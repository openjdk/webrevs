{"files":[{"patch":"@@ -27,4 +27,3 @@\n-import jdk.jpackage.internal.model.LinuxPackage;\n-import jdk.jpackage.internal.model.LinuxLauncher;\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.Launcher;\n+import static jdk.jpackage.internal.ApplicationImageUtils.createLauncherIconResource;\n+import static jdk.jpackage.internal.model.LauncherShortcut.toRequest;\n+\n@@ -48,1 +47,0 @@\n-import static jdk.jpackage.internal.ApplicationImageUtils.createLauncherIconResource;\n@@ -50,0 +48,4 @@\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LinuxLauncher;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.Package;\n@@ -53,1 +55,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -68,1 +69,1 @@\n-    private DesktopIntegration(BuildEnv env, LinuxPackage pkg, LinuxLauncher launcher) throws IOException {\n+    private DesktopIntegration(BuildEnv env, LinuxPackage pkg, LinuxLauncher launcher) {\n@@ -80,4 +81,1 @@\n-        boolean withDesktopFile = !associations.isEmpty() || launcher.shortcut().orElse(false);\n-\n-        var curIconResource = createLauncherIconResource(pkg.app(), launcher,\n-                env::createResource);\n+        boolean withDesktopFile = !associations.isEmpty() || toRequest(launcher.shortcut()).orElse(false);\n@@ -85,1 +83,1 @@\n-        if (curIconResource.isEmpty()) {\n+        if (!launcher.hasIcon()) {\n@@ -88,6 +86,3 @@\n-        } else {\n-            final Path nullPath = null;\n-            if (curIconResource.get().saveToFile(nullPath) != OverridableResource.Source.DefaultResource) {\n-                \/\/ This launcher has custom icon configured.\n-                withDesktopFile = true;\n-            }\n+        } else if (launcher.hasCustomIcon()) {\n+            \/\/ This launcher has custom icon configured.\n+            withDesktopFile = true;\n@@ -115,5 +110,0 @@\n-\n-            if (curIconResource.isEmpty()) {\n-                \/\/ Create default icon.\n-                curIconResource = createLauncherIconResource(pkg.app(), pkg.app().mainLauncher().orElseThrow(), env::createResource);\n-            }\n@@ -125,1 +115,1 @@\n-        iconResource = curIconResource;\n+        iconResource = createLauncherIconResource(launcher, env::createResource);\n@@ -135,2 +125,2 @@\n-                return l.shortcut().orElse(true);\n-            }).map(toFunction(l -> {\n+                return toRequest(l.shortcut()).orElse(true);\n+            }).map(l -> {\n@@ -138,1 +128,1 @@\n-            })).toList();\n+            }).toList();\n@@ -142,1 +132,1 @@\n-    static ShellCustomAction create(BuildEnv env, Package pkg) throws IOException {\n+    static ShellCustomAction create(BuildEnv env, Package pkg) {\n@@ -228,0 +218,3 @@\n+\n+        var installedLayout = pkg.asInstalledPackageApplicationLayout().orElseThrow();\n+\n@@ -235,2 +228,18 @@\n-                pkg.asInstalledPackageApplicationLayout().orElseThrow().launchersDirectory().resolve(\n-                        launcher.executableNameWithSuffix()).toString()));\n+                installedLayout.launchersDirectory().resolve(launcher.executableNameWithSuffix()).toString()));\n+        data.put(\"STARTUP_DIRECTORY\", launcher.shortcut()\n+                .flatMap(LauncherShortcut::startupDirectory)\n+                .map(startupDirectory -> {\n+                    switch (startupDirectory) {\n+                        case DEFAULT -> {\n+                            return (Path)null;\n+                        }\n+                        case APP_DIR -> {\n+                            return installedLayout.appDirectory();\n+                        }\n+                        default -> {\n+                            throw new AssertionError();\n+                        }\n+                    }\n+                }).map(str -> {\n+                    return \"Path=\" + str;\n+                }).orElse(null));\n@@ -337,1 +346,1 @@\n-        var srcPath = pkg.asPackageApplicationLayout().orElseThrow().resolveAt(env.appImageDir()).desktopIntegrationDirectory().resolve(fileName);\n+        var srcPath = env.asApplicationLayout().orElseThrow().desktopIntegrationDirectory().resolve(fileName);\n@@ -484,1 +493,1 @@\n-    private final Launcher launcher;\n+    private final LinuxLauncher launcher;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":41,"deletions":32,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Optional;\n+\n@@ -34,1 +36,1 @@\n-            LinuxPackagingPipeline.build()\n+            LinuxPackagingPipeline.build(Optional.empty())\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppBundler.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -43,2 +44,20 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, libAppLauncher()));\n+        return (LinuxApplicationLayout)ApplicationLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout unresolve() {\n+        return (LinuxApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), libAppLauncher());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, libAppLauncher()));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayout.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayoutMixin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-import jdk.jpackage.internal.model.LinuxPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n-import java.io.IOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n@@ -36,9 +29,0 @@\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-\n-import java.nio.file.attribute.PosixFilePermission;\n-import java.nio.file.attribute.PosixFilePermissions;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n@@ -46,10 +30,5 @@\n-import java.util.Set;\n-import java.util.function.Function;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n@@ -59,4 +38,0 @@\n-    private static final String TOOL_DPKG_DEB = \"dpkg-deb\";\n-    private static final String TOOL_DPKG = \"dpkg\";\n-    private static final String TOOL_FAKEROOT = \"fakeroot\";\n-\n@@ -68,118 +43,2 @@\n-    protected void doValidate(BuildEnv env, LinuxPackage pkg) throws ConfigException {\n-\n-        \/\/ Show warning if license file is missing\n-        if (pkg.licenseFile().isEmpty()) {\n-            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n-        }\n-    }\n-\n-    @Override\n-    protected List<ToolValidator> getToolValidators() {\n-        return Stream.of(TOOL_DPKG_DEB, TOOL_DPKG, TOOL_FAKEROOT).map(\n-                ToolValidator::new).toList();\n-    }\n-\n-    @Override\n-    protected void createConfigFiles(Map<String, String> replacementData,\n-            BuildEnv env, LinuxPackage pkg) throws IOException {\n-        prepareProjectConfig(replacementData, env, pkg);\n-        adjustPermissionsRecursive(env.appImageDir());\n-    }\n-\n-    @Override\n-    protected Path buildPackageBundle(BuildEnv env, LinuxPackage pkg,\n-            Path outputParentDir) throws PackagerException, IOException {\n-        return buildDeb(env, pkg, outputParentDir);\n-    }\n-\n-    private static final Pattern PACKAGE_NAME_REGEX = Pattern.compile(\"^(^\\\\S+):\");\n-\n-    @Override\n-    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n-\n-        libProvidersLookup.setPackageLookup(file -> {\n-            Path realPath = file.toRealPath();\n-\n-            try {\n-                \/\/ Try the real path first as it works better on newer Ubuntu versions\n-                return findProvidingPackages(realPath);\n-            } catch (IOException ex) {\n-                \/\/ Try the default path if differ\n-                if (!realPath.toString().equals(file.toString())) {\n-                    return findProvidingPackages(file);\n-                } else {\n-                    throw ex;\n-                }\n-            }\n-        });\n-    }\n-\n-    private static Stream<String> findProvidingPackages(Path file) throws IOException {\n-        \/\/\n-        \/\/ `dpkg -S` command does glob pattern lookup. If not the absolute path\n-        \/\/ to the file is specified it might return mltiple package names.\n-        \/\/ Even for full paths multiple package names can be returned as\n-        \/\/ it is OK for multiple packages to provide the same file. `\/opt`\n-        \/\/ directory is such an example. So we have to deal with multiple\n-        \/\/ packages per file situation.\n-        \/\/\n-        \/\/ E.g.: `dpkg -S libc.so.6` command reports three packages:\n-        \/\/ libc6-x32: \/libx32\/libc.so.6\n-        \/\/ libc6:amd64: \/lib\/x86_64-linux-gnu\/libc.so.6\n-        \/\/ libc6-i386: \/lib32\/libc.so.6\n-        \/\/ `:amd64` is architecture suffix and can (should) be dropped.\n-        \/\/ Still need to decide what package to choose from three.\n-        \/\/ libc6-x32 and libc6-i386 both depend on libc6:\n-        \/\/ $ dpkg -s libc6-x32\n-        \/\/ Package: libc6-x32\n-        \/\/ Status: install ok installed\n-        \/\/ Priority: optional\n-        \/\/ Section: libs\n-        \/\/ Installed-Size: 10840\n-        \/\/ Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>\n-        \/\/ Architecture: amd64\n-        \/\/ Source: glibc\n-        \/\/ Version: 2.23-0ubuntu10\n-        \/\/ Depends: libc6 (= 2.23-0ubuntu10)\n-        \/\/\n-        \/\/ We can dive into tracking dependencies, but this would be overly\n-        \/\/ complicated.\n-        \/\/\n-        \/\/ For simplicity lets consider the following rules:\n-        \/\/ 1. If there is one item in `dpkg -S` output, accept it.\n-        \/\/ 2. If there are multiple items in `dpkg -S` output and there is at\n-        \/\/  least one item with the default arch suffix (DEB_ARCH),\n-        \/\/  accept only these items.\n-        \/\/ 3. If there are multiple items in `dpkg -S` output and there are\n-        \/\/  no with the default arch suffix (DEB_ARCH), accept all items.\n-        \/\/ So lets use this heuristics: don't accept packages for whom\n-        \/\/  `dpkg -p` command fails.\n-        \/\/ 4. Arch suffix should be stripped from accepted package names.\n-        \/\/\n-\n-        Set<String> archPackages = new HashSet<>();\n-        Set<String> otherPackages = new HashSet<>();\n-\n-        var debArch = LinuxPackageArch.getValue(LINUX_DEB);\n-\n-        Executor.of(TOOL_DPKG, \"-S\", file.toString())\n-                .saveOutput(true).executeExpectSuccess()\n-                .getOutput().forEach(line -> {\n-                    Matcher matcher = PACKAGE_NAME_REGEX.matcher(line);\n-                    if (matcher.find()) {\n-                        String name = matcher.group(1);\n-                        if (name.endsWith(\":\" + debArch)) {\n-                            \/\/ Strip arch suffix\n-                            name = name.substring(0,\n-                                    name.length() - (debArch.length() + 1));\n-                            archPackages.add(name);\n-                        } else {\n-                            otherPackages.add(name);\n-                        }\n-                    }\n-                });\n-\n-        if (!archPackages.isEmpty()) {\n-            return archPackages.stream();\n-        }\n-        return otherPackages.stream();\n+    public String getName() {\n+        return I18N.getString(\"deb.bundler.name\");\n@@ -189,151 +48,2 @@\n-    protected List<ConfigException> verifyOutputBundle(BuildEnv env, LinuxPackage pkg,\n-            Path packageBundle) {\n-        List<ConfigException> errors = new ArrayList<>();\n-\n-        String controlFileName = \"control\";\n-\n-        List<PackageProperty> properties = List.of(\n-                new PackageProperty(\"Package\", pkg.packageName(),\n-                        \"APPLICATION_PACKAGE\", controlFileName),\n-                new PackageProperty(\"Version\", ((LinuxDebPackage)pkg).versionWithRelease(),\n-                        \"APPLICATION_VERSION_WITH_RELEASE\",\n-                        controlFileName),\n-                new PackageProperty(\"Architecture\", pkg.arch(), \"APPLICATION_ARCH\", controlFileName));\n-\n-        List<String> cmdline = new ArrayList<>(List.of(TOOL_DPKG_DEB, \"-f\",\n-                packageBundle.toString()));\n-        properties.forEach(property -> cmdline.add(property.name));\n-        try {\n-            Map<String, String> actualValues = Executor.of(cmdline.toArray(String[]::new))\n-                    .saveOutput(true)\n-                    .executeExpectSuccess()\n-                    .getOutput().stream()\n-                            .map(line -> line.split(\":\\\\s+\", 2))\n-                            .collect(Collectors.toMap(\n-                                    components -> components[0],\n-                                    components -> components[1]));\n-            properties.forEach(property -> errors.add(property.verifyValue(\n-                    actualValues.get(property.name))));\n-        } catch (IOException ex) {\n-            \/\/ Ignore error as it is not critical. Just report it.\n-            Log.verbose(ex);\n-        }\n-\n-        return errors;\n-    }\n-\n-    \/*\n-     * set permissions with a string like \"rwxr-xr-x\"\n-     *\n-     * This cannot be directly backport to 22u which is built with 1.6\n-     *\/\n-    private void setPermissions(Path file, String permissions) {\n-        Set<PosixFilePermission> filePermissions =\n-                PosixFilePermissions.fromString(permissions);\n-        try {\n-            if (Files.exists(file)) {\n-                Files.setPosixFilePermissions(file, filePermissions);\n-            }\n-        } catch (IOException ex) {\n-            Log.error(ex.getMessage());\n-            Log.verbose(ex);\n-        }\n-\n-    }\n-\n-    public static boolean isDebian() {\n-        \/\/ we are just going to run \"dpkg -s coreutils\" and assume Debian\n-        \/\/ or deritive if no error is returned.\n-        try {\n-            Executor.of(TOOL_DPKG, \"-s\", \"coreutils\").executeExpectSuccess();\n-            return true;\n-        } catch (IOException e) {\n-            \/\/ just fall thru\n-        }\n-        return false;\n-    }\n-\n-    private void adjustPermissionsRecursive(Path dir) throws IOException {\n-        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult visitFile(Path file,\n-                    BasicFileAttributes attrs)\n-                    throws IOException {\n-                if (file.endsWith(\".so\") || !Files.isExecutable(file)) {\n-                    setPermissions(file, \"rw-r--r--\");\n-                } else if (Files.isExecutable(file)) {\n-                    setPermissions(file, \"rwxr-xr-x\");\n-                }\n-                return FileVisitResult.CONTINUE;\n-            }\n-\n-            @Override\n-            public FileVisitResult postVisitDirectory(Path dir, IOException e)\n-                    throws IOException {\n-                if (e == null) {\n-                    setPermissions(dir, \"rwxr-xr-x\");\n-                    return FileVisitResult.CONTINUE;\n-                } else {\n-                    \/\/ directory iteration failed\n-                    throw e;\n-                }\n-            }\n-        });\n-    }\n-\n-    private class DebianFile {\n-\n-        DebianFile(Path dstFilePath, String comment) {\n-            this.dstFilePath = dstFilePath;\n-            this.comment = comment;\n-        }\n-\n-        DebianFile setExecutable() {\n-            permissions = \"rwxr-xr-x\";\n-            return this;\n-        }\n-\n-        void create(Map<String, String> data, Function<String, OverridableResource> resourceFactory)\n-                throws IOException {\n-            resourceFactory.apply(\"template.\" + dstFilePath.getFileName().toString())\n-                    .setCategory(I18N.getString(comment))\n-                    .setSubstitutionData(data)\n-                    .saveToFile(dstFilePath);\n-            if (permissions != null) {\n-                setPermissions(dstFilePath, permissions);\n-            }\n-        }\n-\n-        private final Path dstFilePath;\n-        private final String comment;\n-        private String permissions;\n-    }\n-\n-    private void prepareProjectConfig(Map<String, String> data, BuildEnv env, LinuxPackage pkg) throws IOException {\n-\n-        Path configDir = env.appImageDir().resolve(\"DEBIAN\");\n-        List<DebianFile> debianFiles = new ArrayList<>();\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"control\"),\n-                \"resource.deb-control-file\"));\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"preinst\"),\n-                \"resource.deb-preinstall-script\").setExecutable());\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"prerm\"),\n-                \"resource.deb-prerm-script\").setExecutable());\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"postinst\"),\n-                \"resource.deb-postinstall-script\").setExecutable());\n-        debianFiles.add(new DebianFile(\n-                configDir.resolve(\"postrm\"),\n-                \"resource.deb-postrm-script\").setExecutable());\n-\n-        ((LinuxDebPackage)pkg).relativeCopyrightFilePath().ifPresent(copyrightFile -> {\n-            debianFiles.add(new DebianFile(env.appImageDir().resolve(copyrightFile),\n-                    \"resource.copyright-file\"));\n-        });\n-\n-        for (DebianFile debianFile : debianFiles) {\n-            debianFile.create(data, env::createResource);\n-        }\n+    public String getID() {\n+        return \"deb\";\n@@ -343,2 +53,1 @@\n-    protected Map<String, String> createReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n+    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n@@ -346,1 +55,1 @@\n-        String licenseText = pkg.licenseFile().map(toFunction(Files::readString)).orElse(\"Unknown\");\n+        var pkg = LinuxFromParams.DEB_PACKAGE.fetchFrom(params);\n@@ -348,40 +57,6 @@\n-        data.put(\"APPLICATION_MAINTAINER\", ((LinuxDebPackage) pkg).maintainer());\n-        data.put(\"APPLICATION_SECTION\", pkg.category().orElseThrow());\n-        data.put(\"APPLICATION_COPYRIGHT\", pkg.app().copyright());\n-        data.put(\"APPLICATION_LICENSE_TEXT\", licenseText);\n-        data.put(\"APPLICATION_ARCH\", pkg.arch());\n-        data.put(\"APPLICATION_INSTALLED_SIZE\", Long.toString(\n-                AppImageLayout.toPathGroup(pkg.packageLayout().resolveAt(\n-                        env.appImageDir())).sizeInBytes() >> 10));\n-        data.put(\"APPLICATION_HOMEPAGE\", pkg.aboutURL().map(\n-                value -> \"Homepage: \" + value).orElse(\"\"));\n-        data.put(\"APPLICATION_VERSION_WITH_RELEASE\", ((LinuxDebPackage) pkg).versionWithRelease());\n-\n-        return data;\n-    }\n-\n-    private Path buildDeb(BuildEnv env, LinuxPackage pkg, Path outdir) throws IOException {\n-        Path outFile = outdir.resolve(pkg.packageFileNameWithSuffix());\n-        Log.verbose(I18N.format(\"message.outputting-to-location\", outFile.toAbsolutePath()));\n-\n-        List<String> cmdline = new ArrayList<>();\n-        cmdline.addAll(List.of(TOOL_FAKEROOT, TOOL_DPKG_DEB));\n-        if (Log.isVerbose()) {\n-            cmdline.add(\"--verbose\");\n-        }\n-        cmdline.addAll(List.of(\"-b\", env.appImageDir().toString(),\n-                outFile.toAbsolutePath().toString()));\n-\n-        \/\/ run dpkg\n-        RetryExecutor.retryOnKnownErrorMessage(\n-                \"semop(1): encountered an error: Invalid argument\").execute(\n-                        cmdline.toArray(String[]::new));\n-\n-        Log.verbose(I18N.format(\"message.output-to-location\", outFile.toAbsolutePath()));\n-\n-        return outFile;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"deb.bundler.name\");\n+        return Packager.<LinuxDebPackage>build().outputDir(outputParentDir)\n+                .pkg(pkg)\n+                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n+                    return new LinuxDebPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(LinuxPackagingPipeline.build(Optional.of(pkg)));\n@@ -391,7 +66,2 @@\n-    public String getID() {\n-        return \"deb\";\n-    }\n-\n-    @Override\n-    public boolean supported(boolean runtimeInstaller) {\n-        return OperatingSystem.isLinux() && (new ToolValidator(TOOL_DPKG_DEB).validate() == null);\n+    protected Result<LinuxDebSystemEnvironment> sysEnv() {\n+        return sysEnv;\n@@ -402,1 +72,4 @@\n-        return isDebian();\n+        return sysEnv.value()\n+                .map(LinuxSystemEnvironment::nativePackageType)\n+                .map(StandardPackageType.LINUX_DEB::equals)\n+                .orElse(false);\n@@ -404,0 +77,2 @@\n+\n+    private final Result<LinuxDebSystemEnvironment> sysEnv = LinuxDebSystemEnvironment.create(SYS_ENV);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":25,"deletions":350,"binary":false,"changes":375,"status":"modified"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+\n+final class LinuxDebPackager extends LinuxPackager<LinuxDebPackage> {\n+\n+    LinuxDebPackager(BuildEnv env, LinuxDebPackage pkg, Path outputDir, LinuxDebSystemEnvironment sysEnv) {\n+        super(env, pkg, outputDir, sysEnv);\n+        this.sysEnv = Objects.requireNonNull(sysEnv);\n+    }\n+\n+    @Override\n+    protected void createConfigFiles(Map<String, String> replacementData) throws IOException {\n+        prepareProjectConfig(replacementData);\n+        adjustPermissionsRecursive();\n+    }\n+\n+    @Override\n+    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n+\n+        libProvidersLookup.setPackageLookup(file -> {\n+            Path realPath = file.toRealPath();\n+\n+            try {\n+                \/\/ Try the real path first as it works better on newer Ubuntu versions\n+                return findProvidingPackages(realPath, sysEnv.dpkg());\n+            } catch (IOException ex) {\n+                \/\/ Try the default path if differ\n+                if (!realPath.equals(file)) {\n+                    return findProvidingPackages(file, sysEnv.dpkg());\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected List<? extends Exception> findErrorsInOutputPackage() throws IOException {\n+        List<ConfigException> errors = new ArrayList<>();\n+\n+        var controlFileName = \"control\";\n+\n+        List<PackageProperty> properties = List.of(\n+                new PackageProperty(\"Package\", pkg.packageName(),\n+                        \"APPLICATION_PACKAGE\", controlFileName),\n+                new PackageProperty(\"Version\", pkg.versionWithRelease(),\n+                        \"APPLICATION_VERSION_WITH_RELEASE\",\n+                        controlFileName),\n+                new PackageProperty(\"Architecture\", pkg.arch(), \"APPLICATION_ARCH\", controlFileName));\n+\n+        List<String> cmdline = new ArrayList<>(List.of(\n+                sysEnv.dpkgdeb().toString(), \"-f\", outputPackageFile().toString()));\n+\n+        properties.forEach(property -> cmdline.add(property.name));\n+\n+        Map<String, String> actualValues = Executor.of(cmdline.toArray(String[]::new))\n+                .saveOutput(true)\n+                .executeExpectSuccess()\n+                .getOutput().stream()\n+                        .map(line -> line.split(\":\\\\s+\", 2))\n+                        .collect(Collectors.toMap(\n+                                components -> components[0],\n+                                components -> components[1]));\n+\n+        for (var property : properties) {\n+            Optional.ofNullable(property.verifyValue(actualValues.get(property.name))).ifPresent(errors::add);\n+        }\n+\n+        return errors;\n+    }\n+\n+    @Override\n+    protected Map<String, String> createReplacementData() throws IOException {\n+        Map<String, String> data = new HashMap<>();\n+\n+        String licenseText = pkg.licenseFile().map(toFunction(Files::readString)).orElse(\"Unknown\");\n+\n+        data.put(\"APPLICATION_MAINTAINER\", pkg.maintainer());\n+        data.put(\"APPLICATION_SECTION\", pkg.category().orElseThrow());\n+        data.put(\"APPLICATION_COPYRIGHT\", pkg.app().copyright());\n+        data.put(\"APPLICATION_LICENSE_TEXT\", licenseText);\n+        data.put(\"APPLICATION_ARCH\", pkg.arch());\n+        data.put(\"APPLICATION_INSTALLED_SIZE\", Long.toString(\n+                AppImageLayout.toPathGroup(env.appImageLayout()).sizeInBytes() >> 10));\n+        data.put(\"APPLICATION_HOMEPAGE\", pkg.aboutURL().map(\n+                value -> \"Homepage: \" + value).orElse(\"\"));\n+        data.put(\"APPLICATION_VERSION_WITH_RELEASE\", pkg.versionWithRelease());\n+\n+        return data;\n+    }\n+\n+    @Override\n+    protected void buildPackage() throws IOException {\n+\n+        Path debFile = outputPackageFile();\n+\n+        Log.verbose(I18N.format(\"message.outputting-to-location\", debFile.toAbsolutePath()));\n+\n+        List<String> cmdline = new ArrayList<>();\n+        Stream.of(sysEnv.fakeroot(), sysEnv.dpkgdeb()).map(Path::toString).forEach(cmdline::add);\n+        if (Log.isVerbose()) {\n+            cmdline.add(\"--verbose\");\n+        }\n+        cmdline.addAll(List.of(\"-b\", env.appImageDir().toString(), debFile.toAbsolutePath().toString()));\n+\n+        \/\/ run dpkg\n+        RetryExecutor.retryOnKnownErrorMessage(\n+                \"semop(1): encountered an error: Invalid argument\").execute(\n+                        cmdline.toArray(String[]::new));\n+\n+        Log.verbose(I18N.format(\"message.output-to-location\", debFile.toAbsolutePath()));\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        super.accept(pipelineBuilder);\n+\n+        \/\/ Build deb config files after app image contents are ready because\n+        \/\/ it calculates the size of the image and saves the value in one of the config files.\n+        pipelineBuilder.configuredTasks().filter(task -> {\n+            return PackageTaskID.CREATE_CONFIG_FILES.equals(task.task());\n+        }).findFirst().orElseThrow()\n+                .addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE)\n+                .add();\n+    }\n+\n+    private void adjustPermissionsRecursive() throws IOException {\n+        Files.walkFileTree(env.appImageDir(), new SimpleFileVisitor<Path>() {\n+            @Override\n+            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                if (file.endsWith(\".so\") || !Files.isExecutable(file)) {\n+                    Files.setPosixFilePermissions(file, SO_PERMISSIONS);\n+                } else if (Files.isExecutable(file)) {\n+                    Files.setPosixFilePermissions(file, EXECUTABLE_PERMISSIONS);\n+                }\n+                return FileVisitResult.CONTINUE;\n+            }\n+\n+            @Override\n+            public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {\n+                if (e == null) {\n+                    Files.setPosixFilePermissions(dir, FOLDER_PERMISSIONS);\n+                    return FileVisitResult.CONTINUE;\n+                } else {\n+                    \/\/ directory iteration failed\n+                    throw e;\n+                }\n+            }\n+        });\n+    }\n+\n+    private void prepareProjectConfig(Map<String, String> data) throws IOException {\n+\n+        Path configDir = env.appImageDir().resolve(\"DEBIAN\");\n+        List<DebianFile> debianFiles = new ArrayList<>();\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"control\"),\n+                \"resource.deb-control-file\"));\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"preinst\"),\n+                \"resource.deb-preinstall-script\").setExecutable());\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"prerm\"),\n+                \"resource.deb-prerm-script\").setExecutable());\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"postinst\"),\n+                \"resource.deb-postinstall-script\").setExecutable());\n+        debianFiles.add(new DebianFile(\n+                configDir.resolve(\"postrm\"),\n+                \"resource.deb-postrm-script\").setExecutable());\n+\n+        pkg.relativeCopyrightFilePath().ifPresent(copyrightFile -> {\n+            debianFiles.add(new DebianFile(env.appImageDir().resolve(copyrightFile),\n+                    \"resource.copyright-file\"));\n+        });\n+\n+        for (DebianFile debianFile : debianFiles) {\n+            debianFile.create(data, env::createResource);\n+        }\n+    }\n+\n+    private static Stream<String> findProvidingPackages(Path file, Path dpkg) throws IOException {\n+        \/\/\n+        \/\/ `dpkg -S` command does glob pattern lookup. If not the absolute path\n+        \/\/ to the file is specified it might return mltiple package names.\n+        \/\/ Even for full paths multiple package names can be returned as\n+        \/\/ it is OK for multiple packages to provide the same file. `\/opt`\n+        \/\/ directory is such an example. So we have to deal with multiple\n+        \/\/ packages per file situation.\n+        \/\/\n+        \/\/ E.g.: `dpkg -S libc.so.6` command reports three packages:\n+        \/\/ libc6-x32: \/libx32\/libc.so.6\n+        \/\/ libc6:amd64: \/lib\/x86_64-linux-gnu\/libc.so.6\n+        \/\/ libc6-i386: \/lib32\/libc.so.6\n+        \/\/ `:amd64` is architecture suffix and can (should) be dropped.\n+        \/\/ Still need to decide what package to choose from three.\n+        \/\/ libc6-x32 and libc6-i386 both depend on libc6:\n+        \/\/ $ dpkg -s libc6-x32\n+        \/\/ Package: libc6-x32\n+        \/\/ Status: install ok installed\n+        \/\/ Priority: optional\n+        \/\/ Section: libs\n+        \/\/ Installed-Size: 10840\n+        \/\/ Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>\n+        \/\/ Architecture: amd64\n+        \/\/ Source: glibc\n+        \/\/ Version: 2.23-0ubuntu10\n+        \/\/ Depends: libc6 (= 2.23-0ubuntu10)\n+        \/\/\n+        \/\/ We can dive into tracking dependencies, but this would be overly\n+        \/\/ complicated.\n+        \/\/\n+        \/\/ For simplicity lets consider the following rules:\n+        \/\/ 1. If there is one item in `dpkg -S` output, accept it.\n+        \/\/ 2. If there are multiple items in `dpkg -S` output and there is at\n+        \/\/  least one item with the default arch suffix (DEB_ARCH),\n+        \/\/  accept only these items.\n+        \/\/ 3. If there are multiple items in `dpkg -S` output and there are\n+        \/\/  no with the default arch suffix (DEB_ARCH), accept all items.\n+        \/\/ So lets use this heuristics: don't accept packages for whom\n+        \/\/  `dpkg -p` command fails.\n+        \/\/ 4. Arch suffix should be stripped from accepted package names.\n+        \/\/\n+\n+        Set<String> archPackages = new HashSet<>();\n+        Set<String> otherPackages = new HashSet<>();\n+\n+        var debArch = LinuxPackageArch.getValue(LINUX_DEB);\n+\n+        Executor.of(dpkg.toString(), \"-S\", file.toString())\n+                .saveOutput(true).executeExpectSuccess()\n+                .getOutput().forEach(line -> {\n+                    Matcher matcher = PACKAGE_NAME_REGEX.matcher(line);\n+                    if (matcher.find()) {\n+                        String name = matcher.group(1);\n+                        if (name.endsWith(\":\" + debArch)) {\n+                            \/\/ Strip arch suffix\n+                            name = name.substring(0,\n+                                    name.length() - (debArch.length() + 1));\n+                            archPackages.add(name);\n+                        } else {\n+                            otherPackages.add(name);\n+                        }\n+                    }\n+                });\n+\n+        if (!archPackages.isEmpty()) {\n+            return archPackages.stream();\n+        }\n+        return otherPackages.stream();\n+    }\n+\n+\n+    private static final class DebianFile {\n+\n+        DebianFile(Path dstFilePath, String comment) {\n+            this.dstFilePath = Objects.requireNonNull(dstFilePath);\n+            this.comment = Objects.requireNonNull(comment);\n+        }\n+\n+        DebianFile setExecutable() {\n+            permissions = EXECUTABLE_PERMISSIONS;\n+            return this;\n+        }\n+\n+        void create(Map<String, String> data, Function<String, OverridableResource> resourceFactory)\n+                throws IOException {\n+            resourceFactory.apply(\"template.\" + dstFilePath.getFileName().toString())\n+                    .setCategory(I18N.getString(comment))\n+                    .setSubstitutionData(data)\n+                    .saveToFile(dstFilePath);\n+            if (permissions != null) {\n+                Files.setPosixFilePermissions(dstFilePath, permissions);\n+            }\n+        }\n+\n+        private final Path dstFilePath;\n+        private final String comment;\n+        private Set<PosixFilePermission> permissions;\n+    }\n+\n+\n+    private final LinuxDebSystemEnvironment sysEnv;\n+\n+    private static final Pattern PACKAGE_NAME_REGEX = Pattern.compile(\"^(^\\\\S+):\");\n+\n+    private static final Set<PosixFilePermission> EXECUTABLE_PERMISSIONS = PosixFilePermissions.fromString(\"rwxr-xr-x\");\n+    private static final Set<PosixFilePermission> FOLDER_PERMISSIONS = PosixFilePermissions.fromString(\"rwxr-xr-x\");\n+    private static final Set<PosixFilePermission> SO_PERMISSIONS = PosixFilePermissions.fromString(\"rw-r--r--\");\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebPackager.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.LinuxSystemEnvironment.mixin;\n+\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxDebSystemEnvironment extends LinuxSystemEnvironment, LinuxDebSystemEnvironmentMixin {\n+\n+    static Result<LinuxDebSystemEnvironment> create(Result<LinuxSystemEnvironment> base) {\n+        return mixin(LinuxDebSystemEnvironment.class, base, LinuxDebSystemEnvironmentMixin::create);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironment.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxDebSystemEnvironmentMixin {\n+    Path dpkg();\n+    Path dpkgdeb();\n+    Path fakeroot();\n+\n+    record Stub(Path dpkg, Path dpkgdeb, Path fakeroot) implements LinuxDebSystemEnvironmentMixin {\n+    }\n+\n+    static Result<LinuxDebSystemEnvironmentMixin> create() {\n+        final var errors = Stream.of(Internal.TOOL_DPKG_DEB, Internal.TOOL_DPKG, Internal.TOOL_FAKEROOT)\n+                .map(ToolValidator::new)\n+                .map(ToolValidator::validate)\n+                .filter(Objects::nonNull)\n+                .toList();\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(new Stub(Internal.TOOL_DPKG, Internal.TOOL_DPKG_DEB, Internal.TOOL_FAKEROOT));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    static final class Internal {\n+\n+        private static final Path TOOL_DPKG_DEB = Path.of(\"dpkg-deb\");\n+        private static final Path TOOL_DPKG = Path.of(\"dpkg\");\n+        private static final Path TOOL_FAKEROOT = Path.of(\"fakeroot\");\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebSystemEnvironmentMixin.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n@@ -33,1 +34,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -40,2 +40,0 @@\n-import java.util.Optional;\n-import java.util.stream.Stream;\n@@ -44,0 +42,1 @@\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n@@ -46,1 +45,2 @@\n-import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n+import jdk.jpackage.internal.model.Launcher;\n@@ -54,0 +54,1 @@\n+\n@@ -56,3 +57,1 @@\n-            final var shortcut = Stream.of(SHORTCUT_HINT, LINUX_SHORTCUT_HINT).map(param -> {\n-                return param.findIn(launcherParams);\n-            }).filter(Optional::isPresent).map(Optional::get).findFirst();\n+            final var shortcut = findLauncherShortcut(LINUX_SHORTCUT_HINT, params, launcherParams);\n@@ -60,1 +59,3 @@\n-        }), APPLICATION_LAYOUT).create();\n+        }), (LinuxLauncher linuxLauncher, Launcher launcher) -> {\n+            return LinuxLauncher.create(launcher, linuxLauncher);\n+        }, APPLICATION_LAYOUT).create();\n@@ -82,1 +83,1 @@\n-    private static LinuxPackage createLinuxRpmPackage(\n+    private static LinuxRpmPackage createLinuxRpmPackage(\n@@ -94,1 +95,1 @@\n-    private static LinuxPackage createLinuxDebPackage(\n+    private static LinuxDebPackage createLinuxDebPackage(\n@@ -103,1 +104,8 @@\n-        return pkgBuilder.create();\n+        final var pkg = pkgBuilder.create();\n+\n+        \/\/ Show warning if license file is missing\n+        if (pkg.licenseFile().isEmpty()) {\n+            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n+        }\n+\n+        return pkg;\n@@ -109,1 +117,1 @@\n-    static final BundlerParamInfo<LinuxPackage> RPM_PACKAGE = createPackageBundlerParam(\n+    static final BundlerParamInfo<LinuxRpmPackage> RPM_PACKAGE = createPackageBundlerParam(\n@@ -112,1 +120,1 @@\n-    static final BundlerParamInfo<LinuxPackage> DEB_PACKAGE = createPackageBundlerParam(\n+    static final BundlerParamInfo<LinuxDebPackage> DEB_PACKAGE = createPackageBundlerParam(\n@@ -115,6 +123,2 @@\n-    private static final BundlerParamInfo<Boolean> LINUX_SHORTCUT_HINT = new BundlerParamInfo<>(\n-            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n-            Boolean.class,\n-            params -> false,\n-            (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ? false : Boolean.valueOf(s)\n-    );\n+    private static final BundlerParamInfo<String> LINUX_SHORTCUT_HINT = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId());\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    private LinuxLaunchersAsServices(BuildEnv env, Package pkg) throws IOException {\n+    private LinuxLaunchersAsServices(BuildEnv env, Package pkg) {\n@@ -61,1 +61,1 @@\n-    static ShellCustomAction create(BuildEnv env, Package pkg) throws IOException {\n+    static ShellCustomAction create(BuildEnv env, Package pkg) {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxLaunchersAsServices.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.jpackage.internal.model.LinuxApplication;\n@@ -37,0 +38,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -55,1 +57,1 @@\n-        final var pkg = pkgBuilder.create();\n+        final var tmpPkg = pkgBuilder.create();\n@@ -57,1 +59,1 @@\n-        final var stdPkgType = pkg.asStandardPackageType();\n+        final var stdPkgType = tmpPkg.asStandardPackageType();\n@@ -59,1 +61,1 @@\n-            validatePackageName(pkg.packageName(), stdPkgType.orElseThrow());\n+            validatePackageName(tmpPkg.packageName(), stdPkgType.orElseThrow());\n@@ -62,3 +64,10 @@\n-        var reply = create(pkg, pkg.packageLayout());\n-        if (reply.isInstallDirInUsrTree()) {\n-            reply = create(pkg, usrTreePackageLayout(pkg.relativeInstallDir(), pkg.packageName()));\n+        final AppImageLayout relativeInstalledLayout;\n+        if (create(tmpPkg).isInstallDirInUsrTree()) {\n+            final var usrTreeLayout = usrTreePackageLayout(tmpPkg.relativeInstallDir(), tmpPkg.packageName());\n+            if (tmpPkg.isRuntimeInstaller()) {\n+                relativeInstalledLayout = RuntimeLayout.create(usrTreeLayout.runtimeDirectory());\n+            } else {\n+                relativeInstalledLayout = usrTreeLayout;\n+            }\n+        } else {\n+            relativeInstalledLayout = tmpPkg.appImageLayout().resolveAt(tmpPkg.relativeInstallDir()).resetRootDirectory();\n@@ -67,1 +76,6 @@\n-        return reply;\n+        final var app = ApplicationBuilder.overrideAppImageLayout(pkgBuilder.app(), relativeInstalledLayout);\n+\n+        return create(pkgBuilder\n+                .app(LinuxApplication.create(app))\n+                .installedPackageLayout(relativeInstalledLayout.resolveAt(Path.of(\"\/\")).resetRootDirectory())\n+                .create());\n@@ -70,1 +84,1 @@\n-    private LinuxPackage create(Package pkg, AppImageLayout pkgLayout) throws ConfigException {\n+    private LinuxPackage create(Package pkg) throws ConfigException {\n@@ -72,1 +86,0 @@\n-                pkgLayout,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBuilder.java","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -27,6 +27,0 @@\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n@@ -35,6 +29,0 @@\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.PackagingPipeline.PackageBuildEnv;\n-import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n-import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n-import jdk.jpackage.internal.model.AppImageLayout;\n@@ -42,1 +30,0 @@\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n@@ -44,2 +31,1 @@\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.util.Result;\n@@ -50,4 +36,1 @@\n-        this.pkgParam = pkgParam;\n-        customActions = List.of(new CustomActionInstance(\n-                DesktopIntegration::create), new CustomActionInstance(\n-                LinuxLaunchersAsServices::create));\n+        this.pkgParam = Objects.requireNonNull(pkgParam);\n@@ -61,8 +44,8 @@\n-        LinuxPackage pkg = pkgParam.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        for (var validator: getToolValidators()) {\n-            ConfigException ex = validator.validate();\n-            if (ex != null) {\n-                throw ex;\n-            }\n+        pkgParam.fetchFrom(params);\n+        BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+\n+        LinuxSystemEnvironment sysEnv;\n+        try {\n+            sysEnv = sysEnv().orElseThrow();\n+        } catch (RuntimeException ex) {\n+            throw ConfigException.rethrowConfigException(ex);\n@@ -72,3 +55,2 @@\n-            withFindNeededPackages = false;\n-            Log.verbose(MessageFormat.format(I18N.getString(\n-                    \"message.not-default-bundler-no-dependencies-lookup\"),\n+            Log.verbose(I18N.format(\n+                    \"message.not-default-bundler-no-dependencies-lookup\",\n@@ -76,12 +58,6 @@\n-        } else {\n-            withFindNeededPackages = LibProvidersLookup.supported();\n-            if (!withFindNeededPackages) {\n-                final String advice;\n-                if (\"deb\".equals(getID())) {\n-                    advice = \"message.deb-ldd-not-available.advice\";\n-                } else {\n-                    advice = \"message.rpm-ldd-not-available.advice\";\n-                }\n-                \/\/ Let user know package dependencies will not be generated.\n-                Log.error(String.format(\"%s\\n%s\", I18N.getString(\n-                        \"message.ldd-not-available\"), I18N.getString(advice)));\n+        } else if (!sysEnv.soLookupAvailable()) {\n+            final String advice;\n+            if (\"deb\".equals(getID())) {\n+                advice = \"message.deb-ldd-not-available.advice\";\n+            } else {\n+                advice = \"message.rpm-ldd-not-available.advice\";\n@@ -89,0 +65,3 @@\n+            \/\/ Let user know package dependencies will not be generated.\n+            Log.error(String.format(\"%s\\n%s\", I18N.getString(\n+                    \"message.ldd-not-available\"), I18N.getString(advice)));\n@@ -91,3 +70,0 @@\n-        \/\/ Packaging specific validation\n-        doValidate(env, pkg);\n-\n@@ -103,103 +79,2 @@\n-    public final Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-        IOUtils.writableOutputDir(outputParentDir);\n-\n-        \/\/ Order is important!\n-        final LinuxPackage pkg = pkgParam.fetchFrom(params);\n-        final var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        final var pipelineBuilder = LinuxPackagingPipeline.build()\n-                .excludeDirFromCopying(outputParentDir)\n-                .task(PackageTaskID.CREATE_PACKAGE_FILE)\n-                        .packageAction(this::buildPackage)\n-                        .add();\n-\n-        final var createConfigFilesTaskBuilder = pipelineBuilder\n-                .task(PackageTaskID.CREATE_CONFIG_FILES)\n-                .packageAction(this::buildConfigFiles);\n-\n-        if (pkg instanceof LinuxDebPackage) {\n-            \/\/ Build deb config files after app image contents are ready because\n-            \/\/ it calculates the size of the image and saves the value in one of the config files.\n-            createConfigFilesTaskBuilder.addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE);\n-        }\n-\n-        createConfigFilesTaskBuilder.add();\n-\n-        pipelineBuilder.create().execute(env, pkg, outputParentDir);\n-\n-        return outputParentDir.resolve(pkg.packageFileNameWithSuffix()).toAbsolutePath();\n-    }\n-\n-    private void buildConfigFiles(PackageBuildEnv<LinuxPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        for (var ca : customActions) {\n-            ca.init(env.env(), env.pkg());\n-        }\n-\n-        Map<String, String> data = createDefaultReplacementData(env.env(), env.pkg());\n-\n-        for (var ca : customActions) {\n-            ShellCustomAction.mergeReplacementData(data, ca.instance.create());\n-        }\n-\n-        data.putAll(createReplacementData(env.env(), env.pkg()));\n-\n-        createConfigFiles(Collections.unmodifiableMap(data), env.env(), env.pkg());\n-    }\n-\n-    private void buildPackage(PackageBuildEnv<LinuxPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        Path packageBundle = buildPackageBundle(env.env(), env.pkg(), env.outputDir());\n-\n-        verifyOutputBundle(env.env(), env.pkg(), packageBundle).stream()\n-                .filter(Objects::nonNull)\n-                .forEachOrdered(ex -> {\n-            Log.verbose(ex.getLocalizedMessage());\n-            Log.verbose(ex.getAdvice());\n-        });\n-    }\n-\n-    private List<String> getListOfNeededPackages(BuildEnv env) throws IOException {\n-\n-        final List<String> caPackages = customActions.stream()\n-                .map(ca -> ca.instance)\n-                .map(ShellCustomAction::requiredPackages)\n-                .flatMap(List::stream).toList();\n-\n-        final List<String> neededLibPackages;\n-        if (withFindNeededPackages) {\n-            LibProvidersLookup lookup = new LibProvidersLookup();\n-            initLibProvidersLookup(lookup);\n-\n-            neededLibPackages = lookup.execute(env.appImageDir());\n-        } else {\n-            neededLibPackages = Collections.emptyList();\n-            Log.info(I18N.getString(\"warning.foreign-app-image\"));\n-        }\n-\n-        \/\/ Merge all package lists together.\n-        \/\/ Filter out empty names, sort and remove duplicates.\n-        List<String> result = Stream.of(caPackages, neededLibPackages).flatMap(\n-                List::stream).filter(Predicate.not(String::isEmpty)).sorted().distinct().toList();\n-\n-        Log.verbose(String.format(\"Required packages: %s\", result));\n-\n-        return result;\n-    }\n-\n-    private Map<String, String> createDefaultReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        data.put(\"APPLICATION_PACKAGE\", pkg.packageName());\n-        data.put(\"APPLICATION_VENDOR\", pkg.app().vendor());\n-        data.put(\"APPLICATION_VERSION\", pkg.version());\n-        data.put(\"APPLICATION_DESCRIPTION\", pkg.description());\n-\n-        String defaultDeps = String.join(\", \", getListOfNeededPackages(env));\n-        String customDeps = pkg.additionalDependencies().orElse(\"\");\n-        if (!customDeps.isEmpty() && !defaultDeps.isEmpty()) {\n-            customDeps = \", \" + customDeps;\n-        }\n-        data.put(\"PACKAGE_DEFAULT_DEPENDENCIES\", defaultDeps);\n-        data.put(\"PACKAGE_CUSTOM_DEPENDENCIES\", customDeps);\n-\n-        return data;\n+    public boolean supported(boolean runtimeInstaller) {\n+        return sysEnv().hasValue();\n@@ -208,20 +83,1 @@\n-    protected abstract List<ConfigException> verifyOutputBundle(\n-            BuildEnv env, LinuxPackage pkg, Path packageBundle);\n-\n-    protected abstract void initLibProvidersLookup(LibProvidersLookup libProvidersLookup);\n-\n-    protected abstract List<ToolValidator> getToolValidators();\n-\n-    protected abstract void doValidate(BuildEnv env, LinuxPackage pkg)\n-            throws ConfigException;\n-\n-    protected abstract Map<String, String> createReplacementData(\n-            BuildEnv env, LinuxPackage pkg) throws IOException;\n-\n-    protected abstract void createConfigFiles(\n-            Map<String, String> replacementData,\n-            BuildEnv env, LinuxPackage pkg) throws IOException;\n-\n-    protected abstract Path buildPackageBundle(\n-            BuildEnv env, LinuxPackage pkg, Path outputParentDir) throws\n-            PackagerException, IOException;\n+    protected abstract Result<? extends LinuxSystemEnvironment> sysEnv();\n@@ -230,2 +86,0 @@\n-    private boolean withFindNeededPackages;\n-    private final List<CustomActionInstance> customActions;\n@@ -233,14 +87,1 @@\n-    private static final class CustomActionInstance {\n-\n-        CustomActionInstance(ShellCustomActionFactory factory) {\n-            this.factory = factory;\n-        }\n-\n-        void init(BuildEnv env, Package pkg) throws IOException {\n-            instance = factory.create(env, pkg);\n-            Objects.requireNonNull(instance);\n-        }\n-\n-        private final ShellCustomActionFactory factory;\n-        ShellCustomAction instance;\n-    }\n+    static final Result<LinuxSystemEnvironment> SYS_ENV = LinuxSystemEnvironment.create();\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBundler.java","additions":25,"deletions":184,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.PackagerException;\n+\n+abstract class LinuxPackager<T extends LinuxPackage> implements Consumer<PackagingPipeline.Builder> {\n+\n+    LinuxPackager(BuildEnv env, T pkg, Path outputDir, LinuxSystemEnvironment sysEnv) {\n+        this.env = Objects.requireNonNull(env);\n+        this.pkg = Objects.requireNonNull(pkg);\n+        this.outputDir = Objects.requireNonNull(outputDir);\n+        this.withRequiredPackagesLookup = sysEnv.soLookupAvailable() && sysEnv.nativePackageType().equals(pkg.type());\n+\n+        customActions = List.of(\n+                DesktopIntegration.create(env, pkg),\n+                LinuxLaunchersAsServices.create(env, pkg));\n+    }\n+\n+    enum LinuxPackageTaskID implements TaskID {\n+        INIT_REQUIRED_PACKAGES,\n+        VERIFY_PACKAGE\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder.excludeDirFromCopying(outputDir)\n+                .task(PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::buildConfigFiles)\n+                        .add()\n+                .task(LinuxPackageTaskID.INIT_REQUIRED_PACKAGES)\n+                        .addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE)\n+                        .addDependent(PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::initRequiredPackages)\n+                        .add()\n+                .task(LinuxPackageTaskID.VERIFY_PACKAGE)\n+                        .addDependencies(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .addDependent(PrimaryTaskID.PACKAGE)\n+                        .action(this::verifyOutputPackage)\n+                        .add()\n+                .task(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .action(this::buildPackage)\n+                        .add();\n+    }\n+\n+    protected final Path outputPackageFile() {\n+        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n+    }\n+\n+    protected abstract void buildPackage() throws IOException;\n+\n+    protected abstract List<? extends Exception> findErrorsInOutputPackage() throws IOException;\n+\n+    protected abstract void createConfigFiles(Map<String, String> replacementData) throws IOException;\n+\n+    protected abstract Map<String, String> createReplacementData() throws IOException;\n+\n+    protected abstract void initLibProvidersLookup(LibProvidersLookup libProvidersLookup);\n+\n+    private void buildConfigFiles() throws PackagerException, IOException {\n+\n+        final var data = createDefaultReplacementData();\n+\n+        for (var ca : customActions) {\n+            ShellCustomAction.mergeReplacementData(data, ca.create());\n+        }\n+\n+        data.putAll(createReplacementData());\n+\n+        createConfigFiles(Collections.unmodifiableMap(data));\n+    }\n+\n+    private Map<String, String> createDefaultReplacementData() {\n+        Map<String, String> data = new HashMap<>();\n+\n+        data.put(\"APPLICATION_PACKAGE\", pkg.packageName());\n+        data.put(\"APPLICATION_VENDOR\", pkg.app().vendor());\n+        data.put(\"APPLICATION_VERSION\", pkg.version());\n+        data.put(\"APPLICATION_DESCRIPTION\", pkg.description());\n+\n+        String defaultDeps = String.join(\", \", requiredPackages);\n+        String customDeps = pkg.additionalDependencies().orElse(\"\");\n+        if (!customDeps.isEmpty() && !defaultDeps.isEmpty()) {\n+            customDeps = \", \" + customDeps;\n+        }\n+        data.put(\"PACKAGE_DEFAULT_DEPENDENCIES\", defaultDeps);\n+        data.put(\"PACKAGE_CUSTOM_DEPENDENCIES\", customDeps);\n+\n+        return data;\n+    }\n+\n+    private void initRequiredPackages() throws IOException {\n+\n+        final List<String> caPackages = customActions.stream()\n+                .map(ShellCustomAction::requiredPackages)\n+                .flatMap(List::stream).toList();\n+\n+        final List<String> neededLibPackages;\n+        if (withRequiredPackagesLookup) {\n+            neededLibPackages = findRequiredPackages();\n+        } else {\n+            neededLibPackages = Collections.emptyList();\n+            Log.info(I18N.getString(\"warning.foreign-app-image\"));\n+        }\n+\n+        \/\/ Merge all package lists together.\n+        \/\/ Filter out empty names, sort and remove duplicates.\n+        Stream.of(caPackages, neededLibPackages)\n+                .flatMap(List::stream)\n+                .filter(Predicate.not(String::isEmpty))\n+                .sorted().distinct().forEach(requiredPackages::add);\n+\n+        Log.verbose(String.format(\"Required packages: %s\", requiredPackages));\n+    }\n+\n+    private List<String> findRequiredPackages() throws IOException {\n+        var lookup = new LibProvidersLookup();\n+        initLibProvidersLookup(lookup);\n+        return lookup.execute(env.appImageDir());\n+    }\n+\n+    private void verifyOutputPackage() {\n+        final List<? extends Exception> errors;\n+        try {\n+            errors = findErrorsInOutputPackage();\n+        } catch (Exception ex) {\n+            \/\/ Ignore error as it is not critical. Just report it.\n+            Log.verbose(ex);\n+            return;\n+        }\n+\n+        for (var ex : errors) {\n+            Log.verbose(ex.getLocalizedMessage());\n+            if (ex instanceof ConfigException cfgEx) {\n+                Log.verbose(cfgEx.getAdvice());\n+            }\n+        }\n+    }\n+\n+    protected final BuildEnv env;\n+    protected final T pkg;\n+    protected final Path outputDir;\n+    private final boolean withRequiredPackagesLookup;\n+    private final List<String> requiredPackages = new ArrayList<>();\n+    private final List<ShellCustomAction> customActions;\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackager.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.jpackage.internal.PackagingPipeline.AppImageBuildEnv;\n@@ -34,0 +33,2 @@\n+import java.util.Optional;\n+import jdk.jpackage.internal.PackagingPipeline.AppImageBuildEnv;\n@@ -39,0 +40,2 @@\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LinuxPackage;\n@@ -48,2 +51,2 @@\n-    static PackagingPipeline.Builder build() {\n-        return PackagingPipeline.buildStandard()\n+    static PackagingPipeline.Builder build(Optional<LinuxPackage> pkg) {\n+        var builder = PackagingPipeline.buildStandard()\n@@ -56,0 +59,6 @@\n+\n+        pkg.ifPresent(_ -> {\n+            builder.task(LinuxAppImageTaskID.LAUNCHER_ICONS).noaction().add();\n+        });\n+\n+        return builder;\n@@ -71,2 +80,2 @@\n-        for (var launcher : env.app().launchers()) {\n-            createLauncherIconResource(env.app(), launcher, env.env()::createResource).ifPresent(iconResource -> {\n+        env.app().launchers().stream().filter(Launcher::hasCustomIcon).forEach(launcher -> {\n+            createLauncherIconResource(launcher, env.env()::createResource).ifPresent(iconResource -> {\n@@ -81,1 +90,1 @@\n-        }\n+        });\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackagingPipeline.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -30,4 +29,0 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n@@ -35,7 +30,1 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.model.LinuxPackage;\n+import java.util.Optional;\n@@ -43,1 +32,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -45,0 +33,2 @@\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n@@ -47,11 +37,0 @@\n-\/**\n- * There are two command line options to configure license information for RPM\n- * packaging: --linux-rpm-license-type and --license-file. Value of\n- * --linux-rpm-license-type command line option configures \"License:\" section\n- * of RPM spec. Value of --license-file command line option specifies a license\n- * file to be added to the package. License file is a sort of documentation file\n- * but it will be installed even if user selects an option to install the\n- * package without documentation. --linux-rpm-license-type is the primary option\n- * to set license information. --license-file makes little sense in case of RPM\n- * packaging.\n- *\/\n@@ -60,7 +39,0 @@\n-    private static final String DEFAULT_SPEC_TEMPLATE = \"template.spec\";\n-\n-    public static final String TOOL_RPM = \"rpm\";\n-    public static final String TOOL_RPMBUILD = \"rpmbuild\";\n-    public static final DottedVersion TOOL_RPMBUILD_MIN_VERSION = DottedVersion.lazy(\n-            \"4.10\");\n-\n@@ -72,66 +44,2 @@\n-    protected void doValidate(BuildEnv env, LinuxPackage pkg) throws ConfigException {\n-    }\n-\n-    private static ToolValidator createRpmbuildToolValidator() {\n-        Pattern pattern = Pattern.compile(\" (\\\\d+\\\\.\\\\d+)\");\n-        return new ToolValidator(TOOL_RPMBUILD).setMinimalVersion(\n-                TOOL_RPMBUILD_MIN_VERSION).setVersionParser(lines -> {\n-                    String versionString = lines.limit(1).collect(\n-                            Collectors.toList()).get(0);\n-                    Matcher matcher = pattern.matcher(versionString);\n-                    if (matcher.find()) {\n-                        return matcher.group(1);\n-                    }\n-                    return null;\n-                });\n-    }\n-\n-    @Override\n-    protected List<ToolValidator> getToolValidators() {\n-        return List.of(createRpmbuildToolValidator());\n-    }\n-\n-    protected void createConfigFiles(Map<String, String> replacementData,\n-            BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Path specFile = specFile(env, pkg);\n-\n-        \/\/ prepare spec file\n-        env.createResource(DEFAULT_SPEC_TEMPLATE)\n-                .setCategory(I18N.getString(\"resource.rpm-spec-file\"))\n-                .setSubstitutionData(replacementData)\n-                .saveToFile(specFile);\n-    }\n-\n-    @Override\n-    protected Path buildPackageBundle(BuildEnv env, LinuxPackage pkg,\n-            Path outputParentDir) throws PackagerException, IOException {\n-        return buildRPM(env, pkg, outputParentDir);\n-    }\n-\n-    private static Path installPrefix(LinuxPackage pkg) {\n-        Path path = pkg.relativeInstallDir();\n-        if (!pkg.isInstallDirInUsrTree()) {\n-            path = path.getParent();\n-        }\n-        return Path.of(\"\/\").resolve(path);\n-    }\n-\n-    @Override\n-    protected Map<String, String> createReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        data.put(\"APPLICATION_RELEASE\", pkg.release().orElseThrow());\n-        data.put(\"APPLICATION_PREFIX\", installPrefix(pkg).toString());\n-        data.put(\"APPLICATION_DIRECTORY\", Path.of(\"\/\").resolve(pkg.relativeInstallDir()).toString());\n-        data.put(\"APPLICATION_SUMMARY\", pkg.app().name());\n-        data.put(\"APPLICATION_LICENSE_TYPE\", ((LinuxRpmPackage)pkg).licenseType());\n-\n-        String licenseFile = pkg.licenseFile().map(v -> {\n-            return v.toAbsolutePath().normalize().toString();\n-        }).orElse(null);\n-        data.put(\"APPLICATION_LICENSE_FILE\", licenseFile);\n-        data.put(\"APPLICATION_GROUP\", pkg.category().orElse(\"\"));\n-\n-        data.put(\"APPLICATION_URL\", pkg.aboutURL().orElse(\"\"));\n-\n-        return data;\n+    public String getName() {\n+        return I18N.getString(\"rpm.bundler.name\");\n@@ -141,7 +49,2 @@\n-    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n-        libProvidersLookup.setPackageLookup(file -> {\n-            return Executor.of(TOOL_RPM,\n-                \"-q\", \"--queryformat\", \"%{name}\\\\n\",\n-                \"-q\", \"--whatprovides\", file.toString())\n-                .saveOutput(true).executeExpectSuccess().getOutput().stream();\n-        });\n+    public String getID() {\n+        return \"rpm\";\n@@ -151,15 +54,1 @@\n-    protected List<ConfigException> verifyOutputBundle(BuildEnv env, LinuxPackage pkg,\n-            Path packageBundle) {\n-        List<ConfigException> errors = new ArrayList<>();\n-\n-        String specFileName = specFile(env, pkg).getFileName().toString();\n-\n-        try {\n-            List<PackageProperty> properties = List.of(\n-                    new PackageProperty(\"Name\", pkg.packageName(),\n-                            \"APPLICATION_PACKAGE\", specFileName),\n-                    new PackageProperty(\"Version\", pkg.version(),\n-                            \"APPLICATION_VERSION\", specFileName),\n-                    new PackageProperty(\"Release\", pkg.release().orElseThrow(),\n-                            \"APPLICATION_RELEASE\", specFileName),\n-                    new PackageProperty(\"Arch\", pkg.arch(), null, specFileName));\n+    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n@@ -167,15 +56,1 @@\n-            List<String> actualValues = Executor.of(TOOL_RPM, \"-qp\", \"--queryformat\",\n-                    properties.stream().map(entry -> String.format(\"%%{%s}\",\n-                    entry.name)).collect(Collectors.joining(\"\\\\n\")),\n-                    packageBundle.toString()).saveOutput(true).executeExpectSuccess().getOutput();\n-\n-            Iterator<String> actualValuesIt = actualValues.iterator();\n-            properties.forEach(property -> errors.add(property.verifyValue(\n-                    actualValuesIt.next())));\n-        } catch (IOException ex) {\n-            \/\/ Ignore error as it is not critical. Just report it.\n-            Log.verbose(ex);\n-        }\n-\n-        return errors;\n-    }\n+        var pkg = LinuxFromParams.RPM_PACKAGE.fetchFrom(params);\n@@ -183,31 +58,6 @@\n-    private Path specFile(BuildEnv env, Package pkg) {\n-        return env.buildRoot().resolve(Path.of(\"SPECS\", pkg.packageName() + \".spec\"));\n-    }\n-\n-    private Path buildRPM(BuildEnv env, Package pkg, Path outdir) throws IOException {\n-\n-        Path rpmFile = outdir.toAbsolutePath().resolve(pkg.packageFileNameWithSuffix());\n-\n-        Log.verbose(I18N.format(\"message.outputting-bundle-location\", rpmFile.getParent()));\n-\n-        \/\/run rpmbuild\n-        Executor.of(TOOL_RPMBUILD,\n-                \"-bb\", specFile(env, pkg).toAbsolutePath().toString(),\n-                \"--define\", String.format(\"%%_sourcedir %s\",\n-                        env.appImageDir().toAbsolutePath()),\n-                \/\/ save result to output dir\n-                \"--define\", String.format(\"%%_rpmdir %s\", rpmFile.getParent()),\n-                \/\/ do not use other system directories to build as current user\n-                \"--define\", String.format(\"%%_topdir %s\",\n-                        env.buildRoot().toAbsolutePath()),\n-                \"--define\", String.format(\"%%_rpmfilename %s\", rpmFile.getFileName())\n-        ).executeExpectSuccess();\n-\n-        Log.verbose(I18N.format(\"message.output-bundle-location\", rpmFile.getParent()));\n-\n-        return rpmFile;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"rpm.bundler.name\");\n+        return Packager.<LinuxRpmPackage>build().outputDir(outputParentDir)\n+                .pkg(pkg)\n+                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n+                    return new LinuxRpmPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(LinuxPackagingPipeline.build(Optional.of(pkg)));\n@@ -217,7 +67,2 @@\n-    public String getID() {\n-        return \"rpm\";\n-    }\n-\n-    @Override\n-    public boolean supported(boolean runtimeInstaller) {\n-        return OperatingSystem.isLinux() && (createRpmbuildToolValidator().validate() == null);\n+    protected Result<LinuxRpmSystemEnvironment> sysEnv() {\n+        return sysEnv;\n@@ -228,1 +73,4 @@\n-        return !LinuxDebBundler.isDebian();\n+        return sysEnv.value()\n+                .map(LinuxSystemEnvironment::nativePackageType)\n+                .map(StandardPackageType.LINUX_RPM::equals)\n+                .orElse(false);\n@@ -230,0 +78,2 @@\n+\n+    private final Result<LinuxRpmSystemEnvironment> sysEnv = LinuxRpmSystemEnvironment.create(SYS_ENV);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":23,"deletions":173,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.joining;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n+\n+\n+\/**\n+ * There are two command line options to configure license information for RPM\n+ * packaging: --linux-rpm-license-type and --license-file. Value of\n+ * --linux-rpm-license-type command line option configures \"License:\" section\n+ * of RPM spec. Value of --license-file command line option specifies a license\n+ * file to be added to the package. License file is a sort of documentation file\n+ * but it will be installed even if user selects an option to install the\n+ * package without documentation. --linux-rpm-license-type is the primary option\n+ * to set license information. --license-file makes little sense in case of RPM\n+ * packaging.\n+ *\/\n+final class LinuxRpmPackager extends LinuxPackager<LinuxRpmPackage> {\n+\n+    LinuxRpmPackager(BuildEnv env, LinuxRpmPackage pkg, Path outputDir, LinuxRpmSystemEnvironment sysEnv) {\n+        super(env, pkg, outputDir, sysEnv);\n+        this.sysEnv = Objects.requireNonNull(sysEnv);\n+    }\n+\n+    @Override\n+    protected void createConfigFiles(Map<String, String> replacementData) throws IOException {\n+        Path specFile = specFile();\n+\n+        \/\/ prepare spec file\n+        env.createResource(\"template.spec\")\n+                .setCategory(I18N.getString(\"resource.rpm-spec-file\"))\n+                .setSubstitutionData(replacementData)\n+                .saveToFile(specFile);\n+    }\n+\n+    @Override\n+    protected Map<String, String> createReplacementData() {\n+        Map<String, String> data = new HashMap<>();\n+\n+        data.put(\"APPLICATION_RELEASE\", pkg.release().orElseThrow());\n+        data.put(\"APPLICATION_PREFIX\", installPrefix().toString());\n+        data.put(\"APPLICATION_DIRECTORY\", Path.of(\"\/\").resolve(pkg.relativeInstallDir()).toString());\n+        data.put(\"APPLICATION_SUMMARY\", pkg.app().name());\n+        data.put(\"APPLICATION_LICENSE_TYPE\", pkg.licenseType());\n+\n+        String licenseFile = pkg.licenseFile().map(v -> {\n+            return v.toAbsolutePath().normalize().toString();\n+        }).orElse(null);\n+        data.put(\"APPLICATION_LICENSE_FILE\", licenseFile);\n+        data.put(\"APPLICATION_GROUP\", pkg.category().orElse(\"\"));\n+\n+        data.put(\"APPLICATION_URL\", pkg.aboutURL().orElse(\"\"));\n+\n+        return data;\n+    }\n+\n+    @Override\n+    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n+        libProvidersLookup.setPackageLookup(file -> {\n+            return Executor.of(sysEnv.rpm().toString(),\n+                \"-q\", \"--queryformat\", \"%{name}\\\\n\",\n+                \"-q\", \"--whatprovides\", file.toString()\n+            ).saveOutput(true).executeExpectSuccess().getOutput().stream();\n+        });\n+    }\n+\n+    @Override\n+    protected List<? extends Exception> findErrorsInOutputPackage() throws IOException {\n+        List<ConfigException> errors = new ArrayList<>();\n+\n+        var specFileName = specFile().getFileName().toString();\n+\n+        var properties = List.of(\n+                new PackageProperty(\"Name\", pkg.packageName(),\n+                        \"APPLICATION_PACKAGE\", specFileName),\n+                new PackageProperty(\"Version\", pkg.version(),\n+                        \"APPLICATION_VERSION\", specFileName),\n+                new PackageProperty(\"Release\", pkg.release().orElseThrow(),\n+                        \"APPLICATION_RELEASE\", specFileName),\n+                new PackageProperty(\"Arch\", pkg.arch(), null, specFileName));\n+\n+        var actualValues = Executor.of(\n+                sysEnv.rpm().toString(),\n+                \"-qp\",\n+                \"--queryformat\", properties.stream().map(e -> String.format(\"%%{%s}\", e.name)).collect(joining(\"\\\\n\")),\n+                outputPackageFile().toString()\n+        ).saveOutput(true).executeExpectSuccess().getOutput();\n+\n+        for (int i = 0; i != properties.size(); i++) {\n+            Optional.ofNullable(properties.get(i).verifyValue(actualValues.get(i))).ifPresent(errors::add);\n+        }\n+\n+        return errors;\n+    }\n+\n+    @Override\n+    protected void buildPackage() throws IOException {\n+\n+        Path rpmFile = outputPackageFile();\n+\n+        Log.verbose(I18N.format(\"message.outputting-bundle-location\", rpmFile.getParent()));\n+\n+        \/\/run rpmbuild\n+        Executor.of(sysEnv.rpmbuild().toString(),\n+                \"-bb\", specFile().toAbsolutePath().toString(),\n+                \"--define\", String.format(\"%%_sourcedir %s\",\n+                        env.appImageDir().toAbsolutePath()),\n+                \/\/ save result to output dir\n+                \"--define\", String.format(\"%%_rpmdir %s\", rpmFile.getParent()),\n+                \/\/ do not use other system directories to build as current user\n+                \"--define\", String.format(\"%%_topdir %s\",\n+                        env.buildRoot().toAbsolutePath()),\n+                \"--define\", String.format(\"%%_rpmfilename %s\", rpmFile.getFileName())\n+        ).executeExpectSuccess();\n+\n+        Log.verbose(I18N.format(\"message.output-bundle-location\", rpmFile.getParent()));\n+    }\n+\n+    private Path installPrefix() {\n+        Path path = pkg.relativeInstallDir();\n+        if (!pkg.isInstallDirInUsrTree()) {\n+            path = path.getParent();\n+        }\n+        return Path.of(\"\/\").resolve(path);\n+    }\n+\n+    private Path specFile() {\n+        return env.buildRoot().resolve(Path.of(\"SPECS\", pkg.packageName() + \".spec\"));\n+    }\n+\n+    private final LinuxRpmSystemEnvironment sysEnv;\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmPackager.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.LinuxSystemEnvironment.mixin;\n+\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxRpmSystemEnvironment extends LinuxSystemEnvironment, LinuxRpmSystemEnvironmentMixin {\n+\n+    static Result<LinuxRpmSystemEnvironment> create(Result<LinuxSystemEnvironment> base) {\n+        return mixin(LinuxRpmSystemEnvironment.class, base, LinuxRpmSystemEnvironmentMixin::create);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironment.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.model.DottedVersion;\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxRpmSystemEnvironmentMixin {\n+    Path rpm();\n+    Path rpmbuild();\n+\n+    record Stub(Path rpm, Path rpmbuild) implements LinuxRpmSystemEnvironmentMixin {\n+    }\n+\n+    static Result<LinuxRpmSystemEnvironmentMixin> create() {\n+\n+        final var errors = Stream.of(\n+                Internal.createRpmbuildToolValidator(),\n+                new ToolValidator(Internal.TOOL_RPM)\n+        ).map(ToolValidator::validate).filter(Objects::nonNull).toList();\n+\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(new Stub(Internal.TOOL_RPM, Internal.TOOL_RPMBUILD));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    static final class Internal {\n+        private static ToolValidator createRpmbuildToolValidator() {\n+            Pattern pattern = Pattern.compile(\" (\\\\d+\\\\.\\\\d+)\");\n+            return new ToolValidator(TOOL_RPMBUILD).setMinimalVersion(\n+                    TOOL_RPMBUILD_MIN_VERSION).setVersionParser(lines -> {\n+                        String versionString = lines.limit(1).findFirst().orElseThrow();\n+                        Matcher matcher = pattern.matcher(versionString);\n+                        if (matcher.find()) {\n+                            return matcher.group(1);\n+                        }\n+                        return null;\n+                    });\n+        }\n+\n+        private static final Path TOOL_RPM = Path.of(\"rpm\");\n+        private static final Path TOOL_RPMBUILD = Path.of(\"rpmbuild\");\n+        private static final DottedVersion TOOL_RPMBUILD_MIN_VERSION = DottedVersion.lazy(\"4.10\");\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmSystemEnvironmentMixin.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+import jdk.jpackage.internal.util.Result;\n+\n+public interface LinuxSystemEnvironment extends SystemEnvironment {\n+    boolean soLookupAvailable();\n+    PackageType nativePackageType();\n+\n+    static Result<LinuxSystemEnvironment> create() {\n+        return detectNativePackageType().map(LinuxSystemEnvironment::create).orElseGet(() -> {\n+            return Result.ofError(new RuntimeException(\"Unknown native package type\"));\n+        });\n+    }\n+\n+    static Optional<PackageType> detectNativePackageType() {\n+        if (Internal.isDebian()) {\n+            return Optional.of(StandardPackageType.LINUX_DEB);\n+        } else if (Internal.isRpm()) {\n+            return Optional.of(StandardPackageType.LINUX_RPM);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    static Result<LinuxSystemEnvironment> create(PackageType nativePackageType) {\n+        return Result.ofValue(new Stub(LibProvidersLookup.supported(),\n+                Objects.requireNonNull(nativePackageType)));\n+    }\n+\n+    static <T, U extends LinuxSystemEnvironment> U createWithMixin(Class<U> type, LinuxSystemEnvironment base, T mixin) {\n+        return CompositeProxy.create(type, base, mixin);\n+    }\n+\n+    static <T, U extends LinuxSystemEnvironment> Result<U> mixin(Class<U> type,\n+            Result<LinuxSystemEnvironment> base, Supplier<Result<T>> mixinResultSupplier) {\n+        final var mixin = mixinResultSupplier.get();\n+\n+        final List<Exception> errors = new ArrayList<>();\n+        errors.addAll(base.errors());\n+        errors.addAll(mixin.errors());\n+\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(createWithMixin(type, base.orElseThrow(), mixin.orElseThrow()));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    record Stub(boolean soLookupAvailable, PackageType nativePackageType) implements LinuxSystemEnvironment {\n+    }\n+\n+    static final class Internal {\n+\n+        private static boolean isDebian() {\n+            \/\/ we are just going to run \"dpkg -s coreutils\" and assume Debian\n+            \/\/ or derivative if no error is returned.\n+            try {\n+                Executor.of(\"dpkg\", \"-s\", \"coreutils\").executeExpectSuccess();\n+                return true;\n+            } catch (IOException e) {\n+                \/\/ just fall thru\n+                return false;\n+            }\n+        }\n+\n+        private static boolean isRpm() {\n+            \/\/ we are just going to run \"rpm -q rpm\" and assume RPM\n+            \/\/ or derivative if no error is returned.\n+            try {\n+                Executor.of(\"rpm\", \"-q\", \"rpm\").executeExpectSuccess();\n+                return true;\n+            } catch (IOException e) {\n+                \/\/ just fall thru\n+                return false;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxSystemEnvironment.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.HashMap;\n@@ -39,3 +40,5 @@\n-        return shortcut().map(v -> {\n-            return Map.of(\"shortcut\", Boolean.toString(v));\n-        }).orElseGet(Map::of);\n+        Map<String, String> map = new HashMap<>();\n+        shortcut().ifPresent(shortcut -> {\n+            shortcut.store(SHORTCUT_ID, map::put);\n+        });\n+        return map;\n@@ -55,0 +58,2 @@\n+\n+    public static final String SHORTCUT_ID = \"linux-shortcut\";\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncher.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-     * Gets the start menu shortcut setting of this application launcher.\n+     * Gets the start menu shortcut of this application launcher.\n@@ -37,8 +37,4 @@\n-     * Returns <code>true<\/code> if this application launcher was requested to have\n-     * the start menu shortcut.\n-     * <p>\n-     * Returns <code>false<\/code> if this application launcher was requested not to\n-     * have the start menu shortcut.\n-     * <p>\n-     * Returns an empty {@link Optional} instance if there was no request about the\n-     * start menu shortcut for this application launcher.\n+     * Returns a non-empty {@link Optional} instance if a request about the start\n+     * menu shortcut for this application launcher was made and an empty\n+     * {@link Optional} instance if there was no request about the start menu\n+     * shortcut for this application launcher.\n@@ -46,1 +42,1 @@\n-     * @return the start menu shortcut setting of this application launcher\n+     * @return the start menu shortcut of this application launcher\n@@ -48,1 +44,1 @@\n-    Optional<Boolean> shortcut();\n+    Optional<LauncherShortcut> shortcut();\n@@ -53,1 +49,1 @@\n-    record Stub(Optional<Boolean> shortcut) implements LinuxLauncherMixin {\n+    record Stub(Optional<LauncherShortcut> shortcut) implements LinuxLauncherMixin {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncherMixin.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-    @Override\n-    AppImageLayout packageLayout();\n-\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackage.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,5 +34,0 @@\n-    \/**\n-     * Overrides {@link Package#packageLayout()}.\n-     *\/\n-    AppImageLayout packageLayout();\n-\n@@ -91,1 +86,1 @@\n-    record Stub(AppImageLayout packageLayout, String menuGroupName,\n+    record Stub(String menuGroupName,\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackageMixin.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+STARTUP_DIRECTORY\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.desktop","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -47,0 +49,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -53,1 +56,1 @@\n-    static Consumer<Path> createSigner(MacApplication app, CodesignConfig signingCfg) {\n+    static Consumer<MacBundle> createSigner(MacApplication app, CodesignConfig signingCfg) {\n@@ -70,1 +73,1 @@\n-        SignFilter(Application app, Path appImage) {\n+        SignFilter(Application app, MacBundle appImage) {\n@@ -75,1 +78,1 @@\n-                return appLayout.resolveAt(appImage);\n+                return appLayout.resolveAt(appImage.root());\n@@ -101,1 +104,6 @@\n-    private void sign(MacApplication app, Path appImage) throws CodesignException, IOException {\n+    private void sign(MacApplication app, MacBundle appImage) throws CodesignException, IOException {\n+        if (!appImage.isValid()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        app = copyWithUnresolvedAppImageLayout(app);\n@@ -105,1 +113,1 @@\n-        try (var content = Files.walk(appImage)) {\n+        try (var content = Files.walk(appImage.root())) {\n@@ -121,1 +129,1 @@\n-            return appLayout.resolveAt(appImage);\n+            return appLayout.resolveAt(appImage.root());\n@@ -124,1 +132,1 @@\n-        final var frameworkPath = appImage.resolve(\"Contents\/Frameworks\");\n+        final var frameworkPath = appImage.contentsDir().resolve(\"Frameworks\");\n@@ -134,1 +142,1 @@\n-        codesigners.accept(appImage);\n+        codesigners.accept(appImage.root());\n@@ -238,0 +246,14 @@\n+    private static MacApplication copyWithUnresolvedAppImageLayout(MacApplication app) {\n+        switch (app.imageLayout()) {\n+            case MacApplicationLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, APPLICATION_LAYOUT);\n+            }\n+            case RuntimeLayout macLayout -> {\n+                return MacApplicationBuilder.overrideAppImageLayout(app, RUNTIME_BUNDLE_LAYOUT);\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -47,1 +47,3 @@\n-            throw new IllegalArgumentException(\"Signing identity and identifier prefix mismatch\");\n+            throw new IllegalArgumentException(\n+                \"Signing identity (\" + identity + \") and identifier prefix (\" +\n+                identifierPrefix + \") mismatch\");\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/CodesignConfig.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-                 env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+                 env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n@@ -49,1 +49,1 @@\n-                 env = BuildEnv.withAppImageDir(BuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n+                 env = BuildEnv.withAppImageDir(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n@@ -72,1 +72,1 @@\n-        if (StandardBundlerParam.getPredefinedAppImage(params) != null) {\n+        if (StandardBundlerParam.hasPredefinedAppImage(params)) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.file.Files;\n@@ -30,0 +31,2 @@\n+import java.util.List;\n+import java.util.Set;\n@@ -37,0 +40,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -97,0 +101,1 @@\n+        validateAppContentDirs(app);\n@@ -98,2 +103,7 @@\n-        final var mixin = new MacApplicationMixin.Stub(validatedIcon(), validatedBundleName(),\n-                validatedBundleIdentifier(), validatedCategory(), appStore, createSigningConfig());\n+        final var mixin = new MacApplicationMixin.Stub(\n+                validatedIcon(),\n+                validatedBundleName(),\n+                validatedBundleIdentifier(),\n+                validatedCategory(),\n+                appStore,\n+                createSigningConfig());\n@@ -104,0 +114,11 @@\n+    static MacApplication overrideAppImageLayout(MacApplication app, AppImageLayout appImageLayout) {\n+        final var mixin = new MacApplicationMixin.Stub(\n+                app.icon(),\n+                app.bundleName(),\n+                app.bundleIdentifier(),\n+                app.category(),\n+                app.appStore(),\n+                app.signingConfig());\n+        return MacApplication.create(ApplicationBuilder.overrideAppImageLayout(app, appImageLayout), mixin);\n+    }\n+\n@@ -126,0 +147,12 @@\n+    private static void validateAppContentDirs(Application app) {\n+        for (var contentDir : app.contentDirs()) {\n+            if (!Files.isDirectory(contentDir)) {\n+                Log.info(I18N.format(\"warning.app.content.is.not.dir\",\n+                        contentDir));\n+            } else if (!CONTENTS_SUB_DIRS.contains(contentDir.getFileName().toString())) {\n+                Log.info(I18N.format(\"warning.non.standard.contents.sub.dir\",\n+                        contentDir));\n+            }\n+        }\n+    }\n+\n@@ -236,0 +269,4 @@\n+\n+    \/\/ List of standard subdirectories of the \"Contents\" directory\n+    private static final Set<String> CONTENTS_SUB_DIRS = Set.of(\"MacOS\",\n+            \"Resources\", \"Frameworks\", \"PlugIns\", \"SharedSupport\");\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationBuilder.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -38,1 +39,2 @@\n-                .create(MacApplicationLayout.class, layout, new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n+                .create(MacApplicationLayout.class, layout,\n+                        new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n@@ -43,2 +45,1 @@\n-        return create(ApplicationLayout.super.resolveAt(root),\n-                resolveNullablePath(root, runtimeRootDirectory()));\n+        return (MacApplicationLayout)ApplicationLayout.super.resolveAt(root);\n@@ -46,0 +47,20 @@\n+\n+    @Override\n+    default MacApplicationLayout unresolve() {\n+        return (MacApplicationLayout)ApplicationLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default MacApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(ApplicationLayout.super.resetRootDirectory(), runtimeRootDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default MacApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return create(ApplicationLayout.super.map(mapper), mapNullablePath(mapper, runtimeRootDirectory()));\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayout.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+\/\/ Must be public to allow access from AppImageLayout.toPathGroup()\n@@ -33,1 +33,2 @@\n-     * Path to the root Java runtime directory in the application image.\n+     * Returns path to the root Java runtime directory in the application image.\n+     * <p>\n@@ -35,0 +36,2 @@\n+     *\n+     * @return the path to the root Java runtime directory in the application image\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayoutMixin.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n@@ -32,3 +30,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n@@ -36,1 +31,0 @@\n-import java.util.Optional;\n@@ -47,20 +41,1 @@\n-        if (PREDEFINED_APP_IMAGE.fetchFrom(params) != null) {\n-            Path applicationImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n-            if (new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params)).signed()) {\n-                var appLayout = ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT.resolveAt(applicationImage);\n-                if (!Files.exists(\n-                        PackageFile.getPathInAppImage(appLayout))) {\n-                    Log.info(MessageFormat.format(I18N.getString(\n-                            \"warning.per.user.app.image.signed\"),\n-                            PackageFile.getPathInAppImage(appLayout)));\n-                }\n-            } else {\n-                if (Optional.ofNullable(\n-                        SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {\n-                    \/\/ if signing bundle with app-image, warn user if app-image\n-                    \/\/ is not already signed.\n-                    Log.info(MessageFormat.format(I18N.getString(\n-                            \"warning.unsigned.app.image\"), getID()));\n-                }\n-            }\n-        } else {\n+        if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import jdk.jpackage.internal.model.MacPackage;\n+\n+final class MacBuildEnvFromParams {\n+\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return BuildEnvFromParams.create(params, MacPackagingPipeline.APPLICATION_LAYOUT::resolveAt, MacPackage::guessRuntimeLayout);\n+    });\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBuildEnvFromParams.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+\n+\/**\n+ * An abstraction of macOS Application bundle.\n+ *\n+ * @see <a href=\"https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles\">https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles<\/a>\n+ *\/\n+record MacBundle(Path root) {\n+\n+    MacBundle {\n+        Objects.requireNonNull(root);\n+    }\n+\n+    boolean isValid() {\n+        return Files.isDirectory(contentsDir()) && Files.isDirectory(macOsDir()) && Files.isRegularFile(infoPlistFile());\n+    }\n+\n+    boolean isSigned() {\n+        return Files.isDirectory(contentsDir().resolve(\"_CodeSignature\"));\n+    }\n+\n+    Path contentsDir() {\n+        return root.resolve(\"Contents\");\n+    }\n+\n+    Path homeDir() {\n+        return contentsDir().resolve(\"Home\");\n+    }\n+\n+    Path macOsDir() {\n+        return contentsDir().resolve(\"MacOS\");\n+    }\n+\n+    Path resourcesDir() {\n+        return contentsDir().resolve(\"Resources\");\n+    }\n+\n+    Path infoPlistFile() {\n+        return contentsDir().resolve(\"Info.plist\");\n+    }\n+\n+    static Optional<MacBundle> fromPath(Path path) {\n+        var bundle = new MacBundle(path);\n+        if (bundle.isValid()) {\n+            return Optional.of(bundle);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    static Optional<MacBundle> fromAppImageLayout(AppImageLayout layout) {\n+        final var root = layout.rootDirectory();\n+        final var bundleSubdir = root.relativize(layout.runtimeDirectory());\n+        final var contentsDirname = Path.of(\"Contents\");\n+        var bundleRoot = root;\n+        for (int i = 0; i != bundleSubdir.getNameCount(); i++) {\n+            var nameComponent = bundleSubdir.getName(i);\n+            if (contentsDirname.equals(nameComponent)) {\n+                return Optional.of(new MacBundle(bundleRoot));\n+            } else {\n+                bundleRoot = bundleRoot.resolve(nameComponent);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundle.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.file.Files;\n@@ -32,0 +31,1 @@\n+import java.util.Optional;\n@@ -33,0 +33,1 @@\n+import jdk.jpackage.internal.model.MacDmgPackage;\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.internal.util.Result;\n@@ -73,2 +75,1 @@\n-        final var pkg = MacFromParams.DMG_PACKAGE.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var pkg = MacFromParams.DMG_PACKAGE.fetchFrom(params);\n@@ -76,1 +77,1 @@\n-        final var packager = MacDmgPackager.build().outputDir(outputParentDir).pkg(pkg).env(env);\n+        Log.verbose(I18N.format(\"message.building-dmg\", pkg.app().name()));\n@@ -78,3 +79,6 @@\n-        MacDmgPackager.findSetFileUtility().ifPresent(packager::setFileUtility);\n-\n-        return packager.execute();\n+        return Packager.<MacDmgPackage>build().outputDir(outputParentDir)\n+                .pkg(pkg)\n+                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n+                    return new MacDmgPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n@@ -85,17 +89,1 @@\n-        return isSupported();\n-    }\n-\n-    public static final String[] required =\n-            {\"\/usr\/bin\/hdiutil\", \"\/usr\/bin\/osascript\"};\n-    public static boolean isSupported() {\n-        try {\n-            for (String s : required) {\n-                Path f = Path.of(s);\n-                if (!Files.exists(f) || !Files.isExecutable(f)) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        } catch (Exception e) {\n-            return false;\n-        }\n+        return sysEnv.hasValue();\n@@ -108,0 +96,2 @@\n+\n+    private final Result<MacDmgSystemEnvironment> sysEnv = MacDmgSystemEnvironment.create();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":14,"deletions":24,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-        final var superPkgBuilder = pkgBuilder.pkgBuilder();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackageBuilder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,2 +39,1 @@\n-import java.util.Optional;\n-import java.util.stream.Stream;\n+import java.util.function.Consumer;\n@@ -42,1 +41,0 @@\n-import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n@@ -45,1 +43,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -49,1 +46,2 @@\n-record MacDmgPackager(MacDmgPackage pkg, BuildEnv env, Path hdiutil, Path outputDir, Optional<Path> setFileUtility) {\n+record MacDmgPackager(BuildEnv env, MacDmgPackage pkg, Path outputDir,\n+        MacDmgSystemEnvironment sysEnv) implements Consumer<PackagingPipeline.Builder> {\n@@ -52,1 +50,0 @@\n-        Objects.requireNonNull(pkg);\n@@ -54,1 +51,1 @@\n-        Objects.requireNonNull(hdiutil);\n+        Objects.requireNonNull(pkg);\n@@ -56,5 +53,1 @@\n-        Objects.requireNonNull(setFileUtility);\n-    }\n-\n-    static Builder build() {\n-        return new Builder();\n+        Objects.requireNonNull(sysEnv);\n@@ -63,76 +56,2 @@\n-    static final class Builder extends PackagerBuilder<MacDmgPackage, Builder> {\n-\n-        Builder hdiutil(Path v) {\n-            hdiutil = v;\n-            return this;\n-        }\n-\n-        Builder setFileUtility(Path v) {\n-            setFileUtility = v;\n-            return this;\n-        }\n-\n-        Path execute() throws PackagerException {\n-            Log.verbose(MessageFormat.format(I18N.getString(\"message.building-dmg\"),\n-                    pkg.app().name()));\n-\n-            IOUtils.writableOutputDir(outputDir);\n-\n-            return execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-        }\n-\n-        @Override\n-        protected void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n-                StartupParameters startupParameters) {\n-            final var packager = new MacDmgPackager(pkg, startupParameters.packagingEnv(),\n-                    validatedHdiutil(), outputDir, Optional.ofNullable(setFileUtility));\n-            packager.applyToPipeline(pipelineBuilder);\n-        }\n-\n-        private Path validatedHdiutil() {\n-            return Optional.ofNullable(hdiutil).orElse(HDIUTIL);\n-        }\n-\n-        private Path hdiutil;\n-        private Path setFileUtility;\n-    }\n-\n-    \/\/ Location of SetFile utility may be different depending on MacOS version\n-    \/\/ We look for several known places and if none of them work will\n-    \/\/ try to find it\n-    static Optional<Path> findSetFileUtility() {\n-        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n-                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n-\n-        final var setFilePath = Stream.of(typicalPaths).map(Path::of).filter(Files::isExecutable).findFirst();\n-        if (setFilePath.isPresent()) {\n-            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n-            \/\/ code\n-            try {\n-                if (Executor.of(setFilePath.orElseThrow().toString(), \"-h\").setQuiet(true).execute() == 0) {\n-                    return setFilePath;\n-                }\n-            } catch (Exception ignored) {\n-                \/\/ No need for generic find attempt. We found it, but it does not work.\n-                \/\/ Probably due to missing xcode.\n-                return Optional.empty();\n-            }\n-        }\n-\n-        \/\/ generic find attempt\n-        try {\n-            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n-            final var code = executor.setQuiet(true).saveOutput(true).execute();\n-            if (code == 0 && executor.getOutput().isEmpty()) {\n-                final var firstLine = executor.getOutput().getFirst();\n-                Path f = Path.of(firstLine);\n-                if (Files.exists(f) && Files.isExecutable(f)) {\n-                    return Optional.of(f.toAbsolutePath());\n-                }\n-            }\n-        } catch (IOException ignored) {}\n-\n-        return Optional.empty();\n-    }\n-\n-    private void applyToPipeline(PackagingPipeline.Builder pipelineBuilder) {\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n@@ -321,1 +240,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -344,1 +263,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -360,1 +279,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -385,1 +304,1 @@\n-                pb = new ProcessBuilder(\"\/usr\/bin\/osascript\",\n+                pb = new ProcessBuilder(sysEnv.osascript().toString(),\n@@ -400,1 +319,1 @@\n-            if (setFileUtility.isPresent()) {\n+            if (sysEnv.setFileUtility().isPresent()) {\n@@ -409,1 +328,1 @@\n-                            setFileUtility.orElseThrow().toString(),\n+                            sysEnv.setFileUtility().orElseThrow().toString(),\n@@ -416,1 +335,1 @@\n-                            setFileUtility.orElseThrow().toString(),\n+                            sysEnv.setFileUtility().orElseThrow().toString(),\n@@ -431,1 +350,1 @@\n-                    hdiutil.toString(),\n+                    sysEnv.hdiutil().toString(),\n@@ -454,1 +373,1 @@\n-                                hdiutil.toString(),\n+                                sysEnv.hdiutil().toString(),\n@@ -467,1 +386,1 @@\n-                hdiutil.toString(),\n+                sysEnv.hdiutil().toString(),\n@@ -484,1 +403,1 @@\n-                        hdiutil.toString(),\n+                        sysEnv.hdiutil().toString(),\n@@ -499,1 +418,1 @@\n-                    hdiutil.toString(),\n+                    sysEnv.hdiutil().toString(),\n@@ -530,2 +449,0 @@\n-\n-    private static final Path HDIUTIL = Path.of(\"\/usr\/bin\/hdiutil\");\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackager.java","additions":19,"deletions":102,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.Result;\n+\n+record MacDmgSystemEnvironment(Path hdiutil, Path osascript, Optional<Path> setFileUtility) implements SystemEnvironment {\n+\n+    MacDmgSystemEnvironment {\n+    }\n+\n+    static Result<MacDmgSystemEnvironment> create() {\n+        final var errors = Stream.of(HDIUTIL, OSASCRIPT)\n+                .map(ToolValidator::new)\n+                .map(ToolValidator::checkExistsOnly)\n+                .map(ToolValidator::validate)\n+                .filter(Objects::nonNull)\n+                .toList();\n+        if (errors.isEmpty()) {\n+            return Result.ofValue(new MacDmgSystemEnvironment(HDIUTIL, OSASCRIPT, findSetFileUtility()));\n+        } else {\n+            return Result.ofErrors(errors);\n+        }\n+    }\n+\n+    \/\/ Location of SetFile utility may be different depending on MacOS version\n+    \/\/ We look for several known places and if none of them work will\n+    \/\/ try to find it\n+    private static Optional<Path> findSetFileUtility() {\n+        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n+                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n+\n+        final var setFilePath = Stream.of(typicalPaths).map(Path::of).filter(Files::isExecutable).findFirst();\n+        if (setFilePath.isPresent()) {\n+            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n+            \/\/ code\n+            try {\n+                if (Executor.of(setFilePath.orElseThrow().toString(), \"-h\").setQuiet(true).execute() == 0) {\n+                    return setFilePath;\n+                }\n+            } catch (Exception ignored) {\n+                \/\/ No need for generic find attempt. We found it, but it does not work.\n+                \/\/ Probably due to missing xcode.\n+                return Optional.empty();\n+            }\n+        }\n+\n+        \/\/ generic find attempt\n+        try {\n+            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n+            final var code = executor.setQuiet(true).saveOutput(true).execute();\n+            if (code == 0 && !executor.getOutput().isEmpty()) {\n+                final var firstLine = executor.getOutput().getFirst();\n+                Path f = Path.of(firstLine);\n+                if (new ToolValidator(f).checkExistsOnly().validate() == null) {\n+                    return Optional.of(f.toAbsolutePath());\n+                }\n+            }\n+        } catch (IOException ignored) {}\n+\n+        return Optional.empty();\n+    }\n+\n+    private static final Path HDIUTIL = Path.of(\"\/usr\/bin\/hdiutil\");\n+    private static final Path OSASCRIPT = Path.of(\"\/usr\/bin\/osascript\");\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgSystemEnvironment.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -35,0 +35,2 @@\n+import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasJliLib;\n+import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasNoBinDir;\n@@ -42,1 +44,1 @@\n-import static jdk.jpackage.internal.model.MacPackage.RUNTIME_PACKAGE_LAYOUT;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n@@ -48,1 +50,0 @@\n-import java.nio.file.Files;\n@@ -67,0 +68,1 @@\n+import jdk.jpackage.internal.model.MacPackage;\n@@ -78,5 +80,7 @@\n-        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params).map(predefinedRuntimeImage -> {\n-            if (Files.isDirectory(RUNTIME_PACKAGE_LAYOUT.resolveAt(predefinedRuntimeImage).runtimeDirectory())) {\n-                return RUNTIME_PACKAGE_LAYOUT;\n-            } else {\n-                return RuntimeLayout.DEFAULT;\n+        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params)\n+                .map(MacPackage::guessRuntimeLayout);\n+\n+        if (predefinedRuntimeLayout.isPresent()) {\n+            validateRuntimeHasJliLib(predefinedRuntimeLayout.orElseThrow());\n+            if (APP_STORE.findIn(params).orElse(false)) {\n+                validateRuntimeHasNoBinDir(predefinedRuntimeLayout.orElseThrow());\n@@ -84,1 +88,1 @@\n-        });\n+        }\n@@ -91,1 +95,3 @@\n-        }), APPLICATION_LAYOUT, predefinedRuntimeLayout);\n+        }), (MacLauncher _, Launcher launcher) -> {\n+            return MacLauncher.create(launcher);\n+        }, APPLICATION_LAYOUT, RUNTIME_BUNDLE_LAYOUT, predefinedRuntimeLayout.map(RuntimeLayout::unresolve));\n@@ -98,1 +104,1 @@\n-            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getMainClass());\n+            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(superAppBuilder.mainLauncherClassName().orElseThrow());\n@@ -109,1 +115,1 @@\n-            appBuilder.externalInfoPlistFile(PREDEFINED_APP_IMAGE.findIn(params).orElseThrow().resolve(\"Contents\/Info.plist\"));\n+            appBuilder.externalInfoPlistFile(PREDEFINED_APP_IMAGE.findIn(params).map(MacBundle::new).orElseThrow().infoPlistFile());\n@@ -121,1 +127,1 @@\n-            final var appImageFileExtras = new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params));\n+            final var appImageFileExtras = new MacAppImageFileExtras(superAppBuilder.externalApplication().orElseThrow());\n@@ -150,1 +156,9 @@\n-            app.mainLauncher().flatMap(Launcher::startupInfo).ifPresent(signingBuilder::signingIdentifierPrefix);\n+            final var bundleIdentifier = appBuilder.create().bundleIdentifier();\n+            app.mainLauncher().flatMap(Launcher::startupInfo).ifPresentOrElse(\n+                signingBuilder::signingIdentifierPrefix,\n+                () -> {\n+                    \/\/ Runtime installer does not have main launcher, so use\n+                    \/\/ 'bundleIdentifier' as prefix by default.\n+                    signingBuilder.signingIdentifierPrefix(\n+                        bundleIdentifier + \".\");\n+                });\n@@ -171,0 +185,6 @@\n+        PREDEFINED_RUNTIME_IMAGE.findIn(params)\n+                .map(MacBundle::new)\n+                .filter(MacBundle::isValid)\n+                .map(MacBundle::isSigned)\n+                .ifPresent(builder::predefinedAppImageSigned);\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.MacPackagingPipeline.LayoutUtils.packagerLayout;\n+\n+import java.nio.file.Files;\n@@ -29,0 +33,1 @@\n+import jdk.jpackage.internal.model.MacApplication;\n@@ -48,2 +53,24 @@\n-        final var pkg = pkgBuilder.create();\n-        return MacPackage.create(pkg, new MacPackageMixin.Stub(pkg.predefinedAppImage().map(v -> predefinedAppImageSigned)));\n+\n+        final var app = (MacApplication)pkgBuilder.app();\n+\n+        var pkg = pkgBuilder.create();\n+\n+        pkgBuilder.app(MacApplicationBuilder.overrideAppImageLayout(app, packagerLayout(pkg)))\n+                .installedPackageLayout(pkg.installedPackageLayout());\n+\n+        pkg = pkgBuilder.create();\n+\n+        var macPkg = MacPackage.create(pkg, new MacPackageMixin.Stub(pkg.predefinedAppImage().map(v -> predefinedAppImageSigned)));\n+        validatePredefinedAppImage(macPkg);\n+        return macPkg;\n+    }\n+\n+    private static void validatePredefinedAppImage(MacPackage pkg) {\n+        if (pkg.predefinedAppImageSigned().orElse(false)) {\n+            pkg.predefinedAppImage().ifPresent(predefinedAppImage -> {\n+                var thePackageFile = PackageFile.getPathInAppImage(APPLICATION_LAYOUT);\n+                if (!Files.exists(predefinedAppImage.resolve(thePackageFile))) {\n+                    Log.info(I18N.format(\"warning.per.user.app.image.signed\", thePackageFile));\n+                }\n+            });\n+        }\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.UncheckedIOException;\n@@ -44,0 +45,1 @@\n+import java.nio.file.LinkOption;\n@@ -51,0 +53,1 @@\n+import java.util.function.UnaryOperator;\n@@ -55,0 +58,1 @@\n+import jdk.jpackage.internal.PackagingPipeline.AppImageTaskAction;\n@@ -75,0 +79,1 @@\n+import jdk.jpackage.internal.util.FileUtils;\n@@ -94,0 +99,1 @@\n+        COPY_RUNTIME_JLILIB,\n@@ -98,4 +104,0 @@\n-    static AppImageLayout packagingLayout(Package pkg) {\n-        return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName());\n-    }\n-\n@@ -104,9 +106,2 @@\n-                .appContextMapper(appContext -> {\n-                    return new TaskContextProxy(appContext, true, false);\n-                })\n-                .pkgContextMapper(appContext -> {\n-                    final var isRuntimeInstaller = pkg.map(Package::isRuntimeInstaller).orElse(false);\n-                    final var withPredefinedAppImage = pkg.flatMap(Package::predefinedAppImage).isPresent();\n-                    return new TaskContextProxy(appContext, false, isRuntimeInstaller || withPredefinedAppImage);\n-                })\n-                .appImageLayoutForPackaging(MacPackagingPipeline::packagingLayout)\n+                .contextMapper(pkg.map(MacPackagingPipeline::mapPackageTaskContext)\n+                        .orElseGet(MacPackagingPipeline::mapAppTaskContext))\n@@ -118,1 +113,1 @@\n-                        .applicationAction(MacPackagingPipeline::writeApplicationRuntimeInfoPlist)\n+                        .appImageAction(MacPackagingPipeline::writeRuntimeInfoPlist)\n@@ -121,1 +116,1 @@\n-                        .applicationAction(MacPackagingPipeline::copyJliLib)\n+                        .appImageAction(MacPackagingPipeline::copyJliLib)\n@@ -141,0 +136,5 @@\n+                        .appImageAction(MacPackagingPipeline::writeRuntimeInfoPlist)\n+                        .addDependencies(CopyAppImageTaskID.COPY)\n+                        .addDependents(PrimaryTaskID.COPY_APP_IMAGE).add()\n+                .task(MacCopyAppImageTaskID.COPY_RUNTIME_JLILIB)\n+                        .noaction()\n@@ -147,1 +147,1 @@\n-                        .applicationAction(MacPackagingPipeline::writeAppInfoPlist)\n+                        .applicationAction(MacPackagingPipeline::writeApplicationInfoPlist)\n@@ -151,1 +151,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -157,1 +157,1 @@\n-                .appImageAction(MacPackagingPipeline::sign)\n+                .appImageAction(LayoutUtils.withBundleLayout(MacPackagingPipeline::sign))\n@@ -175,5 +175,11 @@\n-                builder.task(MacCopyAppImageTaskID.REPLACE_APP_IMAGE_FILE).applicationAction(createWriteAppImageFileAction()).add();\n-                builder.appImageLayoutForPackaging(Package::appImageLayout);\n-            } else if (p.isRuntimeInstaller() || ((MacPackage)p).predefinedAppImageSigned().orElse(false)) {\n-                \/\/ If this is a runtime package or a signed predefined app image,\n-                \/\/ don't create \".package\" file and don't sign it.\n+                builder.task(MacCopyAppImageTaskID.REPLACE_APP_IMAGE_FILE)\n+                        .applicationAction(createWriteAppImageFileAction()).add();\n+            } else if (p.isRuntimeInstaller()) {\n+\n+                builder.task(MacCopyAppImageTaskID.COPY_RUNTIME_JLILIB)\n+                        .appImageAction(MacPackagingPipeline::copyJliLib).add();\n+\n+                final var predefinedRuntimeBundle = Optional.of(\n+                        new MacBundle(p.predefinedAppImage().orElseThrow())).filter(MacBundle::isValid);\n+\n+                \/\/ Don't create \".package\" file.\n@@ -181,0 +187,18 @@\n+\n+                if (predefinedRuntimeBundle.isPresent()) {\n+                    \/\/ The predefined app image is a macOS bundle.\n+                    \/\/ Disable all alterations of the input bundle, but keep the signing enabled.\n+                    disabledTasks.addAll(List.of(MacCopyAppImageTaskID.values()));\n+                    disabledTasks.remove(MacCopyAppImageTaskID.COPY_SIGN);\n+                }\n+\n+                if (predefinedRuntimeBundle.map(MacBundle::isSigned).orElse(false) && !((MacPackage)p).app().sign()) {\n+                    \/\/ The predefined app image is a signed bundle; explicit signing is not requested for the package.\n+                    \/\/ Disable the signing, i.e. don't re-sign the input bundle.\n+                    disabledTasks.add(MacCopyAppImageTaskID.COPY_SIGN);\n+                }\n+            } else if (((MacPackage)p).predefinedAppImageSigned().orElse(false)) {\n+                \/\/ This is a signed predefined app image.\n+                \/\/ Don't create \".package\" file.\n+                disabledTasks.add(MacCopyAppImageTaskID.COPY_PACKAGE_FILE);\n+                \/\/ Don't sign the image.\n@@ -182,3 +206,0 @@\n-\/\/                if (p.isRuntimeInstaller()) {\n-\/\/                    builder.task(MacCopyAppImageTaskID.COPY_RUNTIME_INFO_PLIST).packageAction(MacPackagingPipeline::writeRuntimeRuntimeInfoPlist).add();\n-\/\/                }\n@@ -209,3 +230,77 @@\n-    private static void copyAppImage(MacPackage pkg, AppImageDesc srcAppImage,\n-            AppImageDesc dstAppImage) throws IOException {\n-        PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !pkg.predefinedAppImageSigned().orElse(false));\n+    static final class LayoutUtils {\n+        \/**\n+         * Returns unresolved app image layout for the specified package for use with\n+         * the signing function defined in {@link MacPackagingPipeline} class and\n+         * {@link MacPkgPackager} and {@link MacDmgPackager} packagers.\n+         * <p>\n+         * Paths of the result app image layout will start with the bundle name. E.g.:\n+         * for a package with relative installation directory set to\n+         * {@code \"Applications\/Acme\/MyApp.app\"} and the \"launchers\" directory of an\n+         * application layout set to {@code \"Contents\/MacOS\"}, the result application\n+         * layout object will be such that the value of its \"launchers\" directory will\n+         * be {@code \"MyApp.app\/Contents\/MacOS\"}. The root directory of the result app\n+         * image layout will be an empty path ({@link Path.of(\"\")}), i.e. the app image\n+         * layout will be unresolved.\n+         *\n+         * @param pkg the package\n+         * @return the unresolved app image layout for the specified package suitable\n+         *         for the use with macosx packaging pipeline and packagers\n+         *\/\n+        static AppImageLayout packagerLayout(Package pkg) {\n+            return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName()).resetRootDirectory();\n+        }\n+\n+        static <T extends AppImageLayout> AppImageBuildEnv<MacApplication, T> fromPackagerLayout(AppImageBuildEnv<MacApplication, T> cfg) {\n+\n+            var bundleDirectoryName = cfg.envLayout().runtimeDirectory().getName(0);\n+            var bundleLayout = cfg.envLayout().map(bundleDirectoryName::relativize).resetRootDirectory();\n+            var bundleRoot = cfg.env().appImageDir().resolve(bundleDirectoryName);\n+            var app = MacApplicationBuilder.overrideAppImageLayout(cfg.app(), bundleLayout);\n+            var env = BuildEnv.withAppImageLayout(cfg.env(), bundleLayout.resolveAt(bundleRoot));\n+\n+            return new AppImageBuildEnv<>(env, app);\n+        }\n+\n+        static <T extends AppImageLayout> AppImageTaskAction<MacApplication, T> withBundleLayout(AppImageTaskAction<MacApplication, T> action) {\n+            return new AppImageTaskAction<>() {\n+                @Override\n+                public void execute(AppImageBuildEnv<MacApplication, T> env) throws IOException, PackagerException {\n+                    if (!env.envLayout().runtimeDirectory().getName(0).equals(Path.of(\"Contents\"))) {\n+                        env = LayoutUtils.fromPackagerLayout(env);\n+                    }\n+                    action.execute(env);\n+                }\n+            };\n+        }\n+    }\n+\n+    private static void copyAppImage(MacPackage pkg, AppImageLayout srcAppImage,\n+            AppImageLayout dstAppImage) throws IOException {\n+\n+        boolean predefinedAppImageSigned = pkg.predefinedAppImageSigned().orElse(false);\n+\n+        final Optional<MacBundle> srcMacBundle;\n+        if (pkg.isRuntimeInstaller()) {\n+            srcMacBundle = MacBundle.fromAppImageLayout(srcAppImage);\n+        } else {\n+            srcMacBundle = Optional.empty();\n+        }\n+\n+        srcMacBundle.ifPresentOrElse(inputBundle -> {\n+            \/\/ Building runtime package from the input runtime bundle.\n+            \/\/ Copy the input bundle verbatim.\n+            try {\n+                FileUtils.copyRecursive(\n+                        inputBundle.root(),\n+                        MacBundle.fromAppImageLayout(dstAppImage).orElseThrow().root(),\n+                        LinkOption.NOFOLLOW_LINKS);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }, () -> {\n+            try {\n+                PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !predefinedAppImageSigned);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n@@ -215,1 +310,1 @@\n-            AppImageBuildEnv<MacApplication, MacApplicationLayout> env) throws IOException {\n+            AppImageBuildEnv<MacApplication, AppImageLayout> env) throws IOException {\n@@ -217,1 +312,1 @@\n-        final var runtimeMacOSDir = env.resolvedLayout().runtimeRootDirectory().resolve(\"Contents\/MacOS\");\n+        final var runtimeBundle = runtimeBundle(env);\n@@ -226,2 +321,2 @@\n-            Files.createDirectories(runtimeMacOSDir);\n-            Files.copy(jli, runtimeMacOSDir.resolve(jliName));\n+            Files.createDirectories(runtimeBundle.macOsDir());\n+            Files.copy(jli, runtimeBundle.macOsDir().resolve(jliName));\n@@ -231,4 +326,17 @@\n-    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> env) throws IOException {\n-        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env.env(), env.env().appImageDir().resolve(env.envLayout().rootDirectory())),\n-                env.pkg(), env.pkg().appImageLayout(), env.outputDir()));\n+    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> cfg) throws IOException {\n+        var appCfg = LayoutUtils.fromPackagerLayout(\n+                new AppImageBuildEnv<>(cfg.env(), (MacApplication)cfg.pkg().app()));\n+\n+        var pkg = cfg.pkg(); pkg = new Package.Stub(\n+                appCfg.app(),\n+                pkg.type(),\n+                pkg.packageName(),\n+                pkg.description(),\n+                pkg.version(),\n+                pkg.aboutURL(),\n+                pkg.licenseFile(),\n+                pkg.predefinedAppImage(),\n+                pkg.installedPackageLayout(),\n+                pkg.relativeInstallDir());\n+\n+        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(appCfg.env(), pkg, cfg.outputDir()));\n@@ -250,8 +358,2 @@\n-    private static void writeRuntimeRuntimeInfoPlist(PackageBuildEnv<MacPackage, AppImageLayout> env) throws IOException {\n-        writeRuntimeInfoPlist(env.pkg().app(), env.env(), env.resolvedLayout().rootDirectory());\n-    }\n-\n-    private static void writeApplicationRuntimeInfoPlist(\n-            AppImageBuildEnv<MacApplication, MacApplicationLayout> env) throws IOException {\n-        writeRuntimeInfoPlist(env.app(), env.env(), env.resolvedLayout().runtimeRootDirectory());\n-    }\n+    private static void writeRuntimeInfoPlist(\n+            AppImageBuildEnv<MacApplication, AppImageLayout> env) throws IOException {\n@@ -259,1 +361,1 @@\n-    private static void writeRuntimeInfoPlist(MacApplication app, BuildEnv env, Path runtimeRootDirectory) throws IOException {\n+        final var app = env.app();\n@@ -266,0 +368,3 @@\n+        if (app.isRuntime()) {\n+            data.put(\"CF_BUNDLE_VENDOR\", app.vendor());\n+        }\n@@ -267,3 +372,17 @@\n-        env.createResource(\"Runtime-Info.plist.template\")\n-                .setPublicName(\"Runtime-Info.plist\")\n-                .setCategory(I18N.getString(\"resource.runtime-info-plist\"))\n+        final String template;\n+        final String publicName;\n+        final String category;\n+\n+        if (app.isRuntime()) {\n+            template = \"Runtime-Info.plist.template\";\n+            publicName = \"Info.plist\";\n+            category = \"resource.runtime-info-plist\";\n+        } else {\n+            template = \"ApplicationRuntime-Info.plist.template\";\n+            publicName = \"Runtime-Info.plist\";\n+            category = \"resource.app-runtime-info-plist\";\n+        }\n+\n+        env.env().createResource(template)\n+                .setPublicName(publicName)\n+                .setCategory(I18N.getString(category))\n@@ -271,1 +390,1 @@\n-                .saveToFile(runtimeRootDirectory.resolve(\"Contents\/Info.plist\"));\n+                .saveToFile(runtimeBundle(env).infoPlistFile());\n@@ -274,1 +393,1 @@\n-    private static void writeAppInfoPlist(\n+    private static void writeApplicationInfoPlist(\n@@ -279,1 +398,1 @@\n-        final var infoPlistFile = env.resolvedLayout().contentDirectory().resolve(\"Info.plist\");\n+        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow().infoPlistFile();\n@@ -311,1 +430,1 @@\n-    private static void sign(AppImageBuildEnv<MacApplication, MacApplicationLayout> env) throws IOException {\n+    private static void sign(AppImageBuildEnv<MacApplication, AppImageLayout> env) throws IOException {\n@@ -332,2 +451,1 @@\n-            final var appImageDir = env.resolvedLayout().rootDirectory();\n-            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(appImageDir);\n+            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow());\n@@ -413,0 +531,8 @@\n+    private static MacBundle runtimeBundle(AppImageBuildEnv<MacApplication, AppImageLayout> env) {\n+        if (env.app().isRuntime()) {\n+            return MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow();\n+        } else {\n+            return new MacBundle(((MacApplicationLayout)env.resolvedLayout()).runtimeRootDirectory());\n+        }\n+    }\n+\n@@ -438,0 +564,15 @@\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapAppTaskContext() {\n+        return ctx -> {\n+            return new TaskContextProxy(ctx, true, false);\n+        };\n+    }\n+\n+    private static UnaryOperator<PackagingPipeline.TaskContext> mapPackageTaskContext(Package pkg) {\n+        return ctx -> {\n+            final var isRuntimeInstaller = pkg.isRuntimeInstaller();\n+            final var withPredefinedAppImage = pkg.predefinedAppImage().isPresent();\n+            return new TaskContextProxy(ctx, false, isRuntimeInstaller || withPredefinedAppImage);\n+        };\n+    }\n+\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":196,"deletions":55,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -32,0 +33,1 @@\n+import jdk.jpackage.internal.model.MacPkgPackage;\n@@ -52,1 +54,1 @@\n-            final var pkgPkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n+            final var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n@@ -75,2 +77,1 @@\n-        final var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+        var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n@@ -78,1 +79,1 @@\n-        final var packager = MacPkgPackager.build().outputDir(outputParentDir).pkg(pkg).env(env);\n+        Log.verbose(I18N.format(\"message.building-pkg\", pkg.app().name()));\n@@ -80,1 +81,6 @@\n-        return packager.execute();\n+        return Packager.<MacPkgPackage>build().outputDir(outputParentDir)\n+                .pkg(pkg)\n+                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n+                    return new MacPkgPackager(env, pkg, outputDir);\n+                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Optional;\n@@ -36,1 +37,1 @@\n-        preinstall(new ResourceConfig(\"preinstall.template\",\n+        preinstall(new ResourceConfig(Optional.empty(),\n@@ -38,1 +39,1 @@\n-        postinstall(new ResourceConfig(\"postinstall.template\",\n+        postinstall(new ResourceConfig(Optional.empty(),\n@@ -47,1 +48,1 @@\n-            return cfg.createResource();\n+            return cfg.createResource().setPublicName(name());\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgInstallerScripts.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-        return MacPkgPackage.create(pkgBuilder.create(), new MacPkgPackageMixin.Stub(createSigningConfig()));\n+        var pkg = MacPkgPackage.create(pkgBuilder.create(), new MacPkgPackageMixin.Stub(createSigningConfig()));\n+        validatePredefinedAppImage(pkg);\n+        return pkg;\n@@ -59,0 +61,8 @@\n+    private static void validatePredefinedAppImage(MacPkgPackage pkg) {\n+        if (!pkg.predefinedAppImageSigned().orElse(false) && pkg.sign()) {\n+            pkg.predefinedAppImage().ifPresent(predefinedAppImage -> {\n+                Log.info(I18N.format(\"warning.unsigned.app.image\", \"pkg\"));\n+            });\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackageBuilder.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.file.DirectoryStream;\n@@ -44,0 +45,1 @@\n+import java.util.function.Consumer;\n@@ -55,1 +57,0 @@\n-import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n@@ -58,1 +59,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -63,1 +63,13 @@\n-record MacPkgPackager(MacPkgPackage pkg, BuildEnv env, Optional<Services> services, Path outputDir) {\n+record MacPkgPackager(BuildEnv env, MacPkgPackage pkg, Optional<Services> services,\n+        Path outputDir) implements Consumer<PackagingPipeline.Builder> {\n+\n+    MacPkgPackager {\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(services);\n+        Objects.requireNonNull(outputDir);\n+    }\n+\n+    MacPkgPackager(BuildEnv env, MacPkgPackage pkg, Path outputDir) {\n+        this(env, pkg, createServices(env, pkg), outputDir);\n+    }\n@@ -67,0 +79,1 @@\n+        LOG_NO_MAIN_SCRIPTS,\n@@ -72,31 +85,0 @@\n-    static Builder build() {\n-        return new Builder();\n-    }\n-\n-    static final class Builder extends PackagerBuilder<MacPkgPackage, Builder> {\n-\n-        Path execute() throws PackagerException {\n-            Log.verbose(MessageFormat.format(I18N.getString(\"message.building-pkg\"),\n-                    pkg.app().name()));\n-\n-            IOUtils.writableOutputDir(outputDir);\n-\n-            return execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-        }\n-\n-        @Override\n-        protected void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n-                StartupParameters startupParameters) {\n-            final var packager = new MacPkgPackager(pkg, startupParameters.packagingEnv(), createServices(), outputDir);\n-            packager.applyToPipeline(pipelineBuilder);\n-        }\n-\n-        private Optional<Services> createServices() {\n-            if (pkg.app().isService()) {\n-                return Optional.of(Services.create(pkg, env));\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-    }\n-\n@@ -177,1 +159,1 @@\n-                    .setResourceDir(env.resourceDir().orElse(null))\n+                    .setResourceDir(env)\n@@ -233,1 +215,2 @@\n-    private void applyToPipeline(PackagingPipeline.Builder pipelineBuilder) {\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n@@ -240,0 +223,4 @@\n+                .task(PkgPackageTaskID.LOG_NO_MAIN_SCRIPTS)\n+                        .action(this::logNoMainScripts)\n+                        .addDependent(PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                        .add()\n@@ -281,0 +268,2 @@\n+        } else {\n+            disabledTasks.add(PkgPackageTaskID.LOG_NO_MAIN_SCRIPTS);\n@@ -309,1 +298,2 @@\n-        if (pkg.app().appStore() || pkg.isRuntimeInstaller()) {\n+        if (pkg.app().appStore() || pkg.isRuntimeInstaller() ||\n+                MacPkgInstallerScripts.createAppScripts().setResourceDir(env).isEmpty()) {\n@@ -371,7 +361,0 @@\n-        final Map<String, String> data = new HashMap<>();\n-\n-        final var appLocation = pkg.asInstalledPackageApplicationLayout().orElseThrow().appDirectory();\n-\n-        data.put(\"INSTALL_LOCATION\", Path.of(\"\/\").resolve(pkg.relativeInstallDir()).toString());\n-        data.put(\"APP_LOCATION\", appLocation.toString());\n-\n@@ -379,2 +362,1 @@\n-                .setResourceDir(env.resourceDir().orElse(null))\n-                .setSubstitutionData(data)\n+                .setResourceDir(env)\n@@ -384,0 +366,7 @@\n+    private void logNoMainScripts() throws IOException {\n+        \/\/ Should not create any files, but merely log what files the user\n+        \/\/ should add to the resource directory to customize install scripts.\n+        MacPkgInstallerScripts.createAppScripts()\n+                .saveInFolder(env.configDir().resolve(\"scripts\"));\n+    }\n+\n@@ -562,0 +551,8 @@\n+    private static Optional<Services> createServices(BuildEnv env, MacPkgPackage pkg) {\n+        if (pkg.app().isService()) {\n+            return Optional.of(Services.create(pkg, env));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackager.java","additions":43,"deletions":46,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+\n+final class MacRuntimeValidator {\n+\n+    static void validateRuntimeHasJliLib(RuntimeLayout runtimeLayout) throws ConfigException {\n+        final var jliName = Path.of(\"libjli.dylib\");\n+        try (var walk = Files.walk(runtimeLayout.runtimeDirectory().resolve(\"lib\"))) {\n+            if (walk.map(Path::getFileName).anyMatch(Predicate.isEqual(jliName))) {\n+                return;\n+            }\n+        } catch (NoSuchFileException ex) {\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+\n+        throw I18N.buildConfigException(\"error.invalid-runtime-image-missing-file\",\n+                runtimeLayout.rootDirectory(),\n+                runtimeLayout.unresolve().runtimeDirectory().resolve(\"lib\/**\").resolve(jliName)).create();\n+    }\n+\n+    static void validateRuntimeHasNoBinDir(RuntimeLayout runtimeLayout) throws ConfigException {\n+        if (Files.isDirectory(runtimeLayout.runtimeDirectory().resolve(\"bin\"))) {\n+            throw I18N.buildConfigException()\n+                    .message(\"error.invalid-runtime-image-bin-dir\", runtimeLayout.rootDirectory())\n+                    .advice(\"error.invalid-runtime-image-bin-dir.advice\", \"--mac-app-store\")\n+                    .create();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacRuntimeValidator.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -57,0 +57,1 @@\n+        final String suffix;\n@@ -58,1 +59,1 @@\n-            return Application.super.appImageDirName();\n+            suffix = \".jdk\";\n@@ -60,1 +61,1 @@\n-            return Path.of(Application.super.appImageDirName().toString() + \".app\");\n+            suffix = \".app\";\n@@ -62,0 +63,1 @@\n+        return Path.of(Application.super.appImageDirName().toString() + suffix);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacApplication.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.nio.file.Files;\n@@ -32,2 +33,0 @@\n-    MacApplication app();\n-\n@@ -35,7 +34,1 @@\n-    default AppImageLayout appImageLayout() {\n-        if (isRuntimeInstaller()) {\n-            return RUNTIME_PACKAGE_LAYOUT;\n-        } else {\n-            return Package.super.appImageLayout();\n-        }\n-    }\n+    MacApplication app();\n@@ -51,1 +44,15 @@\n-    public static final RuntimeLayout RUNTIME_PACKAGE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n+    \/**\n+     * Guesses layout of a runtime image at the given path.\n+     *\n+     * @param path the path to a runtime image\n+     * @return the runtime image layout resolved at the given path\n+     *\/\n+    public static RuntimeLayout guessRuntimeLayout(Path path) {\n+        if (Files.isDirectory(RUNTIME_BUNDLE_LAYOUT.resolveAt(path).runtimeDirectory())) {\n+            return RUNTIME_BUNDLE_LAYOUT.resolveAt(path);\n+        } else {\n+            return RuntimeLayout.DEFAULT.resolveAt(path);\n+        }\n+    }\n+\n+    public static final RuntimeLayout RUNTIME_BUNDLE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacPackage.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/ApplicationRuntime-Info.plist.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/Runtime-Info.plist.template","status":"copied"},{"patch":"@@ -42,0 +42,3 @@\n+error.invalid-runtime-image-missing-file=Runtime image \"{0}\" is missing \"{1}\" file\n+error.invalid-runtime-image-bin-dir=Runtime image \"{0}\" should not contain \"bin\" folder\n+error.invalid-runtime-image-bin-dir.advice=Use --strip-native-commands jlink option when generating runtime image used with {0} option\n@@ -44,0 +47,1 @@\n+resource.app-runtime-info-plist=Embedded Java Runtime Info.plist\n@@ -87,0 +91,2 @@\n+warning.non.standard.contents.sub.dir=Warning: The file name of the directory \"{0}\" specified for the --app-content option is not a standard subdirectory name in the \"Contents\" directory of the application bundle. The result application bundle may fail code signing and\/or notarization.\n+warning.app.content.is.not.dir=Warning: The value \"{0}\" of the --app-content option is not a directory. The result application bundle may fail code signing and\/or notarization.\n\\ No newline at end of file\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -23,0 +23,15 @@\n+        <key>NSMicrophoneUsageDescription<\/key>\n+        <string>The application is requesting access to the microphone.<\/string>\n+        <key>JavaVM<\/key>\n+        <dict>\n+                <key>JVMCapabilities<\/key>\n+                <array>\n+                        <string>CommandLine<\/string>\n+                <\/array>\n+                <key>JVMPlatformVersion<\/key>\n+                <string>CF_BUNDLE_VERSION<\/string>\n+                <key>JVMVendor<\/key>\n+                <string>CF_BUNDLE_VENDOR<\/string>\n+                <key>JVMVersion<\/key>\n+                <string>CF_BUNDLE_VERSION<\/string>\n+        <\/dict>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/Runtime-Info.plist.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,7 +0,0 @@\n-#!\/usr\/bin\/env sh\n-\n-chown root:wheel \"INSTALL_LOCATION\"\n-chmod a+rX \"INSTALL_LOCATION\"\n-chmod +r \"APP_LOCATION\/\"*.jar\n-\n-exit 0\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/postinstall.template","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-#!\/usr\/bin\/env sh\n-\n-if [ ! -d \"INSTALL_LOCATION\" ]\n-then\n-    mkdir -p \"INSTALL_LOCATION\"\n-fi\n-\n-exit 0\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/preinstall.template","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -39,2 +39,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -138,1 +136,1 @@\n-            Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_SHORTCUT_HINT.getId(),\n@@ -140,1 +138,1 @@\n-            Arguments.putUnlessNull(bundleParams, MENU_HINT.getID(),\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_MENU_HINT.getId(),\n@@ -147,1 +145,1 @@\n-            Arguments.putUnlessNull(bundleParams, SHORTCUT_HINT.getID(),\n+            Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AddLauncherArguments.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-\n-record AppImageDesc(AppImageLayout appImageLayout, Path path) {\n-\n-    AppImageDesc {\n-        Objects.requireNonNull(appImageLayout);\n-        Objects.requireNonNull(path);\n-    }\n-\n-    AppImageLayout resolvedAppImagelayout() {\n-        return appImageLayout.resolveAt(path);\n-    }\n-\n-    Optional<ApplicationLayout> asResolvedApplicationLayout() {\n-        return asApplicationLayout().map(v -> v.resolveAt(path));\n-    }\n-\n-    Optional<ApplicationLayout> asApplicationLayout() {\n-        if (appImageLayout instanceof ApplicationLayout layout) {\n-            return Optional.of(layout);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageDesc.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.BiFunction;\n@@ -36,0 +37,1 @@\n+import java.util.function.Predicate;\n@@ -43,0 +45,1 @@\n+import jdk.jpackage.internal.model.LauncherIcon;\n@@ -44,0 +47,1 @@\n+import jdk.jpackage.internal.model.ResourceDirLauncherIcon;\n@@ -89,0 +93,3 @@\n+\n+        externalApp = Objects.requireNonNull(app);\n+\n@@ -115,0 +122,13 @@\n+    Optional<ExternalApplication> externalApplication() {\n+        return Optional.ofNullable(externalApp);\n+    }\n+\n+    Optional<String> mainLauncherClassName() {\n+        return launchers()\n+                .map(ApplicationLaunchers::mainLauncher)\n+                .flatMap(Launcher::startupInfo)\n+                .map(LauncherStartupInfo::qualifiedClassName).or(() -> {\n+                    return externalApplication().map(ExternalApplication::getMainClass);\n+                });\n+    }\n+\n@@ -155,0 +175,91 @@\n+    static <T extends Launcher> ApplicationLaunchers normalizeIcons(\n+            ApplicationLaunchers appLaunchers, Optional<Path> resourceDir, BiFunction<T, Launcher, T> launcherOverrideCtor) {\n+\n+        Objects.requireNonNull(resourceDir);\n+\n+        return normalizeLauncherProperty(appLaunchers, Launcher::hasDefaultIcon, (T launcher) -> {\n+            return resourceDir.<LauncherIcon>flatMap(dir -> {\n+                var resource = LauncherBuilder.createLauncherIconResource(launcher, _ -> {\n+                    return new OverridableResource()\n+                            .setResourceDir(dir)\n+                            .setSourceOrder(OverridableResource.Source.ResourceDir);\n+                });\n+                if (resource.probe() == OverridableResource.Source.ResourceDir) {\n+                    return Optional.of(ResourceDirLauncherIcon.create(resource.getPublicName().toString()));\n+                } else {\n+                    return Optional.empty();\n+                }\n+            });\n+        }, launcher -> {\n+            return launcher.icon().orElseThrow();\n+        }, (launcher, icon) -> {\n+            return launcherOverrideCtor.apply(launcher, overrideIcon(launcher, icon));\n+        });\n+    }\n+\n+    static <T, U extends Launcher> ApplicationLaunchers normalizeLauncherProperty(\n+            ApplicationLaunchers appLaunchers,\n+            Predicate<U> needsNormalization,\n+            Function<U, Optional<T>> normalizedPropertyValueFinder,\n+            BiFunction<U, T, U> propertyOverrider) {\n+\n+        return normalizeLauncherProperty(\n+                appLaunchers,\n+                needsNormalization,\n+                normalizedPropertyValueFinder,\n+                launcher -> {\n+                    return normalizedPropertyValueFinder.apply(launcher).orElseThrow();\n+                },\n+                propertyOverrider);\n+    }\n+\n+    static <T, U extends Launcher> ApplicationLaunchers normalizeLauncherProperty(\n+            ApplicationLaunchers appLaunchers,\n+            Predicate<U> needsNormalization,\n+            Function<U, Optional<T>> normalizedPropertyValueFinder,\n+            Function<U, T> normalizedPropertyValueGetter,\n+            BiFunction<U, T, U> propertyOverrider) {\n+\n+        Objects.requireNonNull(appLaunchers);\n+        Objects.requireNonNull(needsNormalization);\n+        Objects.requireNonNull(normalizedPropertyValueFinder);\n+        Objects.requireNonNull(normalizedPropertyValueGetter);\n+        Objects.requireNonNull(propertyOverrider);\n+\n+        boolean[] modified = new boolean[1];\n+\n+        @SuppressWarnings(\"unchecked\")\n+        var newLaunchers = appLaunchers.asList().stream().map(launcher -> {\n+            return (U)launcher;\n+        }).map(launcher -> {\n+            if (needsNormalization.test(launcher)) {\n+                return normalizedPropertyValueFinder.apply(launcher).map(normalizedPropertyValue -> {\n+                    modified[0] = true;\n+                    return propertyOverrider.apply(launcher, normalizedPropertyValue);\n+                }).orElse(launcher);\n+            } else {\n+                return launcher;\n+            }\n+        }).toList();\n+\n+        var newMainLauncher = newLaunchers.getFirst();\n+        if (!needsNormalization.test(newMainLauncher)) {\n+            \/\/ The main launcher doesn't require normalization.\n+            newLaunchers = newLaunchers.stream().map(launcher -> {\n+                if (needsNormalization.test(launcher)) {\n+                    var normalizedPropertyValue = normalizedPropertyValueGetter.apply(newMainLauncher);\n+                    modified[0] = true;\n+                    return propertyOverrider.apply(launcher, normalizedPropertyValue);\n+                } else {\n+                    return launcher;\n+                }\n+            }).toList();\n+        }\n+\n+        if (modified[0]) {\n+            return ApplicationLaunchers.fromList(newLaunchers).orElseThrow();\n+        } else {\n+            return appLaunchers;\n+        }\n+    }\n+\n@@ -156,3 +267,36 @@\n-        return new Launcher.Stub(launcher.name(), Optional.of(startupInfo),\n-                launcher.fileAssociations(), launcher.isService(), launcher.description(),\n-                launcher.icon(), launcher.defaultIconResourceName(), launcher.extraAppImageFileData());\n+        return new Launcher.Stub(\n+                launcher.name(),\n+                Optional.of(startupInfo),\n+                launcher.fileAssociations(),\n+                launcher.isService(),\n+                launcher.description(),\n+                launcher.icon(),\n+                launcher.defaultIconResourceName(),\n+                launcher.extraAppImageFileData());\n+    }\n+\n+    static Application overrideAppImageLayout(Application app, AppImageLayout appImageLayout) {\n+        return new Application.Stub(\n+                app.name(),\n+                app.description(),\n+                app.version(),\n+                app.vendor(),\n+                app.copyright(),\n+                app.srcDir(),\n+                app.contentDirs(),\n+                Objects.requireNonNull(appImageLayout),\n+                app.runtimeBuilder(),\n+                app.launchers(),\n+                app.extraAppImageFileData());\n+    }\n+\n+    private static Launcher overrideIcon(Launcher launcher, LauncherIcon icon) {\n+        return new Launcher.Stub(\n+                launcher.name(),\n+                launcher.startupInfo(),\n+                launcher.fileAssociations(),\n+                launcher.isService(),\n+                launcher.description(),\n+                Optional.of(icon),\n+                launcher.defaultIconResourceName(),\n+                launcher.extraAppImageFileData());\n@@ -190,0 +334,1 @@\n+    private ExternalApplication externalApp;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":148,"deletions":3,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -35,0 +34,1 @@\n+import java.nio.file.StandardCopyOption;\n@@ -45,0 +45,1 @@\n+import jdk.jpackage.internal.model.DefaultLauncherIcon;\n@@ -46,0 +47,1 @@\n+import jdk.jpackage.internal.model.ResourceDirLauncherIcon;\n@@ -47,1 +49,0 @@\n-import jdk.jpackage.internal.util.PathUtils;\n@@ -52,2 +53,1 @@\n-    static Optional<OverridableResource> createLauncherIconResource(Application app,\n-            Launcher launcher,\n+    static Optional<OverridableResource> createLauncherIconResource(Launcher launcher,\n@@ -55,2 +55,0 @@\n-        final String defaultIconName = launcher.defaultIconResourceName();\n-        final String resourcePublicName = launcher.executableName() + PathUtils.getSuffix(Path.of(defaultIconName));\n@@ -58,3 +56,2 @@\n-        if (!launcher.hasIcon()) {\n-            return Optional.empty();\n-        }\n+        return launcher.icon().map(icon -> {\n+            var resource = LauncherBuilder.createLauncherIconResource(launcher, resourceSupplier);\n@@ -62,17 +59,12 @@\n-        OverridableResource resource = resourceSupplier.apply(defaultIconName)\n-                .setCategory(\"icon\")\n-                .setPublicName(resourcePublicName);\n-\n-        launcher.icon().flatMap(CustomLauncherIcon::fromLauncherIcon).map(CustomLauncherIcon::path).ifPresent(resource::setExternal);\n-\n-        if (launcher.hasDefaultIcon() && app.mainLauncher().orElseThrow() != launcher) {\n-            \/\/ No icon explicitly configured for this launcher.\n-            \/\/ Dry-run resource creation to figure out its source.\n-            final Path nullPath = null;\n-            if (toSupplier(() -> resource.saveToFile(nullPath)).get() != OverridableResource.Source.ResourceDir) {\n-                \/\/ No icon in resource dir for this launcher, inherit icon\n-                \/\/ configured for the main launcher.\n-                return createLauncherIconResource(\n-                        app, app.mainLauncher().orElseThrow(),\n-                        resourceSupplier\n-                ).map(r -> r.setLogPublicName(resourcePublicName));\n+            switch (icon) {\n+                case DefaultLauncherIcon _ -> {\n+                    resource.setSourceOrder(OverridableResource.Source.DefaultResource);\n+                }\n+                case ResourceDirLauncherIcon v -> {\n+                    resource.setSourceOrder(OverridableResource.Source.ResourceDir);\n+                    resource.setPublicName(v.name());\n+                }\n+                case CustomLauncherIcon v -> {\n+                    resource.setSourceOrder(OverridableResource.Source.External);\n+                    resource.setExternal(v.path());\n+                }\n@@ -80,1 +72,0 @@\n-        }\n@@ -82,1 +73,2 @@\n-        return Optional.of(resource);\n+            return resource;\n+        });\n@@ -87,1 +79,1 @@\n-            env.app().runtimeBuilder().orElseThrow().createRuntime(env.resolvedLayout());\n+            env.app().runtimeBuilder().orElseThrow().create(env.resolvedLayout());\n@@ -151,1 +143,2 @@\n-        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes, LinkOption.NOFOLLOW_LINKS);\n+        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes,\n+                LinkOption.NOFOLLOW_LINKS, StandardCopyOption.REPLACE_EXISTING);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -127,1 +128,1 @@\n-        Log.verbose (\"\\njpackage argument list: \\n\" + argList + \"\\n\");\n+\n@@ -351,3 +352,2 @@\n-        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-menu\", true);\n-        }),\n+        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN,\n+                createArgumentWithOptionalValueAction(\"win-menu\")),\n@@ -357,4 +357,2 @@\n-        WIN_SHORTCUT_HINT (\"win-shortcut\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-shortcut\", true);\n-        }),\n+        WIN_SHORTCUT_HINT (\"win-shortcut\", OptionCategories.PLATFORM_WIN,\n+                createArgumentWithOptionalValueAction(\"win-shortcut\")),\n@@ -399,4 +397,2 @@\n-        LINUX_SHORTCUT_HINT (\"linux-shortcut\",\n-                OptionCategories.PLATFORM_LINUX, () -> {\n-            setOptionValue(\"linux-shortcut\", true);\n-        }),\n+        LINUX_SHORTCUT_HINT (\"linux-shortcut\", OptionCategories.PLATFORM_LINUX,\n+                createArgumentWithOptionalValueAction(\"linux-shortcut\")),\n@@ -481,0 +477,5 @@\n+        private static void prevArg() {\n+            Objects.checkIndex(context().pos, context().argList.size());\n+            context().pos--;\n+        }\n+\n@@ -484,0 +485,18 @@\n+\n+        private static Runnable createArgumentWithOptionalValueAction(String option) {\n+            Objects.requireNonNull(option);\n+            return () -> {\n+                nextArg();\n+                if (hasNextArg()) {\n+                    var value = getArg();\n+                    if (value.startsWith(\"-\")) {\n+                        prevArg();\n+                        setOptionValue(option, true);\n+                    } else {\n+                        setOptionValue(option, value);\n+                    }\n+                } else {\n+                    setOptionValue(option, true);\n+                }\n+            };\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -31,0 +33,3 @@\n+\/**\n+ * Build environment.\n+ *\/\n@@ -33,0 +38,5 @@\n+    \/**\n+     * Returns root directory for intermediate build files.\n+     *\n+     * @return the root directory for intermediate build files\n+     *\/\n@@ -35,0 +45,5 @@\n+    \/**\n+     * Returns <code>true<\/code> if the build should be verbose output.\n+     *\n+     * @return <code>true<\/code> if the build should be verbose output\n+     *\/\n@@ -37,0 +52,7 @@\n+    \/**\n+     * Returns the path of the resource directory or an empty {@link Optional}\n+     * instance if none is configured with the build.\n+     *\n+     * @return the path of the resource directory or an empty {@link Optional}\n+     *         instance if non is configured with the build\n+     *\/\n@@ -40,1 +62,1 @@\n-     * Returns path to application image directory.\n+     * Returns the path of the app image directory of this build.\n@@ -42,2 +64,1 @@\n-     * The return value is supposed to be used as a parameter for\n-     * ApplicationLayout#resolveAt function.\n+     * @return the path of the app image directory of this build\n@@ -46,1 +67,1 @@\n-        return buildRoot().resolve(\"image\");\n+        return appImageLayout().rootDirectory();\n@@ -49,0 +70,20 @@\n+    \/**\n+     * Returns resolved app image layout of the app image directory. The return\n+     * layout is resolved at {@link #appImageDir()} path.\n+     *\n+     * @return the resolved app image layout of the app image directory\n+     *\/\n+    AppImageLayout appImageLayout();\n+\n+    default Optional<ApplicationLayout> asApplicationLayout() {\n+        if (appImageLayout() instanceof ApplicationLayout layout) {\n+            return Optional.of(layout);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Returns a path to a directory for intermediate configuration files.\n+     * @return the path to the directory for intermediate configuration files\n+     *\/\n@@ -53,0 +94,7 @@\n+    \/**\n+     * Creates an {@link OverridableResource} instance for the given resource name.\n+     *\n+     * @param defaultName the resource name\n+     * @return the {@link OverridableResource} instance wrapping a resource with the\n+     *         given name\n+     *\/\n@@ -59,2 +107,8 @@\n-    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose, Class<?> resourceLocator) {\n-        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.empty());\n+    static BuildEnv withAppImageLayout(BuildEnv env, AppImageLayout appImageLayout) {\n+        return ((Internal.DefaultBuildEnv)env).copyWithAppImageLayout(appImageLayout);\n+    }\n+\n+    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose,\n+            Class<?> resourceLocator, AppImageLayout appImageLayout) {\n+        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose,\n+                resourceLocator, appImageLayout);\n@@ -64,2 +118,3 @@\n-        private static record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n-                boolean verbose, Class<?> resourceLocator, Optional<Path> optAppImageDir) implements BuildEnv {\n+        private record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n+                boolean verbose, Class<?> resourceLocator,\n+                AppImageLayout appImageLayout) implements BuildEnv {\n@@ -71,1 +126,1 @@\n-                Objects.requireNonNull(optAppImageDir);\n+                Objects.requireNonNull(appImageLayout);\n@@ -74,2 +129,2 @@\n-            DefaultBuildEnv copyWithAppImageDir(Path appImageDir) {\n-                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.of(appImageDir));\n+            DefaultBuildEnv copyWithAppImageDir(Path v) {\n+                return copyWithAppImageLayout(appImageLayout.unresolve().resolveAt(v));\n@@ -78,3 +133,2 @@\n-            @Override\n-            public Path appImageDir() {\n-                return optAppImageDir.orElseGet(BuildEnv.super::appImageDir);\n+            DefaultBuildEnv copyWithAppImageLayout(AppImageLayout v) {\n+                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, v);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnv.java","additions":68,"deletions":14,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -34,0 +35,1 @@\n+import jdk.jpackage.internal.model.Package;\n@@ -43,2 +45,0 @@\n-        Objects.requireNonNull(appImageDir);\n-\n@@ -60,2 +60,2 @@\n-        return BuildEnv.withAppImageDir(BuildEnv.create(root, Optional.ofNullable(resourceDir),\n-                verbose, ResourceLocator.class), appImageDir);\n+        return BuildEnv.create(root, Optional.ofNullable(resourceDir), verbose,\n+                ResourceLocator.class, resolvedAppImageLayout());\n@@ -79,0 +79,5 @@\n+    BuildEnvBuilder appImageLayout(AppImageLayout v) {\n+        appImageLayout = v;\n+        return this;\n+    }\n+\n@@ -81,0 +86,1 @@\n+        appImageLayout = app.imageLayout();\n@@ -84,1 +90,1 @@\n-    BuildEnvBuilder appImageDirForPackage() {\n+    BuildEnvBuilder appImageDirFor(Package pkg) {\n@@ -86,0 +92,1 @@\n+        appImageLayout = pkg.appImageLayout();\n@@ -89,0 +96,5 @@\n+    private AppImageLayout resolvedAppImageLayout() {\n+        Objects.requireNonNull(appImageLayout);\n+        return Optional.ofNullable(appImageDir).map(appImageLayout.unresolve()::resolveAt).orElse(appImageLayout);\n+    }\n+\n@@ -94,0 +106,1 @@\n+    private AppImageLayout appImageLayout;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvBuilder.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n@@ -32,0 +34,1 @@\n+import java.nio.file.Path;\n@@ -33,0 +36,2 @@\n+import java.util.function.Function;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -34,0 +39,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -37,1 +43,3 @@\n-    static BuildEnv create(Map<String, ? super Object> params) throws ConfigException {\n+    static BuildEnv create(Map<String, ? super Object> params,\n+            Function<Path, ApplicationLayout> predefinedAppImageLayoutProvider,\n+            Function<Path, RuntimeLayout> predefinedRuntimeImageLayoutProvider) throws ConfigException {\n@@ -49,1 +57,2 @@\n-            builder.appImageDir(PREDEFINED_RUNTIME_IMAGE.fetchFrom(params));\n+            var layout = predefinedRuntimeImageLayoutProvider.apply(PREDEFINED_RUNTIME_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -51,1 +60,2 @@\n-            builder.appImageDir(StandardBundlerParam.getPredefinedAppImage(params));\n+            var layout = predefinedAppImageLayoutProvider.apply(PREDEFINED_APP_IMAGE.findIn(params).orElseThrow());\n+            builder.appImageLayout(layout);\n@@ -53,1 +63,1 @@\n-            builder.appImageDirForPackage();\n+            builder.appImageDirFor(pkg.orElseThrow());\n@@ -61,2 +71,3 @@\n-    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(\n-            BuildEnv.class, BuildEnvFromParams::create);\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n+        return create(params, PLATFORM_APPLICATION_LAYOUT::resolveAt, RuntimeLayout.DEFAULT::resolveAt);\n+    });\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromParams.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+            String pAppContentNote;\n@@ -69,0 +70,2 @@\n+                    pAppContentNote\n+                            = I18N.getString(\"MSG_Help_mac_app_content_note\");\n@@ -79,0 +82,1 @@\n+                    pAppContentNote = \"\";\n@@ -89,0 +93,1 @@\n+                    pAppContentNote = \"\";\n@@ -102,0 +107,1 @@\n+                    pAppContentNote = \"\";\n@@ -107,1 +113,1 @@\n-                    pSignSampleUsage));\n+                    pSignSampleUsage, pAppContentNote));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CLIHelp.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -283,24 +283,0 @@\n-\n-            \/\/ Validate runtime if mac-app-store is set. Predefined runtime\n-            \/\/ should not contain \"bin\" folder.\n-            runtime = (String)bundlerArguments.get(\n-                    Arguments.CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId());\n-            if (runtime != null) {\n-                \/\/ Should exist from check above if not null\n-                Path topImage = Path.of(runtime);\n-\n-                \/\/ On Mac topImage can be runtime root or runtime home.\n-                Path runtimeHome = topImage.resolve(\"Contents\/Home\");\n-                if (Files.isDirectory(runtimeHome)) {\n-                    \/\/ topImage references runtime root, adjust it to pick data\n-                    \/\/ from runtime home\n-                    topImage = runtimeHome;\n-                }\n-\n-                Path runtimeBin = topImage.resolve(\"bin\");\n-                if (Files.isDirectory(runtimeBin)) {\n-                    throw new PackagerException(\n-                            \"ERR_MacAppStoreRuntimeBinExists\",\n-                            topImage.toAbsolutePath().toString());\n-                }\n-            }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DeployParams.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import static jdk.jpackage.internal.Arguments.CLIOptions.LINUX_SHORTCUT_HINT;\n+import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_MENU_HINT;\n+import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_SHORTCUT_HINT;\n@@ -44,0 +47,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n@@ -46,0 +50,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n@@ -49,1 +54,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.getPredefinedAppImage;\n@@ -52,0 +56,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -59,0 +64,1 @@\n+import java.util.function.BiFunction;\n@@ -64,0 +70,1 @@\n+import jdk.jpackage.internal.model.ExternalApplication;\n@@ -66,0 +73,2 @@\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n@@ -67,0 +76,1 @@\n+import jdk.jpackage.internal.model.ParseUtils;\n@@ -72,1 +82,1 @@\n-    static ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n+    static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n@@ -74,0 +84,1 @@\n+            BiFunction<T, Launcher, T> launcherOverrideCtor,\n@@ -75,1 +86,1 @@\n-        return createApplicationBuilder(params, launcherMapper, appLayout, Optional.of(RuntimeLayout.DEFAULT));\n+        return createApplicationBuilder(params, launcherMapper, launcherOverrideCtor, appLayout, RuntimeLayout.DEFAULT, Optional.of(RuntimeLayout.DEFAULT));\n@@ -78,1 +89,1 @@\n-    static ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n+    static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n@@ -80,1 +91,3 @@\n-            ApplicationLayout appLayout, Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n+            BiFunction<T, Launcher, T> launcherOverrideCtor,\n+            ApplicationLayout appLayout, RuntimeLayout runtimeLayout,\n+            Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n@@ -100,1 +113,1 @@\n-            appBuilder.appImageLayout(predefinedRuntimeLayout.orElseThrow());\n+            appBuilder.appImageLayout(runtimeLayout);\n@@ -107,1 +120,1 @@\n-                    var launcherParams = mapLauncherInfo(launcherInfo);\n+                    var launcherParams = mapLauncherInfo(appImageFile, launcherInfo);\n@@ -115,1 +128,1 @@\n-                MODULE_PATH.copyInto(params, runtimeBuilderBuilder::modulePath);\n+                runtimeBuilderBuilder.modulePath(MODULE_PATH.fetchFrom(params));\n@@ -125,1 +138,1 @@\n-                    jlinkOptionsBuilder.appy();\n+                    jlinkOptionsBuilder.apply();\n@@ -128,1 +141,3 @@\n-                appBuilder.launchers(launchers).runtimeBuilder(runtimeBuilderBuilder.create());\n+                final var normalizedLaunchers = ApplicationBuilder.normalizeIcons(launchers, RESOURCE_DIR.findIn(params), launcherOverrideCtor);\n+\n+                appBuilder.launchers(normalizedLaunchers).runtimeBuilder(runtimeBuilderBuilder.create());\n@@ -146,1 +161,2 @@\n-        builder.predefinedAppImage(getPredefinedAppImage(params));\n+        PREDEFINED_APP_IMAGE.findIn(params).ifPresent(builder::predefinedAppImage);\n+        PREDEFINED_RUNTIME_IMAGE.findIn(params).ifPresent(builder::predefinedAppImage);\n@@ -167,0 +183,28 @@\n+    static Optional<LauncherShortcut> findLauncherShortcut(\n+            BundlerParamInfo<String> shortcutParam,\n+            Map<String, ? super Object> mainParams,\n+            Map<String, ? super Object> launcherParams) {\n+\n+        Optional<String> launcherValue;\n+        if (launcherParams == mainParams) {\n+            \/\/ The main launcher\n+            launcherValue = Optional.empty();\n+        } else {\n+            launcherValue = shortcutParam.findIn(launcherParams);\n+        }\n+\n+        return launcherValue.map(ParseUtils::parseLauncherShortcutForAddLauncher).or(() -> {\n+            return Optional.ofNullable(mainParams.get(shortcutParam.getID())).map(toFunction(value -> {\n+                if (value instanceof Boolean) {\n+                    return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n+                } else {\n+                    try {\n+                        return ParseUtils.parseLauncherShortcutForMainLauncher((String)value);\n+                    } catch (IllegalArgumentException ex) {\n+                        throw I18N.buildConfigException(\"error.invalid-option-value\", value, \"--\" + shortcutParam.getID()).create();\n+                    }\n+                }\n+            }));\n+        });\n+    }\n+\n@@ -180,1 +224,1 @@\n-    private static Map<String, ? super Object> mapLauncherInfo(LauncherInfo launcherInfo) {\n+    private static Map<String, ? super Object> mapLauncherInfo(ExternalApplication appImageFile, LauncherInfo launcherInfo) {\n@@ -183,1 +227,5 @@\n-        launcherParams.put(LAUNCHER_AS_SERVICE.getID(), Boolean.toString(launcherInfo.service()));\n+        if (!appImageFile.getLauncherName().equals(launcherInfo.name())) {\n+            \/\/ This is not the main launcher, accept the value\n+            \/\/ of \"launcher-as-service\" from the app image file (.jpackage.xml).\n+            launcherParams.put(LAUNCHER_AS_SERVICE.getID(), Boolean.toString(launcherInfo.service()));\n+        }\n@@ -197,2 +245,3 @@\n-        return AddLauncherArguments.merge(mainParams, launcherParams, ICON.getID(), ADD_LAUNCHERS\n-                .getID(), FILE_ASSOCIATIONS.getID());\n+        return AddLauncherArguments.merge(mainParams, launcherParams, ICON.getID(),\n+                ADD_LAUNCHERS.getID(), FILE_ASSOCIATIONS.getID(), WIN_MENU_HINT.getId(),\n+                WIN_SHORTCUT_HINT.getId(), LINUX_SHORTCUT_HINT.getId());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":64,"deletions":15,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.BufferedReader;\n-import java.io.InputStreamReader;\n@@ -48,1 +46,1 @@\n-        Files.createDirectories(getParent(destFile));\n+        Files.createDirectories(destFile.getParent());\n@@ -55,20 +53,0 @@\n-    public static boolean exists(Path path) {\n-        if (path == null) {\n-            return false;\n-        }\n-\n-        return Files.exists(path);\n-    }\n-\n-    \/\/ run \"launcher paramfile\" in the directory where paramfile is kept\n-    public static void run(String launcher, Path paramFile)\n-            throws IOException {\n-        if (IOUtils.exists(paramFile)) {\n-            ProcessBuilder pb =\n-                    new ProcessBuilder(launcher,\n-                        getFileName(paramFile).toString());\n-            pb = pb.directory(getParent(paramFile).toFile());\n-            exec(pb);\n-        }\n-    }\n-\n@@ -86,15 +64,0 @@\n-    \/\/ See JDK-8236282\n-    \/\/ Reading output from some processes (currently known \"hdiutil attach\")\n-    \/\/ might hang even if process already exited. Only possible workaround found\n-    \/\/ in \"hdiutil attach\" case is to redirect the output to a temp file and then\n-    \/\/ read this file back.\n-    public static void exec(ProcessBuilder pb, boolean writeOutputToFile)\n-            throws IOException {\n-        exec(pb, false, null, writeOutputToFile, Executor.INFINITE_TIMEOUT);\n-    }\n-\n-    static void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n-            PrintStream consumer) throws IOException {\n-        exec(pb, testForPresenceOnly, consumer, false, Executor.INFINITE_TIMEOUT);\n-    }\n-\n@@ -130,45 +93,0 @@\n-    public static int getProcessOutput(List<String> result, String... args)\n-            throws IOException, InterruptedException {\n-\n-        ProcessBuilder pb = new ProcessBuilder(args);\n-\n-        final Process p = pb.start();\n-\n-        List<String> list = new ArrayList<>();\n-\n-        final BufferedReader in =\n-                new BufferedReader(new InputStreamReader(p.getInputStream()));\n-        final BufferedReader err =\n-                new BufferedReader(new InputStreamReader(p.getErrorStream()));\n-\n-        Thread t = new Thread(() -> {\n-            try {\n-                String line;\n-                while ((line = in.readLine()) != null) {\n-                    list.add(line);\n-                }\n-            } catch (IOException ioe) {\n-                Log.verbose(ioe);\n-            }\n-\n-            try {\n-                String line;\n-                while ((line = err.readLine()) != null) {\n-                    Log.error(line);\n-                }\n-            } catch (IOException ioe) {\n-                  Log.verbose(ioe);\n-            }\n-        });\n-        t.setDaemon(true);\n-        t.start();\n-\n-        int ret = p.waitFor();\n-        Log.verbose(pb.command(), list, ret, IOUtils.getPID(p));\n-\n-        result.clear();\n-        result.addAll(list);\n-\n-        return ret;\n-    }\n-\n@@ -191,22 +109,0 @@\n-    public static Path getParent(Path p) {\n-        Path parent = p.getParent();\n-        if (parent == null) {\n-            IllegalArgumentException iae =\n-                    new IllegalArgumentException(p.toString());\n-            Log.verbose(iae);\n-            throw iae;\n-        }\n-        return parent;\n-    }\n-\n-    public static Path getFileName(Path p) {\n-        Path filename = p.getFileName();\n-        if (filename == null) {\n-            IllegalArgumentException iae =\n-                    new IllegalArgumentException(p.toString());\n-            Log.verbose(iae);\n-            throw iae;\n-        }\n-        return filename;\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":1,"deletions":105,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n@@ -28,0 +29,1 @@\n+import java.io.IOException;\n@@ -35,0 +37,1 @@\n+import java.nio.file.Files;\n@@ -64,1 +67,1 @@\n-    public void createRuntime(AppImageLayout appImageLayout) throws PackagerException {\n+    public void create(AppImageLayout appImageLayout) throws PackagerException {\n@@ -96,0 +99,46 @@\n+    \/**\n+     * Returns a list of paths that includes the location where the \"java.base\"\n+     * module can be found.\n+     * <p>\n+     * Returns the specified path list if \"java.base\" module can be found in one of\n+     * the paths from the specified path list.\n+     * <p>\n+     * Returns a new path list created from the specified path list with the path of\n+     * \"java.base\" module in the current runtime appended otherwise.\n+     *\n+     * @param modulePath the path list where to look up for \"java.base\" module\n+     * @return the path list that includes location of \"java.base\" module\n+     *\/\n+    static List<Path> ensureBaseModuleInModulePath(List<Path> modulePath) {\n+        if (modulePath.stream().anyMatch(path -> {\n+            return Files.isRegularFile(path.resolve(\"java.base.jmod\"));\n+        })) {\n+            return modulePath;\n+        } else {\n+            \/\/ There is no \"java.base.jmod\" file in the `modulePath` path list.\n+            \/\/ Pick items from the default module path list that are not yet\n+            \/\/ in the `modulePath` path list and append them to it.\n+\n+            var missingDefaultModulePath = getDefaultModulePath();\n+\n+            if (!modulePath.isEmpty()) {\n+                missingDefaultModulePath.stream().filter(defaultPath -> {\n+                    return modulePath.stream().anyMatch(path -> {\n+                        try {\n+                            return Files.isSameFile(path, defaultPath);\n+                        } catch (IOException ex) {\n+                            \/\/ Assume `defaultPath` path doesn't exist in `modulePath` list.\n+                            return false;\n+                        }\n+                    });\n+                }).toList();\n+            }\n+\n+            if (missingDefaultModulePath.isEmpty()) {\n+                return modulePath;\n+            } else {\n+                return Stream.of(modulePath, missingDefaultModulePath).flatMap(Collection::stream).toList();\n+            }\n+        }\n+    }\n+\n@@ -218,1 +267,1 @@\n-        return strings.stream().collect(Collectors.joining(\",\"));\n+        return strings.stream().sorted().collect(Collectors.joining(\",\"));\n@@ -233,1 +282,1 @@\n-    };\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":52,"deletions":3,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import jdk.jpackage.internal.model.DefaultLauncherIcon;\n@@ -41,0 +43,1 @@\n+import jdk.jpackage.internal.util.PathUtils;\n@@ -43,0 +46,1 @@\n+import jdk.jpackage.internal.model.ResourceDirLauncherIcon;\n@@ -113,0 +117,9 @@\n+    static OverridableResource createLauncherIconResource(Launcher launcher,\n+            Function<String, OverridableResource> resourceSupplier) {\n+\n+        var defaultIconResourceName = launcher.defaultIconResourceName();\n+        return resourceSupplier.apply(defaultIconResourceName)\n+                    .setPublicName(launcher.executableName() + PathUtils.getSuffix(Path.of(defaultIconResourceName)))\n+                    .setCategory(\"icon\");\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherBuilder.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.io.UncheckedIOException;\n@@ -41,1 +42,1 @@\n-import java.util.List;\n+import java.util.LinkedHashMap;\n@@ -45,1 +46,1 @@\n-import java.util.function.Supplier;\n+import java.util.function.Function;\n@@ -75,1 +76,1 @@\n-        defaultResourceSupplier = null;\n+        defaultResourceGetter = null;\n@@ -80,1 +81,1 @@\n-            Supplier<InputStream> defaultResourceSupplier) {\n+            Function<String, InputStream> defaultResourceGetter) {\n@@ -82,1 +83,1 @@\n-        this.defaultResourceSupplier = Objects.requireNonNull(defaultResourceSupplier);\n+        this.defaultResourceGetter = Objects.requireNonNull(defaultResourceGetter);\n@@ -87,3 +88,1 @@\n-        this(defaultName, () -> {\n-            return resourceLocator.getResourceAsStream(defaultName);\n-        });\n+        this(defaultName, resourceLocator::getResourceAsStream);\n@@ -139,1 +138,1 @@\n-    enum Source { External, ResourceDir, DefaultResource };\n+    enum Source { External, ResourceDir, DefaultResource }\n@@ -142,3 +141,3 @@\n-        sources = Stream.of(v)\n-                .map(source -> Map.entry(source, getHandler(source)))\n-                .toList();\n+        sources = Stream.of(v).collect(Collectors.toMap(x -> x, this::getHandler, (a, b) -> {\n+            throw new IllegalStateException();\n+        }, LinkedHashMap::new));\n@@ -185,0 +184,9 @@\n+    Source probe() {\n+        try {\n+            return saveToStream(null);\n+        } catch (IOException ex) {\n+            \/\/ Should never happen.\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n@@ -229,1 +237,1 @@\n-        for (var source: sources) {\n+        for (var source: sources.entrySet()) {\n@@ -234,0 +242,5 @@\n+\n+        if (!sources.containsKey(Source.DefaultResource)) {\n+            noDefault(consumer);\n+        }\n+\n@@ -265,2 +278,1 @@\n-        final Path resourceName = Optional.ofNullable(publicName).orElseGet(\n-                () -> dest.publicName());\n+        final Path resourceName = resourceName(dest);\n@@ -292,3 +304,3 @@\n-                    .orElse(Optional\n-                            .ofNullable(publicName)\n-                            .orElseGet(() -> dest.publicName()));\n+                    .orElseGet(() -> {\n+                        return resourceName(dest);\n+                    });\n@@ -298,1 +310,1 @@\n-            try (InputStream in = defaultResourceSupplier.get()) {\n+            try (InputStream in = defaultResourceGetter.apply(defaultName)) {\n@@ -305,0 +317,18 @@\n+    private void noDefault(ResourceConsumer dest) {\n+        if (dest != null) {\n+            final Path resourceName = Optional\n+                    .ofNullable(logPublicName)\n+                    .orElseGet(() -> {\n+                        return resourceName(dest);\n+                    });\n+            Log.verbose(I18N.format(\"message.no-default-resource\",\n+                    getPrintableCategory(), resourceName));\n+        }\n+    }\n+\n+    private Path resourceName(ResourceConsumer dest) {\n+        return Optional.ofNullable(publicName).orElseGet(() -> {\n+            return dest.publicName();\n+        });\n+    }\n+\n@@ -389,2 +419,2 @@\n-    private final Supplier<InputStream> defaultResourceSupplier;\n-    private List<Map.Entry<Source, SourceHandler>> sources;\n+    private final Function<String, InputStream> defaultResourceGetter;\n+    private Map<Source, SourceHandler> sources;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/OverridableResource.java","additions":51,"deletions":21,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -89,0 +90,1 @@\n+                validatedInstalledPackageLayout(relativeInstallDir),\n@@ -92,0 +94,9 @@\n+    PackageBuilder app(Application v) {\n+        app = v;\n+        return this;\n+    }\n+\n+    Application app() {\n+        return app;\n+    }\n+\n@@ -172,0 +183,9 @@\n+    PackageBuilder installedPackageLayout(AppImageLayout v) {\n+        installedPackageLayout = v;\n+        return this;\n+    }\n+\n+    Optional<AppImageLayout> installedPackageLayout() {\n+        return Optional.ofNullable(installedPackageLayout);\n+    }\n+\n@@ -176,0 +196,15 @@\n+    private AppImageLayout validatedInstalledPackageLayout(Path relativeInstallDir) {\n+        return installedPackageLayout().orElseGet(() -> {\n+            var theInstallDir = relativeInstallDir;\n+            if (type instanceof StandardPackageType stdType) {\n+                switch (stdType) {\n+                    case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n+                        theInstallDir = Path.of(\"\/\").resolve(theInstallDir);\n+                    }\n+                    default -> {}\n+                }\n+            }\n+            return app.imageLayout().resolveAt(theInstallDir).resetRootDirectory();\n+        });\n+    }\n+\n@@ -238,0 +273,1 @@\n+    private Application app;\n@@ -246,0 +282,1 @@\n+    private AppImageLayout installedPackageLayout;\n@@ -248,1 +285,0 @@\n-    private final Application app;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackageBuilder.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackagerException;\n+\n+final class Packager<T extends Package> {\n+\n+    static <T extends Package> Packager<T> build() {\n+        return new Packager<>();\n+    }\n+\n+    Packager<T> pkg(T v) {\n+        pkg = v;\n+        return this;\n+    }\n+\n+    Packager<T> env(BuildEnv v) {\n+        env = v;\n+        return this;\n+    }\n+\n+    Packager<T> outputDir(Path v) {\n+        outputDir = v;\n+        return this;\n+    }\n+\n+    Packager<T> pipelineBuilderMutatorFactory(PipelineBuilderMutatorFactory<T> v) {\n+        pipelineBuilderMutatorFactory = v;\n+        return this;\n+    }\n+\n+    T pkg() {\n+        return Objects.requireNonNull(pkg);\n+    }\n+\n+    Path outputDir() {\n+        return Objects.requireNonNull(outputDir);\n+    }\n+\n+    BuildEnv env() {\n+        return Objects.requireNonNull(env);\n+    }\n+\n+    Path execute(PackagingPipeline.Builder pipelineBuilder) throws PackagerException {\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(outputDir);\n+\n+        IOUtils.writableOutputDir(outputDir);\n+\n+        final var startupParameters = pipelineBuilder.createStartupParameters(env, pkg, outputDir);\n+\n+        pipelineBuilderMutatorFactory().ifPresent(factory -> {\n+            factory.create(startupParameters.packagingEnv(), pkg, outputDir).accept(pipelineBuilder);\n+        });\n+\n+        pipelineBuilder.create().execute(startupParameters);\n+\n+        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n+    }\n+\n+\n+    @FunctionalInterface\n+    interface PipelineBuilderMutatorFactory<T extends Package> {\n+        Consumer<PackagingPipeline.Builder> create(BuildEnv env, T pkg, Path outputDir);\n+    }\n+\n+\n+    private Optional<PipelineBuilderMutatorFactory<T>> pipelineBuilderMutatorFactory() {\n+        return Optional.ofNullable(pipelineBuilderMutatorFactory);\n+    }\n+\n+    private T pkg;\n+    private BuildEnv env;\n+    private Path outputDir;\n+    private PipelineBuilderMutatorFactory<T> pipelineBuilderMutatorFactory;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Packager.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-abstract class PackagerBuilder<T extends Package, U extends PackagerBuilder<T, U>> {\n-\n-    U pkg(T v) {\n-        pkg = v;\n-        return thiz();\n-    }\n-\n-    U env(BuildEnv v) {\n-        env = v;\n-        return thiz();\n-    }\n-\n-    U outputDir(Path v) {\n-        outputDir = v;\n-        return thiz();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private U thiz() {\n-        return (U)this;\n-    }\n-\n-    protected abstract void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n-            StartupParameters startupParameters);\n-\n-    Path execute(PackagingPipeline.Builder pipelineBuilder) throws PackagerException {\n-        Objects.requireNonNull(pkg);\n-        Objects.requireNonNull(env);\n-        Objects.requireNonNull(outputDir);\n-\n-        final var startupParameters = pipelineBuilder.createStartupParameters(env, pkg, outputDir);\n-\n-        configurePackagingPipeline(pipelineBuilder, startupParameters);\n-\n-        pipelineBuilder.create().execute(startupParameters);\n-\n-        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n-    }\n-\n-    protected T pkg;\n-    protected BuildEnv env;\n-    protected Path outputDir;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagerBuilder.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -41,1 +42,0 @@\n-import java.util.function.Function;\n@@ -44,0 +44,1 @@\n+import java.util.stream.Stream;\n@@ -58,0 +59,6 @@\n+    \/**\n+     * Runs the pipeline for the given application.\n+     *\n+     * @param env the build environment\n+     * @param app the application\n+     *\/\n@@ -59,3 +66,18 @@\n-        execute(appContextMapper.apply(createTaskContext(env, app)));\n-    }\n-\n+        execute(contextMapper.apply(createTaskContext(env, app)));\n+    }\n+\n+    \/**\n+     * Runs the pipeline for the given package.\n+     * <p>\n+     * Building a package may require a directory where the app image bits will be\n+     * accumulated or the existing app image may be used. The decision is made based\n+     * on the properties of the given package. A new build environment will be\n+     * created if an intermediate directory is required. To access the build\n+     * environment that will be used by the pipeline before running the pipeline\n+     * create {@link StartupParameters} instance using\n+     * {@link Builder#createStartupParameters(BuildEnv, Package, Path)} method.\n+     *\n+     * @param env       the build environment\n+     * @param pkg       the package\n+     * @param outputDir the output directory for the package file\n+     *\/\n@@ -63,2 +85,1 @@\n-        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir,\n-                taskConfig, appImageLayoutForPackaging.apply(pkg)));\n+        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir, taskConfig));\n@@ -67,0 +88,6 @@\n+    \/**\n+     * Runs the pipeline using the startup parameters created with\n+     * {@link Builder#createStartupParameters(BuildEnv, Package, Path)} call.\n+     *\n+     * @param startupParameters the pipeline startup parameters\n+     *\/\n@@ -68,1 +95,1 @@\n-        execute(pkgContextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n+        execute(contextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n@@ -71,0 +98,3 @@\n+    \/**\n+     * The way to access packaging build environment before building a package in a pipeline.\n+     *\/\n@@ -108,1 +138,6 @@\n-    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app, U envLayout) {\n+    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app) {\n+        @SuppressWarnings(\"unchecked\")\n+        U envLayout() {\n+            return (U)app.imageLayout();\n+        }\n+\n@@ -111,1 +146,1 @@\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+            return (U)env.appImageLayout();\n@@ -115,1 +150,1 @@\n-    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, U envLayout, Path outputDir) {\n+    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, Path outputDir) {\n@@ -117,2 +152,2 @@\n-        U resolvedLayout() {\n-            return (U)envLayout.resolveAt(env.appImageDir());\n+        U envLayout() {\n+            return (U)pkg.appImageLayout();\n@@ -121,2 +156,3 @@\n-        AppImageBuildEnv<Application, U> appImageBuildEnv() {\n-            return new AppImageBuildEnv<>(env, pkg.app(), envLayout);\n+        @SuppressWarnings(\"unchecked\")\n+        U resolvedLayout() {\n+            return (U)env.appImageLayout();\n@@ -138,1 +174,1 @@\n-        void execute(T pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException, PackagerException;\n+        void execute(T pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException, PackagerException;\n@@ -168,0 +204,5 @@\n+            private TaskBuilder(TaskID id, TaskConfig config) {\n+                this(id);\n+                config.action().ifPresent(this::setAction);\n+            }\n+\n@@ -198,0 +239,4 @@\n+            boolean hasAction() {\n+                return action != null;\n+            }\n+\n@@ -256,0 +301,6 @@\n+        Stream<TaskBuilder> configuredTasks() {\n+            return taskConfig.entrySet().stream().map(e -> {\n+                return new TaskBuilder(e.getKey(), e.getValue());\n+            });\n+        }\n+\n@@ -263,17 +314,1 @@\n-            appContextMapper(v);\n-            pkgContextMapper(v);\n-            return this;\n-        }\n-\n-        Builder appContextMapper(UnaryOperator<TaskContext> v) {\n-            appContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder pkgContextMapper(UnaryOperator<TaskContext> v) {\n-            pkgContextMapper = v;\n-            return this;\n-        }\n-\n-        Builder appImageLayoutForPackaging(Function<Package, AppImageLayout> v) {\n-            appImageLayoutForPackaging = v;\n+            contextMapper = v;\n@@ -291,6 +326,1 @@\n-            return createPackagingTaskContext(env, pkg, outputDir, taskConfig,\n-                    validatedAppImageLayoutForPackaging().apply(pkg));\n-        }\n-\n-        private Function<Package, AppImageLayout> validatedAppImageLayoutForPackaging() {\n-            return Optional.ofNullable(appImageLayoutForPackaging).orElse(Package::packageLayout);\n+            return createPackagingTaskContext(env, pkg, outputDir, taskConfig);\n@@ -301,3 +331,1 @@\n-                    Optional.ofNullable(appContextMapper).orElse(UnaryOperator.identity()),\n-                    Optional.ofNullable(pkgContextMapper).orElse(UnaryOperator.identity()),\n-                    validatedAppImageLayoutForPackaging());\n+                    Optional.ofNullable(contextMapper).orElse(UnaryOperator.identity()));\n@@ -309,3 +337,1 @@\n-        private UnaryOperator<TaskContext> appContextMapper;\n-        private UnaryOperator<TaskContext> pkgContextMapper;\n-        private Function<Package, AppImageLayout> appImageLayoutForPackaging;\n+        private UnaryOperator<TaskContext> contextMapper;\n@@ -377,1 +403,1 @@\n-    static void copyAppImage(Package pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException {\n+    static void copyAppImage(Package pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException {\n@@ -381,1 +407,1 @@\n-    static void copyAppImage(AppImageDesc srcAppImage, AppImageDesc dstAppImage,\n+    static void copyAppImage(AppImageLayout srcAppImage, AppImageLayout dstAppImage,\n@@ -383,2 +409,1 @@\n-        final var srcLayout = srcAppImage.resolvedAppImagelayout();\n-        final var srcLayoutPathGroup = AppImageLayout.toPathGroup(srcLayout);\n+        final var srcLayoutPathGroup = toPathGroup(srcAppImage);\n@@ -386,1 +411,1 @@\n-        if (removeAppImageFile && srcLayout instanceof ApplicationLayout appLayout) {\n+        if (removeAppImageFile && srcAppImage instanceof ApplicationLayout appLayout) {\n@@ -391,1 +416,1 @@\n-        srcLayoutPathGroup.copy(AppImageLayout.toPathGroup(dstAppImage.resolvedAppImagelayout()), LinkOption.NOFOLLOW_LINKS);\n+        srcLayoutPathGroup.copy(toPathGroup(dstAppImage), LinkOption.NOFOLLOW_LINKS);\n@@ -405,2 +430,1 @@\n-            UnaryOperator<TaskContext> appContextMapper, UnaryOperator<TaskContext> pkgContextMapper,\n-            Function<Package, AppImageLayout> appImageLayoutForPackaging) {\n+            UnaryOperator<TaskContext> contextMapper) {\n@@ -409,3 +433,1 @@\n-        this.appContextMapper = Objects.requireNonNull(appContextMapper);\n-        this.pkgContextMapper = Objects.requireNonNull(pkgContextMapper);\n-        this.appImageLayoutForPackaging = Objects.requireNonNull(appImageLayoutForPackaging);\n+        this.contextMapper = Objects.requireNonNull(contextMapper);\n@@ -415,1 +437,1 @@\n-        return new DefaultTaskContext(taskGraph, env, app, app.asApplicationLayout(), Optional.empty());\n+        return new DefaultTaskContext(taskGraph, env, app, Optional.empty());\n@@ -419,3 +441,2 @@\n-        final var pkgEnv = BuildEnv.withAppImageDir(packagingContext.env.env(), packagingContext.srcAppImage.path());\n-        return new DefaultTaskContext(taskGraph, pkgEnv, packagingContext.env.pkg.app(),\n-                packagingContext.srcAppImage.asApplicationLayout(), Optional.of(packagingContext));\n+        return new DefaultTaskContext(taskGraph, packagingContext.env(),\n+                packagingContext.pkg().app(), Optional.of(packagingContext));\n@@ -425,1 +446,1 @@\n-            Path outputDir, Map<TaskID, TaskConfig> taskConfig, AppImageLayout appImageLayoutForPackaging) {\n+            Path outputDir, Map<TaskID, TaskConfig> taskConfig) {\n@@ -430,1 +451,3 @@\n-        Objects.requireNonNull(appImageLayoutForPackaging);\n+        if (pkg.appImageLayout().isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -432,2 +455,2 @@\n-        final AppImageDesc srcAppImageDesc;\n-        final AppImageDesc dstAppImageDesc;\n+        final AppImageLayout srcLayout;\n+        final AppImageLayout dstLayout;\n@@ -436,3 +459,2 @@\n-            \/\/ appImageDir() should point to a directory where the application image will be created.\n-            srcAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.appImageDir());\n-            dstAppImageDesc = srcAppImageDesc;\n+            srcLayout = pkg.appImageLayout().resolveAt(env.appImageDir());\n+            dstLayout = srcLayout;\n@@ -440,1 +462,8 @@\n-            srcAppImageDesc = new AppImageDesc(pkg.app().imageLayout(), pkg.predefinedAppImage().orElseGet(() -> {\n+            srcLayout = pkg.predefinedAppImage().map(predefinedAppImage -> {\n+                \/\/ Will create a package from the predefined app image.\n+                if (predefinedAppImage.equals(env.appImageDir())) {\n+                    return env.appImageLayout();\n+                } else {\n+                    return pkg.appImageLayout().resolveAt(predefinedAppImage);\n+                }\n+            }).orElseGet(() -> {\n@@ -444,1 +473,1 @@\n-                    return env.appImageDir();\n+                    return env.appImageLayout();\n@@ -449,1 +478,1 @@\n-            }));\n+            });\n@@ -452,3 +481,3 @@\n-                \/\/ \"copy app image\" task action is undefined indicating\n-                \/\/ the package will use provided app image as-is.\n-                dstAppImageDesc = srcAppImageDesc;\n+                \/\/ \"copy app image\" task action is empty indicating\n+                \/\/ the package will use provided app image in place.\n+                dstLayout = srcLayout;\n@@ -456,1 +485,1 @@\n-                dstAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.buildRoot().resolve(\"image\"));\n+                dstLayout = pkg.appImageLayout().resolveAt(env.buildRoot().resolve(\"image\"));\n@@ -460,4 +489,1 @@\n-        final var pkgEnv = new PackageBuildEnv<>(\n-                BuildEnv.withAppImageDir(env, dstAppImageDesc.path()), pkg, dstAppImageDesc.appImageLayout(), outputDir);\n-\n-        return new PackagingTaskContext(pkgEnv, srcAppImageDesc);\n+        return new PackagingTaskContext(BuildEnv.withAppImageLayout(env, dstLayout), pkg, outputDir, srcLayout);\n@@ -481,0 +507,6 @@\n+        } catch (ExceptionBox ex) {\n+            throw new PackagerException(ex.getCause());\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (PackagerException ex) {\n+            throw ex;\n@@ -482,7 +514,1 @@\n-            if (ex instanceof PackagerException pex) {\n-                throw pex;\n-            } else if (ex instanceof ExceptionBox bex) {\n-                throw new PackagerException(bex.getCause());\n-            } else {\n-                throw new PackagerException(ex);\n-            }\n+            throw new PackagerException(ex);\n@@ -492,2 +518,2 @@\n-    private record PackagingTaskContext(PackageBuildEnv<Package, AppImageLayout> env,\n-            AppImageDesc srcAppImage) implements TaskContext, StartupParameters {\n+    private record PackagingTaskContext(BuildEnv env, Package pkg, Path outputDir,\n+            AppImageLayout srcAppImage) implements TaskContext, StartupParameters {\n@@ -497,0 +523,2 @@\n+            Objects.requireNonNull(pkg);\n+            Objects.requireNonNull(outputDir);\n@@ -502,1 +530,1 @@\n-            return env.env;\n+            return env;\n@@ -519,1 +547,1 @@\n-                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(env);\n+                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(pkgBuildEnv());\n@@ -521,2 +549,2 @@\n-                ((CopyAppImageTaskAction<Package>)taskAction).execute(env.pkg(),\n-                        srcAppImage, new AppImageDesc(env.envLayout(), env.env().appImageDir()));\n+                ((CopyAppImageTaskAction<Package>)taskAction).execute(pkg(),\n+                        srcAppImage, env.appImageLayout());\n@@ -529,1 +557,5 @@\n-            return env.appImageBuildEnv();\n+            return new AppImageBuildEnv<>(env, pkg.app());\n+        }\n+\n+        PackageBuildEnv<Package, AppImageLayout> pkgBuildEnv() {\n+            return new PackageBuildEnv<>(env, pkg, outputDir);\n@@ -534,1 +566,1 @@\n-            Optional<ApplicationLayout> appLayout, Optional<PackagingTaskContext> pkg) implements TaskContext {\n+            Optional<PackagingTaskContext> pkg) implements TaskContext {\n@@ -540,1 +572,0 @@\n-            Objects.requireNonNull(appLayout);\n@@ -552,2 +583,2 @@\n-            } else if (pkg.isEmpty() && isPackageTask) {\n-                \/\/ Building application image, skip packaging tasks.\n+            } else if (pkg.isEmpty() && (isPackageTask || isCopyAppImageTask)) {\n+                \/\/ Building application image, skip packaging and copying app image tasks.\n@@ -555,2 +586,2 @@\n-            } else if (app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n-                \/\/ Runtime builder is not present, skip building application image tasks.\n+            } else if (pkg.isPresent() && app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n+                \/\/ Building a package, runtime builder is not present, skip building application image tasks.\n@@ -577,1 +608,1 @@\n-                pkg.orElseThrow().execute(taskAction);\n+                pkg.orElseThrow(UnsupportedOperationException::new).execute(taskAction);\n@@ -593,1 +624,1 @@\n-            return new AppImageBuildEnv<>(env, app, (T)appLayout.orElseThrow());\n+            return new AppImageBuildEnv<>(env, app);\n@@ -603,5 +634,1 @@\n-                try {\n-                    context.execute(config.action.orElseThrow());\n-                } catch (ExceptionBox ex) {\n-                    throw ExceptionBox.rethrowUnchecked(ex);\n-                }\n+                context.execute(config.action.orElseThrow());\n@@ -615,3 +642,1 @@\n-    private final Function<Package, AppImageLayout> appImageLayoutForPackaging;\n-    private final UnaryOperator<TaskContext> appContextMapper;\n-    private final UnaryOperator<TaskContext> pkgContextMapper;\n+    private final UnaryOperator<TaskContext> contextMapper;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":132,"deletions":107,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import static jdk.jpackage.internal.I18N.buildConfigException;\n@@ -33,1 +32,0 @@\n-import java.nio.file.Files;\n@@ -79,1 +77,1 @@\n-        RuntimeBuilderBuilder appy() {\n+        RuntimeBuilderBuilder apply() {\n@@ -119,9 +117,0 @@\n-        if (!Files.exists(runtimeDir)) {\n-            throw buildConfigException()\n-                    .message(\"message.runtime-image-dir-does-not-exist\",\n-                            \"--runtime-image\", runtimeDir)\n-                    .advice(\"message.runtime-image-dir-does-not-exist.advice\",\n-                            \"--runtime-image\")\n-                    .create();\n-        }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/RuntimeBuilderBuilder.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n@@ -59,1 +58,0 @@\n-    private static final String JAVABASEJMOD = \"java.base.jmod\";\n@@ -97,0 +95,7 @@\n+    static final BundlerParamInfo<Path> PREDEFINED_APP_IMAGE =\n+            new BundlerParamInfo<>(\n+            Arguments.CLIOptions.PREDEFINED_APP_IMAGE.getId(),\n+            Path.class,\n+            params -> null,\n+            (s, p) -> Path.of(s));\n+\n@@ -100,1 +105,1 @@\n-                    var appImage = getPredefinedAppImage(params);\n+                    var appImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n@@ -130,7 +135,0 @@\n-    static final BundlerParamInfo<Path> PREDEFINED_APP_IMAGE =\n-            new BundlerParamInfo<>(\n-            Arguments.CLIOptions.PREDEFINED_APP_IMAGE.getId(),\n-            Path.class,\n-            params -> null,\n-            (s, p) -> Path.of(s));\n-\n@@ -310,18 +308,0 @@\n-    static final BundlerParamInfo<Boolean> SHORTCUT_HINT  =\n-            new BundlerParamInfo<>(\n-                    \"shortcut-hint\", \/\/ not directly related to a CLI option\n-                    Boolean.class,\n-                    params -> true,  \/\/ defaults to true\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n-    static final BundlerParamInfo<Boolean> MENU_HINT  =\n-            new BundlerParamInfo<>(\n-                    \"menu-hint\", \/\/ not directly related to a CLI option\n-                    Boolean.class,\n-                    params -> true,  \/\/ defaults to true\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n@@ -436,1 +416,1 @@\n-                    p -> getDefaultModulePath(),\n+                    p -> JLinkRuntimeBuilder.ensureBaseModuleInModulePath(List.of()),\n@@ -441,20 +421,1 @@\n-                        Path javaBasePath = findPathOfModule(modulePath, JAVABASEJMOD);\n-\n-                        \/\/ Add the default JDK module path to the module path.\n-                        if (javaBasePath == null) {\n-                            List<Path> jdkModulePath = getDefaultModulePath();\n-\n-                            if (jdkModulePath != null) {\n-                                modulePath = Stream.concat(modulePath.stream(),\n-                                        jdkModulePath.stream()).toList();\n-                                javaBasePath = findPathOfModule(modulePath, JAVABASEJMOD);\n-                            }\n-                        }\n-\n-                        if (javaBasePath == null ||\n-                                !Files.exists(javaBasePath)) {\n-                            Log.error(String.format(I18N.getString(\n-                                    \"warning.no.jdk.modules.found\")));\n-                        }\n-\n-                        return modulePath;\n+                        return JLinkRuntimeBuilder.ensureBaseModuleInModulePath(modulePath);\n@@ -463,14 +424,0 @@\n-    \/\/ Returns the path to the JDK modules in the user defined module path.\n-    private static Path findPathOfModule( List<Path> modulePath, String moduleName) {\n-\n-        for (Path path : modulePath) {\n-            Path moduleNamePath = path.resolve(moduleName);\n-\n-            if (Files.exists(moduleNamePath)) {\n-                return path;\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n@@ -536,12 +483,0 @@\n-    static Path getPredefinedAppImage(Map<String, ? super Object> params) {\n-        Path applicationImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n-        if (applicationImage != null && !IOUtils.exists(applicationImage)) {\n-            throw new RuntimeException(\n-                    MessageFormat.format(I18N.getString(\n-                            \"message.app-image-dir-does-not-exist\"),\n-                            PREDEFINED_APP_IMAGE.getID(),\n-                            applicationImage.toString()));\n-        }\n-        return applicationImage;\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":10,"deletions":75,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package jdk.jpackage.internal.model;\n+package jdk.jpackage.internal;\n@@ -27,4 +27,1 @@\n-\/**\n- * Application launcher icon.\n- *\/\n-public interface LauncherIcon {\n+public interface SystemEnvironment {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/SystemEnvironment.java","additions":2,"deletions":5,"binary":false,"changes":7,"previous_filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherIcon.java","status":"copied"},{"patch":"@@ -27,3 +27,0 @@\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.DottedVersion;\n@@ -31,0 +28,1 @@\n+import java.nio.file.Files;\n@@ -32,1 +30,0 @@\n-import java.text.MessageFormat;\n@@ -35,1 +32,1 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.Objects;\n@@ -39,0 +36,3 @@\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -41,1 +41,1 @@\n-public final class ToolValidator {\n+final class ToolValidator {\n@@ -48,3 +48,1 @@\n-        this.toolPath = toolPath;\n-        args = new ArrayList<>();\n-\n+        this.toolPath = Objects.requireNonNull(toolPath);\n@@ -54,3 +52,0 @@\n-\n-        setToolNotFoundErrorHandler(null);\n-        setToolOldVersionErrorHandler(null);\n@@ -70,1 +65,11 @@\n-        return setMinimalVersion(t -> DottedVersion.compareComponents(v, DottedVersion.lazy(t)));\n+        return setMinimalVersion(new Comparable<String>() {\n+            @Override\n+            public int compareTo(String o) {\n+                return DottedVersion.compareComponents(v, DottedVersion.lazy(o));\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return v.toString();\n+            }\n+        });\n@@ -78,2 +83,1 @@\n-    ToolValidator setToolNotFoundErrorHandler(\n-            BiFunction<String, IOException, ConfigException> v) {\n+    ToolValidator setToolNotFoundErrorHandler(Function<Path, ConfigException> v) {\n@@ -84,1 +88,1 @@\n-    ToolValidator setToolOldVersionErrorHandler(BiFunction<String, String, ConfigException> v) {\n+    ToolValidator setToolOldVersionErrorHandler(BiFunction<Path, String, ConfigException> v) {\n@@ -89,0 +93,9 @@\n+    ToolValidator checkExistsOnly(boolean v) {\n+        checkExistsOnly = v;\n+        return this;\n+    }\n+\n+    ToolValidator checkExistsOnly() {\n+        return checkExistsOnly(true);\n+    }\n+\n@@ -90,0 +103,15 @@\n+        if (checkExistsOnly) {\n+            if (Files.isExecutable(toolPath) && !Files.isDirectory(toolPath)) {\n+                return null;\n+            } else if (Files.exists(toolPath)) {\n+                return new ConfigException(\n+                        I18N.format(\"error.tool-not-executable\", toolPath), (String)null);\n+            } else if (toolNotFoundErrorHandler != null) {\n+                return toolNotFoundErrorHandler.apply(toolPath);\n+            } else {\n+                return new ConfigException(\n+                        I18N.format(\"error.tool-not-found\", toolPath),\n+                        I18N.format(\"error.tool-not-found.advice\", toolPath));\n+            }\n+        }\n+\n@@ -92,1 +120,3 @@\n-        cmdline.addAll(args);\n+        if (args != null) {\n+            cmdline.addAll(args);\n+        }\n@@ -94,8 +124,5 @@\n-        String name = IOUtils.getFileName(toolPath).toString();\n-        try {\n-            ProcessBuilder pb = new ProcessBuilder(cmdline);\n-            AtomicBoolean canUseTool = new AtomicBoolean();\n-            if (minimalVersion == null) {\n-                \/\/ No version check.\n-                canUseTool.setPlain(true);\n-            }\n+        boolean canUseTool[] = new boolean[1];\n+        if (minimalVersion == null) {\n+            \/\/ No version check.\n+            canUseTool[0] = true;\n+        }\n@@ -103,2 +130,4 @@\n-            String[] version = new String[1];\n-            Executor.of(pb).setQuiet(true).setOutputConsumer(lines -> {\n+        String[] version = new String[1];\n+\n+        try {\n+            Executor.of(cmdline.toArray(String[]::new)).setQuiet(true).setOutputConsumer(lines -> {\n@@ -107,2 +136,2 @@\n-                    if (minimalVersion.compareTo(version[0]) < 0) {\n-                        canUseTool.setPlain(true);\n+                    if (version[0] != null && minimalVersion.compareTo(version[0]) <= 0) {\n+                        canUseTool[0] = true;\n@@ -112,11 +141,0 @@\n-\n-            if (!canUseTool.getPlain()) {\n-                if (toolOldVersionErrorHandler != null) {\n-                    return toolOldVersionErrorHandler.apply(name, version[0]);\n-                }\n-                return new ConfigException(MessageFormat.format(I18N.getString(\n-                        \"error.tool-old-version\"), name, minimalVersion),\n-                        MessageFormat.format(I18N.getString(\n-                                \"error.tool-old-version.advice\"), name,\n-                                minimalVersion));\n-            }\n@@ -124,7 +142,1 @@\n-            if (toolNotFoundErrorHandler != null) {\n-                return toolNotFoundErrorHandler.apply(name, e);\n-            }\n-            return new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.tool-not-found\"), name, e.getMessage()),\n-                    MessageFormat.format(I18N.getString(\n-                            \"error.tool-not-found.advice\"), name), e);\n+            return new ConfigException(I18N.format(\"error.tool-error\", toolPath, e.getMessage()), null, e);\n@@ -133,2 +145,10 @@\n-        \/\/ All good. Tool can be used.\n-        return null;\n+        if (canUseTool[0]) {\n+            \/\/ All good. Tool can be used.\n+            return null;\n+        } else if (toolOldVersionErrorHandler != null) {\n+            return toolOldVersionErrorHandler.apply(toolPath, version[0]);\n+        } else {\n+            return new ConfigException(\n+                    I18N.format(\"error.tool-old-version\", toolPath, minimalVersion),\n+                    I18N.format(\"error.tool-old-version.advice\", toolPath, minimalVersion));\n+        }\n@@ -141,2 +161,3 @@\n-    private BiFunction<String, IOException, ConfigException> toolNotFoundErrorHandler;\n-    private BiFunction<String, String, ConfigException> toolOldVersionErrorHandler;\n+    private Function<Path, ConfigException> toolNotFoundErrorHandler;\n+    private BiFunction<Path, String, ConfigException> toolOldVersionErrorHandler;\n+    private boolean checkExistsOnly;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ToolValidator.java","additions":72,"deletions":51,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -32,0 +35,1 @@\n+import java.util.Objects;\n@@ -33,0 +37,1 @@\n+import java.util.function.UnaryOperator;\n@@ -35,2 +40,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n@@ -44,3 +47,8 @@\n- *\n- * The layout is \"unresolved\" if the root directory is an empty string and\n- * \"resolved\" otherwise.\n+ * <p>\n+ * The layout is \"unresolved\" if the root directory is an empty path\n+ * ({@code Path.of(\"\")}) and \"resolved\" otherwise.\n+ * <p>\n+ * The return value of the {@link #runtimeDirectory()} method call is always a\n+ * path starting with the path returned by the {@link #rootDirectory()} method\n+ * call. Public methods without parameters and with the return type {@link Path}\n+ * in the derived interfaces must comply to this constrain.\n@@ -59,1 +67,1 @@\n-     * Root directory of this app image.\n+     * Root directory of this app image layout.\n@@ -62,1 +70,1 @@\n-     * @return the root directory of this app image\n+     * @return the root directory of this app image layout\n@@ -67,1 +75,21 @@\n-     * Creates a copy of this app image resolved at the given root directory.\n+     * Returns a copy of this app image layout with the root directory set to an empty\n+     * path ({@code Path.of(\"\")}) or this instance if its root directory is already\n+     * an empty path.\n+     *\n+     * @return an app image layout with the root directory set to an empty path\n+     *\/\n+    AppImageLayout resetRootDirectory();\n+\n+    \/**\n+     * Returns <code>true<\/code> if the root directory of this app image layout is\n+     * not an empty path, i.e, if it is not equal to <code>Path.of(\"\")<\/code>.\n+     *\n+     * @return <code>true<\/code> if the root directory of this app image layout is\n+     *         not an empty path\n+     *\/\n+    default boolean isResolved() {\n+        return !rootDirectory().equals(Path.of(\"\"));\n+    }\n+\n+    \/**\n+     * Creates a copy of this app image layout resolved at the given root directory.\n@@ -70,1 +98,29 @@\n-     * @return a copy of this app image resolved at the given root directory\n+     * @return a copy of this app image layout resolved at the given root directory\n+     *\/\n+    default AppImageLayout resolveAt(Path root) {\n+        return map(root::resolve);\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout resolved such that its root directory\n+     * is set to an empty path ({@code Path.of(\"\")}) or this instance if its root\n+     * directory is already an empty path.\n+     *\n+     * @return an app image layout resolved at {@code Path.of(\"\")} path\n+     *\/\n+    default AppImageLayout unresolve() {\n+        if (isResolved()) {\n+            final var root = rootDirectory();\n+            return map(root::relativize);\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a copy of this app image layout with the specified mapper applied to\n+     * every path.\n+     *\n+     * @param mapper the mapper to use with every path in this app image layout.\n+     * @return the copy of this app image layout with the specified mapper applied\n+     *         to every path\n@@ -72,1 +128,1 @@\n-    AppImageLayout resolveAt(Path root);\n+    AppImageLayout map(UnaryOperator<Path> mapper);\n@@ -76,1 +132,1 @@\n-    *\/\n+     *\/\n@@ -79,0 +135,17 @@\n+        public Stub {\n+            Objects.requireNonNull(rootDirectory);\n+        }\n+\n+        public Stub(Path runtimeDirectory) {\n+            this(Path.of(\"\"), runtimeDirectory);\n+        }\n+\n+        @Override\n+        public AppImageLayout resetRootDirectory() {\n+            if (isResolved()) {\n+                return new Stub(runtimeDirectory);\n+            } else {\n+                return this;\n+            }\n+        }\n+\n@@ -80,2 +153,2 @@\n-        public AppImageLayout resolveAt(Path base) {\n-            return new Stub(resolveNullablePath(base, rootDirectory), resolveNullablePath(base, runtimeDirectory));\n+        public AppImageLayout map(UnaryOperator<Path> mapper) {\n+            return new Stub(mapNullablePath(mapper, rootDirectory), mapNullablePath(mapper, runtimeDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/AppImageLayout.java","additions":86,"deletions":13,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-     * in the app image (\".jpackage\") file.\n+     * in the app image (\".jpackage.xml\") file.\n@@ -228,1 +228,1 @@\n-     *         entry in \".jpackage\" file\n+     *         entry in \".jpackage.xml\" file\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Application.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-    public static Optional<ApplicationLaunchers> fromList(List<Launcher> launchers) {\n+    public static Optional<ApplicationLaunchers> fromList(List<? extends Launcher> launchers) {\n@@ -65,1 +65,1 @@\n-                    launchers.subList(1, launchers.size())));\n+                    List.copyOf(launchers.subList(1, launchers.size()))));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLaunchers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -31,0 +31,1 @@\n+import java.util.function.UnaryOperator;\n@@ -45,1 +46,20 @@\n-        return buildFrom(this).resolveAt(root).create();\n+        return (ApplicationLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default ApplicationLayout unresolve() {\n+        return (ApplicationLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default ApplicationLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return buildFrom(this).rootDirectory(\"\").create();\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default ApplicationLayout map(UnaryOperator<Path> mapper) {\n+        return buildFrom(this).mutate(mapper).create();\n@@ -116,8 +136,8 @@\n-        public Builder resolveAt(Path base) {\n-            rootDirectory(resolveNullablePath(base, rootDirectory));\n-            launchersDirectory(resolveNullablePath(base, launchersDirectory));\n-            appDirectory(resolveNullablePath(base, appDirectory));\n-            runtimeDirectory(resolveNullablePath(base, runtimeDirectory));\n-            appModsDirectory(resolveNullablePath(base, appModsDirectory));\n-            desktopIntegrationDirectory(resolveNullablePath(base, desktopIntegrationDirectory));\n-            contentDirectory(resolveNullablePath(base, contentDirectory));\n+        public Builder mutate(UnaryOperator<Path> mapper) {\n+            rootDirectory(mapNullablePath(mapper, rootDirectory));\n+            launchersDirectory(mapNullablePath(mapper, launchersDirectory));\n+            appDirectory(mapNullablePath(mapper, appDirectory));\n+            runtimeDirectory(mapNullablePath(mapper, runtimeDirectory));\n+            appModsDirectory(mapNullablePath(mapper, appModsDirectory));\n+            desktopIntegrationDirectory(mapNullablePath(mapper, desktopIntegrationDirectory));\n+            contentDirectory(mapNullablePath(mapper, contentDirectory));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLayout.java","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Custom application launcher icon.\n+ * Custom application launcher icon sourced from an external file.\n@@ -36,1 +36,1 @@\n-public interface CustomLauncherIcon extends LauncherIcon {\n+public sealed interface CustomLauncherIcon extends LauncherIcon {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/CustomLauncherIcon.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Default icon is either loaded from the resources of {@link jdk.jpackage\/} module or picked from the resource directory.\n+ * Default icon is loaded from the resources of {@link jdk.jpackage} module.\n@@ -36,1 +36,1 @@\n-public interface DefaultLauncherIcon extends LauncherIcon {\n+public sealed interface DefaultLauncherIcon extends LauncherIcon {\n@@ -56,1 +56,5 @@\n-    public static DefaultLauncherIcon INSTANCE = new DefaultLauncherIcon() {};\n+    public static DefaultLauncherIcon INSTANCE = new Details.Impl();\n+\n+    static final class Details {\n+        private static final class Impl implements DefaultLauncherIcon {}\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/DefaultLauncherIcon.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -154,1 +154,3 @@\n-     * Returns <code>true<\/code> if this launcher has a custom icon.\n+     * Returns <code>true<\/code> if this launcher has non-default icon.\n+     * <p>\n+     * A custom icon can be sourced from an external file or from the resource directory.\n@@ -156,1 +158,1 @@\n-     * @return <code>true<\/code> if this launcher has a custom icon\n+     * @return <code>true<\/code> if this launcher has non-default icon\n@@ -163,1 +165,1 @@\n-        return icon().flatMap(CustomLauncherIcon::fromLauncherIcon).isPresent();\n+        return !hasDefaultIcon() && icon().isPresent();\n@@ -176,1 +178,1 @@\n-     * image (\".jpackage\") file.\n+     * image (\".jpackage.xml\") file.\n@@ -179,1 +181,1 @@\n-     *         \".jpackage\" file\n+     *         \".jpackage.xml\" file\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Launcher.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-public interface LauncherIcon {\n+public sealed interface LauncherIcon permits DefaultLauncherIcon, ResourceDirLauncherIcon, CustomLauncherIcon {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherIcon.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+\n+\/**\n+ * A shortcut to launch an application launcher.\n+ *\/\n+public record LauncherShortcut(Optional<LauncherShortcutStartupDirectory> startupDirectory) {\n+\n+    public LauncherShortcut {\n+        Objects.requireNonNull(startupDirectory);\n+    }\n+\n+    public LauncherShortcut(LauncherShortcutStartupDirectory startupDirectory) {\n+        this(Optional.of(startupDirectory));\n+    }\n+\n+    public LauncherShortcut() {\n+        this(Optional.empty());\n+    }\n+\n+    void store(String propertyName, BiConsumer<String, String> sink) {\n+        Objects.requireNonNull(propertyName);\n+        Objects.requireNonNull(sink);\n+        if (startupDirectory.isEmpty()) {\n+            sink.accept(propertyName, Boolean.FALSE.toString());\n+        } else {\n+            startupDirectory.ifPresent(v -> {\n+                sink.accept(propertyName, v.asStringValue());\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Converts the given shortcut into a shortcut request.\n+     * <p>\n+     * Returns <code>true<\/code> if shortcut was explicitly requested.\n+     * <p>\n+     * Returns <code>false<\/code> if no shortcut was explicitly requested.\n+     * <p>\n+     * Returns an empty {@link Optional} instance if there was no shortcut request.\n+     *\n+     * @return shortcut request\n+     *\/\n+    public static Optional<Boolean> toRequest(Optional<LauncherShortcut> shortcut) {\n+        return shortcut.map(v -> v.startupDirectory().isPresent());\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherShortcut.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * The directory in which to run an application launcher when it is started from\n+ * a shortcut.\n+ *\/\n+public enum LauncherShortcutStartupDirectory {\n+\n+    \/**\n+     * Platform-specific default value.\n+     * <p>\n+     * On Windows, it indicates that the startup directory should be the package's\n+     * installation directory.\n+     * <p>\n+     * On Linux, it indicates that a shortcut doesn't have the startup directory\n+     * configured explicitly.\n+     *\/\n+    DEFAULT(\"true\"),\n+\n+    \/**\n+     * The 'app' directory in the installed application app image. This is the\n+     * directory that is referenced with {@link ApplicationLayout#appDirectory()}\n+     * method.\n+     *\/\n+    APP_DIR(\"app-dir\");\n+\n+    LauncherShortcutStartupDirectory(String stringValue) {\n+        this.stringValue = Objects.requireNonNull(stringValue);\n+    }\n+\n+    public String asStringValue() {\n+        return stringValue;\n+    }\n+\n+    private final String stringValue;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherShortcutStartupDirectory.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -33,2 +33,1 @@\n- * The interface specifies the source app image layout with two transformations:\n- * package app image layout and installed app image layout.\n+ * The interface specifies the source app image and the installed app image layouts.\n@@ -39,7 +38,0 @@\n- * Package app image layout is the source app image layout resolved at the\n- * relative installation directory of the package. Additionally, to resolve the\n- * source layout, some packages may transform the source layout.\n- * <p>\n- * Use {@link #packageLayout()} or {@link #asPackageApplicationLayout()} to get\n- * the package app image layout.\n- * <p>\n@@ -58,1 +50,0 @@\n- * <th>Package app image layout<\/th>\n@@ -65,1 +56,0 @@\n- * <td>Duke\/bin\/foo.exe Duke\/app\/foo.jar<\/td>\n@@ -70,1 +60,0 @@\n- * <td>opt\/duke\/bin\/foo opt\/duke\/lib\/app\/foo.jar<\/td>\n@@ -76,1 +65,0 @@\n- * <td>Applications\/Duke.app\/Contents\/MacOS\/foo Applications\/Duke.app\/Contents\/app\/foo.jar<\/td>\n@@ -151,2 +139,10 @@\n-     * Gets the path to a directory with the application app image of this package\n-     * if available or an empty {@link Optional} instance otherwise.\n+     * Gets the path to a directory with the predefined app image of this package if\n+     * available or an empty {@link Optional} instance otherwise.\n+     * <p>\n+     * If {@link #isRuntimeInstaller()} returns {@code true}, the method returns the\n+     * path to a directory with the predefined runtime. The layout of this directory\n+     * should be of {@link RuntimeLayout} type.\n+     * <p>\n+     * If {@link #isRuntimeInstaller()} returns {@code false}, the method returns\n+     * the path to a directory with the predefined application image. The layout of\n+     * this directory should be of {@link ApplicationLayout} type.\n@@ -164,1 +160,0 @@\n-     * @see #packageLayout\n@@ -188,38 +183,0 @@\n-    \/**\n-     * Gets the layout of the installed app image of the application resolved at the\n-     * relative installation directory of this package.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package\n-     *\n-     * @see #relativeInstallDir\n-     * @see #appImageLayout\n-     * @see #installedPackageLayout\n-     *\/\n-    default AppImageLayout packageLayout() {\n-        return appImageLayout().resolveAt(relativeInstallDir());\n-    }\n-\n-    \/**\n-     * Returns the layout of the installed app image of the application resolved at\n-     * the relative installation directory of this package as\n-     * {@link ApplicationLayout} type or an empty {@link Optional} instance if the\n-     * layout object is of incompatible type.\n-     * <p>\n-     * Returns an empty {@link Optional} instance if {@link #isRuntimeInstaller()}\n-     * returns <code>true<\/code>.\n-     *\n-     * @return the layout of the installed app image of the application resolved at\n-     *         the relative installation directory of this package as\n-     *         {@link ApplicationLayout} type\n-     *\n-     * @see #packageLayout\n-     *\/\n-    default Optional<ApplicationLayout> asPackageApplicationLayout() {\n-        if (packageLayout() instanceof ApplicationLayout layout) {\n-            return Optional.of(layout);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n@@ -232,1 +189,0 @@\n-     * @see #packageLayout\n@@ -234,16 +190,1 @@\n-    default AppImageLayout installedPackageLayout() {\n-        return asStandardPackageType().map(stdType -> {\n-            switch (stdType) {\n-                case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n-                    return packageLayout().resolveAt(Path.of(\"\/\"));\n-                }\n-                case WIN_EXE, WIN_MSI -> {\n-                    return packageLayout();\n-                }\n-                default -> {\n-                    \/\/ Should never get here\n-                    throw new IllegalStateException();\n-                }\n-            }\n-        }).orElseThrow(UnsupportedOperationException::new);\n-    }\n+    AppImageLayout installedPackageLayout();\n@@ -329,1 +270,1 @@\n-            Path relativeInstallDir) implements Package {\n+            AppImageLayout installedPackageLayout, Path relativeInstallDir) implements Package {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Package.java","additions":13,"deletions":72,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Collection of functions to create instances of types defined in this package from strings.\n+ *\/\n+public final class ParseUtils {\n+\n+    private ParseUtils() {\n+    }\n+\n+    public static LauncherShortcut parseLauncherShortcutForMainLauncher(String str) {\n+        return parse(str, LauncherShortcutStartupDirectory.APP_DIR).map(LauncherShortcut::new).orElseThrow(IllegalArgumentException::new);\n+    }\n+\n+    public static LauncherShortcut parseLauncherShortcutForAddLauncher(String str) {\n+        return parse(str, LauncherShortcutStartupDirectory.values()).map(LauncherShortcut::new).orElseGet(() -> {\n+            if (Boolean.valueOf(str)) {\n+                return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n+            } else {\n+                return new LauncherShortcut();\n+            }\n+        });\n+    }\n+\n+    private static Optional<LauncherShortcutStartupDirectory> parse(String str, LauncherShortcutStartupDirectory... recognizedValues) {\n+        Objects.requireNonNull(str);\n+        return Stream.of(recognizedValues).filter(v -> {\n+            return str.equals(v.asStringValue());\n+        }).findFirst();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ParseUtils.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * Custom application launcher icon sourced from the resource directory.\n+ * <p>\n+ * Use {@link #create(String)} method to create an instance of this type.\n+ *\/\n+public sealed interface ResourceDirLauncherIcon extends LauncherIcon {\n+\n+    \/**\n+     * Returns name of the resource referencing an icon file in the resource directory.\n+     * @return name of the resource referencing an icon file in the resource directory\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Returns the given icon as {@link ResourceDirLauncherIcon} type or an empty {@link Optional} instance\n+     * if the given icon object is not an instance of {@link ResourceDirLauncherIcon} type.\n+     *\n+     * @param icon application launcher icon object or <code>null<\/null>\n+     * @return the given icon as {@link ResourceDirLauncherIcon} type or an empty {@link Optional} instance\n+     *\/\n+    public static Optional<ResourceDirLauncherIcon> fromLauncherIcon(LauncherIcon icon) {\n+        if (icon instanceof ResourceDirLauncherIcon customIcon) {\n+            return Optional.of(customIcon);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Creates object of type {@link ResourceDirLauncherIcon} from the name of the resource referencing an icon file in the resource directory.\n+     * @param name name of the resource referencing an icon file in the resource directory\n+     * @return {@link ResourceDirLauncherIcon} instance\n+     *\/\n+    public static ResourceDirLauncherIcon create(String name) {\n+        Objects.requireNonNull(name);\n+        return new Stub(name);\n+    }\n+\n+    \/**\n+     * Default implementation of {@link ResourceDirLauncherIcon} type.\n+     *\/\n+    record Stub(String name) implements ResourceDirLauncherIcon {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ResourceDirLauncherIcon.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.module.ModuleFinder;\n@@ -46,1 +47,1 @@\n-    void createRuntime(AppImageLayout appImageLayout) throws PackagerException;\n+    void create(AppImageLayout appImageLayout) throws PackagerException;\n@@ -49,1 +50,7 @@\n-     * Gets the default set of paths where to find Java modules.\n+     * Gets the default set of paths where jlink should look up for system Java\n+     * modules.\n+     *\n+     * <p>\n+     * These paths are for {@code jlink} command. Using them with\n+     * {@link ModuleFinder#of(Path...)} may not work as expected: attempt to find\n+     * \"java.base\" module in these paths will fail.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+import static jdk.jpackage.internal.util.PathUtils.mapNullablePath;\n@@ -30,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -42,2 +43,21 @@\n-        return create(new AppImageLayout.Stub(resolveNullablePath(root, rootDirectory()),\n-                resolveNullablePath(root, runtimeDirectory())));\n+        return (RuntimeLayout)AppImageLayout.super.resolveAt(root);\n+    }\n+\n+    @Override\n+    default RuntimeLayout resetRootDirectory() {\n+        if (isResolved()) {\n+            return create(runtimeDirectory());\n+        } else {\n+            return this;\n+        }\n+    }\n+\n+    @Override\n+    default RuntimeLayout unresolve() {\n+        return (RuntimeLayout)AppImageLayout.super.unresolve();\n+    }\n+\n+    @Override\n+    default RuntimeLayout map(UnaryOperator<Path> mapper) {\n+        return create(new RuntimeLayout.Stub(mapNullablePath(mapper, rootDirectory()),\n+                mapNullablePath(mapper, runtimeDirectory())));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeLayout.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-\\n\\\n+{7}\\n\\\n@@ -337,0 +337,7 @@\n+\n+MSG_Help_mac_app_content_note=\\\n+\\          Note: The value should be a directory with the \"Resources\"\\n\\\n+\\          subdirectory (or any other directory that is valid in the \"Contents\"\\n\\\n+\\          directory of the application bundle). Otherwise, jpackage may produce\\n\\\n+\\          invalid application bundle which may fail code signing and\/or\\n\\\n+\\          notarization.\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-message.no-default-resource=no default package resource {0} {1} (add {2} to the resource-dir to customize).\n+message.no-default-resource=No default package resource {0} (add {1} to the resource-dir to customize).\n@@ -69,4 +69,7 @@\n-error.tool-not-found=Can not find {0}. Reason: {1}\n-error.tool-not-found.advice=Please install {0}\n-error.tool-old-version=Can not find {0} {1} or newer\n-error.tool-old-version.advice=Please install {0} {1} or newer\n+error.tool-error=Can not validate \"{0}\". Reason: {1}\n+error.tool-not-executable=\"{0}\" is not executable\n+error.tool-not-found=Can not find \"{0}\"\n+error.tool-not-found.advice=Please install \"{0}\"\n+error.tool-old-version=Can not find \"{0}\" {1} or newer\n+error.tool-old-version.advice=Please install \"{0}\" {1} or newer\n+\n@@ -78,2 +81,0 @@\n-warning.no.jdk.modules.found=Warning: No JDK Modules found\n-\n@@ -85,0 +86,2 @@\n+error.invalid-option-value=Invalid value \"{0}\" of option {1}\n+\n@@ -115,1 +118,0 @@\n-ERR_MacAppStoreRuntimeBinExists=Error: Runtime image \"{0}\" should not contain \"bin\" folder. Use --strip-native-commands jlink option when generating runtime image used with --mac-app-store argument.\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-public class ResourceLocator {\n-    public ResourceLocator() {\n+public final class ResourceLocator {\n+    private ResourceLocator() {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/ResourceLocator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import static java.util.stream.Collectors.toSet;\n@@ -33,1 +34,0 @@\n-import java.util.ArrayList;\n@@ -36,0 +36,3 @@\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n@@ -294,0 +297,74 @@\n+    private record InterfaceDispatchBuilder(Set<? extends Class<?>> interfaces, Collection<Object> slices) {\n+\n+        InterfaceDispatchBuilder {\n+            Objects.requireNonNull(interfaces);\n+            Objects.requireNonNull(slices);\n+\n+            if (interfaces.isEmpty()) {\n+                throw new IllegalArgumentException(\"No interfaces to dispatch\");\n+            }\n+\n+            if (slices.isEmpty()) {\n+                throw createInterfaceNotImplementedException(interfaces);\n+            }\n+        }\n+\n+        InterfaceDispatchBuilder(Result result) {\n+            this(result.unservedInterfaces(), result.unusedSlices());\n+        }\n+\n+        Map<? extends Class<?>, List<Object>> createDispatchGroups() {\n+            return interfaces.stream().collect(toMap(x -> x, iface -> {\n+                return slices.stream().filter(obj -> {\n+                    return Stream.of(obj.getClass().getInterfaces()).flatMap(sliceIface -> {\n+                        return unfoldInterface(sliceIface);\n+                    }).anyMatch(Predicate.isEqual(iface));\n+                }).toList();\n+            }));\n+        }\n+\n+        Result createDispatch() {\n+            var groups = createDispatchGroups();\n+\n+            var dispatch = groups.entrySet().stream().filter(e -> {\n+                return e.getValue().size() == 1;\n+            }).collect(toMap(Map.Entry::getKey, e -> {\n+                return e.getValue().getFirst();\n+            }));\n+\n+            var unservedInterfaces = groups.entrySet().stream().filter(e -> {\n+                return e.getValue().size() != 1;\n+            }).map(Map.Entry::getKey).collect(toSet());\n+\n+            var usedSliceIdentities = dispatch.values().stream()\n+                    .map(IdentityWrapper::new)\n+                    .collect(toSet());\n+\n+            var unusedSliceIdentities = new HashSet<>(toIdentitySet(slices));\n+            unusedSliceIdentities.removeAll(usedSliceIdentities);\n+\n+            return new Result(dispatch, unservedInterfaces, unusedSliceIdentities.stream().map(IdentityWrapper::value).toList());\n+        }\n+\n+        private record Result(Map<? extends Class<?>, Object> dispatch, Set<? extends Class<?>> unservedInterfaces, Collection<Object> unusedSlices) {\n+\n+            Result {\n+                Objects.requireNonNull(dispatch);\n+                Objects.requireNonNull(unservedInterfaces);\n+                Objects.requireNonNull(unusedSlices);\n+\n+                if (!Collections.disjoint(dispatch.keySet(), unservedInterfaces)) {\n+                    throw new IllegalArgumentException();\n+                }\n+\n+                if (!Collections.disjoint(toIdentitySet(dispatch.values()), toIdentitySet(unusedSlices))) {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        }\n+\n+        private static Collection<IdentityWrapper<Object>> toIdentitySet(Collection<Object> v) {\n+            return v.stream().map(IdentityWrapper::new).collect(toSet());\n+        }\n+    }\n+\n@@ -296,13 +373,32 @@\n-        final Map<Class<?>, Object> interfaceDispatch = Stream.of(interfaces).collect(toMap(x -> x, iface -> {\n-            return Stream.of(slices).filter(obj -> {\n-                return Set.of(obj.getClass().getInterfaces()).contains(iface);\n-            }).reduce((a, b) -> {\n-                throw new IllegalArgumentException(\n-                        String.format(\"both [%s] and [%s] slices implement %s\", a, b, iface));\n-            }).orElseThrow(() -> createInterfaceNotImplementedException(List.of(iface)));\n-        }));\n-\n-        if (interfaceDispatch.size() != interfaces.length) {\n-            final List<Class<?>> missingInterfaces = new ArrayList<>(Set.of(interfaces));\n-            missingInterfaces.removeAll(interfaceDispatch.keySet());\n-            throw createInterfaceNotImplementedException(missingInterfaces);\n+        if (interfaces.length == 0) {\n+            return Collections.emptyMap();\n+        }\n+\n+        Map<Class<?>, Object> dispatch = new HashMap<>();\n+\n+        var builder = new InterfaceDispatchBuilder(Set.of(interfaces), List.of(slices));\n+        for (;;) {\n+            var result = builder.createDispatch();\n+            if (result.dispatch().isEmpty()) {\n+                var unserved = builder.createDispatchGroups();\n+                for (var e : unserved.entrySet()) {\n+                    var iface = e.getKey();\n+                    var ifaceSlices = e.getValue();\n+                    if (ifaceSlices.size() > 1) {\n+                        throw new IllegalArgumentException(\n+                                String.format(\"multiple slices %s implement %s\", ifaceSlices, iface));\n+                    }\n+                }\n+\n+                var unservedInterfaces = unserved.entrySet().stream().filter(e -> {\n+                    return e.getValue().isEmpty();\n+                }).map(Map.Entry::getKey).toList();\n+                throw createInterfaceNotImplementedException(unservedInterfaces);\n+            } else {\n+                dispatch.putAll(result.dispatch());\n+                if (result.unservedInterfaces().isEmpty()) {\n+                    break;\n+                }\n+            }\n+\n+            builder = new InterfaceDispatchBuilder(result);\n@@ -311,1 +407,1 @@\n-        return Stream.of(interfaces).flatMap(iface -> {\n+        return dispatch.keySet().stream().flatMap(iface -> {\n@@ -313,1 +409,1 @@\n-                return Map.entry(unfoldedIface, interfaceDispatch.get(iface));\n+                return Map.entry(unfoldedIface, dispatch.get(iface));\n@@ -324,1 +420,1 @@\n-            Collection<Class<?>> missingInterfaces) {\n+            Collection<? extends Class<?>> missingInterfaces) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CompositeProxy.java","additions":113,"deletions":17,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.file.StandardCopyOption;\n@@ -36,0 +37,1 @@\n+import java.util.Optional;\n@@ -67,10 +69,11 @@\n-        Files.walkFileTree(src, new SimpleFileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult preVisitDirectory(final Path dir,\n-                    final BasicFileAttributes attrs) {\n-                if (isPathMatch(dir, excludes)) {\n-                    return FileVisitResult.SKIP_SUBTREE;\n-                } else {\n-                    copyActions.add(new CopyAction(null, dest.resolve(src.\n-                            relativize(dir))));\n-                    return FileVisitResult.CONTINUE;\n+        if (Files.isDirectory(src)) {\n+            Files.walkFileTree(src, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(final Path dir,\n+                        final BasicFileAttributes attrs) {\n+                    if (isPathMatch(dir, excludes)) {\n+                        return FileVisitResult.SKIP_SUBTREE;\n+                    } else {\n+                        copyActions.add(new CopyAction(null, dest.resolve(src.relativize(dir))));\n+                        return FileVisitResult.CONTINUE;\n+                    }\n@@ -78,1 +81,0 @@\n-            }\n@@ -80,6 +82,7 @@\n-            @Override\n-            public FileVisitResult visitFile(final Path file,\n-                    final BasicFileAttributes attrs) {\n-                if (!isPathMatch(file, excludes)) {\n-                    copyActions.add(new CopyAction(file, dest.resolve(src.\n-                            relativize(file))));\n+                @Override\n+                public FileVisitResult visitFile(final Path file,\n+                        final BasicFileAttributes attrs) {\n+                    if (!isPathMatch(file, excludes)) {\n+                        copyActions.add(new CopyAction(file, dest.resolve(src.relativize(file))));\n+                    }\n+                    return FileVisitResult.CONTINUE;\n@@ -87,3 +90,7 @@\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n+            });\n+        } else if (!isPathMatch(src, excludes)) {\n+            Optional.ofNullable(dest.getParent()).ifPresent(dstDir -> {\n+                copyActions.add(new CopyAction(null, dstDir));\n+            });\n+            copyActions.add(new CopyAction(src, dest));\n+        }\n@@ -103,0 +110,11 @@\n+            if (List.of(options).contains(StandardCopyOption.REPLACE_EXISTING)) {\n+                \/\/ They requested copying with replacing the existing content.\n+                if (src == null && Files.isRegularFile(dest)) {\n+                    \/\/ This copy action creates a directory, but a file at the same path already exists, so delete it.\n+                    Files.deleteIfExists(dest);\n+                } else if (src != null && Files.isDirectory(dest)) {\n+                    \/\/ This copy action copies a file, but a directory at the same path exists already, so delete it.\n+                    deleteRecursive(dest);\n+                }\n+            }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/FileUtils.java","additions":39,"deletions":21,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * Object wrapper implementing {@link Object#equals(Object)} such that it\n+ * returns {@code true} only when the argument is another instance of this class\n+ * wrapping the same object.\n+ * <p>\n+ * The class guarantees that {@link Object#equals(Object)} and\n+ * {@link Object#hashCode()} methods of the wrapped object will never be called\n+ * inside of the class methods.\n+ *\n+ * @param <T> the type of the wrapped value\n+ *\/\n+public final class IdentityWrapper<T> {\n+\n+    public IdentityWrapper(T value) {\n+        this.value = Objects.requireNonNull(value);\n+    }\n+\n+    public T value() {\n+        return value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if ((obj == null) || (getClass() != obj.getClass())) {\n+            return false;\n+        }\n+        var other = (IdentityWrapper<?>) obj;\n+        return value == other.value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"Identity[%s]\", value);\n+    }\n+\n+    private final T value;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/IdentityWrapper.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -93,1 +93,7 @@\n-        xml.writeDTD(\"plist PUBLIC \\\"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\\\" \\\"https:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\\\"\");\n+        try {\n+            xml.writeDTD(\"<!DOCTYPE plist PUBLIC \\\"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\\\" \\\"https:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\\\">\");\n+        } catch (UnsupportedOperationException ex) {\n+            \/\/ Silently ignore.\n+            \/\/ This would normally be thrown by com.sun.xml.internal.stream.writers.XMLDOMWriterImpl.writeDTD()\n+            \/\/ or (presumably) any other DOM tree-backed XML stream writer implementation.\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PListWriter.java","additions":7,"deletions":1,"binary":false,"changes":8,"previous_filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/util\/PListWriter.java","status":"renamed"},{"patch":"@@ -473,0 +473,17 @@\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(entries);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        PathGroup other = (PathGroup) obj;\n+        return Objects.equals(entries, other.entries);\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathGroup.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -29,0 +30,1 @@\n+import java.util.function.UnaryOperator;\n@@ -50,2 +52,7 @@\n-    public static Path resolveNullablePath(Path base, Path path) {\n-        return Optional.ofNullable(path).map(base::resolve).orElse(null);\n+    public static Path mapNullablePath(UnaryOperator<Path> mapper, Path path) {\n+        Objects.requireNonNull(mapper);\n+        if (path != null) {\n+            return mapper.apply(path);\n+        } else {\n+            return null;\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathUtils.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.StreamSupport;\n+\n+\n+public record Result<T>(Optional<T> value, Collection<? extends Exception> errors) {\n+    public Result {\n+        if (value.isEmpty() == errors.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        if (value.isEmpty() && errors.isEmpty()) {\n+            throw new IllegalArgumentException(\"Error collection must be non-empty\");\n+        }\n+\n+    }\n+\n+    public T orElseThrow() {\n+        firstError().ifPresent(ex -> {\n+            rethrowUnchecked(ex);\n+        });\n+        return value.orElseThrow();\n+    }\n+\n+    public boolean hasValue() {\n+        return value.isPresent();\n+    }\n+\n+    public boolean hasErrors() {\n+        return !errors.isEmpty();\n+    }\n+\n+    public <U> Result<U> map(Function<T, U> conv) {\n+        return new Result<>(value.map(conv), errors);\n+    }\n+\n+    public <U> Result<U> flatMap(Function<T, Result<U>> conv) {\n+        return value.map(conv).orElseGet(() -> {\n+            return new Result<>(Optional.empty(), errors);\n+        });\n+    }\n+\n+    public Result<T> mapErrors(UnaryOperator<Collection<? extends Exception>> errorsMapper) {\n+        return new Result<>(value, errorsMapper.apply(errors));\n+    }\n+\n+    public <U> Result<U> mapErrors() {\n+        return new Result<>(Optional.empty(), errors);\n+    }\n+\n+    public Result<T> peekErrors(Consumer<Collection<? extends Exception>> consumer) {\n+        if (hasErrors()) {\n+            consumer.accept(errors);\n+        }\n+        return this;\n+    }\n+\n+    public Result<T> peekValue(Consumer<T> consumer) {\n+        value.ifPresent(consumer);\n+        return this;\n+    }\n+\n+    public Optional<? extends Exception> firstError() {\n+        return errors.stream().findFirst();\n+    }\n+\n+    public static <T> Result<T> create(Supplier<T> supplier) {\n+        try {\n+            return ofValue(supplier.get());\n+        } catch (Exception ex) {\n+            return ofError(ex);\n+        }\n+    }\n+\n+    public static <T> Result<T> ofValue(T value) {\n+        return new Result<>(Optional.of(value), List.of());\n+    }\n+\n+    public static <T> Result<T> ofErrors(Collection<? extends Exception> errors) {\n+        return new Result<>(Optional.empty(), List.copyOf(errors));\n+    }\n+\n+    public static <T> Result<T> ofError(Exception error) {\n+        return ofErrors(List.of(error));\n+    }\n+\n+    public static boolean allHaveValues(Iterable<? extends Result<?>> results) {\n+        return StreamSupport.stream(results.spliterator(), false).allMatch(Result::hasValue);\n+    }\n+\n+    public static boolean allHaveValues(Result<?>... results) {\n+        return allHaveValues(List.of(results));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/Result.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+\n@@ -46,0 +48,1 @@\n+import javax.xml.transform.dom.DOMResult;\n@@ -66,2 +69,1 @@\n-    public static void createXml(Path dstFile, XmlConsumer xmlConsumer) throws\n-            IOException {\n+    public static void createXml(Path dstFile, XmlConsumer xmlConsumer) throws IOException {\n@@ -81,3 +83,22 @@\n-            throw new IOException(ex);\n-        } catch (IOException ex) {\n-            throw ex;\n+            throw rethrowUnchecked(ex);\n+        }\n+    }\n+\n+    public static void createXml(Node root, XmlConsumer xmlConsumer) throws IOException {\n+        createXml(new DOMResult(root), xmlConsumer);\n+    }\n+\n+    public static DOMResult createXml(XmlConsumer xmlConsumer) throws IOException {\n+        var dom = new DOMResult(initDocumentBuilder().newDocument());\n+        createXml(dom, xmlConsumer);\n+        return dom;\n+    }\n+\n+    public static void createXml(DOMResult dom, XmlConsumer xmlConsumer) throws IOException {\n+        try {\n+            var xml = XMLOutputFactory.newInstance().createXMLStreamWriter(dom);\n+            xmlConsumer.accept(xml);\n+            xml.flush();\n+            xml.close();\n+        } catch (XMLStreamException ex) {\n+            throw rethrowUnchecked(ex);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/XmlUtils.java","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -193,0 +193,6 @@\n+    macOS note: The value should be a directory with the \"Resources\"\n+                subdirectory (or any other directory that is valid in the\n+                \"Contents\" directory of the application bundle). Otherwise,\n+                jpackage may produce invalid application bundle which may fail\n+                code signing and\/or notarization.\n+\n","filename":"src\/jdk.jpackage\/share\/man\/jpackage.md","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static java.util.stream.Collectors.toMap;\n+\n@@ -28,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -32,0 +35,1 @@\n+import java.util.TreeMap;\n@@ -33,2 +37,0 @@\n-import java.util.function.UnaryOperator;\n-import java.util.stream.Collectors;\n@@ -48,5 +50,5 @@\n-        scripts = EnumSet.allOf(scriptIdsType).stream().collect(\n-                Collectors.toMap(UnaryOperator.identity(), scriptId -> {\n-                    return new ShellScriptResource(scriptId.name()).setResource(\n-                            scriptId.get());\n-                }));\n+        scripts = EnumSet.allOf(scriptIdsType).stream().collect(toMap(x -> x, scriptId -> {\n+            return new ShellScriptResource(scriptId.name()).setResource(scriptId.get());\n+        }, (a, b) -> {\n+            throw new UnsupportedOperationException();\n+        }, TreeMap::new));\n@@ -66,1 +68,1 @@\n-    PackageScripts<T> setResourceDir(Path v) throws IOException {\n+    PackageScripts<T> setResourceDir(Path v) {\n@@ -73,0 +75,16 @@\n+    PackageScripts<T> setResourceDir(BuildEnv env) {\n+        env.resourceDir().ifPresent(this::setResourceDir);\n+        return this;\n+    }\n+\n+    boolean isEmpty() {\n+        return scripts.values().stream().map(\n+                ShellScriptResource::getResource).allMatch(overridableResource -> {\n+            try {\n+                return overridableResource.saveToStream(null) == null;\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        });\n+    }\n+\n@@ -82,0 +100,4 @@\n+            this(Optional.of(defaultName), categoryId);\n+        }\n+\n+        ResourceConfig(Optional<String> defaultName, String categoryId) {\n@@ -87,2 +109,4 @@\n-            var resource = new OverridableResource(defaultName,\n-                    ResourceLocator.class).setCategory(category);\n+            final var resource = defaultName.map(v -> {\n+                    return new OverridableResource(v, ResourceLocator.class);\n+                }).orElseGet(OverridableResource::new).setCategory(category);\n+\n@@ -94,6 +118,8 @@\n-            final String wellKnownSuffix = \".template\";\n-            if (defaultName.endsWith(wellKnownSuffix)) {\n-                return Optional.of(defaultName.substring(0, defaultName.length()\n-                        - wellKnownSuffix.length()));\n-            }\n-            return Optional.ofNullable(null);\n+            return defaultName.flatMap(v -> {\n+                final String wellKnownSuffix = \".template\";\n+                if (v.endsWith(wellKnownSuffix)) {\n+                    return Optional.of(v.substring(0,\n+                            v.length() - wellKnownSuffix.length()));\n+                }\n+                return Optional.empty();\n+            });\n@@ -102,1 +128,1 @@\n-        private final String defaultName;\n+        private final Optional<String> defaultName;\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/PackageScripts.java","additions":43,"deletions":17,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,5 @@\n+        if (!Files.exists(dstFile)) {\n+            \/\/ No script file created.\n+            return;\n+        }\n+\n@@ -70,1 +75,1 @@\n-    final Path publicFileName;\n+    private final Path publicFileName;\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/ShellScriptResource.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,5 +27,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n@@ -33,1 +28,0 @@\n-import java.nio.file.StandardCopyOption;\n@@ -37,1 +31,1 @@\n-import jdk.jpackage.internal.model.WinExePackage;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n@@ -74,1 +68,1 @@\n-        return msiBundler.validate(params);\n+        return msiBundler.validate(params, WinFromParams.EXE_PACKAGE);\n@@ -82,1 +76,1 @@\n-        var pkg = WinFromParams.MSI_PACKAGE.fetchFrom(params);\n+        var pkg = WinFromParams.EXE_PACKAGE.fetchFrom(params);\n@@ -85,22 +79,11 @@\n-        IOUtils.writableOutputDir(outdir);\n-\n-        Path msiDir = env.buildRoot().resolve(\"msi\");\n-        toRunnable(() -> Files.createDirectories(msiDir)).run();\n-\n-        \/\/ Write msi to temporary directory.\n-        Path msi = msiBundler.execute(params, msiDir);\n-\n-        try {\n-            new ScriptRunner()\n-            .setDirectory(msi.getParent())\n-            .setResourceCategoryId(\"resource.post-msi-script\")\n-            .setScriptNameSuffix(\"post-msi\")\n-            .setEnvironmentVariable(\"JpMsiFile\", msi.toAbsolutePath().toString())\n-            .run(env, pkg.packageName());\n-\n-            var exePkg = new WinExePackageBuilder(pkg).icon(ICON.fetchFrom(params)).create();\n-            return buildEXE(env, exePkg, msi, outdir);\n-        } catch (IOException|ConfigException ex) {\n-            Log.verbose(ex);\n-            throw new PackagerException(ex);\n-        }\n+        var msiOutputDir = env.buildRoot().resolve(\"msi\");\n+\n+        return Packager.<WinMsiPackage>build().outputDir(msiOutputDir)\n+                .pkg(pkg.msiPackage())\n+                .env(env)\n+                .pipelineBuilderMutatorFactory((packagingEnv, msiPackage, _) -> {\n+                    var msiPackager = new WinMsiPackager(packagingEnv, msiPackage,\n+                            msiOutputDir, msiBundler.sysEnv.orElseThrow());\n+                    var exePackager = new WinExePackager(packagingEnv, pkg, outdir, msiOutputDir);\n+                    return msiPackager.andThen(exePackager);\n+                }).execute(WinPackagingPipeline.build());\n@@ -109,28 +92,1 @@\n-    private Path buildEXE(BuildEnv env, WinExePackage pkg, Path msi,\n-            Path outdir) throws IOException {\n-\n-        Log.verbose(I18N.format(\"message.outputting-to-location\", outdir.toAbsolutePath()));\n-\n-        \/\/ Copy template msi wrapper next to msi file\n-        final Path exePath = msi.getParent().resolve(pkg.packageFileNameWithSuffix());\n-\n-        env.createResource(\"msiwrapper.exe\")\n-                .setCategory(I18N.getString(\"resource.installer-exe\"))\n-                .setPublicName(\"installer.exe\")\n-                .saveToFile(exePath);\n-\n-        new ExecutableRebrander(pkg, env::createResource, resourceLock -> {\n-            \/\/ Embed msi in msi wrapper exe.\n-            embedMSI(resourceLock, msi.toAbsolutePath().toString());\n-        }).execute(env, exePath, pkg.icon());\n-\n-        Path dstExePath = outdir.resolve(exePath.getFileName());\n-\n-        Files.copy(exePath, dstExePath, StandardCopyOption.REPLACE_EXISTING);\n-\n-        dstExePath.toFile().setExecutable(true);\n-\n-        Log.verbose(I18N.format(\"message.output-location\", outdir.toAbsolutePath()));\n-\n-        return dstExePath;\n-    }\n+    static native int embedMSI(long resourceLock, String msiPath);\n@@ -139,2 +95,0 @@\n-\n-    private static native int embedMSI(long resourceLock, String msiPath);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":15,"deletions":61,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.WinExePackage;\n+\n+final record WinExePackager(BuildEnv env, WinExePackage pkg, Path outputDir, Path msiOutputDir) implements Consumer<PackagingPipeline.Builder> {\n+\n+    WinExePackager {\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(outputDir);\n+        Objects.requireNonNull(msiOutputDir);\n+    }\n+\n+    enum ExePackageTaskID implements TaskID {\n+        RUN_POST_MSI_USER_SCRIPT,\n+        WRAP_MSI_IN_EXE\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder.excludeDirFromCopying(outputDir)\n+                .task(ExePackageTaskID.RUN_POST_MSI_USER_SCRIPT)\n+                        .action(this::runPostMsiScript)\n+                        .addDependency(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .add()\n+                .task(ExePackageTaskID.WRAP_MSI_IN_EXE)\n+                        .action(this::wrapMsiInExe)\n+                        .addDependency(ExePackageTaskID.RUN_POST_MSI_USER_SCRIPT)\n+                        .addDependent(PrimaryTaskID.PACKAGE)\n+                        .add();\n+    }\n+\n+    private Path msi() {\n+        return msiOutputDir.resolve(pkg.msiPackage().packageFileNameWithSuffix());\n+    }\n+\n+    private void runPostMsiScript() throws IOException {\n+        new ScriptRunner()\n+        .setDirectory(msiOutputDir)\n+        .setResourceCategoryId(\"resource.post-msi-script\")\n+        .setScriptNameSuffix(\"post-msi\")\n+        .setEnvironmentVariable(\"JpMsiFile\", msi().toAbsolutePath().toString())\n+        .run(env, pkg.msiPackage().packageName());\n+    }\n+\n+    private void wrapMsiInExe() throws IOException {\n+\n+        Log.verbose(I18N.format(\"message.outputting-to-location\", outputDir.toAbsolutePath()));\n+\n+        final var msi = msi();\n+\n+        \/\/ Copy template msi wrapper next to msi file\n+        final Path exePath = msi.getParent().resolve(pkg.packageFileNameWithSuffix());\n+\n+        env.createResource(\"msiwrapper.exe\")\n+                .setCategory(I18N.getString(\"resource.installer-exe\"))\n+                .setPublicName(\"installer.exe\")\n+                .saveToFile(exePath);\n+\n+        new ExecutableRebrander(pkg, env::createResource, resourceLock -> {\n+            \/\/ Embed msi in msi wrapper exe.\n+            WinExeBundler.embedMSI(resourceLock, msi.toAbsolutePath().toString());\n+        }).execute(env, exePath, pkg.icon());\n+\n+        Path dstExePath = outputDir.resolve(exePath.getFileName());\n+\n+        Files.createDirectories(dstExePath.getParent());\n+        Files.copy(exePath, dstExePath, StandardCopyOption.REPLACE_EXISTING);\n+\n+        dstExePath.toFile().setExecutable(true);\n+\n+        Log.verbose(I18N.format(\"message.output-location\", outputDir.toAbsolutePath()));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExePackager.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import static java.util.stream.Collectors.toSet;\n@@ -34,1 +33,2 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n+import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n+import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n@@ -36,1 +36,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n@@ -39,2 +38,0 @@\n-import static jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut.WIN_SHORTCUT_DESKTOP;\n-import static jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut.WIN_SHORTCUT_START_MENU;\n@@ -44,1 +41,0 @@\n-import java.util.List;\n@@ -48,0 +44,1 @@\n+import jdk.jpackage.internal.model.Launcher;\n@@ -49,0 +46,1 @@\n+import jdk.jpackage.internal.model.WinExePackage;\n@@ -66,3 +64,1 @@\n-            final var shortcuts = Map.of(WIN_SHORTCUT_DESKTOP, List.of(SHORTCUT_HINT,\n-                WIN_SHORTCUT_HINT), WIN_SHORTCUT_START_MENU, List.of(MENU_HINT,\n-                        WIN_MENU_HINT)).entrySet().stream().filter(e -> {\n+            final var startMenuShortcut = findLauncherShortcut(WIN_MENU_HINT, params, launcherParams);\n@@ -70,1 +66,1 @@\n-                    final var shortcutParams = e.getValue();\n+            final var desktopShortcut = findLauncherShortcut(WIN_SHORTCUT_HINT, params, launcherParams);\n@@ -72,4 +68,1 @@\n-                    return shortcutParams.get(0).findIn(launcherParams).orElseGet(() -> {\n-                        return shortcutParams.get(1).findIn(launcherParams).orElse(false);\n-                    });\n-                }).map(Map.Entry::getKey).collect(toSet());\n+            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, startMenuShortcut, desktopShortcut));\n@@ -77,3 +70,3 @@\n-            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, shortcuts));\n-\n-        }), APPLICATION_LAYOUT).create();\n+        }), (WinLauncher winLauncher, Launcher launcher) -> {\n+            return WinLauncher.create(launcher, winLauncher);\n+        }, APPLICATION_LAYOUT).create();\n@@ -114,0 +107,11 @@\n+    private static WinExePackage createWinExePackage(Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        final var msiPkg = MSI_PACKAGE.fetchFrom(params);\n+\n+        final var pkgBuilder = new WinExePackageBuilder(msiPkg);\n+\n+        ICON.copyInto(params, pkgBuilder::icon);\n+\n+        return pkgBuilder.create();\n+    }\n+\n@@ -120,1 +124,4 @@\n-    private static final BundlerParamInfo<Boolean> WIN_MENU_HINT = createBooleanBundlerParam(\n+    static final BundlerParamInfo<WinExePackage> EXE_PACKAGE = createPackageBundlerParam(\n+            WinFromParams::createWinExePackage);\n+\n+    private static final BundlerParamInfo<String> WIN_MENU_HINT = createStringBundlerParam(\n@@ -123,1 +130,1 @@\n-    private static final BundlerParamInfo<Boolean> WIN_SHORTCUT_HINT = createBooleanBundlerParam(\n+    private static final BundlerParamInfo<String> WIN_SHORTCUT_HINT = createStringBundlerParam(\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,7 +30,0 @@\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.UncheckedIOException;\n-import java.io.Writer;\n-import java.nio.charset.Charset;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n@@ -38,6 +31,0 @@\n-import java.nio.file.PathMatcher;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n@@ -45,13 +32,0 @@\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathExpressionException;\n-import javax.xml.xpath.XPathFactory;\n-import jdk.jpackage.internal.PackagingPipeline.PackageBuildEnv;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -61,1 +35,0 @@\n-import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -63,3 +36,1 @@\n-import org.w3c.dom.Document;\n-import org.w3c.dom.NodeList;\n-import org.xml.sax.SAXException;\n+import jdk.jpackage.internal.util.Result;\n@@ -67,61 +38,0 @@\n-\/**\n- * WinMsiBundler\n- *\n- * Produces .msi installer from application image. Uses WiX Toolkit to build\n- * .msi installer.\n- * <p>\n- * {@link #execute} method creates a number of source files with the description\n- * of installer to be processed by WiX tools. Generated source files are stored\n- * in \"config\" subdirectory next to \"app\" subdirectory in the root work\n- * directory. The following WiX source files are generated:\n- * <ul>\n- * <li>main.wxs. Main source file with the installer description\n- * <li>bundle.wxf. Source file with application and Java run-time directory tree\n- * description.\n- * <li>ui.wxf. Source file with UI description of the installer.\n- * <\/ul>\n- *\n- * <p>\n- * main.wxs file is a copy of main.wxs resource from\n- * jdk.jpackage.internal.resources package. It is parametrized with the\n- * following WiX variables:\n- * <ul>\n- * <li>JpAppName. Name of the application. Set to the value of --name command\n- * line option\n- * <li>JpAppVersion. Version of the application. Set to the value of\n- * --app-version command line option\n- * <li>JpAppVendor. Vendor of the application. Set to the value of --vendor\n- * command line option\n- * <li>JpAppDescription. Description of the application. Set to the value of\n- * --description command line option\n- * <li>JpProductCode. Set to product code UUID of the application. Random value\n- * generated by jpackage every time {@link #execute} method is called\n- * <li>JpProductUpgradeCode. Set to upgrade code UUID of the application. Random\n- * value generated by jpackage every time {@link #execute} method is called if\n- * --win-upgrade-uuid command line option is not specified. Otherwise this\n- * variable is set to the value of --win-upgrade-uuid command line option\n- * <li>JpAllowUpgrades. Set to \"yes\", but all that matters is it is defined.\n- * <li>JpAllowDowngrades. Defined for application installers, and undefined for\n- * Java runtime installers.\n- * <li>JpConfigDir. Absolute path to the directory with generated WiX source\n- * files.\n- * <li>JpIsSystemWide. Set to \"yes\" if --win-per-user-install command line\n- * option was not specified. Undefined otherwise\n- * <li>JpAppSizeKb. Set to estimated size of the application in kilobytes\n- * <li>JpHelpURL. Set to value of --win-help-url command line option if it\n- * was specified. Undefined otherwise\n- * <li>JpAboutURL. Set to value of --about-url command line option if it\n- * was specified. Undefined otherwise\n- * <li>JpUpdateURL. Set to value of --win-update-url command line option if it\n- * was specified. Undefined otherwise\n- * <\/ul>\n- *\n- * <p>\n- * ui.wxf file is generated based on --license-file, --win-shortcut-prompt,\n- * --win-dir-chooser command line options. It is parametrized with the following\n- * WiX variables:\n- * <ul>\n- * <li>JpLicenseRtf. Set to the value of --license-file command line option.\n- * Undefined if --license-file command line option was not specified\n- * <\/ul>\n- *\/\n@@ -131,8 +41,0 @@\n-        wixFragments = Stream.of(\n-                Map.entry(\"bundle.wxf\", new WixAppImageFragmentBuilder()),\n-                Map.entry(\"ui.wxf\", new WixUiFragmentBuilder()),\n-                Map.entry(\"os-condition.wxf\", OSVersionCondition.createWixFragmentBuilder())\n-        ).<WixFragmentBuilder>map(e -> {\n-            e.getValue().setOutputFileName(e.getKey());\n-            return e.getValue();\n-        }).toList();\n@@ -159,2 +61,5 @@\n-            if (wixToolset == null) {\n-                wixToolset = WixTool.createToolset();\n+            try {\n+                sysEnv.orElseThrow();\n+                return true;\n+            } catch (RuntimeException ex) {\n+                ConfigException.rethrowConfigException(ex);\n@@ -162,1 +67,0 @@\n-            return true;\n@@ -180,1 +84,5 @@\n-    public boolean validate(Map<String, ? super Object> params)\n+    public boolean validate(Map<String, ? super Object> params) throws ConfigException {\n+        return validate(params, WinFromParams.MSI_PACKAGE);\n+    }\n+\n+    boolean validate(Map<String, ? super Object> params, BundlerParamInfo<? extends Package> pkgParam)\n@@ -184,1 +92,1 @@\n-            WinFromParams.APPLICATION.fetchFrom(params);\n+            pkgParam.fetchFrom(params);\n@@ -187,3 +95,1 @@\n-            if (wixToolset == null) {\n-                wixToolset = WixTool.createToolset();\n-            }\n+            final var wixToolset = sysEnv.orElseThrow().wixToolset();\n@@ -197,6 +103,0 @@\n-            wixFragments.forEach(wixFragment -> wixFragment.setWixVersion(wixToolset.getVersion(),\n-                    wixToolset.getType()));\n-\n-            wixFragments.stream().map(WixFragmentBuilder::getLoggableWixFeatures).flatMap(\n-                    List::stream).distinct().toList().forEach(Log::verbose);\n-\n@@ -209,31 +109,0 @@\n-    private void prepareProto(Package pkg, BuildEnv env, AppImageLayout appImageLayout) throws\n-            PackagerException, IOException {\n-\n-        \/\/ Configure installer icon\n-        if (appImageLayout instanceof RuntimeLayout runtimeLayout) {\n-            \/\/ Use icon from java launcher.\n-            \/\/ Assume java.exe exists in Java Runtime being packed.\n-            \/\/ Ignore custom icon if any as we don't want to copy anything in\n-            \/\/ Java Runtime image.\n-            installerIcon = runtimeLayout.runtimeDirectory().resolve(Path.of(\"bin\", \"java.exe\"));\n-        } else if (appImageLayout instanceof ApplicationLayout appLayout) {\n-            installerIcon = appLayout.launchersDirectory().resolve(\n-                    pkg.app().mainLauncher().orElseThrow().executableNameWithSuffix());\n-        }\n-        installerIcon = installerIcon.toAbsolutePath();\n-\n-        pkg.licenseFile().ifPresent(licenseFile -> {\n-            \/\/ need to copy license file to the working directory\n-            \/\/ and convert to rtf if needed\n-            Path destFile = env.configDir().resolve(licenseFile.getFileName());\n-\n-            try {\n-                IOUtils.copyFile(licenseFile, destFile);\n-            } catch (IOException ex) {\n-                throw new UncheckedIOException(ex);\n-            }\n-            destFile.toFile().setWritable(true);\n-            ensureByMutationFileIsRTF(destFile);\n-        });\n-    }\n-\n@@ -244,310 +113,6 @@\n-        IOUtils.writableOutputDir(outputParentDir);\n-\n-        \/\/ Order is important!\n-        var pkg = WinFromParams.MSI_PACKAGE.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        WinPackagingPipeline.build()\n-                .excludeDirFromCopying(outputParentDir)\n-                .task(PackagingPipeline.PackageTaskID.CREATE_CONFIG_FILES)\n-                        .packageAction(this::prepareConfigFiles)\n-                        .add()\n-                .task(PackagingPipeline.PackageTaskID.CREATE_PACKAGE_FILE)\n-                        .packageAction(this::buildPackage)\n-                        .add()\n-                .create().execute(env, pkg, outputParentDir);\n-\n-        return outputParentDir.resolve(pkg.packageFileNameWithSuffix()).toAbsolutePath();\n-    }\n-\n-    private void prepareConfigFiles(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        prepareProto(env.pkg(), env.env(), env.resolvedLayout());\n-        for (var wixFragment : wixFragments) {\n-            wixFragment.initFromParams(env.env(), env.pkg());\n-            wixFragment.addFilesToConfigRoot();\n-        }\n-\n-        final var msiOut = env.outputDir().resolve(env.pkg().packageFileNameWithSuffix());\n-\n-        Log.verbose(I18N.format(\"message.preparing-msi-config\", msiOut.toAbsolutePath()));\n-\n-        final var wixVars = createWixVars(env);\n-\n-        final var wixObjDir = env.env().buildRoot().resolve(\"wixobj\");\n-\n-        final var configDir = env.env().configDir();\n-\n-        final var wixPipelineBuilder = WixPipeline.build()\n-                .setWixObjDir(wixObjDir)\n-                .setWorkDir(env.env().appImageDir())\n-                .addSource(configDir.resolve(\"main.wxs\"), wixVars);\n-\n-        for (var wixFragment : wixFragments) {\n-            wixFragment.configureWixPipeline(wixPipelineBuilder);\n-        }\n-\n-        switch (wixToolset.getType()) {\n-            case Wix3 -> {\n-                wixPipelineBuilder.addLightOptions(\"-sice:ICE27\");\n-\n-                if (!env.pkg().isSystemWideInstall()) {\n-                    wixPipelineBuilder.addLightOptions(\"-sice:ICE91\");\n-                }\n-            }\n-            case Wix4 -> {\n-            }\n-            default -> {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        var primaryWxlFiles = Stream.of(\"de\", \"en\", \"ja\", \"zh_CN\").map(loc -> {\n-            return configDir.resolve(\"MsiInstallerStrings_\" + loc + \".wxl\");\n-        }).toList();\n-\n-        var wixResources = new WixSourceConverter.ResourceGroup(wixToolset.getType());\n-\n-        \/\/ Copy standard l10n files.\n-        for (var path : primaryWxlFiles) {\n-            var name = path.getFileName().toString();\n-            wixResources.addResource(env.env().createResource(name).setPublicName(name).setCategory(\n-                    I18N.getString(\"resource.wxl-file\")), path);\n-        }\n-\n-        wixResources.addResource(env.env().createResource(\"main.wxs\").setPublicName(\"main.wxs\").\n-                setCategory(I18N.getString(\"resource.main-wix-file\")), configDir.resolve(\"main.wxs\"));\n-\n-        wixResources.addResource(env.env().createResource(\"overrides.wxi\").setPublicName(\n-                \"overrides.wxi\").setCategory(I18N.getString(\"resource.overrides-wix-file\")),\n-                configDir.resolve(\"overrides.wxi\"));\n-\n-        \/\/ Filter out custom l10n files that were already used to\n-        \/\/ override primary l10n files. Ignore case filename comparison,\n-        \/\/ both lists are expected to be short.\n-        List<Path> customWxlFiles = env.env().resourceDir()\n-                .map(WinMsiBundler::getWxlFilesFromDir)\n-                .orElseGet(Collections::emptyList)\n-                .stream()\n-                .filter(custom -> primaryWxlFiles.stream().noneMatch(primary ->\n-                        primary.getFileName().toString().equalsIgnoreCase(\n-                                custom.getFileName().toString())))\n-                .peek(custom -> Log.verbose(I18N.format(\n-                        \"message.using-custom-resource\", String.format(\"[%s]\",\n-                                I18N.getString(\"resource.wxl-file\")),\n-                        custom.getFileName()))).toList();\n-\n-        \/\/ Copy custom l10n files.\n-        for (var path : customWxlFiles) {\n-            var name = path.getFileName().toString();\n-            wixResources.addResource(env.env().createResource(name).setPublicName(name).\n-                    setSourceOrder(OverridableResource.Source.ResourceDir).setCategory(I18N.\n-                    getString(\"resource.wxl-file\")), configDir.resolve(name));\n-        }\n-\n-        \/\/ Save all WiX resources into config dir.\n-        wixResources.saveResources();\n-\n-        \/\/ All l10n files are supplied to WiX with \"-loc\", but only\n-        \/\/ Cultures from custom files and a single primary Culture are\n-        \/\/ included into \"-cultures\" list\n-        for (var wxl : primaryWxlFiles) {\n-            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n-        }\n-\n-        List<String> cultures = new ArrayList<>();\n-        for (var wxl : customWxlFiles) {\n-            wxl = configDir.resolve(wxl.getFileName());\n-            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n-            cultures.add(getCultureFromWxlFile(wxl));\n-        }\n-\n-        \/\/ Append a primary culture bases on runtime locale.\n-        final Path primaryWxlFile = configDir.resolve(\n-                I18N.getString(\"resource.wxl-file-name\"));\n-        cultures.add(getCultureFromWxlFile(primaryWxlFile));\n-\n-        \/\/ Build ordered list of unique cultures.\n-        Set<String> uniqueCultures = new LinkedHashSet<>();\n-        uniqueCultures.addAll(cultures);\n-        switch (wixToolset.getType()) {\n-            case Wix3 -> {\n-                wixPipelineBuilder.addLightOptions(uniqueCultures.stream().collect(Collectors.joining(\";\",\n-                        \"-cultures:\", \"\")));\n-            }\n-            case Wix4 -> {\n-                uniqueCultures.forEach(culture -> {\n-                    wixPipelineBuilder.addLightOptions(\"-culture\", culture);\n-                });\n-            }\n-            default -> {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        Files.createDirectories(wixObjDir);\n-        wixPipeline = wixPipelineBuilder.create(wixToolset);\n-    }\n-\n-    private void buildPackage(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws PackagerException, IOException {\n-        final var msiOut = env.outputDir().resolve(env.pkg().packageFileNameWithSuffix());\n-        Log.verbose(I18N.format(\"message.generating-msi\", msiOut.toAbsolutePath()));\n-        wixPipeline.buildMsi(msiOut.toAbsolutePath());\n-    }\n-\n-    private Map<String, String> createWixVars(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        final var pkg = env.pkg();\n-\n-        data.put(\"JpProductCode\", pkg.productCode().toString());\n-        data.put(\"JpProductUpgradeCode\", pkg.upgradeCode().toString());\n-\n-        Log.verbose(I18N.format(\"message.product-code\", pkg.productCode()));\n-        Log.verbose(I18N.format(\"message.upgrade-code\", pkg.upgradeCode()));\n-\n-        data.put(\"JpAllowUpgrades\", \"yes\");\n-        if (!pkg.isRuntimeInstaller()) {\n-            data.put(\"JpAllowDowngrades\", \"yes\");\n-        }\n-\n-        data.put(\"JpAppName\", pkg.packageName());\n-        data.put(\"JpAppDescription\", pkg.description());\n-        data.put(\"JpAppVendor\", pkg.app().vendor());\n-        data.put(\"JpAppVersion\", pkg.version());\n-        if (Files.exists(installerIcon)) {\n-            data.put(\"JpIcon\", installerIcon.toString());\n-        }\n-\n-        pkg.helpURL().ifPresent(value -> {\n-            data.put(\"JpHelpURL\", value);\n-        });\n-\n-        pkg.updateURL().ifPresent(value -> {\n-            data.put(\"JpUpdateURL\", value);\n-        });\n-\n-        pkg.aboutURL().ifPresent(value -> {\n-            data.put(\"JpAboutURL\", value);\n-        });\n-\n-        data.put(\"JpAppSizeKb\", Long.toString(AppImageLayout.toPathGroup(\n-                env.resolvedLayout()).sizeInBytes() >> 10));\n-\n-        data.put(\"JpConfigDir\", env.env().configDir().toAbsolutePath().toString());\n-\n-        if (pkg.isSystemWideInstall()) {\n-            data.put(\"JpIsSystemWide\", \"yes\");\n-        }\n-\n-        return data;\n-    }\n-\n-    private static List<Path> getWxlFilesFromDir(Path dir) {\n-        final String glob = \"glob:**\/*.wxl\";\n-        final PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher(\n-                glob);\n-\n-        try (var walk = Files.walk(dir, 1)) {\n-            return walk\n-                    .filter(Files::isReadable)\n-                    .filter(pathMatcher::matches)\n-                    .sorted((a, b) -> a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString()))\n-                    .toList();\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        }\n-    }\n-\n-    private static String getCultureFromWxlFile(Path wxlPath) {\n-        try {\n-            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n-            factory.setNamespaceAware(false);\n-            DocumentBuilder builder = factory.newDocumentBuilder();\n-\n-            Document doc = builder.parse(wxlPath.toFile());\n-\n-            XPath xPath = XPathFactory.newInstance().newXPath();\n-            NodeList nodes = (NodeList) xPath.evaluate(\n-                    \"\/\/WixLocalization\/@Culture\", doc, XPathConstants.NODESET);\n-            if (nodes.getLength() != 1) {\n-                throw new IOException(I18N.format(\n-                        \"error.extract-culture-from-wix-l10n-file\",\n-                        wxlPath.toAbsolutePath().normalize()));\n-            }\n-\n-            return nodes.item(0).getNodeValue();\n-        } catch (XPathExpressionException | ParserConfigurationException\n-                | SAXException ex) {\n-            throw new UncheckedIOException(new IOException(\n-                    I18N.format(\"error.read-wix-l10n-file\", wxlPath.toAbsolutePath().normalize()), ex));\n-        } catch (IOException ex) {\n-            throw new UncheckedIOException(ex);\n-        }\n-    }\n-\n-    private static void ensureByMutationFileIsRTF(Path f) {\n-        try {\n-            boolean existingLicenseIsRTF = false;\n-\n-            try (InputStream fin = Files.newInputStream(f)) {\n-                byte[] firstBits = new byte[7];\n-\n-                if (fin.read(firstBits) == firstBits.length) {\n-                    String header = new String(firstBits);\n-                    existingLicenseIsRTF = \"{\\\\rtf1\\\\\".equals(header);\n-                }\n-            }\n-\n-            if (!existingLicenseIsRTF) {\n-                List<String> oldLicense = Files.readAllLines(f);\n-                try (Writer w = Files.newBufferedWriter(\n-                        f, Charset.forName(\"Windows-1252\"))) {\n-                    w.write(\"{\\\\rtf1\\\\ansi\\\\ansicpg1252\\\\deff0\\\\deflang1033\"\n-                            + \"{\\\\fonttbl{\\\\f0\\\\fnil\\\\fcharset0 Arial;}}\\n\"\n-                            + \"\\\\viewkind4\\\\uc1\\\\pard\\\\sa200\\\\sl276\"\n-                            + \"\\\\slmult1\\\\lang9\\\\fs20 \");\n-                    oldLicense.forEach(l -> {\n-                        try {\n-                            for (char c : l.toCharArray()) {\n-                                \/\/ 0x00 <= ch < 0x20 Escaped (\\'hh)\n-                                \/\/ 0x20 <= ch < 0x80 Raw(non - escaped) char\n-                                \/\/ 0x80 <= ch <= 0xFF Escaped(\\ 'hh)\n-                                \/\/ 0x5C, 0x7B, 0x7D (special RTF characters\n-                                \/\/ \\,{,})Escaped(\\'hh)\n-                                \/\/ ch > 0xff Escaped (\\\\ud###?)\n-                                if (c < 0x10) {\n-                                    w.write(\"\\\\'0\");\n-                                    w.write(Integer.toHexString(c));\n-                                } else if (c > 0xff) {\n-                                    w.write(\"\\\\ud\");\n-                                    w.write(Integer.toString(c));\n-                                    \/\/ \\\\uc1 is in the header and in effect\n-                                    \/\/ so we trail with a replacement char if\n-                                    \/\/ the font lacks that character - '?'\n-                                    w.write(\"?\");\n-                                } else if ((c < 0x20) || (c >= 0x80) ||\n-                                        (c == 0x5C) || (c == 0x7B) ||\n-                                        (c == 0x7D)) {\n-                                    w.write(\"\\\\'\");\n-                                    w.write(Integer.toHexString(c));\n-                                } else {\n-                                    w.write(c);\n-                                }\n-                            }\n-                            \/\/ blank lines are interpreted as paragraph breaks\n-                            if (l.length() < 1) {\n-                                w.write(\"\\\\par\");\n-                            } else {\n-                                w.write(\" \");\n-                            }\n-                            w.write(\"\\r\\n\");\n-                        } catch (IOException e) {\n-                            Log.verbose(e);\n-                        }\n-                    });\n-                    w.write(\"}\\r\\n\");\n-                }\n-            }\n-        } catch (IOException e) {\n-            Log.verbose(e);\n-        }\n+        return Packager.<WinMsiPackage>build().outputDir(outputParentDir)\n+                .pkg(WinFromParams.MSI_PACKAGE.fetchFrom(params))\n+                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n+                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n+                    return new WinMsiPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n+                }).execute(WinPackagingPipeline.build());\n@@ -556,4 +121,1 @@\n-    private Path installerIcon;\n-    private WixToolset wixToolset;\n-    private WixPipeline wixPipeline;\n-    private final List<WixFragmentBuilder> wixFragments;\n+    final Result<WinSystemEnvironment> sysEnv = WinSystemEnvironment.create();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":20,"deletions":458,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -0,0 +1,486 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.SAXException;\n+\n+\/**\n+ * WinMsiPackager\n+ *\n+ * Produces .msi installer from application image. Uses WiX Toolkit to build\n+ * .msi installer.\n+ * <p>\n+ * Creates a number of source files with the description\n+ * of installer to be processed by WiX tools. Generated source files are stored\n+ * in \"config\" subdirectory next to \"app\" subdirectory in the root work\n+ * directory. The following WiX source files are generated:\n+ * <ul>\n+ * <li>main.wxs. Main source file with the installer description\n+ * <li>bundle.wxf. Source file with application and Java run-time directory tree\n+ * description.\n+ * <li>ui.wxf. Source file with UI description of the installer.\n+ * <\/ul>\n+ *\n+ * <p>\n+ * main.wxs file is a copy of main.wxs resource from\n+ * jdk.jpackage.internal.resources package. It is parametrized with the\n+ * following WiX variables:\n+ * <ul>\n+ * <li>JpAppName. Name of the application. Set to the value of --name command\n+ * line option\n+ * <li>JpAppVersion. Version of the application. Set to the value of\n+ * --app-version command line option\n+ * <li>JpAppVendor. Vendor of the application. Set to the value of --vendor\n+ * command line option\n+ * <li>JpAppDescription. Description of the application. Set to the value of\n+ * --description command line option\n+ * <li>JpProductCode. Set to product code UUID of the application. Random value\n+ * generated by jpackage every time {@link #execute} method is called\n+ * <li>JpProductUpgradeCode. Set to upgrade code UUID of the application. Random\n+ * value generated by jpackage every time {@link #execute} method is called if\n+ * --win-upgrade-uuid command line option is not specified. Otherwise this\n+ * variable is set to the value of --win-upgrade-uuid command line option\n+ * <li>JpAllowUpgrades. Set to \"yes\", but all that matters is it is defined.\n+ * <li>JpAllowDowngrades. Defined for application installers, and undefined for\n+ * Java runtime installers.\n+ * <li>JpConfigDir. Absolute path to the directory with generated WiX source\n+ * files.\n+ * <li>JpIsSystemWide. Set to \"yes\" if --win-per-user-install command line\n+ * option was not specified. Undefined otherwise\n+ * <li>JpAppSizeKb. Set to estimated size of the application in kilobytes\n+ * <li>JpHelpURL. Set to value of --win-help-url command line option if it\n+ * was specified. Undefined otherwise\n+ * <li>JpAboutURL. Set to value of --about-url command line option if it\n+ * was specified. Undefined otherwise\n+ * <li>JpUpdateURL. Set to value of --win-update-url command line option if it\n+ * was specified. Undefined otherwise\n+ * <\/ul>\n+ *\n+ * <p>\n+ * ui.wxf file is generated based on --license-file, --win-shortcut-prompt,\n+ * --win-dir-chooser command line options. It is parametrized with the following\n+ * WiX variables:\n+ * <ul>\n+ * <li>JpLicenseRtf. Set to the value of --license-file command line option.\n+ * Undefined if --license-file command line option was not specified\n+ * <\/ul>\n+ *\/\n+final class WinMsiPackager implements Consumer<PackagingPipeline.Builder> {\n+\n+    WinMsiPackager(BuildEnv env, WinMsiPackage pkg, Path outputDir, WixToolset wixToolset) {\n+        this.pkg = Objects.requireNonNull(pkg);\n+        this.env = Objects.requireNonNull(env);\n+        this.outputDir = Objects.requireNonNull(outputDir);\n+        this.wixToolset = Objects.requireNonNull(wixToolset);\n+\n+        wixFragments = Stream.of(\n+                Map.entry(\"bundle.wxf\", new WixAppImageFragmentBuilder()),\n+                Map.entry(\"ui.wxf\", new WixUiFragmentBuilder()),\n+                Map.entry(\"os-condition.wxf\", OSVersionCondition.createWixFragmentBuilder())\n+        ).<WixFragmentBuilder>map(e -> {\n+            e.getValue().setOutputFileName(e.getKey());\n+            return e.getValue();\n+        }).toList();\n+\n+        \/\/ Configure installer icon\n+        if (env.appImageLayout() instanceof RuntimeLayout runtimeLayout) {\n+            \/\/ Use icon from java launcher.\n+            \/\/ Assume java.exe exists in Java Runtime being packed.\n+            \/\/ Ignore custom icon if any as we don't want to copy anything in\n+            \/\/ Java Runtime image.\n+            installerIcon = runtimeLayout.runtimeDirectory().resolve(Path.of(\"bin\", \"java.exe\")).toAbsolutePath();\n+        } else {\n+            installerIcon = env.asApplicationLayout().orElseThrow().launchersDirectory().resolve(\n+                    pkg.app().mainLauncher().orElseThrow().executableNameWithSuffix()).toAbsolutePath();\n+        }\n+\n+        wixFragments.forEach(wixFragment -> wixFragment.setWixVersion(wixToolset.getVersion(),\n+                wixToolset.getType()));\n+\n+        wixFragments.stream().map(WixFragmentBuilder::getLoggableWixFeatures).flatMap(\n+                List::stream).distinct().toList().forEach(Log::verbose);\n+    }\n+\n+    WinMsiPackager(BuildEnv env, WinMsiPackage pkg, Path outputDir, WinSystemEnvironment sysEnv) {\n+        this(env, pkg, outputDir, sysEnv.wixToolset());\n+    }\n+\n+    @Override\n+    public void accept(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder.excludeDirFromCopying(outputDir)\n+                .task(PackagingPipeline.PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::prepareConfigFiles)\n+                        .add()\n+                .task(PackagingPipeline.PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .action(this::buildPackage)\n+                        .add();\n+    }\n+\n+    private void prepareConfigFiles() throws PackagerException, IOException {\n+\n+        pkg.licenseFile().ifPresent(licenseFile -> {\n+            \/\/ need to copy license file to the working directory\n+            \/\/ and convert to rtf if needed\n+            Path destFile = env.configDir().resolve(licenseFile.getFileName());\n+\n+            try {\n+                IOUtils.copyFile(licenseFile, destFile);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            destFile.toFile().setWritable(true);\n+            ensureByMutationFileIsRTF(destFile);\n+        });\n+\n+        for (var wixFragment : wixFragments) {\n+            wixFragment.initFromParams(env, pkg);\n+            wixFragment.addFilesToConfigRoot();\n+        }\n+\n+        final var msiOut = outputDir.resolve(pkg.packageFileNameWithSuffix());\n+\n+        Log.verbose(I18N.format(\"message.preparing-msi-config\", msiOut.toAbsolutePath()));\n+\n+        final var wixVars = createWixVars();\n+\n+        final var wixObjDir = env.buildRoot().resolve(\"wixobj\");\n+\n+        final var configDir = env.configDir();\n+\n+        final var wixPipelineBuilder = WixPipeline.build()\n+                .setWixObjDir(wixObjDir)\n+                .setWorkDir(env.appImageDir())\n+                .addSource(configDir.resolve(\"main.wxs\"), wixVars);\n+\n+        for (var wixFragment : wixFragments) {\n+            wixFragment.configureWixPipeline(wixPipelineBuilder);\n+        }\n+\n+        switch (wixToolset.getType()) {\n+            case Wix3 -> {\n+                wixPipelineBuilder.addLightOptions(\"-sice:ICE27\");\n+\n+                if (!pkg.isSystemWideInstall()) {\n+                    wixPipelineBuilder.addLightOptions(\"-sice:ICE91\");\n+                }\n+            }\n+            case Wix4 -> {\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        var primaryWxlFiles = Stream.of(\"de\", \"en\", \"ja\", \"zh_CN\").map(loc -> {\n+            return configDir.resolve(\"MsiInstallerStrings_\" + loc + \".wxl\");\n+        }).toList();\n+\n+        var wixResources = new WixSourceConverter.ResourceGroup(wixToolset.getType());\n+\n+        \/\/ Copy standard l10n files.\n+        for (var path : primaryWxlFiles) {\n+            var name = path.getFileName().toString();\n+            wixResources.addResource(env.createResource(name).setPublicName(name).setCategory(\n+                    I18N.getString(\"resource.wxl-file\")), path);\n+        }\n+\n+        wixResources.addResource(env.createResource(\"main.wxs\").setPublicName(\"main.wxs\").\n+                setCategory(I18N.getString(\"resource.main-wix-file\")), configDir.resolve(\"main.wxs\"));\n+\n+        wixResources.addResource(env.createResource(\"overrides.wxi\").setPublicName(\n+                \"overrides.wxi\").setCategory(I18N.getString(\"resource.overrides-wix-file\")),\n+                configDir.resolve(\"overrides.wxi\"));\n+\n+        \/\/ Filter out custom l10n files that were already used to\n+        \/\/ override primary l10n files. Ignore case filename comparison,\n+        \/\/ both lists are expected to be short.\n+        List<Path> customWxlFiles = env.resourceDir()\n+                .map(WinMsiPackager::getWxlFilesFromDir)\n+                .orElseGet(Collections::emptyList)\n+                .stream()\n+                .filter(custom -> primaryWxlFiles.stream().noneMatch(primary ->\n+                        primary.getFileName().toString().equalsIgnoreCase(\n+                                custom.getFileName().toString())))\n+                .peek(custom -> Log.verbose(I18N.format(\n+                        \"message.using-custom-resource\", String.format(\"[%s]\",\n+                                I18N.getString(\"resource.wxl-file\")),\n+                        custom.getFileName()))).toList();\n+\n+        \/\/ Copy custom l10n files.\n+        for (var path : customWxlFiles) {\n+            var name = path.getFileName().toString();\n+            wixResources.addResource(env.createResource(name).setPublicName(name).\n+                    setSourceOrder(OverridableResource.Source.ResourceDir).setCategory(I18N.\n+                    getString(\"resource.wxl-file\")), configDir.resolve(name));\n+        }\n+\n+        \/\/ Save all WiX resources into config dir.\n+        wixResources.saveResources();\n+\n+        \/\/ All l10n files are supplied to WiX with \"-loc\", but only\n+        \/\/ Cultures from custom files and a single primary Culture are\n+        \/\/ included into \"-cultures\" list\n+        for (var wxl : primaryWxlFiles) {\n+            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n+        }\n+\n+        List<String> cultures = new ArrayList<>();\n+        for (var wxl : customWxlFiles) {\n+            wxl = configDir.resolve(wxl.getFileName());\n+            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n+            cultures.add(getCultureFromWxlFile(wxl));\n+        }\n+\n+        \/\/ Append a primary culture bases on runtime locale.\n+        final Path primaryWxlFile = configDir.resolve(\n+                I18N.getString(\"resource.wxl-file-name\"));\n+        cultures.add(getCultureFromWxlFile(primaryWxlFile));\n+\n+        \/\/ Build ordered list of unique cultures.\n+        Set<String> uniqueCultures = new LinkedHashSet<>();\n+        uniqueCultures.addAll(cultures);\n+        switch (wixToolset.getType()) {\n+            case Wix3 -> {\n+                wixPipelineBuilder.addLightOptions(uniqueCultures.stream().collect(Collectors.joining(\";\",\n+                        \"-cultures:\", \"\")));\n+            }\n+            case Wix4 -> {\n+                uniqueCultures.forEach(culture -> {\n+                    wixPipelineBuilder.addLightOptions(\"-culture\", culture);\n+                });\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        Files.createDirectories(wixObjDir);\n+        wixPipeline = wixPipelineBuilder.create(wixToolset);\n+    }\n+\n+    private void buildPackage() throws PackagerException, IOException {\n+        final var msiOut = outputDir.resolve(pkg.packageFileNameWithSuffix());\n+        Log.verbose(I18N.format(\"message.generating-msi\", msiOut.toAbsolutePath()));\n+        wixPipeline.buildMsi(msiOut.toAbsolutePath());\n+    }\n+\n+    private Map<String, String> createWixVars() throws IOException {\n+        Map<String, String> data = new HashMap<>();\n+\n+        data.put(\"JpProductCode\", pkg.productCode().toString());\n+        data.put(\"JpProductUpgradeCode\", pkg.upgradeCode().toString());\n+\n+        Log.verbose(I18N.format(\"message.product-code\", pkg.productCode()));\n+        Log.verbose(I18N.format(\"message.upgrade-code\", pkg.upgradeCode()));\n+\n+        data.put(\"JpAllowUpgrades\", \"yes\");\n+        if (!pkg.isRuntimeInstaller()) {\n+            data.put(\"JpAllowDowngrades\", \"yes\");\n+        }\n+\n+        data.put(\"JpAppName\", pkg.packageName());\n+        data.put(\"JpAppDescription\", pkg.description());\n+        data.put(\"JpAppVendor\", pkg.app().vendor());\n+        data.put(\"JpAppVersion\", pkg.version());\n+        if (Files.exists(installerIcon)) {\n+            data.put(\"JpIcon\", installerIcon.toString());\n+        }\n+\n+        pkg.helpURL().ifPresent(value -> {\n+            data.put(\"JpHelpURL\", value);\n+        });\n+\n+        pkg.updateURL().ifPresent(value -> {\n+            data.put(\"JpUpdateURL\", value);\n+        });\n+\n+        pkg.aboutURL().ifPresent(value -> {\n+            data.put(\"JpAboutURL\", value);\n+        });\n+\n+        data.put(\"JpAppSizeKb\", Long.toString(AppImageLayout.toPathGroup(\n+                env.appImageLayout()).sizeInBytes() >> 10));\n+\n+        data.put(\"JpConfigDir\", env.configDir().toAbsolutePath().toString());\n+\n+        if (pkg.isSystemWideInstall()) {\n+            data.put(\"JpIsSystemWide\", \"yes\");\n+        }\n+\n+        return data;\n+    }\n+\n+    private static List<Path> getWxlFilesFromDir(Path dir) {\n+        final String glob = \"glob:**\/*.wxl\";\n+        final PathMatcher pathMatcher = FileSystems.getDefault().getPathMatcher(\n+                glob);\n+\n+        try (var walk = Files.walk(dir, 1)) {\n+            return walk\n+                    .filter(Files::isReadable)\n+                    .filter(pathMatcher::matches)\n+                    .sorted((a, b) -> a.getFileName().toString().compareToIgnoreCase(b.getFileName().toString()))\n+                    .toList();\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static String getCultureFromWxlFile(Path wxlPath) {\n+        try {\n+            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+            factory.setNamespaceAware(false);\n+            DocumentBuilder builder = factory.newDocumentBuilder();\n+\n+            Document doc = builder.parse(wxlPath.toFile());\n+\n+            XPath xPath = XPathFactory.newInstance().newXPath();\n+            NodeList nodes = (NodeList) xPath.evaluate(\n+                    \"\/\/WixLocalization\/@Culture\", doc, XPathConstants.NODESET);\n+            if (nodes.getLength() != 1) {\n+                throw new RuntimeException(I18N.format(\n+                        \"error.extract-culture-from-wix-l10n-file\",\n+                        wxlPath.toAbsolutePath().normalize()));\n+            }\n+\n+            return nodes.item(0).getNodeValue();\n+        } catch (XPathExpressionException | ParserConfigurationException | SAXException ex) {\n+            throw new RuntimeException(I18N.format(\n+                    \"error.read-wix-l10n-file\", wxlPath.toAbsolutePath().normalize()), ex);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static void ensureByMutationFileIsRTF(Path f) {\n+        try {\n+            boolean existingLicenseIsRTF = false;\n+\n+            try (InputStream fin = Files.newInputStream(f)) {\n+                byte[] firstBits = new byte[7];\n+\n+                if (fin.read(firstBits) == firstBits.length) {\n+                    String header = new String(firstBits);\n+                    existingLicenseIsRTF = \"{\\\\rtf1\\\\\".equals(header);\n+                }\n+            }\n+\n+            if (!existingLicenseIsRTF) {\n+                List<String> oldLicense = Files.readAllLines(f);\n+                try (Writer w = Files.newBufferedWriter(\n+                        f, Charset.forName(\"Windows-1252\"))) {\n+                    w.write(\"{\\\\rtf1\\\\ansi\\\\ansicpg1252\\\\deff0\\\\deflang1033\"\n+                            + \"{\\\\fonttbl{\\\\f0\\\\fnil\\\\fcharset0 Arial;}}\\n\"\n+                            + \"\\\\viewkind4\\\\uc1\\\\pard\\\\sa200\\\\sl276\"\n+                            + \"\\\\slmult1\\\\lang9\\\\fs20 \");\n+                    oldLicense.forEach(l -> {\n+                        try {\n+                            for (char c : l.toCharArray()) {\n+                                \/\/ 0x00 <= ch < 0x20 Escaped (\\'hh)\n+                                \/\/ 0x20 <= ch < 0x80 Raw(non - escaped) char\n+                                \/\/ 0x80 <= ch <= 0xFF Escaped(\\ 'hh)\n+                                \/\/ 0x5C, 0x7B, 0x7D (special RTF characters\n+                                \/\/ \\,{,})Escaped(\\'hh)\n+                                \/\/ ch > 0xff Escaped (\\\\ud###?)\n+                                if (c < 0x10) {\n+                                    w.write(\"\\\\'0\");\n+                                    w.write(Integer.toHexString(c));\n+                                } else if (c > 0xff) {\n+                                    w.write(\"\\\\ud\");\n+                                    w.write(Integer.toString(c));\n+                                    \/\/ \\\\uc1 is in the header and in effect\n+                                    \/\/ so we trail with a replacement char if\n+                                    \/\/ the font lacks that character - '?'\n+                                    w.write(\"?\");\n+                                } else if ((c < 0x20) || (c >= 0x80) ||\n+                                        (c == 0x5C) || (c == 0x7B) ||\n+                                        (c == 0x7D)) {\n+                                    w.write(\"\\\\'\");\n+                                    w.write(Integer.toHexString(c));\n+                                } else {\n+                                    w.write(c);\n+                                }\n+                            }\n+                            \/\/ blank lines are interpreted as paragraph breaks\n+                            if (l.length() < 1) {\n+                                w.write(\"\\\\par\");\n+                            } else {\n+                                w.write(\" \");\n+                            }\n+                            w.write(\"\\r\\n\");\n+                        } catch (IOException e) {\n+                            Log.verbose(e);\n+                        }\n+                    });\n+                    w.write(\"}\\r\\n\");\n+                }\n+            }\n+        } catch (IOException e) {\n+            Log.verbose(e);\n+        }\n+    }\n+\n+    private final WinMsiPackage pkg;\n+    private final BuildEnv env;\n+    private final Path outputDir;\n+    private final WixToolset wixToolset;\n+    private final List<WixFragmentBuilder> wixFragments;\n+    private final Path installerIcon;\n+    private WixPipeline wixPipeline;\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiPackager.java","additions":486,"deletions":0,"binary":false,"changes":486,"status":"added"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.jpackage.internal.model.Package;\n@@ -50,1 +49,0 @@\n-                .appImageLayoutForPackaging(Package::appImageLayout)\n@@ -61,1 +59,1 @@\n-            final var iconTarget = createLauncherIconResource(env.app(), launcher, env.env()::createResource).map(iconResource -> {\n+            final var iconTarget = createLauncherIconResource(launcher, env.env()::createResource).map(iconResource -> {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinPackagingPipeline.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.Result;\n+\n+record WinSystemEnvironment(WixToolset wixToolset) implements SystemEnvironment {\n+\n+    WinSystemEnvironment {\n+        Objects.requireNonNull(wixToolset);\n+    }\n+\n+    static Result<WinSystemEnvironment> create() {\n+        return Result.create(toSupplier(WixTool::createToolset)).map(WinSystemEnvironment::new);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinSystemEnvironment.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -28,6 +28,3 @@\n-import jdk.jpackage.internal.model.WinLauncher;\n-import jdk.jpackage.internal.model.WinMsiPackage;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-import jdk.jpackage.internal.util.PathGroup;\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.util.CollectionUtils.toCollection;\n+\n@@ -53,1 +50,0 @@\n-import static java.util.stream.Collectors.toMap;\n@@ -63,2 +59,0 @@\n-import static jdk.jpackage.internal.util.CollectionUtils.toCollection;\n-import jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut;\n@@ -67,0 +61,2 @@\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -68,0 +64,5 @@\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.WinLauncher;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+import jdk.jpackage.internal.util.PathGroup;\n@@ -69,1 +70,0 @@\n-import jdk.jpackage.internal.util.XmlUtils;\n@@ -71,1 +71,1 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import jdk.jpackage.internal.util.XmlUtils;\n@@ -251,1 +251,1 @@\n-                return IOUtils.getFileName(path).toString();\n+                return path.getFileName().toString();\n@@ -355,1 +355,1 @@\n-    };\n+    }\n@@ -472,1 +472,15 @@\n-                    String componentId = addShortcutComponent(xml, launcherPath, folder);\n+                    var workDirectory = folder.shortcut(launcher).startupDirectory().map(v -> {\n+                        switch (v) {\n+                            case DEFAULT -> {\n+                                return INSTALLDIR;\n+                            }\n+                            case APP_DIR -> {\n+                                return installedAppImage.appDirectory();\n+                            }\n+                            default -> {\n+                                throw new AssertionError();\n+                            }\n+                        }\n+                    }).orElseThrow();\n+\n+                    String componentId = addShortcutComponent(xml, launcherPath, folder, workDirectory);\n@@ -502,1 +516,1 @@\n-            ShortcutsFolder folder) throws XMLStreamException, IOException {\n+            ShortcutsFolder folder, Path shortcutWorkDir) throws XMLStreamException, IOException {\n@@ -509,0 +523,4 @@\n+        if (!INSTALLDIR.equals(shortcutWorkDir.getName(0))) {\n+            throw throwInvalidPathException(shortcutWorkDir);\n+        }\n+\n@@ -510,1 +528,1 @@\n-                IOUtils.getFileName(launcherPath), \"\").toString();\n+                launcherPath.getFileName(), \"\").toString();\n@@ -515,1 +533,1 @@\n-            xml.writeAttribute(\"WorkingDirectory\", INSTALLDIR.toString());\n+            xml.writeAttribute(\"WorkingDirectory\", Id.Folder.of(shortcutWorkDir));\n@@ -517,2 +535,1 @@\n-            xml.writeAttribute(\"Target\", String.format(\"[#%s]\",\n-                    Component.File.idOf(launcherPath)));\n+            xml.writeAttribute(\"Target\", String.format(\"[#%s]\", Id.File.of(launcherPath)));\n@@ -698,1 +715,1 @@\n-            xml.writeAttribute(\"Name\", IOUtils.getFileName(dir).toString());\n+            xml.writeAttribute(\"Name\", dir.getFileName().toString());\n@@ -804,1 +821,1 @@\n-                if (IOUtils.getFileName(src).toString().endsWith(\".ico\")) {\n+                if (src.getFileName().toString().endsWith(\".ico\")) {\n@@ -909,1 +926,1 @@\n-        ProgramMenu(PROGRAM_MENU_PATH, WinShortcut.WIN_SHORTCUT_START_MENU,\n+        ProgramMenu(PROGRAM_MENU_PATH, WinLauncher::startMenuShortcut,\n@@ -911,1 +928,1 @@\n-        Desktop(DESKTOP_PATH, WinShortcut.WIN_SHORTCUT_DESKTOP,\n+        Desktop(DESKTOP_PATH, WinLauncher::desktopShortcut,\n@@ -914,1 +931,1 @@\n-        private ShortcutsFolder(Path root, WinShortcut shortcutId,\n+        private ShortcutsFolder(Path root, Function<WinLauncher, Optional<LauncherShortcut>> shortcut,\n@@ -917,1 +934,1 @@\n-            this.shortcutId = shortcutId;\n+            this.shortcut = shortcut;\n@@ -930,1 +947,5 @@\n-            return launcher.shortcuts().contains(shortcutId);\n+            return LauncherShortcut.toRequest(shortcut.apply(launcher)).orElse(false);\n+        }\n+\n+        LauncherShortcut shortcut(WinLauncher launcher) {\n+            return shortcut.apply(launcher).orElseThrow();\n@@ -950,1 +971,1 @@\n-        private final WinShortcut shortcutId;\n+        private final Function<WinLauncher, Optional<LauncherShortcut>> shortcut;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":48,"deletions":27,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-        Files.createDirectories(IOUtils.getParent(msi));\n+        Files.createDirectories(msi.getParent());\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixPipeline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.TreeMap;\n@@ -93,1 +94,1 @@\n-    Status appyTo(OverridableResource resource, Path resourceSaveAsFile) throws IOException {\n+    Status applyTo(OverridableResource resource, Path resourceSaveAsFile) throws IOException {\n@@ -147,1 +148,1 @@\n-            Files.createDirectories(IOUtils.getParent(resourceSaveAsFile));\n+            Files.createDirectories(resourceSaveAsFile.getParent());\n@@ -187,1 +188,1 @@\n-                        conv.appyTo(e.getValue(), e.getKey());\n+                        conv.applyTo(e.getValue(), e.getKey());\n@@ -196,1 +197,1 @@\n-        private final Map<Path, OverridableResource> resources = new HashMap<>();\n+        private final Map<Path, OverridableResource> resources = new TreeMap<>();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixSourceConverter.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -186,7 +186,6 @@\n-            final var validator = new ToolValidator(toolPath).setMinimalVersion(tool.minimalVersion).\n-                    setToolNotFoundErrorHandler((name, ex) -> {\n-                        return new ConfigException(\"\", \"\");\n-                    }).setToolOldVersionErrorHandler((name, version) -> {\n-                tooOld[0] = true;\n-                return null;\n-            });\n+            final var validator = new ToolValidator(toolPath)\n+                    .setMinimalVersion(tool.minimalVersion)\n+                    .setToolOldVersionErrorHandler((name, version) -> {\n+                        tooOld[0] = true;\n+                        return null;\n+                    });\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixTool.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                pkg.installedPackageLayout(),\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinExePackage.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import static java.util.stream.Collectors.toMap;\n-\n@@ -30,0 +28,1 @@\n+import java.util.HashMap;\n@@ -50,1 +49,8 @@\n-        return shortcuts().stream().collect(toMap(WinShortcut::name, v -> Boolean.toString(true)));\n+        Map<String, String> map = new HashMap<>();\n+        desktopShortcut().ifPresent(shortcut -> {\n+            shortcut.store(SHORTCUT_DESKTOP_ID, map::put);\n+        });\n+        startMenuShortcut().ifPresent(shortcut -> {\n+            shortcut.store(SHORTCUT_START_MENU_ID, map::put);\n+        });\n+        return map;\n@@ -56,0 +62,3 @@\n+\n+    public static final String SHORTCUT_START_MENU_ID = \"win-menu\";\n+    public static final String SHORTCUT_DESKTOP_ID = \"win-shortcut\";\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncher.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.util.Set;\n+import java.util.Optional;\n@@ -33,19 +33,26 @@\n-    enum WinShortcut {\n-        WIN_SHORTCUT_DESKTOP(\"shortcut\"),\n-        WIN_SHORTCUT_START_MENU(\"menu\"),\n-        ;\n-\n-        WinShortcut(String name) {\n-            this.name = name;\n-        }\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        private final String name;\n-    }\n-\n-    Set<WinShortcut> shortcuts();\n-\n-    record Stub(boolean isConsole, Set<WinShortcut> shortcuts) implements WinLauncherMixin {\n+    \/**\n+     * Gets the start menu shortcut of this application launcher.\n+     * <p>\n+     * Returns a non-empty {@link Optional} instance if a request about the start\n+     * menu shortcut for this application launcher was made and an empty\n+     * {@link Optional} instance if there was no request about the start menu\n+     * shortcut for this application launcher.\n+     *\n+     * @return the start menu shortcut of this application launcher\n+     *\/\n+    Optional<LauncherShortcut> startMenuShortcut();\n+\n+    \/**\n+     * Gets the desktop shortcut of this application launcher.\n+     * <p>\n+     * Returns a non-empty {@link Optional} instance if a request about the desktop\n+     * shortcut for this application launcher was made and an empty {@link Optional}\n+     * instance if there was no request about the desktop shortcut for this\n+     * application launcher.\n+     *\n+     * @return the start menu shortcut of this application launcher\n+     *\/\n+    Optional<LauncherShortcut> desktopShortcut();\n+\n+    record Stub(boolean isConsole, Optional<LauncherShortcut> startMenuShortcut,\n+            Optional<LauncherShortcut> desktopShortcut) implements WinLauncherMixin {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncherMixin.java","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+                        .sorted()\n","filename":"test\/jdk\/tools\/jpackage\/apps\/PrintEnv.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,2 +123,1 @@\n-      -e 's|\"\/.*\/jdk.jpackage[0-9]\\{1,\\}\/|\"\/jdk.jpackage\/|' \\\n-      -e 's|\"file:\/\/\/.*\/jdk.jpackage[0-9]\\{1,\\}\/|\"file:\/\/\/jdk.jpackage\/|' \\\n+      -e 's|\/jdk.jpackage[0-9]\\{1,\\}\/|\/jdk.jpackage\/|' \\\n","filename":"test\/jdk\/tools\/jpackage\/clean_stashed_files.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+      # Strip variable part of temporary directory name `jdk.jpackage.test217379316521032539`\n+      -e 's|\\([\\\/]\\)jdk\\.jpackage\\.test[0-9]\\{1,\\}\\b|\\1jdk.jpackage.test|g'\n+\n@@ -79,0 +82,35 @@\n+\n+      # Whipe out entire output of \/usr\/bin\/hdiutil command.\n+      # It is of little to no interest and contains too many variable parts to deal with individually.\n+      -e '\/^Running \\\/usr\\\/bin\\\/hdiutil\/,\/^Returned:\/{\n+            \/\/,\/^Output:\/!d\n+          }'\n+\n+      # Zip stack traces.\n+      -e $'\/^\\tat \/{\n+            :a\n+            g\n+            N\n+            s\/.*\\\\n\/\/\n+            \/^\\tat \/ba\n+            s\/\\\\(^\\t... \\\\)[0-9]\\\\{1,\\\\}\\\\( more\\\\)\/\\\\1N\\\\2\/\n+            s\/\\(.*\\)\/\\tat <stacktrace>\\\\n\\\\1\/\n+            P\n+            D\n+          }'\n+\n+      # Convert PID value in `taskkill \/F \/PID 5640`\n+      -e 's|taskkill \/F \/PID [0-9]\\{1,\\}|taskkill \/F \/PID <pid>|'\n+\n+      # Convert PID value in `The process with PID 5640 has been terminated`\n+      -e 's|\\(The process with PID \\)[0-9]\\{1,\\}\\( has been terminated\\)|\\1<pid>\\2|'\n+\n+      # Convert timeout value in `Check timeout value 57182ms is positive`\n+      -e 's|\\(Check timeout value \\)[0-9]\\{1,\\}\\(ms is positive\\)|\\1<timeout>\\2|'\n+\n+      # Convert variable part of \/usr\/bin\/osascript output `jdk.jpackage\/config\/SigningRuntimeImagePackageTest-dmg-setup.scpt:455:497: execution error: Finder got an error: Cant set 1 to icon view. (-10006)`\n+      -e 's|\\(-dmg-setup.scpt:\\)[0-9]\\{1,\\}:[0-9]\\{1,\\}\\(: execution error: \\)|\\1<N:M>\\2|'\n+\n+      # Use the same name for all exceptions.\n+      -e 's|[^ ]\\{1,\\}\\.[^ ]\\{1,\\}\\Exception:|<Exception>:|g'\n+      -e 's|[^ ]\\{1,\\}\\.[^ ]\\{1,\\}\\ExceptionBox:|<Exception>:|g'\n","filename":"test\/jdk\/tools\/jpackage\/clean_test_output.sh","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/helpers-test\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,0 +98,12 @@\n+        enum Tack {\n+            STARBOARD,\n+            PORTSIDE;\n+        }\n+\n+        @Test\n+        @Parameter({\"STARBOARD\"})\n+        @Parameter({\"PORTSIDE\", \"STARBOARD\"})\n+        public void testEnumVarArg(Tack ... cource) {\n+            recordTestCase((Object[]) cource);\n+        }\n+\n@@ -121,0 +133,2 @@\n+                    \"().testEnumVarArg(STARBOARD)\",\n+                    \"().testEnumVarArg(PORTSIDE, STARBOARD)\",\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/AnnotationsTest.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.Map;\n+import org.junit.jupiter.api.Test;\n+\n+public class JUnitUtilsTest {\n+\n+    @Test\n+    public void test_assertArrayEquals() {\n+        JUnitUtils.assertArrayEquals(new int[] {1, 2, 3}, new int[] {1, 2, 3});\n+        JUnitUtils.assertArrayEquals(new long[] {1, 2, 3}, new long[] {1, 2, 3});\n+        JUnitUtils.assertArrayEquals(new boolean[] {true, true}, new boolean[] {true, true});\n+    }\n+\n+    @Test\n+    public void test_assertArrayEquals_negative() {\n+        assertThrows(AssertionError.class, () -> {\n+            JUnitUtils.assertArrayEquals(new int[] {1, 2, 3}, new int[] {2, 3});\n+        });\n+    }\n+\n+    @Test\n+    public void test_exceptionAsPropertyMapWithMessageWithoutCause() {\n+\n+        var ex = new Exception(\"foo\");\n+\n+        var map = JUnitUtils.exceptionAsPropertyMap(ex);\n+\n+        assertEquals(Map.of(\"getClass\", Exception.class.getName(), \"getMessage\", \"foo\"), map);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JUnitUtilsTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -45,5 +45,4 @@\n-    public static void testClassFilePath(String... args) {\n-        var appDesc = args[0];\n-        var expectedClassFilePath = Path.of(args[1]);\n-        TKit.assertEquals(expectedClassFilePath.toString(), JavaAppDesc.parse(\n-                appDesc).classFilePath().toString(), null);\n+    public static void testClassFilePath(String appDesc, String expectedClassFile) {\n+        var expectedClassFilePath = Path.of(expectedClassFile);\n+        TKit.assertEquals(expectedClassFilePath.toString(),\n+                JavaAppDesc.parse(appDesc).classFilePath().toString(), null);\n@@ -58,0 +57,6 @@\n+            createTestCase(\"bye.jar:!\", appDesc -> {\n+                return appDesc\n+                        .setBundleFileName(\"bye.jar\")\n+                        .setClassName(\"Hello\")\n+                        .setWithMainClass(true);\n+            }),\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JavaAppDescTest.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.Map.entry;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.UncheckedIOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import jdk.jpackage.internal.util.PListReader;\n+import jdk.jpackage.internal.util.XmlUtils;\n+import org.junit.jupiter.api.Test;\n+import org.w3c.dom.Node;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+\n+public class MacHelperTest {\n+\n+    @Test\n+    public void test_flatMapPList() {\n+        var props = MacHelper.flatMapPList(new PListReader(createXml(\n+                \"<key>AppName<\/key>\",\n+                \"<string>Hello<\/string>\",\n+                \"<key>AppVersion<\/key>\",\n+                \"<real>1.0<\/real>\",\n+                \"<key>UserData<\/key>\",\n+                \"<dict>\",\n+                \"  <key>Foo<\/key>\",\n+                \"  <array>\",\n+                \"    <string>Str<\/string>\",\n+                \"    <array>\",\n+                \"      <string>Another Str<\/string>\",\n+                \"      <true\/>\",\n+                \"      <false\/>\",\n+                \"    <\/array>\",\n+                \"  <\/array>\",\n+                \"<\/dict>\",\n+                \"<key>Checksum<\/key>\",\n+                \"<data>7841ff0076cdde93bdca02cfd332748c40620ce4<\/data>\",\n+                \"<key>Plugins<\/key>\",\n+                \"<array>\",\n+                \"  <dict>\",\n+                \"    <key>PluginName<\/key>\",\n+                \"    <string>Foo<\/string>\",\n+                \"    <key>Priority<\/key>\",\n+                \"    <integer>13<\/integer>\",\n+                \"    <key>History<\/key>\",\n+                \"    <array>\",\n+                \"      <string>New File<\/string>\",\n+                \"      <string>Another New File<\/string>\",\n+                \"    <\/array>\",\n+                \"  <\/dict>\",\n+                \"  <dict>\",\n+                \"    <key>PluginName<\/key>\",\n+                \"    <string>Bar<\/string>\",\n+                \"    <key>Priority<\/key>\",\n+                \"    <real>23<\/real>\",\n+                \"    <key>History<\/key>\",\n+                \"    <array\/>\",\n+                \"  <\/dict>\",\n+                \"  <dict\/>\",\n+                \"<\/array>\"\n+        )));\n+\n+        assertEquals(Map.ofEntries(\n+                entry(\"\/AppName\", \"Hello\"),\n+                entry(\"\/AppVersion\", \"1.0\"),\n+                entry(\"\/UserData\/Foo[0]\", \"Str\"),\n+                entry(\"\/UserData\/Foo[1][0]\", \"Another Str\"),\n+                entry(\"\/UserData\/Foo[1][1]\", \"true\"),\n+                entry(\"\/UserData\/Foo[1][2]\", \"false\"),\n+                entry(\"\/Checksum\", \"7841ff0076cdde93bdca02cfd332748c40620ce4\"),\n+                entry(\"\/Plugins[0]\/PluginName\", \"Foo\"),\n+                entry(\"\/Plugins[0]\/Priority\", \"13\"),\n+                entry(\"\/Plugins[0]\/History[0]\", \"New File\"),\n+                entry(\"\/Plugins[0]\/History[1]\", \"Another New File\"),\n+                entry(\"\/Plugins[1]\/PluginName\", \"Bar\"),\n+                entry(\"\/Plugins[1]\/Priority\", \"23\"),\n+                entry(\"\/Plugins[1]\/History[]\", \"\"),\n+                entry(\"\/Plugins[2]{}\", \"\")\n+        ), props);\n+    }\n+\n+    private static String createPListXml(String ...xml) {\n+        final List<String> content = new ArrayList<>();\n+        content.add(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n+        content.add(\"<plist version=\\\"1.0\\\">\");\n+        content.add(\"<dict>\");\n+        content.addAll(List.of(xml));\n+        content.add(\"<\/dict>\");\n+        content.add(\"<\/plist>\");\n+        return String.join(\"\", content.toArray(String[]::new));\n+    }\n+\n+    private static Node createXml(String ...xml) {\n+        try {\n+            return XmlUtils.initDocumentBuilder().parse(new InputSource(new StringReader(createPListXml(xml))));\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        } catch (SAXException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/MacHelperTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,731 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import org.junit.jupiter.api.Test;\n+\n+public class ObjectMapperTest {\n+\n+    @Test\n+    public void test_String() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(\"foo\");\n+\n+        assertEquals(\"foo\", map);\n+    }\n+\n+    @Test\n+    public void test_int() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(100);\n+\n+        assertEquals(100, map);\n+    }\n+\n+    @Test\n+    public void test_null() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(null);\n+\n+        assertNull(map);\n+    }\n+\n+    @Test\n+    public void test_Object() {\n+        var obj = new Object();\n+        assertSame(obj, ObjectMapper.blank().create().map(obj));\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_Path() {\n+        var obj = Path.of(\"foo\/bar\");\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_UUID() {\n+        var obj = UUID.randomUUID();\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_BigInteger() {\n+        var obj = BigInteger.TEN;\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_Enum() {\n+\n+        var expected = Map.of(\n+                \"name\", TestEnum.BAR.name(),\n+                \"ordinal\", TestEnum.BAR.ordinal(),\n+                \"a\", \"A\",\n+                \"b\", 123,\n+                \"num\", 100\n+        );\n+\n+        assertEquals(expected, ObjectMapper.standard().create().map(TestEnum.BAR));\n+    }\n+\n+    @Test\n+    public void test_array_int() {\n+\n+        var obj = new int[] { 1, 4, 5 };\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_String() {\n+\n+        var obj = new String[] { \"Hello\", \"Bye\" };\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_empty() {\n+\n+        var obj = new Thread[0];\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_nulls() {\n+\n+        var obj = new Thread[10];\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_Path() {\n+\n+        var obj = new Path[] { Path.of(\"foo\/bar\"), null, Path.of(\"\").toAbsolutePath() };\n+\n+        assertSame(obj, ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_array_Object() {\n+\n+        var obj = new Object[] { Path.of(\"foo\/bar\"), null, 145, new Simple.Stub(\"Hello\", 738), \"foo\" };\n+\n+        var expected = new Object[] { Path.of(\"foo\/bar\"), null, 145, Map.of(\"a\", \"Hello\", \"b\", 738), \"foo\" };\n+\n+        assertArrayEquals(expected, (Object[])ObjectMapper.standard().create().map(obj));\n+    }\n+\n+    @Test\n+    public void test_functional() {\n+        assertWrappedIdentity(new Function<Object, Integer>() {\n+\n+            @Override\n+            public Integer apply(Object o) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new BiFunction<Object, String, Integer>() {\n+\n+            @Override\n+            public Integer apply(Object a, String b) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Consumer<>() {\n+\n+            @Override\n+            public void accept(Object o) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new BiConsumer<>() {\n+\n+            @Override\n+            public void accept(Object a, Object b) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Predicate<>() {\n+\n+            @Override\n+            public boolean test(Object o) {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Supplier<>() {\n+\n+            @Override\n+            public Object get() {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+\n+        assertWrappedIdentity(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                throw new AssertionError();\n+            }\n+\n+        });\n+    }\n+\n+    @Test\n+    public void testIdentityWrapper() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var a = new Object() {};\n+        var b = new Object() {};\n+\n+        var amap = om.map(a);\n+        var amap2 = om.map(a);\n+\n+        assertEquals(amap, amap2);\n+        assertEquals(ObjectMapper.wrapIdentity(a), amap);\n+\n+        var bmap = om.map(b);\n+\n+        assertNotEquals(amap, bmap);\n+        assertEquals(ObjectMapper.wrapIdentity(b), bmap);\n+    }\n+\n+    @Test\n+    public void test_wrapIdentity() {\n+\n+        assertThrowsExactly(NullPointerException.class, () -> ObjectMapper.wrapIdentity(null));\n+\n+        var iw = ObjectMapper.wrapIdentity(new Object());\n+\n+        assertSame(iw, ObjectMapper.wrapIdentity(iw));\n+\n+        var simpleStubA = new Simple.Stub(\"Hello\", 77);\n+        var simpleStubB = new Simple.Stub(\"Hello\", 77);\n+\n+        assertEquals(simpleStubA, simpleStubB);\n+        assertNotEquals(ObjectMapper.wrapIdentity(simpleStubA), ObjectMapper.wrapIdentity(simpleStubB));\n+        assertEquals(ObjectMapper.wrapIdentity(simpleStubA), ObjectMapper.wrapIdentity(simpleStubA));\n+    }\n+\n+    @Test\n+    public void test_empty_List() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(List.of());\n+\n+        assertEquals(List.of(), map);\n+    }\n+\n+    @Test\n+    public void test_List() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(List.of(100, \"foo\"));\n+\n+        assertEquals(List.of(100, \"foo\"), map);\n+    }\n+\n+    @Test\n+    public void test_empty_Map() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(Map.of());\n+\n+        assertEquals(Map.of(), map);\n+    }\n+\n+    @Test\n+    public void test_Map() {\n+        var om = ObjectMapper.blank().create();\n+\n+        var map = om.map(Map.of(100, \"foo\"));\n+\n+        assertEquals(Map.of(100, \"foo\"), map);\n+    }\n+\n+    @Test\n+    public void test_MapSimple() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Map.of(123, \"foo\", 321, new Simple.Stub(\"Hello\", 567)));\n+\n+        assertEquals(Map.of(123, \"foo\", 321, Map.of(\"a\", \"Hello\", \"b\", 567)), map);\n+    }\n+\n+    @Test\n+    public void test_ListSimple() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(List.of(100, new Simple.Stub(\"Hello\", 567), \"bar\", new Simple() {}));\n+\n+        assertEquals(List.of(100, Map.of(\"a\", \"Hello\", \"b\", 567), \"bar\", Map.of(\"a\", \"foo\", \"b\", 123)), map);\n+    }\n+\n+    @Test\n+    public void test_Simple() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(new Simple() {});\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), map);\n+    }\n+\n+    @Test\n+    public void test_Proxy() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Proxy.newProxyInstance(Simple.class.getClassLoader(), new Class<?>[] { Simple.class }, new InvocationHandler() {\n+\n+            @Override\n+            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                switch (method.getName()) {\n+                    case \"a\" -> {\n+                        return \"Bye\";\n+                    }\n+                    case \"b\" -> {\n+                        return 335;\n+                    }\n+                    default -> {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                }\n+            }\n+\n+        }));\n+\n+        assertEquals(Map.of(\"a\", \"Bye\", \"b\", 335), map);\n+    }\n+\n+    @Test\n+    public void test_Simple_null_property() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(new Simple.Stub(null, 123));\n+\n+        assertEquals(Map.of(\"b\", 123, \"a\", ObjectMapper.NULL), map);\n+    }\n+\n+    @Test\n+    public void test_Optional_String() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Optional.of(\"foo\"));\n+\n+        assertEquals(Map.of(\"get\", \"foo\"), map);\n+    }\n+\n+    @Test\n+    public void test_Optional_empty() {\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.map(Optional.empty());\n+\n+        assertEquals(Map.of(\"get\", ObjectMapper.NULL), map);\n+    }\n+\n+    @Test\n+    public void test_toMap() {\n+        var om = ObjectMapper.standard().create();\n+\n+        assertNull(om.toMap(null));\n+        assertEquals(Map.of(\"value\", \"Hello\"), om.toMap(\"Hello\"));\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+    }\n+\n+    @Test\n+    public void test_getter_throws() {\n+        var om = ObjectMapper.blank()\n+                .mutate(ObjectMapper.configureObject())\n+                .mutate(ObjectMapper.configureLeafClasses())\n+                .mutate(ObjectMapper.configureException())\n+                .create();\n+\n+        var expected = Map.of(\"get\", om.toMap(new UnsupportedOperationException(\"Not for you!\")));\n+\n+        var actual = om.toMap(new Supplier<>() {\n+            @Override\n+            public Object get() {\n+                throw new UnsupportedOperationException(\"Not for you!\");\n+            }\n+        });\n+\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void test_exception_with_message_with_cause() {\n+\n+        var ex = new Exception(\"foo\", new IllegalArgumentException(\"Cause\", new RuntimeException(\"Ops!\")));\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\n+                \"getClass\", Exception.class.getName(),\n+                \"getMessage\", \"foo\",\n+                \"getCause\", Map.of(\n+                        \"getClass\", IllegalArgumentException.class.getName(),\n+                        \"getMessage\", \"Cause\",\n+                        \"getCause\", Map.of(\n+                                \"getClass\", RuntimeException.class.getName(),\n+                                \"getMessage\", \"Ops!\"\n+                        )\n+                )\n+        ), map);\n+    }\n+\n+    @Test\n+    public void test_exception_without_message_with_cause() {\n+\n+        var ex = new RuntimeException(null, new UnknownError(\"Ops!\"));\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\n+                \"getClass\", RuntimeException.class.getName(),\n+                \"getCause\", Map.of(\n+                        \"getMessage\", \"Ops!\",\n+                        \"getCause\", ObjectMapper.NULL\n+                )\n+        ), map);\n+    }\n+\n+    @Test\n+    public void test_exception_without_message_without_cause() {\n+\n+        var ex = new UnsupportedOperationException();\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\"getClass\", UnsupportedOperationException.class.getName()), map);\n+    }\n+\n+    @Test\n+    public void test_exception_CustomException() {\n+\n+        var ex = new CustomException(\"Hello\", Path.of(\"\"), Optional.empty(), null);\n+\n+        var om = ObjectMapper.standard().create();\n+\n+        var map = om.toMap(ex);\n+\n+        assertEquals(Map.of(\n+                \"getClass\", CustomException.class.getName(),\n+                \"getMessage\", \"Hello\",\n+                \"op\", Map.of(\"get\", ObjectMapper.NULL),\n+                \"path2\", Path.of(\"\")\n+        ), map);\n+    }\n+\n+    @Test\n+    public void test_Builder_accessPackageMethods() {\n+\n+        var obj = new TestType().foo(\"Hello\").bar(81);\n+\n+        var map = ObjectMapper.standard().create().toMap(obj);\n+\n+        assertEquals(Map.of(\"foo\", \"Hello\"), map);\n+\n+        map = ObjectMapper.standard().accessPackageMethods(TestType.class.getPackage()).create().toMap(obj);\n+\n+        assertEquals(Map.of(\"foo\", \"Hello\", \"bar\", 81), map);\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_Simple() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleStub() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.Stub.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\", \"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.Stub.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\", \"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleDefault() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.Default.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.Default.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleDefaultExt() {\n+\n+        var om = ObjectMapper.standard().exceptSomeMethods(Simple.DefaultExt.class).add(\"a\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard().exceptSomeMethods(Simple.DefaultExt.class).add(\"b\").apply().create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\", \"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_SimpleStub_and_SimpleDefault() {\n+\n+        var om = ObjectMapper.standard()\n+                .exceptSomeMethods(Simple.Stub.class).add(\"a\").apply()\n+                .exceptSomeMethods(Simple.Default.class).add(\"a\").apply()\n+                .create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\", \"b\", 123), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"b\", 345), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"b\", 123), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"b\", 345 + 10), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+\n+        om = ObjectMapper.standard()\n+                .exceptSomeMethods(Simple.Stub.class).add(\"b\").apply()\n+                .exceptSomeMethods(Simple.Default.class).add(\"b\").apply()\n+                .create();\n+\n+        assertEquals(Map.of(\"a\", \"foo\"), om.toMap(new Simple() {}));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Stub(\"Hello\", 345)));\n+        assertEquals(Map.of(\"a\", \"Hello\"), om.toMap(new Simple.Default(\"Hello\")));\n+        assertEquals(Map.of(\"a\", \"[Hello]\"), om.toMap(new Simple.DefaultExt(\"Hello\", 345)));\n+    }\n+\n+    @Test\n+    public void test_Builder_methods_all_excluded() {\n+\n+        var om = ObjectMapper.standard()\n+                .exceptSomeMethods(Simple.class).add(\"a\").apply()\n+                .exceptSomeMethods(Simple.Stub.class).add(\"b\").apply()\n+                .create();\n+\n+        var obj = new Simple.Stub(\"Hello\", 345);\n+\n+        assertEquals(ObjectMapper.wrapIdentity(obj), om.map(obj));\n+    }\n+\n+    interface Simple {\n+        default String a() {\n+            return \"foo\";\n+        }\n+\n+        default int b() {\n+            return 123;\n+        }\n+\n+        record Stub(String a, int b) implements Simple {}\n+\n+        static class Default implements Simple {\n+            Default(String a) {\n+                this.a = a;\n+            }\n+\n+            @Override\n+            public String a() {\n+                return a;\n+            }\n+\n+            private final String a;\n+        }\n+\n+        static class DefaultExt extends Default {\n+            DefaultExt(String a, int b) {\n+                super(a);\n+                this.b = b;\n+            }\n+\n+            @Override\n+            public String a() {\n+                return \"[\" + super.a() + \"]\";\n+            }\n+\n+            @Override\n+            public int b() {\n+                return 10 + b;\n+            }\n+\n+            private final int b;\n+        }\n+    }\n+\n+    final class TestType {\n+\n+        public String foo() {\n+            return foo;\n+        }\n+\n+        public TestType foo(String v) {\n+            foo = v;\n+            return this;\n+        }\n+\n+        int bar() {\n+            return bar;\n+        }\n+\n+        TestType bar(int v) {\n+            bar = v;\n+            return this;\n+        }\n+\n+        private String foo;\n+        private int bar;\n+    }\n+\n+    enum TestEnum implements Simple {\n+        FOO,\n+        BAR;\n+\n+        public int num() {\n+            return 100;\n+        }\n+\n+        public int num(int v) {\n+            return v;\n+        }\n+\n+        @Override\n+        public String a() {\n+            return \"A\";\n+        }\n+    }\n+\n+    static final class CustomException extends Exception {\n+\n+        CustomException(String message, Path path, Optional<Object> optional, Throwable cause) {\n+            super(message, cause);\n+            this.path = path;\n+            this.optional = optional;\n+        }\n+\n+        Path path() {\n+            return path;\n+        }\n+\n+        public Path path2() {\n+            return path;\n+        }\n+\n+        public Optional<Object> op() {\n+            return optional;\n+        }\n+\n+        private final Path path;\n+        private final Optional<Object> optional;\n+\n+        private static final long serialVersionUID = 1L;\n+\n+    }\n+\n+    private static void assertWrappedIdentity(ObjectMapper om, Object obj) {\n+        var map = om.toMap(obj);\n+        assertEquals(Map.of(\"value\", ObjectMapper.wrapIdentity(obj)), map);\n+    }\n+\n+    private static void assertWrappedIdentity(Object obj) {\n+        assertWrappedIdentity(ObjectMapper.standard().create(), obj);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/ObjectMapperTest.java","additions":731,"deletions":0,"binary":false,"changes":731,"status":"added"},{"patch":"@@ -344,1 +344,1 @@\n-                    JPackageCommand assertAppLayout() {\n+                    JPackageCommand runStandardAsserts() {\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/PackageTestTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+    public String name() {\n+        return name;\n+    }\n+\n@@ -100,0 +104,5 @@\n+    public AdditionalLauncher removeProperty(String name) {\n+        rawProperties.remove(Objects.requireNonNull(name));\n+        return this;\n+    }\n+\n@@ -197,1 +206,1 @@\n-    static PropertyFile getAdditionalLauncherProperties(\n+    public static PropertyFile getAdditionalLauncherProperties(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,1 +101,7 @@\n-    public static ApplicationLayout javaRuntime() {\n+    public static ApplicationLayout platformJavaRuntime() {\n+        Path runtime = Path.of(\"\");\n+        Path runtimeHome = runtime;\n+        if (TKit.isOSX()) {\n+            runtimeHome = Path.of(\"Contents\/Home\");\n+        }\n+\n@@ -105,2 +111,2 @@\n-                Path.of(\"\"),\n-                null,\n+                runtime,\n+                runtimeHome,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ApplicationLayout.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.IOException;\n@@ -37,0 +36,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n@@ -119,1 +119,1 @@\n-    public static CfgFile load(Path path) throws IOException {\n+    public static CfgFile load(Path path) {\n@@ -129,1 +129,1 @@\n-        for (String line : Files.readAllLines(path)) {\n+        for (String line : ThrowingFunction.<Path, List<String>>toFunction(Files::readAllLines).apply(path)) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CfgFile.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.UncheckedIOException;\n@@ -217,16 +216,3 @@\n-        boolean[] withServices = new boolean[1];\n-        withServices[0] = cmd.hasArgument(\"--launcher-as-service\");\n-        if (!withServices[0]) {\n-            AdditionalLauncher.forEachAdditionalLauncher(cmd, (launcherName, propertyFilePath) -> {\n-                try {\n-                    final var launcherAsService = new AdditionalLauncher.PropertyFile(propertyFilePath)\n-                            .findBooleanProperty(\"launcher-as-service\").orElse(false);\n-                    if (launcherAsService) {\n-                        withServices[0] = true;\n-                    }\n-                } catch (IOException ex) {\n-                    throw new UncheckedIOException(ex);\n-                }\n-            });\n-        }\n-        return withServices[0];\n+        return cmd.launcherNames(true).stream().anyMatch(launcherName -> {\n+            return LauncherAsServiceVerifier.launcherAsService(cmd, launcherName);\n+        });\n@@ -377,2 +363,8 @@\n-            \/\/ Use absolute path as jpackage can be executed in another directory\n-            cmd.setArgumentValue(argName, TKit.createTempDirectory(\"stash-script-resource-dir\").toAbsolutePath());\n+            \/\/ Use absolute path as jpackage can be executed in another directory.\n+            \/\/ Some tests expect a specific last argument, don't interfere with them\n+            \/\/ and insert the argument at the beginning of the command line.\n+            List<String> args = new ArrayList<>();\n+            args.add(argName);\n+            args.add(TKit.createTempDirectory(\"stash-script-resource-dir\").toAbsolutePath().toString());\n+            args.addAll(cmd.getAllArguments());\n+            cmd.clearArguments().addArguments(args);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Provides uniform way to configure {@code JPackageCommand} and\n+ * {@code PackageTest} instances.\n+ *\/\n+public record ConfigurationTarget(Optional<JPackageCommand> cmd, Optional<PackageTest> test) {\n+\n+    public ConfigurationTarget {\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(test);\n+        if (cmd.isEmpty() == test.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    public ConfigurationTarget(JPackageCommand target) {\n+        this(Optional.of(target), Optional.empty());\n+    }\n+\n+    public ConfigurationTarget(PackageTest target) {\n+        this(Optional.empty(), Optional.of(target));\n+    }\n+\n+    public ConfigurationTarget apply(Consumer<JPackageCommand> a, Consumer<PackageTest> b) {\n+        cmd.ifPresent(Objects.requireNonNull(a));\n+        test.ifPresent(Objects.requireNonNull(b));\n+        return this;\n+    }\n+\n+    public ConfigurationTarget addInitializer(Consumer<JPackageCommand> initializer) {\n+        cmd.ifPresent(Objects.requireNonNull(initializer));\n+        test.ifPresent(v -> {\n+            v.addInitializer(initializer::accept);\n+        });\n+        return this;\n+    }\n+\n+    public ConfigurationTarget addInstallVerifier(Consumer<JPackageCommand> verifier) {\n+        cmd.ifPresent(Objects.requireNonNull(verifier));\n+        test.ifPresent(v -> {\n+            v.addInstallVerifier(verifier::accept);\n+        });\n+        return this;\n+    }\n+\n+    public ConfigurationTarget addRunOnceInitializer(Consumer<ConfigurationTarget> initializer) {\n+        Objects.requireNonNull(initializer);\n+        cmd.ifPresent(_ -> {\n+            initializer.accept(this);\n+        });\n+        test.ifPresent(v -> {\n+            v.addRunOnceInitializer(() -> {\n+                initializer.accept(this);\n+            });\n+        });\n+        return this;\n+    }\n+\n+    public ConfigurationTarget add(AdditionalLauncher addLauncher) {\n+        return apply(addLauncher::applyTo, addLauncher::applyTo);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigurationTarget.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.HashMap;\n@@ -35,2 +34,1 @@\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.util.PathUtils;\n+import java.util.TreeMap;\n@@ -47,1 +45,1 @@\n-        Map<String, String> entries = new HashMap<>(Map.of(\n+        Map<String, String> entries = new TreeMap<>(Map.of(\n@@ -79,7 +77,0 @@\n-    Path getLinuxIconFileName() {\n-        if (icon == null) {\n-            return null;\n-        }\n-        return Path.of(getMime().replace('\/', '-') + PathUtils.getSuffix(icon));\n-    }\n-\n@@ -98,0 +89,4 @@\n+    boolean hasIcon() {\n+        return icon != null;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/FileAssociations.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -128,0 +128,2 @@\n+        \/\/ Use an old release number to make test app classes runnable on older runtimes.\n+        builder.setRelease(11);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import java.util.HashMap;\n+import java.util.Collections;\n@@ -49,0 +49,1 @@\n+import java.util.OptionalInt;\n@@ -70,0 +71,1 @@\n+    @SuppressWarnings(\"this-escape\")\n@@ -73,0 +75,1 @@\n+        excludeStandardAsserts(StandardAssert.MAIN_LAUNCHER_DESCRIPTION);\n@@ -88,1 +91,1 @@\n-        appLayoutAsserts = cmd.appLayoutAsserts;\n+        standardAsserts = cmd.standardAsserts;\n@@ -204,0 +207,11 @@\n+    public JPackageCommand mutate(Consumer<JPackageCommand> mutator) {\n+        return mutate(List.of(mutator));\n+    }\n+\n+    public JPackageCommand mutate(Iterable<Consumer<JPackageCommand>> mutators) {\n+        for (var mutator : mutators) {\n+            mutator.accept(this);\n+        }\n+        return this;\n+    }\n+\n@@ -315,1 +329,1 @@\n-            cmd.addArguments(\"--runtime-image\", fakeRuntimeDir);\n+            cmd.setArgumentValue(\"--runtime-image\", fakeRuntimeDir);\n@@ -365,0 +379,23 @@\n+    public static Path createInputRuntimeImage() throws IOException {\n+\n+        final Path runtimeImageDir;\n+\n+        if (JPackageCommand.DEFAULT_RUNTIME_IMAGE != null) {\n+            runtimeImageDir = JPackageCommand.DEFAULT_RUNTIME_IMAGE;\n+        } else {\n+            runtimeImageDir = TKit.createTempDirectory(\"runtime-image\").resolve(\"data\");\n+\n+            new Executor().setToolProvider(JavaTool.JLINK)\n+                    .dumpOutput()\n+                    .addArguments(\n+                            \"--output\", runtimeImageDir.toString(),\n+                            \"--add-modules\", \"java.desktop\",\n+                            \"--strip-debug\",\n+                            \"--no-header-files\",\n+                            \"--no-man-pages\")\n+                    .execute();\n+        }\n+\n+        return runtimeImageDir;\n+    }\n+\n@@ -439,1 +476,1 @@\n-            layout = ApplicationLayout.javaRuntime();\n+            layout = ApplicationLayout.platformJavaRuntime();\n@@ -540,0 +577,18 @@\n+    \/**\n+     * Returns the name of the main launcher. It will read the name of the main\n+     * launcher from the external app image if such is specified.\n+     *\n+     * @return the name of the main launcher\n+     *\n+     * @throws IllegalArgumentException if the command is configured for packaging\n+     *                                  Java runtime\n+     *\/\n+    public String mainLauncherName() {\n+        verifyNotRuntime();\n+        return name();\n+    }\n+\n+    boolean isMainLauncher(String launcherName) {\n+        return launcherName == null || mainLauncherName().equals(launcherName);\n+    }\n+\n@@ -556,1 +611,1 @@\n-            launcherName = name();\n+            launcherName = mainLauncherName();\n@@ -574,2 +629,10 @@\n-     * Returns names of all additional launchers or empty list if none\n-     * configured.\n+     * Returns names of additional launchers or an empty list if none configured.\n+     * <p>\n+     * If {@code lookupInPrederfinedAppImage} is {@code true} and the command is\n+     * configured with an external app image, it will read names of the additional\n+     * launchers from the external app image.\n+     *\n+     * @param lookupInPrederfinedAppImage if to read names of additional launchers\n+     *                                    from an external app image\n+     *\n+     * @return the names of additional launchers\n@@ -577,1 +640,5 @@\n-    public List<String> addLauncherNames() {\n+    public List<String> addLauncherNames(boolean lookupInPrederfinedAppImage) {\n+        if (isRuntime()) {\n+            return List.of();\n+        }\n+\n@@ -579,0 +646,8 @@\n+        if (lookupInPrederfinedAppImage) {\n+            Optional.ofNullable(getArgumentValue(\"--app-image\"))\n+                    .map(Path::of)\n+                    .map(AppImageFile::load)\n+                    .map(AppImageFile::addLaunchers)\n+                    .map(Map::keySet)\n+                    .ifPresent(names::addAll);\n+        }\n@@ -582,1 +657,20 @@\n-        return names;\n+        return Collections.unmodifiableList(names);\n+    }\n+\n+    \/**\n+     * Returns names of all launchers.\n+     * <p>\n+     * If the list is not empty, the first element is {@code null} referencing the\n+     * main launcher. In the case of runtime packaging, the list is empty.\n+     *\n+     * @return the names of all launchers\n+     *\/\n+    public List<String> launcherNames(boolean lookupInPrederfinedAppImage) {\n+        if (isRuntime()) {\n+            return List.of();\n+        }\n+\n+        List<String> names = new ArrayList<>();\n+        names.add(null);\n+        names.addAll(addLauncherNames(lookupInPrederfinedAppImage));\n+        return Collections.unmodifiableList(names);\n@@ -606,1 +700,1 @@\n-            launcherName = name();\n+            launcherName = mainLauncherName();\n@@ -670,1 +764,1 @@\n-        defaultToolProvider = Optional.of(jpackageToolProvider);\n+        defaultToolProvider.set(Optional.of(jpackageToolProvider));\n@@ -678,1 +772,1 @@\n-        defaultToolProvider = Optional.empty();\n+        defaultToolProvider.set(Optional.empty());\n@@ -787,1 +881,3 @@\n-        return Optional.ofNullable(withToolProvider).orElseGet(defaultToolProvider::isPresent);\n+        return Optional.ofNullable(withToolProvider).orElseGet(() -> {\n+            return defaultToolProvider.get().isPresent();\n+        });\n@@ -803,1 +899,1 @@\n-            exec.setToolProvider(defaultToolProvider.orElseGet(JavaTool.JPACKAGE::asToolProvider));\n+            exec.setToolProvider(defaultToolProvider.get().orElseGet(JavaTool.JPACKAGE::asToolProvider));\n@@ -814,0 +910,4 @@\n+    public Executor.Result executeIgnoreExitCode() {\n+        return execute(OptionalInt.empty());\n+    }\n+\n@@ -819,0 +919,4 @@\n+        return execute(OptionalInt.of(expectedExitCode));\n+    }\n+\n+    private Executor.Result execute(OptionalInt expectedExitCode) {\n@@ -855,1 +959,2 @@\n-        if (expectedExitCode == 0 && !isImagePackageType()) {\n+        if (expectedExitCode.isPresent() && expectedExitCode.orElseThrow() == 0\n+                && !isImagePackageType()) {\n@@ -863,1 +968,6 @@\n-        Executor.Result result = copy.createExecutor().execute(expectedExitCode);\n+        Executor.Result result;\n+        if (expectedExitCode.isEmpty()) {\n+            result = copy.createExecutor().executeWithoutExitCodeCheck();\n+        } else {\n+            result = copy.createExecutor().execute(expectedExitCode.orElseThrow());\n+        }\n@@ -867,1 +977,2 @@\n-        if (expectedExitCode == 0 && isImagePackageType()) {\n+        if (expectedExitCode.isPresent() && expectedExitCode.orElseThrow() == 0\n+                && isImagePackageType()) {\n@@ -875,1 +986,1 @@\n-        if (result.exitCode() == 0) {\n+        if (result.exitCode() == 0 && expectedExitCode.isPresent()) {\n@@ -896,1 +1007,1 @@\n-        assertAppLayout();\n+        runStandardAsserts();\n@@ -939,4 +1050,4 @@\n-                final var snapshopGroup = snapshots.get(a);\n-                final var newSnapshopGroup = newSnapshots.get(a);\n-                for (int i = 0; i < snapshopGroup.size(); i++) {\n-                    TKit.PathSnapshot.assertEquals(snapshopGroup.get(i), newSnapshopGroup.get(i),\n+                final var snapshotGroup = snapshots.get(a);\n+                final var newSnapshotGroup = newSnapshots.get(a);\n+                for (int i = 0; i < snapshotGroup.size(); i++) {\n+                    snapshotGroup.get(i).assertEquals(newSnapshotGroup.get(i),\n@@ -1057,1 +1168,1 @@\n-    public static enum AppLayoutAssert {\n+    public static enum StandardAssert {\n@@ -1077,0 +1188,5 @@\n+        MAIN_LAUNCHER_DESCRIPTION(cmd -> {\n+            if (!cmd.isRuntime()) {\n+                new LauncherVerifier(cmd).verify(cmd, LauncherVerifier.Action.VERIFY_DESCRIPTION);\n+            }\n+        }),\n@@ -1086,5 +1202,1 @@\n-                if (cmd.isRuntime()) {\n-                    TKit.assertPathExists(libjliPath, false);\n-                } else {\n-                    TKit.assertFileExists(libjliPath);\n-                }\n+                TKit.assertFileExists(libjliPath);\n@@ -1098,0 +1210,5 @@\n+        MAC_BUNDLE_UNSIGNED_SIGNATURE(cmd -> {\n+            if (TKit.isOSX() && !MacHelper.appImageSigned(cmd)) {\n+                MacHelper.verifyUnsignedBundleSignature(cmd);\n+            }\n+        }),\n@@ -1100,1 +1217,1 @@\n-        AppLayoutAssert(Consumer<JPackageCommand> action) {\n+        StandardAssert(Consumer<JPackageCommand> action) {\n@@ -1118,1 +1235,1 @@\n-    public JPackageCommand setAppLayoutAsserts(AppLayoutAssert ... asserts) {\n+    public JPackageCommand setStandardAsserts(StandardAssert ... asserts) {\n@@ -1120,1 +1237,1 @@\n-        appLayoutAsserts = Set.of(asserts);\n+        standardAsserts = Set.of(asserts);\n@@ -1124,1 +1241,1 @@\n-    public JPackageCommand excludeAppLayoutAsserts(AppLayoutAssert... asserts) {\n+    public JPackageCommand excludeStandardAsserts(StandardAssert... asserts) {\n@@ -1126,2 +1243,2 @@\n-        return setAppLayoutAsserts(appLayoutAsserts.stream().filter(Predicate.not(\n-                asSet::contains)).toArray(AppLayoutAssert[]::new));\n+        return setStandardAsserts(standardAsserts.stream().filter(Predicate.not(\n+                asSet::contains)).toArray(StandardAssert[]::new));\n@@ -1130,3 +1247,3 @@\n-    JPackageCommand assertAppLayout() {\n-        for (var appLayoutAssert : appLayoutAsserts.stream().sorted().toList()) {\n-            appLayoutAssert.action.accept(this);\n+    JPackageCommand runStandardAsserts() {\n+        for (var standardAssert : standardAsserts.stream().sorted().toList()) {\n+            standardAssert.action.accept(this);\n@@ -1183,4 +1300,9 @@\n-            TKit.assertStringListEquals(\n-                    addLauncherNames().stream().sorted().toList(),\n-                    aif.addLaunchers().keySet().stream().sorted().toList(),\n-                    \"Check additional launcher names\");\n+            \/\/ Don't compare the add launchers configured on the command line with the\n+            \/\/ add launchers listed in the `.jpackage.xml` file if the latter comes from\n+            \/\/ a predefined app image.\n+            if (!hasArgument(\"--app-image\")) {\n+                TKit.assertStringListEquals(\n+                        addLauncherNames(false).stream().sorted().toList(),\n+                        aif.addLaunchers().keySet().stream().sorted().toList(),\n+                        \"Check additional launcher names\");\n+            }\n@@ -1219,4 +1341,1 @@\n-            if (expectedPath.isAbsolute()) {\n-                throw new IllegalArgumentException();\n-            }\n-            if (!expectedPath.getFileName().equals(filename.getFileName())) {\n+            if (expectedPath.isAbsolute() || !expectedPath.getFileName().equals(filename.getFileName())) {\n@@ -1308,1 +1427,1 @@\n-        if (!hasArgument(\"--verbose\") && TKit.VERBOSE_JPACKAGE && !ignoreDefaultVerbose) {\n+        if (!hasArgument(\"--verbose\") && TKit.verboseJPackage() && !ignoreDefaultVerbose) {\n@@ -1332,5 +1451,1 @@\n-                if (TKit.isLinux() && typesSet.equals(PackageType.LINUX)) {\n-                    return;\n-                }\n-\n-                if (TKit.isWindows() && typesSet.equals(PackageType.WINDOWS)) {\n+                if ((TKit.isLinux() && typesSet.equals(PackageType.LINUX)) || (TKit.isWindows() && typesSet.equals(PackageType.WINDOWS))) {\n@@ -1484,1 +1599,1 @@\n-    private Set<AppLayoutAssert> appLayoutAsserts = Set.of(AppLayoutAssert.values());\n+    private Set<StandardAssert> standardAsserts = Set.of(StandardAssert.values());\n@@ -1486,20 +1601,4 @@\n-    private static Optional<ToolProvider> defaultToolProvider = Optional.empty();\n-\n-    private static final Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n-            () -> {\n-                Map<String, PackageType> reply = new HashMap<>();\n-                for (PackageType type : PackageType.values()) {\n-                    reply.put(type.getType(), type);\n-                }\n-                return reply;\n-            }).get();\n-\n-    public static final Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n-        \/\/ Set the property to the path of run-time image to speed up\n-        \/\/ building app images and platform bundles by avoiding running jlink\n-        \/\/ The value of the property will be automativcally appended to\n-        \/\/ jpackage command line if the command line doesn't have\n-        \/\/ `--runtime-image` parameter set.\n-        String val = TKit.getConfigProperty(\"runtime-image\");\n-        if (val != null) {\n-            return Path.of(val);\n+    private static InheritableThreadLocal<Optional<ToolProvider>> defaultToolProvider = new InheritableThreadLocal<>() {\n+        @Override\n+        protected Optional<ToolProvider> initialValue() {\n+            return Optional.empty();\n@@ -1507,2 +1606,10 @@\n-        return null;\n-    }).get();\n+    };\n+\n+    private static final Map<String, PackageType> PACKAGE_TYPES = Stream.of(PackageType.values()).collect(toMap(PackageType::getType, x -> x));\n+\n+    \/\/ Set the property to the path of run-time image to speed up\n+    \/\/ building app images and platform bundles by avoiding running jlink.\n+    \/\/ The value of the property will be automatically appended to\n+    \/\/ jpackage command line if the command line doesn't have\n+    \/\/ `--runtime-image` parameter set.\n+    public static final Path DEFAULT_RUNTIME_IMAGE = Optional.ofNullable(TKit.getConfigProperty(\"runtime-image\")).map(Path::of).orElse(null);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":182,"deletions":75,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -51,0 +52,5 @@\n+    public JarBuilder setRelease(int v) {\n+        release = v;\n+        return this;\n+    }\n+\n@@ -64,1 +70,1 @@\n-                new Executor()\n+                var exec = new Executor()\n@@ -66,3 +72,7 @@\n-                        .addArguments(\"-d\", workDir.toString())\n-                        .addPathArguments(sourceFiles)\n-                        .execute();\n+                        .addArguments(\"-d\", workDir.toString());\n+\n+                Optional.ofNullable(release).ifPresent(r -> {\n+                    exec.addArguments(\"--release\", r.toString());\n+                });\n+\n+                exec.addPathArguments(sourceFiles).execute();\n@@ -95,0 +105,1 @@\n+    private Integer release;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JarBuilder.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingBiConsumer.toBiConsumer;\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-import static jdk.jpackage.test.AdditionalLauncher.forEachAdditionalLauncher;\n@@ -33,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -39,0 +37,1 @@\n+import java.util.Map;\n@@ -47,0 +46,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n@@ -48,1 +48,0 @@\n-import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n@@ -70,0 +69,13 @@\n+        public Builder setAppOutputFileNamePrefix(String v) {\n+            appOutputFileNamePrefix = v;\n+            return this;\n+        }\n+\n+        public Builder appendAppOutputFileNamePrefix(String v) {\n+            return setAppOutputFileNamePrefix(appOutputFileNamePrefix() + Objects.requireNonNull(v));\n+        }\n+\n+        public Builder setAppOutputFileNamePrefixToAppName() {\n+            return setAppOutputFileNamePrefix(TKit.getCurrentDefaultAppName());\n+        }\n+\n@@ -75,0 +87,5 @@\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n@@ -77,1 +94,4 @@\n-            return new LauncherAsServiceVerifier(launcherName, appOutputFileName,\n+            return new LauncherAsServiceVerifier(\n+                    launcherName,\n+                    appOutputFileNamePrefix()\n+                            + Optional.ofNullable(appOutputFileName).orElse(\"launcher-as-service.txt\"),\n@@ -79,1 +99,5 @@\n-                    launcherName != null ? additionalLauncherCallback : null);\n+                    Optional.ofNullable(additionalLauncherCallback));\n+        }\n+\n+        public Builder applyTo(PackageTest test) {\n+            return applyTo(new ConfigurationTarget(test));\n@@ -82,2 +106,2 @@\n-        public Builder applyTo(PackageTest pkg) {\n-            create().applyTo(pkg);\n+        public Builder applyTo(ConfigurationTarget target) {\n+            create().applyTo(target);\n@@ -87,0 +111,4 @@\n+        private String appOutputFileNamePrefix() {\n+            return Optional.ofNullable(appOutputFileNamePrefix).orElse(\"\");\n+        }\n+\n@@ -89,1 +117,2 @@\n-        private String appOutputFileName = \"launcher-as-service.txt\";\n+        private String appOutputFileName;\n+        private String appOutputFileNamePrefix;\n@@ -100,2 +129,7 @@\n-            Consumer<AdditionalLauncher> additionalLauncherCallback) {\n-        this.expectedValue = expectedArgValue;\n+            Optional<Consumer<AdditionalLauncher>> additionalLauncherCallback) {\n+\n+        if (launcherName == null && additionalLauncherCallback.isPresent()) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        this.expectedValue = Objects.requireNonNull(expectedArgValue);\n@@ -107,1 +141,1 @@\n-    public void applyTo(PackageTest pkg) {\n+    public void applyTo(ConfigurationTarget target) {\n@@ -109,5 +143,3 @@\n-            pkg.forTypes(WINDOWS, () -> {\n-                pkg.addInitializer(cmd -> {\n-                    \/\/ Remove parameter added to jpackage command line in HelloApp.addTo()\n-                    cmd.removeArgument(\"--win-console\");\n-                });\n+            target.addInitializer(cmd -> {\n+                \/\/ Remove parameter added to jpackage command line in HelloApp.addTo()\n+                cmd.removeArgument(\"--win-console\");\n@@ -115,1 +147,1 @@\n-            applyToMainLauncher(pkg);\n+            applyToMainLauncher(target);\n@@ -117,1 +149,1 @@\n-            applyToAdditionalLauncher(pkg);\n+            applyToAdditionalLauncher(target);\n@@ -119,1 +151,3 @@\n-        pkg.addInstallVerifier(this::verifyLauncherExecuted);\n+        target.test().ifPresent(pkg -> {\n+            pkg.addInstallVerifier(this::verifyLauncherExecuted);\n+        });\n@@ -125,1 +159,1 @@\n-        var launcherNames = getLaunchersAsServices(cmd);\n+        var partitionedLauncherNames = partitionLaunchers(cmd);\n@@ -127,3 +161,7 @@\n-        launcherNames.forEach(toConsumer(launcherName -> {\n-            verify(cmd, launcherName);\n-        }));\n+        var launcherAsServiceNames = partitionedLauncherNames.get(true);\n+\n+        for (var launcherAsService : List.of(true, false)) {\n+            partitionedLauncherNames.get(launcherAsService).forEach(launcherName -> {\n+                verify(cmd, launcherName, launcherAsService);\n+            });\n+        }\n@@ -134,1 +172,1 @@\n-            if (launcherNames.isEmpty()) {\n+            if (launcherAsServiceNames.isEmpty()) {\n@@ -149,1 +187,1 @@\n-                        cmd, null).getParent());\n+                        cmd, \"foo\").getParent());\n@@ -154,1 +192,1 @@\n-                        cmd, null).getParent());\n+                        cmd, \"foo\").getParent());\n@@ -158,1 +196,1 @@\n-        if (launcherNames.isEmpty() || cmd.isRuntime()) {\n+        if (launcherAsServiceNames.isEmpty() || cmd.isRuntime()) {\n@@ -190,1 +228,2 @@\n-        List<String> launcherNames = new ArrayList<>();\n+        return Objects.requireNonNull(partitionLaunchers(cmd).get(true));\n+    }\n@@ -192,2 +231,7 @@\n-        if (cmd.hasArgument(\"--launcher-as-service\")) {\n-            launcherNames.add(null);\n+    private static Map<Boolean, List<String>> partitionLaunchers(JPackageCommand cmd) {\n+        if (cmd.isRuntime()) {\n+            return Map.of(true, List.of(), false, List.of());\n+        } else {\n+            return cmd.launcherNames(true).stream().collect(Collectors.partitioningBy(launcherName -> {\n+                return launcherAsService(cmd, launcherName);\n+            }));\n@@ -195,0 +239,1 @@\n+    }\n@@ -196,7 +241,22 @@\n-        forEachAdditionalLauncher(cmd, toBiConsumer((launcherName, propFilePath) -> {\n-            if (new PropertyFile(propFilePath).findBooleanProperty(\"launcher-as-service\").orElse(false)) {\n-                launcherNames.add(launcherName);\n-            }\n-        }));\n-\n-        return launcherNames;\n+    static boolean launcherAsService(JPackageCommand cmd, String launcherName) {\n+        if (cmd.isMainLauncher(launcherName)) {\n+            return PropertyFinder.findLauncherProperty(cmd, null,\n+                    PropertyFinder.cmdlineBooleanOption(\"--launcher-as-service\"),\n+                    PropertyFinder.nop(),\n+                    PropertyFinder.nop()\n+            ).map(Boolean::parseBoolean).orElse(false);\n+        } else {\n+            var mainLauncherValue = PropertyFinder.findLauncherProperty(cmd, null,\n+                    PropertyFinder.cmdlineBooleanOption(\"--launcher-as-service\"),\n+                    PropertyFinder.nop(),\n+                    PropertyFinder.nop()\n+            ).map(Boolean::parseBoolean).orElse(false);\n+\n+            var value = PropertyFinder.findLauncherProperty(cmd, launcherName,\n+                    PropertyFinder.nop(),\n+                    PropertyFinder.launcherPropertyFile(\"launcher-as-service\"),\n+                    PropertyFinder.appImageFileLauncher(cmd, launcherName, \"service\").defaultValue(Boolean.FALSE.toString())\n+            ).map(Boolean::parseBoolean);\n+\n+            return value.orElse(mainLauncherValue);\n+        }\n@@ -205,1 +265,3 @@\n-    private boolean canVerifyInstall(JPackageCommand cmd) throws IOException {\n+    private boolean canVerifyInstall(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(SUPPORTED_PACKAGES);\n+\n@@ -224,2 +286,2 @@\n-    private void applyToMainLauncher(PackageTest pkg) {\n-        pkg.addInitializer(cmd -> {\n+    private void applyToMainLauncher(ConfigurationTarget target) {\n+        target.addInitializer(cmd -> {\n@@ -235,1 +297,1 @@\n-    private void applyToAdditionalLauncher(PackageTest pkg) {\n+    private void applyToAdditionalLauncher(ConfigurationTarget target) {\n@@ -243,1 +305,1 @@\n-        Optional.ofNullable(additionalLauncherCallback).ifPresent(v -> v.accept(al));\n+        additionalLauncherCallback.ifPresent(v -> v.accept(al));\n@@ -245,1 +307,1 @@\n-        al.applyTo(pkg);\n+        target.add(al);\n@@ -248,1 +310,1 @@\n-    private void verifyLauncherExecuted(JPackageCommand cmd) throws IOException {\n+    public void verifyLauncherExecuted(JPackageCommand cmd) {\n@@ -252,1 +314,1 @@\n-            HelloApp.assertApp(cmd.appLauncherPath())\n+            HelloApp.assertApp(cmd.appLauncherPath(launcherName))\n@@ -260,1 +322,1 @@\n-    private static void deleteOutputFile(Path file) throws IOException {\n+    private static void deleteOutputFile(Path file) {\n@@ -267,2 +329,1 @@\n-                Executor.of(\"sudo\", \"rm\", \"-f\").addArgument(file.toString()).\n-                        execute();\n+                Executor.of(\"sudo\", \"rm\", \"-f\").addArgument(file.toString()).execute();\n@@ -270,1 +331,1 @@\n-                throw ex;\n+                throw new UncheckedIOException(ex);\n@@ -272,0 +333,2 @@\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -275,1 +338,1 @@\n-    private static void verify(JPackageCommand cmd, String launcherName) throws IOException {\n+    private static void verify(JPackageCommand cmd, String launcherName, boolean launcherAsService) {\n@@ -277,1 +340,6 @@\n-            verifyLinuxUnitFile(cmd, launcherName);\n+            if (launcherAsService) {\n+                verifyLinuxUnitFile(cmd, launcherName);\n+            } else {\n+                var serviceUnitFile = LinuxHelper.getServiceUnitFilePath(cmd, launcherName);\n+                TKit.assertPathExists(serviceUnitFile, false);\n+            }\n@@ -279,1 +347,6 @@\n-            verifyMacDaemonPlistFile(cmd, launcherName);\n+            if (launcherAsService) {\n+                verifyMacDaemonPlistFile(cmd, launcherName);\n+            } else {\n+                var servicePlistFile = MacHelper.getServicePlistFilePath(cmd, launcherName);\n+                TKit.assertPathExists(servicePlistFile, false);\n+            }\n@@ -283,2 +356,1 @@\n-    private static void verifyLinuxUnitFile(JPackageCommand cmd,\n-            String launcherName) throws IOException {\n+    private static void verifyLinuxUnitFile(JPackageCommand cmd, String launcherName) {\n@@ -299,1 +371,1 @@\n-                .apply(Files.readAllLines(serviceUnitFile));\n+                .apply(ThrowingFunction.<Path, List<String>>toFunction(Files::readAllLines).apply(serviceUnitFile));\n@@ -302,2 +374,1 @@\n-    private static void verifyMacDaemonPlistFile(JPackageCommand cmd,\n-            String launcherName) throws IOException {\n+    private static void verifyMacDaemonPlistFile(JPackageCommand cmd, String launcherName) {\n@@ -351,1 +422,1 @@\n-    private final Consumer<AdditionalLauncher> additionalLauncherCallback;\n+    private final Optional<Consumer<AdditionalLauncher>> additionalLauncherCallback;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":130,"deletions":59,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.file.Files;\n@@ -29,0 +28,1 @@\n+import java.util.Optional;\n@@ -41,0 +41,1 @@\n+        expectedDefault = false;\n@@ -45,0 +46,1 @@\n+        expectedIcon = null;\n@@ -49,0 +51,4 @@\n+    public LauncherIconVerifier setExpectedNoIcon() {\n+        return setExpectedIcon(null);\n+    }\n+\n@@ -54,0 +60,8 @@\n+    public boolean expectDefaultIcon() {\n+        return expectedDefault;\n+    }\n+\n+    public Optional<Path> expectIcon() {\n+        return Optional.ofNullable(expectedIcon);\n+    }\n+\n@@ -55,9 +69,3 @@\n-        final String curLauncherName;\n-        final String label;\n-        if (launcherName == null) {\n-            curLauncherName = cmd.name();\n-            label = \"main\";\n-        } else {\n-            curLauncherName = launcherName;\n-            label = String.format(\"[%s]\", launcherName);\n-        }\n+        final String label = Optional.ofNullable(launcherName).map(v -> {\n+            return String.format(\"[%s]\", v);\n+        }).orElse(\"main\");\n@@ -65,2 +73,1 @@\n-        Path iconPath = cmd.appLayout().desktopIntegrationDirectory().resolve(\n-                curLauncherName + TKit.ICON_SUFFIX);\n+        Path iconPath = cmd.appLayout().desktopIntegrationDirectory().resolve(iconFileName(cmd));\n@@ -74,1 +81,1 @@\n-            TKit.assertPathExists(iconPath, true);\n+            TKit.assertFileExists(iconPath);\n@@ -80,1 +87,1 @@\n-                TKit.assertTrue(-1 == Files.mismatch(expectedIcon, iconPath),\n+                TKit.assertSameFileContent(expectedIcon, iconPath,\n@@ -88,0 +95,8 @@\n+    private Path iconFileName(JPackageCommand cmd) {\n+        if (TKit.isLinux()) {\n+            return LinuxHelper.getLauncherIconFileName(cmd, launcherName);\n+        } else {\n+            return Path.of(Optional.ofNullable(launcherName).orElseGet(cmd::name) + TKit.ICON_SUFFIX);\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+        APP_DIR(\"app-dir\"),\n@@ -82,1 +83,1 @@\n-        private final static Map<String, StartupDirectory> VALUE_MAP =\n+        private static final Map<String, StartupDirectory> VALUE_MAP =\n@@ -95,1 +96,1 @@\n-        return propertyName.substring(propertyName.indexOf('-') + 1);\n+        return propertyName;\n@@ -105,3 +106,1 @@\n-        final var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n-\n-        if (name.equals(cmd.name())) {\n+        if (cmd.isMainLauncher(launcherName)) {\n@@ -150,1 +149,8 @@\n-            return Optional.of(StartupDirectory.DEFAULT);\n+            var value = Optional.ofNullable(cmd.getArgumentValue(optionName())).filter(optionValue -> {\n+                return !optionValue.startsWith(\"-\");\n+            });\n+            if (value.isPresent()) {\n+                return value.flatMap(StartupDirectory::parse);\n+            } else {\n+                return Optional.of(StartupDirectory.DEFAULT);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+        VERIFY_APP_IMAGE_FILE((verifier, cmd) -> {\n+            if (cmd.isImagePackageType()) {\n+                verifier.verifyInAppImageFile(cmd);\n+            }\n+        }),\n@@ -104,1 +109,1 @@\n-                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED, VERIFY_MAC_ENTITLEMENTS\n+                VERIFY_ICON, VERIFY_DESCRIPTION, VERIFY_INSTALLED, VERIFY_APP_IMAGE_FILE, VERIFY_MAC_ENTITLEMENTS\n@@ -202,1 +207,1 @@\n-                \/\/ No \"icon\" property in the property file\n+                \/\/ No \"icon\" property in the property file.\n@@ -210,0 +215,23 @@\n+        if (TKit.isLinux()) {\n+            \/\/ On Linux, a launcher may have an icon only if it has a corresponding .desktop file.\n+            \/\/ In case of \"app-image\" packaging there are no .desktop files, but jpackage will add icon files\n+            \/\/ in the app image anyways so that in two-step packaging jpackage can pick the icons for .desktop files.\n+            \/\/ jpackage should not add the default icon to the app image in case of \"app-image\" packaging.\n+            if (cmd.isImagePackageType()) {\n+                \/\/ This is \"app-image\" packaging. Let's see if, in two-step packaging,\n+                \/\/ jpackage creates a .desktop file for this launcher.\n+                if (!withLinuxDesktopFile(cmd.createMutableCopy().setPackageType(PackageType.LINUX_RPM))) {\n+                    \/\/ No .desktop file in the \"future\" package for this launcher,\n+                    \/\/ then don't expect an icon in the app image produced by the `cmd`.\n+                    verifier.setExpectedNoIcon();\n+                } else if (verifier.expectDefaultIcon()) {\n+                    \/\/ A .desktop file in the \"future\" package for this launcher,\n+                    \/\/ but it will use the default icon.\n+                    \/\/ Don't expect an icon in the app image produced by the `cmd`.\n+                    verifier.setExpectedNoIcon();\n+                }\n+            } else if (!withLinuxDesktopFile(cmd)) {\n+                verifier.setExpectedNoIcon();\n+            }\n+        }\n+\n@@ -292,0 +320,39 @@\n+    private void verifyInAppImageFile(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(PackageType.IMAGE);\n+        if (!isMainLauncher()) {\n+            Stream<LauncherShortcut> shortcuts;\n+            if (TKit.isWindows()) {\n+                shortcuts = Stream.of(LauncherShortcut.WIN_DESKTOP_SHORTCUT, LauncherShortcut.WIN_START_MENU_SHORTCUT);\n+            } else if (TKit.isLinux()) {\n+                shortcuts = Stream.of(LauncherShortcut.LINUX_SHORTCUT);\n+            } else {\n+                shortcuts = Stream.of();\n+            }\n+\n+            var aif = AppImageFile.load(cmd.outputBundle());\n+            var aifFileName = AppImageFile.getPathInAppImage(Path.of(\"\")).getFileName();\n+\n+            var aifProps = Objects.requireNonNull(aif.addLaunchers().get(name));\n+\n+            shortcuts.forEach(shortcut -> {\n+                var recordedShortcut = aifProps.get(shortcut.appImageFilePropertyName());\n+                properties.flatMap(props -> {\n+                    return props.findProperty(shortcut.propertyName());\n+                }).ifPresentOrElse(expectedShortcut -> {\n+                    TKit.assertNotNull(recordedShortcut, String.format(\n+                            \"Check shortcut [%s] of launcher [%s] is recorded in %s file\",\n+                            shortcut, name, aifFileName));\n+                    TKit.assertEquals(\n+                            StartupDirectory.parse(expectedShortcut),\n+                            StartupDirectory.parse(recordedShortcut),\n+                            String.format(\"Check the value of shortcut [%s] of launcher [%s] recorded in %s file\",\n+                                    shortcut, name, aifFileName));\n+                }, () -> {\n+                    TKit.assertNull(recordedShortcut, String.format(\n+                            \"Check shortcut [%s] of launcher [%s] is NOT recorded in %s file\",\n+                            shortcut, name, aifFileName));\n+                });\n+            });\n+        }\n+    }\n+\n@@ -298,0 +365,11 @@\n+        var customFile = Optional.ofNullable(cmd.getArgumentValue(\"--mac-entitlements\")).map(Path::of);\n+        if (customFile.isEmpty()) {\n+            \/\/ Try from the resource dir.\n+            var resourceDirFile = Optional.ofNullable(cmd.getArgumentValue(\"--resource-dir\")).map(Path::of).map(resourceDir -> {\n+                return resourceDir.resolve(cmd.name() + \".entitlements\");\n+            }).filter(Files::exists);\n+            if (resourceDirFile.isPresent()) {\n+                customFile = resourceDirFile;\n+            }\n+        }\n+\n@@ -299,2 +377,2 @@\n-        if (cmd.hasArgument(\"--mac-entitlements\")) {\n-            expected = new PListReader(Files.readAllBytes(Path.of(cmd.getArgumentValue(\"--mac-entitlements\")))).toMap(true);\n+        if (customFile.isPresent()) {\n+            expected = new PListReader(Files.readAllBytes(customFile.orElseThrow())).toMap(true);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":82,"deletions":4,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -25,0 +25,6 @@\n+import static java.util.Collections.unmodifiableSortedSet;\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n+\n@@ -35,1 +41,0 @@\n-import java.util.HashSet;\n@@ -41,0 +46,2 @@\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n@@ -45,1 +52,0 @@\n-import java.util.stream.Collectors;\n@@ -87,3 +93,1 @@\n-        String desktopFileName = String.format(\"%s-%s.desktop\", getPackageName(\n-                cmd), Optional.ofNullable(launcherName).orElseGet(\n-                        () -> cmd.name()).replaceAll(\"\\\\s+\", \"_\"));\n+        var desktopFileName = getLauncherDesktopFileName(cmd, launcherName);\n@@ -99,1 +103,1 @@\n-                        Optional.ofNullable(launcherName).orElseGet(cmd::name))));\n+                        Optional.ofNullable(launcherName).orElseGet(cmd::mainLauncherName))));\n@@ -164,2 +168,1 @@\n-                        \"Depends\").split(\",\")).map(String::strip).collect(\n-                        Collectors.toList());\n+                        \"Depends\").split(\",\")).map(String::strip).toList();\n@@ -202,0 +205,14 @@\n+    private static Path getFaIconFileName(JPackageCommand cmd, String mimeType) {\n+        return Path.of(mimeType.replace('\/', '-') + \".png\");\n+    }\n+\n+    static Path getLauncherDesktopFileName(JPackageCommand cmd, String launcherName) {\n+        return Path.of(String.format(\"%s-%s.desktop\", getPackageName(cmd),\n+                Optional.ofNullable(launcherName).orElseGet(cmd::name).replaceAll(\"\\\\s+\", \"_\")));\n+    }\n+\n+    static Path getLauncherIconFileName(JPackageCommand cmd, String launcherName) {\n+        return Path.of(String.format(\"%s.png\",\n+                Optional.ofNullable(launcherName).orElseGet(cmd::name).replaceAll(\"\\\\s+\", \"_\")));\n+    }\n+\n@@ -326,1 +343,1 @@\n-                    runtimeDir::resolve).collect(Collectors.toSet());\n+                    runtimeDir::resolve).collect(toSet());\n@@ -328,2 +345,1 @@\n-                    expectedCriticalRuntimePaths::contains).collect(\n-                            Collectors.toSet());\n+                    expectedCriticalRuntimePaths::contains).collect(toSet());\n@@ -357,1 +373,0 @@\n-        final var predefinedAppImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load);\n@@ -362,1 +377,1 @@\n-                    launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile),\n+                    launcherNameFromDesktopFile(cmd, desktopFile),\n@@ -375,2 +390,1 @@\n-                Set<String> words = Stream.of(line.split(\"\\\\s+\")).collect(\n-                        Collectors.toSet());\n+                Set<String> words = Stream.of(line.split(\"\\\\s+\")).collect(toSet());\n@@ -392,2 +406,1 @@\n-                Set<Scriptlet> requiredScriptlets = Stream.of(Scriptlet.values()).sorted().collect(\n-                        Collectors.toSet());\n+                var requiredScriptlets = Stream.of(Scriptlet.values()).sorted().toList();\n@@ -424,1 +437,8 @@\n-    static void verifyDesktopFiles(JPackageCommand cmd, boolean installed) {\n+    static void verifyDesktopIntegrationFiles(JPackageCommand cmd, boolean installed) {\n+        verifyDesktopFiles(cmd, installed);\n+        if (installed) {\n+            verifyAllIconsReferenced(cmd);\n+        }\n+    }\n+\n+    private static void verifyDesktopFiles(JPackageCommand cmd, boolean installed) {\n@@ -455,0 +475,1 @@\n+\n@@ -456,0 +477,16 @@\n+\n+        return relativePackageFilesInSubdirectory(cmd, ApplicationLayout::desktopIntegrationDirectory)\n+                .filter(path -> {\n+                    return path.getNameCount() == 1;\n+                })\n+                .filter(path -> {\n+                    return \".desktop\".equals(PathUtils.getSuffix(path));\n+                })\n+                .map(unpackedDir::resolve)\n+                .toList();\n+    }\n+\n+    private static Stream<Path> relativePackageFilesInSubdirectory(\n+            JPackageCommand cmd, Function<ApplicationLayout, Path> subdirFunc) {\n+\n+        var unpackedDir = subdirFunc.apply(cmd.appLayout());\n@@ -457,0 +494,1 @@\n+\n@@ -458,2 +496,35 @@\n-            return packageDir.equals(path.getParent()) && path.getFileName().toString().endsWith(\".desktop\");\n-        }).map(Path::getFileName).map(unpackedDir::resolve).toList();\n+            return path.startsWith(packageDir);\n+        }).map(packageDir::relativize);\n+    }\n+\n+    private static void verifyAllIconsReferenced(JPackageCommand cmd) {\n+\n+        var installCmd = Optional.ofNullable(cmd.unpackedPackageDirectory()).map(_ -> {\n+            return cmd.createMutableCopy().setUnpackedPackageLocation(null);\n+        }).orElse(cmd);\n+\n+        var installedIconFiles = relativePackageFilesInSubdirectory(\n+                installCmd,\n+                ApplicationLayout::desktopIntegrationDirectory\n+        ).filter(path -> {\n+            return \".png\".equals(PathUtils.getSuffix(path));\n+        }).map(installCmd.appLayout().desktopIntegrationDirectory()::resolve).collect(toSet());\n+\n+        var referencedIcons = getDesktopFiles(cmd).stream().map(path -> {\n+            return new DesktopFile(path, false);\n+        }).<Path>mapMulti((desktopFile, sink) -> {\n+            desktopFile.findQuotedValue(\"Icon\").map(Path::of).ifPresent(sink);\n+            desktopFile.find(\"MimeType\").ifPresent(str -> {\n+                Stream.of(str.split(\";\"))\n+                        .map(mimeType -> {\n+                            return getFaIconFileName(cmd, mimeType);\n+                        })\n+                        .map(installCmd.appLayout().desktopIntegrationDirectory()::resolve)\n+                        .forEach(sink);\n+            });\n+        }).collect(toSet());\n+\n+        var unreferencedIconFiles = Comm.compare(installedIconFiles, referencedIcons).unique1().stream().sorted().toList();\n+\n+        \/\/ Verify that all package icon (.png) files are referenced from package .desktop files.\n+        TKit.assertEquals(List.of(), unreferencedIconFiles, \"Check there are no unreferenced icon files in the package\");\n@@ -462,1 +533,1 @@\n-    private static String launcherNameFromDesktopFile(JPackageCommand cmd, Optional<AppImageFile> predefinedAppImage, Path desktopFile) {\n+    private static String launcherNameFromDesktopFile(JPackageCommand cmd, Path desktopFile) {\n@@ -464,1 +535,0 @@\n-        Objects.requireNonNull(predefinedAppImage);\n@@ -467,5 +537,1 @@\n-        return predefinedAppImage.map(v -> {\n-            return v.launchers().keySet().stream();\n-        }).orElseGet(() -> {\n-            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n-        }).filter(name-> {\n+        return Stream.concat(Stream.of(cmd.mainLauncherName()), cmd.addLauncherNames(true).stream()).filter(name-> {\n@@ -487,1 +553,1 @@\n-        var launcherName = launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile);\n+        var launcherName = launcherNameFromDesktopFile(cmd, desktopFile);\n@@ -491,1 +557,1 @@\n-        final Set<String> mandatoryKeys = new HashSet<>(Set.of(\"Name\", \"Comment\",\n+        final Set<String> mandatoryKeys = new TreeSet<>(Set.of(\"Name\", \"Comment\",\n@@ -497,1 +563,14 @@\n-        for (var e : Map.of(\"Type\", \"Application\", \"Terminal\", \"false\").entrySet()) {\n+        final String launcherDescription;\n+        if (cmd.name().equals(launcherName) || predefinedAppImage.isPresent()) {\n+            launcherDescription = Optional.ofNullable(cmd.getArgumentValue(\"--description\")).orElseGet(cmd::name);\n+        } else {\n+            launcherDescription = getAdditionalLauncherProperties(cmd, launcherName).findProperty(\"description\").or(() -> {\n+                return Optional.ofNullable(cmd.getArgumentValue(\"--description\"));\n+            }).orElseGet(cmd::name);\n+        }\n+\n+        for (var e : List.of(\n+                Map.entry(\"Type\", \"Application\"),\n+                Map.entry(\"Terminal\", \"false\"),\n+                Map.entry(\"Comment\", launcherDescription)\n+        )) {\n@@ -517,0 +596,3 @@\n+                case APP_DIR -> {\n+                    return cmd.pathToPackageFile(appLayout.appDirectory());\n+                }\n@@ -628,10 +710,13 @@\n-            final Path mimeTypeIconFileName = fa.getLinuxIconFileName();\n-            if (mimeTypeIconFileName != null) {\n-                \/\/ Verify there are xdg registration commands for mime icon file.\n-                Path mimeTypeIcon = cmd.appLayout().desktopIntegrationDirectory().resolve(\n-                        mimeTypeIconFileName);\n-\n-                Map<Scriptlet, List<String>> scriptlets = getScriptlets(cmd);\n-                scriptlets.entrySet().stream().forEach(e -> verifyIconInScriptlet(\n-                        e.getKey(), e.getValue(), mimeTypeIcon));\n-            }\n+            Optional.of(fa).filter(FileAssociations::hasIcon)\n+                    .map(FileAssociations::getMime)\n+                    .map(mimeType -> {\n+                        return getFaIconFileName(cmd, mimeType);\n+                    }).ifPresent(mimeTypeIconFileName -> {\n+                        \/\/ Verify there are xdg registration commands for mime icon file.\n+                        Path mimeTypeIcon = cmd.appLayout().desktopIntegrationDirectory().resolve(\n+                                mimeTypeIconFileName);\n+\n+                        Map<Scriptlet, List<String>> scriptlets = getScriptlets(cmd);\n+                        scriptlets.entrySet().stream().forEach(e -> verifyIconInScriptlet(\n+                                e.getKey(), e.getValue(), mimeTypeIcon));\n+                    });\n@@ -710,1 +795,1 @@\n-        Map<Scriptlet, List<String>> result = new HashMap<>();\n+        Map<Scriptlet, List<String>> result = new TreeMap<>();\n@@ -732,1 +817,1 @@\n-        Map<Scriptlet, List<String>> result = new HashMap<>();\n+        Map<Scriptlet, List<String>> result = new TreeMap<>();\n@@ -766,1 +851,1 @@\n-                        v -> v.rpm).collect(Collectors.joining(\"|\"))));\n+                        v -> v.rpm).collect(joining(\"|\"))));\n@@ -769,1 +854,1 @@\n-                Collectors.toMap(v -> v.rpm, v -> v));\n+                toMap(v -> v.rpm, v -> v));\n@@ -798,2 +883,3 @@\n-    private static String getServiceUnitFileName(String packageName,\n-            String launcherName) {\n+    private static String getServiceUnitFileName(String packageName, String launcherName) {\n+        Objects.requireNonNull(packageName);\n+        Objects.requireNonNull(launcherName);\n@@ -846,1 +932,1 @@\n-                }).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+                }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n@@ -887,1 +973,2 @@\n-    private static final Set<Integer> XDG_CMD_VALID_ICON_SIZES = Set.of(16, 22, 32, 48, 64, 128);\n+    private static final Set<Integer> XDG_CMD_VALID_ICON_SIZES = unmodifiableSortedSet(\n+            new TreeSet<>(List.of(16, 22, 32, 48, 64, 128)));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":135,"deletions":48,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -26,0 +26,10 @@\n+import static jdk.jpackage.internal.util.PListWriter.writeArray;\n+import static jdk.jpackage.internal.util.PListWriter.writeBoolean;\n+import static jdk.jpackage.internal.util.PListWriter.writeBooleanOptional;\n+import static jdk.jpackage.internal.util.PListWriter.writeDict;\n+import static jdk.jpackage.internal.util.PListWriter.writeKey;\n+import static jdk.jpackage.internal.util.PListWriter.writeString;\n+import static jdk.jpackage.internal.util.PListWriter.writeStringArray;\n+import static jdk.jpackage.internal.util.PListWriter.writeStringOptional;\n+import static jdk.jpackage.internal.util.XmlUtils.toXmlConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n@@ -29,0 +39,2 @@\n+import java.io.UncheckedIOException;\n+import java.lang.constant.ClassDesc;\n@@ -34,0 +46,2 @@\n+import java.util.Collections;\n+import java.util.HashMap;\n@@ -35,0 +49,1 @@\n+import java.util.Map;\n@@ -38,0 +53,1 @@\n+import java.util.Properties;\n@@ -39,0 +55,5 @@\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n@@ -42,0 +63,1 @@\n+import javax.xml.stream.XMLStreamWriter;\n@@ -50,0 +72,1 @@\n+import jdk.jpackage.test.MacSign.CertificateRequest;\n@@ -146,0 +169,4 @@\n+    public static PListReader readPListFromEmbeddedRuntime(Path appImage) {\n+        return readPList(appImage.resolve(\"Contents\/runtime\/Contents\/Info.plist\"));\n+    }\n+\n@@ -163,0 +190,56 @@\n+    public static Map<String, String> flatMapPList(PListReader plistReader) {\n+        return Collections.unmodifiableMap(expandPListDist(new HashMap<>(), \"\", plistReader.toMap(true)));\n+    }\n+\n+    private static Map<String, String> expandPListDist(Map<String, String> accumulator, String root, Map<String, Object> plistDict) {\n+        Objects.requireNonNull(accumulator);\n+        Objects.requireNonNull(plistDict);\n+        Objects.requireNonNull(root);\n+        for (var e : plistDict.entrySet()) {\n+            collectPListProperty(accumulator, root + \"\/\" + e.getKey(), e.getValue());\n+        }\n+        return accumulator;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static void collectPListProperty(Map<String, String> accumulator, String key, Object value) {\n+        Objects.requireNonNull(accumulator);\n+        Objects.requireNonNull(key);\n+        Objects.requireNonNull(value);\n+        switch (value) {\n+            case PListReader.Raw raw -> {\n+                accumulator.put(key, raw.value());\n+            }\n+            case List<?> array -> {\n+                if (array.isEmpty()) {\n+                    accumulator.put(key + \"[]\", \"\");\n+                } else {\n+                    for (int i = 0; i != array.size(); i++) {\n+                        collectPListProperty(accumulator, String.format(\"%s[%d]\", key, i), array.get(i));\n+                    }\n+                }\n+            }\n+            case Map<?, ?> map -> {\n+                if (map.isEmpty()) {\n+                    accumulator.put(key + \"{}\", \"\");\n+                } else {\n+                    expandPListDist(accumulator, key, (Map<String, Object>)map);\n+                }\n+            }\n+            default -> {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Unexpected value type [%s] of property [%s]\", value.getClass(), key));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the given jpackage command line is configured to sign\n+     * predefined app image in place.\n+     * <p>\n+     * jpackage will not create a new app image or a native bundle.\n+     *\n+     * @param cmd the jpackage command to examine\n+     * @return {@code true} if the given jpackage command line is configured to sign\n+     *         predefined app image in place and {@code false} otherwise.\n+     *\/\n@@ -168,1 +251,1 @@\n-        return cmd.hasArgument(\"--mac-sign\") && cmd.hasArgument(\"--app-image\");\n+        return cmd.hasArgument(\"--mac-sign\") && cmd.hasArgument(\"--app-image\") && cmd.isImagePackageType();\n@@ -171,0 +254,12 @@\n+    \/**\n+     * Returns {@code true} if the given jpackage command line is configured such\n+     * that the app image it will produce will be signed.\n+     * <p>\n+     * If the jpackage command line is bundling a native package, the function\n+     * returns {@code true} if the bundled app image will be signed.\n+     *\n+     * @param cmd the jpackage command to examine\n+     * @return {@code true} if the given jpackage command line is configured such\n+     *         that the app image it will produce will be signed and {@code false}\n+     *         otherwise.\n+     *\/\n@@ -177,1 +272,7 @@\n-        if (Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n+        var runtimeImage = Optional.ofNullable(cmd.getArgumentValue(\"--runtime-image\")).map(Path::of);\n+        var appImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n+\n+        if (cmd.isRuntime() && Files.isDirectory(runtimeImage.orElseThrow().resolve(\"Contents\/_CodeSignature\"))) {\n+            \/\/ If the predefined runtime is a signed bundle, bundled image should be signed too.\n+            return true;\n+        } else if (appImage.map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n@@ -182,0 +283,8 @@\n+        if (!cmd.isImagePackageType() && appImage.isPresent()) {\n+            \/\/ Building a \".pkg\" or a \".dmg\" bundle from the predefined app image.\n+            \/\/ The predefined app image is unsigned, so the app image bundled\n+            \/\/ in the output native package will be unsigned too\n+            \/\/ (even if the \".pkg\" file may be signed itself, and we never sign \".dmg\" files).\n+            return false;\n+        }\n+\n@@ -189,0 +298,181 @@\n+    public static void writeFaPListFragment(JPackageCommand cmd, XMLStreamWriter xml) {\n+        toRunnable(() -> {\n+            var allProps = Stream.of(cmd.getAllArgumentValues(\"--file-associations\")).map(Path::of).map(propFile -> {\n+                try (var propFileReader = Files.newBufferedReader(propFile)) {\n+                    var props = new Properties();\n+                    props.load(propFileReader);\n+                    return props;\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            }).toList();\n+\n+            if (!allProps.isEmpty()) {\n+                var bundleId = getPackageId(cmd);\n+\n+                Function<Properties, String> contentType = fa -> {\n+                    return String.format(\"%s.%s\", bundleId, Objects.requireNonNull(fa.getProperty(\"extension\")));\n+                };\n+\n+                Function<Properties, Optional<String>> icon = fa -> {\n+                    return Optional.ofNullable(fa.getProperty(\"icon\")).map(Path::of).map(Path::getFileName).map(Path::toString);\n+                };\n+\n+                BiFunction<Properties, String, Optional<Boolean>> asBoolean = (fa, key) -> {\n+                    return Optional.ofNullable(fa.getProperty(key)).map(Boolean::parseBoolean);\n+                };\n+\n+                BiFunction<Properties, String, List<String>> asList = (fa, key) -> {\n+                    return Optional.ofNullable(fa.getProperty(key)).map(str -> {\n+                        return List.of(str.split(\"[ ,]+\"));\n+                    }).orElseGet(List::of);\n+                };\n+\n+                writeKey(xml, \"CFBundleDocumentTypes\");\n+                writeArray(xml, toXmlConsumer(() -> {\n+                    for (var fa : allProps) {\n+                        writeDict(xml, toXmlConsumer(() -> {\n+                            writeStringArray(xml, \"LSItemContentTypes\", List.of(contentType.apply(fa)));\n+                            writeStringOptional(xml, \"CFBundleTypeName\", Optional.ofNullable(fa.getProperty(\"description\")));\n+                            writeString(xml, \"LSHandlerRank\", Optional.ofNullable(fa.getProperty(\"mac.LSHandlerRank\")).orElse(\"Owner\"));\n+                            writeString(xml, \"CFBundleTypeRole\", Optional.ofNullable(fa.getProperty(\"mac.CFBundleTypeRole\")).orElse(\"Editor\"));\n+                            writeStringOptional(xml, \"NSPersistentStoreTypeKey\", Optional.ofNullable(fa.getProperty(\"mac.NSPersistentStoreTypeKey\")));\n+                            writeStringOptional(xml, \"NSDocumentClass\", Optional.ofNullable(fa.getProperty(\"mac.NSDocumentClass\")));\n+                            writeBoolean(xml, \"LSIsAppleDefaultForType\", true);\n+                            writeBooleanOptional(xml, \"LSTypeIsPackage\", asBoolean.apply(fa, \"mac.LSTypeIsPackage\"));\n+                            writeBooleanOptional(xml, \"LSSupportsOpeningDocumentsInPlace\", asBoolean.apply(fa, \"mac.LSSupportsOpeningDocumentsInPlace\"));\n+                            writeBooleanOptional(xml, \"UISupportsDocumentBrowser\", asBoolean.apply(fa, \"mac.UISupportsDocumentBrowser\"));\n+                            writeStringOptional(xml, \"CFBundleTypeIconFile\", icon.apply(fa));\n+                        }));\n+                    }\n+                }));\n+\n+                writeKey(xml, \"UTExportedTypeDeclarations\");\n+                writeArray(xml, toXmlConsumer(() -> {\n+                    for (var fa : allProps) {\n+                        writeDict(xml, toXmlConsumer(() -> {\n+                            writeString(xml, \"UTTypeIdentifier\", contentType.apply(fa));\n+                            writeStringOptional(xml, \"UTTypeDescription\", Optional.ofNullable(fa.getProperty(\"description\")));\n+                            if (fa.containsKey(\"mac.UTTypeConformsTo\")) {\n+                                writeStringArray(xml, \"UTTypeConformsTo\", asList.apply(fa, \"mac.UTTypeConformsTo\"));\n+                            } else {\n+                                writeStringArray(xml, \"UTTypeConformsTo\", List.of(\"public.data\"));\n+                            }\n+                            writeStringOptional(xml, \"UTTypeIconFile\", icon.apply(fa));\n+                            writeKey(xml, \"UTTypeTagSpecification\");\n+                            writeDict(xml, toXmlConsumer(() -> {\n+                                writeStringArray(xml, \"public.filename-extension\", List.of(fa.getProperty(\"extension\")));\n+                                writeStringArray(xml, \"public.mime-type\", List.of(fa.getProperty(\"mime-type\")));\n+                                writeStringArray(xml, \"NSExportableTypes\", asList.apply(fa, \"mac.NSExportableTypes\"));\n+                            }));\n+                        }));\n+                    }\n+                }));\n+            }\n+        }).run();\n+    }\n+\n+    public static Consumer<JPackageCommand> useKeychain(MacSign.ResolvedKeychain keychain) {\n+        return useKeychain(keychain.spec().keychain());\n+    }\n+\n+    public static Consumer<JPackageCommand> useKeychain(MacSign.Keychain keychain) {\n+        return cmd -> {\n+            useKeychain(cmd, keychain);\n+        };\n+    }\n+\n+    public static JPackageCommand useKeychain(JPackageCommand cmd, MacSign.ResolvedKeychain keychain) {\n+        return useKeychain(cmd, keychain.spec().keychain());\n+    }\n+\n+    public static JPackageCommand useKeychain(JPackageCommand cmd, MacSign.Keychain keychain) {\n+        return sign(cmd).addArguments(\"--mac-signing-keychain\", keychain.name());\n+    }\n+\n+    public static JPackageCommand sign(JPackageCommand cmd) {\n+        if (!cmd.hasArgument(\"--mac-sign\")) {\n+            cmd.addArgument(\"--mac-sign\");\n+        }\n+        return cmd;\n+    }\n+\n+    public record SignKeyOption(Type type, CertificateRequest certRequest) {\n+\n+        public SignKeyOption {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(certRequest);\n+        }\n+\n+        public enum Type {\n+            SIGN_KEY_USER_NAME,\n+            SIGN_KEY_IDENTITY,\n+            ;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuffer();\n+            applyTo((optionName, _) -> {\n+                sb.append(String.format(\"{%s: %s}\", optionName, certRequest));\n+            });\n+            return sb.toString();\n+        }\n+\n+        public JPackageCommand addTo(JPackageCommand cmd) {\n+            applyTo(cmd::addArguments);\n+            return sign(cmd);\n+        }\n+\n+        public JPackageCommand setTo(JPackageCommand cmd) {\n+            applyTo(cmd::setArgumentValue);\n+            return sign(cmd);\n+        }\n+\n+        private void applyTo(BiConsumer<String, String> sink) {\n+            switch (certRequest.type()) {\n+                case INSTALLER -> {\n+                    switch (type) {\n+                        case SIGN_KEY_IDENTITY -> {\n+                            sink.accept(\"--mac-installer-sign-identity\", certRequest.name());\n+                            return;\n+                        }\n+                        case SIGN_KEY_USER_NAME -> {\n+                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n+                            return;\n+                        }\n+                    }\n+                }\n+                case CODE_SIGN -> {\n+                    switch (type) {\n+                        case SIGN_KEY_IDENTITY -> {\n+                            sink.accept(\"--mac-app-image-sign-identity\", certRequest.name());\n+                            return;\n+                        }\n+                        case SIGN_KEY_USER_NAME -> {\n+                            sink.accept(\"--mac-signing-key-user-name\", certRequest.shortName());\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    static void verifyUnsignedBundleSignature(JPackageCommand cmd) {\n+        if (!cmd.isImagePackageType()) {\n+            MacSignVerify.assertUnsigned(cmd.outputBundle());\n+        }\n+\n+        final Path bundleRoot;\n+        if (cmd.isImagePackageType()) {\n+            bundleRoot = cmd.outputBundle();\n+        } else {\n+            bundleRoot = cmd.pathToUnpackedPackageFile(cmd.appInstallationDirectory());\n+        }\n+\n+        MacSignVerify.assertAdhocSigned(bundleRoot);\n+    }\n+\n@@ -352,1 +642,1 @@\n-        return installLocation.resolve(cmd.name() + (cmd.isRuntime() ? \"\" : \".app\"));\n+        return installLocation.resolve(cmd.name() + (cmd.isRuntime() ? \".jdk\" : \".app\"));\n@@ -376,5 +666,15 @@\n-        return cmd.getArgumentValue(\"--mac-package-identifier\", () -> {\n-            return cmd.getArgumentValue(\"--main-class\", cmd::name, className -> {\n-                return JavaAppDesc.parse(className).packageName();\n-            });\n-        });\n+        UnaryOperator<String> getPackageIdFromClassName = className -> {\n+            var packageName = ClassDesc.of(className).packageName();\n+            if (packageName.isEmpty()) {\n+                return className;\n+            } else {\n+                return packageName;\n+            }\n+        };\n+\n+        return PropertyFinder.findAppProperty(cmd,\n+                PropertyFinder.cmdlineOptionWithValue(\"--mac-package-identifier\").or(\n+                        PropertyFinder.cmdlineOptionWithValue(\"--main-class\").map(getPackageIdFromClassName)\n+                ),\n+                PropertyFinder.appImageFile(AppImageFile::mainLauncherClassName).map(getPackageIdFromClassName)\n+        ).orElseGet(cmd::name);\n@@ -418,0 +718,8 @@\n+    private static Set<Path> createBundleContents(String... customItems) {\n+        return Stream.concat(Stream.of(customItems), Stream.of(\n+                \"MacOS\",\n+                \"Info.plist\",\n+                \"_CodeSignature\"\n+        )).map(Path::of).collect(toSet());\n+    }\n+\n@@ -423,3 +731,1 @@\n-    private static final Set<Path> APP_BUNDLE_CONTENTS = Stream.of(\n-            \"Info.plist\",\n-            \"MacOS\",\n+    private static final Set<Path> APP_BUNDLE_CONTENTS = createBundleContents(\n@@ -429,3 +735,2 @@\n-            \"PkgInfo\",\n-            \"_CodeSignature\"\n-    ).map(Path::of).collect(toSet());\n+            \"PkgInfo\"\n+    );\n@@ -433,1 +738,1 @@\n-    private static final Set<Path> RUNTIME_BUNDLE_CONTENTS = Stream.of(\n+    private static final Set<Path> RUNTIME_BUNDLE_CONTENTS = createBundleContents(\n@@ -435,1 +740,1 @@\n-    ).map(Path::of).collect(toSet());\n+    );\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":321,"deletions":16,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import java.util.function.Consumer;\n@@ -354,0 +355,46 @@\n+        public static final class UsageBuilder {\n+\n+            UsageBuilder(Collection<Keychain> keychains) {\n+                this.keychains = List.copyOf(keychains);\n+            }\n+\n+            public void run(Runnable runnable) {\n+                Objects.requireNonNull(runnable);\n+\n+                final Optional<List<Path>> oldKeychains;\n+                if (addToSearchList) {\n+                    oldKeychains = Optional.ofNullable(activeKeychainFiles());\n+                    Keychain.addToSearchList(keychains);\n+                } else {\n+                    oldKeychains = Optional.empty();\n+                }\n+\n+                try {\n+                    \/\/ Ensure keychains to be used for signing are unlocked.\n+                    \/\/ When the codesign command operates on a locked keychain in a ssh session\n+                    \/\/ it emits cryptic \"errSecInternalComponent\" error without other details.\n+                    keychains.forEach(Keychain::unlock);\n+                    runnable.run();\n+                } finally {\n+                    oldKeychains.ifPresent(restoreKeychains -> {\n+                        security(\"list-keychains\", \"-d\", \"user\", \"-s\")\n+                                .addArguments(restoreKeychains.stream().map(Path::toString).toList())\n+                                .execute();\n+                    });\n+                }\n+            }\n+\n+            public UsageBuilder addToSearchList(boolean v) {\n+                addToSearchList = v;\n+                return this;\n+            }\n+\n+            public UsageBuilder addToSearchList() {\n+                return addToSearchList(true);\n+            }\n+\n+            private final Collection<Keychain> keychains;\n+            private boolean addToSearchList;\n+        }\n+\n+\n@@ -418,1 +465,1 @@\n-        public static void addToSearchList(Collection<Keychain> keychains) {\n+        static void addToSearchList(Collection<Keychain> keychains) {\n@@ -424,12 +471,0 @@\n-        public static void withAddedKeychains(Collection<Keychain> keychains, Runnable runnable) {\n-            final var curKeychains = activeKeychainFiles();\n-            addToSearchList(keychains);\n-            try {\n-                runnable.run();\n-            } finally {\n-                security(\"list-keychains\", \"-d\", \"user\", \"-s\")\n-                        .addArguments(curKeychains.stream().map(Path::toString).toList())\n-                        .execute();\n-            }\n-        }\n-\n@@ -1040,0 +1075,41 @@\n+    public static Keychain.UsageBuilder withKeychains(KeychainWithCertsSpec... keychains) {\n+        return withKeychains(Stream.of(keychains).map(KeychainWithCertsSpec::keychain).toArray(Keychain[]::new));\n+    }\n+\n+    public static Keychain.UsageBuilder withKeychains(Keychain... keychains) {\n+        return new Keychain.UsageBuilder(List.of(keychains));\n+    }\n+\n+    public static void withKeychains(Runnable runnable, Consumer<Keychain.UsageBuilder> mutator, Keychain... keychains) {\n+        Objects.requireNonNull(runnable);\n+        var builder = withKeychains(keychains);\n+        mutator.accept(builder);\n+        builder.run(runnable);\n+    }\n+\n+    public static void withKeychains(Runnable runnable, Keychain... keychains) {\n+        withKeychains(runnable, _ -> {}, keychains);\n+    }\n+\n+    public static void withKeychain(Consumer<Keychain> consumer, Consumer<Keychain.UsageBuilder> mutator, Keychain keychain) {\n+        Objects.requireNonNull(consumer);\n+        withKeychains(() -> {\n+            consumer.accept(keychain);\n+        }, mutator, keychain);\n+    }\n+\n+    public static void withKeychain(Consumer<Keychain> consumer, Keychain keychain) {\n+        withKeychain(consumer, _ -> {}, keychain);\n+    }\n+\n+    public static void withKeychain(Consumer<ResolvedKeychain> consumer, Consumer<Keychain.UsageBuilder> mutator, ResolvedKeychain keychain) {\n+        Objects.requireNonNull(consumer);\n+        withKeychains(() -> {\n+            consumer.accept(keychain);\n+        }, mutator, keychain.spec().keychain());\n+    }\n+\n+    public static void withKeychain(Consumer<ResolvedKeychain> consumer, ResolvedKeychain keychain) {\n+        withKeychain(consumer, _ -> {}, keychain);\n+    }\n+\n@@ -1049,0 +1125,4 @@\n+        public String name() {\n+            return spec.keychain().name();\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":93,"deletions":13,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -47,0 +47,35 @@\n+    public static void verifyAppImageSigned(\n+            JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n+\n+        cmd.verifyIsOfType(PackageType.MAC);\n+        Objects.requireNonNull(certRequest);\n+        Objects.requireNonNull(keychain);\n+\n+        final Path bundleRoot;\n+        if (cmd.isImagePackageType()) {\n+            bundleRoot = cmd.outputBundle();\n+        } else {\n+            bundleRoot = cmd.pathToUnpackedPackageFile(\n+                    cmd.appInstallationDirectory());\n+        }\n+\n+        assertSigned(bundleRoot, certRequest);\n+\n+        cmd.addLauncherNames(true).stream().map(cmd::appLauncherPath).forEach(launcherPath -> {\n+            assertSigned(launcherPath, certRequest);\n+        });\n+\n+        \/\/ Set to \"null\" if the sign origin is not found, instead of bailing out with an exception.\n+        \/\/ Let is fail in the following TKit.assertEquals() call with a proper log message.\n+        var signOrigin = findSpctlSignOrigin(SpctlType.EXEC, bundleRoot).orElse(null);\n+\n+        TKit.assertEquals(certRequest.name(), signOrigin,\n+                String.format(\"Check [%s] has sign origin as expected\", bundleRoot));\n+    }\n+\n+    public static void verifyPkgSigned(JPackageCommand cmd, CertificateRequest certRequest, MacSign.ResolvedKeychain keychain) {\n+        cmd.verifyIsOfType(PackageType.MAC_PKG);\n+        assertPkgSigned(cmd.outputBundle(), certRequest,\n+                Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest)));\n+    }\n+\n@@ -117,2 +152,2 @@\n-        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"--display\", \"--verbose=4\", path.toString()).saveOutput();\n-        final var result = exec.executeWithoutExitCodeCheck();\n+        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"--display\", \"--verbose=4\", path.toString());\n+        final var result = exec.saveOutput().executeWithoutExitCodeCheck();\n@@ -147,6 +182,28 @@\n-        final var verifier = TKit.TextStreamVerifier.group()\n-                .add(TKit.assertTextStream(\": valid on disk\").predicate(String::endsWith))\n-                .add(TKit.assertTextStream(\": satisfies its Designated Requirement\").predicate(String::endsWith))\n-                .create();\n-        verifier.accept(Executor.of(\"\/usr\/bin\/codesign\", \"--verify\", \"--deep\",\n-                \"--strict\", \"--verbose=2\", path.toString()).executeAndGetOutput().iterator());\n+        assertSigned(path, false);\n+    }\n+\n+    private static void assertSigned(Path path, boolean sudo) {\n+        final Executor exec;\n+        if (sudo) {\n+            exec = Executor.of(\"sudo\", \"\/usr\/bin\/codesign\");\n+        } else {\n+            exec = Executor.of(\"\/usr\/bin\/codesign\");\n+        }\n+        exec.addArguments(\"--verify\", \"--deep\", \"--strict\", \"--verbose=2\", path.toString());\n+        final var result = exec.saveOutput().executeWithoutExitCodeCheck();\n+        if (result.getExitCode() == 0) {\n+            TKit.TextStreamVerifier.group()\n+                    .add(TKit.assertTextStream(\": valid on disk\").predicate(String::endsWith))\n+                    .add(TKit.assertTextStream(\": satisfies its Designated Requirement\").predicate(String::endsWith))\n+                    .create().accept(result.getOutput().iterator());\n+        } else if (!sudo && result.getOutput().stream().findFirst().filter(str -> {\n+            \/\/ By some reason \/usr\/bin\/codesign command fails for some installed bundles.\n+            \/\/ It is known to fail for some AppContentTest test cases and all FileAssociationsTest test cases.\n+            \/\/ Rerunning the command with \"sudo\" works, though.\n+            return str.equals(String.format(\"%s: Permission denied\", path));\n+        }).isPresent()) {\n+                TKit.trace(\"Try \/usr\/bin\/codesign again with `sudo`\");\n+                assertSigned(path, true);\n+        } else {\n+            reportUnexpectedCommandOutcome(exec.getPrintableCommandLine(), result);\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":65,"deletions":8,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    public static void main(String args[]) throws Throwable {\n+    public static void main(String... args) throws Throwable {\n@@ -48,1 +48,1 @@\n-    public static void main(TestBuilder.Builder builder, String args[]) throws Throwable {\n+    public static void main(TestBuilder.Builder builder, String... args) throws Throwable {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,780 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.IntPredicate;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.xml.stream.XMLStreamWriter;\n+import jdk.jpackage.internal.util.IdentityWrapper;\n+\n+public final class ObjectMapper {\n+\n+    private ObjectMapper(\n+            Predicate<String> classFilter,\n+            Predicate<List<String>> methodFilter,\n+            Predicate<String> leafClassFilter,\n+            Map<Method, Function<?, Object>> substitutes,\n+            Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators,\n+            Set<String> accessPackageMethods) {\n+\n+        this.classFilter = Objects.requireNonNull(classFilter);\n+        this.methodFilter = Objects.requireNonNull(methodFilter);\n+        this.leafClassFilter = Objects.requireNonNull(leafClassFilter);\n+        this.substitutes = Objects.requireNonNull(substitutes);\n+        this.mutators = Objects.requireNonNull(mutators);\n+        this.accessPackageMethods = accessPackageMethods;\n+    }\n+\n+    public static Builder blank() {\n+        return new Builder().allowAllLeafClasses(false).exceptLeafClasses().add(Stream.of(\n+                Object.class,\n+                String.class, String[].class,\n+                boolean.class, Boolean.class, boolean[].class, Boolean[].class,\n+                byte.class, Byte.class, byte[].class, Byte[].class,\n+                char.class, Character.class, char[].class, Character[].class,\n+                short.class, Short.class, short[].class, Short[].class,\n+                int.class, Integer.class, int[].class, Integer[].class,\n+                long.class, Long.class, long[].class, Long[].class,\n+                float.class, Float.class, float[].class, Float[].class,\n+                double.class, Double.class, double[].class, Double[].class,\n+                void.class, Void.class, Void[].class\n+        ).map(Class::getName).toList()).apply();\n+    }\n+\n+    public static Builder standard() {\n+        return blank()\n+                .mutate(configureObject())\n+                .mutate(configureLeafClasses())\n+                .mutate(configureOptional())\n+                .mutate(configureFunctionalTypes())\n+                .mutate(configureEnum())\n+                .mutate(configureException());\n+    }\n+\n+    public static Consumer<Builder> configureObject() {\n+        \/\/ Exclude all method of Object class.\n+        return builder -> {\n+            builder.exceptMethods().add(OBJECT_METHODS).apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureLeafClasses() {\n+        return builder -> {\n+            builder.exceptLeafClasses().add(Stream.of(\n+                    IdentityWrapper.class,\n+                    Class.class,\n+                    Path.class,\n+                    Path.of(\"\").getClass(),\n+                    UUID.class,\n+                    BigInteger.class\n+            ).map(Class::getName).toList()).apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureOptional() {\n+        return builder -> {\n+            \/\/ Filter out all but \"get()\" methods of \"Optional\" class.\n+            builder.exceptAllMethods(Optional.class).remove(\"get\").apply();\n+            \/\/ Substitute \"Optional.get()\" with the function that will return \"null\" if the value is \"null\".\n+            builder.subst(Optional.class, \"get\", opt -> {\n+                if (opt.isPresent()) {\n+                    return opt.get();\n+                } else {\n+                    return null;\n+                }\n+            });\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureFunctionalTypes() {\n+        \/\/ Remove all getters from the standard functional types.\n+        return builder -> {\n+            builder.exceptAllMethods(Predicate.class).apply();\n+            builder.exceptAllMethods(Supplier.class).apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureEnum() {\n+        return builder -> {\n+            \/\/ Filter out \"getDeclaringClass()\" and \"describeConstable()\" methods of \"Enum\" class.\n+            builder.exceptSomeMethods(Enum.class).add(\"getDeclaringClass\", \"describeConstable\").apply();\n+        };\n+    }\n+\n+    public static Consumer<Builder> configureException() {\n+        return builder -> {\n+            \/\/ Include only \"getMessage()\" and \"getCause()\" methods of \"Exception\" class.\n+            builder.exceptAllMethods(Exception.class).remove(\"getMessage\", \"getCause\").apply();\n+            builder.mutator(Exception.class, (ex, map) -> {\n+                var eit = map.entrySet().iterator();\n+                while (eit.hasNext()) {\n+                    var e = eit.next();\n+                    if (e.getValue() == NULL) {\n+                        \/\/ Remove property with the \"null\" value.\n+                        eit.remove();\n+                    }\n+                }\n+                map.put(\"getClass\", ex.getClass().getName());\n+            });\n+        };\n+    }\n+\n+    public static String lookupFullMethodName(Method m) {\n+        return lookupFullMethodName(m.getDeclaringClass(), m.getName());\n+    }\n+\n+    public static String lookupFullMethodName(Class<?> c, String m) {\n+        return Objects.requireNonNull(c).getName() + lookupMethodName(m);\n+    }\n+\n+    public static String lookupMethodName(Method m) {\n+        return lookupMethodName(m.getName());\n+    }\n+\n+    public static String lookupMethodName(String m) {\n+        return \"#\" + Objects.requireNonNull(m);\n+    }\n+\n+    public static Object wrapIdentity(Object v) {\n+        if (v instanceof IdentityWrapper<?> wrapper) {\n+            return wrapper;\n+        } else {\n+            return new IdentityWrapper<Object>(v);\n+        }\n+    }\n+\n+    public static void store(Map<String, Object> map, XMLStreamWriter xml) {\n+        XmlWriter.writePropertyMap(map, xml);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Optional<T> findNonNullProperty(Map<String, Object> map, String propertyName) {\n+        Objects.requireNonNull(propertyName);\n+        Objects.requireNonNull(map);\n+\n+        return Optional.ofNullable(map.get(propertyName)).filter(Predicate.not(NULL::equals)).map(v -> {\n+            return (T)v;\n+        });\n+    }\n+\n+    public Object map(Object obj) {\n+        if (obj != null) {\n+            return mapObject(obj).orElseGet(Map::of);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<String, Object> toMap(Object obj) {\n+        if (obj == null) {\n+            return null;\n+        } else {\n+            var mappedObj = map(obj);\n+            if (mappedObj instanceof Map<?, ?> m) {\n+                return (Map<String, Object>)m;\n+            } else {\n+                return Map.of(\"value\", mappedObj);\n+            }\n+        }\n+    }\n+\n+    public Optional<Object> mapObject(Object obj) {\n+        if (obj == null) {\n+            return Optional.empty();\n+        }\n+\n+        if (leafClassFilter.test(obj.getClass().getName())) {\n+            return Optional.of(obj);\n+        }\n+\n+        if (!filter(obj.getClass())) {\n+            return Optional.empty();\n+        }\n+\n+        if (obj instanceof Iterable<?> col) {\n+            return Optional.of(mapIterable(col));\n+        }\n+\n+        if (obj instanceof Map<?, ?> map) {\n+            return Optional.of(mapMap(map));\n+        }\n+\n+        if (obj.getClass().isArray()) {\n+            return Optional.of(mapArray(obj));\n+        }\n+\n+        var theMap = getMethods(obj).map(m -> {\n+            final Object propertyValue;\n+            final var subst = substitutes.get(m);\n+            if (subst != null) {\n+                propertyValue = applyGetter(obj, subst);\n+            } else {\n+                propertyValue = invoke(m, obj);\n+            }\n+            return Map.entry(m.getName(), mapObject(propertyValue).orElse(NULL));\n+        }).collect(toMutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        mutators.entrySet().stream().filter(m -> {\n+            return m.getKey().isInstance(obj);\n+        }).findFirst().ifPresent(m -> {\n+            m.getValue().accept(obj, theMap);\n+        });\n+\n+        if (theMap.isEmpty()) {\n+            return Optional.of(wrapIdentity(obj));\n+        }\n+\n+        return Optional.of(theMap);\n+    }\n+\n+    private Object invoke(Method m, Object obj) {\n+        try {\n+            return m.invoke(obj);\n+        } catch (IllegalAccessException ex) {\n+            throw rethrowUnchecked(ex);\n+        } catch (InvocationTargetException ex) {\n+            return map(ex.getTargetException());\n+        }\n+    }\n+\n+    private Collection<Object> mapIterable(Iterable<?> col) {\n+        final List<Object> list = new ArrayList<>();\n+        for (var obj : col) {\n+            list.add(mapObject(obj).orElse(NULL));\n+        }\n+        return list;\n+    }\n+\n+    private Map<Object, Object> mapMap(Map<?, ?> map) {\n+        return map.entrySet().stream().collect(toMutableMap(e -> {\n+            return mapObject(e.getKey()).orElse(NULL);\n+        }, e -> {\n+            return mapObject(e.getValue()).orElse(NULL);\n+        }));\n+    }\n+\n+    private Object mapArray(Object arr) {\n+        final var len = Array.getLength(arr);\n+\n+        if (len == 0) {\n+            return arr;\n+        }\n+\n+        Object[] buf = null;\n+\n+        for (int i = 0; i != len; i++) {\n+            var from = Array.get(arr, i);\n+            if (from != null) {\n+                var to = mapObject(from).orElseThrow();\n+                if (from != to || buf != null) {\n+                    if (buf == null) {\n+                        buf = (Object[])Array.newInstance(Object.class, len);\n+                        System.arraycopy(arr, 0, buf, 0, i);\n+                    }\n+                    buf[i] = to;\n+                }\n+            }\n+        }\n+\n+        return Optional.ofNullable((Object)buf).orElse(arr);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> Object applyGetter(Object obj, Function<T, Object> getter) {\n+        return getter.apply((T)obj);\n+    }\n+\n+    private boolean filter(Class<?> type) {\n+        return classFilter.test(type.getName());\n+    }\n+\n+    private boolean filter(Method m) {\n+        return methodFilter.test(List.of(lookupMethodName(m), lookupFullMethodName(m)));\n+    }\n+\n+    private Stream<Method> getMethods(Object obj) {\n+        return MethodGroups.create(obj.getClass(), accessPackageMethods).filter(this::filter).map(MethodGroup::callable);\n+    }\n+\n+    private static boolean defaultFilter(Method m) {\n+        if (Modifier.isStatic(m.getModifiers()) || (m.getParameterCount() > 0) || void.class.equals(m.getReturnType())) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static <T, K, U>\n+    Collector<T, ?, Map<K,U>> toMutableMap(Function<? super T, ? extends K> keyMapper,\n+            Function<? super T, ? extends U> valueMapper) {\n+        return Collectors.toMap(keyMapper, valueMapper, (x , y) -> {\n+            throw new UnsupportedOperationException(\n+                    String.format(\"Entries with the same key and different values [%s] and [%s]\", x, y));\n+        }, HashMap::new);\n+    }\n+\n+    public static final class Builder {\n+\n+        private Builder() {\n+            allowAllClasses();\n+            allowAllLeafClasses();\n+            allowAllMethods();\n+        }\n+\n+        public ObjectMapper create() {\n+            return new ObjectMapper(\n+                    classFilter.createPredicate(),\n+                    methodFilter.createMultiPredicate(),\n+                    leafClassFilter.createPredicate(),\n+                    Map.copyOf(substitutes),\n+                    Map.copyOf(mutators),\n+                    accessPackageMethods);\n+        }\n+\n+\n+        public final class NamePredicateBuilder {\n+\n+            NamePredicateBuilder(Filter sink) {\n+                this.sink = Objects.requireNonNull(sink);\n+            }\n+\n+            public Builder apply() {\n+                sink.addAll(items);\n+                return Builder.this;\n+            }\n+\n+            public NamePredicateBuilder add(String... v) {\n+                return add(List.of(v));\n+            }\n+\n+            public NamePredicateBuilder add(Collection<String> v) {\n+                items.addAll(v);\n+                return this;\n+            }\n+\n+            private final Filter sink;\n+            private final Set<String> items = new HashSet<>();\n+        }\n+\n+\n+        public final class AllMethodPredicateBuilder {\n+\n+            AllMethodPredicateBuilder(Class<?> type) {\n+                impl = new MethodPredicateBuilder(type, false);\n+            }\n+\n+            public AllMethodPredicateBuilder remove(String... v) {\n+                return remove(List.of(v));\n+            }\n+\n+            public AllMethodPredicateBuilder remove(Collection<String> v) {\n+                impl.add(v);\n+                return this;\n+            }\n+\n+            public Builder apply() {\n+                return impl.apply();\n+            }\n+\n+            private final MethodPredicateBuilder impl;\n+        }\n+\n+\n+        public final class SomeMethodPredicateBuilder {\n+\n+            SomeMethodPredicateBuilder(Class<?> type) {\n+                impl = new MethodPredicateBuilder(type, true);\n+            }\n+\n+            public SomeMethodPredicateBuilder add(String... v) {\n+                return add(List.of(v));\n+            }\n+\n+            public SomeMethodPredicateBuilder add(Collection<String> v) {\n+                impl.add(v);\n+                return this;\n+            }\n+\n+            public Builder apply() {\n+                return impl.apply();\n+            }\n+\n+            private final MethodPredicateBuilder impl;\n+        }\n+\n+\n+        public Builder allowAllClasses(boolean v) {\n+            classFilter.negate(v);\n+            return this;\n+        }\n+\n+        public Builder allowAllClasses() {\n+            return allowAllClasses(true);\n+        }\n+\n+        public Builder allowAllMethods(boolean v) {\n+            methodFilter.negate(v);\n+            return this;\n+        }\n+\n+        public Builder allowAllMethods() {\n+            return allowAllMethods(true);\n+        }\n+\n+        public Builder allowAllLeafClasses(boolean v) {\n+            leafClassFilter.negate(v);\n+            return this;\n+        }\n+\n+        public Builder allowAllLeafClasses() {\n+            return allowAllLeafClasses(true);\n+        }\n+\n+        public NamePredicateBuilder exceptClasses() {\n+            return new NamePredicateBuilder(classFilter);\n+        }\n+\n+        public AllMethodPredicateBuilder exceptAllMethods(Class<?> type) {\n+            return new AllMethodPredicateBuilder(type);\n+        }\n+\n+        public SomeMethodPredicateBuilder exceptSomeMethods(Class<?> type) {\n+            return new SomeMethodPredicateBuilder(type);\n+        }\n+\n+        public NamePredicateBuilder exceptMethods() {\n+            return new NamePredicateBuilder(methodFilter);\n+        }\n+\n+        public NamePredicateBuilder exceptLeafClasses() {\n+            return new NamePredicateBuilder(leafClassFilter);\n+        }\n+\n+        public Builder subst(Method target, Function<?, Object> substitute) {\n+            substitutes.put(Objects.requireNonNull(target), Objects.requireNonNull(substitute));\n+            return this;\n+        }\n+\n+        public <T> Builder subst(Class<? extends T> targetClass, String targetMethodName, Function<T, Object> substitute) {\n+            var method = toSupplier(() -> targetClass.getMethod(targetMethodName)).get();\n+            return subst(method, substitute);\n+        }\n+\n+        public Builder mutator(Class<?> targetClass, BiConsumer<Object, Map<String, Object>> mutator) {\n+            mutators.put(Objects.requireNonNull(targetClass), Objects.requireNonNull(mutator));\n+            return this;\n+        }\n+\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        public Builder accessPackageMethods(Package... packages) {\n+            Stream.of(packages).map(Package::getName).forEach(accessPackageMethods::add);\n+            return this;\n+        }\n+\n+\n+        private final class MethodPredicateBuilder {\n+\n+            MethodPredicateBuilder(Class<?> type, boolean negate) {\n+                this.type = Objects.requireNonNull(type);\n+                buffer.negate(negate);\n+            }\n+\n+            void add(Collection<String> v) {\n+                buffer.addAll(v);\n+            }\n+\n+            Builder apply() {\n+                var pred = buffer.createPredicate();\n+\n+                var items = MethodGroups.create(type, accessPackageMethods).groups().stream().map(MethodGroup::primary).filter(m -> {\n+                    return !OBJECT_METHODS.contains(ObjectMapper.lookupMethodName(m));\n+                }).filter(m -> {\n+                    return !pred.test(m.getName());\n+                }).map(ObjectMapper::lookupFullMethodName).toList();\n+\n+                return exceptMethods().add(items).apply();\n+            }\n+\n+            private final Class<?> type;\n+            private final Filter buffer = new Filter();\n+        }\n+\n+\n+        private static final class Filter {\n+            Predicate<List<String>> createMultiPredicate() {\n+                if (items.isEmpty()) {\n+                    var match = negate;\n+                    return v -> match;\n+                } else if (negate) {\n+                    return v -> {\n+                        return v.stream().noneMatch(Set.copyOf(items)::contains);\n+                    };\n+                } else {\n+                    return v -> {\n+                        return v.stream().anyMatch(Set.copyOf(items)::contains);\n+                    };\n+                }\n+            }\n+\n+            Predicate<String> createPredicate() {\n+                if (items.isEmpty()) {\n+                    var match = negate;\n+                    return v -> match;\n+                } else if (negate) {\n+                    return Predicate.not(Set.copyOf(items)::contains);\n+                } else {\n+                    return Set.copyOf(items)::contains;\n+                }\n+            }\n+\n+            void addAll(Collection<String> v) {\n+                items.addAll(v);\n+            }\n+\n+            void negate(boolean v) {\n+                negate = v;\n+            }\n+\n+            private boolean negate;\n+            private final Set<String> items = new HashSet<>();\n+        }\n+\n+\n+        private final Filter classFilter = new Filter();\n+        private final Filter methodFilter = new Filter();\n+        private final Filter leafClassFilter = new Filter();\n+        private final Map<Method, Function<?, Object>> substitutes = new HashMap<>();\n+        private final Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators = new HashMap<>();\n+        private final Set<String> accessPackageMethods = new HashSet<>();\n+    }\n+\n+\n+    private record MethodGroup(List<Method> methods) {\n+\n+        MethodGroup {\n+            Objects.requireNonNull(methods);\n+\n+            if (methods.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            methods.stream().map(Method::getName).reduce((a, b) -> {\n+                if (!a.equals(b)) {\n+                    throw new IllegalArgumentException();\n+                } else {\n+                    return a;\n+                }\n+            });\n+        }\n+\n+        Method callable() {\n+            var primary = primary();\n+            if (!primary.getDeclaringClass().isInterface()) {\n+                primary = methods.stream().filter(m -> {\n+                    return m.getDeclaringClass().isInterface();\n+                }).findFirst().orElse(primary);\n+            }\n+            return primary;\n+        }\n+\n+        Method primary() {\n+            return methods.getFirst();\n+        }\n+\n+        boolean match(Predicate<Method> predicate) {\n+            Objects.requireNonNull(predicate);\n+            return methods.stream().allMatch(predicate);\n+        }\n+    }\n+\n+\n+    private record MethodGroups(Collection<MethodGroup> groups) {\n+\n+        MethodGroups {\n+            Objects.requireNonNull(groups);\n+        }\n+\n+        Stream<MethodGroup> filter(Predicate<Method> predicate) {\n+            Objects.requireNonNull(predicate);\n+\n+            return groups.stream().filter(g -> {\n+                return g.match(predicate);\n+            });\n+        }\n+\n+        static MethodGroups create(Class<?> type, Set<String> accessPackageMethods) {\n+            List<Class<?>> types = new ArrayList<>();\n+\n+            collectSuperclassAndInterfaces(type, types::add);\n+\n+            final var methodGroups = types.stream()\n+                    .map(c -> {\n+                        if (accessPackageMethods.contains(c.getPackageName())) {\n+                            return PUBLIC_AND_PACKAGE_METHODS_GETTER.apply(c);\n+                        } else {\n+                            return PUBLIC_METHODS_GETTER.apply(c);\n+                        }\n+                    })\n+                    .flatMap(x -> x)\n+                    .filter(ObjectMapper::defaultFilter)\n+                    .collect(groupingBy(Method::getName));\n+\n+            return new MethodGroups(methodGroups.values().stream().distinct().map(MethodGroup::new).toList());\n+        }\n+\n+        private static void collectSuperclassAndInterfaces(Class<?> type, Consumer<Class<?>> sink) {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(sink);\n+\n+            for (; type != null; type = type.getSuperclass()) {\n+                sink.accept(type);\n+                for (var i : type.getInterfaces()) {\n+                    collectSuperclassAndInterfaces(i, sink);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private static final class XmlWriter {\n+        static void write(Object obj,  XMLStreamWriter xml) {\n+            if (obj instanceof Map<?, ?> map) {\n+                writePropertyMap(map, xml);\n+            } else if (obj instanceof Collection<?> col) {\n+                writeCollection(col, xml);\n+            } else if (obj.getClass().isArray()) {\n+                writeArray(obj, xml);\n+            } else {\n+                toRunnable(() -> xml.writeCharacters(obj.toString())).run();\n+            }\n+        }\n+\n+        private static void writePropertyMap(Map<?, ?> map, XMLStreamWriter xml) {\n+            map.entrySet().stream().sorted(Comparator.comparing(e -> e.getKey().toString())).forEach(toConsumer(e -> {\n+                xml.writeStartElement(\"property\");\n+                xml.writeAttribute(\"name\", e.getKey().toString());\n+                write(e.getValue(), xml);\n+                xml.writeEndElement();\n+            }));\n+        }\n+\n+        private static void writeCollection(Collection<?> col, XMLStreamWriter xml) {\n+            try {\n+                xml.writeStartElement(\"collection\");\n+                xml.writeAttribute(\"size\", Integer.toString(col.size()));\n+                for (var item : col) {\n+                    xml.writeStartElement(\"item\");\n+                    write(item, xml);\n+                    xml.writeEndElement();\n+                }\n+                xml.writeEndElement();\n+            } catch (Exception ex) {\n+                rethrowUnchecked(ex);\n+            }\n+        }\n+\n+        private static void writeArray(Object arr, XMLStreamWriter xml) {\n+            var len = Array.getLength(arr);\n+            try {\n+                xml.writeStartElement(\"array\");\n+                xml.writeAttribute(\"size\", Integer.toString(len));\n+                for (int i = 0; i != len; i++) {\n+                    xml.writeStartElement(\"item\");\n+                    write(Array.get(arr, i), xml);\n+                    xml.writeEndElement();\n+                }\n+                xml.writeEndElement();\n+            } catch (Exception ex) {\n+                rethrowUnchecked(ex);\n+            }\n+        }\n+    }\n+\n+\n+    private final Predicate<String> classFilter;\n+    private final Predicate<List<String>> methodFilter;\n+    private final Predicate<String> leafClassFilter;\n+    private final Map<Method, Function<?, Object>> substitutes;\n+    private final Map<Class<?>, BiConsumer<Object, Map<String, Object>>> mutators;\n+    private final Set<String> accessPackageMethods;\n+\n+    static final Object NULL = new Object() {\n+        @Override\n+        public String toString() {\n+            return \"<null>\";\n+        }\n+    };\n+\n+    private static final Set<String> OBJECT_METHODS =\n+            Stream.of(Object.class.getMethods()).map(ObjectMapper::lookupMethodName).collect(toSet());\n+\n+    private static final Function<Class<?>, Stream<Method>> PUBLIC_METHODS_GETTER = type -> {\n+        return Stream.of(type.getMethods());\n+    };\n+\n+    private static final Function<Class<?>, Stream<Method>> PUBLIC_AND_PACKAGE_METHODS_GETTER = type -> {\n+        return Stream.of(type.getDeclaredMethods()).filter(m -> {\n+            return Stream.<IntPredicate>of(Modifier::isPrivate, Modifier::isProtected).map(p -> {\n+                return p.test(m.getModifiers());\n+            }).allMatch(v -> !v);\n+        }).map(m -> {\n+            m.setAccessible(true);\n+            return m;\n+        });\n+    };\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ObjectMapper.java","additions":780,"deletions":0,"binary":false,"changes":780,"status":"added"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Collections;\n@@ -321,0 +320,5 @@\n+    public PackageTest mutate(Consumer<PackageTest> mutator) {\n+        mutator.accept(this);\n+        return this;\n+    }\n+\n@@ -336,0 +340,8 @@\n+    public PackageTest forTypes(PackageType type, Consumer<PackageTest> action) {\n+        return forTypes(List.of(type), action);\n+    }\n+\n+    public PackageTest forTypes(Collection<PackageType> types, Consumer<PackageTest> action) {\n+        return forTypes(types, () -> action.accept(this));\n+    }\n+\n@@ -346,0 +358,8 @@\n+    public PackageTest notForTypes(PackageType type, Consumer<PackageTest> action) {\n+        return notForTypes(List.of(type), action);\n+    }\n+\n+    public PackageTest notForTypes(Collection<PackageType> types, Consumer<PackageTest> action) {\n+        return notForTypes(types, () -> action.accept(this));\n+    }\n+\n@@ -767,1 +787,1 @@\n-                    LinuxHelper.verifyDesktopFiles(cmd, true);\n+                    LinuxHelper.verifyDesktopIntegrationFiles(cmd, true);\n@@ -775,1 +795,1 @@\n-            cmd.assertAppLayout();\n+            cmd.runStandardAsserts();\n@@ -848,1 +868,1 @@\n-                    LinuxHelper.verifyDesktopFiles(cmd, false);\n+                    LinuxHelper.verifyDesktopIntegrationFiles(cmd, false);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n+\n+final class PropertyFinder {\n+\n+    @FunctionalInterface\n+    static interface Finder<T> {\n+        Optional<String> find(T target);\n+\n+        default Finder<T> defaultValue(String v) {\n+            return target -> {\n+                return Optional.of(find(target).orElse(v));\n+            };\n+        }\n+\n+        default Finder<T> map(UnaryOperator<String> v) {\n+            Objects.requireNonNull(v);\n+            return target -> {\n+                return find(target).map(v);\n+            };\n+        }\n+\n+        default Finder<T> or(Finder<T> other) {\n+            return target -> {\n+                return find(target).or(() -> {\n+                    return other.find(target);\n+                });\n+            };\n+        }\n+    }\n+\n+    static <T> Finder<T> nop() {\n+        return target -> {\n+            return Optional.empty();\n+        };\n+    }\n+\n+    static Finder<AppImageFile> appImageFileLauncher(JPackageCommand cmd, String launcherName, String propertyName) {\n+        Objects.requireNonNull(propertyName);\n+        if (cmd.isMainLauncher(launcherName)) {\n+            return target -> {\n+                return Optional.ofNullable(target.launchers().get(target.mainLauncherName()).get(propertyName));\n+            };\n+        } else {\n+            return target -> {\n+                return Optional.ofNullable(target.addLaunchers().get(launcherName).get(propertyName));\n+            };\n+        }\n+    }\n+\n+    static Finder<AppImageFile> appImageFile(Function<AppImageFile, String> propertyGetter) {\n+        Objects.requireNonNull(propertyGetter);\n+        return target -> {\n+            return Optional.of(propertyGetter.apply(target));\n+        };\n+    }\n+\n+    static Finder<AppImageFile> appImageFileOptional(Function<AppImageFile, Optional<String>> propertyGetter) {\n+        Objects.requireNonNull(propertyGetter);\n+        return target -> {\n+            return propertyGetter.apply(target);\n+        };\n+    }\n+\n+    static Finder<PropertyFile> launcherPropertyFile(String propertyName) {\n+        return target -> {\n+            return target.findProperty(propertyName);\n+        };\n+    }\n+\n+    static Finder<JPackageCommand> cmdlineBooleanOption(String optionName) {\n+        return target -> {\n+            return Optional.of(target.hasArgument(optionName)).map(Boolean::valueOf).map(Object::toString);\n+        };\n+    }\n+\n+    static Finder<JPackageCommand> cmdlineOptionWithValue(String optionName) {\n+        return target -> {\n+            return Optional.ofNullable(target.getArgumentValue(optionName));\n+        };\n+    }\n+\n+    static Optional<String> findAppProperty(\n+            JPackageCommand cmd,\n+            Finder<JPackageCommand> cmdlineFinder,\n+            Finder<AppImageFile> appImageFileFinder) {\n+\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(cmdlineFinder);\n+        Objects.requireNonNull(appImageFileFinder);\n+\n+        var reply = cmdlineFinder.find(cmd);\n+        if (reply.isPresent()) {\n+            return reply;\n+        } else {\n+            var appImageFilePath = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n+            return appImageFilePath.map(AppImageFile::load).flatMap(appImageFileFinder::find);\n+        }\n+    }\n+\n+    static Optional<String> findLauncherProperty(\n+            JPackageCommand cmd,\n+            String launcherName,\n+            Finder<JPackageCommand> cmdlineFinder,\n+            Finder<PropertyFile> addLauncherPropertyFileFinder,\n+            Finder<AppImageFile> appImageFileFinder) {\n+\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(cmdlineFinder);\n+        Objects.requireNonNull(addLauncherPropertyFileFinder);\n+        Objects.requireNonNull(appImageFileFinder);\n+\n+        var mainLauncher = cmd.isMainLauncher(launcherName);\n+\n+        var appImageFilePath = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n+\n+        Optional<String> reply;\n+\n+        if (mainLauncher) {\n+            reply = cmdlineFinder.find(cmd);\n+        } else if (appImageFilePath.isEmpty()) {\n+            var props = getAdditionalLauncherProperties(cmd, launcherName);\n+            reply = addLauncherPropertyFileFinder.find(props);\n+        } else {\n+            reply = Optional.empty();\n+        }\n+\n+        if (reply.isPresent()) {\n+            return reply;\n+        } else {\n+            return appImageFilePath.map(AppImageFile::load).flatMap(appImageFileFinder::find);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PropertyFinder.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingBiFunction.toBiFunction;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -31,1 +33,0 @@\n-import java.io.FileOutputStream;\n@@ -41,0 +42,1 @@\n+import java.nio.file.StandardOpenOption;\n@@ -112,1 +114,1 @@\n-        if (extraLogStream != null) {\n+        if (state().extraLogStream != null) {\n@@ -122,1 +124,33 @@\n-        var oldExtraLogStream = extraLogStream;\n+        withNewState(action, stateBuilder -> {\n+            stateBuilder.extraLogStream(logStream);\n+        });\n+    }\n+\n+    public static void withMainLogStream(ThrowingRunnable action, PrintStream logStream) {\n+        withNewState(action, stateBuilder -> {\n+            stateBuilder.mainLogStream(logStream);\n+        });\n+    }\n+\n+    public static void withStackTraceStream(ThrowingRunnable action, PrintStream logStream) {\n+        withNewState(action, stateBuilder -> {\n+            stateBuilder.stackTraceStream(logStream);\n+        });\n+    }\n+\n+    public static State state() {\n+        return STATE.get();\n+    }\n+\n+    public static void state(State v) {\n+        STATE.set(Objects.requireNonNull(v));\n+    }\n+\n+    private static void withNewState(ThrowingRunnable action, Consumer<State.Builder> stateBuilderMutator) {\n+        Objects.requireNonNull(action);\n+        Objects.requireNonNull(stateBuilderMutator);\n+\n+        var oldState = state();\n+        var builder = oldState.buildCopy();\n+        stateBuilderMutator.accept(builder);\n+        var newState = builder.create();\n@@ -124,1 +158,1 @@\n-            extraLogStream = logStream;\n+            state(newState);\n@@ -127,1 +161,1 @@\n-            extraLogStream = oldExtraLogStream;\n+            state(oldState);\n@@ -144,3 +178,2 @@\n-        if (currentTest != null) {\n-            throw new IllegalStateException(\n-                    \"Unexpected nested or concurrent Test.run() call\");\n+        if (currentTest() != null) {\n+            throw new IllegalStateException(\"Unexpected nested Test.run() call\");\n@@ -151,11 +184,9 @@\n-                currentTest = test;\n-                try {\n-                    if (modes.contains(RunTestMode.FAIL_FAST)) {\n-                        ThrowingRunnable.toRunnable(test::run).run();\n-                    } else {\n-                        ignoreExceptions(test).run();\n-                    }\n-                } finally {\n-                    currentTest = null;\n-                    if (extraLogStream != null) {\n-                        extraLogStream.flush();\n+                withNewState(() -> {\n+                    try {\n+                        if (modes.contains(RunTestMode.FAIL_FAST)) {\n+                            test.run();\n+                        } else {\n+                            ignoreExceptions(test).run();\n+                        }\n+                    } finally {\n+                        Optional.ofNullable(state().extraLogStream).ifPresent(PrintStream::flush);\n@@ -163,1 +194,3 @@\n-                }\n+                }, stateBuilder -> {\n+                    stateBuilder.currentTest(test);\n+                });\n@@ -220,1 +253,1 @@\n-        return currentTest.workDir();\n+        return currentTest().workDir();\n@@ -227,1 +260,1 @@\n-        String appNamePrefix = currentTest.functionName();\n+        String appNamePrefix = currentTest().functionName();\n@@ -231,1 +264,1 @@\n-        return Stream.of(appNamePrefix, currentTest.baseName()).filter(\n+        return Stream.of(appNamePrefix, currentTest().baseName()).filter(\n@@ -259,3 +292,4 @@\n-        System.out.println(v);\n-        if (extraLogStream != null) {\n-            extraLogStream.println(v);\n+        var state = state();\n+        state.mainLogStream.println(v);\n+        if (state.extraLogStream != null) {\n+            state.extraLogStream.println(v);\n@@ -283,2 +317,5 @@\n-        ThrowingRunnable.toRunnable(() -> Files.write(filename,\n-                lines.peek(TKit::trace).collect(Collectors.toList()))).run();\n+        try {\n+            Files.write(filename, lines.peek(TKit::trace).toList());\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n@@ -292,3 +329,7 @@\n-        ThrowingRunnable.toRunnable(() -> Files.write(propsFilename,\n-                props.stream().map(e -> String.join(\"=\", e.getKey(),\n-                e.getValue())).peek(TKit::trace).collect(Collectors.toList()))).run();\n+        try {\n+            Files.write(propsFilename, props.stream().map(e -> {\n+                return String.join(\"=\", e.getKey(), e.getValue());\n+            }).peek(TKit::trace).toList());\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n@@ -298,1 +339,1 @@\n-    public static void traceFileContents(Path path, String label) throws IOException {\n+    public static void traceFileContents(Path path, String label) {\n@@ -301,1 +342,5 @@\n-        Files.readAllLines(path).forEach(TKit::trace);\n+        try {\n+            Files.readAllLines(path).forEach(TKit::trace);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n@@ -311,1 +356,1 @@\n-        if (TRACE) {\n+        if (state().trace) {\n@@ -317,1 +362,1 @@\n-        if (TRACE_ASSERTS) {\n+        if (state().traceAsserts) {\n@@ -578,1 +623,1 @@\n-        currentTest.notifySkipped(ex);\n+        currentTest().notifySkipped(ex);\n@@ -582,0 +627,4 @@\n+    public static boolean isSkippedException(Throwable t) {\n+        return JtregSkippedExceptionClass.INSTANCE.isInstance(t);\n+    }\n+\n@@ -656,4 +705,3 @@\n-        if (extraLogStream != null) {\n-            throwable.printStackTrace(extraLogStream);\n-        }\n-        throwable.printStackTrace();\n+        var state = state();\n+        Optional.ofNullable(state.extraLogStream).ifPresent(throwable::printStackTrace);\n+        throwable.printStackTrace(state.stackTraceStream);\n@@ -670,1 +718,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -681,1 +729,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -692,1 +740,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -703,1 +751,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -715,1 +763,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -727,1 +775,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -740,1 +788,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -750,1 +798,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -767,1 +815,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -779,1 +827,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -800,0 +848,29 @@\n+    public static void assertMismatchFileContent(Path a, Path b) {\n+        assertFilesMismatch(a, b, true, Optional.empty());\n+    }\n+\n+    public static void assertMismatchFileContent(Path a, Path b, String msg) {\n+        assertFilesMismatch(a, b, true, Optional.of(msg));\n+    }\n+\n+    public static void assertSameFileContent(Path a, Path b) {\n+        assertFilesMismatch(a, b, false, Optional.empty());\n+    }\n+\n+    public static void assertSameFileContent(Path a, Path b, String msg) {\n+        assertFilesMismatch(a, b, false, Optional.of(msg));\n+    }\n+\n+    public static void assertFilesMismatch(Path a, Path b, boolean expectMismatch, Optional<String> msg) {\n+        var mismatch = toBiFunction(Files::mismatch).apply(a, b) != -1;\n+        if (expectMismatch) {\n+            assertTrue(mismatch, msg.orElseGet(() -> {\n+                return String.format(\"Check the content of [%s] and [%s] files mismatch\", a, b);\n+            }));\n+        } else {\n+            assertTrue(!mismatch, msg.orElseGet(() -> {\n+                return String.format(\"Check the content of [%s] and [%s] files is the same\", a, b);\n+            }));\n+        }\n+    }\n+\n@@ -834,1 +911,8 @@\n-                (\"Check [%s] is a symbolic link\", path));\n+                (\"Check [%s] is a symbolic link\", Objects.requireNonNull(path)));\n+    }\n+\n+    public static void assertSymbolicLinkTarget(Path symlinkPath, Path expectedTargetPath) {\n+        assertSymbolicLinkExists(symlinkPath);\n+        var targetPath = toFunction(Files::readSymbolicLink).apply(symlinkPath);\n+        assertEquals(expectedTargetPath, targetPath,\n+                String.format(\"Check the target of the symbolic link [%s]\", symlinkPath));\n@@ -856,1 +940,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -882,1 +966,1 @@\n-            currentTest.notifyAssert();\n+            currentTest().notifyAssert();\n@@ -909,1 +993,1 @@\n-            currentTest.notifyAssert();\n+            currentTest().notifyAssert();\n@@ -954,1 +1038,1 @@\n-        currentTest.notifyAssert();\n+        currentTest().notifyAssert();\n@@ -1180,6 +1264,7 @@\n-        if (LOG_FILE == null) {\n-            return null;\n-        }\n-\n-        return ThrowingSupplier.toSupplier(() -> new PrintStream(\n-                new FileOutputStream(LOG_FILE.toFile(), true))).get();\n+        return state().logFile.map(logfile -> {\n+            try {\n+                return Files.newOutputStream(logfile, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }).map(PrintStream::new).orElse(null);\n@@ -1197,2 +1282,2 @@\n-        public static void assertEquals(PathSnapshot a, PathSnapshot b, String msg) {\n-            assertStringListEquals(a.contentHashes(), b.contentHashes(), msg);\n+        public void assertEquals(PathSnapshot other, String msg) {\n+            assertStringListEquals(contentHashes(), other.contentHashes(), msg);\n@@ -1229,9 +1314,0 @@\n-    private static TestInstance currentTest;\n-    private static PrintStream extraLogStream;\n-\n-    private static final boolean TRACE;\n-    private static final boolean TRACE_ASSERTS;\n-\n-    static final boolean VERBOSE_JPACKAGE;\n-    static final boolean VERBOSE_TEST_SETUP;\n-\n@@ -1265,7 +1341,3 @@\n-    static final Path LOG_FILE = Functional.identity(() -> {\n-        String val = getConfigProperty(\"logfile\");\n-        if (val == null) {\n-            return null;\n-        }\n-        return Path.of(val);\n-    }).get();\n+    private static TestInstance currentTest() {\n+        return state().currentTest;\n+    }\n@@ -1273,16 +1345,3 @@\n-    static {\n-        Set<String> logOptions = tokenizeConfigProperty(\"suppress-logging\");\n-        if (logOptions == null) {\n-            TRACE = true;\n-            TRACE_ASSERTS = true;\n-            VERBOSE_JPACKAGE = true;\n-            VERBOSE_TEST_SETUP = true;\n-        } else if (logOptions.contains(\"all\")) {\n-            TRACE = false;\n-            TRACE_ASSERTS = false;\n-            VERBOSE_JPACKAGE = false;\n-            VERBOSE_TEST_SETUP = false;\n-        } else {\n-            Predicate<Set<String>> isNonOf = options -> {\n-                return Collections.disjoint(logOptions, options);\n-            };\n+    static boolean verboseJPackage() {\n+        return state().verboseJPackage;\n+    }\n@@ -1290,5 +1349,2 @@\n-            TRACE = isNonOf.test(Set.of(\"trace\", \"t\"));\n-            TRACE_ASSERTS = isNonOf.test(Set.of(\"assert\", \"a\"));\n-            VERBOSE_JPACKAGE = isNonOf.test(Set.of(\"jpackage\", \"jp\"));\n-            VERBOSE_TEST_SETUP = isNonOf.test(Set.of(\"init\", \"i\"));\n-        }\n+    static boolean verboseTestSetup() {\n+        return state().verboseTestSetup;\n@@ -1297,0 +1353,1 @@\n+\n@@ -1322,0 +1379,155 @@\n+\n+\n+    public static final class State {\n+\n+        private State(\n+                Optional<Path> logFile,\n+                TestInstance currentTest,\n+                PrintStream mainLogStream,\n+                PrintStream stackTraceStream,\n+                PrintStream extraLogStream,\n+                boolean trace,\n+                boolean traceAsserts,\n+                boolean verboseJPackage,\n+                boolean verboseTestSetup) {\n+\n+            Objects.requireNonNull(logFile);\n+            Objects.requireNonNull(mainLogStream);\n+            Objects.requireNonNull(stackTraceStream);\n+\n+            this.logFile = logFile;\n+            this.currentTest = currentTest;\n+            this.mainLogStream = mainLogStream;\n+            this.stackTraceStream = stackTraceStream;\n+            this.extraLogStream = extraLogStream;\n+\n+            this.trace = trace;\n+            this.traceAsserts = traceAsserts;\n+\n+            this.verboseJPackage = verboseJPackage;\n+            this.verboseTestSetup = verboseTestSetup;\n+        }\n+\n+\n+        Builder buildCopy() {\n+            return build().initFrom(this);\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+\n+        static final class Builder {\n+\n+            Builder initDefaults() {\n+                logFile = Optional.ofNullable(getConfigProperty(\"logfile\")).map(Path::of);\n+                currentTest = null;\n+                mainLogStream = System.out;\n+                stackTraceStream = System.err;\n+                extraLogStream = null;\n+\n+                var logOptions = tokenizeConfigProperty(\"suppress-logging\");\n+                if (logOptions == null) {\n+                    trace = true;\n+                    traceAsserts = true;\n+                    verboseJPackage = true;\n+                    verboseTestSetup = true;\n+                } else if (logOptions.contains(\"all\")) {\n+                    trace = false;\n+                    traceAsserts = false;\n+                    verboseJPackage = false;\n+                    verboseTestSetup = false;\n+                } else {\n+                    Predicate<Set<String>> isNonOf = options -> {\n+                        return Collections.disjoint(logOptions, options);\n+                    };\n+\n+                    trace = isNonOf.test(Set.of(\"trace\", \"t\"));\n+                    traceAsserts = isNonOf.test(Set.of(\"assert\", \"a\"));\n+                    verboseJPackage = isNonOf.test(Set.of(\"jpackage\", \"jp\"));\n+                    verboseTestSetup = isNonOf.test(Set.of(\"init\", \"i\"));\n+                }\n+\n+                return this;\n+            }\n+\n+            Builder initFrom(State state) {\n+                logFile = state.logFile;\n+                currentTest = state.currentTest;\n+                mainLogStream = state.mainLogStream;\n+                stackTraceStream = state.stackTraceStream;\n+                extraLogStream = state.extraLogStream;\n+\n+                trace = state.trace;\n+                traceAsserts = state.traceAsserts;\n+\n+                verboseJPackage = state.verboseJPackage;\n+                verboseTestSetup = state.verboseTestSetup;\n+\n+                return this;\n+            }\n+\n+            Builder logFile(Optional<Path> v) {\n+                logFile = v;\n+                return this;\n+            }\n+\n+            Builder currentTest(TestInstance v) {\n+                currentTest = v;\n+                return this;\n+            }\n+\n+            Builder mainLogStream(PrintStream v) {\n+                mainLogStream = v;\n+                return this;\n+            }\n+\n+            Builder stackTraceStream(PrintStream v) {\n+                stackTraceStream = v;\n+                return this;\n+            }\n+\n+            Builder extraLogStream(PrintStream v) {\n+                extraLogStream = v;\n+                return this;\n+            }\n+\n+            State create() {\n+                return new State(logFile, currentTest, mainLogStream, stackTraceStream, extraLogStream, trace, traceAsserts, verboseJPackage, verboseTestSetup);\n+            }\n+\n+            private Optional<Path> logFile;\n+            private TestInstance currentTest;\n+            private PrintStream mainLogStream;\n+            private PrintStream stackTraceStream;\n+            private PrintStream extraLogStream;\n+\n+            private boolean trace;\n+            private boolean traceAsserts;\n+\n+            private boolean verboseJPackage;\n+            private boolean verboseTestSetup;\n+        }\n+\n+\n+        private final Optional<Path> logFile;\n+        private final TestInstance currentTest;\n+        private final PrintStream mainLogStream;\n+        private final PrintStream stackTraceStream;\n+        private final PrintStream extraLogStream;\n+\n+        private final boolean trace;\n+        private final boolean traceAsserts;\n+\n+        private final boolean verboseJPackage;\n+        private final boolean verboseTestSetup;\n+    }\n+\n+\n+    private static final InheritableThreadLocal<State> STATE = new InheritableThreadLocal<>() {\n+        @Override\n+        protected State initialValue() {\n+            return State.build().initDefaults().create();\n+        }\n+    };\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":312,"deletions":100,"binary":false,"changes":412,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-        if (TKit.VERBOSE_TEST_SETUP) {\n+        if (TKit.verboseTestSetup()) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-        if (TKit.VERBOSE_TEST_SETUP) {\n+        if (TKit.verboseTestSetup()) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TestMethodSupplier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n@@ -35,1 +36,0 @@\n-import java.util.HashMap;\n@@ -54,1 +54,1 @@\n-        if (Stream.of(\"--win-menu\", \"--win-shortcut\").noneMatch(cmd::hasArgument) && cmd.addLauncherNames().isEmpty()) {\n+        if (Stream.of(\"--win-menu\", \"--win-shortcut\").noneMatch(cmd::hasArgument) && cmd.addLauncherNames(true).isEmpty()) {\n@@ -173,1 +173,1 @@\n-        var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n+        var name = Optional.ofNullable(launcherName).orElseGet(cmd::mainLauncherName);\n@@ -216,1 +216,11 @@\n-            return installDir;\n+            switch (startupDirectory) {\n+                case DEFAULT -> {\n+                    return installDir;\n+                }\n+                case APP_DIR -> {\n+                    return ApplicationLayout.windowsAppImage().resolveAt(installDir).appDirectory();\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n@@ -243,1 +253,0 @@\n-        Map<String, Collection<Shortcut>> expectedShortcuts = new HashMap<>();\n@@ -247,5 +256,3 @@\n-        predefinedAppImage.map(v -> {\n-            return v.launchers().keySet().stream();\n-        }).orElseGet(() -> {\n-            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n-        }).forEach(launcherName -> {\n+        return cmd.launcherNames(true).stream().map(launcherName -> {\n+            return Optional.ofNullable(launcherName).orElseGet(cmd::mainLauncherName);\n+        }).map(launcherName -> {\n@@ -253,2 +260,4 @@\n-            if (!shortcuts.isEmpty()) {\n-                expectedShortcuts.put(launcherName, shortcuts);\n+            if (shortcuts.isEmpty()) {\n+                return null;\n+            } else {\n+                return Map.entry(launcherName, shortcuts);\n@@ -256,3 +265,1 @@\n-        });\n-\n-        return expectedShortcuts;\n+        }).filter(Objects::nonNull).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WinShortcutVerifier.java","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,0 +3,2 @@\n+lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class LinuxApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static LinuxApplicationLayout createLayout() {\n+        return LinuxApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"libapplauncher.so\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/jdk.jpackage\/jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test LinuxApplicationLayout\n+ * @requires (os.family == \"linux\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/LinuxApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.LinuxApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/linux\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.AppImageLayoutTest;\n+import jdk.jpackage.internal.model.ApplicationLayoutTest;\n+import org.junit.jupiter.api.Test;\n+\n+public class MacApplicationLayoutTest {\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    public static MacApplicationLayout createLayout() {\n+        return MacApplicationLayout.create(ApplicationLayoutTest.createLayout(),\n+                Path.of(\"Contents\/runtime\"));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/jdk.jpackage\/jdk\/jpackage\/internal\/MacApplicationLayoutTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test MacApplicationLayoutTest\n+ * @requires (os.family == \"mac\")\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/MacApplicationLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java\n+ *    ..\/..\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java\n+ * @run junit jdk.jpackage\/jdk.jpackage.internal.MacApplicationLayoutTest\n+ *\/\n","filename":"test\/jdk\/tools\/jpackage\/junit\/macosx\/junit.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class BuildEnvTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"image\"})\n+    public void testUnresolvedAppImageLayout(Path appImageDir) {\n+        final var rootDir = Path.of(\"\");\n+\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory());\n+\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @Test\n+    public void testResolvedAppImageLayout() {\n+        final var rootDir = Path.of(\"\/oof\");\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final var layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        final var env = BuildEnv.create(rootDir, Optional.empty(), true, BuildEnvTest.class, layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(Path.of(\"\/foo\/bar\"), env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertTrue(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"\/foo\/bar\"})\n+    public void test_withAppImageDir(Path appImageDir) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var layout = RuntimeLayout.DEFAULT;\n+        final var env = BuildEnv.withAppImageDir(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, layout), appImageDir);\n+\n+        assertNotSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(appImageDir, env.appImageDir());\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_withAppImageLayout(boolean resolved) {\n+        final var rootDir = Path.of(\"\/oof\");\n+\n+        final var appImageDir = Path.of(\"\/foo\/bar\");\n+\n+        final AppImageLayout layout;\n+        if (resolved) {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir);\n+        } else {\n+            layout = RuntimeLayout.DEFAULT.resolveAt(appImageDir).resetRootDirectory();\n+        }\n+\n+        final var env = BuildEnv.withAppImageLayout(BuildEnv.create(rootDir,\n+                Optional.empty(), false, BuildEnvTest.class, RuntimeLayout.DEFAULT), layout);\n+\n+        assertSame(layout, env.appImageLayout());\n+        assertEquals(env.appImageDir(), env.appImageLayout().rootDirectory());\n+\n+        assertEquals(toPathGroup(RuntimeLayout.DEFAULT.resolveAt(appImageDir)), toPathGroup(env.appImageLayout()));\n+        assertEquals(rootDir, env.buildRoot());\n+        assertEquals(rootDir.resolve(\"config\"), env.configDir());\n+        assertEquals(Optional.empty(), env.resourceDir());\n+        assertFalse(env.verbose());\n+    }\n+\n+    @Test\n+    public void test_asApplicationLayout() {\n+        final var rootDir = Path.of(\"r\");\n+\n+        assertTrue(BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, RuntimeLayout.DEFAULT).asApplicationLayout().isEmpty());\n+\n+        var layout = ApplicationLayout.build().setAll(\"foo\").create();\n+        assertSame(layout, BuildEnv.create(rootDir, Optional.empty(), false,\n+                BuildEnvTest.class, layout).asApplicationLayout().orElseThrow());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/BuildEnvTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,872 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.CopyAppImageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.NoArgTaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.TaskContext;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class PackagingPipelineTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testBuildApplication(boolean withRuntimeBuilder, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1, withRuntimeBuilder ? Optional.of(TestRuntimeBuilder.INSTANCE) : Optional.empty());\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(app).create();\n+\n+        \/\/ Build application image in `env.appImageDir()` directory.\n+        final var builder = buildPipeline();\n+        if (app.runtimeBuilder().isEmpty()) {\n+            builder.task(BuildApplicationTaskID.RUNTIME).noaction().add();\n+        }\n+\n+        builder.create().execute(env, app);\n+\n+        assertEquals(app.appImageDirName(), env.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, app);\n+        }));\n+\n+        List<TaskID> expectedActions = new ArrayList<>();\n+        if (app.runtimeBuilder().isPresent()) {\n+            expectedActions.add(BuildApplicationTaskID.RUNTIME);\n+        }\n+        expectedActions.addAll(List.of(BuildApplicationTaskID.LAUNCHERS, BuildApplicationTaskID.CONTENT));\n+\n+        assertEquals(expectedActions, executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage;\n+        if (withRuntimeBuilder) {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT)\n+                    .file(\"runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+        } else {\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(\"launchers\/my-launcher\", TestLauncher.CONTENT);\n+        }\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCopyApplication(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var srcApp = createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE);\n+\n+        final var srcEnv = buildEnv(workDir.resolve(\"build\")).appImageDirFor(srcApp).create();\n+\n+        \/\/ Build application image in `srcEnv.appImageDir()` directory.\n+        buildPipeline().create().execute(srcEnv, srcApp);\n+\n+        final var dstApp = createApp(TEST_LAYOUT_2, TestRuntimeBuilder.INSTANCE);\n+\n+        final var dstEnv = buildEnv(workDir.resolve(\"build-2\"))\n+                .appImageLayout(dstApp.imageLayout().resolveAt(workDir.resolve(\"a\/b\/c\")))\n+                .create();\n+\n+        \/\/ Copy application image from `srcEnv.appImageDir()` into `dstEnv.appImageDir()`\n+        \/\/ with layout transformation.\n+        \/\/ This test exercises flexibility of the packaging pipeline.\n+        final var builder = buildPipeline()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).applicationAction(cfg -> {\n+                    assertSame(dstApp, cfg.app());\n+                    assertEquals(dstEnv.appImageDir(), cfg.env().appImageLayout().rootDirectory());\n+                    assertFalse(Files.exists(dstEnv.appImageDir()));\n+                    PackagingPipeline.copyAppImage(srcEnv.appImageLayout(), cfg.env().appImageLayout(), false);\n+                }).add();\n+\n+        \/\/ Disable the default \"build application image\" actions of the tasks which\n+        \/\/ are the dependencies of `PrimaryTaskID.BUILD_APPLICATION_IMAGE` task as\n+        \/\/ their output will be overwritten in the custom action of this task.\n+        builder.taskGraphSnapshot().getAllTailsOf(PrimaryTaskID.BUILD_APPLICATION_IMAGE).forEach(taskId -> {\n+            builder.task(taskId).noaction().add();\n+        });\n+\n+        builder.create().execute(dstEnv, dstApp);\n+\n+        AppImageLayout.toPathGroup(dstEnv.appImageLayout()).paths().forEach(path -> {\n+            assertTrue(Files.exists(path));\n+        });\n+\n+        assertEquals(Path.of(\"c\"), dstEnv.appImageDir().getFileName());\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dstEnv, dstApp);\n+        }));\n+\n+        assertEquals(List.of(PrimaryTaskID.BUILD_APPLICATION_IMAGE), executedTaskActions);\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(\"q\/launchers\/my-launcher\", TestLauncher.CONTENT)\n+                .file(\"qqq\/runtime\/my-runtime\", TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(dstEnv.appImageDir()));\n+    }\n+\n+    @Test\n+    void testCreatePackage(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = buildEnv(workDir.resolve(\"build\")).appImageDirFor(pkg).create();\n+\n+        final var builder = buildPipeline();\n+\n+        \/\/ Will create an app image in `env.appImageDir()` directory with `pkg.appImageLayout()` layout.\n+        \/\/ Will convert the created app image into a package.\n+        builder.create().execute(env, pkg, outputDir);\n+\n+        final var expected = createTestPackageFileContents(env.appImageLayout());\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"testCreatePackage:\\n---\\n%s\\n---\", actual));\n+\n+        var executedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(env, pkg, outputDir);\n+        }));\n+\n+        assertEquals(List.of(\n+                BuildApplicationTaskID.RUNTIME,\n+                BuildApplicationTaskID.LAUNCHERS,\n+                BuildApplicationTaskID.CONTENT,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE\n+        ), executedTaskActions);\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(env.appImageDir()));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testCreateRuntimeInstaller(boolean transformLayout, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final AppImageLayout srcLayout;\n+        if (transformLayout) {\n+            \/\/ Create an application layout such that the runtime directory doesn't\n+            \/\/ have a common parent with other directories otherwise the runtime directory\n+            \/\/ will be skipped when copying the app image layout as path groups because\n+            \/\/ the destination app image layout is of type RuntimeLayout and have only\n+            \/\/ the runtime directory.\n+            srcLayout = ApplicationLayout.build()\n+                    .launchersDirectory(\"launchers\")\n+                    .appDirectory(\"lib\")\n+                    .runtimeDirectory(\"runtime\")\n+                    .appModsDirectory(\"lib\")\n+                    .contentDirectory(\"lib\")\n+                    .desktopIntegrationDirectory(\"lib\")\n+                    .create();\n+        } else {\n+            srcLayout = RuntimeLayout.DEFAULT;\n+        }\n+\n+        \/\/ Create a runtime image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(srcLayout)\n+                .appImageDir(workDir.resolve(\"rt\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+\n+        final var pipeline = buildPackage(createApp(\n+                RuntimeLayout.DEFAULT.resolveAt(TEST_INSTALL_DIR).resetRootDirectory())).create();\n+\n+        final var expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(TEST_INSTALL_DIR.resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+\n+        createAndVerifyPackage(buildPipeline(), pipeline, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreateRuntimeInstaller(%s)\", transformLayout), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    private enum ExternalAppImageMode {\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant equals to `Package.appImageLayout()`.\n+        COPY_FROM_BUILD_ENV,\n+\n+        \/\/ Copy predefined app image from some directory.\n+        \/\/ Layout of the predefined app image is `Package.appImageLayout()`.\n+        COPY,\n+\n+        \/\/ Copy predefined app image from `BuildEnv.appImageDir()`.\n+        \/\/ Layout of the predefined app image is `BuildEnv.appImageLayout()` and\n+        \/\/ its unresolved variant is NOT equal to `Package.appImageLayout()`.\n+        TRANSFORM_FROM_BUILD_ENV,\n+        ;\n+\n+        static final Set<ExternalAppImageMode> FROM_BUILD_ENV = Set.of(\n+                COPY_FROM_BUILD_ENV, TRANSFORM_FROM_BUILD_ENV);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ExternalAppImageMode.class)\n+    void testCreatePackageFromExternalAppImage(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout;\n+        final ExpectedAppImage expectedAppImage;\n+        if (ExternalAppImageMode.TRANSFORM_FROM_BUILD_ENV == mode) {\n+            appLayout = TEST_LAYOUT_2_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"q\/launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"qqq\/runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        } else {\n+            appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+            expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                    .file(TEST_INSTALL_DIR.resolve(\"launchers\/my-launcher\"), TestLauncher.CONTENT)\n+                    .file(TEST_INSTALL_DIR.resolve(\"runtime\/my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        }\n+\n+        final BuildEnv env;\n+        final Path predefinedAppImage;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImage = env.appImageDir();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            final var externalAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(externalAppImageLayout);\n+            TestLauncher.INSTANCE.create(externalAppImageLayout);\n+            predefinedAppImage = externalAppImageLayout.rootDirectory();\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImage)\n+                .create();\n+\n+        createAndVerifyPackage(buildPipeline(), pkg, env, workDir.resolve(\"bundles\"),\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), expectedAppImage,\n+                CopyAppImageTaskID.COPY,\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names={\"COPY\", \"COPY_FROM_BUILD_ENV\"})\n+    void testCreatePackageFromExternalAppImageNoCopyAction(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final ApplicationLayout appLayout = TEST_LAYOUT_1_WITH_INSTALL_DIR;\n+\n+        final BuildEnv env;\n+        final ApplicationLayout predefinedAppImageLayout;\n+        if (ExternalAppImageMode.FROM_BUILD_ENV.contains(mode)) {\n+            \/\/ External app image is stored in the build env app image directory.\n+            env = setupBuildEnvForExternalAppImage(workDir);\n+            predefinedAppImageLayout = env.asApplicationLayout().orElseThrow();\n+        } else {\n+            \/\/ External app image is stored outside of the build env app image directory\n+            \/\/ and should have the same layout as the app's app image layout.\n+            env = buildEnv(workDir.resolve(\"build\"))\n+                    .appImageDir(workDir)\n+                    \/\/ Always need some app image layout.\n+                    .appImageLayout(new AppImageLayout.Stub(Path.of(\"\")))\n+                    .create();\n+            predefinedAppImageLayout = appLayout.resolveAt(workDir.resolve(\"app-image\"));\n+            TestRuntimeBuilder.INSTANCE.create(predefinedAppImageLayout);\n+            TestLauncher.INSTANCE.create(predefinedAppImageLayout);\n+        }\n+\n+        final var pkg = buildPackage(createApp(appLayout))\n+                .predefinedAppImage(predefinedAppImageLayout.rootDirectory())\n+                .create();\n+\n+        final var outputDir = workDir.resolve(\"bundles\");\n+\n+        final var builder = buildPipeline().configuredTasks().filter(task -> {\n+            return CopyAppImageTaskID.COPY.equals(task.task());\n+        }).findFirst().orElseThrow().noaction().add();\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        builder.create().execute(startupParameters);\n+\n+        final var expected = createTestPackageFileContents(predefinedAppImageLayout);\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\",\n+                String.format(\"testCreatePackageFromExternalAppImage(%s)\", mode), actual));\n+\n+        final ExpectedAppImage expectedAppImage = ExpectedAppImage.build().dir(\"\")\n+                .file(predefinedAppImageLayout.unresolve().launchersDirectory().resolve(\"my-launcher\"), TestLauncher.CONTENT)\n+                .file(predefinedAppImageLayout.unresolve().runtimeDirectory().resolve(\"my-runtime\"), TestRuntimeBuilder.CONTENT);\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(pkg.predefinedAppImage().orElseThrow()));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+        assertEquals(List.of(\n+                PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT,\n+                PrimaryTaskID.PACKAGE), actualExecutedTaskActions);\n+    }\n+\n+    @Test\n+    void testCreatePackageFromExternalAppImageWithoutExternalAppImageError(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+\n+        final var env = setupBuildEnvForExternalAppImage(workDir);\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1_WITH_INSTALL_DIR)).create();\n+        final var pipeline = buildPipeline().create();\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, pkg, workDir));\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_RuntimeException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new RuntimeException(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_PackagerException() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new PackagerException(\"param.vendor.default\");\n+        final var ex = testExceptionRethrow(expectedException, expectedException.getClass(), () -> {\n+            throw expectedException;\n+        });\n+        assertSame(expectedException, ex);\n+    }\n+\n+    @Test\n+    void testExceptionRethrow_Exception() throws ConfigException, PackagerException, IOException {\n+\n+        final var expectedException = new Exception(\"foo\");\n+        final var ex = testExceptionRethrow(expectedException, PackagerException.class, () -> {\n+            rethrowUnchecked(expectedException);\n+        });\n+        assertSame(expectedException, ex.getCause());\n+    }\n+\n+    @Test\n+    void testAppImageAction() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).appImageAction(ctx -> {\n+                    assertSame(app, ctx.app());\n+                    assertSame(env, ctx.env());\n+                    executed[0] = true;\n+                }).add().create().execute(env, app);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testAppImageActionWithPackage() throws PackagerException, IOException {\n+\n+        final var pkg = buildPackage(createApp(TEST_LAYOUT_1, TestRuntimeBuilder.INSTANCE)).create();\n+        final var env = dummyBuildEnv();\n+\n+        final var executed = new boolean[1];\n+\n+        final var builder = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.PACKAGE).add();\n+\n+        final var startupParameters = builder.createStartupParameters(env,  pkg,  Path.of(\"\"));\n+\n+        builder.task(PrimaryTaskID.PACKAGE).appImageAction(ctx -> {\n+            assertSame(pkg.app(), ctx.app());\n+            assertSame(startupParameters.packagingEnv(), ctx.env());\n+            executed[0] = true;\n+        }).add().create().execute(startupParameters);\n+\n+        assertTrue(executed[0]);\n+    }\n+\n+    @Test\n+    void testPackageActionWithApplication() throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        final var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).packageAction(ctx -> {\n+                    throw new AssertionError();\n+                }).add().create();\n+\n+        \/\/ If the pipeline is building an application, it can not execute actions that take a package as an argument.\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> pipeline.execute(env, app));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    void testContextMapper(boolean allowAll) throws PackagerException, IOException {\n+\n+        var builder = PackagingPipeline.buildStandard().contextMapper(ctx -> {\n+            return new TaskContext() {\n+                @Override\n+                public boolean test(TaskID task) {\n+                    return allowAll;\n+                }\n+\n+                @Override\n+                public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+                    if (!allowAll) {\n+                        throw new AssertionError();\n+                    }\n+                    ctx.execute(taskAction);\n+                }\n+            };\n+        });\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(dummyBuildEnv(), createApp(TEST_LAYOUT_1));\n+        }));\n+\n+        List<TaskID> expectedExecutedTaskActions;\n+\n+        if (allowAll) {\n+            expectedExecutedTaskActions = List.of(\n+                    BuildApplicationTaskID.RUNTIME,\n+                    BuildApplicationTaskID.LAUNCHERS,\n+                    BuildApplicationTaskID.CONTENT,\n+                    BuildApplicationTaskID.APP_IMAGE_FILE,\n+                    CopyAppImageTaskID.COPY,\n+                    PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT);\n+        } else {\n+            expectedExecutedTaskActions = List.of();\n+        }\n+\n+        assertEquals(expectedExecutedTaskActions, actualExecutedTaskActions);\n+    }\n+\n+    public static List<PackagingPipeline.TaskID> dryRun(PackagingPipeline.Builder builder,\n+            Consumer<PackagingPipeline.Builder> callback) {\n+\n+        List<PackagingPipeline.TaskID> executedTaskActions = new ArrayList<>();\n+        builder.configuredTasks().filter(PackagingPipeline.Builder.TaskBuilder::hasAction).forEach(taskBuilder -> {\n+            var taskId = taskBuilder.task();\n+            taskBuilder.action(() -> {\n+                executedTaskActions.add(taskId);\n+            }).add();\n+        });\n+\n+        callback.accept(builder);\n+\n+        return executedTaskActions;\n+    }\n+\n+    private static Exception testExceptionRethrow(Exception expectedException,\n+            Class<? extends Exception> expectedCatchExceptionType,\n+            NoArgTaskAction throwAction) throws PackagerException, IOException {\n+\n+        final var app = createApp(TEST_LAYOUT_1);\n+        final var env = dummyBuildEnv();\n+\n+        var pipeline = PackagingPipeline.build()\n+                \/\/ The pipleline must have at least two tasks, add a dummy.\n+                .task(new TaskID() {}).addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add()\n+                .task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).action(throwAction).add().create();\n+\n+        return assertThrowsExactly(expectedCatchExceptionType, () -> pipeline.execute(env,  app));\n+    }\n+\n+    private static BuildEnv setupBuildEnvForExternalAppImage(Path workDir) throws ConfigException {\n+        \/\/ Create an app image in `env.appImageDir()` directory.\n+        final var env = buildEnv(workDir.resolve(\"build\"))\n+                .appImageLayout(TEST_LAYOUT_1.resolveAt(Path.of(\"a\/b\/c\")).resetRootDirectory())\n+                .appImageDir(workDir.resolve(\"app-image\"))\n+                .create();\n+        TestRuntimeBuilder.INSTANCE.create(env.appImageLayout());\n+        TestLauncher.INSTANCE.create((ApplicationLayout)env.appImageLayout());\n+\n+        return env;\n+    }\n+\n+    private static void createAndVerifyPackage(PackagingPipeline.Builder builder, Package pkg,\n+            BuildEnv env, Path outputDir, String logMsgHeader, ExpectedAppImage expectedAppImage,\n+            TaskID... expectedExecutedTaskActions) throws PackagerException, IOException {\n+        Objects.requireNonNull(logMsgHeader);\n+\n+        final var startupParameters = builder.createStartupParameters(env, pkg, outputDir);\n+\n+        assertNotSameAppImageDirs(env, startupParameters.packagingEnv());\n+\n+        \/\/ Will create an app image in `startupParameters.packagingEnv().appImageDir()` directory\n+        \/\/ with `pkg.appImageLayout()` layout using an app image (runtime image) from `env.appImageDir()` as input.\n+        \/\/ Will convert the created app image into a package.\n+        \/\/ Will not overwrite the contents of `env.appImageDir()` directory.\n+        builder.create().execute(startupParameters);\n+\n+        final var packagingAppImageDir = startupParameters.packagingEnv().appImageDir();\n+\n+        final var expected = createTestPackageFileContents(pkg.appImageLayout().resolveAt(packagingAppImageDir));\n+\n+        final var actual = Files.readString(outputDir.resolve(pkg.packageFileNameWithSuffix()));\n+\n+        assertEquals(expected, actual);\n+        System.out.println(String.format(\"%s:\\n---\\n%s\\n---\", logMsgHeader, actual));\n+\n+        assertEquals(expectedAppImage, ExpectedAppImage.load(packagingAppImageDir));\n+\n+        var actualExecutedTaskActions = dryRun(builder, toConsumer(_ -> {\n+            builder.create().execute(startupParameters);\n+        }));\n+\n+        assertEquals(List.of(expectedExecutedTaskActions), actualExecutedTaskActions);\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout) {\n+        return createApp(appImageLayout, Optional.empty());\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, RuntimeBuilder runtimeBuilder) {\n+        return createApp(appImageLayout, Optional.of(runtimeBuilder));\n+    }\n+\n+    private static Application createApp(AppImageLayout appImageLayout, Optional<RuntimeBuilder> runtimeBuilder) {\n+        Objects.requireNonNull(appImageLayout);\n+        Objects.requireNonNull(runtimeBuilder);\n+        if (appImageLayout.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new Application.Stub(\n+                \"foo\",\n+                \"My app\",\n+                \"1.0\",\n+                \"Acme\",\n+                \"copyright\",\n+                Optional.empty(),\n+                List.of(),\n+                appImageLayout,\n+                runtimeBuilder,\n+                List.of(),\n+                Map.of());\n+    }\n+\n+\n+    private static final class PackageBuilder {\n+        PackageBuilder(Application app) {\n+            this.app = Objects.requireNonNull(app);\n+        }\n+\n+        Package create() {\n+            return new Package.Stub(\n+                    app,\n+                    new PackageType() {},\n+                    \"the-package\",\n+                    \"My package\",\n+                    \"1.0\",\n+                    Optional.empty(),\n+                    Optional.empty(),\n+                    Optional.ofNullable(predefinedAppImage),\n+                    null,\n+                    TEST_INSTALL_DIR);\n+        }\n+\n+        PackageBuilder predefinedAppImage(Path v) {\n+            predefinedAppImage = v;\n+            return this;\n+        }\n+\n+        private Path predefinedAppImage;\n+        private final Application app;\n+    }\n+\n+\n+    private static PackageBuilder buildPackage(Application app) {\n+        return new PackageBuilder(app);\n+    }\n+\n+    private static BuildEnvBuilder buildEnv(Path rootDir) {\n+        return new BuildEnvBuilder(rootDir);\n+    }\n+\n+    private static BuildEnv dummyBuildEnv() {\n+        return BuildEnv.create(Path.of(\"foo\"), Optional.empty(), false, PackagingPipeline.class, RuntimeLayout.DEFAULT);\n+    }\n+\n+    private static PackagingPipeline.Builder buildPipeline() {\n+        return PackagingPipeline.buildStandard()\n+                \/\/ Disable building the app image file (.jpackage.xml) as we don't have launchers in the test app.\n+                .task(BuildApplicationTaskID.APP_IMAGE_FILE).noaction().add()\n+                .task(BuildApplicationTaskID.LAUNCHERS).applicationAction(cfg -> {\n+                    TestLauncher.INSTANCE.create(cfg.resolvedLayout());\n+                }).add()\n+                .task(PrimaryTaskID.PACKAGE).packageAction(cfg -> {\n+                    var str = createTestPackageFileContents(cfg.resolvedLayout());\n+                    var packageFile = cfg.outputDir().resolve(cfg.pkg().packageFileNameWithSuffix());\n+                    Files.createDirectories(packageFile.getParent());\n+                    Files.writeString(packageFile, str);\n+                }).add();\n+    }\n+\n+    private static String createTestPackageFileContents(AppImageLayout pkgLayout) throws IOException {\n+        return ExpectedAppImage.load(pkgLayout.rootDirectory()).toString();\n+    }\n+\n+    private static void assertNotSameAppImageDirs(BuildEnv a, BuildEnv b) {\n+        assertNotEquals(a.appImageDir(), b.appImageDir());\n+        assertEquals(a.buildRoot(), b.buildRoot());\n+        assertEquals(a.configDir(), b.configDir());\n+        assertEquals(a.resourceDir(), b.resourceDir());\n+    }\n+\n+\n+    private static final class TestRuntimeBuilder implements RuntimeBuilder {\n+        @Override\n+        public void create(AppImageLayout appImageLayout) {\n+            assertTrue(appImageLayout.isResolved());\n+            try {\n+                Files.createDirectories(appImageLayout.runtimeDirectory());\n+                Files.writeString(runtimeFile(appImageLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path runtimeFile(AppImageLayout appImageLayout) {\n+            return appImageLayout.runtimeDirectory().resolve(\"my-runtime\");\n+        }\n+\n+        static final String CONTENT = \"this is the runtime\";\n+\n+        static final TestRuntimeBuilder INSTANCE = new TestRuntimeBuilder();\n+    }\n+\n+\n+    private static final class TestLauncher {\n+        public void create(ApplicationLayout appLayout) {\n+            assertTrue(appLayout.isResolved());\n+            try {\n+                Files.createDirectories(appLayout.launchersDirectory());\n+                Files.writeString(launcherFile(appLayout), CONTENT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+\n+        private static Path launcherFile(ApplicationLayout appLayout) {\n+            return appLayout.launchersDirectory().resolve(\"my-launcher\");\n+        }\n+\n+        static final String CONTENT = \"this is the launcher\";\n+\n+        static final TestLauncher INSTANCE = new TestLauncher();\n+    }\n+\n+\n+    private static final class ExpectedAppImage {\n+\n+        static ExpectedAppImage build() {\n+            return new ExpectedAppImage(new HashSet<>());\n+        }\n+\n+        static ExpectedAppImage load(Path appImageRoot) throws IOException {\n+            try (var walk = Files.walk(appImageRoot)) {\n+                return new ExpectedAppImage(walk.sorted().map(path -> {\n+                    var relativePath = appImageRoot.relativize(path);\n+                    if (Files.isDirectory(path)) {\n+                        return new Directory(relativePath);\n+                    } else {\n+                        return new File(relativePath, toSupplier(() -> Files.readString(path)).get());\n+                    }\n+                }).collect(Collectors.toSet()));\n+            }\n+        }\n+\n+        ExpectedAppImage file(Path path, String content) {\n+            return add(new File(path, content));\n+        }\n+\n+        ExpectedAppImage file(String path, String content) {\n+            return file(Path.of(path), content);\n+        }\n+\n+        ExpectedAppImage dir(Path path) {\n+            return add(new Directory(path));\n+        }\n+\n+        ExpectedAppImage dir(String path) {\n+            return dir(Path.of(path));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return items.stream().map(AppImageItem::toString).sorted().collect(Collectors.joining(\"\\n\"));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(items);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if ((obj == null) || (getClass() != obj.getClass())) {\n+                return false;\n+            }\n+            ExpectedAppImage other = (ExpectedAppImage) obj;\n+            return Objects.equals(items, other.items);\n+        }\n+\n+        private ExpectedAppImage(Set<AppImageItem> items) {\n+            this.items = Objects.requireNonNull(items);\n+        }\n+\n+        private ExpectedAppImage add(AppImageItem v) {\n+            var path = v.path();\n+            if (path.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            items.add(v);\n+            while (path.getNameCount() > 1) {\n+                items.add(new Directory(path = path.getParent()));\n+            }\n+            return this;\n+        }\n+\n+        private interface AppImageItem {\n+            Path path();\n+        }\n+\n+        private record File(Path path, String content) implements AppImageItem {\n+\n+            File {\n+                Objects.requireNonNull(path);\n+                Objects.requireNonNull(content);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return String.format(\"%s[%s]\", path, content);\n+            }\n+        }\n+\n+        private record Directory(Path path) implements AppImageItem {\n+\n+            Directory {\n+                Objects.requireNonNull(path);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return path.toString();\n+            }\n+        }\n+\n+        private final Set<AppImageItem> items;\n+    }\n+\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1 = ApplicationLayout.build()\n+            .launchersDirectory(\"launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2 = ApplicationLayout.build()\n+            .launchersDirectory(\"q\/launchers\")\n+            .appDirectory(\"\")\n+            .runtimeDirectory(\"qqq\/runtime\")\n+            .appModsDirectory(\"\")\n+            .contentDirectory(\"\")\n+            .desktopIntegrationDirectory(\"\")\n+            .create();\n+\n+    private static final Path TEST_INSTALL_DIR = Path.of(\"Acme\/My app\");\n+\n+    private static final ApplicationLayout TEST_LAYOUT_1_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_1.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+\n+    private static final ApplicationLayout TEST_LAYOUT_2_WITH_INSTALL_DIR =\n+            TEST_LAYOUT_2.resolveAt(TEST_INSTALL_DIR).resetRootDirectory();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":872,"deletions":0,"binary":false,"changes":872,"status":"added"},{"patch":"@@ -26,4 +26,1 @@\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.model.ConfigException;\n-import java.nio.file.Path;\n-import jdk.internal.util.OperatingSystem;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -33,0 +30,10 @@\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.DottedVersion;\n@@ -34,0 +41,4 @@\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -38,3 +49,4 @@\n-    @Test\n-    public void testAvailable() {\n-        assertNull(new ToolValidator(TOOL_JAVA).validate());\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testAvailable(boolean checkExistsOnly) {\n+        assertNull(new ToolValidator(TOOL_JAVA).checkExistsOnly(checkExistsOnly).validate());\n@@ -44,2 +56,98 @@\n-    public void testNotAvailable() {\n-        assertValidationFailure(new ToolValidator(TOOL_UNKNOWN).validate(), true);\n+    public void testAvailable_setCommandLine() {\n+        \/\/ java doesn't recognize \"--foo\" command line option, but the validation will\n+        \/\/ still pass as there is no minimal version specified and the validator ignores\n+        \/\/ the exit code\n+        assertNull(new ToolValidator(TOOL_JAVA).setCommandLine(\"--foo\").validate());\n+    }\n+\n+    enum TestAvailableMode {\n+        NO_VERSION(null),\n+        TOO_OLD(\"0.9\"),\n+        EQUALS(\"1.0\"),\n+        NEWER(\"1.1\");\n+\n+        TestAvailableMode(String parsedVersion) {\n+            this.parsedVersion = parsedVersion;\n+        }\n+\n+        final String parsedVersion;\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestAvailableMode.class)\n+    public void testAvailable(TestAvailableMode mode) {\n+        var minVer = TestAvailableMode.EQUALS.parsedVersion;\n+        var err = new ToolValidator(TOOL_JAVA).setVersionParser(lines -> {\n+            return mode.parsedVersion;\n+        }).setMinimalVersion(DottedVersion.greedy(minVer)).validate();\n+\n+        if (Set.of(TestAvailableMode.NO_VERSION, TestAvailableMode.TOO_OLD).contains(mode)) {\n+            var expectedMessage = I18N.format(\"error.tool-old-version\", TOOL_JAVA, minVer);\n+            var expectedAdvice = I18N.format(\"error.tool-old-version.advice\", TOOL_JAVA, minVer);\n+\n+            assertEquals(expectedMessage, err.getMessage());\n+            assertEquals(expectedAdvice, err.getAdvice());\n+        } else {\n+            assertNull(err);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestAvailableMode.class)\n+    public void testAvailable_setToolOldVersionErrorHandler(TestAvailableMode mode) {\n+        var handler = new ToolOldVersionErrorHandler();\n+        var minVer = TestAvailableMode.EQUALS.parsedVersion;\n+        var err = new ToolValidator(TOOL_JAVA).setVersionParser(lines -> {\n+            return mode.parsedVersion;\n+        }).setMinimalVersion(DottedVersion.greedy(minVer)).setToolOldVersionErrorHandler(handler).validate();\n+\n+        if (Set.of(TestAvailableMode.NO_VERSION, TestAvailableMode.TOO_OLD).contains(mode)) {\n+            assertSame(ToolOldVersionErrorHandler.ERR, err);\n+            handler.verifyCalled(Path.of(TOOL_JAVA), mode.parsedVersion);\n+        } else {\n+            assertNull(err);\n+            handler.verifyNotCalled();\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testNotAvailable(boolean checkExistsOnly, @TempDir Path dir) {\n+        var err = new ToolValidator(dir.resolve(\"foo\")).checkExistsOnly(checkExistsOnly).validate();\n+        if (checkExistsOnly) {\n+            assertValidationFailure(err, false);\n+        } else {\n+            assertValidationFailureNoAdvice(err, !checkExistsOnly);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testToolIsDirectory(boolean checkExistsOnly, @TempDir Path dir) {\n+        var err = new ToolValidator(dir).checkExistsOnly(checkExistsOnly).validate();\n+        assertValidationFailureNoAdvice(err, !checkExistsOnly);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testNotAvailable_setToolNotFoundErrorHandler(boolean checkExistsOnly, @TempDir Path dir) {\n+        var handler = new ToolNotFoundErrorHandler();\n+        var err = new ToolValidator(dir.resolve(\"foo\")).checkExistsOnly(checkExistsOnly)\n+                .setToolNotFoundErrorHandler(handler)\n+                .validate();\n+        if (checkExistsOnly) {\n+            handler.verifyCalled(dir.resolve(\"foo\"));\n+            assertSame(ToolNotFoundErrorHandler.ERR, err);\n+        } else {\n+            handler.verifyNotCalled();\n+            assertValidationFailureNoAdvice(err, !checkExistsOnly);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testToolIsDirectory_setToolNotFoundErrorHandler(boolean checkExistsOnly, @TempDir Path dir) {\n+        var handler = new ToolNotFoundErrorHandler();\n+        var err = new ToolValidator(dir).checkExistsOnly(checkExistsOnly).validate();\n+        handler.verifyNotCalled();\n+        assertValidationFailureNoAdvice(err, !checkExistsOnly);\n@@ -52,1 +160,1 @@\n-            throw new RuntimeException();\n+            throw new AssertionError();\n@@ -84,0 +192,61 @@\n+    private static void assertValidationFailureNoAdvice(ConfigException v, boolean withCause) {\n+        assertNotNull(v);\n+        assertNotEquals(\"\", v.getMessage().strip());\n+        assertNull(v.getAdvice());\n+        if (withCause) {\n+            assertNotNull(v.getCause());\n+        } else {\n+            assertNull(v.getCause());\n+        }\n+    }\n+\n+\n+    private static final class ToolNotFoundErrorHandler implements Function<Path, ConfigException> {\n+\n+        @Override\n+        public ConfigException apply(Path tool) {\n+            assertNotNull(tool);\n+            this.tool = tool;\n+            return ERR;\n+        }\n+\n+        void verifyCalled(Path expectedTool) {\n+            assertEquals(Objects.requireNonNull(expectedTool), tool);\n+        }\n+\n+        void verifyNotCalled() {\n+            assertNull(tool);\n+        }\n+\n+        private Path tool;\n+\n+        static final ConfigException ERR = new ConfigException(\"no tool\", \"install the tool\");\n+    }\n+\n+\n+    private static final class ToolOldVersionErrorHandler implements BiFunction<Path, String, ConfigException> {\n+\n+        @Override\n+        public ConfigException apply(Path tool, String parsedVersion) {\n+            assertNotNull(tool);\n+            this.tool = tool;\n+            this.parsedVersion = parsedVersion;\n+            return ERR;\n+        }\n+\n+        void verifyCalled(Path expectedTool, String expectedParsedVersion) {\n+            assertEquals(Objects.requireNonNull(expectedTool), tool);\n+            assertEquals(expectedParsedVersion, parsedVersion);\n+        }\n+\n+        void verifyNotCalled() {\n+            assertNull(tool);\n+        }\n+\n+        private Path tool;\n+        private String parsedVersion;\n+\n+        static final ConfigException ERR = new ConfigException(\"tool too old\", \"install the newer version\");\n+    }\n+\n+\n@@ -85,2 +254,0 @@\n-    private static final String TOOL_UNKNOWN = Path.of(System.getProperty(\n-            \"java.home\"), \"bin\").toString();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/ToolValidatorTest.java","additions":179,"deletions":12,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.model.AppImageLayout.toPathGroup;\n@@ -27,1 +28,1 @@\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n@@ -32,0 +33,1 @@\n+import jdk.jpackage.internal.util.PathGroup;\n@@ -51,1 +53,1 @@\n-        final var pathGroup = AppImageLayout.toPathGroup(layout);\n+        final var pathGroup = toPathGroup(layout);\n@@ -59,1 +61,28 @@\n-        final var dir = Path.of(\"foo\/bar\");\n+        testResolveAt(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        testResolveAtRepeat(new AppImageLayout.Stub(Path.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        testUnresolve(new AppImageLayout.Stub(Path.of(\"runtime\")));\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        testEmptyRootDirectory(new AppImageLayout.Stub(Path.of(\"rt\")));\n+    }\n+\n+    public static void testResolveAt(AppImageLayout testee) {\n+\n+        var dir = Path.of(\"foo\/bar\");\n+\n+        assertLayout(testee.resolveAt(dir), true, testee, dir);\n+    }\n+\n+    public static void testResolveAtRepeat(AppImageLayout testee) {\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"b\/c\")).resolveAt(Path.of(\"a\"));\n@@ -61,1 +90,20 @@\n-        final var layout = new AppImageLayout.Stub(Path.of(\"\"), Path.of(\"runtime\"));\n+        assertLayout(resolvedLayout, true, testee, Path.of(\"a\/b\/c\"));\n+    }\n+\n+    public static void testUnresolve(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        var resolvedLayout = testee.resolveAt(Path.of(\"foo\/bar\"));\n+        var layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        resolvedLayout = testee.resolveAt(Path.of(\"\").toAbsolutePath());\n+        layout = resolvedLayout.unresolve();\n+\n+        assertLayout(layout, false, testee, Path.of(\"\"));\n+\n+        assertSame(testee, testee.unresolve());\n+    }\n@@ -63,1 +111,4 @@\n-        final var resolvedLayout = layout.resolveAt(dir);\n+    public static void testEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            throw new IllegalArgumentException();\n+        }\n@@ -65,1 +116,1 @@\n-        assertNotSame(layout, resolvedLayout);\n+        assertEmptyRootDirectory(testee);\n@@ -67,2 +118,25 @@\n-        assertEquals(dir.resolve(layout.rootDirectory()), resolvedLayout.rootDirectory());\n-        assertEquals(dir.resolve(layout.runtimeDirectory()), resolvedLayout.runtimeDirectory());\n+        final var resolved = testee.resolveAt(Path.of(\"t\"));\n+\n+        assertEmptyRootDirectory(resolved);\n+    }\n+\n+    private static void assertEmptyRootDirectory(AppImageLayout testee) {\n+        if (testee.isResolved()) {\n+            var newLayout = testee.resetRootDirectory();\n+            assertLayout(newLayout, false, Path.of(\"\"), toPathGroup(testee));\n+        } else {\n+            assertSame(testee, testee.resetRootDirectory());\n+        }\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            AppImageLayout base, Path baseResolveAt) {\n+        assertLayout(actual, expectedResolved, baseResolveAt.resolve(base.rootDirectory()),\n+                toPathGroup(base).resolveAt(baseResolveAt));\n+    }\n+\n+    private static void assertLayout(AppImageLayout actual, boolean expectedResolved,\n+            Path expectedRootDir, PathGroup expectedPaths) {\n+        assertEquals(expectedResolved, actual.isResolved());\n+        assertEquals(expectedRootDir, actual.rootDirectory());\n+        assertEquals(expectedPaths, toPathGroup(actual));\n@@ -70,0 +144,1 @@\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java","additions":83,"deletions":8,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n@@ -31,2 +34,0 @@\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -39,1 +40,31 @@\n-    public void test(boolean move, Path tempDir) throws IOException {\n+    @Test\n+    public void testMove(@TempDir Path tempDir) throws IOException {\n+        test(true, tempDir);\n+    }\n+\n+    @Test\n+    public void testCopy(@TempDir Path tempDir) throws IOException {\n+        test(false, tempDir);\n+    }\n+\n+    @Test\n+    public void testResolveAt() {\n+        AppImageLayoutTest.testResolveAt(createLayout());\n+    }\n+\n+    @Test\n+    public void testResolveAtRepeat() {\n+        AppImageLayoutTest.testResolveAtRepeat(createLayout());\n+    }\n+\n+    @Test\n+    public void testUnresolve() {\n+        AppImageLayoutTest.testUnresolve(createLayout());\n+    }\n+\n+    @Test\n+    public void testEmptyRootDirectory() {\n+        AppImageLayoutTest.testEmptyRootDirectory(createLayout());\n+    }\n+\n+    private static void test(boolean move, Path tempDir) throws IOException {\n@@ -58,8 +89,1 @@\n-        final var layout = ApplicationLayout.build()\n-                .launchersDirectory(\"bin\")\n-                .appDirectory(\"lib\/app\")\n-                .runtimeDirectory(\"runtime\")\n-                .appModsDirectory(\"mods\")\n-                .contentDirectory(\"content\")\n-                .desktopIntegrationDirectory(\"lib\/apps\")\n-                .create();\n+        final var layout = createLayout();\n@@ -103,8 +127,9 @@\n-    @Test\n-    public void testMove(@TempDir Path tempDir) throws IOException {\n-        test(true, tempDir);\n-    }\n-\n-    @Test\n-    public void testCopy(@TempDir Path tempDir) throws IOException {\n-        test(false, tempDir);\n+    public static ApplicationLayout createLayout() {\n+        return ApplicationLayout.build()\n+                .launchersDirectory(\"bin\")\n+                .appDirectory(\"lib\/app\")\n+                .runtimeDirectory(\"runtime\")\n+                .appModsDirectory(\"mods\")\n+                .contentDirectory(\"content\")\n+                .desktopIntegrationDirectory(\"lib\/apps\")\n+                .create();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java","additions":44,"deletions":19,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class FileUtilsTest {\n+\n+    @ParameterizedTest\n+    @EnumSource(ExcludeType.class)\n+    public void test_copyRecursive_dir(ExcludeType exclude, @TempDir Path workdir) throws IOException {\n+        Files.createDirectories(workdir.resolve(\"from\/foo\/bar\"));\n+        Files.createDirectories(workdir.resolve(\"from\/foo\/buz\"));\n+        Files.writeString(workdir.resolve(\"from\/foo\/bar\/file.txt\"), \"Hello\");\n+\n+        List<Path> excludes = new ArrayList<>();\n+        switch (exclude) {\n+            case EXCLUDE_FILE -> {\n+                excludes.add(Path.of(\"file.txt\"));\n+            }\n+            case EXCLUDE_DIR -> {\n+                excludes.add(Path.of(\"bar\"));\n+            }\n+            case EXCLUDE_SUBDIR -> {\n+                excludes.add(Path.of(\"foo\"));\n+            }\n+            case EXCLUDE_NONE -> {\n+            }\n+        }\n+\n+        FileUtils.copyRecursive(workdir.resolve(\"from\"), workdir.resolve(\"to\"), excludes);\n+\n+        assertEquals(\"Hello\", Files.readString(workdir.resolve(\"from\/foo\/bar\/file.txt\")));\n+\n+        switch (exclude) {\n+            case EXCLUDE_FILE -> {\n+                assertFalse(Files.exists(workdir.resolve(\"to\/foo\/bar\/file.txt\")));\n+                assertTrue(Files.isDirectory(workdir.resolve(\"to\/foo\/bar\")));\n+            }\n+            case EXCLUDE_DIR -> {\n+                assertFalse(Files.exists(workdir.resolve(\"to\/foo\/bar\")));\n+                assertTrue(Files.isDirectory(workdir.resolve(\"to\/foo\/buz\")));\n+            }\n+            case EXCLUDE_SUBDIR -> {\n+                assertFalse(Files.exists(workdir.resolve(\"to\/foo\")));\n+                assertTrue(Files.isDirectory(workdir.resolve(\"to\")));\n+            }\n+            case EXCLUDE_NONE -> {\n+                assertEquals(\"Hello\", Files.readString(workdir.resolve(\"to\/foo\/bar\/file.txt\")));\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_copyRecursive_file(boolean exclude, @TempDir Path workdir) throws IOException {\n+        Files.createDirectories(workdir.resolve(\"from\/foo\/bar\"));\n+        Files.writeString(workdir.resolve(\"from\/foo\/bar\/file.txt\"), \"Hello\");\n+\n+        List<Path> excludes = new ArrayList<>();\n+        if (exclude) {\n+            excludes.add(Path.of(\"bar\/file.txt\"));\n+        }\n+\n+        FileUtils.copyRecursive(workdir.resolve(\"from\/foo\/bar\/file.txt\"), workdir.resolve(\"to\/foo\/bar\/file.txt\"), excludes);\n+\n+        assertEquals(\"Hello\", Files.readString(workdir.resolve(\"from\/foo\/bar\/file.txt\")));\n+        if (exclude) {\n+            assertFalse(Files.exists(workdir.resolve(\"to\")));\n+        } else {\n+            assertEquals(\"Hello\", Files.readString(workdir.resolve(\"to\/foo\/bar\/file.txt\")));\n+        }\n+    }\n+\n+    enum ExcludeType {\n+        EXCLUDE_NONE,\n+        EXCLUDE_FILE,\n+        EXCLUDE_DIR,\n+        EXCLUDE_SUBDIR,\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/FileUtilsTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class IdentityWrapperTest {\n+\n+    @Test\n+    public void test_null() {\n+        assertThrows(NullPointerException.class, () -> identityOf(null));\n+    }\n+\n+    @Test\n+    public void test_equals() {\n+        var obj = new TestRecord(10);\n+        assertEquals(identityOf(obj), identityOf(obj));\n+    }\n+\n+    @Test\n+    public void test_not_equals() {\n+        var identity = identityOf(new TestRecord(10));\n+        var identity2 = identityOf(new TestRecord(10));\n+        assertNotEquals(identity, identity2);\n+        assertEquals(identity.value(), identity2.value());\n+    }\n+\n+    @Test\n+    public void test_Foo() {\n+        var foo = new Foo(10);\n+        assertFalse(foo.accessed());\n+\n+        foo.hashCode();\n+        assertTrue(foo.accessed());\n+        assertTrue(foo.hashCodeCalled());\n+        assertFalse(foo.equalsCalled());\n+\n+        foo = new Foo(1);\n+        foo.equals(null);\n+        assertTrue(foo.accessed());\n+        assertFalse(foo.hashCodeCalled());\n+        assertTrue(foo.equalsCalled());\n+    }\n+\n+    @Test\n+    public void test_wrappedValue_not_accessed() {\n+        var identity = identityOf(new Foo(10));\n+        var identity2 = identityOf(new Foo(10));\n+        assertNotEquals(identity, identity2);\n+\n+        assertFalse(identity.value().accessed());\n+        assertFalse(identity2.value().accessed());\n+\n+        assertEquals(identity.value(), identity2.value());\n+        assertEquals(identity2.value(), identity.value());\n+\n+        assertTrue(identity.value().accessed());\n+        assertTrue(identity2.value().accessed());\n+    }\n+\n+    @Test\n+    public void test_wrappedValue_not_accessed_in_set() {\n+        var identitySet = Set.of(identityOf(new Foo(10)), identityOf(new Foo(10)), identityOf(new Foo(10)));\n+        assertEquals(3, identitySet.size());\n+\n+        var valueSet = identitySet.stream().peek(identity -> {\n+            assertFalse(identity.value().accessed());\n+        }).map(IdentityWrapper::value).collect(Collectors.toSet());\n+\n+        assertEquals(1, valueSet.size());\n+    }\n+\n+    private static <T> IdentityWrapper<T> identityOf(T obj) {\n+        return new IdentityWrapper<>(obj);\n+    }\n+\n+    private record TestRecord(int v) {}\n+\n+    private final static class Foo {\n+\n+        Foo(int v) {\n+            this.v = v;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            try {\n+                return Objects.hash(v);\n+            } finally {\n+                hashCodeCalled = true;\n+            }\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            try {\n+                if (this == obj)\n+                    return true;\n+                if (obj == null)\n+                    return false;\n+                if (getClass() != obj.getClass())\n+                    return false;\n+                Foo other = (Foo) obj;\n+                return v == other.v;\n+            } finally {\n+                equalsCalled = true;\n+            }\n+        }\n+\n+        boolean equalsCalled() {\n+            return equalsCalled;\n+        }\n+\n+        boolean hashCodeCalled() {\n+            return hashCodeCalled;\n+        }\n+\n+        boolean accessed() {\n+            return equalsCalled() || hashCodeCalled();\n+        }\n+\n+        private final int v;\n+        private boolean equalsCalled;\n+        private boolean hashCodeCalled;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/IdentityWrapperTest.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -68,0 +68,8 @@\n+    @Test\n+    public void equals() {\n+        assertEquals(new PathGroup(Map.of()), new PathGroup(Map.of()));\n+        assertEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"foo\", Path.of(\"rab\"))));\n+        assertNotEquals(new PathGroup(Map.of(\"foo\", Path.of(\"bar\"))), new PathGroup(Map.of(\"Foo\", Path.of(\"bar\"))));\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/PathGroupTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,4 +43,6 @@\n-    static {\n-        if (System.getProperty(\"test.src\") == null) {\n-            \/\/ Was called by somebody else but not by jtreg\n-            System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+    public static class TestSrcInitializer {\n+        static {\n+            if (System.getProperty(\"test.src\") == null) {\n+                \/\/ Was called by somebody else but not by jtreg\n+                System.setProperty(\"test.src\", Path.of(\"@@openJdkDir@@\/test\/jdk\/tools\/jpackage\").toString());\n+            }\n@@ -87,0 +89,4 @@\n+    static {\n+        new TestSrcInitializer();\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitAdapter.java","additions":10,"deletions":4,"binary":false,"changes":14,"previous_filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/JUnitAdapter.java","status":"renamed"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import org.junit.jupiter.api.Assertions;\n+\n+\n+public final class JUnitUtils {\n+\n+    \/**\n+     * Convenience adapter for {@link Assertions#assertArrayEquals(byte[], byte[])},\n+     * {@link Assertions#assertArrayEquals(int[], int[])},\n+     * {@link Assertions#assertArrayEquals(Object[], Object[])}, etc. methods.\n+     *\n+     * @param expected the expected array to test for equality\n+     * @param actual   the actual array to test for equality\n+     *\/\n+    public static void assertArrayEquals(Object expected, Object actual) {\n+        ARRAY_ASSERTERS.getOrDefault(expected.getClass().componentType(), OBJECT_ARRAY_ASSERTER).acceptUnchecked(expected, actual);\n+    }\n+\n+    \/**\n+     * Converts the given exception object to a property map.\n+     * <p>\n+     * Values returned by public getters are added to the map. Names of getters are\n+     * the keys in the returned map. The values are property map representations of\n+     * the objects returned by the getters. Only {@link Throwable#getMessage()} and\n+     * {@link Throwable#getCause()} getters are picked for the property map by\n+     * default. If the exception class has additional getters, they will be added to\n+     * the map. {@code null} is permitted.\n+     *\n+     * @param ex the exception to convert into a property map\n+     * @return the property map view of the given exception object\n+     *\/\n+    public static Map<String, Object> exceptionAsPropertyMap(Exception ex) {\n+        return EXCEPTION_OM.toMap(ex);\n+    }\n+\n+\n+    public static final class ExceptionPattern {\n+\n+        public ExceptionPattern() {\n+        }\n+\n+        public boolean match(Exception ex) {\n+            Objects.requireNonNull(ex);\n+\n+            if (expectedType != null && !expectedType.isInstance(ex)) {\n+                return false;\n+            }\n+\n+            if (expectedMessage != null && !expectedMessage.equals(ex.getMessage())) {\n+                return false;\n+            }\n+\n+            if (expectedCauseType != null && !expectedCauseType.isInstance(ex.getCause())) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        public ExceptionPattern hasMessage(String v) {\n+            expectedMessage = v;\n+            return this;\n+        }\n+\n+        public ExceptionPattern isInstanceOf(Class<? extends Exception> v) {\n+            expectedType = v;\n+            return this;\n+        }\n+\n+        public ExceptionPattern isCauseInstanceOf(Class<? extends Throwable> v) {\n+            expectedCauseType = v;\n+            return this;\n+        }\n+\n+        public ExceptionPattern hasCause(boolean v) {\n+            return isCauseInstanceOf(v ? Exception.class : null);\n+        }\n+\n+        public ExceptionPattern hasCause() {\n+            return hasCause(true);\n+        }\n+\n+        private String expectedMessage;\n+        private Class<? extends Exception> expectedType;\n+        private Class<? extends Throwable> expectedCauseType;\n+    }\n+\n+\n+    @FunctionalInterface\n+    private interface ArrayEqualsAsserter<T> {\n+        void accept(T expected, T actual);\n+\n+        @SuppressWarnings(\"unchecked\")\n+        default void acceptUnchecked(Object expected, Object actual) {\n+            accept((T)expected, (T)actual);\n+        }\n+    }\n+\n+\n+    private static final Map<Class<?>, ArrayEqualsAsserter<?>> ARRAY_ASSERTERS = Map.of(\n+            boolean.class, (ArrayEqualsAsserter<boolean[]>)Assertions::assertArrayEquals,\n+            byte.class, (ArrayEqualsAsserter<byte[]>)Assertions::assertArrayEquals,\n+            char.class, (ArrayEqualsAsserter<char[]>)Assertions::assertArrayEquals,\n+            double.class, (ArrayEqualsAsserter<double[]>)Assertions::assertArrayEquals,\n+            float.class, (ArrayEqualsAsserter<float[]>)Assertions::assertArrayEquals,\n+            int.class, (ArrayEqualsAsserter<int[]>)Assertions::assertArrayEquals,\n+            long.class, (ArrayEqualsAsserter<long[]>)Assertions::assertArrayEquals,\n+            short.class, (ArrayEqualsAsserter<short[]>)Assertions::assertArrayEquals\n+    );\n+\n+    private static final ArrayEqualsAsserter<Object[]> OBJECT_ARRAY_ASSERTER = Assertions::assertArrayEquals;\n+\n+    private static final ObjectMapper EXCEPTION_OM = ObjectMapper.standard().create();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/tools\/jdk\/jpackage\/test\/JUnitUtils.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -27,1 +27,2 @@\n- * @compile\/module=jdk.jpackage jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n+ * @compile\/module=jdk.jpackage -Xlint:all -Werror\n+ *    jdk\/jpackage\/internal\/ExecutableOSVersionTest.java\n","filename":"test\/jdk\/tools\/jpackage\/junit\/windows\/junit.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-                            \"Comment=\",\n+                            \"Comment=APPLICATION_DESCRIPTION\",\n","filename":"test\/jdk\/tools\/jpackage\/linux\/ShortcutHintTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.util.Collections.unmodifiableSortedSet;\n+import static java.util.Map.entry;\n+import static jdk.jpackage.internal.util.PListWriter.writeDict;\n+import static jdk.jpackage.internal.util.PListWriter.writePList;\n+import static jdk.jpackage.internal.util.PListWriter.writeString;\n+import static jdk.jpackage.internal.util.XmlUtils.createXml;\n+import static jdk.jpackage.internal.util.XmlUtils.toXmlConsumer;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import jdk.jpackage.internal.util.PListReader;\n+import jdk.jpackage.internal.util.function.ThrowingBiConsumer;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JPackageStringBundle;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n+\n+\/**\n+ * Test --resource-dir with custom \"Info.plist\" for the top-level bundle\n+ * and \"Runtime-Info.plist\" for the embedded runtime bundle\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --type image --resource-dir \"Info.plist\" and \"Runtime-Info.plist\"\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @build CustomInfoPListTest\n+ * @requires (os.family == \"mac\")\n+ * @requires (jpackage.test.SQETest == null)\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=CustomInfoPListTest\n+ *\/\n+public class CustomInfoPListTest {\n+\n+    @Test\n+    @ParameterSupplier(\"customPLists\")\n+    public void testAppImage(TestConfig cfg) throws Throwable {\n+        var cmd = cfg.init(JPackageCommand.helloAppImage());\n+        var verifier = cfg.createPListFilesVerifier(cmd.executePrerequisiteActions());\n+        cmd.executeAndAssertHelloAppImageCreated();\n+        verifier.accept(cmd);\n+    }\n+\n+    @Test\n+    @ParameterSupplier(\"customPLists\")\n+    public void testNativePackage(TestConfig cfg) {\n+        List<ThrowingConsumer<JPackageCommand>> verifier = new ArrayList<>();\n+        new PackageTest().configureHelloApp().addInitializer(cmd -> {\n+            cfg.init(cmd.setFakeRuntime());\n+        }).addRunOnceInitializer(() -> {\n+            verifier.add(cfg.createPListFilesVerifier(JPackageCommand.helloAppImage().executePrerequisiteActions()));\n+        }).addInstallVerifier(cmd -> {\n+            verifier.get(0).accept(cmd);\n+        }).run(Action.CREATE_AND_UNPACK);\n+    }\n+\n+    @Test\n+    public void testRuntime() {\n+        final Path runtimeImage[] = new Path[1];\n+\n+        var cfg = new TestConfig(Set.of(CustomPListType.RUNTIME));\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            runtimeImage[0] = JPackageCommand.createInputRuntimeImage();\n+        }).addInitializer(cmd -> {\n+            cmd.ignoreDefaultRuntime(true)\n+                    .removeArgumentWithValue(\"--input\")\n+                    .setArgumentValue(\"--runtime-image\", runtimeImage[0]);\n+            cfg.init(cmd);\n+        }).addInstallVerifier(cmd -> {\n+            cfg.createPListFilesVerifier(cmd).accept(cmd);\n+        }).run(Action.CREATE_AND_UNPACK);\n+    }\n+\n+    public static Collection<Object[]> customPLists() {\n+        return Stream.of(\n+                Set.of(CustomPListType.APP),\n+                Set.of(CustomPListType.APP_WITH_FA),\n+                Set.of(CustomPListType.EMBEDDED_RUNTIME),\n+                Set.of(CustomPListType.APP, CustomPListType.EMBEDDED_RUNTIME)\n+        ).map(TestConfig::new).map(cfg -> {\n+            return new Object[] { cfg };\n+        }).toList();\n+    }\n+\n+    private static List<String> toStringList(PListReader plistReader) {\n+        return MacHelper.flatMapPList(plistReader).entrySet().stream().sorted(Comparator.comparing(Map.Entry::getKey)).map(e -> {\n+            return String.format(\"%s: %s\", e.getKey(), e.getValue());\n+        }).toList();\n+    }\n+\n+\n+    public record TestConfig(Set<CustomPListType> customPLists) {\n+\n+        public TestConfig {\n+            Objects.requireNonNull(customPLists);\n+            if (customPLists.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+            customPLists = unmodifiableSortedSet(new TreeSet<>(customPLists));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return customPLists.stream()\n+                    .map(CustomPListType::toString)\n+                    .collect(Collectors.joining(\"+\"));\n+        }\n+\n+        JPackageCommand init(JPackageCommand cmd) throws IOException {\n+            if (customPLists.contains(CustomPListType.APP_WITH_FA)) {\n+                final Path propFile = TKit.createTempFile(\"fa.properties\");\n+                final var props = List.of(\n+                        entry(\"mime-type\", \"application\/x-jpackage-foo\"),\n+                        entry(\"extension\", \"foo\"),\n+                        entry(\"description\", \"bar\")\n+                );\n+                TKit.createPropertiesFile(propFile, props);\n+                cmd.setArgumentValue(\"--file-associations\", propFile);\n+            }\n+\n+            cmd.setArgumentValue(\"--resource-dir\", TKit.createTempDirectory(\"resources\"));\n+            for (var customPList : customPLists) {\n+                customPList.createInputPListFile(cmd);\n+            }\n+            return cmd;\n+        }\n+\n+        ThrowingConsumer<JPackageCommand> createPListFilesVerifier(JPackageCommand cmd) throws IOException {\n+            ThrowingConsumer<JPackageCommand> defaultVerifier = otherCmd -> {\n+                for (var customPList : customPLists) {\n+                    customPList.verifyPListFile(otherCmd);\n+                }\n+            };\n+\n+            var defaultPListFiles = CustomPListType.defaultRoles(customPLists);\n+\n+            if (defaultPListFiles.isEmpty()) {\n+                return defaultVerifier;\n+            } else {\n+                var vanillaCmd = new JPackageCommand().setFakeRuntime()\n+                        .addArguments(cmd.getAllArguments())\n+                        .setPackageType(PackageType.IMAGE)\n+                        .removeArgumentWithValue(\"--resource-dir\")\n+                        .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"vanilla\"));\n+                vanillaCmd.executeIgnoreExitCode().assertExitCodeIsZero();\n+\n+                return otherCmd -> {\n+                    defaultVerifier.accept(otherCmd);\n+                    for (var defaultPListFile : defaultPListFiles) {\n+                        final var expectedPListPath = defaultPListFile.path(vanillaCmd);\n+                        final var expectedPList = MacHelper.readPList(expectedPListPath);\n+\n+                        final var actualPListPath = defaultPListFile.path(otherCmd);\n+                        final var actualPList = MacHelper.readPList(actualPListPath);\n+\n+                        var expected = toStringList(expectedPList);\n+                        var actual = toStringList(actualPList);\n+\n+                        TKit.assertStringListEquals(expected, actual, String.format(\n+                                \"Check contents of [%s] and [%s] plist files are the same\", expectedPListPath, actualPListPath));\n+                    }\n+                };\n+            }\n+        }\n+    }\n+\n+\n+    private enum PListRole {\n+        MAIN,\n+        EMBEDDED_RUNTIME,\n+        ;\n+\n+        Path path(JPackageCommand cmd) {\n+            final Path bundleRoot;\n+            if (cmd.isRuntime() || this == EMBEDDED_RUNTIME) {\n+                bundleRoot = cmd.appRuntimeDirectory();\n+            } else {\n+                bundleRoot = cmd.appLayout().contentDirectory().getParent();\n+            }\n+            return bundleRoot.resolve(\"Contents\/Info.plist\");\n+        }\n+    }\n+\n+\n+    private enum CustomPListType {\n+        APP(\n+                CustomPListFactory.PLIST_INPUT::writeAppPlist,\n+                CustomPListFactory.PLIST_OUTPUT::writeAppPlist,\n+                \"Info.plist\"),\n+\n+        APP_WITH_FA(APP),\n+\n+        EMBEDDED_RUNTIME(\n+                CustomPListFactory.PLIST_INPUT::writeEmbeddedRuntimePlist,\n+                CustomPListFactory.PLIST_OUTPUT::writeEmbeddedRuntimePlist,\n+                \"Runtime-Info.plist\"),\n+\n+        RUNTIME(\n+                CustomPListFactory.PLIST_INPUT::writeRuntimePlist,\n+                CustomPListFactory.PLIST_OUTPUT::writeRuntimePlist,\n+                \"Info.plist\"),\n+        ;\n+\n+        private CustomPListType(\n+                ThrowingBiConsumer<JPackageCommand, XMLStreamWriter> inputPlistWriter,\n+                ThrowingBiConsumer<JPackageCommand, XMLStreamWriter> outputPlistWriter,\n+                String outputPlistFilename) {\n+            this.inputPlistWriter = ThrowingBiConsumer.toBiConsumer(inputPlistWriter);\n+            this.outputPlistWriter = ThrowingBiConsumer.toBiConsumer(outputPlistWriter);\n+            this.outputPlistFilename = outputPlistFilename;\n+        }\n+\n+        private CustomPListType(CustomPListType other) {\n+            this.inputPlistWriter = other.inputPlistWriter;\n+            this.outputPlistWriter = other.outputPlistWriter;\n+            this.outputPlistFilename = other.outputPlistFilename;\n+        }\n+\n+        void createInputPListFile(JPackageCommand cmd) throws IOException {\n+            createXml(Path.of(cmd.getArgumentValue(\"--resource-dir\")).resolve(outputPlistFilename), xml -> {\n+                inputPlistWriter.accept(cmd, xml);\n+            });\n+        }\n+\n+        void verifyPListFile(JPackageCommand cmd) throws IOException {\n+            final var expectedPList = new PListReader(createXml(xml -> {\n+                    outputPlistWriter.accept(cmd, xml);\n+                }).getNode());\n+\n+            final var actualPListPath = role().path(cmd);\n+            final var actualPList = MacHelper.readPList(actualPListPath);\n+\n+            var expected = toStringList(expectedPList);\n+            var actual = toStringList(actualPList);\n+\n+            TKit.assertStringListEquals(expected, actual, String.format(\"Check contents of [%s] plist file is as expected\", actualPListPath));\n+        }\n+\n+        PListRole role() {\n+            if (this == EMBEDDED_RUNTIME) {\n+                return PListRole.EMBEDDED_RUNTIME;\n+            } else {\n+                return PListRole.MAIN;\n+            }\n+        }\n+\n+        static Set<PListRole> defaultRoles(Collection<CustomPListType> customPLists) {\n+            var result = new HashSet<>(Set.of(PListRole.values()));\n+            customPLists.stream().<PListRole>mapMulti((customPList, acc) -> {\n+                if (customPList == CustomPListType.RUNTIME) {\n+                    List.of(PListRole.values()).forEach(acc::accept);\n+                } else {\n+                    acc.accept(customPList.role());\n+                }\n+            }).forEach(result::remove);\n+            return Collections.unmodifiableSet(result);\n+        }\n+\n+        private final BiConsumer<JPackageCommand, XMLStreamWriter> inputPlistWriter;\n+        private final BiConsumer<JPackageCommand, XMLStreamWriter> outputPlistWriter;\n+        private final String outputPlistFilename;\n+    }\n+\n+\n+    private enum CustomPListFactory {\n+        PLIST_INPUT,\n+        PLIST_OUTPUT,\n+        ;\n+\n+        private void writeAppPlist(JPackageCommand cmd, XMLStreamWriter xml) throws XMLStreamException, IOException {\n+            writePList(xml, toXmlConsumer(() -> {\n+                writeDict(xml, toXmlConsumer(() -> {\n+                    writeString(xml, \"CustomAppProperty\", \"App\");\n+                    writeString(xml, \"CFBundleExecutable\", value(\"DEPLOY_LAUNCHER_NAME\", cmd.name()));\n+                    writeString(xml, \"CFBundleIconFile\", value(\"DEPLOY_ICON_FILE\", cmd.name() + \".icns\"));\n+                    writeString(xml, \"CFBundleIdentifier\", value(\"DEPLOY_BUNDLE_IDENTIFIER\", \"Hello\"));\n+                    writeString(xml, \"CFBundleName\", value(\"DEPLOY_BUNDLE_NAME\", cmd.name()));\n+                    writeString(xml, \"CFBundleShortVersionString\", value(\"DEPLOY_BUNDLE_SHORT_VERSION\", cmd.version()));\n+                    writeString(xml, \"LSApplicationCategoryType\", value(\"DEPLOY_APP_CATEGORY\", \"public.app-category.utilities\"));\n+                    writeString(xml, \"CFBundleVersion\", value(\"DEPLOY_BUNDLE_CFBUNDLE_VERSION\", cmd.version()));\n+                    writeString(xml, \"NSHumanReadableCopyright\", value(\"DEPLOY_BUNDLE_COPYRIGHT\",\n+                            JPackageStringBundle.MAIN.cannedFormattedString(\"param.copyright.default\", new Date()).getValue()));\n+                    if (cmd.hasArgument(\"--file-associations\")) {\n+                        if (this == PLIST_INPUT) {\n+                            xml.writeCharacters(\"DEPLOY_FILE_ASSOCIATIONS\");\n+                        } else {\n+                            MacHelper.writeFaPListFragment(cmd, xml);\n+                        }\n+                    }\n+                }));\n+            }));\n+        }\n+\n+        void writeEmbeddedRuntimePlist(JPackageCommand cmd, XMLStreamWriter xml) throws XMLStreamException, IOException {\n+            writePList(xml, toXmlConsumer(() -> {\n+                writeDict(xml, toXmlConsumer(() -> {\n+                    writeString(xml, \"CustomEmbeddedRuntimeProperty\", \"Embedded runtime\");\n+                    writeString(xml, \"CFBundleIdentifier\", value(\"CF_BUNDLE_IDENTIFIER\", \"Hello\"));\n+                    writeString(xml, \"CFBundleName\", value(\"CF_BUNDLE_NAME\", cmd.name()));\n+                    writeString(xml, \"CFBundleShortVersionString\", value(\"CF_BUNDLE_SHORT_VERSION_STRING\", cmd.version()));\n+                    writeString(xml, \"CFBundleVersion\", value(\"CF_BUNDLE_VERSION\", cmd.version()));\n+                }));\n+            }));\n+        }\n+\n+        void writeRuntimePlist(JPackageCommand cmd, XMLStreamWriter xml) throws XMLStreamException, IOException {\n+            writePList(xml, toXmlConsumer(() -> {\n+                writeDict(xml, toXmlConsumer(() -> {\n+                    writeString(xml, \"CustomRuntimeProperty\", \"Runtime\");\n+                    writeString(xml, \"CFBundleIdentifier\", value(\"CF_BUNDLE_IDENTIFIER\", cmd.name()));\n+                    writeString(xml, \"CFBundleName\", value(\"CF_BUNDLE_NAME\", cmd.name()));\n+                    writeString(xml, \"CFBundleShortVersionString\", value(\"CF_BUNDLE_SHORT_VERSION_STRING\", cmd.version()));\n+                    writeString(xml, \"CFBundleVersion\", value(\"CF_BUNDLE_VERSION\", cmd.version()));\n+                    writeString(xml, \"CustomInfoPListFA\", \"DEPLOY_FILE_ASSOCIATIONS\");\n+                }));\n+            }));\n+        }\n+\n+        private String value(String input, String output) {\n+            if (this == PLIST_INPUT) {\n+                return input;\n+            } else {\n+                return output;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/CustomInfoPListTest.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.jpackage.internal.util.PListWriter.writeBoolean;\n+import static jdk.jpackage.internal.util.PListWriter.writeDict;\n+import static jdk.jpackage.internal.util.PListWriter.writePList;\n+import static jdk.jpackage.internal.util.XmlUtils.createXml;\n+import static jdk.jpackage.internal.util.XmlUtils.toXmlConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n+import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * Test generates signed app-image with custom entitlements file from the\n+ * \"--mac-entitlements\" parameter and the resource directory. Following cases\n+ * are covered:\n+ * - Custom entitlements file in the resource directory.\n+ * - Custom entitlements file specified with the \"--mac-entitlements\" parameter.\n+ * - Custom entitlements file in the resource directory and specified with the\n+ * \"--mac-entitlements\" parameter.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --type app-image \"--mac-entitlements\" parameter\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @library base\n+ * @build SigningBase\n+ * @build jdk.jpackage.test.*\n+ * @build EntitlementsTest\n+ * @requires (jpackage.test.MacSignTests == \"run\")\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=EntitlementsTest\n+ *  --jpt-before-run=SigningBase.verifySignTestEnvReady\n+ *\/\n+public class EntitlementsTest {\n+\n+    private static void createEntitlementsFile(Path file, boolean microphone) throws IOException {\n+        createXml(file, xml -> {\n+            writePList(xml, toXmlConsumer(() -> {\n+                writeDict(xml, toXmlConsumer(() -> {\n+                    writeBoolean(xml, \"com.apple.security.cs.allow-jit\", true);\n+                    writeBoolean(xml, \"com.apple.security.cs.allow-unsigned-executable-memory\", true);\n+                    writeBoolean(xml, \"com.apple.security.cs.disable-library-validation\", true);\n+                    writeBoolean(xml, \"com.apple.security.cs.allow-dyld-environment-variables\", true);\n+                    writeBoolean(xml, \"com.apple.security.cs.debugger\", true);\n+                    writeBoolean(xml, \"com.apple.security.device.audio-input\", true);\n+                    writeBoolean(xml, \"com.apple.security.device.microphone\", microphone);\n+                }));\n+            }));\n+        });\n+    }\n+\n+    public enum EntitlementsSource implements Consumer<JPackageCommand> {\n+        CMDLINE(cmd -> {\n+            var macEntitlementsFile = TKit.createTempFile(\"foo.plist\");\n+            createEntitlementsFile(macEntitlementsFile, true);\n+            cmd.addArguments(\"--mac-entitlements\", macEntitlementsFile);\n+        }),\n+        RESOURCE_DIR(cmd -> {\n+            if (!cmd.hasArgument(\"--resource-dir\")) {\n+                cmd.setArgumentValue(\"--resource-dir\", TKit.createTempDirectory(\"resources\"));\n+            }\n+\n+            var resourcesDir = Path.of(cmd.getArgumentValue(\"--resource-dir\"));\n+            createEntitlementsFile(resourcesDir.resolve(cmd.name() + \".entitlements\"), false);\n+        }),\n+        ;\n+\n+        EntitlementsSource(ThrowingConsumer<JPackageCommand> initializer) {\n+            this.initializer = toConsumer(initializer);\n+        }\n+\n+        @Override\n+        public void accept(JPackageCommand cmd) {\n+            initializer.accept(cmd);\n+        }\n+\n+        private final Consumer<JPackageCommand> initializer;\n+    }\n+\n+    @Test\n+    @Parameter({\"CMDLINE\"})\n+    @Parameter({\"RESOURCE_DIR\"})\n+    @Parameter({\"CMDLINE\", \"RESOURCE_DIR\"})\n+    public static void test(EntitlementsSource... entitlementsSources) {\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, Stream.of(entitlementsSources));\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    @Test\n+    @Parameter({\"CMDLINE\"})\n+    @Parameter({\"RESOURCE_DIR\"})\n+    @Parameter({\"CMDLINE\", \"RESOURCE_DIR\"})\n+    public static void testAppStore(EntitlementsSource... entitlementsSources) {\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, Stream.concat(Stream.of(cmd -> {\n+                cmd.addArguments(\"--mac-app-store\");\n+                \/\/ Ignore externally supplied runtime as it may have the \"bin\"\n+                \/\/ directory that will cause jpackage to bail out.\n+                cmd.ignoreDefaultRuntime(true);\n+            }), Stream.of(entitlementsSources)));\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, Stream<Consumer<JPackageCommand>> mutators) {\n+\n+        var cmd = JPackageCommand.helloAppImage();\n+\n+        cmd.mutate(MacHelper.useKeychain(keychain)).mutate(new SignKeyOption(\n+                SignKeyOption.Type.SIGN_KEY_IDENTITY,\n+                SigningBase.StandardCertificateRequest.CODESIGN.spec()\n+        )::addTo);\n+\n+        cmd.mutate(new AdditionalLauncher(\"x\")::applyTo);\n+\n+        mutators.forEach(cmd::mutate);\n+\n+        cmd.executeAndAssertHelloAppImageCreated();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/EntitlementsTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -25,0 +25,7 @@\n+import static jdk.jpackage.internal.util.PListWriter.writeDict;\n+import static jdk.jpackage.internal.util.PListWriter.writePList;\n+import static jdk.jpackage.internal.util.XmlUtils.createXml;\n+import static jdk.jpackage.internal.util.XmlUtils.toXmlConsumer;\n+import static jdk.jpackage.test.MacHelper.flatMapPList;\n+import static jdk.jpackage.test.MacHelper.readPListFromAppImage;\n+import static jdk.jpackage.test.MacHelper.writeFaPListFragment;\n@@ -27,0 +34,1 @@\n+import java.util.Comparator;\n@@ -29,0 +37,2 @@\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n@@ -32,1 +42,0 @@\n-import jdk.jpackage.test.MacHelper;\n@@ -55,2 +64,2 @@\n-        final Path propFile = TKit.workDir().resolve(\"fa.properties\");\n-        Map<String, String> map = Map.ofEntries(\n+        final Path propFile = TKit.createTempFile(\"fa.properties\");\n+        final var props = List.of(\n@@ -68,1 +77,1 @@\n-        TKit.createPropertiesFile(propFile, map);\n+        TKit.createPropertiesFile(propFile, props);\n@@ -70,1 +79,1 @@\n-        JPackageCommand cmd = JPackageCommand.helloAppImage();\n+        final var cmd = JPackageCommand.helloAppImage().setFakeRuntime();\n@@ -74,41 +83,3 @@\n-        Path appImage = cmd.outputBundle();\n-        verifyPList(appImage);\n-    }\n-\n-    private static void checkStringValue(PListReader plist, String key, String value) {\n-        String result = plist.queryValue(key);\n-        TKit.assertEquals(value, result, String.format(\n-                \"Check value of %s plist key\", key));\n-    }\n-\n-    private static void checkBoolValue(PListReader plist, String key, boolean value) {\n-        boolean result = plist.queryBoolValue(key);\n-        TKit.assertEquals(value, result, String.format(\n-                \"Check value of %s plist key\", key));\n-    }\n-\n-    private static void checkArrayValue(PListReader plist, String key,\n-            List<String> values) {\n-        List<String> result = plist.queryStringArrayValue(key);\n-        TKit.assertStringListEquals(values, result, String.format(\n-                \"Check value of %s plist key\", key));\n-    }\n-\n-    private static void verifyPList(Path appImage) throws Exception {\n-        final var rootPlist = MacHelper.readPListFromAppImage(appImage);\n-\n-        TKit.traceFileContents(appImage.resolve(\"Contents\/Info.plist\"), \"Info.plist\");\n-\n-        var plist = rootPlist.queryArrayValue(\"CFBundleDocumentTypes\", false).findFirst().map(PListReader.class::cast).orElseThrow();\n-\n-        checkStringValue(plist, \"CFBundleTypeRole\", \"Viewer\");\n-        checkStringValue(plist, \"LSHandlerRank\", \"Default\");\n-        checkStringValue(plist, \"NSDocumentClass\", \"SomeClass\");\n-\n-        checkBoolValue(plist, \"LSTypeIsPackage\", true);\n-        checkBoolValue(plist, \"LSSupportsOpeningDocumentsInPlace\", false);\n-        checkBoolValue(plist, \"UISupportsDocumentBrowser\", false);\n-\n-        plist = rootPlist.queryArrayValue(\"UTExportedTypeDeclarations\", false).findFirst().map(PListReader.class::cast).orElseThrow();\n-\n-        checkArrayValue(plist, \"UTTypeConformsTo\", List.of(\"public.image\", \"public.data\"));\n+        Function<Map.Entry<String, String>, String> toString = e -> {\n+            return String.format(\"%s => %s\", e.getKey(), e.getValue());\n+        };\n@@ -116,1 +87,3 @@\n-        plist = plist.queryDictValue(\"UTTypeTagSpecification\");\n+        final var actualFaProperties = flatMapPList(readPListFromAppImage(cmd.outputBundle())).entrySet().stream().filter(e -> {\n+            return Stream.of(\"\/CFBundleDocumentTypes\", \"\/UTExportedTypeDeclarations\").anyMatch(e.getKey()::startsWith);\n+        }).sorted(Comparator.comparing(Map.Entry::getKey)).map(toString).toList();\n@@ -118,1 +91,7 @@\n-        checkArrayValue(plist, \"NSExportableTypes\", List.of(\"public.png\", \"public.jpg\"));\n+        final var expectedFaProperties = flatMapPList(new PListReader(createXml(xml -> {\n+            writePList(xml, toXmlConsumer(() -> {\n+                writeDict(xml, toXmlConsumer(() -> {\n+                    writeFaPListFragment(cmd, xml);\n+                }));\n+            }));\n+        }).getNode())).entrySet().stream().sorted(Comparator.comparing(Map.Entry::getKey)).map(toString).toList();\n@@ -120,0 +99,1 @@\n+        TKit.assertStringListEquals(expectedFaProperties, actualFaProperties, \"Check fa properties in the Info.plist file as expected\");\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacFileAssociationsTest.java","additions":28,"deletions":48,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+        expectedStrings.add(JPackageStringBundle.MAIN.cannedFormattedString(\"error.tool.failed.with.output\", \"codesign\"));\n+\n@@ -78,3 +80,1 @@\n-        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n+        MacSign.withKeychain(keychain -> {\n@@ -89,2 +89,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -98,2 +96,30 @@\n-            cmd.execute(1);\n-        });\n+            MacHelper.useKeychain(cmd, keychain).execute(1);\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    @Test\n+    public static void testCodesignUnspecifiedFailure() throws IOException {\n+\n+        var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n+\n+        appImageCmd.executeIgnoreExitCode().assertExitCodeIsZero();\n+\n+        \/\/ This test expects jpackage to respond in a specific way on a codesign failure.\n+        \/\/ The simplest option to trigger codesign failure is to request the signing of an invalid bundle.\n+        \/\/ Create app content directory with the name known to fail signing.\n+        final var appContent = appImageCmd.appLayout().contentDirectory().resolve(\"foo.1\");\n+        Files.createDirectory(appContent);\n+        Files.createFile(appContent.resolve(\"file\"));\n+\n+        final List<CannedFormattedString> expectedStrings = new ArrayList<>();\n+        expectedStrings.add(JPackageStringBundle.MAIN.cannedFormattedString(\"error.tool.failed.with.output\", \"codesign\"));\n+\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = new JPackageCommand().setPackageType(PackageType.IMAGE)\n+                    .ignoreDefaultVerbose(true)\n+                    .validateOutput(expectedStrings.toArray(CannedFormattedString[]::new))\n+                    .addArguments(\"--app-image\", appImageCmd.outputBundle())\n+                    .addArguments(\"--mac-app-image-sign-identity\", SigningBase.StandardCertificateRequest.CODESIGN.spec().name());\n+\n+            MacHelper.useKeychain(cmd, keychain).execute(1);\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n@@ -119,4 +145,2 @@\n-        final var keychain = SigningBase.StandardKeychain.EXPIRED.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n-            final var cmd = JPackageCommand.helloAppImage()\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n@@ -124,2 +148,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -132,1 +154,1 @@\n-        });\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.EXPIRED.keychain());\n@@ -136,13 +158,17 @@\n-    @Parameter({\"IMAGE\", \"GOOD_SIGNING_KEY_USER_NAME\"})\n-    @Parameter({\"MAC_DMG\", \"GOOD_SIGNING_KEY_USER_NAME\"})\n-    @Parameter({\"MAC_PKG\", \"GOOD_SIGNING_KEY_USER_NAME_PKG\", \"GOOD_SIGNING_KEY_USER_NAME\"})\n-\n-    @Parameter({\"IMAGE\", \"GOOD_CODESIGN_SIGN_IDENTITY\"})\n-    @Parameter({\"MAC_PKG\", \"GOOD_CODESIGN_SIGN_IDENTITY\", \"GOOD_PKG_SIGN_IDENTITY\"})\n-    @Parameter({\"MAC_PKG\", \"GOOD_PKG_SIGN_IDENTITY\"})\n-    public static void testMultipleCertificates(PackageType type, SignOption... options) {\n-\n-        final var keychain = SigningBase.StandardKeychain.DUPLICATE.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n-            final var cmd = JPackageCommand.helloAppImage()\n+    \/\/ Case \"--mac-signing-key-user-name\": jpackage selects first certificate\n+    \/\/ found with warning message. Certificate hash is pass to \"codesign\" in this\n+    \/\/ case.\n+    @Parameter({\"IMAGE\", \"0\", \"GOOD_SIGNING_KEY_USER_NAME\"})\n+    @Parameter({\"MAC_DMG\", \"0\", \"GOOD_SIGNING_KEY_USER_NAME\"})\n+    @Parameter({\"MAC_PKG\", \"0\", \"GOOD_SIGNING_KEY_USER_NAME_PKG\", \"GOOD_SIGNING_KEY_USER_NAME\"})\n+\n+    \/\/ Case \"--mac-app-image-sign-identity\": sign identity will be pass to\n+    \/\/ \"codesign\" and \"codesign\" should fail due to multiple certificates with\n+    \/\/ same common name found.\n+    @Parameter({\"IMAGE\", \"1\", \"GOOD_CODESIGN_SIGN_IDENTITY\"})\n+    @Parameter({\"MAC_PKG\", \"1\", \"GOOD_CODESIGN_SIGN_IDENTITY\", \"GOOD_PKG_SIGN_IDENTITY\"})\n+    @Parameter({\"MAC_PKG\", \"1\", \"GOOD_PKG_SIGN_IDENTITY\"})\n+    public static void testMultipleCertificates(PackageType type, int jpackageExitCode, SignOption... options) {\n+\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n@@ -150,2 +176,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -157,2 +181,2 @@\n-            }).execute(1);\n-        });\n+            }).execute(jpackageExitCode);\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.DUPLICATE.keychain());\n@@ -165,4 +189,2 @@\n-        final var keychain = SigningBase.StandardKeychain.MAIN.spec().keychain();\n-\n-        MacSign.Keychain.withAddedKeychains(List.of(keychain), () -> {\n-            final var cmd = JPackageCommand.helloAppImage()\n+        MacSign.withKeychain(keychain -> {\n+            final var cmd = MacHelper.useKeychain(JPackageCommand.helloAppImage(), keychain)\n@@ -170,2 +192,0 @@\n-                    .addArguments(\"--mac-sign\")\n-                    .addArguments(\"--mac-signing-keychain\", keychain.name())\n@@ -177,1 +197,1 @@\n-        });\n+        }, MacSign.Keychain.UsageBuilder::addToSearchList, SigningBase.StandardKeychain.MAIN.keychain());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacSignTest.java","additions":58,"deletions":38,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JPackageStringBundle;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --type pkg --resource-dir Scripts\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @build PkgScriptsTest\n+ * @requires (os.family == \"mac\")\n+ * @requires (jpackage.test.SQETest == null)\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=PkgScriptsTest\n+ *\/\n+public class PkgScriptsTest {\n+\n+    public static Collection<?> input() {\n+        return List.of(new Object[][]{\n+            { new PkgInstallScript[]{\n+                    PkgInstallScript.PREINSTALL,\n+                    PkgInstallScript.POSTINSTALL },\n+            },\n+            { new PkgInstallScript[]{\n+                    PkgInstallScript.PREINSTALL },\n+            },\n+            { new PkgInstallScript[]{\n+                    PkgInstallScript.POSTINSTALL },\n+            },\n+        });\n+    }\n+\n+    @Test\n+    @ParameterSupplier(\"input\")\n+    public void test(PkgInstallScript[] customScriptRoles) {\n+        var responseDir = TKit.createTempDirectory(\"response\");\n+\n+        var customScripts = Stream.of(customScriptRoles).map(role -> {\n+            return new CustomInstallScript(responseDir, role);\n+        }).toList();\n+\n+        var noScriptRoles = noScriptRoles(customScripts);\n+\n+        new PackageTest()\n+            .forTypes(PackageType.MAC_PKG)\n+            .configureHelloApp()\n+            .addInitializer(cmd -> {\n+                cmd.addArguments(\"--resource-dir\", TKit.createTempDirectory(\"resources\"));\n+                customScripts.forEach(customScript -> {\n+                    customScript.createFor(cmd);\n+                });\n+                \/\/ Verify jpackage logs script resources user can customize.\n+                noScriptRoles.stream().map(role -> {\n+                    return JPackageStringBundle.MAIN.cannedFormattedString(\n+                            \"message.no-default-resource\",\n+                            String.format(\"[%s]\", role.resourceCategory()),\n+                            role.scriptName());\n+                }).forEach(cmd::validateOutput);\n+            }).addInstallVerifier(cmd -> {\n+                customScripts.forEach(customScript -> {\n+                    customScript.verify(cmd);\n+                });\n+                if (cmd.isPackageUnpacked()) {\n+                    noScriptRoles.forEach(role -> {\n+                        role.verifyExists(cmd, false);\n+                    });\n+                }\n+            }).run();\n+    }\n+\n+    enum PkgInstallScript {\n+        POSTINSTALL,\n+        PREINSTALL,\n+        ;\n+\n+        String scriptName() {\n+            return name().toLowerCase();\n+        }\n+\n+        String resourceCategory() {\n+            return JPackageStringBundle.MAIN.cannedFormattedString(\n+                    String.format(\"resource.pkg-%s-script\", scriptName())).getValue();\n+        }\n+\n+        Path pathInUnpackedPackage(JPackageCommand cmd) {\n+            cmd.verifyIsOfType(PackageType.MAC_PKG);\n+            if (!cmd.isPackageUnpacked()) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \/\/ Internal unpacked pkg name will be \"PkgScriptsTest-app.pkg\" and not a\n+            \/\/ \"PkgScriptsTest-1.0.pkg\"\n+            return cmd.pathToUnpackedPackageFile(Path.of(\"\/\")).getParent()\n+                    .resolve(\"data\").resolve(cmd.name() + \"-app.pkg\")\n+                    .resolve(\"Scripts\");\n+        }\n+\n+        void verifyExists(JPackageCommand cmd, boolean exists) {\n+            var scriptPath = pathInUnpackedPackage(cmd).resolve(scriptName());\n+            if (exists) {\n+                TKit.assertExecutableFileExists(scriptPath);\n+            } else {\n+                TKit.assertPathExists(scriptPath, false);\n+            }\n+        }\n+    }\n+\n+    record CustomInstallScript(Path responseDir, PkgInstallScript role) {\n+        CustomInstallScript {\n+            Objects.requireNonNull(responseDir);\n+            Objects.requireNonNull(role);\n+        }\n+\n+        void createFor(JPackageCommand cmd) {\n+            var responseFile = responseFilePath(cmd);\n+            TKit.assertPathExists(responseFile, false);\n+            TKit.createTextFile(Path.of(cmd.getArgumentValue(\"--resource-dir\")).resolve(role.scriptName()), Stream.of(\n+                    \"#!\/usr\/bin\/env sh\",\n+                    String.format(\"touch \\\"%s\\\"\", responseFile.toAbsolutePath()),\n+                    \"exit 0\"\n+            ));\n+        }\n+\n+        void verify(JPackageCommand cmd) {\n+            if (cmd.isPackageUnpacked()) {\n+                role.verifyExists(cmd, true);\n+            } else {\n+                TKit.assertFileExists(responseFilePath(cmd));\n+            }\n+        }\n+\n+        private Path responseFilePath(JPackageCommand cmd) {\n+            return responseDir.resolve(role.scriptName());\n+        }\n+    }\n+\n+    private static Set<PkgInstallScript> noScriptRoles(Collection<CustomInstallScript> customScripts) {\n+        var noScriptRoles = new HashSet<>(Set.of(PkgInstallScript.values()));\n+        customScripts.stream().map(CustomInstallScript::role).forEach(noScriptRoles::remove);\n+        return noScriptRoles;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/PkgScriptsTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-import java.nio.file.Path;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -26,3 +26,1 @@\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import java.nio.file.Path;\n@@ -30,0 +28,4 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.MacSign;\n@@ -71,0 +73,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, doSign, signingKey, certEnum);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private void test(MacSign.ResolvedKeychain keychain, boolean doSign, boolean signingKey, SigningBase.CertIndex certEnum) throws Exception {\n@@ -77,1 +85,1 @@\n-                    SigningBase.getKeyChain());\n+                    keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTest.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-import java.nio.file.Path;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -26,0 +26,4 @@\n+import java.nio.file.Path;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,1 +31,1 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.MacSign;\n@@ -29,3 +33,1 @@\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.TKit;\n@@ -70,0 +72,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, signAppImage, signingKey);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n@@ -81,1 +89,1 @@\n-                    SigningBase.getKeyChain());\n+                    keychain.name());\n@@ -106,1 +114,1 @@\n-            .addArguments(\"--mac-signing-keychain\", SigningBase.getKeyChain());\n+            .addArguments(\"--mac-signing-keychain\", keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningAppImageTwoStepsTest.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -25,0 +27,2 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,1 +31,2 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacSign;\n@@ -30,3 +35,1 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.TKit;\n@@ -44,1 +47,1 @@\n- * \"jpackage.openjdk.java.net\" can be over-ridden by systerm property\n+ * \"jpackage.openjdk.java.net\" can be over-ridden by system property\n@@ -105,0 +108,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, signAppImage, signingKey);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private void test(MacSign.ResolvedKeychain keychain, boolean signAppImage, boolean signingKey) throws Exception {\n@@ -115,1 +124,1 @@\n-                    \"--mac-signing-keychain\", SigningBase.getKeyChain());\n+                    \"--mac-signing-keychain\", keychain.name());\n@@ -136,1 +145,1 @@\n-            .addArguments(\"--mac-signing-keychain\", SigningBase.getKeyChain());\n+            .addArguments(\"--mac-signing-keychain\", keychain.name());\n@@ -157,1 +166,1 @@\n-                                SigningBase.getKeyChain());\n+                                keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageFromTwoStepAppImageTest.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -25,0 +27,2 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,0 +31,2 @@\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacSign;\n@@ -29,3 +35,0 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n@@ -42,1 +45,1 @@\n- * \"jpackage.openjdk.java.net\" can be over-ridden by systerm property\n+ * \"jpackage.openjdk.java.net\" can be over-ridden by system property\n@@ -58,0 +61,19 @@\n+ * @requires (jpackage.test.SQETest != null)\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * --jpt-run=SigningPackageTest\n+ * --jpt-space-subst=*\n+ * --jpt-include=SigningPackageTest.test(true,*true,*true,*ASCII_INDEX)\n+ * --jpt-before-run=SigningBase.verifySignTestEnvReady\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --type pkg,dmg --mac-sign\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @library base\n+ * @key jpackagePlatformPackage\n+ * @build SigningBase\n+ * @build jdk.jpackage.test.*\n+ * @build SigningPackageTest\n+ * @requires (jpackage.test.MacSignTests == \"run\")\n+ * @requires (jpackage.test.SQETest == null)\n@@ -128,0 +150,6 @@\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, signingKey, signAppImage, signPKG, certEnum);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, boolean signingKey, boolean signAppImage, boolean signPKG, SigningBase.CertIndex certEnum) throws Exception {\n@@ -135,1 +163,1 @@\n-                            \"--mac-signing-keychain\", SigningBase.getKeyChain());\n+                            \"--mac-signing-keychain\", keychain.name());\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTest.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n@@ -25,1 +27,12 @@\n-import jdk.jpackage.test.ApplicationLayout;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n@@ -27,1 +40,6 @@\n-import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.JPackageStringBundle;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacHelper.SignKeyOption;\n+import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.MacSignVerify;\n+import jdk.jpackage.test.PackageFile;\n@@ -30,3 +48,1 @@\n-import jdk.jpackage.test.MacHelper;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.TKit;\n@@ -35,14 +51,6 @@\n- * Note: Testing unsgined app image is done to verify support for per-user\n- * configuration by checking for PackageFile.\n- * Tests generation of dmg and pkg from signed or unsigned predefined app image.\n- * Test will generate pkg and verifies its signature. It verifies that dmg\n- * is not signed, but app image inside dmg is signed or unsigned. This test\n- * requires that the machine is configured with test certificate for\n- * \"Developer ID Installer: jpackage.openjdk.java.net\" in\n- * jpackagerTest keychain with\n- * always allowed access to this keychain for user which runs test.\n- * note:\n- * \"jpackage.openjdk.java.net\" can be over-ridden by systerm property\n- * \"jpackage.mac.signing.key.user.name\", and\n- * \"jpackagerTest\" can be over-ridden by system property\n- * \"jpackage.mac.signing.keychain\"\n+ * Tests packaging of a signed\/unsigned predefined app image into a\n+ * signed\/unsigned .pkg or .dmg package.\n+ *\n+ * <p>\n+ * Prerequisites: A keychain with self-signed certificates as specified in\n+ * {@link SigningBase.StandardKeychain#MAIN}.\n@@ -67,3 +75,23 @@\n-    private static void verifyPKG(JPackageCommand cmd) {\n-        if (!cmd.hasArgument(\"--mac-sign\")) {\n-            return; \/\/ Nothing to check if not signed\n+    @Test\n+    @ParameterSupplier\n+    public static void test(TestSpec spec) {\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            spec.test(keychain);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    public record TestSpec(Optional<SignKeyOption> signAppImage, Map<PackageType, SignKeyOption> signPackage) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(signAppImage);\n+            Objects.requireNonNull(signPackage);\n+\n+            if ((signAppImage.isEmpty() && signPackage.isEmpty()) || !PackageType.MAC.containsAll(signPackage.keySet())) {\n+                \/\/ Unexpected package types.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            \/\/ Ensure stable result of toString() call.\n+            if (!SortedMap.class.isInstance(signPackage)) {\n+                signPackage = new TreeMap<>(signPackage);\n+            }\n@@ -72,4 +100,3 @@\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyPkgutil(outputBundle, true, SigningBase.DEFAULT_INDEX);\n-        SigningBase.verifySpctl(outputBundle, \"install\", SigningBase.DEFAULT_INDEX);\n-    }\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuilder();\n@@ -77,5 +104,3 @@\n-    private static void verifyDMG(JPackageCommand cmd) {\n-        \/\/ DMG always unsigned, so we will check it\n-        Path outputBundle = cmd.outputBundle();\n-        SigningBase.verifyDMG(outputBundle);\n-    }\n+            signAppImage.ifPresent(signOption -> {\n+                sb.append(String.format(\"app-image=%s\", signOption));\n+            });\n@@ -83,13 +108,2 @@\n-    private static void verifyAppImageInDMG(JPackageCommand cmd) {\n-        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n-            \/\/ We will be called with all folders in DMG since JDK-8263155, but\n-            \/\/ we only need to verify app.\n-            if (dmgImage.endsWith(cmd.name() + \".app\")) {\n-                boolean isSigned = cmd.hasArgument(\"--mac-sign\");\n-                Path launcherPath = ApplicationLayout.platformAppImage()\n-                    .resolveAt(dmgImage).launchersDirectory().resolve(cmd.name());\n-                SigningBase.verifyCodesign(launcherPath, isSigned, SigningBase.DEFAULT_INDEX);\n-                SigningBase.verifyCodesign(dmgImage, isSigned, SigningBase.DEFAULT_INDEX);\n-                if (isSigned) {\n-                    SigningBase.verifySpctl(dmgImage, \"exec\", SigningBase.DEFAULT_INDEX);\n-                }\n+            if (!sb.isEmpty() && !signPackage.isEmpty()) {\n+                sb.append(\"; \");\n@@ -97,2 +111,0 @@\n-        });\n-    }\n@@ -100,23 +112,2 @@\n-    @Test\n-    \/\/ (Signed, \"signing-key or sign-identity\"})\n-    \/\/ Signed and signing-key\n-    @Parameter({\"true\", \"true\"})\n-    \/\/ Signed and signing-identity\n-    @Parameter({\"true\", \"false\"})\n-    \/\/ Unsigned\n-    @Parameter({\"false\", \"true\"})\n-    public static void test(boolean signAppImage, boolean signingKey) throws Exception {\n-        Path appimageOutput = TKit.createTempDirectory(\"appimage\");\n-\n-        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", appimageOutput);\n-        if (signAppImage) {\n-            appImageCmd.addArguments(\"--mac-sign\")\n-                       .addArguments(\"--mac-signing-keychain\",\n-                                     SigningBase.getKeyChain());\n-            if (signingKey) {\n-                appImageCmd.addArguments(\"--mac-signing-key-user-name\",\n-                                SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-            } else {\n-                appImageCmd.addArguments(\"--mac-app-image-sign-identity\",\n-                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n+            if (!signPackage.isEmpty()) {\n+                sb.append(signPackage);\n@@ -124,0 +115,6 @@\n+\n+            return sb.toString();\n+        }\n+\n+        boolean signNativeBundle() {\n+            return signPackage.isEmpty();\n@@ -126,36 +123,127 @@\n-        new PackageTest()\n-                .addRunOnceInitializer(() -> appImageCmd.execute())\n-                .forTypes(PackageType.MAC)\n-                .addInitializer(cmd -> {\n-                    cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n-                    cmd.removeArgumentWithValue(\"--input\");\n-                    if (signAppImage) {\n-                        cmd.addArguments(\"--mac-sign\",\n-                                \"--mac-signing-keychain\",\n-                                SigningBase.getKeyChain());\n-                        if (signingKey) {\n-                            cmd.addArguments(\"--mac-signing-key-user-name\",\n-                                    SigningBase.getDevName(SigningBase.DEFAULT_INDEX));\n-                        } else {\n-                            cmd.addArguments(\"--mac-installer-sign-identity\",\n-                                    SigningBase.getInstallerCert(SigningBase.DEFAULT_INDEX));\n-                        }\n-                    }\n-                })\n-                .forTypes(PackageType.MAC_PKG)\n-                .addBundleVerifier(SigningPackageTwoStepTest::verifyPKG)\n-                .forTypes(PackageType.MAC_DMG)\n-                .addInitializer(cmd -> {\n-                    if (signAppImage && !signingKey) {\n-                        \/\/ jpackage throws expected error with\n-                        \/\/ --mac-installer-sign-identity and DMG type\n-                        cmd.removeArgumentWithValue(\"--mac-installer-sign-identity\");\n-                        \/\/ It will do nothing, but it signals test that app\n-                        \/\/ image itself is signed for verification.\n-                        cmd.addArguments(\"--mac-app-image-sign-identity\",\n-                                SigningBase.getAppCert(SigningBase.DEFAULT_INDEX));\n-                    }\n-                })\n-                .addBundleVerifier(SigningPackageTwoStepTest::verifyDMG)\n-                .addBundleVerifier(SigningPackageTwoStepTest::verifyAppImageInDMG)\n-                .run();\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(Optional.ofNullable(signAppImage), signPackage);\n+            }\n+\n+            Builder certRequest(SigningBase.StandardCertificateRequest v) {\n+                return certRequest(v.spec());\n+            }\n+\n+            Builder certRequest(MacSign.CertificateRequest v) {\n+                certRequest = Objects.requireNonNull(v);\n+                return this;\n+            }\n+\n+            Builder signIdentityType(SignKeyOption.Type v) {\n+                signIdentityType = Objects.requireNonNull(v);\n+                return this;\n+            }\n+\n+            Builder signAppImage() {\n+                signAppImage = createSignKeyOption();\n+                return this;\n+            }\n+\n+            Builder signPackage(PackageType type) {\n+                Objects.requireNonNull(type);\n+                signPackage.put(type, createSignKeyOption());\n+                return this;\n+            }\n+\n+            Builder signPackage() {\n+                PackageType.MAC.forEach(this::signPackage);\n+                return this;\n+            }\n+\n+            private SignKeyOption createSignKeyOption() {\n+                return new SignKeyOption(signIdentityType, certRequest);\n+            }\n+\n+            private MacSign.CertificateRequest certRequest = SigningBase.StandardCertificateRequest.CODESIGN.spec();\n+            private SignKeyOption.Type signIdentityType = SignKeyOption.Type.SIGN_KEY_IDENTITY;\n+\n+            private SignKeyOption signAppImage;\n+            private Map<PackageType, SignKeyOption> signPackage = new HashMap<>();\n+        }\n+\n+        void test(MacSign.ResolvedKeychain keychain) {\n+\n+            var appImageCmd = JPackageCommand.helloAppImage().setFakeRuntime();\n+            MacHelper.useKeychain(appImageCmd, keychain);\n+            signAppImage.ifPresent(signOption -> {\n+                signOption.setTo(appImageCmd);\n+            });\n+\n+            var test = new PackageTest();\n+\n+            signAppImage.map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n+                \/\/ The predefined app image is signed, verify bundled app image is signed too.\n+                test.addInstallVerifier(cmd -> {\n+                    MacSignVerify.verifyAppImageSigned(cmd, certRequest, keychain);\n+                });\n+            });\n+\n+            Optional.ofNullable(signPackage.get(PackageType.MAC_PKG)).map(SignKeyOption::certRequest).ifPresent(certRequest -> {\n+                test.forTypes(PackageType.MAC_PKG, () -> {\n+                    test.addBundleVerifier(cmd -> {\n+                        MacSignVerify.verifyPkgSigned(cmd, certRequest, keychain);\n+                    });\n+                });\n+            });\n+\n+            test.forTypes(signPackage.keySet()).addRunOnceInitializer(() -> {\n+                appImageCmd.setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\")).execute(0);\n+            }).addInitializer(cmd -> {\n+                MacHelper.useKeychain(cmd, keychain);\n+                cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n+                cmd.removeArgumentWithValue(\"--input\");\n+                Optional.ofNullable(signPackage.get(cmd.packageType())).ifPresent(signOption -> {\n+                    signOption.setTo(cmd);\n+                });\n+\n+                if (signAppImage.isPresent()) {\n+                    \/\/ Predefined app image is signed. Expect a warning.\n+                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\n+                            \"warning.per.user.app.image.signed\",\n+                            PackageFile.getPathInAppImage(Path.of(\"\"))));\n+                } else if (cmd.packageType() == PackageType.MAC_PKG && signPackage.containsKey(cmd.packageType())) {\n+                    \/\/ Create signed \".pkg\" bundle from the unsigned predefined app image. Expect a warning.\n+                    cmd.validateOutput(JPackageStringBundle.MAIN.cannedFormattedString(\"warning.unsigned.app.image\", \"pkg\"));\n+                }\n+            })\n+            .run();\n+        }\n+    }\n+\n+    public static Collection<Object[]> test() {\n+\n+        List<TestSpec.Builder> data = new ArrayList<>();\n+\n+        Stream.of(SignKeyOption.Type.values()).flatMap(signIdentityType -> {\n+            return Stream.of(\n+                    \/\/ Sign both predefined app image and native package.\n+                    TestSpec.build().signIdentityType(signIdentityType)\n+                            .signAppImage()\n+                            .signPackage()\n+                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n+                            .signPackage(PackageType.MAC_PKG),\n+\n+                    \/\/ Don't sign predefined app image, sign native package.\n+                    TestSpec.build().signIdentityType(signIdentityType)\n+                            .signPackage()\n+                            .certRequest(SigningBase.StandardCertificateRequest.PKG)\n+                            .signPackage(PackageType.MAC_PKG),\n+\n+                    \/\/ Sign predefined app image, don't sign native package.\n+                    TestSpec.build().signIdentityType(signIdentityType).signAppImage()\n+            );\n+        }).forEach(data::add);\n+\n+        return data.stream().map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningPackageTwoStepTest.java","additions":194,"deletions":106,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.MacSign;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.TKit;\n+\n+\/**\n+ * Tests generation of dmg and pkg with --mac-sign and related arguments. Test\n+ * will generate pkg and verifies its signature. It verifies that dmg is not\n+ * signed, but runtime image inside dmg is signed.\n+ *\n+ * <p>\n+ * Note: Specific UNICODE signing is not tested, since it is shared code with\n+ * app image signing and it will be covered by SigningPackageTest.\n+ *\n+ * <p>\n+ * Following combinations are tested:\n+ * <ol>\n+ * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is not\n+ * provided. Expected result: runtime image ad-hoc signed.\n+ * <li>\"--runtime-image\" points to unsigned JDK bundle and --mac-sign is\n+ * provided. Expected result: Everything is signed with provided certificate.\n+ * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is not\n+ * provided. Expected result: runtime image is signed with original certificate.\n+ * <li>\"--runtime-image\" points to signed JDK bundle and --mac-sign is provided.\n+ * Expected result: runtime image is signed with provided certificate.\n+ * <li>\"--runtime-image\" points to JDK image and --mac-sign is not provided.\n+ * Expected result: runtime image ad-hoc signed.\n+ * <li>\"--runtime-image\" points to JDK image and --mac-sign is provided.\n+ * Expected result: Everything is signed with provided certificate.\n+ * <\/ol>\n+ *\n+ * This test requires that the machine is configured with test certificate for\n+ * \"Developer ID Installer: jpackage.openjdk.java.net\" in jpackagerTest keychain\n+ * with always allowed access to this keychain for user which runs test. note:\n+ * \"jpackage.openjdk.java.net\" can be over-ridden by system property\n+ * \"jpackage.mac.signing.key.user.name\"\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with --type pkg,dmg --runtime-image --mac-sign\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @library base\n+ * @key jpackagePlatformPackage\n+ * @build SigningBase\n+ * @build jdk.jpackage.test.*\n+ * @build SigningRuntimeImagePackageTest\n+ * @requires (jpackage.test.MacSignTests == \"run\")\n+ * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=SigningRuntimeImagePackageTest\n+ *  --jpt-before-run=SigningBase.verifySignTestEnvReady\n+ *\/\n+public class SigningRuntimeImagePackageTest {\n+\n+    private static JPackageCommand addSignOptions(JPackageCommand cmd, MacSign.ResolvedKeychain keychain, int certIndex) {\n+        if (certIndex != SigningBase.CertIndex.INVALID_INDEX.value()) {\n+            cmd.addArguments(\n+                    \"--mac-sign\",\n+                    \"--mac-signing-keychain\", keychain.name(),\n+                    \"--mac-signing-key-user-name\", SigningBase.getDevName(certIndex));\n+        }\n+        return cmd;\n+    }\n+\n+    private static Path createInputRuntimeBundle(MacSign.ResolvedKeychain keychain, int certIndex) throws IOException {\n+\n+        final var runtimeImage = JPackageCommand.createInputRuntimeImage();\n+\n+        final var runtimeBundleWorkDir = TKit.createTempDirectory(\"runtime-bundle\");\n+\n+        final var unpackadeRuntimeBundleDir = runtimeBundleWorkDir.resolve(\"unpacked\");\n+\n+        var cmd = new JPackageCommand()\n+                .useToolProvider(true)\n+                .ignoreDefaultRuntime(true)\n+                .dumpOutput(true)\n+                .setPackageType(PackageType.MAC_DMG)\n+                .setArgumentValue(\"--name\", \"foo\")\n+                .addArguments(\"--runtime-image\", runtimeImage)\n+                .addArguments(\"--dest\", runtimeBundleWorkDir);\n+\n+        addSignOptions(cmd, keychain, certIndex);\n+\n+        cmd.execute();\n+\n+        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n+            if (dmgImage.endsWith(cmd.appInstallationDirectory().getFileName())) {\n+                Executor.of(\"cp\", \"-R\")\n+                        .addArgument(dmgImage)\n+                        .addArgument(unpackadeRuntimeBundleDir)\n+                        .execute(0);\n+            }\n+        });\n+\n+        return unpackadeRuntimeBundleDir;\n+    }\n+\n+    @Test\n+    \/\/ useJDKBundle  - If \"true\" predefined runtime image will be converted to\n+    \/\/                 JDK bundle. If \"false\" JDK image will be used.\n+    \/\/ JDKBundleCert - Certificate to sign JDK bundle before calling jpackage.\n+    \/\/ signCert      - Certificate to sign bundle produced by jpackage.\n+    \/\/ 1) unsigned JDK bundle and --mac-sign is not provided\n+    @Parameter({\"true\", \"INVALID_INDEX\", \"INVALID_INDEX\"})\n+    \/\/ 2) unsigned JDK bundle and --mac-sign is provided\n+    @Parameter({\"true\", \"INVALID_INDEX\", \"ASCII_INDEX\"})\n+    \/\/ 3) signed JDK bundle and --mac-sign is not provided\n+    @Parameter({\"true\", \"UNICODE_INDEX\", \"INVALID_INDEX\"})\n+    \/\/ 4) signed JDK bundle and --mac-sign is provided\n+    @Parameter({\"true\", \"UNICODE_INDEX\", \"ASCII_INDEX\"})\n+    \/\/ 5) JDK image and --mac-sign is not provided\n+    @Parameter({\"false\", \"INVALID_INDEX\", \"INVALID_INDEX\"})\n+    \/\/ 6) JDK image and --mac-sign is provided\n+    @Parameter({\"false\", \"INVALID_INDEX\", \"ASCII_INDEX\"})\n+    public static void test(boolean useJDKBundle,\n+                            SigningBase.CertIndex jdkBundleCert,\n+                            SigningBase.CertIndex signCert) throws Exception {\n+        MacSign.withKeychain(toConsumer(keychain -> {\n+            test(keychain, useJDKBundle, jdkBundleCert, signCert);\n+        }), SigningBase.StandardKeychain.MAIN.keychain());\n+    }\n+\n+    private static void test(MacSign.ResolvedKeychain keychain, boolean useJDKBundle,\n+            SigningBase.CertIndex jdkBundleCert,\n+            SigningBase.CertIndex signCert) throws Exception {\n+\n+        final Path inputRuntime[] = new Path[1];\n+\n+        new PackageTest()\n+                .addRunOnceInitializer(() -> {\n+                    if (useJDKBundle) {\n+                        inputRuntime[0] = createInputRuntimeBundle(keychain, jdkBundleCert.value());\n+                    } else {\n+                        inputRuntime[0] = JPackageCommand.createInputRuntimeImage();\n+                    }\n+                })\n+                .addInitializer(cmd -> {\n+                    cmd.addArguments(\"--runtime-image\", inputRuntime[0]);\n+                    \/\/ Remove --input parameter from jpackage command line as we don't\n+                    \/\/ create input directory in the test and jpackage fails\n+                    \/\/ if --input references non existent directory.\n+                    cmd.removeArgumentWithValue(\"--input\");\n+                    addSignOptions(cmd, keychain, signCert.value());\n+                })\n+                .addInstallVerifier(cmd -> {\n+                    final var certIndex = Stream.of(signCert, jdkBundleCert)\n+                            .filter(Predicate.isEqual(SigningBase.CertIndex.INVALID_INDEX).negate())\n+                            .findFirst().orElse(SigningBase.CertIndex.INVALID_INDEX).value();\n+\n+                    final var signed = certIndex != SigningBase.CertIndex.INVALID_INDEX.value();\n+\n+                    final var unfoldedBundleDir = cmd.appRuntimeDirectory();\n+\n+                    final var libjli = unfoldedBundleDir.resolve(\"Contents\/MacOS\/libjli.dylib\");\n+\n+                    SigningBase.verifyCodesign(libjli, signed, certIndex);\n+                    SigningBase.verifyCodesign(unfoldedBundleDir, signed, certIndex);\n+                    if (signed) {\n+                        SigningBase.verifySpctl(unfoldedBundleDir, \"exec\", certIndex);\n+                    }\n+                })\n+                .run();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/SigningRuntimeImagePackageTest.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -93,0 +93,3 @@\n+    \/**\n+     * Standard keychains used in signing tests.\n+     *\/\n@@ -94,1 +97,4 @@\n-        MAIN(DEFAULT_KEYCHAIN,\n+        \/**\n+         * The primary keychain with good certificates.\n+         *\/\n+        MAIN(\"jpackagerTest.keychain\",\n@@ -99,0 +105,3 @@\n+        \/**\n+         * A keychain with some good and some expired certificates.\n+         *\/\n@@ -104,0 +113,3 @@\n+        \/**\n+         * A keychain with duplicated certificates.\n+         *\/\n@@ -117,1 +129,1 @@\n-            this.spec = new ResolvedKeychain(builder.create());\n+            this.keychain = new ResolvedKeychain(builder.create());\n@@ -120,2 +132,2 @@\n-        public KeychainWithCertsSpec spec() {\n-            return spec.spec();\n+        public ResolvedKeychain keychain() {\n+            return keychain;\n@@ -125,1 +137,1 @@\n-            return Objects.requireNonNull(spec.mapCertificateRequests().get(certRequest));\n+            return Objects.requireNonNull(keychain.mapCertificateRequests().get(certRequest));\n@@ -132,4 +144,0 @@\n-        private static CertificateRequest.Builder cert() {\n-            return new CertificateRequest.Builder();\n-        }\n-\n@@ -137,1 +145,1 @@\n-            return Stream.of(values()).map(StandardKeychain::spec).toList();\n+            return Stream.of(values()).map(StandardKeychain::keychain).map(ResolvedKeychain::spec).toList();\n@@ -140,1 +148,1 @@\n-        private final ResolvedKeychain spec;\n+        private final ResolvedKeychain keychain;\n@@ -182,1 +190,0 @@\n-    private static String DEFAULT_KEYCHAIN = \"jpackagerTest.keychain\";\n@@ -198,10 +205,0 @@\n-    \/\/ Returns 'true' if dev name from DEV_NAMES\n-    public static boolean isDevNameDefault() {\n-        String value = System.getProperty(\"jpackage.mac.signing.key.user.name\");\n-        if (value != null) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n@@ -216,10 +213,0 @@\n-    public static String getKeyChain() {\n-        \/\/ Always use values from system properties if set\n-        String value = System.getProperty(\"jpackage.mac.signing.keychain\");\n-        if (value != null) {\n-            return value;\n-        }\n-\n-        return DEFAULT_KEYCHAIN;\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/base\/SigningBase.java","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.LinkedHashMap;\n@@ -32,0 +33,1 @@\n+import java.util.Map;\n@@ -34,0 +36,1 @@\n+import java.util.stream.Collectors;\n@@ -40,0 +43,1 @@\n+import jdk.jpackage.test.HelloApp;\n@@ -41,0 +45,1 @@\n+import jdk.jpackage.test.JavaAppDesc;\n@@ -66,0 +71,1 @@\n+ * @requires (os.family != \"mac\")\n@@ -79,0 +85,1 @@\n+ * @requires (os.family != \"mac\")\n@@ -88,1 +95,1 @@\n-    @Test\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n@@ -96,0 +103,2 @@\n+        final var packageName = MethodHandles.lookup().lookupClass().getSimpleName();\n+\n@@ -105,0 +114,5 @@\n+\n+            cmd.setArgumentValue(\"--name\", packageName);\n+\n+            var addLauncherApp = TKit.TEST_SRC_ROOT.resolve(\"apps\/PrintEnv.java\");\n+            HelloApp.createBundle(JavaAppDesc.parse(addLauncherApp + \"*another.jar:Welcome\"), cmd.inputDir());\n@@ -107,3 +121,7 @@\n-        new FileAssociations(\n-                MethodHandles.lookup().lookupClass().getSimpleName()).applyTo(\n-                packageTest);\n+        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n+            \/\/ Ensure launchers are executable because the output bundle will be installed\n+            \/\/ and launchers will be attempted to be executed through their shortcuts.\n+            packageTest.addInitializer(JPackageCommand::ignoreFakeRuntime);\n+        }\n+\n+        new FileAssociations(packageName).applyTo(packageTest);\n@@ -134,2 +152,2 @@\n-        new AdditionalLauncher(\"Launcher5\")\n-                .setDefaultArguments()\n+        var launcher5 = new AdditionalLauncher(\"Launcher5\")\n+                .setDefaultArguments(\"--print-workdir\")\n@@ -137,2 +155,7 @@\n-                .setShortcuts(false, true)\n-                .applyTo(packageTest);\n+                .setShortcut(LauncherShortcut.LINUX_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_DESKTOP_SHORTCUT, StartupDirectory.APP_DIR)\n+                .setShortcut(LauncherShortcut.WIN_START_MENU_SHORTCUT, null)\n+                .setProperty(\"main-jar\", \"another.jar\")\n+                .setProperty(\"main-class\", \"Welcome\");\n+\n+        new ShortcutStartupDirectoryVerifier(packageName).add(launcher5).applyTo(packageTest);\n@@ -193,0 +216,1 @@\n+            cfgs[0].applyToMainLauncher(cmd);\n@@ -196,1 +220,40 @@\n-            cfgs[0].applyToMainLauncher(cmd);\n+        }).run(RunnablePackageTest.Action.CREATE_AND_UNPACK);\n+    }\n+\n+    @Test(ifNotOS = OperatingSystem.MACOS)\n+    @Parameter(value = \"DEFAULT\")\n+    @Parameter(value = \"APP_DIR\")\n+    public void testLastArg(StartupDirectory startupDirectory) {\n+        final List<String> shortcutArgs = new ArrayList<>();\n+        if (TKit.isLinux()) {\n+            shortcutArgs.add(\"--linux-shortcut\");\n+        } else if (TKit.isWindows()) {\n+            shortcutArgs.add(\"--win-shortcut\");\n+        } else {\n+            TKit.assertUnexpected(\"Unsupported platform\");\n+        }\n+\n+        if (startupDirectory == StartupDirectory.APP_DIR) {\n+            shortcutArgs.add(startupDirectory.asStringValue());\n+        }\n+\n+        Path[] predefinedAppImage = new Path[1];\n+\n+        new PackageTest().addRunOnceInitializer(() -> {\n+            var cmd = JPackageCommand.helloAppImage()\n+                    .setArgumentValue(\"--name\", \"foo\")\n+                    .setFakeRuntime();\n+\n+            cmd.execute();\n+\n+            predefinedAppImage[0] = cmd.outputBundle();\n+        }).addInitializer(cmd -> {\n+            cmd.removeArgumentWithValue(\"--input\");\n+            cmd.setArgumentValue(\"--name\", \"AddLShortcutDir3Test\");\n+            cmd.addArguments(\"--app-image\", predefinedAppImage[0]);\n+            cmd.ignoreDefaultVerbose(true);\n+        }).addInitializer(cmd -> {\n+            cmd.addArguments(shortcutArgs);\n+        }).addBundleVerifier(cmd -> {\n+            TKit.assertEquals(shortcutArgs.getLast(), cmd.getAllArguments().getLast(),\n+                    \"Check the last argument of jpackage command line\");\n@@ -210,0 +273,1 @@\n+    @Parameter(value = \"APP_DIR\")\n@@ -222,17 +286,1 @@\n-        var shortcutStartupDirectoryVerifier = new ShortcutStartupDirectoryVerifier(name, \"a\");\n-\n-        shortcutStartupDirectoryVerifier.applyTo(test, startupDirectory);\n-\n-        test.addInstallVerifier(cmd -> {\n-            if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n-                Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n-                if (TKit.isLinux()) {\n-                    invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n-                } else if (TKit.isWindows()) {\n-                    invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n-                } else {\n-                    throw new UnsupportedOperationException();\n-                }\n-                shortcutStartupDirectoryVerifier.verify(invokeShortcutSpecs);\n-            }\n-        });\n+        new ShortcutStartupDirectoryVerifier(name).add(\"a\", startupDirectory).applyTo(test);\n@@ -244,4 +292,4 @@\n-    private record ShortcutStartupDirectoryVerifier(String packageName, String launcherName) {\n-        ShortcutStartupDirectoryVerifier {\n-            Objects.requireNonNull(packageName);\n-            Objects.requireNonNull(launcherName);\n+    private static final class ShortcutStartupDirectoryVerifier {\n+\n+        ShortcutStartupDirectoryVerifier(String packageName) {\n+            this.packageName = Objects.requireNonNull(packageName);\n@@ -250,6 +298,33 @@\n-        void applyTo(PackageTest test, StartupDirectory startupDirectory) {\n-            var al = new AdditionalLauncher(launcherName);\n-            al.setShortcut(shortcut(), Objects.requireNonNull(startupDirectory));\n-            al.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n-                    outputDirVarName(), expectedOutputFilename()));\n-            al.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+        void applyTo(PackageTest test) {\n+            verifiers.values().forEach(verifier -> {\n+                verifier.applyTo(test);\n+            });\n+            test.addInstallVerifier(cmd -> {\n+                if (!cmd.isPackageUnpacked(\"Not invoking launcher shortcuts\")) {\n+                    Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs;\n+                    if (TKit.isLinux()) {\n+                        invokeShortcutSpecs = LinuxHelper.getInvokeShortcutSpecs(cmd);\n+                    } else if (TKit.isWindows()) {\n+                        invokeShortcutSpecs = WinShortcutVerifier.getInvokeShortcutSpecs(cmd);\n+                    } else {\n+                        throw new UnsupportedOperationException();\n+                    }\n+\n+                    var invokeShortcutSpecsMap = invokeShortcutSpecs.stream().collect(Collectors.groupingBy(InvokeShortcutSpec::launcherName));\n+\n+                    for (var e : verifiers.entrySet()) {\n+                        e.getValue().verify(invokeShortcutSpecsMap.get(e.getKey()));\n+                    }\n+                }\n+            });\n+        }\n+\n+        ShortcutStartupDirectoryVerifier add(String launcherName, StartupDirectory startupDirectory) {\n+            return add(new AdditionalLauncher(launcherName)\n+                    .setShortcut(shortcut(), Objects.requireNonNull(Objects.requireNonNull(startupDirectory))));\n+        }\n+\n+        ShortcutStartupDirectoryVerifier add(AdditionalLauncher addLauncher) {\n+            var launcherVerifier = new LauncherVerifier(addLauncher);\n+            verifiers.put(launcherVerifier.launcherName(), launcherVerifier);\n+            return this;\n@@ -258,1 +333,0 @@\n-        void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n@@ -260,1 +334,1 @@\n-            TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName));\n+        private final class LauncherVerifier {\n@@ -262,1 +336,13 @@\n-            var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n+            private LauncherVerifier(AdditionalLauncher addLauncher) {\n+                this.addLauncher = Objects.requireNonNull(addLauncher);\n+            }\n+\n+            private String launcherName() {\n+                return addLauncher.name();\n+            }\n+\n+            private void applyTo(PackageTest test) {\n+                addLauncher.addJavaOptions(String.format(\"-Djpackage.test.appOutput=${%s}\/%s\",\n+                        outputDirVarName(), expectedOutputFilename()));\n+                addLauncher.withoutVerifyActions(Action.EXECUTE_LAUNCHER).applyTo(test);\n+            }\n@@ -264,1 +350,5 @@\n-            TKit.deleteIfExists(expectedOutputFile);\n+            private void verify(Collection<? extends InvokeShortcutSpec> invokeShortcutSpecs) throws IOException {\n+                Objects.requireNonNull(invokeShortcutSpecs);\n+                if (invokeShortcutSpecs.isEmpty()) {\n+                    throw new IllegalArgumentException();\n+                }\n@@ -266,3 +356,1 @@\n-            var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n-                return launcherName.equals(v.launcherName());\n-            }).findAny().orElseThrow();\n+                TKit.trace(String.format(\"Verify shortcut [%s]\", launcherName()));\n@@ -270,1 +358,1 @@\n-            invokeShortcutSpec.execute();\n+                var expectedOutputFile = Path.of(System.getenv(outputDirVarName())).resolve(expectedOutputFilename());\n@@ -272,3 +360,1 @@\n-            \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n-            \/\/ way to make it wait for exit of a process it triggers.\n-            TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n+                TKit.deleteIfExists(expectedOutputFile);\n@@ -276,2 +362,3 @@\n-            TKit.assertFileExists(expectedOutputFile);\n-            var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n+                var invokeShortcutSpec = invokeShortcutSpecs.stream().filter(v -> {\n+                    return launcherName().equals(v.launcherName());\n+                }).findAny().orElseThrow();\n@@ -279,1 +366,1 @@\n-            var outputPrefix = \"$CD=\";\n+                invokeShortcutSpec.execute();\n@@ -281,1 +368,3 @@\n-            TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+                \/\/ On Linux, \"gtk-launch\" is used to launch a .desktop file. It is async and there is no\n+                \/\/ way to make it wait for exit of a process it triggers.\n+                TKit.waitForFileCreated(expectedOutputFile, Duration.ofSeconds(10), Duration.ofSeconds(3));\n@@ -283,9 +372,2 @@\n-            invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n-                TKit.assertEquals(\n-                        expectedWorkDirectory,\n-                        Path.of(actualStr.substring(outputPrefix.length())),\n-                        String.format(\"Check work directory of %s of launcher [%s]\",\n-                                invokeShortcutSpec.shortcut().propertyName(),\n-                                invokeShortcutSpec.launcherName()));\n-            });\n-        }\n+                TKit.assertFileExists(expectedOutputFile);\n+                var actualStr = Files.readAllLines(expectedOutputFile).getFirst();\n@@ -293,2 +375,19 @@\n-        private String expectedOutputFilename() {\n-            return String.format(\"%s-%s.out\", packageName, launcherName);\n+                var outputPrefix = \"$CD=\";\n+\n+                TKit.assertTrue(actualStr.startsWith(outputPrefix), \"Check output starts with '\" + outputPrefix+ \"' string\");\n+\n+                invokeShortcutSpec.expectedWorkDirectory().ifPresent(expectedWorkDirectory -> {\n+                    TKit.assertEquals(\n+                            expectedWorkDirectory,\n+                            Path.of(actualStr.substring(outputPrefix.length())),\n+                            String.format(\"Check work directory of %s of launcher [%s]\",\n+                                    invokeShortcutSpec.shortcut().propertyName(),\n+                                    invokeShortcutSpec.launcherName()));\n+                });\n+            }\n+\n+            private String expectedOutputFilename() {\n+                return String.format(\"%s-%s.out\", packageName, launcherName());\n+            }\n+\n+            private final AdditionalLauncher addLauncher;\n@@ -297,1 +396,2 @@\n-        private String outputDirVarName() {\n+\n+        private static String outputDirVarName() {\n@@ -307,1 +407,1 @@\n-        private LauncherShortcut shortcut() {\n+        private static LauncherShortcut shortcut() {\n@@ -316,0 +416,4 @@\n+\n+        private final String packageName;\n+        \/\/ Keep the order\n+        private final Map<String, LauncherVerifier> verifiers = new LinkedHashMap<>();\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLShortcutTest.java","additions":168,"deletions":64,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import java.nio.file.Path;\n-import java.util.Map;\n@@ -27,2 +25,3 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.FileAssociations;\n+import java.nio.file.Path;\n+import java.util.function.Consumer;\n+import jdk.internal.util.OperatingSystem;\n@@ -30,0 +29,5 @@\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.CfgFile;\n+import jdk.jpackage.test.ConfigurationTarget;\n+import jdk.jpackage.test.FileAssociations;\n@@ -32,0 +36,3 @@\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n@@ -33,3 +40,0 @@\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import jdk.jpackage.test.CfgFile;\n@@ -236,0 +240,55 @@\n+    \/**\n+     * Test --description option\n+     *\/\n+    @Test(ifNotOS = OperatingSystem.MACOS) \/\/ Don't run on macOS as launcher description is ignored on this platform\n+    @Parameter(\"true\")\n+    @Parameter(\"fase\")\n+    public void testDescription(boolean withPredefinedAppImage) {\n+\n+        ConfigurationTarget target;\n+        if (TKit.isWindows() || withPredefinedAppImage) {\n+            target = new ConfigurationTarget(JPackageCommand.helloAppImage());\n+        } else {\n+            target = new ConfigurationTarget(new PackageTest().configureHelloApp());\n+        }\n+\n+        target.addInitializer(cmd -> {\n+            cmd.setArgumentValue(\"--name\", \"Foo\").setArgumentValue(\"--description\", \"Hello\");\n+            cmd.setFakeRuntime();\n+            cmd.setStandardAsserts(JPackageCommand.StandardAssert.MAIN_LAUNCHER_DESCRIPTION);\n+        });\n+\n+        target.add(new AdditionalLauncher(\"x\"));\n+        target.add(new AdditionalLauncher(\"bye\").setProperty(\"description\", \"Bye\"));\n+\n+        target.test().ifPresent(test -> {\n+            \/\/ Make all launchers have shortcuts and thus .desktop files.\n+            \/\/ Launcher description is recorded in a desktop file and verified automatically.\n+            test.mutate(addLinuxShortcuts());\n+        });\n+\n+        target.cmd().ifPresent(withPredefinedAppImage ? JPackageCommand::execute : JPackageCommand::executeAndAssertImageCreated);\n+        target.test().ifPresent(test -> {\n+            test.run(Action.CREATE_AND_UNPACK);\n+        });\n+\n+        if (withPredefinedAppImage) {\n+            new PackageTest().addInitializer(cmd -> {\n+                cmd.setArgumentValue(\"--name\", \"Bar\");\n+                \/\/ Should not have impact of launcher descriptions, but it does.\n+                cmd.setArgumentValue(\"--description\", \"Installer\");\n+                cmd.removeArgumentWithValue(\"--input\").setArgumentValue(\"--app-image\", target.cmd().orElseThrow().outputBundle());\n+            }).mutate(addLinuxShortcuts()).run(Action.CREATE_AND_UNPACK);\n+        }\n+    }\n+\n+    private static Consumer<PackageTest> addLinuxShortcuts() {\n+        return test -> {\n+            test.forTypes(PackageType.LINUX, () -> {\n+                test.addInitializer(cmd -> {\n+                    cmd.addArgument(\"--linux-shortcut\");\n+                });\n+            });\n+        };\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":66,"deletions":7,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -24,2 +24,1 @@\n-import static jdk.internal.util.OperatingSystem.LINUX;\n-import static jdk.internal.util.OperatingSystem.MACOS;\n+import static java.util.Map.entry;\n@@ -27,0 +26,4 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.util.OperatingSystem.MACOS;\n+import static jdk.internal.util.OperatingSystem.WINDOWS;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -29,0 +32,1 @@\n+import java.io.UncheckedIOException;\n@@ -30,0 +34,1 @@\n+import java.nio.file.NoSuchFileException;\n@@ -31,5 +36,1 @@\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.Annotations.Test;\n-import jdk.jpackage.test.Annotations.Parameter;\n-import java.util.Arrays;\n+import java.util.ArrayList;\n@@ -37,0 +38,1 @@\n+import java.util.HashSet;\n@@ -38,0 +40,7 @@\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n@@ -39,0 +48,1 @@\n+import java.util.stream.StreamSupport;\n@@ -40,1 +50,6 @@\n-import jdk.jpackage.internal.util.function.ThrowingFunction;\n+import jdk.jpackage.internal.util.IdentityWrapper;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.ConfigurationTarget;\n@@ -42,0 +57,4 @@\n+import jdk.jpackage.test.JPackageStringBundle;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.TKit;\n@@ -60,5 +79,6 @@\n-    private static final String TEST_JAVA = \"apps\/PrintEnv.java\";\n-    private static final String TEST_DUKE = \"apps\/dukeplug.png\";\n-    private static final String TEST_DUKE_LINK = \"dukeplugLink.txt\";\n-    private static final String TEST_DIR = \"apps\";\n-    private static final String TEST_BAD = \"non-existant\";\n+    @Test\n+    @ParameterSupplier\n+    @ParameterSupplier(value=\"testSymlink\", ifNotOS = WINDOWS)\n+    public void test(TestSpec testSpec) throws Exception {\n+        testSpec.test(new ConfigurationTarget(new PackageTest().configureHelloApp()));\n+    }\n@@ -66,7 +86,6 @@\n-    \/\/ On OSX `--app-content` paths will be copied into the \"Contents\" folder\n-    \/\/ of the output app image.\n-    \/\/ \"codesign\" imposes restrictions on the directory structure of \"Contents\" folder.\n-    \/\/ In particular, random files should be placed in \"Contents\/Resources\" folder\n-    \/\/ otherwise \"codesign\" will fail to sign.\n-    \/\/ Need to prepare arguments for `--app-content` accordingly.\n-    private static final boolean copyInResources = TKit.isOSX();\n+    @Test\n+    @ParameterSupplier(\"test\")\n+    @ParameterSupplier(value=\"testSymlink\", ifNotOS = WINDOWS)\n+    public void testAppImage(TestSpec testSpec) throws Exception {\n+        testSpec.test(new ConfigurationTarget(JPackageCommand.helloAppImage()));\n+    }\n@@ -74,2 +93,7 @@\n-    private static final String RESOURCES_DIR = \"Resources\";\n-    private static final String LINKS_DIR = \"Links\";\n+    @Test(ifOS = MACOS)\n+    @Parameter({\"apps\", \"warning.non.standard.contents.sub.dir\"})\n+    @Parameter({\"apps\/dukeplug.png\", \"warning.app.content.is.not.dir\"})\n+    public void testWarnings(String testPath, String warningId) throws Exception {\n+        final var appContentValue = TKit.TEST_SRC_ROOT.resolve(testPath);\n+        final var expectedWarning = JPackageStringBundle.MAIN.cannedFormattedString(\n+                warningId, appContentValue);\n@@ -77,35 +101,159 @@\n-    @Test\n-    \/\/ include two files in two options\n-    @Parameter({TEST_JAVA, TEST_DUKE})\n-    \/\/ try to include non-existant content\n-    @Parameter({TEST_JAVA, TEST_BAD})\n-     \/\/ two files in one option and a dir tree in another option.\n-    @Parameter({TEST_JAVA + \",\" + TEST_DUKE, TEST_DIR})\n-     \/\/ include one file and one link to the file\n-    @Parameter(value = {TEST_JAVA, TEST_DUKE_LINK}, ifOS = {MACOS,LINUX})\n-    public void test(String... args) throws Exception {\n-        final List<String> testPathArgs = List.of(args);\n-        final int expectedJPackageExitCode;\n-        if (testPathArgs.contains(TEST_BAD)) {\n-            expectedJPackageExitCode = 1;\n-        } else {\n-            expectedJPackageExitCode = 0;\n-        }\n-\n-        var appContentInitializer = new AppContentInitializer(testPathArgs);\n-\n-        new PackageTest().configureHelloApp()\n-            .addRunOnceInitializer(appContentInitializer::initAppContent)\n-            .addInitializer(appContentInitializer::applyTo)\n-            .addInstallVerifier(cmd -> {\n-                for (String arg : testPathArgs) {\n-                    List<String> paths = Arrays.asList(arg.split(\",\"));\n-                    for (String p : paths) {\n-                        Path name = Path.of(p).getFileName();\n-                        if (isSymlinkPath(name)) {\n-                            TKit.assertSymbolicLinkExists(getAppContentRoot(cmd)\n-                                .resolve(LINKS_DIR).resolve(name));\n-                        } else {\n-                            TKit.assertPathExists(getAppContentRoot(cmd)\n-                                .resolve(name), true);\n-                        }\n+        JPackageCommand.helloAppImage()\n+            .addArguments(\"--app-content\", appContentValue)\n+            .setFakeRuntime()\n+            .validateOutput(expectedWarning)\n+            .executeIgnoreExitCode();\n+    }\n+\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+                build().add(TEST_JAVA).add(TEST_DUKE),\n+                build().add(TEST_JAVA).add(TEST_BAD),\n+                build().startGroup().add(TEST_JAVA).add(TEST_DUKE).endGroup().add(TEST_DIR),\n+                \/\/ Same directory specified multiple times.\n+                build().add(TEST_DIR).add(TEST_DIR),\n+                \/\/ Same file specified multiple times.\n+                build().add(TEST_JAVA).add(TEST_JAVA),\n+                \/\/ Two files with the same name but different content.\n+                build()\n+                        .add(createTextFileContent(\"welcome.txt\", \"Welcome\"))\n+                        .add(createTextFileContent(\"welcome.txt\", \"Benvenuti\")),\n+                \/\/ Same name: one is a directory, another is a file.\n+                build().add(createTextFileContent(\"a\/b\/c\/d\", \"Foo\")).add(createTextFileContent(\"a\", \"Bar\")),\n+                \/\/ Same name: one is a file, another is a directory.\n+                build().add(createTextFileContent(\"a\", \"Bar\")).add(createTextFileContent(\"a\/b\/c\/d\", \"Foo\"))\n+        ).map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    public static Collection<Object[]> testSymlink() {\n+        return Stream.of(\n+                build().add(TEST_JAVA)\n+                        .add(new SymlinkContentFactory(\"Links\", \"duke-link\", \"duke-target\"))\n+                        .add(new SymlinkContentFactory(\"\", \"a\/b\/foo-link\", \"c\/bar-target\"))\n+        ).map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    public record TestSpec(List<List<ContentFactory>> contentFactories) {\n+        public TestSpec {\n+            contentFactories.stream().flatMap(List::stream).forEach(Objects::requireNonNull);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return contentFactories.stream().map(group -> {\n+                return group.stream().map(ContentFactory::toString).collect(joining(\",\"));\n+            }).collect(joining(\"; \"));\n+        }\n+\n+        void test(ConfigurationTarget target) {\n+            final int expectedJPackageExitCode;\n+            if (contentFactories.stream().flatMap(List::stream).anyMatch(TEST_BAD::equals)) {\n+                expectedJPackageExitCode = 1;\n+            } else {\n+                expectedJPackageExitCode = 0;\n+            }\n+\n+            final List<List<Content>> allContent = new ArrayList<>();\n+\n+            target.addInitializer(JPackageCommand::setFakeRuntime)\n+            .addRunOnceInitializer(_ -> {\n+                contentFactories.stream().map(group -> {\n+                    return group.stream().map(ContentFactory::create).toList();\n+                }).forEach(allContent::add);\n+            }).addInitializer(cmd -> {\n+                allContent.stream().map(group -> {\n+                    return Stream.of(\"--app-content\", group.stream()\n+                            .map(Content::paths)\n+                            .flatMap(List::stream)\n+                            .map(appContentArg -> {\n+                                if (COPY_IN_RESOURCES && Optional.ofNullable(appContentArg.getParent())\n+                                        .map(Path::getFileName)\n+                                        .map(RESOURCES_DIR::equals)\n+                                        .orElse(false)) {\n+                                    return appContentArg.getParent();\n+                                } else {\n+                                    return appContentArg;\n+                                }\n+                            })\n+                            .map(Path::toString)\n+                            .collect(joining(\",\")));\n+                    }).flatMap(x -> x).forEachOrdered(cmd::addArgument);\n+            });\n+\n+            target.cmd().ifPresent(cmd -> {\n+                if (expectedJPackageExitCode == 0) {\n+                    cmd.executeAndAssertImageCreated();\n+                } else {\n+                    cmd.execute(expectedJPackageExitCode);\n+                }\n+            });\n+\n+            target.addInstallVerifier(cmd -> {\n+                var appContentRoot = getAppContentRoot(cmd);\n+\n+                Set<PathVerifier> disabledVerifiers = new HashSet<>();\n+\n+                var verifiers = allContent.stream().flatMap(List::stream).flatMap(content -> {\n+                    return StreamSupport.stream(content.verifiers(appContentRoot).spliterator(), false).map(verifier -> {\n+                        return new PathVerifierWithOrigin(verifier, content);\n+                    });\n+                }).collect(toMap(PathVerifierWithOrigin::path, x -> x, (first, second) -> {\n+                    \/\/ The same file in the content directory is sourced from multiple origins.\n+                    \/\/ jpackage will handle this case such that the following origins overwrite preceding origins.\n+                    \/\/ Scratch all path verifiers affected by overrides.\n+                    first.getNestedVerifiers(appContentRoot, first.path()).forEach(disabledVerifiers::add);\n+                    return second;\n+                }, TreeMap::new)).values().stream()\n+                        .map(PathVerifierWithOrigin::verifier)\n+                        .filter(Predicate.not(disabledVerifiers::contains))\n+                        .filter(verifier -> {\n+                            if (!(verifier instanceof DirectoryVerifier dirVerifier)) {\n+                                return true;\n+                            } else {\n+                                try {\n+                                    \/\/ Run the directory verifier if the directory is empty.\n+                                    \/\/ Otherwise, it just pollutes the test log.\n+                                    return isDirectoryEmpty(verifier.path());\n+                                } catch (NoSuchFileException ex) {\n+                                    \/\/ If an MSI contains an empty directory, it will be installed but not created when the MSI is unpacked.\n+                                    \/\/ In the latter the control flow will reach this point.\n+                                    if (dirVerifier.isEmpty()\n+                                            && PackageType.WINDOWS.contains(cmd.packageType())\n+                                            && cmd.isPackageUnpacked(String.format(\n+                                                    \"Expected empty directory [%s] is missing\", verifier.path()))) {\n+                                        return false;\n+                                    }\n+                                    throw new UncheckedIOException(ex);\n+                                } catch (IOException ex) {\n+                                    throw new UncheckedIOException(ex);\n+                                }\n+                            }\n+                        })\n+                        .toList();\n+\n+                verifiers.forEach(PathVerifier::verify);\n+            });\n+\n+            target.test().ifPresent(test -> {\n+                test.setExpectedExitCode(expectedJPackageExitCode).run();\n+            });\n+        }\n+\n+        static final class Builder {\n+            TestSpec create() {\n+                return new TestSpec(groups);\n+            }\n+\n+            final class GroupBuilder {\n+                GroupBuilder add(ContentFactory cf) {\n+                    group.add(Objects.requireNonNull(cf));\n+                    return this;\n+                }\n+\n+                Builder endGroup() {\n+                    if (!group.isEmpty()) {\n+                        groups.add(group);\n@@ -113,0 +261,30 @@\n+                    return Builder.this;\n+                }\n+\n+                private final List<ContentFactory> group = new ArrayList<>();\n+            }\n+\n+            Builder add(ContentFactory cf) {\n+                return startGroup().add(cf).endGroup();\n+            }\n+\n+            GroupBuilder startGroup() {\n+                return new GroupBuilder();\n+            }\n+\n+            private final List<List<ContentFactory>> groups = new ArrayList<>();\n+        }\n+\n+        private record PathVerifierWithOrigin(PathVerifier verifier, Content origin) {\n+            PathVerifierWithOrigin {\n+                Objects.requireNonNull(verifier);\n+                Objects.requireNonNull(origin);\n+            }\n+\n+            Path path() {\n+                return verifier.path();\n+            }\n+\n+            Stream<PathVerifier> getNestedVerifiers(Path appContentRoot, Path path) {\n+                if (!path.startsWith(appContentRoot)) {\n+                    throw new IllegalArgumentException();\n@@ -114,3 +292,10 @@\n-            })\n-            .setExpectedExitCode(expectedJPackageExitCode)\n-            .run();\n+\n+                return StreamSupport.stream(origin.verifiers(appContentRoot).spliterator(), false).filter(v -> {\n+                    return v.path().getNameCount() > path.getNameCount() && v.path().startsWith(path);\n+                });\n+            }\n+        }\n+    }\n+\n+    private static TestSpec.Builder build() {\n+        return new TestSpec.Builder();\n@@ -120,2 +305,2 @@\n-        Path contentDir = cmd.appLayout().contentDirectory();\n-        if (copyInResources) {\n+        final Path contentDir = cmd.appLayout().contentDirectory();\n+        if (COPY_IN_RESOURCES) {\n@@ -128,2 +313,232 @@\n-    private static boolean isSymlinkPath(Path v) {\n-        return v.getFileName().toString().contains(\"Link\");\n+    private static Path createAppContentRoot() {\n+        if (COPY_IN_RESOURCES) {\n+            return TKit.createTempDirectory(\"app-content\").resolve(RESOURCES_DIR);\n+        } else {\n+            return TKit.createTempDirectory(\"app-content\");\n+        }\n+    }\n+\n+    private static boolean isDirectoryEmpty(Path path) throws IOException {\n+        if (Files.exists(path) && !Files.isDirectory(path)) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        try (var files = Files.list(path)) {\n+            return files.findAny().isEmpty();\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface ContentFactory {\n+        Content create();\n+    }\n+\n+    private interface Content {\n+        List<Path> paths();\n+        Iterable<PathVerifier> verifiers(Path appContentRoot);\n+    }\n+\n+    private sealed interface PathVerifier permits\n+            RegularFileVerifier,\n+            DirectoryVerifier,\n+            SymlinkTargetVerifier,\n+            NoPathVerifier {\n+\n+        Path path();\n+        void verify();\n+    }\n+\n+    private record RegularFileVerifier(Path path, Path srcFile) implements PathVerifier {\n+        RegularFileVerifier {\n+            Objects.requireNonNull(path);\n+            Objects.requireNonNull(srcFile);\n+        }\n+\n+        @Override\n+        public void verify() {\n+            TKit.assertSameFileContent(srcFile, path);\n+        }\n+    }\n+\n+    private record DirectoryVerifier(Path path, boolean isEmpty, IdentityWrapper<Content> origin) implements PathVerifier {\n+        DirectoryVerifier {\n+            Objects.requireNonNull(path);\n+        }\n+\n+        @Override\n+        public void verify() {\n+            if (isEmpty) {\n+                TKit.assertDirectoryEmpty(path);\n+            } else {\n+                TKit.assertDirectoryExists(path);\n+            }\n+        }\n+    }\n+\n+    private record SymlinkTargetVerifier(Path path, Path targetPath) implements PathVerifier {\n+        SymlinkTargetVerifier {\n+            Objects.requireNonNull(path);\n+            Objects.requireNonNull(targetPath);\n+        }\n+\n+        @Override\n+        public void verify() {\n+            TKit.assertSymbolicLinkTarget(path, targetPath);\n+        }\n+    }\n+\n+    private record NoPathVerifier(Path path) implements PathVerifier {\n+        NoPathVerifier {\n+            Objects.requireNonNull(path);\n+        }\n+\n+        @Override\n+        public void verify() {\n+            TKit.assertPathExists(path, false);\n+        }\n+    }\n+\n+    private record FileContent(Path path, int level) implements Content {\n+\n+        FileContent {\n+            Objects.requireNonNull(path);\n+            if ((level < 0) || (path.getNameCount() <= level)) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        @Override\n+        public List<Path> paths() {\n+            return List.of(appContentOptionValue());\n+        }\n+\n+        @Override\n+        public Iterable<PathVerifier> verifiers(Path appContentRoot) {\n+            List<PathVerifier> verifiers = new ArrayList<>();\n+\n+            var appContentPath = appContentRoot.resolve(pathInAppContentRoot());\n+\n+            if (Files.isDirectory(path)) {\n+                try (var walk = Files.walk(path)) {\n+                    verifiers.addAll(walk.map(srcFile -> {\n+                        var dstFile = appContentPath.resolve(path.relativize(srcFile));\n+                        if (Files.isRegularFile(srcFile)) {\n+                            return new RegularFileVerifier(dstFile, srcFile);\n+                        } else {\n+                            return new DirectoryVerifier(dstFile,\n+                                    toFunction(AppContentTest::isDirectoryEmpty).apply(srcFile),\n+                                    new IdentityWrapper<>(this));\n+                        }\n+                    }).toList());\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            } else if (Files.isRegularFile(path)) {\n+                verifiers.add(new RegularFileVerifier(appContentPath, path));\n+            } else {\n+                verifiers.add(new NoPathVerifier(appContentPath));\n+            }\n+\n+            if (level > 0) {\n+                var cur = appContentPath;\n+                for (int i = 0; i != level; i++) {\n+                    cur = cur.getParent();\n+                    verifiers.add(new DirectoryVerifier(cur, false, new IdentityWrapper<>(this)));\n+                }\n+            }\n+\n+            return verifiers;\n+        }\n+\n+        private Path appContentOptionValue() {\n+            var cur = path;\n+            for (int i = 0; i != level; i++) {\n+                cur = cur.getParent();\n+            }\n+            return cur;\n+        }\n+\n+        private Path pathInAppContentRoot() {\n+            return StreamSupport.stream(path.spliterator(), false)\n+                    .skip(path.getNameCount() - level - 1)\n+                    .reduce(Path::resolve).orElseThrow();\n+        }\n+    }\n+\n+    \/**\n+     * Non-existing content.\n+     *\/\n+    private static final class NonExistantPath implements ContentFactory {\n+        @Override\n+        public Content create() {\n+            var nonExistant = TKit.createTempFile(\"non-existant\");\n+            try {\n+                TKit.deleteIfExists(nonExistant);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            return new FileContent(nonExistant, 0);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"*non-existant*\";\n+        }\n+    }\n+\n+    \/**\n+     * Creates a content from a directory tree.\n+     *\n+     * @param path name of directory where to create a directory tree\n+     *\/\n+    private static ContentFactory createDirTreeContent(Path path) {\n+        if (path.isAbsolute()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new FileContentFactory(() -> {\n+            var basedir = TKit.createTempDirectory(\"content\").resolve(path);\n+\n+            for (var textFile : Map.ofEntries(\n+                    entry(\"woods\/moose\", \"The moose\"),\n+                    entry(\"woods\/bear\", \"The bear\"),\n+                    entry(\"woods\/trees\/jay\", \"The gray jay\")\n+            ).entrySet()) {\n+                var src = basedir.resolve(textFile.getKey());\n+                Files.createDirectories(src.getParent());\n+                TKit.createTextFile(src, Stream.of(textFile.getValue()));\n+            }\n+\n+            for (var emptyDir : List.of(\"sky\")) {\n+                Files.createDirectories(basedir.resolve(emptyDir));\n+            }\n+\n+            return basedir;\n+        }, path);\n+    }\n+\n+    private static ContentFactory createDirTreeContent(String path) {\n+        return createDirTreeContent(Path.of(path));\n+    }\n+\n+    \/**\n+     * Creates a content from a text file.\n+     *\n+     * @param path the path where to copy the text file in app image's content directory\n+     * @param lines the content of the source text file\n+     *\/\n+    private static ContentFactory createTextFileContent(Path path, String ... lines) {\n+        if (path.isAbsolute()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        return new FileContentFactory(() -> {\n+            var srcPath = TKit.createTempDirectory(\"content\").resolve(path);\n+            Files.createDirectories(srcPath.getParent());\n+            TKit.createTextFile(srcPath, Stream.of(lines));\n+            return srcPath;\n+        }, path);\n+    }\n+\n+    private static ContentFactory createTextFileContent(String path, String ... lines) {\n+        return createTextFileContent(Path.of(path), lines);\n@@ -132,5 +547,72 @@\n-    private static final class AppContentInitializer {\n-        AppContentInitializer(List<String> appContentArgs) {\n-            appContentPathGroups = appContentArgs.stream().map(arg -> {\n-                return Stream.of(arg.split(\",\")).map(Path::of).toList();\n-            }).toList();\n+    \/**\n+     * Symlink content factory.\n+     *\n+     * @path basedir the directory where to write the content in app image's content\n+     *       directory\n+     * @param symlink   the path to the symlink relative to {@code basedir} path\n+     * @param symlinked the path to the source file for the symlink\n+     *\/\n+    private record SymlinkContentFactory(Path basedir, Path symlink, Path symlinked) implements ContentFactory {\n+        SymlinkContentFactory {\n+            for (final var path : List.of(basedir, symlink, symlinked)) {\n+                if (path.isAbsolute()) {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        }\n+\n+        SymlinkContentFactory(String basedir, String symlink, String symlinked) {\n+            this(Path.of(basedir), Path.of(symlink), Path.of(symlinked));\n+        }\n+\n+        @Override\n+        public Content create() {\n+            final var appContentRoot = createAppContentRoot();\n+\n+            final var symlinkPath = appContentRoot.resolve(symlinkPath());\n+            final var symlinkedPath = appContentRoot.resolve(symlinkedPath());\n+            try {\n+                Files.createDirectories(symlinkPath.getParent());\n+                Files.createDirectories(symlinkedPath.getParent());\n+                \/\/ Create the target file for the link.\n+                Files.writeString(symlinkedPath, symlinkedPath().toString());\n+                \/\/ Create the link.\n+                Files.createSymbolicLink(symlinkPath, symlinkTarget());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+\n+            List<Path> contentPaths;\n+            if (COPY_IN_RESOURCES) {\n+                contentPaths = List.of(appContentRoot);\n+            } else if (basedir.equals(Path.of(\"\"))) {\n+                contentPaths = Stream.of(symlinkPath(), symlinkedPath()).map(path -> {\n+                    return path.getName(0);\n+                }).map(appContentRoot::resolve).toList();\n+            } else {\n+                contentPaths = List.of(appContentRoot.resolve(basedir));\n+            }\n+\n+            return new Content() {\n+                @Override\n+                public List<Path> paths() {\n+                    return contentPaths;\n+                }\n+\n+                @Override\n+                public Iterable<PathVerifier> verifiers(Path appContentRoot) {\n+                    return List.of(\n+                            new RegularFileVerifier(appContentRoot.resolve(symlinkedPath()), symlinkedPath),\n+                            new SymlinkTargetVerifier(appContentRoot.resolve(symlinkPath()), symlinkTarget())\n+                    );\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"symlink:[%s]->[%s][%s]\", symlinkPath(), symlinkedPath(), symlinkTarget());\n+        }\n+\n+        private Path symlinkPath() {\n+            return basedir.resolve(symlink);\n@@ -139,9 +621,2 @@\n-        void initAppContent() {\n-            jpackageArgs = appContentPathGroups.stream()\n-                    .map(AppContentInitializer::initAppContentPaths)\n-                    .<String>mapMulti((appContentPaths, consumer) -> {\n-                        consumer.accept(\"--app-content\");\n-                        consumer.accept(\n-                        appContentPaths.stream().map(Path::toString).collect(\n-                                joining(\",\")));\n-                    }).toList();\n+        private Path symlinkedPath() {\n+            return basedir.resolve(symlinked);\n@@ -150,2 +625,4 @@\n-        void applyTo(JPackageCommand cmd) {\n-            cmd.addArguments(jpackageArgs);\n+        private Path symlinkTarget() {\n+            return Optional.ofNullable(symlinkPath().getParent()).map(dir -> {\n+                return dir.relativize(symlinkedPath());\n+            }).orElseGet(this::symlinkedPath);\n@@ -153,0 +630,3 @@\n+    }\n+\n+    private static final class FileContentFactory implements ContentFactory {\n@@ -154,7 +634,6 @@\n-        private static Path copyAppContentPath(Path appContentPath) throws IOException {\n-            var appContentArg = TKit.createTempDirectory(\"app-content\").resolve(RESOURCES_DIR);\n-            var srcPath = TKit.TEST_SRC_ROOT.resolve(appContentPath);\n-            var dstPath = appContentArg.resolve(srcPath.getFileName());\n-            Files.createDirectories(dstPath.getParent());\n-            FileUtils.copyRecursive(srcPath, dstPath);\n-            return appContentArg;\n+        FileContentFactory(ThrowingSupplier<Path> factory, Path pathInAppContentRoot) {\n+            this.factory = ThrowingSupplier.toSupplier(factory);\n+            this.pathInAppContentRoot = pathInAppContentRoot;\n+            if (pathInAppContentRoot.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n@@ -163,2 +642,7 @@\n-        private static Path createAppContentLink(Path appContentPath) throws IOException {\n-            var appContentArg = TKit.createTempDirectory(\"app-content\");\n+        @Override\n+        public Content create() {\n+            Path srcPath = factory.get();\n+            if (!srcPath.endsWith(pathInAppContentRoot)) {\n+                throw new IllegalArgumentException();\n+            }\n+\n@@ -166,4 +650,2 @@\n-            if (copyInResources) {\n-                appContentArg = appContentArg.resolve(RESOURCES_DIR);\n-                dstPath = appContentArg.resolve(LINKS_DIR)\n-                                       .resolve(appContentPath.getFileName());\n+            if (!COPY_IN_RESOURCES) {\n+                dstPath = srcPath;\n@@ -171,30 +653,6 @@\n-                appContentArg = appContentArg.resolve(LINKS_DIR);\n-                dstPath = appContentArg.resolve(appContentPath.getFileName());\n-            }\n-\n-            Files.createDirectories(dstPath.getParent());\n-\n-            \/\/ Create target file for a link\n-            String tagetName = dstPath.getFileName().toString().replace(\"Link\", \"\");\n-            Path targetPath = dstPath.getParent().resolve(tagetName);\n-            Files.write(targetPath, \"foo\".getBytes());\n-            \/\/ Create link\n-            Files.createSymbolicLink(dstPath, targetPath.getFileName());\n-\n-            return appContentArg;\n-        }\n-\n-        private static List<Path> initAppContentPaths(List<Path> appContentPaths) {\n-            return appContentPaths.stream().map(appContentPath -> {\n-                if (appContentPath.endsWith(TEST_BAD)) {\n-                    return appContentPath;\n-                } else if (isSymlinkPath(appContentPath)) {\n-                    return ThrowingFunction.toFunction(\n-                            AppContentInitializer::createAppContentLink).apply(\n-                                    appContentPath);\n-                } else if (copyInResources) {\n-                    return ThrowingFunction.toFunction(\n-                            AppContentInitializer::copyAppContentPath).apply(\n-                                    appContentPath);\n-                } else {\n-                    return TKit.TEST_SRC_ROOT.resolve(appContentPath);\n+                var contentDir = createAppContentRoot();\n+                dstPath = contentDir.resolve(pathInAppContentRoot);\n+                try {\n+                    FileUtils.copyRecursive(srcPath, dstPath);\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n@@ -202,1 +660,7 @@\n-            }).toList();\n+            }\n+            return new FileContent(dstPath, pathInAppContentRoot.getNameCount() - 1);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return pathInAppContentRoot.toString();\n@@ -205,2 +669,2 @@\n-        private List<String> jpackageArgs;\n-        private final List<List<Path>> appContentPathGroups;\n+        private final Supplier<Path> factory;\n+        private final Path pathInAppContentRoot;\n@@ -208,0 +672,15 @@\n+\n+    private static final ContentFactory TEST_JAVA = createTextFileContent(\"apps\/PrintEnv.java\", \"Not what someone would expect\");\n+    private static final ContentFactory TEST_DUKE = createTextFileContent(\"duke.txt\", \"Hi Duke!\");\n+    private static final ContentFactory TEST_DIR = createDirTreeContent(\"apps\");\n+    private static final ContentFactory TEST_BAD = new NonExistantPath();\n+\n+    \/\/ On OSX `--app-content` paths will be copied into the \"Contents\" folder\n+    \/\/ of the output app image.\n+    \/\/ \"codesign\" imposes restrictions on the directory structure of \"Contents\" folder.\n+    \/\/ In particular, random files should be placed in \"Contents\/Resources\" folder\n+    \/\/ otherwise \"codesign\" will fail to sign.\n+    \/\/ Need to prepare arguments for `--app-content` accordingly.\n+    private static final boolean COPY_IN_RESOURCES = TKit.isOSX();\n+\n+    private static final Path RESOURCES_DIR = Path.of(\"Resources\");\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppContentTest.java","additions":605,"deletions":126,"binary":false,"changes":731,"status":"modified"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.AppImageFile;\n+import jdk.jpackage.test.ApplicationLayout;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary test order in which jpackage fills app image\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror AppImageFillOrderTest.java\n+ * @run main\/othervm\/timeout=1440 -Xmx512m\n+ *  jdk.jpackage.test.Main\n+ *  --jpt-run=AppImageFillOrderTest\n+ *\/\n+\n+\/**\n+ * Test order in which overlapping items are added to the app image. jpackage\n+ * defaults should go first to let user-provided content override them.\n+ *\n+ * <p>\n+ * Custom content comes from:\n+ * <ul>\n+ * <li>input directory (--input)\n+ * <li>app content (--app-content)\n+ * <ul>\n+ *\/\n+public class AppImageFillOrderTest {\n+\n+    @Test\n+    @ParameterSupplier\n+    public void test(AppImageOverlay overlays[]) {\n+        test(createJPackage().setFakeRuntime(), overlays);\n+    }\n+\n+    \/**\n+     * Test they can override a file in the runtime.\n+     * @param jlink\n+     *\/\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testRuntime(boolean jlink) {\n+        var cmd = createJPackage();\n+        if (jlink) {\n+            cmd.ignoreDefaultRuntime(true);\n+        } else {\n+            \/\/ Configure fake runtime and create it.\n+            cmd.setFakeRuntime().executePrerequisiteActions();\n+\n+            var runtimeDir = Path.of(cmd.getArgumentValue(\"--runtime-image\"));\n+            if (!runtimeDir.toAbsolutePath().normalize().startsWith(TKit.workDir().toAbsolutePath().normalize())) {\n+                throw new IllegalStateException(String.format(\n+                        \"Fake runtime [%s] created outside of the test work directory [%s]\",\n+                        runtimeDir, TKit.workDir()));\n+            }\n+\n+            TKit.createTextFile(runtimeDir.resolve(RUNTIME_RELEASE_FILE), List.of(\"Foo release\"));\n+        }\n+\n+        test(cmd, AppImageAppContentOverlay.APP_CONTENT_RUNTIME_RELEASE_FILE);\n+    }\n+\n+    \/**\n+     * Test they can not override .jpackage.xml file.\n+     * @throws IOException\n+     *\/\n+    @Test\n+    public void testAppImageFile() throws IOException {\n+\n+        var cmd = createJPackage().setFakeRuntime();\n+\n+        var outputBundle = cmd.outputBundle();\n+\n+        buildOverlay(cmd, TKit.createTempDirectory(\"app-content\"), AppImageFile.getPathInAppImage(outputBundle))\n+                .textContent(\"This is not a valid XML content\")\n+                .configureCmdOptions().createOverlayFile();\n+\n+        \/\/ Run jpackage and verify it created valid .jpackage.xml file ignoring the overlay.\n+        cmd.executeAndAssertImageCreated();\n+\n+        TKit.trace(String.format(\"Parse [%s] file...\", AppImageFile.getPathInAppImage(outputBundle)));\n+        AppImageFile.load(outputBundle);\n+    }\n+\n+    private static void test(JPackageCommand cmd, AppImageOverlay... overlays) {\n+        if (overlays.length == 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        final var outputDir = Path.of(cmd.getArgumentValue(\"--dest\"));\n+        final var noOverlaysOutputDir = Path.of(outputDir.toString() + \"-no-overlay\");\n+        cmd.setArgumentValue(\"--dest\", noOverlaysOutputDir);\n+\n+        \/\/ Run the command without overlays with redirected output directory.\n+        cmd.execute();\n+\n+        final Optional<Path> appContentRoot;\n+        if (Stream.of(overlays).anyMatch(AppImageAppContentOverlay.class::isInstance)) {\n+            appContentRoot = Optional.of(TKit.createTempDirectory(\"app-content\"));\n+        } else {\n+            appContentRoot = Optional.empty();\n+        }\n+\n+        \/\/ Apply overlays to the command.\n+        var fileCopies = Stream.of(overlays).map(overlay -> {\n+            switch (overlay) {\n+                case AppImageDefaultOverlay v -> {\n+                    return v.addOverlay(cmd);\n+                }\n+                case AppImageAppContentOverlay v -> {\n+                    return v.addOverlay(cmd, appContentRoot.orElseThrow());\n+                }\n+            }\n+        }).flatMap(Collection::stream).collect(toMap(FileCopy::out, x -> x, (a, b) -> {\n+            return b;\n+        }, TreeMap::new)).values().stream().toList();\n+\n+        \/\/ Collect paths in the app image that will be affected by overlays.\n+        var noOverlayOutputPaths = fileCopies.stream().map(FileCopy::out).toList();\n+\n+        fileCopies = fileCopies.stream().map(v -> {\n+            return new FileCopy(v.in(), outputDir.resolve(noOverlaysOutputDir.relativize(v.out())));\n+        }).toList();\n+\n+        \/\/ Restore the original output directory for the command and execute it.\n+        cmd.setArgumentValue(\"--dest\", outputDir).execute();\n+\n+        for (var i = 0; i != fileCopies.size(); i++) {\n+            var noOverlayPath = noOverlayOutputPaths.get(i);\n+            var fc = fileCopies.get(i);\n+            TKit.assertSameFileContent(fc.in(), fc.out());\n+            TKit.assertMismatchFileContent(noOverlayPath, fc.out());\n+        }\n+    }\n+\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+\n+                \/\/ Overwrite main launcher .cfg file from the input dir.\n+                List.of(AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG),\n+\n+                \/\/ Overwrite main launcher .cfg file from the app content dir.\n+                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG),\n+\n+                \/\/ Overwrite main launcher .cfg file from the input dir and from the app content dir.\n+                \/\/ The one from app content should win.\n+                List.<AppImageOverlay>of(\n+                        AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG,\n+                        AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG\n+                ),\n+\n+                \/\/ Overwrite main jar from the app content dir.\n+                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_JAR)\n+        ).map(args -> {\n+            return args.toArray(AppImageOverlay[]::new);\n+        }).map(args -> {\n+            return new Object[] {args};\n+        }).toList();\n+    }\n+\n+\n+    public sealed interface AppImageOverlay {\n+    }\n+\n+\n+    private enum AppImageDefaultOverlay implements AppImageOverlay {\n+        INPUT_MAIN_LAUNCHER_CFG(AppImageFillOrderTest::replaceMainLauncherCfgFile),\n+        ;\n+\n+        AppImageDefaultOverlay(Function<JPackageCommand, FileCopy> func) {\n+            Objects.requireNonNull(func);\n+            this.func = cmd -> {\n+                return List.of(func.apply(cmd));\n+            };\n+        }\n+\n+        Collection<FileCopy> addOverlay(JPackageCommand cmd) {\n+            return func.apply(cmd);\n+        }\n+\n+        private final Function<JPackageCommand, Collection<FileCopy>> func;\n+    }\n+\n+\n+    private enum AppImageAppContentOverlay implements AppImageOverlay {\n+        \/\/ Replace the standard main launcher .cfg file with the custom one from the app content.\n+        APP_CONTENT_MAIN_LAUNCHER_CFG((cmd, appContentRoot) -> {\n+            return buildOverlay(cmd, appContentRoot, cmd.appLauncherCfgPath(null))\n+                    .textContent(\"!Olleh\")\n+                    .configureCmdOptions().createOverlayFile();\n+        }),\n+\n+        \/\/ Replace the jar file that jpackage will pick up from the input directory with the custom one.\n+        APP_CONTENT_MAIN_JAR((cmd, appContentRoot) -> {\n+            return buildOverlay(cmd, appContentRoot, cmd.appLayout().appDirectory().resolve(cmd.getArgumentValue(\"--main-jar\")))\n+                    .textContent(\"Surprise!\")\n+                    .configureCmdOptions().createOverlayFile();\n+        }),\n+\n+        \/\/ Replace \"release\" file in the runtime directory.\n+        APP_CONTENT_RUNTIME_RELEASE_FILE((cmd, appContentRoot) -> {\n+            return buildOverlay(cmd, appContentRoot, cmd.appLayout().runtimeHomeDirectory().resolve(\"release\"))\n+                    .textContent(\"blob\")\n+                    .configureCmdOptions().createOverlayFile();\n+        }),\n+        ;\n+\n+        AppImageAppContentOverlay(BiFunction<JPackageCommand, Path, FileCopy> func) {\n+            Objects.requireNonNull(func);\n+            this.func = (cmd, appContentRoot) -> {\n+                return List.of(func.apply(cmd, appContentRoot));\n+            };\n+        }\n+\n+        Collection<FileCopy> addOverlay(JPackageCommand cmd, Path appContentRoot) {\n+            return func.apply(cmd, appContentRoot);\n+        }\n+\n+        private final BiFunction<JPackageCommand, Path, Collection<FileCopy>> func;\n+    }\n+\n+\n+    private record FileCopy(Path in, Path out) {\n+        FileCopy {\n+            Objects.requireNonNull(in);\n+            Objects.requireNonNull(out);\n+        }\n+    }\n+\n+\n+    private static FileCopy replaceMainLauncherCfgFile(JPackageCommand cmd) {\n+        \/\/ Replace the standard main launcher .cfg file with the custom one from the input dir.\n+        final var outputFile = cmd.appLauncherCfgPath(null);\n+\n+        final var inputDir = Path.of(cmd.getArgumentValue(\"--input\"));\n+\n+        final var file = inputDir.resolve(outputFile.getFileName());\n+\n+        TKit.createTextFile(file, List.of(\"Hello!\"));\n+\n+        return new FileCopy(file, outputFile);\n+    }\n+\n+    private static AppContentOverlayFileBuilder buildOverlay(JPackageCommand cmd, Path appContentRoot, Path outputFile) {\n+        return new AppContentOverlayFileBuilder(cmd, appContentRoot, outputFile);\n+    }\n+\n+\n+    private static final class AppContentOverlayFileBuilder {\n+\n+        AppContentOverlayFileBuilder(JPackageCommand cmd, Path appContentRoot, Path outputFile) {\n+            if (outputFile.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (!outputFile.startsWith(cmd.outputBundle())) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.cmd = Objects.requireNonNull(cmd);\n+            this.outputFile = Objects.requireNonNull(outputFile);\n+            this.appContentRoot = Objects.requireNonNull(appContentRoot);\n+        }\n+\n+        FileCopy createOverlayFile() {\n+            final var file = appContentRoot.resolve(pathInAppContentDirectory());\n+\n+            try {\n+                Files.createDirectories(file.getParent());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            fileContentInitializer.accept(file);\n+\n+            return new FileCopy(file, outputFile);\n+        }\n+\n+        AppContentOverlayFileBuilder configureCmdOptions() {\n+            cmd.addArguments(\"--app-content\", appContentRoot.resolve(pathInAppContentDirectory().getName(0)));\n+            return this;\n+        }\n+\n+        AppContentOverlayFileBuilder content(Consumer<Path> v) {\n+            fileContentInitializer = v;\n+            return this;\n+        }\n+\n+        AppContentOverlayFileBuilder textContent(String... lines) {\n+            return content(path -> {\n+                TKit.createTextFile(path, List.of(lines));\n+            });\n+        }\n+\n+        private Path pathInAppContentDirectory() {\n+            return APP_IMAGE_LAYOUT.resolveAt(cmd.outputBundle()).contentDirectory().relativize(outputFile);\n+        }\n+\n+        private Consumer<Path> fileContentInitializer;\n+        private final JPackageCommand cmd;\n+        private final Path outputFile;\n+        private final Path appContentRoot;\n+    }\n+\n+\n+    private static JPackageCommand createJPackage() {\n+        \/\/ With short name.\n+        var cmd = JPackageCommand.helloAppImage().setArgumentValue(\"--name\", \"Foo\");\n+\n+        \/\/ Clean leftovers in the input dir from the previous test run if any.\n+        TKit.deleteDirectoryContentsRecursive(cmd.inputDir());\n+\n+        return cmd;\n+    }\n+\n+    private static final ApplicationLayout APP_IMAGE_LAYOUT = ApplicationLayout.platformAppImage();\n+    private static final Path RUNTIME_RELEASE_FILE = Path.of(\"release\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImageFillOrderTest.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"},{"patch":"@@ -24,2 +24,0 @@\n-import java.nio.file.Path;\n-import java.nio.file.Files;\n@@ -27,1 +25,3 @@\n-import java.util.List;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.function.Predicate;\n@@ -29,1 +29,0 @@\n-import jdk.jpackage.test.AppImageFile;\n@@ -31,0 +30,2 @@\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.AppImageFile;\n@@ -32,1 +33,0 @@\n-import jdk.jpackage.test.TKit;\n@@ -34,0 +34,1 @@\n+import jdk.jpackage.test.JPackageCommand.StandardAssert;\n@@ -37,1 +38,1 @@\n-import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.TKit;\n@@ -58,0 +59,3 @@\n+    \/**\n+     * Create a native bundle from a valid predefined app image produced by jpackage.\n+     *\/\n@@ -60,1 +64,0 @@\n-        Path appimageOutput = TKit.workDir().resolve(\"appimage\");\n@@ -62,2 +65,2 @@\n-        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()\n-                .setArgumentValue(\"--dest\", appimageOutput);\n+        var appImageCmd = JPackageCommand.helloAppImage()\n+                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n@@ -66,1 +69,1 @@\n-        .addRunOnceInitializer(() -> appImageCmd.execute())\n+        .addRunOnceInitializer(appImageCmd::execute)\n@@ -73,0 +76,7 @@\n+    \/**\n+     * Create a native bundle from a predefined app image not produced by jpackage\n+     * but having a valid \".jpackage.xml\" file.\n+     *\n+     * @param withIcon {@code true} if jpackage command line should have \"--icon\"\n+     *                 option\n+     *\/\n@@ -77,3 +87,0 @@\n-        final String name = \"EmptyAppImagePackageTest\";\n-        final String imageName = name + (TKit.isOSX() ? \".app\" : \"\");\n-        Path appImageDir = TKit.createTempDirectory(\"appimage\").resolve(imageName);\n@@ -81,4 +88,4 @@\n-        Files.createDirectories(appImageDir.resolve(\"bin\"));\n-        Path libDir = Files.createDirectories(appImageDir.resolve(\"lib\"));\n-        TKit.createTextFile(libDir.resolve(\"README\"),\n-                List.of(\"This is some arbitrary text for the README file\\n\"));\n+        var appImageCmd = JPackageCommand.helloAppImage()\n+                .setFakeRuntime()\n+                .setArgumentValue(\"--name\", \"EmptyAppImagePackageTest\")\n+                .setArgumentValue(\"--dest\", TKit.createTempDirectory(\"appimage\"));\n@@ -87,0 +94,25 @@\n+        .addRunOnceInitializer(appImageCmd::execute)\n+        .addRunOnceInitializer(() -> {\n+            var layout = appImageCmd.appLayout();\n+            if (!TKit.isOSX()) {\n+                \/\/ Delete the launcher if not on macOS.\n+                \/\/ On macOS, deleting the launcher will render the app bundle invalid.\n+                TKit.deleteIfExists(appImageCmd.appLauncherPath());\n+            }\n+            \/\/ Delete the runtime.\n+            TKit.deleteDirectoryRecursive(layout.runtimeDirectory());\n+            \/\/ Delete the \"app\" dir.\n+            TKit.deleteDirectoryRecursive(layout.appDirectory());\n+\n+            new AppImageFile(appImageCmd.name(), \"PhonyMainClass\").save(appImageCmd.outputBundle());\n+            var appImageDir = appImageCmd.outputBundle();\n+\n+            TKit.trace(String.format(\"Files in [%s] app image:\", appImageDir));\n+            try (var files = Files.walk(appImageDir)) {\n+                files.sequential()\n+                        .filter(Predicate.isEqual(appImageDir).negate())\n+                        .map(path -> String.format(\"[%s]\", appImageDir.relativize(path)))\n+                        .forEachOrdered(TKit::trace);\n+                TKit.trace(\"Done\");\n+            }\n+        })\n@@ -88,1 +120,1 @@\n-            cmd.addArguments(\"--app-image\", appImageDir);\n+            cmd.addArguments(\"--app-image\", appImageCmd.outputBundle());\n@@ -93,1 +125,0 @@\n-            new AppImageFile(\"EmptyAppImagePackageTest\", \"Hello\").save(appImageDir);\n@@ -95,5 +126,5 @@\n-            \/\/ on mac, with --app-image and without --mac-package-identifier,\n-            \/\/ will try to infer it from the image, so foreign image needs it.\n-            if (TKit.isOSX()) {\n-                cmd.addArguments(\"--mac-package-identifier\", name);\n-            }\n+            cmd.excludeStandardAsserts(\n+                    StandardAssert.MAIN_JAR_FILE,\n+                    StandardAssert.MAIN_LAUNCHER_FILES,\n+                    StandardAssert.MAC_BUNDLE_STRUCTURE,\n+                    StandardAssert.RUNTIME_DIRECTORY);\n@@ -101,5 +132,1 @@\n-        \/\/ On macOS we always signing app image and signing will fail, since\n-        \/\/ test produces invalid app bundle.\n-        .setExpectedExitCode(TKit.isOSX() ? 1 : 0)\n-        .run(Action.CREATE, Action.UNPACK);\n-        \/\/ default: {CREATE, UNPACK, VERIFY}, but we can't verify foreign image\n+        .run(Action.CREATE_AND_UNPACK);\n@@ -108,0 +135,4 @@\n+    \/**\n+     * Bad predefined app image - not an output of jpackage.\n+     * jpackage command using the bad predefined app image doesn't have \"--name\" option.\n+     *\/\n@@ -117,0 +148,3 @@\n+    \/**\n+     * Bad predefined app image - not an output of jpackage.\n+     *\/\n@@ -124,0 +158,3 @@\n+    \/**\n+     * Bad predefined app image - valid app image missing \".jpackage.xml\" file.\n+     *\/\n@@ -125,1 +162,1 @@\n-    public static void testBadAppImage3() throws IOException {\n+    public static void testBadAppImage3() {\n@@ -137,0 +174,3 @@\n+    \/**\n+     * Bad predefined app image - valid app image with invalid \".jpackage.xml\" file.\n+     *\/\n@@ -138,1 +178,1 @@\n-    public static void testBadAppImageFile() throws IOException {\n+    public static void testBadAppImageFile() {\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":71,"deletions":31,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -31,0 +32,1 @@\n+import java.nio.file.Files;\n@@ -91,1 +93,21 @@\n-        ADD_LAUNCHER_PROPERTY_FILE;\n+        INVALID_MAC_RUNTIME_BUNDLE(toFunction(cmd -> {\n+            \/\/ Has \"Contents\/MacOS\/libjli.dylib\", but missing \"Contents\/Home\/lib\/libjli.dylib\".\n+            final Path root = TKit.createTempDirectory(\"mac-invalid-runtime-bundle\");\n+            Files.createDirectories(root.resolve(\"Contents\/Home\"));\n+            Files.createFile(root.resolve(\"Contents\/Info.plist\"));\n+            Files.createDirectories(root.resolve(\"Contents\/MacOS\"));\n+            Files.createFile(root.resolve(\"Contents\/MacOS\/libjli.dylib\"));\n+            return root.toString();\n+        })),\n+        INVALID_MAC_RUNTIME_IMAGE(toFunction(cmd -> {\n+            \/\/ Has some files in the \"lib\" subdirectory, but doesn't have the \"lib\/libjli.dylib\" file.\n+            final Path root = TKit.createTempDirectory(\"mac-invalid-runtime-image\");\n+            Files.createDirectories(root.resolve(\"lib\"));\n+            Files.createFile(root.resolve(\"lib\/foo\"));\n+            return root.toString();\n+        })),\n+        EMPTY_DIR(toFunction(cmd -> {\n+            return TKit.createTempDirectory(\"empty-dir\");\n+        })),\n+        ADD_LAUNCHER_PROPERTY_FILE,\n+        ;\n@@ -579,0 +601,3 @@\n+        invalidShortcut(testCases::add, \"--win-menu\");\n+        invalidShortcut(testCases::add, \"--win-shortcut\");\n+\n@@ -602,5 +627,1 @@\n-                        .error(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\"),\n-                testSpec().nativeType().addArgs(\"--mac-app-store\", \"--runtime-image\", Token.JAVA_HOME.token())\n-                        .error(\"ERR_MacAppStoreRuntimeBinExists\", JPackageCommand.cannedArgument(cmd -> {\n-                            return Path.of(cmd.getArgumentValue(\"--runtime-image\")).toAbsolutePath();\n-                        }, Token.JAVA_HOME.token()))\n+                        .error(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\")\n@@ -609,0 +630,2 @@\n+        macInvalidRuntime(testCases::add);\n+\n@@ -645,0 +668,2 @@\n+        invalidShortcut(testCases::add, \"--linux-shortcut\");\n+\n@@ -700,0 +725,60 @@\n+    private static void invalidShortcut(Consumer<TestSpec> accumulator, String shortcutOption) {\n+        Objects.requireNonNull(shortcutOption);\n+        Stream.of(\"true\", \"false\", \"\").map(value -> {\n+            return testSpec().nativeType().addArgs(shortcutOption, value).error(\"error.invalid-option-value\", value, shortcutOption).create();\n+        }).forEach(accumulator);\n+    }\n+\n+    private static void macInvalidRuntime(Consumer<TestSpec> accumulator) {\n+        var runtimeWithBinDirErr = JPackageStringBundle.MAIN.cannedFormattedString(\n+                \"error.invalid-runtime-image-bin-dir\", JPackageCommand.cannedArgument(cmd -> {\n+                    return Path.of(cmd.getArgumentValue(\"--runtime-image\"));\n+                }, Token.JAVA_HOME.token()));\n+        var runtimeWithBinDirErrAdvice = JPackageStringBundle.MAIN.cannedFormattedString(\n+                \"error.invalid-runtime-image-bin-dir.advice\", \"--mac-app-store\");\n+\n+        Stream.of(\n+                testSpec().nativeType().addArgs(\"--mac-app-store\", \"--runtime-image\", Token.JAVA_HOME.token())\n+                        .errors(runtimeWithBinDirErr, runtimeWithBinDirErrAdvice)\n+        ).map(TestSpec.Builder::create).forEach(accumulator);\n+\n+        Stream.of(\n+                Token.INVALID_MAC_RUNTIME_BUNDLE,\n+                Token.EMPTY_DIR,\n+                Token.INVALID_MAC_RUNTIME_IMAGE\n+        ).map(MissingRuntimeFileError::missingLibjli).forEach(mapper -> {\n+            Stream.of(\n+                    testSpec(),\n+                    testSpec().nativeType(),\n+                    testSpec().nativeType().noAppDesc()\n+            ).map(mapper::applyTo).map(TestSpec.Builder::create).forEach(accumulator);\n+        });\n+    }\n+\n+    private record MissingRuntimeFileError(Token runtimeDir, String missingFile) {\n+\n+        MissingRuntimeFileError {\n+            Objects.requireNonNull(runtimeDir);\n+            Objects.requireNonNull(missingFile);\n+        }\n+\n+        static MissingRuntimeFileError missingLibjli(Token runtimeDir) {\n+            if (runtimeDir == Token.INVALID_MAC_RUNTIME_BUNDLE) {\n+                return new MissingRuntimeFileError(runtimeDir, \"Contents\/Home\/lib\/**\/libjli.dylib\");\n+            } else {\n+                return new MissingRuntimeFileError(runtimeDir, \"lib\/**\/libjli.dylib\");\n+            }\n+        }\n+\n+        TestSpec.Builder applyTo(TestSpec.Builder builder) {\n+            return builder.addArgs(\"--runtime-image\", runtimeDir.token()).errors(expectedErrorMsg());\n+        }\n+\n+        private CannedFormattedString expectedErrorMsg() {\n+            return JPackageStringBundle.MAIN.cannedFormattedString(\n+                    \"error.invalid-runtime-image-missing-file\", JPackageCommand.cannedArgument(cmd -> {\n+                        return Path.of(cmd.getArgumentValue(\"--runtime-image\"));\n+                    }, runtimeDir.token()), missingFile);\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":91,"deletions":6,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import static java.util.Map.entry;\n@@ -27,0 +28,1 @@\n+import java.util.List;\n@@ -28,0 +30,1 @@\n+import java.util.TreeMap;\n@@ -117,3 +120,3 @@\n-            TKit.createPropertiesFile(propFile, Map.of(\n-                \"extension\", \"foo\",\n-                \"description\", \"bar\"\n+            TKit.createPropertiesFile(propFile, List.of(\n+                    entry(\"extension\", \"foo\"),\n+                    entry(\"description\", \"bar\")\n@@ -134,4 +137,4 @@\n-            TKit.createPropertiesFile(propFile, Map.of(\n-                \"mime-type\", \"application\/x-jpackage-foo, application\/x-jpackage-bar\",\n-                \"extension\", \"foo\",\n-                \"description\", \"bar\"\n+            TKit.createPropertiesFile(propFile, List.of(\n+                    entry(\"mime-type\", \"application\/x-jpackage-foo, application\/x-jpackage-bar\"),\n+                    entry(\"extension\", \"foo\"),\n+                    entry(\"description\", \"bar\")\n","filename":"test\/jdk\/tools\/jpackage\/share\/FileAssociationsTest.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n+\n@@ -25,3 +27,1 @@\n-import java.util.stream.Stream;\n-import java.util.stream.Collectors;\n-import java.util.function.Consumer;\n+import java.io.UncheckedIOException;\n@@ -35,0 +35,1 @@\n+import java.util.Objects;\n@@ -37,8 +38,3 @@\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.LauncherIconVerifier;\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.Executor;\n-import jdk.jpackage.test.LinuxHelper;\n-import jdk.jpackage.test.AdditionalLauncher;\n-import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -46,0 +42,2 @@\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+import jdk.jpackage.test.AdditionalLauncher;\n@@ -48,0 +46,9 @@\n+import jdk.jpackage.test.CannedFormattedString;\n+import jdk.jpackage.test.ConfigurationTarget;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JPackageStringBundle;\n+import jdk.jpackage.test.LauncherIconVerifier;\n+import jdk.jpackage.test.LinuxHelper;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.TKit;\n@@ -95,1 +102,1 @@\n-        config = Map.of(\n+        config = new TreeMap<>(Map.of(\n@@ -97,1 +104,1 @@\n-                Launcher.Additional, additionalLauncherIconType);\n+                Launcher.Additional, additionalLauncherIconType));\n@@ -104,1 +111,1 @@\n-        config = Map.of(\n+        config = new TreeMap<>(Map.of(\n@@ -106,1 +113,1 @@\n-                Launcher.Additional, additionalLauncherIconType);\n+                Launcher.Additional, additionalLauncherIconType));\n@@ -161,0 +168,2 @@\n+\n+        final ConfigurationTarget target;\n@@ -162,4 +171,1 @@\n-            JPackageCommand cmd = initAppImageTest();\n-            var result = cmd.executeAndAssertImageCreated();\n-            ThrowingConsumer.toConsumer(createInstallVerifier()).accept(cmd);\n-            ThrowingBiConsumer.toBiConsumer(createBundleVerifier()).accept(cmd, result);\n+            target = new ConfigurationTarget(JPackageCommand.helloAppImage());\n@@ -167,3 +173,4 @@\n-            PackageTest test = initPackageTest();\n-            test.addInstallVerifier(createInstallVerifier());\n-            test.addBundleVerifier(createBundleVerifier());\n+            target = new ConfigurationTarget(new PackageTest().configureHelloApp());\n+        }\n+\n+        initTest(target);\n@@ -171,0 +178,11 @@\n+        var installVerifier = createInstallVerifier();\n+        var bundleVerifier = createBundleVerifier();\n+\n+        var cmdResult = target.cmd().map(JPackageCommand::executeAndAssertImageCreated);\n+\n+        target.apply(ThrowingConsumer.toConsumer(installVerifier), test -> {\n+            test.addInstallVerifier(installVerifier);\n+        }).apply(cmd -> {\n+            ThrowingBiConsumer.toBiConsumer(bundleVerifier).accept(cmd, cmdResult.orElseThrow());\n+        }, test -> {\n+            test.addBundleVerifier(bundleVerifier);\n@@ -173,0 +191,1 @@\n+        });\n@@ -174,2 +193,3 @@\n-            test.run(PackageTest.Action.CREATE_AND_UNPACK);\n-        }\n+        target.test().ifPresent(v -> {\n+            v.run(PackageTest.Action.CREATE_AND_UNPACK);\n+        });\n@@ -179,3 +199,0 @@\n-        if (appImage) {\n-            return false;\n-        }\n@@ -191,11 +208,2 @@\n-            var verifier = createConsoleOutputVerifier(cmd.name(), config.get(\n-                    Launcher.Main), null);\n-            if (verifier != null) {\n-                verifier.apply(result.getOutput());\n-            }\n-\n-            if (config.containsKey(Launcher.Additional)) {\n-                verifier = createConsoleOutputVerifier(\n-                        Launcher.Additional.launcherName, config.get(\n-                                Launcher.Additional), config.get(Launcher.Main));\n-                if (verifier != null) {\n+            Stream.of(Launcher.Main, Launcher.Additional).filter(config::containsKey).forEach(launcher -> {\n+                createConsoleOutputVerifier(cmd, launcher).ifPresent(verifier -> {\n@@ -203,2 +211,2 @@\n-                }\n-            }\n+                });\n+            });\n@@ -208,4 +216,14 @@\n-    private TKit.TextStreamVerifier createConsoleOutputVerifier(\n-            String launcherName, IconType iconType, IconType mainIconType) {\n-        if (iconType == IconType.DefaultIcon && mainIconType != null) {\n-            iconType = mainIconType;\n+    private Optional<TKit.TextStreamVerifier> createConsoleOutputVerifier(\n+            JPackageCommand cmd, Launcher launcher) {\n+\n+        var launcherName = Optional.ofNullable(launcher.launcherName).orElseGet(cmd::name);\n+        var resourceName = launcherName;\n+        Optional<Path> customIcon;\n+\n+        if (launcherName.equals(cmd.name())) {\n+            customIcon = Optional.ofNullable(cmd.getArgumentValue(\"--icon\")).map(Path::of);\n+        } else if (config.get(launcher) == IconType.DefaultIcon) {\n+            resourceName = cmd.name();\n+            customIcon = Optional.ofNullable(cmd.getArgumentValue(\"--icon\")).map(Path::of);\n+        } else {\n+            customIcon = getAdditionalLauncherProperties(cmd, launcherName).findProperty(\"icon\").map(Path::of);\n@@ -213,1 +231,6 @@\n-        return createConsoleOutputVerifier(launcherName, iconType);\n+\n+        return createConsoleOutputVerifier(\n+                getBundleIconType(cmd, launcher),\n+                launcherName,\n+                resourceName,\n+                customIcon);\n@@ -216,3 +239,9 @@\n-    private static TKit.TextStreamVerifier createConsoleOutputVerifier(\n-            String launcherName, IconType iconType) {\n-        String lookupString = null;\n+    private static Optional<TKit.TextStreamVerifier> createConsoleOutputVerifier(\n+            IconType iconType, String launcherName, String resourceName, Optional<Path> customIcon) {\n+\n+        Objects.requireNonNull(launcherName);\n+        Objects.requireNonNull(resourceName);\n+        Objects.requireNonNull(customIcon);\n+\n+        CannedFormattedString lookupString;\n+\n@@ -221,2 +250,2 @@\n-                lookupString = String.format(\n-                        \"Using default package resource %s [icon] (add %s%s to the resource-dir to customize)\",\n+                lookupString = JPackageStringBundle.MAIN.cannedFormattedString(\n+                        \"message.using-default-resource\",\n@@ -224,1 +253,2 @@\n-                        launcherName, TKit.ICON_SUFFIX);\n+                        \"[icon]\",\n+                        launcherName + TKit.ICON_SUFFIX);\n@@ -228,3 +258,4 @@\n-                lookupString = String.format(\n-                        \"Using custom package resource [icon] (loaded from %s%s)\",\n-                        launcherName, TKit.ICON_SUFFIX);\n+                lookupString = JPackageStringBundle.MAIN.cannedFormattedString(\n+                        \"message.using-custom-resource\",\n+                        \"[icon]\",\n+                        resourceName + TKit.ICON_SUFFIX);\n@@ -235,1 +266,4 @@\n-                lookupString = \"Using custom package resource [icon] (loaded from file\";\n+                lookupString = JPackageStringBundle.MAIN.cannedFormattedString(\n+                        \"message.using-custom-resource-from-file\",\n+                        \"[icon]\",\n+                        customIcon.orElseThrow());\n@@ -239,1 +273,1 @@\n-                return null;\n+                return Optional.empty();\n@@ -242,1 +276,1 @@\n-        return TKit.assertTextStream(lookupString);\n+        return Optional.of(TKit.assertTextStream(lookupString.getValue()));\n@@ -246,5 +280,2 @@\n-        LauncherIconVerifier verifier = new LauncherIconVerifier();\n-        switch (config.get(Launcher.Main)) {\n-            case NoIcon:\n-                verifier.setExpectedIcon(null);\n-                break;\n+        return cmd -> {\n+            var verifier = new LauncherIconVerifier();\n@@ -252,3 +283,1 @@\n-            case DefaultIcon:\n-                verifier.setExpectedDefaultIcon();\n-                break;\n+            var bundleIconType = getBundleIconType(cmd, Launcher.Main);\n@@ -256,3 +285,4 @@\n-            case CustomIcon:\n-                verifier.setExpectedIcon(Launcher.Main.cmdlineIcon);\n-                break;\n+            switch (bundleIconType) {\n+                case NoIcon:\n+                    verifier.setExpectedNoIcon();\n+                    break;\n@@ -260,3 +290,3 @@\n-            case ResourceDirIcon:\n-                verifier.setExpectedIcon(Launcher.Main.resourceDirIcon);\n-                break;\n+                case DefaultIcon:\n+                    verifier.setExpectedDefaultIcon();\n+                    break;\n@@ -264,4 +294,12 @@\n-            case CustomWithResourceDirIcon:\n-                verifier.setExpectedIcon(Launcher.Main2.cmdlineIcon);\n-                break;\n-        }\n+                case CustomIcon:\n+                    verifier.setExpectedIcon(Launcher.Main.cmdlineIcon);\n+                    break;\n+\n+                case ResourceDirIcon:\n+                    verifier.setExpectedIcon(Launcher.Main.resourceDirIcon);\n+                    break;\n+\n+                case CustomWithResourceDirIcon:\n+                    verifier.setExpectedIcon(Launcher.Main2.cmdlineIcon);\n+                    break;\n+            }\n@@ -269,1 +307,0 @@\n-        return cmd -> {\n@@ -271,0 +308,1 @@\n+\n@@ -273,1 +311,1 @@\n-                if (isWithDesktopIntegration(config.get(Launcher.Main))) {\n+                if (isWithDesktopIntegration(bundleIconType)) {\n@@ -282,1 +320,1 @@\n-    private void initTest(JPackageCommand cmd, PackageTest test) {\n+    private void initTest(ConfigurationTarget target) {\n@@ -284,1 +322,1 @@\n-            initTest(entry.getKey(), entry.getValue(), cmd, test);\n+            initTest(entry.getKey(), entry.getValue(), target);\n@@ -287,11 +325,5 @@\n-        ThrowingConsumer<JPackageCommand> initializer = testCmd -> {\n-            testCmd.saveConsoleOutput(true);\n-            testCmd.setFakeRuntime();\n-            testCmd.addArguments(extraJPackageArgs);\n-        };\n-\n-        if (test != null) {\n-            test.addInitializer(initializer);\n-        } else {\n-            ThrowingConsumer.toConsumer(initializer).accept(cmd);\n-        }\n+        target.addInitializer(cmd -> {\n+            cmd.saveConsoleOutput(true);\n+            cmd.setFakeRuntime();\n+            cmd.addArguments(extraJPackageArgs);\n+        });\n@@ -301,8 +333,1 @@\n-            JPackageCommand cmd, PackageTest test) throws IOException {\n-        Consumer<AdditionalLauncher> addLauncher = v -> {\n-            if (test != null) {\n-                v.applyTo(test);\n-            } else {\n-                v.applyTo(cmd);\n-            }\n-        };\n+            ConfigurationTarget target) throws IOException {\n@@ -312,3 +337,2 @@\n-                if (cfg.launcherName != null) {\n-                    addLauncher.accept(new AdditionalLauncher(cfg.launcherName));\n-                }\n+                Optional.ofNullable(cfg.launcherName).map(AdditionalLauncher::new)\n+                        .ifPresent(target::add);\n@@ -318,4 +342,3 @@\n-                if (cfg.launcherName != null) {\n-                    addLauncher.accept(\n-                            new AdditionalLauncher(cfg.launcherName).setNoIcon());\n-                }\n+                Optional.ofNullable(cfg.launcherName).map(AdditionalLauncher::new)\n+                        .map(AdditionalLauncher::setNoIcon)\n+                        .ifPresent(target::add);\n@@ -325,5 +348,1 @@\n-                if (test != null) {\n-                    addCustomIcon(null, test, cfg.launcherName, cfg.cmdlineIcon);\n-                } else {\n-                    addCustomIcon(cmd, null, cfg.launcherName, cfg.cmdlineIcon);\n-                }\n+                addCustomIcon(target, cfg.launcherName, cfg.cmdlineIcon);\n@@ -333,10 +352,3 @@\n-                if (Launcher.PRIMARY.contains(cfg) && cfg.launcherName != null) {\n-                    addLauncher.accept(new AdditionalLauncher(cfg.launcherName));\n-                }\n-                if (test != null) {\n-                    test.addInitializer(testCmd -> {\n-                        addResourceDirIcon(testCmd, cfg.launcherName,\n-                                cfg.resourceDirIcon);\n-                    });\n-                } else {\n-                    addResourceDirIcon(cmd, cfg.launcherName, cfg.resourceDirIcon);\n+                if (Launcher.PRIMARY.contains(cfg)) {\n+                    Optional.ofNullable(cfg.launcherName).map(AdditionalLauncher::new)\n+                            .ifPresent(target::add);\n@@ -344,0 +356,7 @@\n+                target.addInitializer(cmd -> {\n+                    try {\n+                        addResourceDirIcon(cmd, cfg.launcherName, cfg.resourceDirIcon);\n+                    } catch (IOException ex) {\n+                        throw new UncheckedIOException(ex);\n+                    }\n+                });\n@@ -349,2 +368,2 @@\n-                        initTest(Launcher.Main2, IconType.CustomIcon, cmd, test);\n-                        initTest(Launcher.Main2, IconType.ResourceDirIcon, cmd, test);\n+                        initTest(Launcher.Main2, IconType.CustomIcon, target);\n+                        initTest(Launcher.Main2, IconType.ResourceDirIcon, target);\n@@ -354,2 +373,2 @@\n-                        initTest(Launcher.Additional2, IconType.CustomIcon, cmd, test);\n-                        initTest(Launcher.Additional2, IconType.ResourceDirIcon, cmd, test);\n+                        initTest(Launcher.Additional2, IconType.CustomIcon, target);\n+                        initTest(Launcher.Additional2, IconType.ResourceDirIcon, target);\n@@ -365,4 +384,2 @@\n-    private JPackageCommand initAppImageTest() {\n-        JPackageCommand cmd = JPackageCommand.helloAppImage();\n-        initTest(cmd, null);\n-        return cmd;\n+    private IconType getBundleIconType(JPackageCommand cmd, Launcher launcher) {\n+        return getBundleIconType(cmd, config.get(Launcher.Main), launcher, config.get(launcher));\n@@ -371,4 +388,33 @@\n-    private PackageTest initPackageTest() {\n-        PackageTest test = new PackageTest().configureHelloApp();\n-        initTest(null, test);\n-        return test;\n+    \/**\n+     * Returns the expected icon type of the given launcher in the output bundle\n+     * that the given jpackage command line will output based on the icon type\n+     * configured for the launcher.\n+     *\n+     * @param cmd                  jpackage command line\n+     * @param mainLauncherIconType the icon type configured for the main launcher\n+     * @param launcher             the launcher\n+     * @param iconType             the icon type configured for the specified\n+     *                             launcher\n+     * @return the type of of an icon of the given launcher in the output bundle\n+     *\/\n+    private static IconType getBundleIconType(JPackageCommand cmd,\n+            IconType mainLauncherIconType, Launcher launcher, IconType iconType) {\n+\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(mainLauncherIconType);\n+        Objects.requireNonNull(launcher);\n+        Objects.requireNonNull(iconType);\n+\n+        if (iconType == IconType.DefaultIcon) {\n+            iconType = mainLauncherIconType;\n+        }\n+\n+        if (TKit.isLinux()) {\n+            var noDefaultIcon = cmd.isImagePackageType() || !cmd.hasArgument(\"--linux-shortcut\");\n+\n+            if (noDefaultIcon && iconType == IconType.DefaultIcon) {\n+                iconType = IconType.NoIcon;\n+            }\n+        }\n+\n+        return iconType;\n@@ -379,6 +425,3 @@\n-        Path resourceDir = cmd.getArgumentValue(\"--resource-dir\", () -> null,\n-                Path::of);\n-        if (resourceDir == null) {\n-            resourceDir = TKit.createTempDirectory(\"resources\");\n-            cmd.addArguments(\"--resource-dir\", resourceDir);\n-        }\n+        var resourceDir = Optional.ofNullable(cmd.getArgumentValue(\"--resource-dir\")).map(Path::of).orElseGet(() -> {\n+            return TKit.createTempDirectory(\"resources\");\n+        });\n@@ -386,2 +429,3 @@\n-        String dstIconFileName = Optional.ofNullable(launcherName).orElseGet(\n-                () -> cmd.name()) + TKit.ICON_SUFFIX;\n+        cmd.addArguments(\"--resource-dir\", resourceDir);\n+\n+        String dstIconFileName = Optional.ofNullable(launcherName).orElseGet(cmd::name) + TKit.ICON_SUFFIX;\n@@ -395,2 +439,2 @@\n-    private static void addCustomIcon(JPackageCommand cmd, PackageTest test,\n-            String launcherName, Path iconPath) throws IOException {\n+    private static void addCustomIcon(ConfigurationTarget target,\n+            String launcherName, Path iconPath) {\n@@ -399,11 +443,2 @@\n-            AdditionalLauncher al = new AdditionalLauncher(launcherName).setIcon(\n-                    iconPath);\n-            if (test != null) {\n-                al.applyTo(test);\n-            } else {\n-                al.applyTo(cmd);\n-            }\n-        } else if (test != null) {\n-            test.addInitializer(testCmd -> {\n-                testCmd.addArguments(\"--icon\", iconPath);\n-            });\n+            var al = new AdditionalLauncher(launcherName).setIcon(iconPath);\n+            target.apply(al::applyTo, al::applyTo);\n@@ -411,1 +446,3 @@\n-            cmd.addArguments(\"--icon\", iconPath);\n+            target.addInitializer(cmd -> {\n+                cmd.addArguments(\"--icon\", iconPath);\n+            });\n","filename":"test\/jdk\/tools\/jpackage\/share\/IconTest.java","additions":191,"deletions":154,"binary":false,"changes":345,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import jdk.jpackage.test.JPackageCommand.AppLayoutAssert;\n+import jdk.jpackage.test.JPackageCommand.StandardAssert;\n@@ -180,1 +180,1 @@\n-                cmd.excludeAppLayoutAsserts(AppLayoutAssert.APP_IMAGE_FILE);\n+                cmd.excludeStandardAsserts(StandardAssert.APP_IMAGE_FILE);\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-                expectedLicensePath)).findFirst().orElse(null) != null,\n+                expectedLicensePath)).findFirst().isPresent(),\n","filename":"test\/jdk\/tools\/jpackage\/share\/LicenseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,5 @@\n+import static jdk.internal.util.OperatingSystem.LINUX;\n+import static jdk.internal.util.OperatingSystem.MACOS;\n+import static jdk.jpackage.test.TKit.assertFalse;\n+import static jdk.jpackage.test.TKit.assertTrue;\n+\n@@ -27,2 +32,1 @@\n-import java.util.HashSet;\n-import java.util.Set;\n+import java.util.Objects;\n@@ -30,7 +34,1 @@\n-import java.util.stream.Collectors;\n-import jdk.jpackage.test.PackageType;\n-import jdk.jpackage.test.RunnablePackageTest.Action;\n-import jdk.jpackage.test.PackageTest;\n-import jdk.jpackage.test.JPackageCommand;\n-import jdk.jpackage.test.TKit;\n-import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -38,0 +36,1 @@\n+import jdk.jpackage.test.Annotations.Test;\n@@ -39,0 +38,1 @@\n+import jdk.jpackage.test.JPackageCommand;\n@@ -41,3 +41,5 @@\n-import static jdk.jpackage.test.TKit.assertTrue;\n-import static jdk.jpackage.test.TKit.assertFalse;\n-import static jdk.internal.util.OperatingSystem.LINUX;\n+import jdk.jpackage.test.MacHelper;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n@@ -88,0 +90,5 @@\n+    @Test(ifOS = MACOS)\n+    public static void testFromBundle() {\n+        init(RuntimePackageTest::createInputRuntimeBundle).run();\n+    }\n+\n@@ -110,0 +117,8 @@\n+        return init(RuntimePackageTest::createInputRuntimeImage);\n+    }\n+\n+    private static PackageTest init(ThrowingSupplier<Path> createRuntime) {\n+        Objects.requireNonNull(createRuntime);\n+\n+        final Path[] runtimeImageDir = new Path[1];\n+\n@@ -111,0 +126,3 @@\n+        .addRunOnceInitializer(() -> {\n+            runtimeImageDir[0] = createRuntime.get();\n+        })\n@@ -112,19 +130,1 @@\n-            final Path runtimeImageDir;\n-\n-            if (JPackageCommand.DEFAULT_RUNTIME_IMAGE != null) {\n-                runtimeImageDir = JPackageCommand.DEFAULT_RUNTIME_IMAGE;\n-            } else {\n-                runtimeImageDir = TKit.createTempDirectory(\"runtime\").resolve(\"data\");\n-\n-                new Executor()\n-                .setToolProvider(JavaTool.JLINK)\n-                .dumpOutput()\n-                .addArguments(\n-                        \"--output\", runtimeImageDir.toString(),\n-                        \"--add-modules\", \"java.desktop\",\n-                        \"--strip-debug\",\n-                        \"--no-header-files\",\n-                        \"--no-man-pages\")\n-                .execute();\n-            }\n-            cmd.addArguments(\"--runtime-image\", runtimeImageDir);\n+            cmd.addArguments(\"--runtime-image\", runtimeImageDir[0]);\n@@ -137,4 +137,30 @@\n-            Set<Path> srcRuntime = listFiles(Path.of(cmd.getArgumentValue(\"--runtime-image\")));\n-            Path dest = cmd.appRuntimeDirectory();\n-            if (TKit.isOSX()) {\n-                dest = dest.resolve(\"Contents\/Home\");\n+            var src = TKit.assertDirectoryContentRecursive(inputRuntimeDir(cmd)).items();\n+            var dest = cmd.appLayout().runtimeHomeDirectory();\n+            TKit.assertDirectoryContentRecursive(dest).match(src);\n+        })\n+        .forTypes(PackageType.LINUX_DEB, test -> {\n+            test.addInstallVerifier(cmd -> {\n+                String installDir = cmd.getArgumentValue(\"--install-dir\", () -> \"\/opt\");\n+                Path copyright = Path.of(\"\/usr\/share\/doc\",\n+                        LinuxHelper.getPackageName(cmd), \"copyright\");\n+                boolean withCopyright = LinuxHelper.getPackageFiles(cmd).anyMatch(\n+                        Predicate.isEqual(copyright));\n+                if (installDir.startsWith(\"\/usr\/\") || installDir.equals(\"\/usr\")) {\n+                    assertTrue(withCopyright, String.format(\n+                            \"Check the package delivers [%s] copyright file\",\n+                            copyright));\n+                } else {\n+                    assertFalse(withCopyright, String.format(\n+                            \"Check the package doesn't deliver [%s] copyright file\",\n+                            copyright));\n+                }\n+            });\n+        });\n+    }\n+\n+    private static Path inputRuntimeDir(JPackageCommand cmd) {\n+        var path = Path.of(cmd.getArgumentValue(\"--runtime-image\"));\n+        if (TKit.isOSX()) {\n+            var bundleHome = path.resolve(\"Contents\/Home\");\n+            if (Files.isDirectory(bundleHome)) {\n+                return bundleHome;\n@@ -142,1 +168,3 @@\n-            Set<Path> dstRuntime = listFiles(dest);\n+        }\n+        return path;\n+    }\n@@ -144,2 +172,1 @@\n-            Set<Path> intersection = new HashSet<>(srcRuntime);\n-            intersection.retainAll(dstRuntime);\n+    private static Path createInputRuntimeImage() throws IOException {\n@@ -147,2 +174,1 @@\n-            srcRuntime.removeAll(intersection);\n-            dstRuntime.removeAll(intersection);\n+        final Path runtimeImageDir;\n@@ -150,21 +176,4 @@\n-            assertFileListEmpty(srcRuntime, \"Missing\");\n-            assertFileListEmpty(dstRuntime, \"Unexpected\");\n-        })\n-        .forTypes(PackageType.LINUX_DEB)\n-        .addInstallVerifier(cmd -> {\n-            String installDir = cmd.getArgumentValue(\"--install-dir\", () -> \"\/opt\");\n-            Path copyright = Path.of(\"\/usr\/share\/doc\",\n-                    LinuxHelper.getPackageName(cmd), \"copyright\");\n-            boolean withCopyright = LinuxHelper.getPackageFiles(cmd).anyMatch(\n-                    Predicate.isEqual(copyright));\n-            if (installDir.startsWith(\"\/usr\/\") || installDir.equals(\"\/usr\")) {\n-                assertTrue(withCopyright, String.format(\n-                        \"Check the package delivers [%s] copyright file\",\n-                        copyright));\n-            } else {\n-                assertFalse(withCopyright, String.format(\n-                        \"Check the package doesn't deliver [%s] copyright file\",\n-                        copyright));\n-            }\n-        });\n-    }\n+        if (JPackageCommand.DEFAULT_RUNTIME_IMAGE != null) {\n+            runtimeImageDir = JPackageCommand.DEFAULT_RUNTIME_IMAGE;\n+        } else {\n+            runtimeImageDir = TKit.createTempDirectory(\"runtime-image\").resolve(\"data\");\n@@ -172,8 +181,9 @@\n-    private static Set<Path> listFiles(Path root) throws IOException {\n-        try (var files = Files.walk(root)) {\n-            \/\/ Ignore files created by system prefs if any.\n-            final Path prefsDir = Path.of(\".systemPrefs\");\n-            return files.map(root::relativize)\n-                    .filter(x -> !x.startsWith(prefsDir))\n-                    .filter(x -> !x.endsWith(\".DS_Store\"))\n-                    .collect(Collectors.toSet());\n+            new Executor().setToolProvider(JavaTool.JLINK)\n+                    .dumpOutput()\n+                    .addArguments(\n+                            \"--output\", runtimeImageDir.toString(),\n+                            \"--add-modules\", \"java.desktop\",\n+                            \"--strip-debug\",\n+                            \"--no-header-files\",\n+                            \"--no-man-pages\")\n+                    .execute();\n@@ -181,0 +191,2 @@\n+\n+        return runtimeImageDir;\n@@ -183,9 +195,26 @@\n-    private static void assertFileListEmpty(Set<Path> paths, String msg) {\n-        TKit.assertTrue(paths.isEmpty(), String.format(\n-                \"Check there are no %s files in installed image\",\n-                msg.toLowerCase()), () -> {\n-            String msg2 = String.format(\"%s %d files\", msg, paths.size());\n-            TKit.trace(msg2 + \":\");\n-            paths.stream().map(Path::toString).sorted().forEachOrdered(\n-                    TKit::trace);\n-            TKit.trace(\"Done\");\n+    private static Path createInputRuntimeBundle() throws IOException {\n+\n+        final var runtimeImage = createInputRuntimeImage();\n+\n+        final var runtimeBundleWorkDir = TKit.createTempDirectory(\"runtime-bundle\");\n+\n+        final var unpackadeRuntimeBundleDir = runtimeBundleWorkDir.resolve(\"unpacked\");\n+\n+        var cmd = new JPackageCommand()\n+                .useToolProvider(true)\n+                .ignoreDefaultRuntime(true)\n+                .dumpOutput(true)\n+                .setPackageType(PackageType.MAC_DMG)\n+                .setArgumentValue(\"--name\", \"foo\")\n+                .addArguments(\"--runtime-image\", runtimeImage)\n+                .addArguments(\"--dest\", runtimeBundleWorkDir);\n+\n+        cmd.execute();\n+\n+        MacHelper.withExplodedDmg(cmd, dmgImage -> {\n+            if (dmgImage.endsWith(cmd.appInstallationDirectory().getFileName())) {\n+                Executor.of(\"cp\", \"-R\")\n+                        .addArgument(dmgImage)\n+                        .addArgument(unpackadeRuntimeBundleDir)\n+                        .execute(0);\n+            }\n@@ -193,0 +222,2 @@\n+\n+        return unpackadeRuntimeBundleDir;\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimePackageTest.java","additions":109,"deletions":78,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import static jdk.jpackage.test.PackageType.MAC_DMG;\n+import static jdk.jpackage.test.PackageType.WINDOWS;\n+\n@@ -25,0 +28,1 @@\n+import java.io.UncheckedIOException;\n@@ -27,0 +31,1 @@\n+import java.util.HexFormat;\n@@ -28,0 +33,1 @@\n+import java.util.function.Consumer;\n@@ -29,1 +35,2 @@\n-import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -31,0 +38,1 @@\n+import jdk.jpackage.test.ConfigurationTarget;\n@@ -34,2 +42,2 @@\n-import static jdk.jpackage.test.PackageType.MAC_DMG;\n-import static jdk.jpackage.test.PackageType.WINDOWS;\n+import jdk.jpackage.test.LauncherVerifier.Action;\n+import jdk.jpackage.test.PackageTest;\n@@ -50,0 +58,1 @@\n+ * @requires (jpackage.test.SQETest != null)\n@@ -51,1 +60,14 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n+ *  jdk.jpackage.test.Main\n+ *  --jpt-run=ServiceTest.test,ServiceTest.testUpdate\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Launcher as service packaging test\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @key jpackagePlatformPackage\n+ * @requires (jpackage.test.SQETest == null)\n+ * @compile -Xlint:all -Werror ServiceTest.java\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n@@ -55,0 +77,1 @@\n+\n@@ -89,1 +112,0 @@\n-        var testInitializer = createTestInitializer();\n@@ -92,1 +114,1 @@\n-        testInitializer.applyTo(pkg);\n+        createTestInitializer().applyTo(pkg);\n@@ -135,0 +157,102 @@\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testAddL(boolean mainLauncherAsService) {\n+\n+        final var uniqueOutputFile = uniqueOutputFile();\n+\n+        createPackageTest()\n+                .addHelloAppInitializer(\"com.buz.AddLaunchersServiceTest\")\n+                .mutate(test -> {\n+                    if (mainLauncherAsService) {\n+                        LauncherAsServiceVerifier.build()\n+                                .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-\")\n+                                .setExpectedValue(\"Main\").applyTo(test);\n+                    }\n+                })\n+                \/\/ Regular launcher. The installer should not automatically execute it.\n+                .mutate(new AdditionalLauncher(\"notservice\")\n+                        .withoutVerifyActions(Action.EXECUTE_LAUNCHER)\n+                        .setProperty(\"launcher-as-service\", Boolean.FALSE)\n+                        .addJavaOptions(\"-Djpackage.test.noexit=true\")::applyTo)\n+                \/\/ Additional launcher with explicit \"launcher-as-service=true\" property in the property file.\n+                .mutate(LauncherAsServiceVerifier.build()\n+                        .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-A1-\")\n+                        .setLauncherName(\"AL1\")\n+                        .setExpectedValue(\"AL1\")::applyTo)\n+                .mutate(test -> {\n+                    if (mainLauncherAsService) {\n+                        \/\/ Additional launcher without \"launcher-as-service\" property in the property file.\n+                        \/\/ Still, should be installed as a service.\n+                        LauncherAsServiceVerifier.build()\n+                                .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-A2-\")\n+                                .setLauncherName(\"AL2\")\n+                                .setExpectedValue(\"AL2\")\n+                                .setAdditionalLauncherCallback(al -> {\n+                                    al.removeProperty(\"launcher-as-service\");\n+                                })\n+                                .applyTo(test);\n+                    }\n+                })\n+                .mutate(createTestInitializer()::applyTo)\n+                .run();\n+        }\n+\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testAddLFromAppImage(boolean mainLauncherAsService) {\n+\n+        var uniqueOutputFile = uniqueOutputFile();\n+\n+        var appImageCmd = new ConfigurationTarget(JPackageCommand.helloAppImage(\"com.bar.AddLaunchersFromAppImageServiceTest\"));\n+\n+        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n+            \/\/ Ensure launchers are executable because the output bundle will be installed\n+            \/\/ and we want to verify launchers are automatically started by the installer.\n+            appImageCmd.addInitializer(JPackageCommand::ignoreFakeRuntime);\n+        }\n+\n+        if (mainLauncherAsService) {\n+            LauncherAsServiceVerifier.build()\n+                    .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-\")\n+                    .setExpectedValue(\"Main\")\n+                    .applyTo(appImageCmd);\n+            \/\/ Can not use \"--launcher-as-service\" option with app image packaging.\n+            appImageCmd.cmd().orElseThrow().removeArgument(\"--launcher-as-service\");\n+        } else {\n+            appImageCmd.addInitializer(cmd -> {\n+                \/\/ Configure the main launcher to hang at the end of the execution.\n+                \/\/ The main launcher should not be executed in this test.\n+                \/\/ If it is executed, it indicates it was started as a service,\n+                \/\/ which must fail the test. The launcher's hang-up will be the event failing the test.\n+                cmd.addArguments(\"--java-options\", \"-Djpackage.test.noexit=true\");\n+            });\n+        }\n+\n+        \/\/ Additional launcher with explicit \"launcher-as-service=true\" property in the property file.\n+        LauncherAsServiceVerifier.build()\n+                .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-A1-\")\n+                .setLauncherName(\"AL1\")\n+                .setExpectedValue(\"AL1\").applyTo(appImageCmd);\n+\n+        \/\/ Regular launcher. The installer should not automatically execute it.\n+        appImageCmd.add(new AdditionalLauncher(\"notservice\")\n+                .withoutVerifyActions(Action.EXECUTE_LAUNCHER)\n+                .addJavaOptions(\"-Djpackage.test.noexit=true\"));\n+\n+        new PackageTest().excludeTypes(MAC_DMG)\n+                .addRunOnceInitializer(appImageCmd.cmd().orElseThrow()::execute)\n+                .addInitializer(cmd -> {\n+                    cmd.removeArgumentWithValue(\"--input\");\n+                    cmd.addArguments(\"--app-image\", appImageCmd.cmd().orElseThrow().outputBundle());\n+                })\n+                .addInitializer(cmd -> {\n+                    if (mainLauncherAsService) {\n+                        cmd.addArgument(\"--launcher-as-service\");\n+                    }\n+                })\n+                .mutate(createTestInitializer()::applyTo)\n+                .run();\n+    }\n+\n@@ -142,1 +266,1 @@\n-        void applyTo(PackageTest test) throws IOException {\n+        void applyTo(PackageTest test) {\n@@ -145,2 +269,5 @@\n-                Files.copy(winServiceInstaller, resourceDir.resolve(\n-                        \"service-installer.exe\"));\n+                try {\n+                    Files.copy(winServiceInstaller, resourceDir.resolve(\"service-installer.exe\"));\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n@@ -168,1 +295,1 @@\n-        return new PackageTest()\n+        var test = new PackageTest()\n@@ -171,0 +298,19 @@\n+        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n+            \/\/ Ensure launchers are executable because the output bundle will be installed\n+            \/\/ and we want to verify launchers are automatically started by the installer.\n+            test.addInitializer(JPackageCommand::ignoreFakeRuntime);\n+        }\n+        return test;\n+    }\n+\n+    private static Consumer<LauncherAsServiceVerifier.Builder> uniqueOutputFile() {\n+        var prefix = uniquePrefix();\n+        return builder -> {\n+            builder.setAppOutputFileNamePrefixToAppName()\n+                    .appendAppOutputFileNamePrefix(\"-\")\n+                    .appendAppOutputFileNamePrefix(prefix);\n+        };\n+    }\n+\n+    private static String uniquePrefix() {\n+        return HexFormat.of().toHexDigits(System.currentTimeMillis());\n","filename":"test\/jdk\/tools\/jpackage\/share\/ServiceTest.java","additions":156,"deletions":10,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n+\n@@ -27,3 +29,0 @@\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import jdk.jpackage.test.JPackageCommand;\n@@ -33,1 +32,1 @@\n-import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n+import jdk.jpackage.test.JPackageCommand;\n@@ -96,5 +95,4 @@\n-            try ( \/\/ Launch the app in a separate thread\n-                ExecutorService exec = Executors.newSingleThreadExecutor()) {\n-                exec.execute(() -> {\n-                    HelloApp.executeLauncher(cmd);\n-                });\n+            \/\/ Launch the app in a separate thread\n+            new Thread(() -> {\n+                HelloApp.executeLauncher(cmd);\n+            }).start();\n@@ -102,2 +100,2 @@\n-                \/\/ Wait a bit to let the app start\n-                Thread.sleep(Duration.ofSeconds(10));\n+            \/\/ Wait a bit to let the app start\n+            Thread.sleep(Duration.ofSeconds(10));\n@@ -105,3 +103,2 @@\n-                \/\/ Find the main app launcher process and kill it\n-                killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n-            }\n+            \/\/ Find the main app launcher process and kill it\n+            killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"}]}