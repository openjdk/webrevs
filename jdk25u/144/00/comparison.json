{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-\/*-\n+\/*\n@@ -31,2 +31,11 @@\n-import java.io.*;\n-import java.awt.image.*;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.BufferedInputStream;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.lang.Math.multiplyExact;\n@@ -53,0 +62,2 @@\n+    private static final int MAX_XBM_SIZE = 16384;\n+    private static final int HEADER_SCAN_LIMIT = 100;\n@@ -75,4 +86,0 @@\n-        char[] nm = new char[80];\n-        int c;\n-        int i = 0;\n-        int state = 0;\n@@ -83,1 +90,2 @@\n-        boolean start = true;\n+        int n = 0;\n+        int state = 0;\n@@ -86,20 +94,29 @@\n-        while (!aborted && (c = input.read()) != -1) {\n-            if ('a' <= c && c <= 'z' ||\n-                    'A' <= c && c <= 'Z' ||\n-                    '0' <= c && c <= '9' || c == '#' || c == '_') {\n-                if (i < 78)\n-                    nm[i++] = (char) c;\n-            } else if (i > 0) {\n-                int nc = i;\n-                i = 0;\n-                if (start) {\n-                    if (nc != 7 ||\n-                        nm[0] != '#' ||\n-                        nm[1] != 'd' ||\n-                        nm[2] != 'e' ||\n-                        nm[3] != 'f' ||\n-                        nm[4] != 'i' ||\n-                        nm[5] != 'n' ||\n-                        nm[6] != 'e')\n-                    {\n-                        error(\"Not an XBM file\");\n+\n+        String matchRegex = \"(0[xX])?[0-9a-fA-F]+[\\\\s+]?[,|};]\";\n+        String replaceRegex = \"(0[xX])|,|[\\\\s+]|[};]\";\n+\n+        String line;\n+        int lineNum = 0;\n+\n+        try (BufferedReader br = new BufferedReader(new InputStreamReader(input))) {\n+            \/\/ loop to process XBM header - width, height and create raster\n+            while (!aborted && (line = br.readLine()) != null\n+                    && lineNum <= HEADER_SCAN_LIMIT) {\n+                lineNum++;\n+                \/\/ process #define stmts\n+                if (line.trim().startsWith(\"#define\")) {\n+                    String[] token = line.split(\"\\\\s+\");\n+                    if (token.length != 3) {\n+                        error(\"Error while parsing define statement\");\n+                    }\n+                    try {\n+                        if (!token[2].isBlank() && state == 0) {\n+                            W = Integer.parseInt(token[2]);\n+                            state = 1; \/\/ after width is set\n+                        } else if (!token[2].isBlank() && state == 1) {\n+                            H = Integer.parseInt(token[2]);\n+                            state = 2; \/\/ after height is set\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        \/\/ parseInt() can throw NFE\n+                        error(\"Error while parsing width or height.\");\n@@ -107,1 +124,0 @@\n-                    start = false;\n@@ -109,17 +125,4 @@\n-                if (nm[nc - 1] == 'h')\n-                    state = 1;  \/* expecting width *\/\n-                else if (nm[nc - 1] == 't' && nc > 1 && nm[nc - 2] == 'h')\n-                    state = 2;  \/* expecting height *\/\n-                else if (nc > 2 && state < 0 && nm[0] == '0' && nm[1] == 'x') {\n-                    int n = 0;\n-                    for (int p = 2; p < nc; p++) {\n-                        c = nm[p];\n-                        if ('0' <= c && c <= '9')\n-                            c = c - '0';\n-                        else if ('A' <= c && c <= 'Z')\n-                            c = c - 'A' + 10;\n-                        else if ('a' <= c && c <= 'z')\n-                            c = c - 'a' + 10;\n-                        else\n-                            c = 0;\n-                        n = n * 16 + c;\n+\n+                if (state == 2) {\n+                    if (W <= 0 || H <= 0) {\n+                        error(\"Invalid values for width or height.\");\n@@ -127,8 +130,3 @@\n-                    for (int mask = 1; mask <= 0x80; mask <<= 1) {\n-                        if (x < W) {\n-                            if ((n & mask) != 0)\n-                                raster[x] = 1;\n-                            else\n-                                raster[x] = 0;\n-                        }\n-                        x++;\n+                    if (multiplyExact(W, H) > MAX_XBM_SIZE) {\n+                        error(\"Large XBM file size.\"\n+                                + \" Maximum allowed size: \" + MAX_XBM_SIZE);\n@@ -136,3 +134,36 @@\n-                    if (x >= W) {\n-                        if (setPixels(0, y, W, 1, model, raster, 0, W) <= 0) {\n-                            return;\n+                    model = new IndexColorModel(8, 2, XbmColormap,\n+                            0, false, 0);\n+                    setDimensions(W, H);\n+                    setColorModel(model);\n+                    setHints(XbmHints);\n+                    headerComplete();\n+                    raster = new byte[W];\n+                    state = 3;\n+                    break;\n+                }\n+            }\n+\n+            if (state != 3) {\n+                error(\"Width or Height of XBM file not defined\");\n+            }\n+\n+            \/\/ loop to process image data\n+            while (!aborted && (line = br.readLine()) != null) {\n+                lineNum++;\n+\n+                if (line.contains(\"[]\")) {\n+                    Matcher matcher = Pattern.compile(matchRegex).matcher(line);\n+                    while (matcher.find()) {\n+                        if (y >= H) {\n+                            error(\"Scan size of XBM file exceeds\"\n+                                    + \" the defined width x height\");\n+                        }\n+\n+                        int startIndex = matcher.start();\n+                        int endIndex = matcher.end();\n+                        String hexByte = line.substring(startIndex, endIndex);\n+\n+                        if (!(hexByte.startsWith(\"0x\")\n+                                || hexByte.startsWith(\"0X\"))) {\n+                            error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n+                                    + \" Col#:\" + (startIndex + 1));\n@@ -140,3 +171,4 @@\n-                        x = 0;\n-                        if (y++ >= H) {\n-                            break;\n+                        hexByte = hexByte.replaceAll(replaceRegex, \"\");\n+                        if (hexByte.length() != 2) {\n+                            error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n+                                    + \" Col#:\" + (startIndex + 1));\n@@ -144,9 +176,15 @@\n-                    }\n-                } else {\n-                    int n = 0;\n-                    for (int p = 0; p < nc; p++)\n-                        if ('0' <= (c = nm[p]) && c <= '9')\n-                            n = n * 10 + c - '0';\n-                        else {\n-                            n = -1;\n-                            break;\n+\n+                        try {\n+                            n = Integer.parseInt(hexByte, 16);\n+                        } catch (NumberFormatException nfe) {\n+                            error(\"Error parsing hexadecimal at Ln#:\" + lineNum\n+                                    + \" Col#:\" + (startIndex + 1));\n+                        }\n+                        for (int mask = 1; mask <= 0x80; mask <<= 1) {\n+                            if (x < W) {\n+                                if ((n & mask) != 0)\n+                                    raster[x] = 1;\n+                                else\n+                                    raster[x] = 0;\n+                            }\n+                            x++;\n@@ -154,16 +192,8 @@\n-                    if (n > 0 && state > 0) {\n-                        if (state == 1)\n-                            W = n;\n-                        else\n-                            H = n;\n-                        if (W == 0 || H == 0)\n-                            state = 0;\n-                        else {\n-                            model = new IndexColorModel(8, 2, XbmColormap,\n-                                                        0, false, 0);\n-                            setDimensions(W, H);\n-                            setColorModel(model);\n-                            setHints(XbmHints);\n-                            headerComplete();\n-                            raster = new byte[W];\n-                            state = -1;\n+\n+                        if (x >= W) {\n+                            int result = setPixels(0, y, W, 1, model, raster, 0, W);\n+                            if (result <= 0) {\n+                                error(\"Unexpected error occurred during setPixel()\");\n+                            }\n+                            x = 0;\n+                            y++;\n@@ -174,0 +204,1 @@\n+            imageComplete(ImageConsumer.STATICIMAGEDONE, true);\n@@ -175,2 +206,0 @@\n-        input.close();\n-        imageComplete(ImageConsumer.STATICIMAGEDONE, true);\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/XbmImageDecoder.java","additions":117,"deletions":88,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361748\n+ * @summary Tests XBM image size limits and if XBMImageDecoder.produceImage()\n+ *          throws appropriate error when parsing invalid XBM image data.\n+ * @run main XBMDecoderTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.PrintStream;\n+import javax.swing.ImageIcon;\n+\n+public class XBMDecoderTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        String dir = System.getProperty(\"test.src\");\n+        PrintStream originalErr = System.err;\n+        boolean validCase;\n+\n+        File currentDir = new File(dir);\n+        File[] files = currentDir.listFiles((File d, String s)\n+                                            -> s.endsWith(\".xbm\"));\n+\n+        for (File file : files) {\n+            String fileName = file.getName();\n+            validCase = fileName.startsWith(\"valid\");\n+\n+            System.out.println(\"--- Testing \" + fileName + \" ---\");\n+            try (FileInputStream fis = new FileInputStream(file);\n+                 ByteArrayOutputStream errContent = new ByteArrayOutputStream()) {\n+                System.setErr(new PrintStream(errContent));\n+\n+                ImageIcon icon = new ImageIcon(fis.readAllBytes());\n+                boolean isErrEmpty = errContent.toString().isEmpty();\n+                if (!isErrEmpty) {\n+                    System.out.println(\"Expected ImageFormatException occurred.\");\n+                    System.out.print(errContent);\n+                }\n+\n+                if (validCase && !isErrEmpty) {\n+                    throw new RuntimeException(\"Test failed: Error stream not empty\");\n+                } else if (!validCase && isErrEmpty) {\n+                    throw new RuntimeException(\"Test failed: ImageFormatException\"\n+                            + \" expected but not thrown\");\n+                }\n+                System.out.println(\"PASSED\\n\");\n+            } finally {\n+                System.setErr(originalErr);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/XBMDecoderTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+#define k_ht 3\n+h` k[] = { 01x0, 42222222222236319330::\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid.xbm","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+#define k_wt 16\n+#define k_ht  1\n+k[] = { 0x10, 1234567890};\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_hex.xbm","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+#define k_wt 16\n+#define k_ht  0\n+k[] = { 0x10, 0x12};\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_ht.xbm","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+#define test_width 16\n+#define test_height 3\n+#define ht_x 1\n+#define ht_y 2\n+static unsigned char test_bits[] = {\n+0x13, 0x11, 0x15, 0x00, 0xAB, 0xcd };\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/valid.xbm","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+#define test_width 16\n+#define test_height 2\n+static unsigned char test_bits[] = { 0x13, 0x11,\n+ 0xAB, 0xff };\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/valid_hex.xbm","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"}]}