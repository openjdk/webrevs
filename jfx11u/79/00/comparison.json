{"files":[{"patch":"@@ -35,0 +35,1 @@\n+#include <utility>\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/API\/JSRetainPtr.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -179,0 +179,1 @@\n+    \".text\" \"\\n\"\n@@ -519,0 +520,1 @@\n+    \".text\" \"\\n\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/assembler\/MacroAssemblerX86Common.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    const ObjectPropertyConditionSet& conditionSet, RefPtr<PolyProtoAccessChain>&& prototypeAccessChain)\n+    const ObjectPropertyConditionSet& conditionSet, RefPtr<PolyProtoAccessChain>&& prototypeAccessChain, const StructureStubInfo& stubInfo)\n@@ -132,4 +132,38 @@\n-    if (GPRInfo::numberOfRegisters < 6\n-        && oldStructure->outOfLineCapacity() != newStructure->outOfLineCapacity()\n-        && oldStructure->outOfLineCapacity()) {\n-        return nullptr;\n+    if (oldStructure->outOfLineCapacity() != newStructure->outOfLineCapacity()) {\n+        \/\/ In 64 bits jsc uses 1 register for value, and it uses 2 registers in 32 bits\n+        size_t requiredRegisters = 1; \/\/ stubInfo.valueRegs()\n+#if USE(JSVALUE32_64)\n+        ++requiredRegisters;\n+#endif\n+\n+        \/\/ 1 register for the property in 64 bits\n+        ++requiredRegisters;\n+#if USE(JSVALUE32_64)\n+        \/\/ In 32 bits, jsc uses may use one extra register, if it is not a Cell\n+        if (stubInfo.propertyRegs().tagGPR() != InvalidGPRReg)\n+            ++requiredRegisters;\n+#endif\n+\n+        \/\/ 1 register for the base in 64 bits\n+        ++requiredRegisters;\n+#if USE(JSVALUE32_64)\n+        \/\/ In 32 bits, jsc uses may use one extra register, if it is not a Cell\n+        if (stubInfo.baseRegs().tagGPR() != InvalidGPRReg)\n+            ++requiredRegisters;\n+#endif\n+\n+        if (stubInfo.m_stubInfoGPR != InvalidGPRReg)\n+            ++requiredRegisters;\n+        if (stubInfo.m_arrayProfileGPR != InvalidGPRReg)\n+            ++requiredRegisters;\n+\n+        \/\/ One extra register for scratchGPR\n+        ++requiredRegisters;\n+\n+        \/\/ Check if we have enough registers when reallocating\n+        if (oldStructure->outOfLineCapacity() && GPRInfo::numberOfRegisters < requiredRegisters)\n+            return nullptr;\n+\n+        \/\/ If we are (re)allocating inline, jsc needs two extra scratchGPRs\n+        if (!oldStructure->couldHaveIndexingHeader() && GPRInfo::numberOfRegisters < (requiredRegisters + 2))\n+            return nullptr;\n@@ -1487,1 +1521,0 @@\n-                failAndRepatch.append(jit.branchIfNaN(state.scratchFPR));\n@@ -1489,1 +1522,0 @@\n-                failAndRepatch.append(jit.branch32(CCallHelpers::Above, valueRegs.tagGPR(), CCallHelpers::TrustedImm32(JSValue::LowestTag)));\n@@ -1492,0 +1524,1 @@\n+                failAndRepatch.append(jit.branchIfNaN(state.scratchFPR));\n@@ -2253,1 +2286,1 @@\n-        \/\/ AccessCase::transition() should have returned null if this wasn't true.\n+        \/\/ AccessCase::createTransition() should have returned null if this wasn't true.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/bytecode\/AccessCase.cpp","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-        Structure* newStructure, const ObjectPropertyConditionSet&, RefPtr<PolyProtoAccessChain>&&);\n+        Structure* newStructure, const ObjectPropertyConditionSet&, RefPtr<PolyProtoAccessChain>&&, const StructureStubInfo&);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/bytecode\/AccessCase.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3144,2 +3144,13 @@\n-            else if (base.isObject())\n-                structure = m_vm.structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());\n+            else if (base.isObject()) {\n+                \/\/ Having a bad time clears the structureCache, and so it should invalidate this structure.\n+                bool isHavingABadTime = globalObject->isHavingABadTime();\n+                WTF::loadLoadFence();\n+                if (!isHavingABadTime)\n+                    m_graph.watchpoints().addLazily(globalObject->havingABadTimeWatchpoint());\n+                \/\/ Normally, we would always install a watchpoint. In this case, however, if we haveABadTime, we\n+                \/\/ still want to optimize. There is no watchpoint for that case though, so we need to make sure this load\n+                \/\/ does not get hoisted above the check.\n+                WTF::loadLoadFence();\n+                structure = m_vm.structureCache\n+                    .emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());\n+            }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGAbstractInterpreterInlines.h","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -6485,1 +6485,3 @@\n-                        if (auto* impl = string->tryGetValueImpl(); impl->isAtom() && !parseIndex(*const_cast<StringImpl*>(impl))) {\n+                        auto* impl = string->tryGetValueImpl();\n+                        ASSERT(impl); \/\/ FIXME: rdar:\/\/83902782\n+                        if (impl && impl->isAtom() && !parseIndex(*const_cast<StringImpl*>(impl))) {\n@@ -8867,1 +8869,3 @@\n-                if (auto* impl = string->tryGetValueImpl(); impl->isAtom() && !parseIndex(*const_cast<StringImpl*>(impl))) {\n+                auto* impl = string->tryGetValueImpl();\n+                ASSERT(impl); \/\/ FIXME: rdar:\/\/83902782\n+                if (impl && impl->isAtom() && !parseIndex(*const_cast<StringImpl*>(impl))) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGByteCodeParser.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -842,2 +842,13 @@\n-                    else if (base.isObject())\n-                        structure = globalObject->vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());\n+                    else if (base.isObject()) {\n+                        \/\/ Having a bad time clears the structureCache, and so it should invalidate this structure.\n+                        bool isHavingABadTime = globalObject->isHavingABadTime();\n+                        WTF::loadLoadFence();\n+                        if (!isHavingABadTime)\n+                            m_graph.watchpoints().addLazily(globalObject->havingABadTimeWatchpoint());\n+                        \/\/ Normally, we would always install a watchpoint. In this case, however, if we haveABadTime, we\n+                        \/\/ still want to optimize. There is no watchpoint for that case though, so we need to make sure this load\n+                        \/\/ does not get hoisted above the check.\n+                        WTF::loadLoadFence();\n+                        structure = globalObject->vm().structureCache\n+                            .emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());\n+                    }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGConstantFoldingPhase.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1846,1 +1846,2 @@\n-    ArrayPrototype* arrayPrototype = globalObjectFor(node->child1()->origin.semantic)->arrayPrototype();\n+    JSGlobalObject* globalObject = globalObjectFor(node->child1()->origin.semantic);\n+    ArrayPrototype* arrayPrototype = globalObject->arrayPrototype();\n@@ -1849,1 +1850,2 @@\n-        allGood &= structure->hasMonoProto()\n+        allGood &= structure->globalObject() == globalObject\n+            && structure->hasMonoProto()\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGGraph.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2015-2020 Apple Inc. All rights reserved.\n+ * Copyright (C) 2015-2021 Apple Inc. All rights reserved.\n@@ -231,2 +231,11 @@\n-        if (m_right->isInt32Constant() && other.m_right->isInt32Constant())\n-            return (m_right->asInt32() + m_offset) == (other.m_right->asInt32() + other.m_offset);\n+        if (m_right->isInt32Constant() && other.m_right->isInt32Constant()) {\n+            int thisRight = m_right->asInt32();\n+            int otherRight = other.m_right->asInt32();\n+\n+            if (sumOverflows<int>(thisRight, m_offset))\n+                return false;\n+            if (sumOverflows<int>(otherRight, other.m_offset))\n+                return false;\n+\n+            return (thisRight + m_offset) == (otherRight + other.m_offset);\n+        }\n@@ -1394,1 +1403,19 @@\n-            setRelationship(Relationship(node, m_zero, Relationship::GreaterThan, -1));\n+\n+            \/\/ If ArithAbs cares about overflow, then INT32_MIN input will cause OSR exit.\n+            \/\/ Thus we can safely say `x >= 0`.\n+            if (shouldCheckOverflow(node->arithMode())) {\n+                setRelationship(Relationship(node, m_zero, Relationship::GreaterThan, -1));\n+                break;\n+            }\n+\n+            \/\/ If ArithAbs does not care about overflow, it can return INT32_MIN if the input is INT32_MIN.\n+            \/\/ If minValue is not INT32_MIN, we can still say it is `x >= 0`.\n+            int minValue = std::numeric_limits<int>::min();\n+            auto iter = m_relationships.find(node->child1().node());\n+            if (iter != m_relationships.end()) {\n+                for (Relationship relationship : iter->value)\n+                    minValue = std::max(minValue, relationship.minValueOfLeft());\n+            }\n+\n+            if (minValue > std::numeric_limits<int>::min())\n+                setRelationship(Relationship(node, m_zero, Relationship::GreaterThan, -1));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGIntegerRangeOptimizationPhase.cpp","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2541,0 +2541,12 @@\n+JSC_DEFINE_JIT_OPERATION(operationEnumeratorGetByValGeneric, EncodedJSValue, (JSGlobalObject* globalObject, JSCell* baseCell, EncodedJSValue propertyNameValue, uint32_t index, int32_t modeNumber, JSPropertyNameEnumerator* enumerator))\n+{\n+    VM& vm = globalObject->vm();\n+    CallFrame* callFrame = DECLARE_CALL_FRAME(vm);\n+    JITOperationPrologueCallFrameTracer tracer(vm, callFrame);\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    JSValue property = JSValue::decode(propertyNameValue);\n+    JSPropertyNameEnumerator::Mode mode = static_cast<JSPropertyNameEnumerator::Mode>(modeNumber);\n+    RELEASE_AND_RETURN(scope, JSValue::encode(CommonSlowPaths::opEnumeratorGetByVal(globalObject, baseCell, property, index, mode, enumerator)));\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGOperations.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+JSC_DECLARE_JIT_OPERATION(operationEnumeratorGetByValGeneric, EncodedJSValue, (JSGlobalObject*, JSCell*, EncodedJSValue, uint32_t, int32_t, JSPropertyNameEnumerator*));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGOperations.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -13626,108 +13626,0 @@\n-void SpeculativeJIT::compileEnumeratorGetByVal(Node* node)\n-{\n-    Edge baseEdge = m_graph.varArgChild(node, 0);\n-    auto generate = [&] (GPRReg baseCellGPR) {\n-        MacroAssembler::JumpList doneCases;\n-        JSValueRegsTemporary result;\n-        JSValueRegs resultRegs;\n-        GPRReg indexGPR;\n-        GPRReg enumeratorGPR;\n-        MacroAssembler::Jump badStructureSlowPath;\n-\n-        compileGetByVal(node, scopedLambda<std::tuple<JSValueRegs, DataFormat>(DataFormat)>([&] (DataFormat) {\n-            Edge storageEdge = m_graph.varArgChild(node, 2);\n-            StorageOperand storage;\n-            if (storageEdge)\n-                storage.emplace(this, storageEdge);\n-            SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 3));\n-            SpeculateStrictInt32Operand mode(this, m_graph.varArgChild(node, 4));\n-            SpeculateCellOperand enumerator(this, m_graph.varArgChild(node, 5));\n-\n-            GPRReg modeGPR = mode.gpr();\n-            indexGPR = index.gpr();\n-            enumeratorGPR = enumerator.gpr();\n-\n-            result = JSValueRegsTemporary(this);\n-            resultRegs = result.regs();\n-            GPRReg scratchGPR = resultRegs.payloadGPR();\n-\n-            bool haveStorage = !!storageEdge;\n-            GPRTemporary storageTemporary;\n-            GPRReg storageGPR;\n-            if (!haveStorage) {\n-                storageTemporary = GPRTemporary(this, Reuse, enumerator);\n-                storageGPR = storageTemporary.gpr();\n-            } else\n-                storageGPR = storage.gpr();\n-\n-            MacroAssembler::JumpList notFastNamedCases;\n-\n-            \/\/ FIXME: We shouldn't generate this code if we know base is not an object.\n-            notFastNamedCases.append(m_jit.branchTest32(MacroAssembler::NonZero, modeGPR, TrustedImm32(JSPropertyNameEnumerator::IndexedMode | JSPropertyNameEnumerator::GenericMode)));\n-            {\n-                if (!m_state.forNode(baseEdge).isType(SpecCell))\n-                    notFastNamedCases.append(m_jit.branchIfNotCell(baseCellGPR));\n-\n-                \/\/ Check the structure\n-                \/\/ FIXME: If we know there's only one structure for base we can just embed it here.\n-                m_jit.load32(MacroAssembler::Address(baseCellGPR, JSCell::structureIDOffset()), scratchGPR);\n-\n-                auto badStructure = m_jit.branch32(\n-                    MacroAssembler::NotEqual,\n-                    scratchGPR,\n-                    MacroAssembler::Address(\n-                        enumeratorGPR, JSPropertyNameEnumerator::cachedStructureIDOffset()));\n-\n-                \/\/ FIXME: Maybe we should have a better way to represent Indexed+Named?\n-                if (m_graph.varArgChild(node, 1).node() == m_graph.varArgChild(node, 3).node())\n-                    badStructureSlowPath = badStructure;\n-                else\n-                    notFastNamedCases.append(badStructure);\n-\n-                \/\/ Compute the offset\n-                \/\/ If index is less than the enumerator's cached inline storage, then it's an inline access\n-                MacroAssembler::Jump outOfLineAccess = m_jit.branch32(MacroAssembler::AboveOrEqual,\n-                    indexGPR, MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()));\n-\n-                m_jit.loadValue(MacroAssembler::BaseIndex(baseCellGPR, indexGPR, MacroAssembler::TimesEight, JSObject::offsetOfInlineStorage()), resultRegs);\n-\n-                doneCases.append(m_jit.jump());\n-\n-                \/\/ Otherwise it's out of line\n-                outOfLineAccess.link(&m_jit);\n-                m_jit.move(indexGPR, scratchGPR);\n-                m_jit.sub32(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()), scratchGPR);\n-                m_jit.neg32(scratchGPR);\n-                m_jit.signExtend32ToPtr(scratchGPR, scratchGPR);\n-                if (!haveStorage)\n-                    m_jit.loadPtr(MacroAssembler::Address(baseCellGPR, JSObject::butterflyOffset()), storageGPR);\n-                constexpr intptr_t offsetOfFirstProperty = offsetInButterfly(firstOutOfLineOffset) * static_cast<intptr_t>(sizeof(EncodedJSValue));\n-                m_jit.loadValue(MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesEight, offsetOfFirstProperty), resultRegs);\n-                doneCases.append(m_jit.jump());\n-            }\n-\n-            notFastNamedCases.link(&m_jit);\n-            return std::make_pair(resultRegs, DataFormatJS);\n-        }));\n-\n-        \/\/ We rely on compileGetByVal to call jsValueResult for us.\n-        \/\/ FIXME: This is kinda hacky...\n-        ASSERT(generationInfo(node).jsValueRegs() == resultRegs && generationInfo(node).registerFormat() == DataFormatJS);\n-\n-        if (badStructureSlowPath.isSet())\n-            addSlowPathGenerator(slowPathCall(badStructureSlowPath, this, operationEnumeratorRecoverNameAndGetByVal, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node->origin.semantic)), baseCellGPR, indexGPR, enumeratorGPR));\n-\n-        doneCases.link(&m_jit);\n-    };\n-\n-    if (isCell(baseEdge.useKind())) {\n-        \/\/ Use manual operand speculation since Fixup may have picked a UseKind more restrictive than CellUse.\n-        speculate(node, baseEdge);\n-        SpeculateCellOperand baseOperand(this, baseEdge, ManualOperandSpeculation);\n-        generate(baseOperand.gpr());\n-    } else {\n-        JSValueOperand baseOperand(this, baseEdge);\n-        generate(baseOperand.gpr());\n-    }\n-}\n-\n@@ -13738,1 +13630,1 @@\n-    auto generate = [&] (auto base, GPRReg baseCellGPR) {\n+    auto generate = [&] (JSValueRegs baseRegs) {\n@@ -13757,1 +13649,1 @@\n-            operationCases.append(m_jit.branchIfNotCell(base));\n+            operationCases.append(m_jit.branchIfNotCell(baseRegs));\n@@ -13762,1 +13654,1 @@\n-        m_jit.load32(MacroAssembler::Address(baseCellGPR, JSCell::structureIDOffset()), resultRegs.payloadGPR());\n+        m_jit.load32(MacroAssembler::Address(baseRegs.payloadGPR(), JSCell::structureIDOffset()), resultRegs.payloadGPR());\n@@ -13770,7 +13662,4 @@\n-#if USE(JSVALUE32_64)\n-        m_jit.move(TrustedImm32(JSValue::CellTag), resultRegs.tagGPR());\n-        auto baseRegs = JSValueRegs(baseCellGPR, resultRegs.tagGPR());\n-#else\n-        auto baseRegs = base;\n-#endif\n-        callOperation(slowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node->origin.semantic)), baseRegs, propertyNameRegs, indexGPR, modeGPR);\n+        if (baseRegs.tagGPR() == InvalidGPRReg)\n+            callOperation(slowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node->origin.semantic)), CCallHelpers::CellValue(baseRegs.payloadGPR()), propertyNameRegs, indexGPR, modeGPR);\n+        else\n+            callOperation(slowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node->origin.semantic)), baseRegs, propertyNameRegs, indexGPR, modeGPR);\n@@ -13786,1 +13675,1 @@\n-        generate(base.gpr(), base.gpr());\n+        generate(JSValueRegs::payloadOnly(base.gpr()));\n@@ -13789,1 +13678,1 @@\n-        generate(base.regs(), base.regs().payloadGPR());\n+        generate(base.regs());\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGSpeculativeJIT.cpp","additions":9,"deletions":120,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -4483,0 +4483,23 @@\n+\/\/ FIXME: we are always taking the slow path here, we should be able to do the equivalent to the 64bit version if we add more available (callee-save registers) to ARMv7 and\/or if we reduce the number of registers compileEnumeratorGetByVal uses. See bug #230189.\n+void SpeculativeJIT::compileEnumeratorGetByVal(Node* node)\n+{\n+    SpeculateCellOperand baseOperand(this, m_graph.varArgChild(node, 0));\n+    JSValueOperand property(this, m_graph.varArgChild(node, 1));\n+    SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 3));\n+    SpeculateStrictInt32Operand mode(this, m_graph.varArgChild(node, 4));\n+    SpeculateCellOperand enumerator(this, m_graph.varArgChild(node, 5));\n+    GPRReg baseOperandGPR = baseOperand.gpr();\n+    JSValueRegs propertyRegs = property.jsValueRegs();\n+    GPRReg indexGPR = index.gpr();\n+    GPRReg modeGPR = mode.gpr();\n+    GPRReg enumeratorGPR = enumerator.gpr();\n+\n+    flushRegisters();\n+\n+    JSValueRegsFlushedCallResult result(this);\n+    JSValueRegs resultRegs = result.regs();\n+\n+    callOperation(operationEnumeratorGetByValGeneric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node->origin.semantic)), baseOperandGPR, propertyRegs, indexGPR, modeGPR, enumeratorGPR);\n+    m_jit.exceptionCheck();\n+    jsValueResult(resultRegs, node);\n+}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGSpeculativeJIT32_64.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -6266,0 +6266,108 @@\n+void SpeculativeJIT::compileEnumeratorGetByVal(Node* node)\n+{\n+    Edge baseEdge = m_graph.varArgChild(node, 0);\n+    auto generate = [&] (GPRReg baseCellGPR) {\n+        MacroAssembler::JumpList doneCases;\n+        JSValueRegsTemporary result;\n+        JSValueRegs resultRegs;\n+        GPRReg indexGPR;\n+        GPRReg enumeratorGPR;\n+        MacroAssembler::Jump badStructureSlowPath;\n+\n+        compileGetByVal(node, scopedLambda<std::tuple<JSValueRegs, DataFormat>(DataFormat)>([&] (DataFormat) {\n+            Edge storageEdge = m_graph.varArgChild(node, 2);\n+            StorageOperand storage;\n+            if (storageEdge)\n+                storage.emplace(this, storageEdge);\n+            SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 3));\n+            SpeculateStrictInt32Operand mode(this, m_graph.varArgChild(node, 4));\n+            SpeculateCellOperand enumerator(this, m_graph.varArgChild(node, 5));\n+\n+            GPRReg modeGPR = mode.gpr();\n+            indexGPR = index.gpr();\n+            enumeratorGPR = enumerator.gpr();\n+\n+            result = JSValueRegsTemporary(this);\n+            resultRegs = result.regs();\n+            GPRReg scratchGPR = resultRegs.payloadGPR();\n+\n+            bool haveStorage = !!storageEdge;\n+            GPRTemporary storageTemporary;\n+            GPRReg storageGPR;\n+            if (!haveStorage) {\n+                storageTemporary = GPRTemporary(this, Reuse, enumerator);\n+                storageGPR = storageTemporary.gpr();\n+            } else\n+                storageGPR = storage.gpr();\n+\n+            MacroAssembler::JumpList notFastNamedCases;\n+\n+            \/\/ FIXME: We shouldn't generate this code if we know base is not an object.\n+            notFastNamedCases.append(m_jit.branchTest32(MacroAssembler::NonZero, modeGPR, TrustedImm32(JSPropertyNameEnumerator::IndexedMode | JSPropertyNameEnumerator::GenericMode)));\n+            {\n+                if (!m_state.forNode(baseEdge).isType(SpecCell))\n+                    notFastNamedCases.append(m_jit.branchIfNotCell(baseCellGPR));\n+\n+                \/\/ Check the structure\n+                \/\/ FIXME: If we know there's only one structure for base we can just embed it here.\n+                m_jit.load32(MacroAssembler::Address(baseCellGPR, JSCell::structureIDOffset()), scratchGPR);\n+\n+                auto badStructure = m_jit.branch32(\n+                    MacroAssembler::NotEqual,\n+                    scratchGPR,\n+                    MacroAssembler::Address(\n+                        enumeratorGPR, JSPropertyNameEnumerator::cachedStructureIDOffset()));\n+\n+                \/\/ FIXME: Maybe we should have a better way to represent Indexed+Named?\n+                if (m_graph.varArgChild(node, 1).node() == m_graph.varArgChild(node, 3).node())\n+                    badStructureSlowPath = badStructure;\n+                else\n+                    notFastNamedCases.append(badStructure);\n+\n+                \/\/ Compute the offset\n+                \/\/ If index is less than the enumerator's cached inline storage, then it's an inline access\n+                MacroAssembler::Jump outOfLineAccess = m_jit.branch32(MacroAssembler::AboveOrEqual,\n+                    indexGPR, MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()));\n+\n+                m_jit.loadValue(MacroAssembler::BaseIndex(baseCellGPR, indexGPR, MacroAssembler::TimesEight, JSObject::offsetOfInlineStorage()), resultRegs);\n+\n+                doneCases.append(m_jit.jump());\n+\n+                \/\/ Otherwise it's out of line\n+                outOfLineAccess.link(&m_jit);\n+                m_jit.move(indexGPR, scratchGPR);\n+                m_jit.sub32(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()), scratchGPR);\n+                m_jit.neg32(scratchGPR);\n+                m_jit.signExtend32ToPtr(scratchGPR, scratchGPR);\n+                if (!haveStorage)\n+                    m_jit.loadPtr(MacroAssembler::Address(baseCellGPR, JSObject::butterflyOffset()), storageGPR);\n+                constexpr intptr_t offsetOfFirstProperty = offsetInButterfly(firstOutOfLineOffset) * static_cast<intptr_t>(sizeof(EncodedJSValue));\n+                m_jit.loadValue(MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesEight, offsetOfFirstProperty), resultRegs);\n+                doneCases.append(m_jit.jump());\n+            }\n+\n+            notFastNamedCases.link(&m_jit);\n+            return std::make_pair(resultRegs, DataFormatJS);\n+        }));\n+\n+        \/\/ We rely on compileGetByVal to call jsValueResult for us.\n+        \/\/ FIXME: This is kinda hacky...\n+        ASSERT(generationInfo(node).jsValueRegs() == resultRegs && generationInfo(node).registerFormat() == DataFormatJS);\n+\n+        if (badStructureSlowPath.isSet())\n+            addSlowPathGenerator(slowPathCall(badStructureSlowPath, this, operationEnumeratorRecoverNameAndGetByVal, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node->origin.semantic)), baseCellGPR, indexGPR, enumeratorGPR));\n+\n+        doneCases.link(&m_jit);\n+    };\n+\n+    if (isCell(baseEdge.useKind())) {\n+        \/\/ Use manual operand speculation since Fixup may have picked a UseKind more restrictive than CellUse.\n+        speculate(node, baseEdge);\n+        SpeculateCellOperand baseOperand(this, baseEdge, ManualOperandSpeculation);\n+        generate(baseOperand.gpr());\n+    } else {\n+        JSValueOperand baseOperand(this, baseEdge);\n+        generate(baseOperand.gpr());\n+    }\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/dfg\/DFGSpeculativeJIT64.cpp","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -250,0 +250,2 @@\n+    \/\/ FIXME: We need to handle JSONP interpretation case in ProgramExecutable since it does not have vm.topCallFrame.\n+    \/\/ rdar:\/\/83691438\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/interpreter\/CallFrame.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class Structure;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/jit\/JITStubRoutine.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-                newCase = AccessCase::createTransition(vm, codeBlock, propertyName, offset, oldStructure, newStructure, conditionSet, WTFMove(prototypeAccessChain));\n+                newCase = AccessCase::createTransition(vm, codeBlock, propertyName, offset, oldStructure, newStructure, conditionSet, WTFMove(prototypeAccessChain), stubInfo);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/jit\/Repatch.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2471,2 +2471,2 @@\n-    vm.deferredWorkTimer->addPendingWork(vm, callback, { });\n-    vm.deferredWorkTimer->scheduleWorkSoon(callback, [callback](DeferredWorkTimer::Ticket, DeferredWorkTimer::TicketData&&) {\n+    auto ticket = vm.deferredWorkTimer->addPendingWork(vm, callback, { });\n+    vm.deferredWorkTimer->scheduleWorkSoon(ticket, [callback](DeferredWorkTimer::Ticket) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/jsc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1013,0 +1013,1 @@\n+    JSValue propertyName = GET(bytecode.m_propertyName).jsValue();\n@@ -1016,1 +1017,0 @@\n-\n@@ -1019,15 +1019,0 @@\n-    switch (mode) {\n-    case JSPropertyNameEnumerator::IndexedMode: {\n-        if (LIKELY(baseValue.isCell()))\n-            metadata.m_arrayProfile.observeStructureID(baseValue.asCell()->structureID());\n-        RETURN_PROFILED(baseValue.get(globalObject, static_cast<unsigned>(index)));\n-    }\n-    case JSPropertyNameEnumerator::OwnStructureMode: {\n-        if (LIKELY(baseValue.isCell()) && baseValue.asCell()->structureID() == enumerator->cachedStructureID()) {\n-            \/\/ We'll only match the structure ID if the base is an object.\n-            ASSERT(index < enumerator->endStructurePropertyIndex());\n-            RETURN_PROFILED(baseValue.getObject()->getDirect(index < enumerator->cachedInlineCapacity() ? index : index - enumerator->cachedInlineCapacity() + firstOutOfLineOffset));\n-        } else\n-            metadata.m_enumeratorMetadata |= static_cast<uint8_t>(JSPropertyNameEnumerator::HasSeenOwnStructureModeStructureMismatch);\n-        FALLTHROUGH;\n-    }\n@@ -1035,14 +1020,1 @@\n-    case JSPropertyNameEnumerator::GenericMode: {\n-        if (baseValue.isCell() && mode != JSPropertyNameEnumerator::OwnStructureMode)\n-            metadata.m_arrayProfile.observeStructureID(baseValue.asCell()->structureID());\n-        JSString* string = asString(GET(bytecode.m_propertyName).jsValue());\n-        auto propertyName = string->toIdentifier(globalObject);\n-        CHECK_EXCEPTION();\n-        RETURN_PROFILED(baseValue.get(globalObject, propertyName));\n-    }\n-\n-    default:\n-        RELEASE_ASSERT_NOT_REACHED();\n-        break;\n-    };\n-    RELEASE_ASSERT_NOT_REACHED();\n+    RETURN_PROFILED(CommonSlowPaths::opEnumeratorGetByVal(globalObject, baseValue, propertyName, index, mode, enumerator, &metadata.m_arrayProfile, &metadata.m_enumeratorMetadata));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/CommonSlowPaths.cpp","additions":2,"deletions":30,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"JSPropertyNameEnumerator.h\"\n@@ -94,0 +95,54 @@\n+inline JSValue opEnumeratorGetByVal(JSGlobalObject* globalObject, JSValue baseValue, JSValue propertyNameValue, unsigned index, JSPropertyNameEnumerator::Mode mode, JSPropertyNameEnumerator* enumerator, ArrayProfile* arrayProfile = nullptr, uint8_t* enumeratorMetadata = nullptr)\n+{\n+    VM& vm = getVM(globalObject);\n+    auto scope = DECLARE_THROW_SCOPE(vm);\n+\n+    switch (mode) {\n+    case JSPropertyNameEnumerator::IndexedMode: {\n+        if (arrayProfile && LIKELY(baseValue.isCell()))\n+            arrayProfile->observeStructureID(baseValue.asCell()->structureID());\n+        RELEASE_AND_RETURN(scope, baseValue.get(globalObject, static_cast<unsigned>(index)));\n+    }\n+    case JSPropertyNameEnumerator::OwnStructureMode: {\n+        if (LIKELY(baseValue.isCell()) && baseValue.asCell()->structureID() == enumerator->cachedStructureID()) {\n+            \/\/ We'll only match the structure ID if the base is an object.\n+            ASSERT(index < enumerator->endStructurePropertyIndex());\n+            RELEASE_AND_RETURN(scope, baseValue.getObject()->getDirect(index < enumerator->cachedInlineCapacity() ? index : index - enumerator->cachedInlineCapacity() + firstOutOfLineOffset));\n+        } else {\n+            if (enumeratorMetadata)\n+                *enumeratorMetadata |= static_cast<uint8_t>(JSPropertyNameEnumerator::HasSeenOwnStructureModeStructureMismatch);\n+        }\n+        FALLTHROUGH;\n+    }\n+\n+    case JSPropertyNameEnumerator::GenericMode: {\n+        if (arrayProfile && baseValue.isCell() && mode != JSPropertyNameEnumerator::OwnStructureMode)\n+            arrayProfile->observeStructureID(baseValue.asCell()->structureID());\n+#if USE(JSVALUE32_64)\n+        if (!propertyNameValue.isCell()) {\n+            \/\/ This branch is only needed because we use this method\n+            \/\/ both as a slow_path and as a DFG call op. We'll end up\n+            \/\/ here if propertyName is not a cell then we are in\n+            \/\/ index+named mode, so do what RecoverNameAndGetVal\n+            \/\/ does. This can probably be removed if we re-enable the\n+            \/\/ optimizations for enumeratorGetByVal in DFG, see bug\n+            \/\/ #230189.\n+            JSString* string = enumerator->propertyNameAtIndex(index);\n+            auto propertyName = string->toIdentifier(globalObject);\n+            RETURN_IF_EXCEPTION(scope, { });\n+            RELEASE_AND_RETURN(scope, baseValue.get(globalObject, propertyName));\n+        }\n+#endif\n+        JSString* string = asString(propertyNameValue);\n+        auto propertyName = string->toIdentifier(globalObject);\n+        RETURN_IF_EXCEPTION(scope, { });\n+        RELEASE_AND_RETURN(scope, baseValue.get(globalObject, propertyName));\n+    }\n+\n+    default:\n+        RELEASE_ASSERT_NOT_REACHED();\n+        break;\n+    };\n+    RELEASE_ASSERT_NOT_REACHED();\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/CommonSlowPaths.h","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2017-2020 Apple Inc. All rights reserved.\n+ * Copyright (C) 2017-2021 Apple Inc. All rights reserved.\n@@ -40,0 +40,19 @@\n+inline DeferredWorkTimer::TicketData::TicketData(VM& vm, JSObject* scriptExecutionOwner, Vector<Strong<JSCell>>&& dependencies)\n+    : dependencies(WTFMove(dependencies))\n+    , scriptExecutionOwner(vm, scriptExecutionOwner)\n+{\n+}\n+\n+inline VM& DeferredWorkTimer::TicketData::vm()\n+{\n+    ASSERT(!isCancelled());\n+    return target()->vm();\n+}\n+\n+inline void DeferredWorkTimer::TicketData::cancel()\n+{\n+    scriptExecutionOwner.clear();\n+    dependencies.clear();\n+}\n+\n+\n@@ -57,1 +76,0 @@\n-        auto globalObject = ticket->structure(vm)->globalObject();\n@@ -64,0 +82,6 @@\n+        ASSERT(ticket == pendingTicket->get());\n+\n+        if (ticket->isCancelled()) {\n+            m_pendingTickets.remove(pendingTicket);\n+            continue;\n+        }\n@@ -65,1 +89,4 @@\n-        switch (globalObject->globalObjectMethodTable()->scriptExecutionStatus(globalObject, pendingTicket->value.scriptExecutionOwner.get())) {\n+        \/\/ We shouldn't access the TicketData to get this globalObject until\n+        \/\/ after we confirm that the ticket is still valid (which we did above).\n+        auto globalObject = ticket->target()->structure(vm)->globalObject();\n+        switch (globalObject->globalObjectMethodTable()->scriptExecutionStatus(globalObject, ticket->scriptExecutionOwner.get())) {\n@@ -78,2 +105,1 @@\n-        auto ticketData = WTFMove(pendingTicket->value);\n-        m_pendingTickets.remove(pendingTicket);\n+        std::unique_ptr<TicketData> ticketData = m_pendingTickets.take(pendingTicket);\n@@ -90,1 +116,2 @@\n-            task(ticket, WTFMove(ticketData));\n+            task(ticket);\n+            ticketData = nullptr;\n@@ -92,1 +119,0 @@\n-                auto* globalObject = ticket->globalObject();\n@@ -106,0 +132,7 @@\n+    \/\/ It is theoretically possible that a client may cancel a pending ticket and\n+    \/\/ never call scheduleWorkSoon() on it. As such, it would not be found when\n+    \/\/ we iterated m_tasks above. We'll need to make sure to purge them here.\n+    m_pendingTickets.removeIf([] (auto& ticket) {\n+        return ticket->isCancelled();\n+    });\n+\n@@ -121,1 +154,1 @@\n-void DeferredWorkTimer::addPendingWork(VM& vm, Ticket ticket, Vector<Strong<JSCell>>&& dependencies)\n+DeferredWorkTimer::Ticket DeferredWorkTimer::addPendingWork(VM& vm, JSObject* target, Vector<Strong<JSCell>>&& dependencies)\n@@ -125,13 +158,14 @@\n-        ASSERT(dependencies[i].get() != ticket);\n-\n-    auto globalObject = ticket->globalObject();\n-    auto result = m_pendingTickets.ensure(ticket, [&] {\n-        dataLogLnIf(DeferredWorkTimerInternal::verbose, \"Adding new pending ticket: \", RawPointer(ticket));\n-        JSObject* scriptExecutionOwner = globalObject->globalObjectMethodTable()->currentScriptExecutionOwner(globalObject);\n-        dependencies.append(Strong<JSCell>(vm, ticket));\n-        return TicketData { WTFMove(dependencies), Strong<JSObject>(vm, scriptExecutionOwner) };\n-    });\n-    if (!result.isNewEntry) {\n-        dataLogLnIf(DeferredWorkTimerInternal::verbose, \"Adding new dependencies for ticket: \", RawPointer(ticket));\n-        result.iterator->value.dependencies.appendVector(WTFMove(dependencies));\n-    }\n+        ASSERT(dependencies[i].get() != target);\n+\n+    auto* globalObject = target->globalObject();\n+    JSObject* scriptExecutionOwner = globalObject->globalObjectMethodTable()->currentScriptExecutionOwner(globalObject);\n+    dependencies.append(Strong<JSCell>(vm, target));\n+\n+    auto ticketData = makeUnique<TicketData>(vm, scriptExecutionOwner, WTFMove(dependencies));\n+    Ticket ticket = ticketData.get();\n+\n+    dataLogLnIf(DeferredWorkTimerInternal::verbose, \"Adding new pending ticket: \", RawPointer(ticket));\n+    auto result = m_pendingTickets.add(WTFMove(ticketData));\n+    RELEASE_ASSERT(result.isNewEntry);\n+\n+    return ticket;\n@@ -142,0 +176,3 @@\n+    auto result = m_pendingTickets.find(ticket);\n+    if (result == m_pendingTickets.end() || ticket->isCancelled())\n+        return false;\n@@ -143,1 +180,1 @@\n-    return m_pendingTickets.contains(ticket);\n+    return true;\n@@ -148,0 +185,3 @@\n+    auto result = m_pendingTickets.find(ticket);\n+    if (result == m_pendingTickets.end() || ticket->isCancelled())\n+        return false;\n@@ -149,4 +189,1 @@\n-    ASSERT(m_pendingTickets.contains(ticket));\n-\n-    auto result = m_pendingTickets.get(ticket);\n-    return result.dependencies.contains(dependency);\n+    return (*result)->dependencies.contains(dependency);\n@@ -165,2 +202,2 @@\n-    ASSERT(ticket->vm().currentThreadIsHoldingAPILock() || (Thread::mayBeGCThread() && ticket->vm().heap.worldIsStopped()));\n-    bool result = m_pendingTickets.remove(ticket);\n+    ASSERT(m_pendingTickets.contains(ticket));\n+    ASSERT(ticket->isCancelled() || ticket->vm().currentThreadIsHoldingAPILock() || (Thread::mayBeGCThread() && ticket->vm().heap.worldIsStopped()));\n@@ -168,1 +205,2 @@\n-    if (result)\n+    bool result = false;\n+    if (!ticket->isCancelled()) {\n@@ -170,0 +208,3 @@\n+        ticket->cancel();\n+        result = true;\n+    }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/DeferredWorkTimer.cpp","additions":70,"deletions":29,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2017-2020 Apple Inc. All rights reserved.\n+ * Copyright (C) 2017-2021 Apple Inc. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"JSCast.h\"\n@@ -32,1 +33,1 @@\n-#include <wtf\/HashMap.h>\n+#include <wtf\/HashSet.h>\n@@ -47,0 +48,11 @@\n+    private:\n+        WTF_MAKE_FAST_ALLOCATED;\n+    public:\n+        TicketData(VM&, JSObject* scriptExecutionOwner, Vector<Strong<JSCell>>&& dependencies);\n+\n+        VM& vm();\n+        JSObject* target();\n+\n+        void cancel();\n+        bool isCancelled() const { return !scriptExecutionOwner.get(); }\n+\n@@ -51,0 +63,2 @@\n+    using Ticket = TicketData*;\n+\n@@ -53,2 +67,1 @@\n-    using Ticket = JSObject*;\n-    void addPendingWork(VM&, Ticket, Vector<Strong<JSCell>>&& dependencies);\n+    Ticket addPendingWork(VM&, JSObject* target, Vector<Strong<JSCell>>&& dependencies);\n@@ -64,1 +77,1 @@\n-    using Task = Function<void(Ticket, TicketData&&)>;\n+    using Task = Function<void(Ticket)>;\n@@ -80,1 +93,1 @@\n-    HashMap<Ticket, TicketData> m_pendingTickets;\n+    HashSet<std::unique_ptr<TicketData>> m_pendingTickets;\n@@ -83,0 +96,6 @@\n+inline JSObject* DeferredWorkTimer::TicketData::target()\n+{\n+    ASSERT(!isCancelled());\n+    return jsCast<JSObject*>(dependencies.last().get());\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/DeferredWorkTimer.h","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"IntlDisplayNames.h\"\n@@ -56,0 +57,1 @@\n+#if HAVE(ICU_U_LOCALE_DISPLAY_NAMES)\n@@ -67,0 +69,1 @@\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/IntlCache.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"IntlDisplayNames.h\"\n@@ -42,0 +43,1 @@\n+#if HAVE(ICU_U_LOCALE_DISPLAY_NAMES)\n@@ -43,0 +45,1 @@\n+#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/IntlCache.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -152,4 +152,4 @@\n-    if (!vm.deferredWorkTimer->hasPendingWork(this) && (readiedCell || deadCount(locker))) {\n-        vm.deferredWorkTimer->addPendingWork(vm, this, { });\n-        ASSERT(vm.deferredWorkTimer->hasPendingWork(this));\n-        vm.deferredWorkTimer->scheduleWorkSoon(this, [this](DeferredWorkTimer::Ticket, DeferredWorkTimer::TicketData&&) {\n+    if (!m_hasAlreadyScheduledWork && (readiedCell || deadCount(locker))) {\n+        auto ticket = vm.deferredWorkTimer->addPendingWork(vm, this, { });\n+        ASSERT(vm.deferredWorkTimer->hasPendingWork(ticket));\n+        vm.deferredWorkTimer->scheduleWorkSoon(ticket, [this](DeferredWorkTimer::Ticket) {\n@@ -157,0 +157,1 @@\n+            this->m_hasAlreadyScheduledWork = false;\n@@ -159,0 +160,1 @@\n+        m_hasAlreadyScheduledWork = true;\n@@ -243,0 +245,1 @@\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/JSFinalizationRegistry.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    bool m_hasAlreadyScheduledWork { false };\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/JSFinalizationRegistry.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1941,0 +1941,9 @@\n+    \/\/ This must happen first, because the compiler thread may race with haveABadTime.\n+    \/\/ Let R_BT, W_BT <- Read\/Fire the watchpoint, R_SC, W_SC <- Read\/clear the structure cache.\n+    \/\/ The possible interleavings are:\n+    \/\/ R_BT, R_SC, W_SC, W_BT: Compiler thread installs a watchpoint, and the code is discarded.\n+    \/\/ R_BT, W_SC, R_SC, W_BT: ^ Same\n+    \/\/ R_BT, W_SC, W_BT, W_SC: ^ Same\n+    \/\/ W_SC, R_BT, R_SC, W_BT: ^ Same\n+    \/\/ W_SC, R_BT, W_BT, R_SC: ^ Same\n+    \/\/ W_SC, W_BT, R_BT, R_SC: No watchpoint is installed, but we could not see old structures from the cache.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/JSGlobalObject.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+void StructureCache::clear()\n+{\n+    Locker locker { m_lock };\n+    m_structures.clear();\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/StructureCache.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    void clear() { m_structures.clear(); }\n+    JS_EXPORT_PRIVATE void clear();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/runtime\/StructureCache.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-            llintCallee.setReplacement(callee.copyRef());\n+            llintCallee.setReplacement(callee.copyRef(), mode());\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/WasmBBQPlan.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    virtual void setOSREntryCallee(Ref<OMGForOSREntryCallee>&&)\n+    virtual void setOSREntryCallee(Ref<OMGForOSREntryCallee>&&, MemoryMode)\n@@ -163,1 +163,1 @@\n-    void setOSREntryCallee(Ref<OMGForOSREntryCallee>&& osrEntryCallee) final\n+    void setOSREntryCallee(Ref<OMGForOSREntryCallee>&& osrEntryCallee, MemoryMode) final\n@@ -208,2 +208,2 @@\n-    JITCallee* replacement() { return m_replacement.get(); }\n-    void setReplacement(Ref<JITCallee>&& replacement)\n+    JITCallee* replacement(MemoryMode mode) { return m_replacements[static_cast<uint8_t>(mode)].get(); }\n+    void setReplacement(Ref<JITCallee>&& replacement, MemoryMode mode)\n@@ -211,1 +211,1 @@\n-        m_replacement = WTFMove(replacement);\n+        m_replacements[static_cast<uint8_t>(mode)] = WTFMove(replacement);\n@@ -214,2 +214,2 @@\n-    OMGForOSREntryCallee* osrEntryCallee() { return m_osrEntryCallee.get(); }\n-    void setOSREntryCallee(Ref<OMGForOSREntryCallee>&& osrEntryCallee) final\n+    OMGForOSREntryCallee* osrEntryCallee(MemoryMode mode) { return m_osrEntryCallees[static_cast<uint8_t>(mode)].get(); }\n+    void setOSREntryCallee(Ref<OMGForOSREntryCallee>&& osrEntryCallee, MemoryMode mode) final\n@@ -217,1 +217,1 @@\n-        m_osrEntryCallee = WTFMove(osrEntryCallee);\n+        m_osrEntryCallees[static_cast<uint8_t>(mode)] = WTFMove(osrEntryCallee);\n@@ -232,2 +232,2 @@\n-    RefPtr<JITCallee> m_replacement;\n-    RefPtr<OMGForOSREntryCallee> m_osrEntryCallee;\n+    RefPtr<JITCallee> m_replacements[Wasm::NumberOfMemoryModes];\n+    RefPtr<OMGForOSREntryCallee> m_osrEntryCallees[Wasm::NumberOfMemoryModes];\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/WasmCallee.h","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                llintCallee->setOSREntryCallee(callee.copyRef());\n+                llintCallee->setOSREntryCallee(callee.copyRef(), mode());\n@@ -131,1 +131,1 @@\n-                bbqCallee->setOSREntryCallee(callee.copyRef());\n+                bbqCallee->setOSREntryCallee(callee.copyRef(), mode());\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/WasmOMGForOSREntryPlan.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-                llintCallee.setReplacement(callee.copyRef());\n+                llintCallee.setReplacement(callee.copyRef(), mode());\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/WasmOMGPlan.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-            if (JITCallee* replacementCallee = llintCallee.replacement())\n+            if (JITCallee* replacementCallee = llintCallee.replacement(codeBlock.mode()))\n@@ -144,1 +144,1 @@\n-            if (OMGForOSREntryCallee* osrEntryCallee = llintCallee.osrEntryCallee())\n+            if (OMGForOSREntryCallee* osrEntryCallee = llintCallee.osrEntryCallee(codeBlock.mode()))\n@@ -177,1 +177,1 @@\n-            if (JITCallee* replacementCallee = llintCallee.replacement())\n+            if (JITCallee* replacementCallee = llintCallee.replacement(codeBlock.mode()))\n@@ -179,1 +179,1 @@\n-            if (OMGForOSREntryCallee* osrEntryCallee = llintCallee.osrEntryCallee())\n+            if (OMGForOSREntryCallee* osrEntryCallee = llintCallee.osrEntryCallee(codeBlock.mode()))\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/WasmPlan.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    if (callee->replacement())  {\n+    if (callee->replacement(instance->memory()->mode()))  {\n@@ -144,1 +144,1 @@\n-    return !!callee->replacement();\n+    return !!callee->replacement(instance->memory()->mode());\n@@ -167,1 +167,1 @@\n-    WASM_RETURN_TWO(callee->replacement()->entrypoint().executableAddress(), nullptr);\n+    WASM_RETURN_TWO(callee->replacement(instance->memory()->mode())->entrypoint().executableAddress(), nullptr);\n@@ -191,2 +191,1 @@\n-    const auto doOSREntry = [&] {\n-        Wasm::OMGForOSREntryCallee* osrEntryCallee = callee->osrEntryCallee();\n+    const auto doOSREntry = [&](Wasm::OMGForOSREntryCallee* osrEntryCallee) {\n@@ -209,2 +208,2 @@\n-    if (callee->osrEntryCallee())\n-        return doOSREntry();\n+    if (auto* osrEntryCallee = callee->osrEntryCallee(instance->memory()->mode()))\n+        return doOSREntry(osrEntryCallee);\n@@ -237,2 +236,2 @@\n-    if (callee->osrEntryCallee())\n-        return doOSREntry();\n+    if (auto* osrEntryCallee = callee->osrEntryCallee(instance->memory()->mode()))\n+        return doOSREntry(osrEntryCallee);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/WasmSlowPaths.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"JSBigInt.h\"\n@@ -47,1 +48,0 @@\n-    , m_promise(promise)\n@@ -55,4 +55,4 @@\n-    vm.deferredWorkTimer->addPendingWork(vm, promise, WTFMove(dependencies));\n-    ASSERT(vm.deferredWorkTimer->hasPendingWork(promise));\n-    ASSERT(vm.deferredWorkTimer->hasDependancyInPendingWork(promise, globalObject));\n-    ASSERT(!importObject || vm.deferredWorkTimer->hasDependancyInPendingWork(promise, importObject));\n+    m_ticket = vm.deferredWorkTimer->addPendingWork(vm, promise, WTFMove(dependencies));\n+    ASSERT(vm.deferredWorkTimer->hasPendingWork(m_ticket));\n+    ASSERT(vm.deferredWorkTimer->hasDependancyInPendingWork(m_ticket, globalObject));\n+    ASSERT(!importObject || vm.deferredWorkTimer->hasDependancyInPendingWork(m_ticket, importObject));\n@@ -63,3 +63,3 @@\n-    if (m_promise) {\n-        auto* promise = std::exchange(m_promise, nullptr);\n-        m_vm.deferredWorkTimer->scheduleWorkSoon(promise, [](DeferredWorkTimer::Ticket, DeferredWorkTimer::TicketData&&) mutable { });\n+    if (m_ticket) {\n+        auto ticket = std::exchange(m_ticket, nullptr);\n+        m_vm.deferredWorkTimer->scheduleWorkSoon(ticket, [](DeferredWorkTimer::Ticket) mutable { });\n@@ -140,1 +140,1 @@\n-    auto* promise = std::exchange(m_promise, nullptr);\n+    auto ticket = std::exchange(m_ticket, nullptr);\n@@ -143,3 +143,3 @@\n-        m_vm.deferredWorkTimer->scheduleWorkSoon(promise, [result = WTFMove(result)](DeferredWorkTimer::Ticket ticket, DeferredWorkTimer::TicketData&& ticketData) mutable {\n-            JSPromise* promise = jsCast<JSPromise*>(ticket);\n-            JSGlobalObject* globalObject = jsCast<JSGlobalObject*>(ticketData.dependencies[0].get());\n+        m_vm.deferredWorkTimer->scheduleWorkSoon(ticket, [result = WTFMove(result)](DeferredWorkTimer::Ticket ticket) mutable {\n+            JSPromise* promise = jsCast<JSPromise*>(ticket->target());\n+            JSGlobalObject* globalObject = jsCast<JSGlobalObject*>(ticket->dependencies[0].get());\n@@ -162,4 +162,4 @@\n-        m_vm.deferredWorkTimer->scheduleWorkSoon(promise, [result = WTFMove(result)](DeferredWorkTimer::Ticket ticket, DeferredWorkTimer::TicketData&& ticketData) mutable {\n-            JSPromise* promise = jsCast<JSPromise*>(ticket);\n-            JSGlobalObject* globalObject = jsCast<JSGlobalObject*>(ticketData.dependencies[0].get());\n-            JSObject* importObject = jsCast<JSObject*>(ticketData.dependencies[1].get());\n+        m_vm.deferredWorkTimer->scheduleWorkSoon(ticket, [result = WTFMove(result)](DeferredWorkTimer::Ticket ticket) mutable {\n+            JSPromise* promise = jsCast<JSPromise*>(ticket->target());\n+            JSGlobalObject* globalObject = jsCast<JSGlobalObject*>(ticket->dependencies[0].get());\n+            JSObject* importObject = jsCast<JSObject*>(ticket->dependencies[1].get());\n@@ -209,2 +209,8 @@\n-    auto* promise = std::exchange(m_promise, nullptr);\n-    m_vm.deferredWorkTimer->cancelPendingWork(promise);\n+    auto ticket = std::exchange(m_ticket, nullptr);\n+    JSPromise* promise = jsCast<JSPromise*>(ticket->target());\n+    \/\/ The pending work TicketData was keeping the promise alive. We need to\n+    \/\/ make sure it is reachable from the stack before we remove it from the\n+    \/\/ pending work list. Note: m_ticket stores it as a PackedPtr, which is not\n+    \/\/ scannable by the GC.\n+    WTF::compilerFence();\n+    m_vm.deferredWorkTimer->cancelPendingWork(ticket);\n@@ -223,2 +229,2 @@\n-    auto* promise = std::exchange(m_promise, nullptr);\n-    m_vm.deferredWorkTimer->cancelPendingWork(promise);\n+    auto ticket = std::exchange(m_ticket, nullptr);\n+    m_vm.deferredWorkTimer->cancelPendingWork(ticket);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/WasmStreamingCompiler.cpp","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"DeferredWorkTimer.h\"\n@@ -75,1 +76,1 @@\n-    JSPromise* m_promise; \/\/ Raw pointer, but held by DeferredWorkTimer.\n+    DeferredWorkTimer::Ticket m_ticket;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/WasmStreamingCompiler.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-        if (!checkedGrow(funcRefTable->m_importableFunctions, [] (auto&) { }))\n+        if (!checkedGrow(funcRefTable->m_importableFunctions, [](auto&) { }))\n@@ -120,1 +120,1 @@\n-        if (!checkedGrow(funcRefTable->m_instances, [] (auto&) { }))\n+        if (!checkedGrow(funcRefTable->m_instances, [](auto&) { }))\n@@ -124,1 +124,2 @@\n-    if (!checkedGrow(m_jsValues, [defaultValue] (WriteBarrier<Unknown>& slot) { slot.setStartingValue(defaultValue); }))\n+    VM& vm = m_owner->vm();\n+    if (!checkedGrow(m_jsValues, [&](WriteBarrier<Unknown>& slot) { slot.set(vm, m_owner, defaultValue); }))\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/WasmTable.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -171,3 +171,3 @@\n-    vm.deferredWorkTimer->addPendingWork(vm, promise, WTFMove(dependencies));\n-    Wasm::Module::validateAsync(&vm.wasmContext, WTFMove(source), createSharedTask<Wasm::Module::CallbackType>([promise, globalObject, &vm] (Wasm::Module::ValidationResult&& result) mutable {\n-        vm.deferredWorkTimer->scheduleWorkSoon(promise, [promise, globalObject, result = WTFMove(result), &vm](DeferredWorkTimer::Ticket, DeferredWorkTimer::TicketData&&) mutable {\n+    auto ticket = vm.deferredWorkTimer->addPendingWork(vm, promise, WTFMove(dependencies));\n+    Wasm::Module::validateAsync(&vm.wasmContext, WTFMove(source), createSharedTask<Wasm::Module::CallbackType>([ticket, promise, globalObject, &vm] (Wasm::Module::ValidationResult&& result) mutable {\n+        vm.deferredWorkTimer->scheduleWorkSoon(ticket, [promise, globalObject, result = WTFMove(result), &vm](DeferredWorkTimer::Ticket) mutable {\n@@ -202,1 +202,1 @@\n-    vm.deferredWorkTimer->addPendingWork(vm, instance, WTFMove(dependencies));\n+    auto ticket = vm.deferredWorkTimer->addPendingWork(vm, instance, WTFMove(dependencies));\n@@ -204,1 +204,1 @@\n-    module->module().compileAsync(&vm.wasmContext, instance->memoryMode(), createSharedTask<Wasm::CodeBlock::CallbackType>([promise, instance, module, importObject, resolveKind, creationMode, &vm] (Ref<Wasm::CodeBlock>&& refCodeBlock) mutable {\n+    module->module().compileAsync(&vm.wasmContext, instance->memoryMode(), createSharedTask<Wasm::CodeBlock::CallbackType>([ticket, promise, instance, module, importObject, resolveKind, creationMode, &vm] (Ref<Wasm::CodeBlock>&& refCodeBlock) mutable {\n@@ -206,1 +206,1 @@\n-        vm.deferredWorkTimer->scheduleWorkSoon(instance, [promise, instance, module, importObject, resolveKind, creationMode, &vm, codeBlock = WTFMove(codeBlock)](DeferredWorkTimer::Ticket, DeferredWorkTimer::TicketData&&) mutable {\n+        vm.deferredWorkTimer->scheduleWorkSoon(ticket, [promise, instance, module, importObject, resolveKind, creationMode, &vm, codeBlock = WTFMove(codeBlock)](DeferredWorkTimer::Ticket) mutable {\n@@ -227,3 +227,3 @@\n-    vm.deferredWorkTimer->addPendingWork(vm, promise, WTFMove(dependencies));\n-    Wasm::Module::validateAsync(&vm.wasmContext, WTFMove(source), createSharedTask<Wasm::Module::CallbackType>([promise, importObject, moduleKeyCell, globalObject, resolveKind, creationMode, &vm] (Wasm::Module::ValidationResult&& result) mutable {\n-        vm.deferredWorkTimer->scheduleWorkSoon(promise, [promise, importObject, moduleKeyCell, globalObject, result = WTFMove(result), resolveKind, creationMode, &vm](DeferredWorkTimer::Ticket, DeferredWorkTimer::TicketData&&) mutable {\n+    auto ticket = vm.deferredWorkTimer->addPendingWork(vm, promise, WTFMove(dependencies));\n+    Wasm::Module::validateAsync(&vm.wasmContext, WTFMove(source), createSharedTask<Wasm::Module::CallbackType>([ticket, promise, importObject, moduleKeyCell, globalObject, resolveKind, creationMode, &vm] (Wasm::Module::ValidationResult&& result) mutable {\n+        vm.deferredWorkTimer->scheduleWorkSoon(ticket, [promise, importObject, moduleKeyCell, globalObject, result = WTFMove(result), resolveKind, creationMode, &vm](DeferredWorkTimer::Ticket) mutable {\n@@ -271,3 +271,3 @@\n-    vm.deferredWorkTimer->addPendingWork(vm, promise, WTFMove(dependencies));\n-    Wasm::Module::validateAsync(&vm.wasmContext, WTFMove(source), createSharedTask<Wasm::Module::CallbackType>([promise, importObject, globalObject, &vm] (Wasm::Module::ValidationResult&& result) mutable {\n-        vm.deferredWorkTimer->scheduleWorkSoon(promise, [promise, importObject, globalObject, result = WTFMove(result), &vm](DeferredWorkTimer::Ticket, DeferredWorkTimer::TicketData&&) mutable {\n+    auto ticket = vm.deferredWorkTimer->addPendingWork(vm, promise, WTFMove(dependencies));\n+    Wasm::Module::validateAsync(&vm.wasmContext, WTFMove(source), createSharedTask<Wasm::Module::CallbackType>([ticket, promise, importObject, globalObject, &vm] (Wasm::Module::ValidationResult&& result) mutable {\n+        vm.deferredWorkTimer->scheduleWorkSoon(ticket, [promise, importObject, globalObject, result = WTFMove(result), &vm](DeferredWorkTimer::Ticket) mutable {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/wasm\/js\/JSWebAssembly.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-#define CRASH_UNDER_CONSTEXPR_CONTEXT() std::abort()\n+#define CRASH_UNDER_CONSTEXPR_CONTEXT() WTFBreakpointTrapUnderConstexprContext()\n@@ -277,1 +277,1 @@\n-#define CRASH_UNDER_CONSTEXPR_CONTEXT() abort()\n+#define CRASH_UNDER_CONSTEXPR_CONTEXT() WTFBreakpointTrapUnderConstexprContext()\n@@ -281,1 +281,1 @@\n-#define CRASH_UNDER_CONSTEXPR_CONTEXT() WTFCrash()\n+#define CRASH_UNDER_CONSTEXPR_CONTEXT() WTFBreakpointTrapUnderConstexprContext()\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/Assertions.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include <utility>\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/CompletionHandler.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include <utility>\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/MallocPtr.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include <string>\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/text\/IntegerToStringConversion.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -181,1 +181,5 @@\n-        auto voidOrException = createReadableStream(*context.globalObject());\n+        auto* globalObject = context.globalObject();\n+        if (!globalObject)\n+            return Exception { InvalidStateError, \"Context is stopped\"_s };\n+\n+        auto voidOrException = createReadableStream(*globalObject);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/fetch\/FetchResponse.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -533,0 +533,3 @@\n+        if (database->identifier().origin() != origin)\n+            continue;\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/indexeddb\/server\/IDBServer.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include <wtf\/IsoMallocInlines.h>\n@@ -36,0 +37,2 @@\n+WTF_MAKE_ISO_ALLOCATED_IMPL(XRReferenceSpaceEvent);\n+\n@@ -47,1 +50,0 @@\n-    ASSERT(m_transform);\n@@ -57,1 +59,1 @@\n-const WebXRRigidTransform& XRReferenceSpaceEvent::transform() const\n+WebXRRigidTransform* XRReferenceSpaceEvent::transform() const\n@@ -59,1 +61,1 @@\n-    return *m_transform;\n+    return m_transform.get();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/webxr\/XRReferenceSpaceEvent.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include <wtf\/IsoMalloc.h>\n@@ -40,0 +41,1 @@\n+    WTF_MAKE_ISO_ALLOCATED(XRReferenceSpaceEvent);\n@@ -50,1 +52,1 @@\n-    const WebXRRigidTransform& transform() const;\n+    WebXRRigidTransform* transform() const;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/webxr\/XRReferenceSpaceEvent.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-    WebXRRigidTransform transform;\n+    WebXRRigidTransform? transform;\n@@ -43,1 +43,1 @@\n-    [SameObject] readonly attribute WebXRRigidTransform transform;\n+    [SameObject] readonly attribute WebXRRigidTransform? transform;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/webxr\/XRReferenceSpaceEvent.idl","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -521,0 +521,1 @@\n+bindings\/js\/JSRangeCustom.cpp\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Sources.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -531,0 +531,1 @@\n+#if ENABLE(VIDEO)\n@@ -534,0 +535,1 @@\n+#endif \/\/ ENABLE(VIDEO)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/accessibility\/AXObjectCache.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -492,1 +492,1 @@\n-    if (isWebArea())\n+    if (m_renderer && isWebArea())\n@@ -1361,0 +1361,5 @@\n+\n+        \/\/ Walking up the parent chain might reset the m_renderer.\n+        if (!m_renderer)\n+            return true;\n+\n@@ -1645,1 +1650,1 @@\n-    return m_renderer->frame().selection().selection();\n+    return m_renderer ? m_renderer->frame().selection().selection() : VisibleSelection();\n@@ -1715,1 +1720,2 @@\n-    if (auto client = m_renderer->document().editor().client())\n+    auto* client = m_renderer ? m_renderer->document().editor().client() : nullptr;\n+    if (client)\n@@ -1721,1 +1727,1 @@\n-    } else {\n+    } else if (m_renderer) {\n@@ -1736,1 +1742,1 @@\n-    if (auto client = m_renderer->document().editor().client())\n+    if (client)\n@@ -2013,0 +2019,3 @@\n+    if (!m_renderer)\n+        return { };\n+\n@@ -2291,1 +2300,2 @@\n-    if (auto client = m_renderer->document().editor().client())\n+    auto* client = m_renderer ? m_renderer->document().editor().client() : nullptr;\n+    if (client)\n@@ -2320,1 +2330,1 @@\n-    } else {\n+    } else if (m_renderer) {\n@@ -2342,1 +2352,1 @@\n-    if (auto client = m_renderer->document().editor().client())\n+    if (client)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/accessibility\/AccessibilityRenderObject.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1745,2 +1745,17 @@\n-        auto* lastStyleChangeEventStyle = m_target->lastStyleChangeEventStyle(m_pseudoId);\n-        ASSERT(lastStyleChangeEventStyle);\n+        \/\/ We need to resolve all animations up to this point to ensure any forward-filling\n+        \/\/ effect is accounted for when computing the \"from\" value for the accelerated animation.\n+        auto* effectStack = m_target->keyframeEffectStack(m_pseudoId);\n+        ASSERT(effectStack);\n+\n+        auto underlyingStyle = [&]() {\n+            if (auto* lastStyleChangeEventStyle = m_target->lastStyleChangeEventStyle(m_pseudoId))\n+                return RenderStyle::clonePtr(*lastStyleChangeEventStyle);\n+            return RenderStyle::clonePtr(renderer->style());\n+        }();\n+\n+        for (const auto& effect : effectStack->sortedEffects()) {\n+            if (this == effect.get())\n+                break;\n+            if (auto progress = effect->getComputedTiming().progress)\n+                effect->setAnimatedPropertiesInStyle(*underlyingStyle, *progress);\n+        }\n@@ -1750,1 +1765,1 @@\n-        explicitKeyframes.fillImplicitKeyframes(*m_target, m_target->styleResolver(), lastStyleChangeEventStyle, nullptr);\n+        explicitKeyframes.fillImplicitKeyframes(*m_target, m_target->styleResolver(), underlyingStyle.get(), nullptr);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/animation\/KeyframeEffect.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -48,5 +48,1 @@\n-        JSDOMGlobalObject* incumbentGlobalObject = &globalObject;\n-        if (auto* globalObject = JSC::CallFrame::globalObjectOfClosestCodeBlock(vm, vm.topCallFrame))\n-            incumbentGlobalObject = JSC::jsCast<JSDOMGlobalObject*>(globalObject);\n-\n-        return T::create(JSC::asObject(value), incumbentGlobalObject);\n+        return T::create(JSC::asObject(value), &callerGlobalObject(globalObject, vm.topCallFrame));\n@@ -86,5 +82,1 @@\n-        JSDOMGlobalObject* incumbentGlobalObject = &globalObject;\n-        if (auto* globalObject = JSC::CallFrame::globalObjectOfClosestCodeBlock(vm, vm.topCallFrame))\n-            incumbentGlobalObject = JSC::jsCast<JSDOMGlobalObject*>(globalObject);\n-\n-        return T::create(JSC::asObject(value), incumbentGlobalObject);\n+        return T::create(JSC::asObject(value), &callerGlobalObject(globalObject, vm.topCallFrame));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/js\/JSDOMConvertCallbacks.h","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include <JavaScriptCore\/VMEntryScope.h>\n@@ -563,0 +564,74 @@\n+static JSDOMGlobalObject& callerGlobalObject(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame* callFrame, bool skipFirstFrame, bool lookUpFromVMEntryScope)\n+{\n+    VM& vm = lexicalGlobalObject.vm();\n+    if (callFrame) {\n+        class GetCallerGlobalObjectFunctor {\n+        public:\n+            GetCallerGlobalObjectFunctor(bool skipFirstFrame)\n+                : m_skipFirstFrame(skipFirstFrame)\n+            { }\n+\n+            StackVisitor::Status operator()(StackVisitor& visitor) const\n+            {\n+                if (m_skipFirstFrame) {\n+                    if (!m_hasSkippedFirstFrame) {\n+                        m_hasSkippedFirstFrame = true;\n+                        return StackVisitor::Continue;\n+                    }\n+                }\n+\n+                if (auto* codeBlock = visitor->codeBlock())\n+                    m_globalObject = codeBlock->globalObject();\n+                else {\n+                    ASSERT(visitor->callee().rawPtr());\n+                    \/\/ FIXME: Callee is not an object if the caller is Web Assembly.\n+                    \/\/ Figure out what to do here. We can probably get the global object\n+                    \/\/ from the top-most Wasm Instance. https:\/\/bugs.webkit.org\/show_bug.cgi?id=165721\n+                    if (visitor->callee().isCell() && visitor->callee().asCell()->isObject())\n+                        m_globalObject = jsCast<JSObject*>(visitor->callee().asCell())->globalObject();\n+                }\n+                return StackVisitor::Done;\n+            }\n+\n+            JSC::JSGlobalObject* globalObject() const { return m_globalObject; }\n+\n+        private:\n+            bool m_skipFirstFrame { false };\n+            mutable bool m_hasSkippedFirstFrame { false };\n+            mutable JSC::JSGlobalObject* m_globalObject { nullptr };\n+        };\n+\n+        GetCallerGlobalObjectFunctor iter(skipFirstFrame);\n+        callFrame->iterate(vm, iter);\n+        if (iter.globalObject())\n+            return *jsCast<JSDOMGlobalObject*>(iter.globalObject());\n+    }\n+\n+    \/\/ In the case of legacyActiveGlobalObjectForAccessor, it is possible that vm.topCallFrame is nullptr when the script is evaluated as JSONP.\n+    \/\/ Since we put JSGlobalObject to VMEntryScope, we can retrieve the right globalObject from that.\n+    \/\/ For callerGlobalObject, we do not check vm.entryScope to keep it the old behavior.\n+    if (lookUpFromVMEntryScope) {\n+        if (vm.entryScope) {\n+            if (auto* result = vm.entryScope->globalObject())\n+                return *jsCast<JSDOMGlobalObject*>(result);\n+        }\n+    }\n+\n+    \/\/ If we cannot find JSGlobalObject in caller frames, we just return the current lexicalGlobalObject.\n+    return *jsCast<JSDOMGlobalObject*>(&lexicalGlobalObject);\n+}\n+\n+JSDOMGlobalObject& callerGlobalObject(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame* callFrame)\n+{\n+    constexpr bool skipFirstFrame = true;\n+    constexpr bool lookUpFromVMEntryScope = false;\n+    return callerGlobalObject(lexicalGlobalObject, callFrame, skipFirstFrame, lookUpFromVMEntryScope);\n+}\n+\n+JSDOMGlobalObject& legacyActiveGlobalObjectForAccessor(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame* callFrame)\n+{\n+    constexpr bool skipFirstFrame = false;\n+    constexpr bool lookUpFromVMEntryScope = true;\n+    return callerGlobalObject(lexicalGlobalObject, callFrame, skipFirstFrame, lookUpFromVMEntryScope);\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/js\/JSDOMGlobalObject.cpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -146,0 +146,2 @@\n+WEBCORE_EXPORT JSDOMGlobalObject& callerGlobalObject(JSC::JSGlobalObject&, JSC::CallFrame*);\n+JSDOMGlobalObject& legacyActiveGlobalObjectForAccessor(JSC::JSGlobalObject&, JSC::CallFrame*);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/js\/JSDOMGlobalObject.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,3 +287,1 @@\n-    if (auto* globalObject = CallFrame::globalObjectOfClosestCodeBlock(fallbackGlobalObject.vm(), &callFrame))\n-        return asJSDOMWindow(globalObject)->wrapped();\n-    return asJSDOMWindow(&fallbackGlobalObject)->wrapped();\n+    return asJSDOMWindow(&callerGlobalObject(fallbackGlobalObject, &callFrame))->wrapped();\n@@ -294,4 +292,1 @@\n-    VM& vm = fallbackGlobalObject.vm();\n-    if (auto* globalObject = CallFrame::globalObjectOfClosestCodeBlock(vm, vm.topCallFrame))\n-        return asJSDOMWindow(globalObject)->wrapped();\n-    return asJSDOMWindow(&fallbackGlobalObject)->wrapped();\n+    return asJSDOMWindow(&callerGlobalObject(fallbackGlobalObject, fallbackGlobalObject.vm().topCallFrame))->wrapped();\n@@ -311,0 +306,10 @@\n+DOMWindow& legacyActiveDOMWindowForAccessor(JSGlobalObject& fallbackGlobalObject, CallFrame& callFrame)\n+{\n+    return asJSDOMWindow(&legacyActiveGlobalObjectForAccessor(fallbackGlobalObject, &callFrame))->wrapped();\n+}\n+\n+DOMWindow& legacyActiveDOMWindowForAccessor(JSGlobalObject& fallbackGlobalObject)\n+{\n+    return asJSDOMWindow(&legacyActiveGlobalObjectForAccessor(fallbackGlobalObject, fallbackGlobalObject.vm().topCallFrame))->wrapped();\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/js\/JSDOMWindowBase.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -129,0 +129,3 @@\n+DOMWindow& legacyActiveDOMWindowForAccessor(JSC::JSGlobalObject&, JSC::CallFrame&);\n+DOMWindow& legacyActiveDOMWindowForAccessor(JSC::JSGlobalObject&);\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/js\/JSDOMWindowBase.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (C) 2021 Igalia S.L. All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and\/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n+ * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS\n+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+#include \"config.h\"\n+#include \"JSRange.h\"\n+\n+#include \"Range.h\"\n+\n+namespace WebCore {\n+\n+template<typename Visitor>\n+void JSRange::visitAdditionalChildren(Visitor& visitor)\n+{\n+    wrapped().visitNodesConcurrently(visitor);\n+}\n+\n+DEFINE_VISIT_ADDITIONAL_CHILDREN(JSRange);\n+\n+} \/\/ namespace WebCore\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/js\/JSRangeCustom.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -5987,0 +5987,5 @@\n+    if ($codeGenerator->ExtendedAttributeContains($callWith, \"LegacyActiveWindowForAccessor\")) {\n+        AddToImplIncludes(\"DOMWindow.h\");\n+        AddToImplIncludes(\"JSDOMWindowBase.h\");\n+        push(@callWithArgs, \"legacyActiveDOMWindowForAccessor(*$globalObject\" . ($callFrameReference ? \", \" . $callFrameReference : \"\") . \")\");\n+    }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/bindings\/scripts\/CodeGeneratorJS.pm","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    if (m_parentStyleSheet->isContentOpaque() || !cachedStyleSheet->isCORSSameOrigin())\n+    if ((m_parentStyleSheet && m_parentStyleSheet->isContentOpaque()) || !cachedStyleSheet->isCORSSameOrigin())\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/css\/StyleRuleImport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"Logging.h\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/css\/calc\/CSSCalcOperationNode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"Logging.h\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/css\/calc\/CSSCalcPrimitiveValueNode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-    if (m_styleScope)\n+    if (m_styleScope && !m_styleScope->hasPendingSheet(element))\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/dom\/InlineStyleSheetOwner.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"JSNode.h\"\n@@ -1102,0 +1103,6 @@\n+void Range::visitNodesConcurrently(JSC::AbstractSlotVisitor& visitor) const\n+{\n+    visitor.addOpaqueRoot(root(&m_start.container()));\n+    visitor.addOpaqueRoot(root(&m_end.container()));\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/dom\/Range.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+    void visitNodesConcurrently(JSC::AbstractSlotVisitor&) const;\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/dom\/Range.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+    JSCustomMarkFunction,\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/dom\/Range.idl","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -388,1 +388,3 @@\n-            if (!nodeFullySelected(downcast<HTMLElement>(*node), start, end))\n+            if (!nodeFullySelected(downcast<HTMLElement>(*node), start, end)) {\n+                if (!node->isConnected())\n+                    break;\n@@ -390,0 +392,1 @@\n+            }\n@@ -591,1 +594,1 @@\n-    if (start.isNull() || end.isNull())\n+    if (start.isNull() || start.isOrphan() || end.isNull() || end.isOrphan())\n@@ -639,0 +642,2 @@\n+    if (start.isNull() || end.isNull())\n+        return;\n@@ -1319,2 +1324,1 @@\n-    insertNodeBefore(element.copyRef(), startNode);\n-    if (!element->isContentRichlyEditable()) {\n+    if (!insertNodeBefore(element.copyRef(), startNode) || !element->isContentRichlyEditable()) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/ApplyStyleCommand.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -554,1 +554,1 @@\n-void CompositeEditCommand::insertNodeBefore(Ref<Node>&& insertChild, Node& refChild, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)\n+bool CompositeEditCommand::insertNodeBefore(Ref<Node>&& insertChild, Node& refChild, ShouldAssumeContentIsAlwaysEditable shouldAssumeContentIsAlwaysEditable)\n@@ -558,1 +558,1 @@\n-        return;\n+        return false;\n@@ -560,0 +560,1 @@\n+    return true;\n@@ -1751,2 +1752,3 @@\n-    for (node = &start; node && node->parentNode() != adjustedEnd; node = node->parentNode()) {\n-        if (!node->parentNode() || !is<Element>(*node->parentNode()))\n+    for (node = &start; node && node->parentNode() != adjustedEnd;) {\n+        RefPtr parentNode = node->parentNode();\n+        if (!parentNode || !is<Element>(*parentNode) || editingIgnoresContent(*parentNode))\n@@ -1755,1 +1757,1 @@\n-        VisiblePosition positionInParent = firstPositionInNode(node->parentNode());\n+        VisiblePosition positionInParent = firstPositionInNode(parentNode.get());\n@@ -1758,1 +1760,2 @@\n-            splitElement(downcast<Element>(*node->parentNode()), *node);\n+            splitElement(downcast<Element>(*parentNode), *node);\n+        node = parentNode;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/CompositeEditCommand.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    void insertNodeBefore(Ref<Node>&&, Node& refChild, ShouldAssumeContentIsAlwaysEditable = DoNotAssumeContentIsAlwaysEditable);\n+    bool insertNodeBefore(Ref<Node>&&, Node& refChild, ShouldAssumeContentIsAlwaysEditable = DoNotAssumeContentIsAlwaysEditable);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/CompositeEditCommand.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    if (endingSelection().isNone())\n+    if (endingSelection().isNoneOrOrphaned())\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/CreateLinkCommand.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -494,1 +494,3 @@\n-    if (&node == m_startBlock && !isEndOfBlock(VisiblePosition(firstPositionInNode(m_startBlock.get())).previous()))\n+    if (&node == m_startBlock) {\n+        auto prev = VisiblePosition(firstPositionInNode(m_startBlock.get())).previous();\n+        if (!prev.isNull() && !isEndOfBlock(prev))\n@@ -496,1 +498,3 @@\n-    else if (&node == m_endBlock && !isStartOfBlock(VisiblePosition(lastPositionInNode(m_startBlock.get())).next()))\n+    } else if (&node == m_endBlock) {\n+        auto next = VisiblePosition(lastPositionInNode(m_endBlock.get())).next();\n+        if (!next.isNull() && !isStartOfBlock(next))\n@@ -498,1 +502,1 @@\n-\n+    }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/DeleteSelectionCommand.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -480,2 +480,4 @@\n-        if (renderStyle->fontDescription().keywordSize())\n-            m_mutableStyle->setProperty(CSSPropertyFontSize, computedStyleAtPosition.getFontSizeCSSValuePreferringKeyword()->cssText());\n+        if (renderStyle->fontDescription().keywordSize()) {\n+            if (auto cssValue = computedStyleAtPosition.getFontSizeCSSValuePreferringKeyword())\n+                m_mutableStyle->setProperty(CSSPropertyFontSize, cssValue->cssText());\n+        }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/EditingStyle.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"StyleTreeResolver.h\"\n@@ -1346,0 +1347,5 @@\n+    auto selectionDocument = m_selection.document();\n+    if (!selectionDocument)\n+        return false;\n+    selectionDocument->updateLayoutIgnorePendingStylesheets();\n+    Style::PostResolutionCallbackDisabler disabler(*selectionDocument);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/FrameSelection.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -119,2 +119,2 @@\n-        else\n-            insertNodeBefore(*targetBlockquote, *outerBlock);\n+        else if (!insertNodeBefore(*targetBlockquote, *outerBlock))\n+            return;\n@@ -195,2 +195,7 @@\n-    if (placeholder->isConnected())\n-        moveParagraph(startOfParagraph(visibleStartOfParagraph), endOfParagraph(visibleEndOfParagraph), positionBeforeNode(placeholder.ptr()), true);\n+    if (!placeholder->isConnected())\n+        return;\n+    auto visibleStartOfParagraphToMove = startOfParagraph(visibleStartOfParagraph);\n+    auto visibleEndOfParagraphToMove = endOfParagraph(visibleEndOfParagraph);\n+    if (visibleStartOfParagraphToMove.isNull() || visibleEndOfParagraphToMove.isNull())\n+        return;\n+    moveParagraph(visibleStartOfParagraphToMove, visibleEndOfParagraphToMove, positionBeforeNode(placeholder.ptr()), true);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/IndentOutdentCommand.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    return node->renderer() && !node->renderer()->style().preserveNewline();\n+    return node && node->renderer() && !node->renderer()->style().preserveNewline();\n@@ -84,0 +84,2 @@\n+    if (!isEditablePosition(position))\n+        return;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/InsertLineBreakCommand.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-                if (!startOfLastParagraph.deepEquivalent().anchorNode()->isConnected())\n+                    if (startOfLastParagraph.isOrphan())\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/InsertListCommand.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,3 +94,3 @@\n-    Node* node = startNode;\n-    while (1) {\n-        Node* next = node->nextSibling();\n+    RefPtr node = startNode;\n+    while (node) {\n+        RefPtr next = node->nextSibling();\n@@ -101,1 +101,1 @@\n-            break;\n+            return;\n@@ -105,0 +105,1 @@\n+    ASSERT_NOT_REACHED();\n@@ -109,3 +110,4 @@\n-    Node* node = startNode;\n-    while (1) {\n-        Node* next = node->nextSibling();\n+    RefPtr node = startNode;\n+    RefPtr refChild = refNode;\n+    while (node) {\n+        RefPtr next = node->nextSibling();\n@@ -113,1 +115,1 @@\n-        insertNodeAfter(*node, *refNode);\n+        insertNodeAfter(*node, *refChild);\n@@ -116,1 +118,1 @@\n-            break;\n+            return;\n@@ -118,1 +120,1 @@\n-        refNode = node;\n+        refChild = node;\n@@ -121,0 +123,1 @@\n+    ASSERT_NOT_REACHED();\n@@ -125,3 +128,3 @@\n-    Node* node = startNode;\n-    while (1) {\n-        Node* next = node->nextSibling();\n+    RefPtr node = startNode;\n+    while (node) {\n+        RefPtr next = node->nextSibling();\n@@ -132,1 +135,1 @@\n-            break;\n+            return;\n@@ -136,0 +139,1 @@\n+    ASSERT_NOT_REACHED();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/ModifySelectionListLevel.cpp","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -833,0 +833,2 @@\n+        if (!ancestor.isConnected())\n+            return;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/ReplaceSelectionCommand.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1184,1 +1184,1 @@\n-        if (r->isBR() || isBlock(n))\n+        if (r->isBR() || is<HTMLBRElement>(n) || isBlock(n))\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/VisibleUnits.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-    Node* traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode);\n+    Node* traverseNodesForSerialization(Node& startNode, Node* pastEnd, NodeTraversalMode);\n@@ -628,0 +628,2 @@\n+    if (!startNode)\n+        return nullptr;\n@@ -633,1 +635,1 @@\n-        Node* lastClosed = traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::DoNotEmitString);\n+        Node* lastClosed = traverseNodesForSerialization(*startNode, pastEnd, NodeTraversalMode::DoNotEmitString);\n@@ -640,1 +642,1 @@\n-    return traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::EmitString);\n+    return traverseNodesForSerialization(*startNode, pastEnd, NodeTraversalMode::EmitString);\n@@ -643,1 +645,1 @@\n-Node* StyledMarkupAccumulator::traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode traversalMode)\n+Node* StyledMarkupAccumulator::traverseNodesForSerialization(Node& startNode, Node* pastEnd, NodeTraversalMode traversalMode)\n@@ -683,1 +685,1 @@\n-    for (auto* n = startNode; n != pastEnd; lastNode = n, n = next) {\n+    for (auto* n = &startNode; n != pastEnd; lastNode = n, n = next) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/editing\/markup.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4472,1 +4472,2 @@\n-    auto& scriptController = document().frame()->script();\n+    Ref protectedFrame = *document().frame();\n+    auto& scriptController = protectedFrame->script();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/html\/HTMLMediaElement.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-    if (video.player()->didPassCORSAccessCheck())\n+    if (!video.player() || video.player()->didPassCORSAccessCheck())\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/html\/ImageBitmap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -295,0 +295,3 @@\n+    if (!scriptingContentIsAllowed(m_parserContentPolicy))\n+        element.stripScriptingAttributes(token.attributes());\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/html\/parser\/HTMLConstructionSite.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"LayoutState.h\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/layout\/formattingContexts\/FormattingQuirks.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -634,1 +634,1 @@\n-    if (!frameLoader()->checkIfFormActionAllowedByCSP(newRequest.url(), didReceiveRedirectResponse)) {\n+    if (!frameLoader()->checkIfFormActionAllowedByCSP(newRequest.url(), didReceiveRedirectResponse, redirectResponse.url())) {\n@@ -761,1 +761,1 @@\n-static std::tuple<Ref<SecurityOrigin>, CrossOriginOpenerPolicy> computeResponseOriginAndCOOP(const ResourceResponse& response, const Document& document, const std::optional<NavigationAction::Requester>& requester)\n+static std::tuple<Ref<SecurityOrigin>, CrossOriginOpenerPolicy> computeResponseOriginAndCOOP(const ResourceResponse& response, const Document& document, const std::optional<NavigationAction::Requester>& requester, ContentSecurityPolicy* responseCSP)\n@@ -769,1 +769,3 @@\n-    return std::make_tuple(SecurityOrigin::create(response.url()), obtainCrossOriginOpenerPolicy(response, document));\n+    \/\/ If the HTTP response contains a CSP header, it may set sandbox flags, which would cause the origin to become unique.\n+    auto responseOrigin = responseCSP && responseCSP->sandboxFlags() != SandboxNone ? SecurityOrigin::createUnique() : SecurityOrigin::create(response.url());\n+    return std::make_tuple(WTFMove(responseOrigin), obtainCrossOriginOpenerPolicy(response, document));\n@@ -782,1 +784,1 @@\n-    auto [responseOrigin, responseCOOP] = computeResponseOriginAndCOOP(response, *m_frame->document(), m_triggeringAction.requester());\n+    auto [responseOrigin, responseCOOP] = computeResponseOriginAndCOOP(response, *m_frame->document(), m_triggeringAction.requester(), m_contentSecurityPolicy.get());\n@@ -919,0 +921,6 @@\n+    if (!response.httpHeaderField(HTTPHeaderName::ContentSecurityPolicy).isNull()) {\n+        m_contentSecurityPolicy = makeUnique<ContentSecurityPolicy>(URL { response.url() }, nullptr);\n+        m_contentSecurityPolicy->didReceiveHeaders(ContentSecurityPolicyResponseHeaders { response }, m_request.httpReferrer(), ContentSecurityPolicy::ReportParsingErrors::No);\n+    } else\n+        m_contentSecurityPolicy = nullptr;\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/DocumentLoader.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+    ContentSecurityPolicy* contentSecurityPolicy() const { return m_contentSecurityPolicy.get(); }\n@@ -631,0 +632,1 @@\n+    std::unique_ptr<ContentSecurityPolicy> m_contentSecurityPolicy;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/DocumentLoader.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -684,1 +684,1 @@\n-        return contentSecurityPolicy().allowChildContextFromSource(url, redirectResponseReceived);\n+        return contentSecurityPolicy().allowChildContextFromSource(url, redirectResponseReceived, preRedirectURL);\n@@ -688,1 +688,1 @@\n-        return contentSecurityPolicy().allowScriptFromSource(url, redirectResponseReceived);\n+        return contentSecurityPolicy().allowScriptFromSource(url, redirectResponseReceived, preRedirectURL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/DocumentThreadableLoader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"DocumentLoader.h\"\n@@ -145,0 +146,6 @@\n+    if (shouldReuseDefaultView) {\n+        ASSERT(m_frame->loader().documentLoader());\n+        if (auto* contentSecurityPolicy = m_frame->loader().documentLoader()->contentSecurityPolicy())\n+            shouldReuseDefaultView = !(contentSecurityPolicy->sandboxFlags() & SandboxOrigin);\n+    }\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/DocumentWriter.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -752,1 +752,5 @@\n-        m_frame.document()->contentSecurityPolicy()->didReceiveHeaders(ContentSecurityPolicyResponseHeaders(m_documentLoader->response()), referrer(), ContentSecurityPolicy::ReportParsingErrors::No);\n+        \/\/ The DocumentLoader may have already parsed the CSP header to do some checks. If so, reuse the already parsed version instead of parsing again.\n+        if (auto* contentSecurityPolicy = m_documentLoader->contentSecurityPolicy())\n+            m_frame.document()->contentSecurityPolicy()->didReceiveHeaders(*contentSecurityPolicy, ContentSecurityPolicy::ReportParsingErrors::No);\n+        else\n+            m_frame.document()->contentSecurityPolicy()->didReceiveHeaders(ContentSecurityPolicyResponseHeaders(m_documentLoader->response()), referrer(), ContentSecurityPolicy::ReportParsingErrors::No);\n@@ -1034,1 +1038,1 @@\n-bool FrameLoader::checkIfFormActionAllowedByCSP(const URL& url, bool didReceiveRedirectResponse) const\n+bool FrameLoader::checkIfFormActionAllowedByCSP(const URL& url, bool didReceiveRedirectResponse, const URL& preRedirectURL) const\n@@ -1040,1 +1044,1 @@\n-    return m_frame.document()->contentSecurityPolicy()->allowFormAction(url, redirectResponseReceived);\n+    return m_frame.document()->contentSecurityPolicy()->allowFormAction(url, redirectResponseReceived, preRedirectURL);\n@@ -2002,1 +2006,2 @@\n-    m_progressTracker->progressCompleted();\n+    if (m_progressTracker)\n+        m_progressTracker->progressCompleted();\n@@ -2588,1 +2593,2 @@\n-        const ResourceError& error = m_documentLoader->mainDocumentError();\n+        Ref protector = *m_documentLoader;\n+        const ResourceError& error = protector->mainDocumentError();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/FrameLoader.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-    bool checkIfFormActionAllowedByCSP(const URL&, bool didReceiveRedirectResponse) const;\n+    bool checkIfFormActionAllowedByCSP(const URL&, bool didReceiveRedirectResponse, const URL& preRedirectURL) const;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/FrameLoader.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-        if (!m_documentLoader->cachedResourceLoader().updateRequestAfterRedirection(m_resource->type(), newRequest, options())) {\n+        if (!m_documentLoader->cachedResourceLoader().updateRequestAfterRedirection(m_resource->type(), newRequest, options(), redirectResponse.url())) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/SubresourceLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,2 +170,2 @@\n-            if (auto data = m_data) {\n-                data->forEachSegment([&](auto& segment) {\n+            if (m_data) {\n+                m_data->forEachSegment([&](auto& segment) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/cache\/CachedRawResource.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-bool CachedResourceLoader::allowedByContentSecurityPolicy(CachedResource::Type type, const URL& url, const ResourceLoaderOptions& options, ContentSecurityPolicy::RedirectResponseReceived redirectResponseReceived) const\n+bool CachedResourceLoader::allowedByContentSecurityPolicy(CachedResource::Type type, const URL& url, const ResourceLoaderOptions& options, ContentSecurityPolicy::RedirectResponseReceived redirectResponseReceived, const URL& preRedirectURL) const\n@@ -503,1 +503,1 @@\n-        if (!m_document->contentSecurityPolicy()->allowScriptFromSource(url, redirectResponseReceived))\n+        if (!m_document->contentSecurityPolicy()->allowScriptFromSource(url, redirectResponseReceived, preRedirectURL))\n@@ -507,1 +507,1 @@\n-        if (!m_document->contentSecurityPolicy()->allowStyleFromSource(url, redirectResponseReceived))\n+        if (!m_document->contentSecurityPolicy()->allowStyleFromSource(url, redirectResponseReceived, preRedirectURL))\n@@ -513,1 +513,1 @@\n-        if (!m_document->contentSecurityPolicy()->allowImageFromSource(url, redirectResponseReceived))\n+        if (!m_document->contentSecurityPolicy()->allowImageFromSource(url, redirectResponseReceived, preRedirectURL))\n@@ -518,1 +518,1 @@\n-        if (!m_document->contentSecurityPolicy()->allowFontFromSource(url, redirectResponseReceived))\n+        if (!m_document->contentSecurityPolicy()->allowFontFromSource(url, redirectResponseReceived, preRedirectURL))\n@@ -525,1 +525,1 @@\n-        if (!m_document->contentSecurityPolicy()->allowMediaFromSource(url, redirectResponseReceived))\n+        if (!m_document->contentSecurityPolicy()->allowMediaFromSource(url, redirectResponseReceived, preRedirectURL))\n@@ -537,1 +537,1 @@\n-        if (!m_document->contentSecurityPolicy()->allowManifestFromSource(url, redirectResponseReceived))\n+        if (!m_document->contentSecurityPolicy()->allowManifestFromSource(url, redirectResponseReceived, preRedirectURL))\n@@ -595,1 +595,1 @@\n-bool CachedResourceLoader::canRequestAfterRedirection(CachedResource::Type type, const URL& url, const ResourceLoaderOptions& options) const\n+bool CachedResourceLoader::canRequestAfterRedirection(CachedResource::Type type, const URL& url, const ResourceLoaderOptions& options, const URL& preRedirectURL) const\n@@ -613,1 +613,1 @@\n-    if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::Yes)) {\n+    if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::Yes, preRedirectURL)) {\n@@ -628,1 +628,1 @@\n-bool CachedResourceLoader::updateRequestAfterRedirection(CachedResource::Type type, ResourceRequest& request, const ResourceLoaderOptions& options)\n+bool CachedResourceLoader::updateRequestAfterRedirection(CachedResource::Type type, ResourceRequest& request, const ResourceLoaderOptions& options, const URL& preRedirectURL)\n@@ -636,1 +636,1 @@\n-    return canRequestAfterRedirection(type, request.url(), options);\n+    return canRequestAfterRedirection(type, request.url(), options, preRedirectURL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/cache\/CachedResourceLoader.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -159,2 +159,2 @@\n-    bool updateRequestAfterRedirection(CachedResource::Type, ResourceRequest&, const ResourceLoaderOptions&);\n-    bool allowedByContentSecurityPolicy(CachedResource::Type, const URL&, const ResourceLoaderOptions&, ContentSecurityPolicy::RedirectResponseReceived) const;\n+    bool updateRequestAfterRedirection(CachedResource::Type, ResourceRequest&, const ResourceLoaderOptions&, const URL& preRedirectURL);\n+    bool allowedByContentSecurityPolicy(CachedResource::Type, const URL&, const ResourceLoaderOptions&, ContentSecurityPolicy::RedirectResponseReceived, const URL& preRedirectURL = URL()) const;\n@@ -200,1 +200,1 @@\n-    bool canRequestAfterRedirection(CachedResource::Type, const URL&, const ResourceLoaderOptions&) const;\n+    bool canRequestAfterRedirection(CachedResource::Type, const URL&, const ResourceLoaderOptions&, const URL& preRedirectURL) const;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/loader\/cache\/CachedResourceLoader.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    bool operator!=(const ClientOrigin& other) const { return !(*this == other); }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/ClientOrigin.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -964,0 +964,5 @@\n+#if PLATFORM(GTK)\n+    if (dragEvent.isTouchEvent())\n+        return false;\n+#endif\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/DragController.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3810,3 +3810,4 @@\n-        else if (event.keyIdentifier() == \"PageUp\" || event.keyIdentifier() == \"PageDown\")\n-            startKeyboardScrolling(event);\n-        else {\n+        else if (event.keyIdentifier() == \"PageUp\" || event.keyIdentifier() == \"PageDown\") {\n+            if (startKeyboardScrolling(event))\n+                event.setDefaultHandled();\n+        } else {\n@@ -4291,0 +4292,3 @@\n+    if (!m_frame.settings().eventHandlerDrivenSmoothKeyboardScrollingEnabled())\n+        return false;\n+\n@@ -4306,2 +4310,2 @@\n-        if (m_frame.settings().eventHandlerDrivenSmoothKeyboardScrollingEnabled())\n-            startKeyboardScrolling(event);\n+        if (startKeyboardScrolling(event))\n+            event.setDefaultHandled();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/EventHandler.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -355,0 +355,5 @@\n+void FrameView::willBeDestroyed()\n+{\n+    setHasHorizontalScrollbar(false);\n+    setHasVerticalScrollbar(false);\n+}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/FrameView.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -685,0 +685,1 @@\n+    void willBeDestroyed() final;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/FrameView.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -173,0 +173,5 @@\n+    \/\/ Per the specification, we should dispatch at least one observation for the target. For this reason, we make sure to keep the\n+    \/\/ target alive until this first observation. This, in turn, will keep the IntersectionObserver's JS wrapper alive via\n+    \/\/ isReachableFromOpaqueRoots(), so the callback stays alive.\n+    m_targetsWaitingForFirstObservation.append(target);\n+\n@@ -186,0 +191,1 @@\n+    m_targetsWaitingForFirstObservation.removeFirstMatching([&](auto& pendingTarget) { return pendingTarget.ptr() == &target; });\n@@ -211,0 +217,1 @@\n+    m_targetsWaitingForFirstObservation.removeFirstMatching([&](auto& pendingTarget) { return pendingTarget.ptr() == &target; });\n@@ -236,0 +243,1 @@\n+    m_targetsWaitingForFirstObservation.clear();\n@@ -277,0 +285,1 @@\n+    auto targetsWaitingForFirstObservation = std::exchange(m_targetsWaitingForFirstObservation, { });\n@@ -302,1 +311,1 @@\n-    return false;\n+    return !m_targetsWaitingForFirstObservation.isEmpty();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/IntersectionObserver.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+    Vector<GCReachableRef<Element>> m_targetsWaitingForFirstObservation;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/IntersectionObserver.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    [SetterCallWith=IncumbentWindow&FirstWindow, DoNotCheckSecurityOnSetter] stringifier attribute USVString href;\n+    [SetterCallWith=LegacyActiveWindowForAccessor&FirstWindow, DoNotCheckSecurityOnSetter] stringifier attribute USVString href;\n@@ -54,7 +54,7 @@\n-    [SetterCallWith=IncumbentWindow&FirstWindow] attribute USVString protocol;\n-    [SetterCallWith=IncumbentWindow&FirstWindow] attribute USVString host;\n-    [SetterCallWith=IncumbentWindow&FirstWindow] attribute USVString hostname;\n-    [SetterCallWith=IncumbentWindow&FirstWindow] attribute USVString port;\n-    [SetterCallWith=IncumbentWindow&FirstWindow] attribute USVString pathname;\n-    [SetterCallWith=IncumbentWindow&FirstWindow] attribute USVString search;\n-    [SetterCallWith=IncumbentWindow&FirstWindow] attribute USVString hash;\n+    [SetterCallWith=LegacyActiveWindowForAccessor&FirstWindow] attribute USVString protocol;\n+    [SetterCallWith=LegacyActiveWindowForAccessor&FirstWindow] attribute USVString host;\n+    [SetterCallWith=LegacyActiveWindowForAccessor&FirstWindow] attribute USVString hostname;\n+    [SetterCallWith=LegacyActiveWindowForAccessor&FirstWindow] attribute USVString port;\n+    [SetterCallWith=LegacyActiveWindowForAccessor&FirstWindow] attribute USVString pathname;\n+    [SetterCallWith=LegacyActiveWindowForAccessor&FirstWindow] attribute USVString search;\n+    [SetterCallWith=LegacyActiveWindowForAccessor&FirstWindow] attribute USVString hash;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/Location.idl","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#pragma once\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/PerformanceNavigationTiming.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,0 +102,3 @@\n+    if (m_resourceTiming.networkLoadMetrics().failsTAOCheck)\n+        return emptyString();\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/PerformanceResourceTiming.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -176,0 +176,11 @@\n+void ContentSecurityPolicy::didReceiveHeaders(const ContentSecurityPolicy& other, ReportParsingErrors reportParsingErrors)\n+{\n+    SetForScope<bool> isReportingEnabled(m_isReportingEnabled, reportParsingErrors == ReportParsingErrors::Yes);\n+    for (auto& policy : other.m_policies)\n+        didReceiveHeader(policy->header(), policy->headerType(), ContentSecurityPolicy::PolicyFrom::HTTPHeader, String { });\n+    m_referrer = other.m_referrer;\n+    m_httpStatusCode = other.m_httpStatusCode;\n+    m_upgradeInsecureRequests = other.m_upgradeInsecureRequests;\n+    m_insecureNavigationRequestsToUpgrade.add(other.m_insecureNavigationRequestsToUpgrade.begin(), other.m_insecureNavigationRequestsToUpgrade.end());\n+}\n+\n@@ -553,1 +564,1 @@\n-bool ContentSecurityPolicy::allowResourceFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived, const char* name, ResourcePredicate resourcePredicate) const\n+bool ContentSecurityPolicy::allowResourceFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived, const char* name, ResourcePredicate resourcePredicate, const URL& preRedirectURL) const\n@@ -558,1 +569,2 @@\n-    TextPosition sourcePosition(WTF::OrdinalNumber::beforeFirst(), WTF::OrdinalNumber());\n+    const auto& blockedURL = !preRedirectURL.isNull() ? preRedirectURL : url;\n+    TextPosition sourcePosition(OrdinalNumber::beforeFirst(), OrdinalNumber());\n@@ -560,2 +572,2 @@\n-        String consoleMessage = consoleMessageForViolation(name, violatedDirective, url, \"Refused to load\");\n-        reportViolation(name, violatedDirective, url, consoleMessage, sourceURL, sourcePosition);\n+        String consoleMessage = consoleMessageForViolation(name, violatedDirective, blockedURL, \"Refused to load\");\n+        reportViolation(name, violatedDirective, blockedURL, consoleMessage, sourceURL, sourcePosition);\n@@ -566,1 +578,1 @@\n-bool ContentSecurityPolicy::allowChildContextFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived) const\n+bool ContentSecurityPolicy::allowChildContextFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived, const URL& preRedirectURL) const\n@@ -568,1 +580,1 @@\n-    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::childSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForChildContext);\n+    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::childSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForChildContext, preRedirectURL);\n@@ -571,1 +583,1 @@\n-bool ContentSecurityPolicy::allowScriptFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived) const\n+bool ContentSecurityPolicy::allowScriptFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived, const URL& preRedirectURL) const\n@@ -573,1 +585,1 @@\n-    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::scriptSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForScript);\n+    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::scriptSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForScript, preRedirectURL);\n@@ -576,1 +588,1 @@\n-bool ContentSecurityPolicy::allowImageFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived) const\n+bool ContentSecurityPolicy::allowImageFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived, const URL& preRedirectURL) const\n@@ -578,1 +590,1 @@\n-    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::imgSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForImage);\n+    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::imgSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForImage, preRedirectURL);\n@@ -581,1 +593,1 @@\n-bool ContentSecurityPolicy::allowStyleFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived) const\n+bool ContentSecurityPolicy::allowStyleFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived, const URL& preRedirectURL) const\n@@ -583,1 +595,1 @@\n-    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::styleSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForStyle);\n+    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::styleSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForStyle, preRedirectURL);\n@@ -586,1 +598,1 @@\n-bool ContentSecurityPolicy::allowFontFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived) const\n+bool ContentSecurityPolicy::allowFontFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived, const URL& preRedirectURL) const\n@@ -588,1 +600,1 @@\n-    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::fontSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForFont);\n+    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::fontSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForFont, preRedirectURL);\n@@ -592,1 +604,1 @@\n-bool ContentSecurityPolicy::allowManifestFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived) const\n+bool ContentSecurityPolicy::allowManifestFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived, const URL& preRedirectURL) const\n@@ -594,1 +606,1 @@\n-    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::manifestSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForManifest);\n+    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::manifestSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForManifest, preRedirectURL);\n@@ -598,1 +610,1 @@\n-bool ContentSecurityPolicy::allowMediaFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived) const\n+bool ContentSecurityPolicy::allowMediaFromSource(const URL& url, RedirectResponseReceived redirectResponseReceived, const URL& preRedirectURL) const\n@@ -600,1 +612,1 @@\n-    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::mediaSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForMedia);\n+    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::mediaSrc, &ContentSecurityPolicyDirectiveList::violatedDirectiveForMedia, preRedirectURL);\n@@ -616,1 +628,1 @@\n-bool ContentSecurityPolicy::allowFormAction(const URL& url, RedirectResponseReceived redirectResponseReceived) const\n+bool ContentSecurityPolicy::allowFormAction(const URL& url, RedirectResponseReceived redirectResponseReceived, const URL& preRedirectURL) const\n@@ -618,1 +630,1 @@\n-    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::formAction, &ContentSecurityPolicyDirectiveList::violatedDirectiveForFormAction);\n+    return allowResourceFromSource(url, redirectResponseReceived, ContentSecurityPolicyDirectiveNames::formAction, &ContentSecurityPolicyDirectiveList::violatedDirectiveForFormAction, preRedirectURL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/csp\/ContentSecurityPolicy.cpp","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+    void didReceiveHeaders(const ContentSecurityPolicy&, ReportParsingErrors = ReportParsingErrors::Yes);\n@@ -106,4 +107,4 @@\n-    WEBCORE_EXPORT bool allowScriptFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No) const;\n-    bool allowImageFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No) const;\n-    bool allowStyleFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No) const;\n-    bool allowFontFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No) const;\n+    WEBCORE_EXPORT bool allowScriptFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No, const URL& preRedirectURL = URL()) const;\n+    bool allowImageFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No, const URL& preRedirectURL = URL()) const;\n+    bool allowStyleFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No, const URL& preRedirectURL = URL()) const;\n+    bool allowFontFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No, const URL& preRedirectURL = URL()) const;\n@@ -111,1 +112,1 @@\n-    bool allowManifestFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No) const;\n+    bool allowManifestFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No, const URL& preRedirectURL = URL()) const;\n@@ -113,1 +114,1 @@\n-    bool allowMediaFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No) const;\n+    bool allowMediaFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No, const URL& preRedirectURL = URL()) const;\n@@ -116,1 +117,1 @@\n-    WEBCORE_EXPORT bool allowChildContextFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No) const;\n+    WEBCORE_EXPORT bool allowChildContextFromSource(const URL&, RedirectResponseReceived = RedirectResponseReceived::No, const URL& requestedURL = URL()) const;\n@@ -118,1 +119,1 @@\n-    bool allowFormAction(const URL&, RedirectResponseReceived = RedirectResponseReceived::No) const;\n+    bool allowFormAction(const URL&, RedirectResponseReceived = RedirectResponseReceived::No, const URL& preRedirectURL = URL()) const;\n@@ -180,0 +181,2 @@\n+    SandboxFlags sandboxFlags() const { return m_sandboxFlags; }\n+\n@@ -206,1 +209,1 @@\n-    bool allowResourceFromSource(const URL&, RedirectResponseReceived, const char*, ResourcePredicate) const;\n+    bool allowResourceFromSource(const URL&, RedirectResponseReceived, const char*, ResourcePredicate, const URL& preRedirectURL = URL()) const;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/csp\/ContentSecurityPolicy.h","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -94,0 +94,6 @@\n+#if PLATFORM(GTK)\n+        enum class IsTouch : bool { No, Yes };\n+\n+        bool isTouchEvent() const { return m_isTouchEvent == IsTouch::Yes; }\n+#endif\n+\n@@ -112,0 +118,2 @@\n+#elif PLATFORM(GTK)\n+        IsTouch m_isTouchEvent { IsTouch::No };\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/PlatformMouseEvent.h","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -241,1 +241,2 @@\n-    for (auto& segment : m_segments)\n+    auto segments = m_segments;\n+    for (auto& segment : segments)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/SharedBuffer.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+platform\/glib\/ApplicationGLib.cpp\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/SourcesGLib.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-        return \"Chrome\/90.0.4419.1\"_s;\n+        return \"Chrome\/97.0.4669.2\"_s;\n@@ -174,1 +174,1 @@\n-        return \"; rv:87.0) Gecko\/20100101 Firefox\/87.0\"_s;\n+        return \"; rv:95.0) Gecko\/20100101 Firefox\/95.0\"_s;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/UserAgentQuirks.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -183,0 +183,2 @@\n+    virtual void willBeDestroyed() { }\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/Widget.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,0 +278,1 @@\n+#if ENABLE(VIDEO)\n@@ -283,0 +284,1 @@\n+#endif \/\/ ENABLE(VIDEO)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/BifurcatedGraphicsContext.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include <utility>\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/x11\/XUniqueResource.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3178,0 +3178,3 @@\n+        \/\/ Only grid is expected to be in a state where it is calculating pref width and having unknown logical width.\n+        if (isRenderGrid() && preferredLogicalWidthsDirty() && !style().logicalWidth().isFixed())\n+            return availableHeight;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/rendering\/RenderBlock.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2102,0 +2102,22 @@\n+bool RenderBlockFlow::subtreeContainsFloat(RenderBox& renderer) const\n+{\n+    bool contains = m_floatingObjects && m_floatingObjects->set().contains<FloatingObjectHashTranslator>(renderer);\n+    for (auto& block : childrenOfType<RenderBlock>(*this)) {\n+        if (!is<RenderBlockFlow>(block))\n+            continue;\n+        auto& blockFlow = downcast<RenderBlockFlow>(block);\n+        contains |= blockFlow.subtreeContainsFloat(renderer);\n+    }\n+    return contains;\n+}\n+bool RenderBlockFlow::subtreeContainsFloats() const\n+{\n+    bool contains = m_floatingObjects && !m_floatingObjects->set().isEmpty();\n+    for (auto& block : childrenOfType<RenderBlock>(*this)) {\n+        if (!is<RenderBlockFlow>(block))\n+            continue;\n+        auto& blockFlow = downcast<RenderBlockFlow>(block);\n+        contains |= blockFlow.subtreeContainsFloats();\n+    }\n+    return contains;\n+}\n@@ -2871,1 +2893,1 @@\n-        if ((floatToRemove ? blockFlow.containsFloat(*floatToRemove) : blockFlow.containsFloats()) || blockFlow.shrinkToAvoidFloats())\n+        if ((floatToRemove ? blockFlow.subtreeContainsFloat(*floatToRemove) : blockFlow.subtreeContainsFloats()) || blockFlow.shrinkToAvoidFloats())\n@@ -3677,1 +3699,1 @@\n-        if (needsLayout())\n+        if (selfNeedsLayout() || normalChildNeedsLayout())\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/rendering\/RenderBlockFlow.cpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -281,0 +281,2 @@\n+    bool subtreeContainsFloats() const;\n+    bool subtreeContainsFloat(RenderBox&) const;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/rendering\/RenderBlockFlow.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-    if (isOutOfFlowPositioned() && parent() && parent()->style().isDisplayFlexibleOrGridBox())\n+    if (isOutOfFlowPositioned() && parent() && parent()->style().isDisplayFlexibleBoxIncludingDeprecatedOrGridBox())\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/rendering\/RenderBox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -294,1 +294,2 @@\n-                        currentRenderer = parentOrPseudoHostElement(*currentRenderer)->renderer();\n+                        auto* parent = parentOrPseudoHostElement(*currentRenderer);\n+                        currentRenderer = parent ? parent->renderer() : nullptr;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/rendering\/RenderCounter.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,0 +106,2 @@\n+    if (renderTreeBeingDestroyed() && document().backForwardCacheState() == Document::NotInBackForwardCache && m_widget)\n+        m_widget->willBeDestroyed();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/rendering\/RenderWidget.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1498,0 +1498,1 @@\n+    bool isDisplayFlexibleBoxIncludingDeprecatedOrGridBox() const { return isDisplayFlexibleOrGridBox() || isDisplayDeprecatedFlexibleBox(display()); }\n@@ -1964,0 +1965,1 @@\n+    static bool isDisplayDeprecatedFlexibleBox(DisplayType);\n@@ -2371,0 +2373,5 @@\n+inline bool RenderStyle::isDisplayDeprecatedFlexibleBox(DisplayType display)\n+{\n+    return display == DisplayType::Box || display == DisplayType::InlineBox;\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/rendering\/style\/RenderStyle.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -320,1 +320,1 @@\n-    bool shouldTearDownRenderers = elementUpdate.change == Style::Change::Renderer && (element.renderer() || element.hasDisplayContents());\n+    bool shouldTearDownRenderers = elementUpdate.change == Style::Change::Renderer && (element.renderer() || element.hasDisplayContents() || element.isInTopLayer());\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/rendering\/updating\/RenderTreeUpdater.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include <wtf\/Deque.h>\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/workers\/Worker.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,2 +91,1 @@\n-\n-    WEBCORE_EXPORT void registerServiceWorkerClients();\n+    bool isClosed() const { return m_isClosed; }\n@@ -109,0 +108,1 @@\n+    void setIsClosed() { m_isClosed = true; }\n@@ -116,0 +116,1 @@\n+    bool m_isClosed { false };\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/workers\/service\/SWClientConnection.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-    if (!m_swConnection) {\n+    if (!m_swConnection || m_swConnection->isClosed()) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/workers\/service\/ServiceWorkerContainer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -822,0 +822,5 @@\n+    if (!result) {\n+        ASSERT(worker.isNotRunning());\n+        return;\n+    }\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/workers\/service\/server\/SWServer.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-                if (nodeMatches(*node, ParentAxis, m_nodeTest))\n+                if (node && nodeMatches(*node, ParentAxis, m_nodeTest))\n@@ -272,0 +272,2 @@\n+                if (!node)\n+                    return;\n@@ -302,0 +304,2 @@\n+                if (!node)\n+                    return;\n@@ -321,1 +325,1 @@\n-            if (context.isAttributeNode())\n+            if (context.isAttributeNode()) {\n@@ -323,1 +327,3 @@\n-            else\n+                if (!node)\n+                    return;\n+            } else\n@@ -384,0 +390,2 @@\n+                if (!node)\n+                    return;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/xml\/XPathStep.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,1 +39,3 @@\n-    auto event = callConstructor(context, \"Event\", { makeValue(context, \"TestRendered\"), initializer });\n+    auto value = makeValue(context, \"TestRendered\");\n+    JSValueProtect(context, value);\n+    auto event = callConstructor(context, \"Event\", { value, initializer });\n@@ -42,0 +44,1 @@\n+    JSValueUnprotect(context, value);\n","filename":"modules\/javafx.web\/src\/main\/native\/Tools\/TestRunnerShared\/ReftestFunctions.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}