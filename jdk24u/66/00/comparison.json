{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1431,0 +1431,1 @@\n+  assert(post_head->in(1)->is_IfProj(), \"must be zero-trip guard If node projection of the post loop\");\n@@ -1436,0 +1437,1 @@\n+  const uint last_node_index_in_pre_loop_body = Compile::current()->unique() - 1;\n@@ -1448,0 +1450,1 @@\n+  DEBUG_ONLY(const uint last_node_index_from_backedge_goo = Compile::current()->unique() - 1);\n@@ -1449,11 +1452,0 @@\n-  \/\/ Nodes inside the loop may be control dependent on a predicate\n-  \/\/ that was moved before the preloop. If the back branch of the main\n-  \/\/ or post loops becomes dead, those nodes won't be dependent on the\n-  \/\/ test that guards that loop nest anymore which could lead to an\n-  \/\/ incorrect array access because it executes independently of the\n-  \/\/ test that was guarding the loop nest. We add a special CastII on\n-  \/\/ the if branch that enters the loop, between the input induction\n-  \/\/ variable value and the induction variable Phi to preserve correct\n-  \/\/ dependencies.\n-\n-  assert(post_head->in(1)->is_IfProj(), \"must be zero-trip guard If node projection of the post loop\");\n@@ -1462,1 +1454,3 @@\n-    initialize_assertion_predicates_for_main_loop(pre_head, main_head, first_node_index_in_pre_loop_body, old_new);\n+    initialize_assertion_predicates_for_main_loop(pre_head, main_head, first_node_index_in_pre_loop_body,\n+                                                  last_node_index_in_pre_loop_body,\n+                                                  DEBUG_ONLY(last_node_index_from_backedge_goo COMMA) old_new);\n@@ -1737,1 +1731,3 @@\n-                                                                   const uint first_node_index_in_cloned_loop_body,\n+                                                                   const uint first_node_index_in_pre_loop_body,\n+                                                                   const uint last_node_index_in_pre_loop_body,\n+                                                                   DEBUG_ONLY(const uint last_node_index_from_backedge_goo COMMA)\n@@ -1739,2 +1735,5 @@\n-  const NodeInOriginalLoopBody node_in_original_loop_body(first_node_index_in_cloned_loop_body, old_new);\n-  create_assertion_predicates_at_loop(pre_loop_head, main_loop_head, node_in_original_loop_body, true);\n+  assert(first_node_index_in_pre_loop_body < last_node_index_in_pre_loop_body, \"cloned some nodes\");\n+  const NodeInMainLoopBody node_in_main_loop_body(first_node_index_in_pre_loop_body,\n+                                                  last_node_index_in_pre_loop_body,\n+                                                  DEBUG_ONLY(last_node_index_from_backedge_goo COMMA) old_new);\n+  create_assertion_predicates_at_main_or_post_loop(pre_loop_head, main_loop_head, node_in_main_loop_body, true);\n@@ -1749,1 +1748,1 @@\n-  create_assertion_predicates_at_loop(main_loop_head, post_loop_head, node_in_cloned_loop_body, false);\n+  create_assertion_predicates_at_main_or_post_loop(main_loop_head, post_loop_head, node_in_cloned_loop_body, false);\n@@ -1771,0 +1770,41 @@\n+\n+void PhaseIdealLoop::create_assertion_predicates_at_main_or_post_loop(CountedLoopNode* source_loop_head,\n+                                                                      CountedLoopNode* target_loop_head,\n+                                                                      const NodeInLoopBody& _node_in_loop_body,\n+                                                                      bool clone_template) {\n+  Node* old_target_loop_head_entry = target_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  const uint node_index_before_new_assertion_predicate_nodes = C->unique();\n+  const bool need_to_rewire_old_target_loop_entry_dependencies = old_target_loop_head_entry->outcnt() > 1;\n+  create_assertion_predicates_at_loop(source_loop_head, target_loop_head, _node_in_loop_body, clone_template);\n+  if (need_to_rewire_old_target_loop_entry_dependencies) {\n+    rewire_old_target_loop_entry_dependency_to_new_entry(target_loop_head, old_target_loop_head_entry,\n+                                                         node_index_before_new_assertion_predicate_nodes);\n+  }\n+}\n+\n+\/\/ Rewire any control dependent nodes on the old target loop entry before adding Assertion Predicate related nodes.\n+\/\/ These have been added by PhaseIdealLoop::clone_up_backedge_goo() and assume to be ending up at the target loop entry\n+\/\/ which is no longer the case when adding additional Assertion Predicates. Fix this by rewiring these nodes to the new\n+\/\/ target loop entry which corresponds to the tail of the last Assertion Predicate before the target loop. This is safe\n+\/\/ to do because these control dependent nodes on the old target loop entry created by clone_up_backedge_goo() were\n+\/\/ pinned on the loop backedge before. The Assertion Predicates are not control dependent on these nodes in any way.\n+void PhaseIdealLoop::rewire_old_target_loop_entry_dependency_to_new_entry(\n+    LoopNode* target_loop_head, const Node* old_target_loop_entry,\n+    const uint node_index_before_new_assertion_predicate_nodes) {\n+  Node* new_main_loop_entry = target_loop_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  if (new_main_loop_entry == old_target_loop_entry) {\n+    \/\/ No Assertion Predicates added.\n+    return;\n+  }\n+\n+  for (DUIterator_Fast imax, i = old_target_loop_entry->fast_outs(imax); i < imax; i++) {\n+    Node* out = old_target_loop_entry->fast_out(i);\n+    if (!out->is_CFG() && out->_idx < node_index_before_new_assertion_predicate_nodes) {\n+      _igvn.replace_input_of(out, 0, new_main_loop_entry);\n+      set_ctrl(out, new_main_loop_entry);\n+      --i;\n+      --imax;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":57,"deletions":17,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -953,1 +953,3 @@\n-                                                     uint first_node_index_in_cloned_loop_body,\n+                                                     uint first_node_index_in_pre_loop_body,\n+                                                     uint last_node_index_in_pre_loop_body,\n+                                                     DEBUG_ONLY(uint last_node_index_from_backedge_goo COMMA)\n@@ -959,0 +961,6 @@\n+  void create_assertion_predicates_at_main_or_post_loop(CountedLoopNode* source_loop_head,\n+                                                        CountedLoopNode* target_loop_head,\n+                                                        const NodeInLoopBody& _node_in_loop_body, bool clone_template);\n+  void rewire_old_target_loop_entry_dependency_to_new_entry(LoopNode* target_loop_head,\n+                                                            const Node* old_target_loop_entry,\n+                                                            uint node_index_before_new_assertion_predicate_nodes);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    if (!output->is_CFG() && data_in_loop_body.check(output)) {\n+    if (!output->is_CFG() && data_in_loop_body.check_node_in_loop_body(output)) {\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -252,1 +252,1 @@\n-  virtual bool check(Node* node) const = 0;\n+  virtual bool check_node_in_loop_body(Node* node) const = 0;\n@@ -955,1 +955,1 @@\n-  bool check(Node* node) const override {\n+  bool check_node_in_loop_body(Node* node) const override {\n@@ -958,0 +958,1 @@\n+      \/\/ Check that the clone is actually part of the cloned loop body and not from some earlier cloning.\n@@ -959,2 +960,0 @@\n-    } else {\n-      return false;\n@@ -962,0 +961,40 @@\n+    return false;\n+  }\n+};\n+\n+\/\/ This class checks whether a node is in the main loop body and not the pre loop body. We cannot use the\n+\/\/ NodeInOriginalLoopBody class because PhaseIdealLoop::clone_up_backedge_goo() could clone additional nodes that\n+\/\/ should be pinned at the main loop body entry. The check in NodeInOriginalLoopBody will ignore these.\n+class NodeInMainLoopBody : public NodeInLoopBody {\n+  const uint _first_node_index_in_pre_loop_body;\n+  const uint _last_node_index_in_pre_loop_body;\n+  DEBUG_ONLY(const uint _last_node_index_from_backedge_goo;)\n+  const Node_List& _old_new;\n+\n+  public:\n+  NodeInMainLoopBody(const uint first_node_index_in_pre_loop_body, const uint last_node_index_in_pre_loop_body,\n+                     DEBUG_ONLY(const uint last_node_index_from_backedge_goo COMMA) const Node_List& old_new)\n+      : _first_node_index_in_pre_loop_body(first_node_index_in_pre_loop_body),\n+        _last_node_index_in_pre_loop_body(last_node_index_in_pre_loop_body),\n+        DEBUG_ONLY(_last_node_index_from_backedge_goo(last_node_index_from_backedge_goo) COMMA)\n+        _old_new(old_new) {}\n+  NONCOPYABLE(NodeInMainLoopBody);\n+\n+  \/\/ Check if 'node' is not a cloned node (i.e. \"< _first_node_index_in_cloned_loop_body\") and if we've created a\n+  \/\/ clone from 'node' (i.e. _old_new entry is non-null). Then we know that 'node' belongs to the original loop body.\n+  \/\/ Additionally check if a node was cloned after the pre loop was created. This indicates that it was created by\n+  \/\/ PhaseIdealLoop::clone_up_backedge_goo(). These nodes should also be pinned at the main loop entry.\n+  bool check_node_in_loop_body(Node* node) const override {\n+    if (node->_idx < _first_node_index_in_pre_loop_body) {\n+      Node* cloned_node = _old_new[node->_idx];\n+      \/\/ Check that the clone is actually part of the cloned loop body and not from some earlier cloning.\n+      bool cloned_node_in_pre_loop_body = cloned_node != nullptr && cloned_node->_idx >= _first_node_index_in_pre_loop_body;\n+      assert(!cloned_node_in_pre_loop_body || cloned_node->_idx <= _last_node_index_in_pre_loop_body,\n+             \"clone must be part of pre loop body\");\n+      return cloned_node_in_pre_loop_body;\n+    }\n+    \/\/ Created in PhaseIdealLoop::clone_up_backedge_goo()?\n+    bool node_created_by_backedge_goo = node->_idx > _last_node_index_in_pre_loop_body;\n+    assert(!node_created_by_backedge_goo || node->_idx <= _last_node_index_from_backedge_goo,\n+           \"cloned node must have been created in PhaseIdealLoop::clone_up_backedge_goo()\");\n+    return node_created_by_backedge_goo;\n@@ -976,1 +1015,1 @@\n-  bool check(Node* node) const override {\n+  bool check_node_in_loop_body(Node* node) const override {\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":45,"deletions":6,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347018\n+ * @summary Test that stores cloned with clone_up_backedge_goo() are not pinned above Assertion Predicates on which a\n+ *          load node is pinned at which will later fail in scheduling.\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,*TestLoadPinnedAboveAssertionPredicatesAndUsingStore::test\n+ *                   compiler.predicates.assertion.TestLoadPinnedAboveAssertionPredicatesAndUsingStore\n+ *\/\n+\n+package compiler.predicates.assertion;\n+\n+public class TestLoadPinnedAboveAssertionPredicatesAndUsingStore {\n+    static int iFld;\n+    static int iArr[] = new int[100];\n+\n+    static void test() {\n+        int i = 63;\n+        do {\n+            iArr[1] = 34;\n+            iArr[i] += iFld;\n+            for (int j = i; j < 1; j++) {\n+            }\n+        } while (--i > 0);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestLoadPinnedAboveAssertionPredicatesAndUsingStore.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}