{"files":[{"patch":"@@ -1,413 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# <pre>\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-\n-# So much for footnotes about Saudi Arabia.\n-# Apparent noon times below are for Riyadh; your mileage will vary.\n-# Times were computed using formulas in the U.S. Naval Observatory's\n-# Almanac for Computers 1987; the formulas \"will give EqT to an accuracy of\n-# [plus or minus two] seconds during the current year.\"\n-#\n-# Rounding to the nearest five seconds results in fewer than\n-# 256 different \"time types\"--a limit that's faced because time types are\n-# stored on disk as unsigned chars.\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tsol87\t1987\tonly\t-\tJan\t1\t12:03:20s -0:03:20 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t2\t12:03:50s -0:03:50 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t3\t12:04:15s -0:04:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t4\t12:04:45s -0:04:45 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t5\t12:05:10s -0:05:10 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t6\t12:05:40s -0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t7\t12:06:05s -0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t8\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t9\t12:06:55s -0:06:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t10\t12:07:20s -0:07:20 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t11\t12:07:45s -0:07:45 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t12\t12:08:10s -0:08:10 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t13\t12:08:30s -0:08:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t14\t12:08:55s -0:08:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t15\t12:09:15s -0:09:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t16\t12:09:35s -0:09:35 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t17\t12:09:55s -0:09:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t18\t12:10:15s -0:10:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t19\t12:10:35s -0:10:35 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t20\t12:10:55s -0:10:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t21\t12:11:10s -0:11:10 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t22\t12:11:30s -0:11:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t23\t12:11:45s -0:11:45 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t24\t12:12:00s -0:12:00 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t25\t12:12:15s -0:12:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t26\t12:12:30s -0:12:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t27\t12:12:40s -0:12:40 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t28\t12:12:55s -0:12:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t29\t12:13:05s -0:13:05 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t30\t12:13:15s -0:13:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t31\t12:13:25s -0:13:25 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t1\t12:13:35s -0:13:35 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t2\t12:13:40s -0:13:40 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t3\t12:13:50s -0:13:50 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t4\t12:13:55s -0:13:55 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t5\t12:14:00s -0:14:00 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t6\t12:14:05s -0:14:05 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t7\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t8\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t9\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t10\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t11\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t12\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t13\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t14\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t15\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t16\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t17\t12:14:05s -0:14:05 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t18\t12:14:00s -0:14:00 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t19\t12:13:55s -0:13:55 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t20\t12:13:50s -0:13:50 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t21\t12:13:45s -0:13:45 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t22\t12:13:35s -0:13:35 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t23\t12:13:30s -0:13:30 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t24\t12:13:20s -0:13:20 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t25\t12:13:10s -0:13:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t26\t12:13:00s -0:13:00 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t27\t12:12:50s -0:12:50 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t28\t12:12:40s -0:12:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t1\t12:12:30s -0:12:30 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t2\t12:12:20s -0:12:20 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t3\t12:12:05s -0:12:05 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t4\t12:11:55s -0:11:55 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t5\t12:11:40s -0:11:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t6\t12:11:25s -0:11:25 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t7\t12:11:15s -0:11:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t8\t12:11:00s -0:11:00 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t9\t12:10:45s -0:10:45 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t10\t12:10:30s -0:10:30 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t11\t12:10:15s -0:10:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t12\t12:09:55s -0:09:55 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t13\t12:09:40s -0:09:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t14\t12:09:25s -0:09:25 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t15\t12:09:10s -0:09:10 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t16\t12:08:50s -0:08:50 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t17\t12:08:35s -0:08:35 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t18\t12:08:15s -0:08:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t19\t12:08:00s -0:08:00 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t20\t12:07:40s -0:07:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t21\t12:07:25s -0:07:25 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t22\t12:07:05s -0:07:05 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t23\t12:06:50s -0:06:50 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t24\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t25\t12:06:10s -0:06:10 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t26\t12:05:55s -0:05:55 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t27\t12:05:35s -0:05:35 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t28\t12:05:15s -0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t29\t12:05:00s -0:05:00 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t30\t12:04:40s -0:04:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t31\t12:04:25s -0:04:25 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t1\t12:04:05s -0:04:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t2\t12:03:45s -0:03:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t3\t12:03:30s -0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t4\t12:03:10s -0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t5\t12:02:55s -0:02:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t6\t12:02:35s -0:02:35 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t7\t12:02:20s -0:02:20 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t8\t12:02:05s -0:02:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t9\t12:01:45s -0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t10\t12:01:30s -0:01:30 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t11\t12:01:15s -0:01:15 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t12\t12:00:55s -0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t13\t12:00:40s -0:00:40 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t14\t12:00:25s -0:00:25 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t15\t12:00:10s -0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t16\t11:59:55s 0:00:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t17\t11:59:45s 0:00:15 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t18\t11:59:30s 0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t19\t11:59:15s 0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t20\t11:59:05s 0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t21\t11:58:50s 0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t22\t11:58:40s 0:01:20 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t23\t11:58:25s 0:01:35 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t24\t11:58:15s 0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t25\t11:58:05s 0:01:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t26\t11:57:55s 0:02:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t27\t11:57:45s 0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t28\t11:57:35s 0:02:25 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t29\t11:57:25s 0:02:35 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t30\t11:57:15s 0:02:45 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t1\t11:57:10s 0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t2\t11:57:00s 0:03:00 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t3\t11:56:55s 0:03:05 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t4\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t5\t11:56:45s 0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t6\t11:56:40s 0:03:20 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t7\t11:56:35s 0:03:25 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t8\t11:56:30s 0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t9\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t10\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t11\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t12\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t13\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t14\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t15\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t16\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t17\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t18\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t19\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t20\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t21\t11:56:30s 0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t22\t11:56:35s 0:03:25 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t23\t11:56:40s 0:03:20 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t24\t11:56:45s 0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t25\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t26\t11:56:55s 0:03:05 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t27\t11:57:00s 0:03:00 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t28\t11:57:10s 0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t29\t11:57:15s 0:02:45 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t30\t11:57:25s 0:02:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t31\t11:57:30s 0:02:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t1\t11:57:40s 0:02:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t2\t11:57:50s 0:02:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t3\t11:58:00s 0:02:00 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t4\t11:58:10s 0:01:50 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t5\t11:58:20s 0:01:40 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t6\t11:58:30s 0:01:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t7\t11:58:40s 0:01:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t8\t11:58:50s 0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t9\t11:59:05s 0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t10\t11:59:15s 0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t11\t11:59:30s 0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t12\t11:59:40s 0:00:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t13\t11:59:50s 0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t14\t12:00:05s -0:00:05 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t15\t12:00:15s -0:00:15 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t16\t12:00:30s -0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t17\t12:00:45s -0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t18\t12:00:55s -0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t19\t12:01:10s -0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t20\t12:01:20s -0:01:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t21\t12:01:35s -0:01:35 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t22\t12:01:50s -0:01:50 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t23\t12:02:00s -0:02:00 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t24\t12:02:15s -0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t25\t12:02:25s -0:02:25 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t26\t12:02:40s -0:02:40 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t27\t12:02:50s -0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t28\t12:03:05s -0:03:05 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t29\t12:03:15s -0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t30\t12:03:30s -0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t1\t12:03:40s -0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t2\t12:03:50s -0:03:50 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t3\t12:04:05s -0:04:05 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t4\t12:04:15s -0:04:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t5\t12:04:25s -0:04:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t6\t12:04:35s -0:04:35 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t7\t12:04:45s -0:04:45 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t8\t12:04:55s -0:04:55 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t9\t12:05:05s -0:05:05 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t10\t12:05:15s -0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t11\t12:05:20s -0:05:20 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t12\t12:05:30s -0:05:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t13\t12:05:40s -0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t14\t12:05:45s -0:05:45 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t15\t12:05:50s -0:05:50 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t16\t12:06:00s -0:06:00 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t17\t12:06:05s -0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t18\t12:06:10s -0:06:10 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t19\t12:06:15s -0:06:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t20\t12:06:15s -0:06:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t21\t12:06:20s -0:06:20 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t22\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t23\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t24\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t25\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t26\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t27\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t28\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t29\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t30\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t31\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t1\t12:06:20s -0:06:20 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t2\t12:06:15s -0:06:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t3\t12:06:10s -0:06:10 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t4\t12:06:05s -0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t5\t12:06:00s -0:06:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t6\t12:05:55s -0:05:55 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t7\t12:05:50s -0:05:50 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t8\t12:05:40s -0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t9\t12:05:35s -0:05:35 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t10\t12:05:25s -0:05:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t11\t12:05:15s -0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t12\t12:05:05s -0:05:05 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t13\t12:04:55s -0:04:55 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t14\t12:04:45s -0:04:45 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t15\t12:04:35s -0:04:35 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t16\t12:04:25s -0:04:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t17\t12:04:10s -0:04:10 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t18\t12:04:00s -0:04:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t19\t12:03:45s -0:03:45 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t20\t12:03:30s -0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t21\t12:03:15s -0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t22\t12:03:00s -0:03:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t23\t12:02:45s -0:02:45 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t24\t12:02:30s -0:02:30 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t25\t12:02:15s -0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t26\t12:02:00s -0:02:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t27\t12:01:40s -0:01:40 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t28\t12:01:25s -0:01:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t29\t12:01:05s -0:01:05 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t30\t12:00:50s -0:00:50 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t31\t12:00:30s -0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t1\t12:00:10s -0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t2\t11:59:50s 0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t3\t11:59:35s 0:00:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t4\t11:59:15s 0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t5\t11:58:55s 0:01:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t6\t11:58:35s 0:01:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t7\t11:58:15s 0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t8\t11:57:55s 0:02:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t9\t11:57:30s 0:02:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t10\t11:57:10s 0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t11\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t12\t11:56:30s 0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t13\t11:56:10s 0:03:50 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t14\t11:55:45s 0:04:15 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t15\t11:55:25s 0:04:35 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t16\t11:55:05s 0:04:55 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t17\t11:54:45s 0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t18\t11:54:20s 0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t19\t11:54:00s 0:06:00 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t20\t11:53:40s 0:06:20 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t21\t11:53:15s 0:06:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t22\t11:52:55s 0:07:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t23\t11:52:35s 0:07:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t24\t11:52:15s 0:07:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t25\t11:51:55s 0:08:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t26\t11:51:35s 0:08:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t27\t11:51:10s 0:08:50 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t28\t11:50:50s 0:09:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t29\t11:50:30s 0:09:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t30\t11:50:10s 0:09:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t1\t11:49:50s 0:10:10 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t2\t11:49:35s 0:10:25 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t3\t11:49:15s 0:10:45 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t4\t11:48:55s 0:11:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t5\t11:48:35s 0:11:25 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t6\t11:48:20s 0:11:40 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t7\t11:48:00s 0:12:00 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t8\t11:47:45s 0:12:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t9\t11:47:25s 0:12:35 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t10\t11:47:10s 0:12:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t11\t11:46:55s 0:13:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t12\t11:46:40s 0:13:20 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t13\t11:46:25s 0:13:35 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t14\t11:46:10s 0:13:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t15\t11:45:55s 0:14:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t16\t11:45:45s 0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t17\t11:45:30s 0:14:30 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t18\t11:45:20s 0:14:40 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t19\t11:45:05s 0:14:55 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t20\t11:44:55s 0:15:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t21\t11:44:45s 0:15:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t22\t11:44:35s 0:15:25 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t23\t11:44:25s 0:15:35 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t24\t11:44:20s 0:15:40 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t25\t11:44:10s 0:15:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t26\t11:44:05s 0:15:55 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t27\t11:43:55s 0:16:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t28\t11:43:50s 0:16:10 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t29\t11:43:45s 0:16:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t30\t11:43:45s 0:16:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t31\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t1\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t2\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t3\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t4\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t5\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t6\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t7\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t8\t11:43:45s 0:16:15 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t9\t11:43:50s 0:16:10 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t10\t11:43:55s 0:16:05 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t11\t11:44:00s 0:16:00 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t12\t11:44:05s 0:15:55 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t13\t11:44:15s 0:15:45 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t14\t11:44:20s 0:15:40 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t15\t11:44:30s 0:15:30 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t16\t11:44:40s 0:15:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t17\t11:44:50s 0:15:10 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t18\t11:45:05s 0:14:55 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t19\t11:45:15s 0:14:45 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t20\t11:45:30s 0:14:30 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t21\t11:45:45s 0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t22\t11:46:00s 0:14:00 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t23\t11:46:15s 0:13:45 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t24\t11:46:30s 0:13:30 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t25\t11:46:50s 0:13:10 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t26\t11:47:10s 0:12:50 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t27\t11:47:25s 0:12:35 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t28\t11:47:45s 0:12:15 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t29\t11:48:05s 0:11:55 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t30\t11:48:30s 0:11:30 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t1\t11:48:50s 0:11:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t2\t11:49:10s 0:10:50 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t3\t11:49:35s 0:10:25 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t4\t11:50:00s 0:10:00 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t5\t11:50:25s 0:09:35 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t6\t11:50:50s 0:09:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t7\t11:51:15s 0:08:45 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t8\t11:51:40s 0:08:20 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t9\t11:52:05s 0:07:55 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t10\t11:52:30s 0:07:30 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t11\t11:53:00s 0:07:00 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t12\t11:53:25s 0:06:35 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t13\t11:53:55s 0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t14\t11:54:25s 0:05:35 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t15\t11:54:50s 0:05:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t16\t11:55:20s 0:04:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t17\t11:55:50s 0:04:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t18\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t19\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t20\t11:57:20s 0:02:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t21\t11:57:50s 0:02:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t22\t11:58:20s 0:01:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t23\t11:58:50s 0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t24\t11:59:20s 0:00:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t25\t11:59:50s 0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t26\t12:00:20s -0:00:20 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t27\t12:00:45s -0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t28\t12:01:15s -0:01:15 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t29\t12:01:45s -0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t30\t12:02:15s -0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t31\t12:02:45s -0:02:45 -\n-\n-# Riyadh is at about 46 degrees 46 minutes East:  3 hrs, 7 mins, 4 secs\n-# Before and after 1987, we'll operate on local mean solar time.\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Riyadh87\t3:07:04\t-\t\tzzz\t1987\n-\t\t\t3:07:04\tsol87\t\tzzz\t1988\n-\t\t\t3:07:04\t-\t\tzzz\n-# For backward compatibility...\n-Link\tAsia\/Riyadh87\tMideast\/Riyadh87\n","filename":"src\/java.base\/share\/data\/tzdata\/solar87","additions":0,"deletions":413,"binary":false,"changes":413,"status":"deleted"},{"patch":"@@ -1,413 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# <pre>\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-\n-# Apparent noon times below are for Riyadh; they're a bit off for other places.\n-# Times were computed using formulas in the U.S. Naval Observatory's\n-# Almanac for Computers 1988; the formulas \"will give EqT to an accuracy of\n-# [plus or minus two] seconds during the current year.\"\n-#\n-# Rounding to the nearest five seconds results in fewer than\n-# 256 different \"time types\"--a limit that's faced because time types are\n-# stored on disk as unsigned chars.\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tsol88\t1988\tonly\t-\tJan\t1\t12:03:15s -0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t2\t12:03:40s -0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t3\t12:04:10s -0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t4\t12:04:40s -0:04:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t5\t12:05:05s -0:05:05 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t6\t12:05:30s -0:05:30 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t7\t12:06:00s -0:06:00 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t8\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t9\t12:06:50s -0:06:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t10\t12:07:15s -0:07:15 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t11\t12:07:40s -0:07:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t12\t12:08:05s -0:08:05 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t13\t12:08:25s -0:08:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t14\t12:08:50s -0:08:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t15\t12:09:10s -0:09:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t16\t12:09:30s -0:09:30 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t17\t12:09:50s -0:09:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t18\t12:10:10s -0:10:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t19\t12:10:30s -0:10:30 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t20\t12:10:50s -0:10:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t21\t12:11:05s -0:11:05 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t22\t12:11:25s -0:11:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t23\t12:11:40s -0:11:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t24\t12:11:55s -0:11:55 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t25\t12:12:10s -0:12:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t26\t12:12:25s -0:12:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t27\t12:12:40s -0:12:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t28\t12:12:50s -0:12:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t29\t12:13:00s -0:13:00 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t30\t12:13:10s -0:13:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t31\t12:13:20s -0:13:20 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t1\t12:13:30s -0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t2\t12:13:40s -0:13:40 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t3\t12:13:45s -0:13:45 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t4\t12:13:55s -0:13:55 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t5\t12:14:00s -0:14:00 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t6\t12:14:05s -0:14:05 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t7\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t8\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t9\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t10\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t11\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t12\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t13\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t14\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t15\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t16\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t17\t12:14:05s -0:14:05 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t18\t12:14:00s -0:14:00 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t19\t12:13:55s -0:13:55 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t20\t12:13:50s -0:13:50 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t21\t12:13:45s -0:13:45 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t22\t12:13:40s -0:13:40 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t23\t12:13:30s -0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t24\t12:13:20s -0:13:20 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t25\t12:13:15s -0:13:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t26\t12:13:05s -0:13:05 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t27\t12:12:55s -0:12:55 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t28\t12:12:45s -0:12:45 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t29\t12:12:30s -0:12:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t1\t12:12:20s -0:12:20 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t2\t12:12:10s -0:12:10 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t3\t12:11:55s -0:11:55 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t4\t12:11:45s -0:11:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t5\t12:11:30s -0:11:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t6\t12:11:15s -0:11:15 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t7\t12:11:00s -0:11:00 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t8\t12:10:45s -0:10:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t9\t12:10:30s -0:10:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t10\t12:10:15s -0:10:15 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t11\t12:10:00s -0:10:00 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t12\t12:09:45s -0:09:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t13\t12:09:30s -0:09:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t14\t12:09:10s -0:09:10 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t15\t12:08:55s -0:08:55 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t16\t12:08:40s -0:08:40 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t17\t12:08:20s -0:08:20 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t18\t12:08:05s -0:08:05 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t19\t12:07:45s -0:07:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t20\t12:07:30s -0:07:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t21\t12:07:10s -0:07:10 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t22\t12:06:50s -0:06:50 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t23\t12:06:35s -0:06:35 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t24\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t25\t12:06:00s -0:06:00 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t26\t12:05:40s -0:05:40 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t27\t12:05:20s -0:05:20 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t28\t12:05:05s -0:05:05 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t29\t12:04:45s -0:04:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t30\t12:04:25s -0:04:25 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t31\t12:04:10s -0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t1\t12:03:50s -0:03:50 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t2\t12:03:35s -0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t3\t12:03:15s -0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t4\t12:03:00s -0:03:00 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t5\t12:02:40s -0:02:40 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t6\t12:02:25s -0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t7\t12:02:05s -0:02:05 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t8\t12:01:50s -0:01:50 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t9\t12:01:35s -0:01:35 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t10\t12:01:15s -0:01:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t11\t12:01:00s -0:01:00 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t12\t12:00:45s -0:00:45 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t13\t12:00:30s -0:00:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t14\t12:00:15s -0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t15\t12:00:00s 0:00:00 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t16\t11:59:45s 0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t17\t11:59:30s 0:00:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t18\t11:59:20s 0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t19\t11:59:05s 0:00:55 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t20\t11:58:55s 0:01:05 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t21\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t22\t11:58:30s 0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t23\t11:58:15s 0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t24\t11:58:05s 0:01:55 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t25\t11:57:55s 0:02:05 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t26\t11:57:45s 0:02:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t27\t11:57:35s 0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t28\t11:57:30s 0:02:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t29\t11:57:20s 0:02:40 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t30\t11:57:10s 0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t1\t11:57:05s 0:02:55 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t2\t11:56:55s 0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t3\t11:56:50s 0:03:10 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t4\t11:56:45s 0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t5\t11:56:40s 0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t6\t11:56:35s 0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t7\t11:56:30s 0:03:30 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t8\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t9\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t10\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t11\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t12\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t13\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t14\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t15\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t16\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t17\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t18\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t19\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t20\t11:56:30s 0:03:30 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t21\t11:56:35s 0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t22\t11:56:40s 0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t23\t11:56:45s 0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t24\t11:56:50s 0:03:10 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t25\t11:56:55s 0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t26\t11:57:00s 0:03:00 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t27\t11:57:05s 0:02:55 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t28\t11:57:15s 0:02:45 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t29\t11:57:20s 0:02:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t30\t11:57:30s 0:02:30 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t31\t11:57:40s 0:02:20 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t1\t11:57:50s 0:02:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t2\t11:57:55s 0:02:05 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t3\t11:58:05s 0:01:55 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t4\t11:58:15s 0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t5\t11:58:30s 0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t6\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t7\t11:58:50s 0:01:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t8\t11:59:00s 0:01:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t9\t11:59:15s 0:00:45 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t10\t11:59:25s 0:00:35 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t11\t11:59:35s 0:00:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t12\t11:59:50s 0:00:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t13\t12:00:00s 0:00:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t14\t12:00:15s -0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t15\t12:00:25s -0:00:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t16\t12:00:40s -0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t17\t12:00:55s -0:00:55 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t18\t12:01:05s -0:01:05 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t19\t12:01:20s -0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t20\t12:01:30s -0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t21\t12:01:45s -0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t22\t12:02:00s -0:02:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t23\t12:02:10s -0:02:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t24\t12:02:25s -0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t25\t12:02:35s -0:02:35 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t26\t12:02:50s -0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t27\t12:03:00s -0:03:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t28\t12:03:15s -0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t29\t12:03:25s -0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t30\t12:03:40s -0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t1\t12:03:50s -0:03:50 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t2\t12:04:00s -0:04:00 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t3\t12:04:10s -0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t4\t12:04:25s -0:04:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t5\t12:04:35s -0:04:35 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t6\t12:04:45s -0:04:45 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t7\t12:04:55s -0:04:55 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t8\t12:05:05s -0:05:05 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t9\t12:05:10s -0:05:10 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t10\t12:05:20s -0:05:20 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t11\t12:05:30s -0:05:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t12\t12:05:35s -0:05:35 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t13\t12:05:45s -0:05:45 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t14\t12:05:50s -0:05:50 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t15\t12:05:55s -0:05:55 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t16\t12:06:00s -0:06:00 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t17\t12:06:05s -0:06:05 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t18\t12:06:10s -0:06:10 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t19\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t20\t12:06:20s -0:06:20 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t21\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t22\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t23\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t24\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t25\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t26\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t27\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t28\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t29\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t30\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t31\t12:06:20s -0:06:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t1\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t2\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t3\t12:06:10s -0:06:10 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t4\t12:06:05s -0:06:05 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t5\t12:05:55s -0:05:55 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t6\t12:05:50s -0:05:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t7\t12:05:45s -0:05:45 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t8\t12:05:35s -0:05:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t9\t12:05:25s -0:05:25 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t10\t12:05:20s -0:05:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t11\t12:05:10s -0:05:10 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t12\t12:05:00s -0:05:00 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t13\t12:04:50s -0:04:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t14\t12:04:35s -0:04:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t15\t12:04:25s -0:04:25 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t16\t12:04:15s -0:04:15 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t17\t12:04:00s -0:04:00 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t18\t12:03:50s -0:03:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t19\t12:03:35s -0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t20\t12:03:20s -0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t21\t12:03:05s -0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t22\t12:02:50s -0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t23\t12:02:35s -0:02:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t24\t12:02:20s -0:02:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t25\t12:02:00s -0:02:00 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t26\t12:01:45s -0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t27\t12:01:30s -0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t28\t12:01:10s -0:01:10 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t29\t12:00:50s -0:00:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t30\t12:00:35s -0:00:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t31\t12:00:15s -0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t1\t11:59:55s 0:00:05 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t2\t11:59:35s 0:00:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t3\t11:59:20s 0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t4\t11:59:00s 0:01:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t5\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t6\t11:58:20s 0:01:40 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t7\t11:58:00s 0:02:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t8\t11:57:35s 0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t9\t11:57:15s 0:02:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t10\t11:56:55s 0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t11\t11:56:35s 0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t12\t11:56:15s 0:03:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t13\t11:55:50s 0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t14\t11:55:30s 0:04:30 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t15\t11:55:10s 0:04:50 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t16\t11:54:50s 0:05:10 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t17\t11:54:25s 0:05:35 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t18\t11:54:05s 0:05:55 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t19\t11:53:45s 0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t20\t11:53:25s 0:06:35 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t21\t11:53:00s 0:07:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t22\t11:52:40s 0:07:20 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t23\t11:52:20s 0:07:40 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t24\t11:52:00s 0:08:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t25\t11:51:40s 0:08:20 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t26\t11:51:15s 0:08:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t27\t11:50:55s 0:09:05 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t28\t11:50:35s 0:09:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t29\t11:50:15s 0:09:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t30\t11:49:55s 0:10:05 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t1\t11:49:35s 0:10:25 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t2\t11:49:20s 0:10:40 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t3\t11:49:00s 0:11:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t4\t11:48:40s 0:11:20 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t5\t11:48:25s 0:11:35 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t6\t11:48:05s 0:11:55 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t7\t11:47:50s 0:12:10 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t8\t11:47:30s 0:12:30 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t9\t11:47:15s 0:12:45 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t10\t11:47:00s 0:13:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t11\t11:46:45s 0:13:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t12\t11:46:30s 0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t13\t11:46:15s 0:13:45 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t14\t11:46:00s 0:14:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t15\t11:45:45s 0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t16\t11:45:35s 0:14:25 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t17\t11:45:20s 0:14:40 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t18\t11:45:10s 0:14:50 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t19\t11:45:00s 0:15:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t20\t11:44:45s 0:15:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t21\t11:44:40s 0:15:20 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t22\t11:44:30s 0:15:30 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t23\t11:44:20s 0:15:40 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t24\t11:44:10s 0:15:50 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t25\t11:44:05s 0:15:55 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t26\t11:44:00s 0:16:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t27\t11:43:55s 0:16:05 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t28\t11:43:50s 0:16:10 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t29\t11:43:45s 0:16:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t30\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t31\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t1\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t2\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t3\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t4\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t5\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t6\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t7\t11:43:45s 0:16:15 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t8\t11:43:45s 0:16:15 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t9\t11:43:50s 0:16:10 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t10\t11:44:00s 0:16:00 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t11\t11:44:05s 0:15:55 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t12\t11:44:10s 0:15:50 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t13\t11:44:20s 0:15:40 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t14\t11:44:30s 0:15:30 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t15\t11:44:40s 0:15:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t16\t11:44:50s 0:15:10 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t17\t11:45:00s 0:15:00 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t18\t11:45:15s 0:14:45 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t19\t11:45:25s 0:14:35 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t20\t11:45:40s 0:14:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t21\t11:45:55s 0:14:05 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t22\t11:46:10s 0:13:50 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t23\t11:46:30s 0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t24\t11:46:45s 0:13:15 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t25\t11:47:05s 0:12:55 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t26\t11:47:20s 0:12:40 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t27\t11:47:40s 0:12:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t28\t11:48:00s 0:12:00 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t29\t11:48:25s 0:11:35 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t30\t11:48:45s 0:11:15 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t1\t11:49:05s 0:10:55 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t2\t11:49:30s 0:10:30 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t3\t11:49:55s 0:10:05 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t4\t11:50:15s 0:09:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t5\t11:50:40s 0:09:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t6\t11:51:05s 0:08:55 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t7\t11:51:35s 0:08:25 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t8\t11:52:00s 0:08:00 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t9\t11:52:25s 0:07:35 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t10\t11:52:55s 0:07:05 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t11\t11:53:20s 0:06:40 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t12\t11:53:50s 0:06:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t13\t11:54:15s 0:05:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t14\t11:54:45s 0:05:15 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t15\t11:55:15s 0:04:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t16\t11:55:45s 0:04:15 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t17\t11:56:15s 0:03:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t18\t11:56:40s 0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t19\t11:57:10s 0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t20\t11:57:40s 0:02:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t21\t11:58:10s 0:01:50 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t22\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t23\t11:59:10s 0:00:50 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t24\t11:59:40s 0:00:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t25\t12:00:10s -0:00:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t26\t12:00:40s -0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t27\t12:01:10s -0:01:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t28\t12:01:40s -0:01:40 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t29\t12:02:10s -0:02:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t30\t12:02:35s -0:02:35 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t31\t12:03:05s -0:03:05 -\n-\n-# Riyadh is at about 46 degrees 46 minutes East:  3 hrs, 7 mins, 4 secs\n-# Before and after 1988, we'll operate on local mean solar time.\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Riyadh88\t3:07:04\t-\t\tzzz\t1988\n-\t\t\t3:07:04\tsol88\t\tzzz\t1989\n-\t\t\t3:07:04\t-\t\tzzz\n-# For backward compatibility...\n-Link\tAsia\/Riyadh88\tMideast\/Riyadh88\n","filename":"src\/java.base\/share\/data\/tzdata\/solar88","additions":0,"deletions":413,"binary":false,"changes":413,"status":"deleted"},{"patch":"@@ -1,418 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# <pre>\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-\n-# Apparent noon times below are for Riyadh; they're a bit off for other places.\n-# Times were computed using a formula provided by the U. S. Naval Observatory:\n-#\teqt = -105.8 * sin(l) + 596.2 * sin(2 * l) + 4.4 * sin(3 * l)\n-#\t\t-12.7 * sin(4 * l) - 429.0 * cos(l) - 2.1 * cos (2 * l)\n-#\t\t+ 19.3 * cos(3 * l);\n-# where l is the \"mean longitude of the Sun\" given by\n-#\tl = 279.642 degrees + 0.985647 * d\n-# and d is the interval in days from January 0, 0 hours Universal Time\n-# (equaling the day of the year plus the fraction of a day from zero hours).\n-# The accuracy of the formula is plus or minus three seconds.\n-#\n-# Rounding to the nearest five seconds results in fewer than\n-# 256 different \"time types\"--a limit that's faced because time types are\n-# stored on disk as unsigned chars.\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tsol89\t1989\tonly\t-\tJan\t1\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t2\t12:04:05s -0:04:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t3\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t4\t12:05:00s -0:05:00 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t5\t12:05:25s -0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t6\t12:05:50s -0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t7\t12:06:15s -0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t8\t12:06:45s -0:06:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t9\t12:07:10s -0:07:10 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t10\t12:07:35s -0:07:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t11\t12:07:55s -0:07:55 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t12\t12:08:20s -0:08:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t13\t12:08:45s -0:08:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t14\t12:09:05s -0:09:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t15\t12:09:25s -0:09:25 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t16\t12:09:45s -0:09:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t17\t12:10:05s -0:10:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t18\t12:10:25s -0:10:25 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t19\t12:10:45s -0:10:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t20\t12:11:05s -0:11:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t21\t12:11:20s -0:11:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t22\t12:11:35s -0:11:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t23\t12:11:55s -0:11:55 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t24\t12:12:10s -0:12:10 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t25\t12:12:20s -0:12:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t26\t12:12:35s -0:12:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t27\t12:12:50s -0:12:50 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t28\t12:13:00s -0:13:00 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t29\t12:13:10s -0:13:10 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t30\t12:13:20s -0:13:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t31\t12:13:30s -0:13:30 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t1\t12:13:40s -0:13:40 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t2\t12:13:45s -0:13:45 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t3\t12:13:55s -0:13:55 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t4\t12:14:00s -0:14:00 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t5\t12:14:05s -0:14:05 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t6\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t7\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t8\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t9\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t10\t12:14:20s -0:14:20 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t11\t12:14:20s -0:14:20 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t12\t12:14:20s -0:14:20 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t13\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t14\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t15\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t16\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t17\t12:14:05s -0:14:05 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t18\t12:14:00s -0:14:00 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t19\t12:13:55s -0:13:55 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t20\t12:13:50s -0:13:50 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t21\t12:13:40s -0:13:40 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t22\t12:13:35s -0:13:35 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t23\t12:13:25s -0:13:25 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t24\t12:13:15s -0:13:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t25\t12:13:05s -0:13:05 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t26\t12:12:55s -0:12:55 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t27\t12:12:45s -0:12:45 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t28\t12:12:35s -0:12:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t1\t12:12:25s -0:12:25 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t2\t12:12:10s -0:12:10 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t3\t12:12:00s -0:12:00 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t4\t12:11:45s -0:11:45 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t5\t12:11:35s -0:11:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t6\t12:11:20s -0:11:20 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t7\t12:11:05s -0:11:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t8\t12:10:50s -0:10:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t9\t12:10:35s -0:10:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t10\t12:10:20s -0:10:20 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t11\t12:10:05s -0:10:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t12\t12:09:50s -0:09:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t13\t12:09:30s -0:09:30 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t14\t12:09:15s -0:09:15 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t15\t12:09:00s -0:09:00 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t16\t12:08:40s -0:08:40 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t17\t12:08:25s -0:08:25 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t18\t12:08:05s -0:08:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t19\t12:07:50s -0:07:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t20\t12:07:30s -0:07:30 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t21\t12:07:15s -0:07:15 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t22\t12:06:55s -0:06:55 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t23\t12:06:35s -0:06:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t24\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t25\t12:06:00s -0:06:00 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t26\t12:05:40s -0:05:40 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t27\t12:05:25s -0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t28\t12:05:05s -0:05:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t29\t12:04:50s -0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t30\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t31\t12:04:10s -0:04:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t1\t12:03:55s -0:03:55 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t2\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t3\t12:03:20s -0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t4\t12:03:00s -0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t5\t12:02:45s -0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t6\t12:02:25s -0:02:25 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t7\t12:02:10s -0:02:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t8\t12:01:50s -0:01:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t9\t12:01:35s -0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t10\t12:01:20s -0:01:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t11\t12:01:05s -0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t12\t12:00:50s -0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t13\t12:00:35s -0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t14\t12:00:20s -0:00:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t15\t12:00:05s -0:00:05 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t16\t11:59:50s 0:00:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t17\t11:59:35s 0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t18\t11:59:20s 0:00:40 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t19\t11:59:10s 0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t20\t11:58:55s 0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t21\t11:58:45s 0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t22\t11:58:30s 0:01:30 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t23\t11:58:20s 0:01:40 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t24\t11:58:10s 0:01:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t25\t11:58:00s 0:02:00 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t26\t11:57:50s 0:02:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t27\t11:57:40s 0:02:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t28\t11:57:30s 0:02:30 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t29\t11:57:20s 0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t30\t11:57:15s 0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t1\t11:57:05s 0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t2\t11:57:00s 0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t3\t11:56:50s 0:03:10 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t4\t11:56:45s 0:03:15 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t5\t11:56:40s 0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t6\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t7\t11:56:30s 0:03:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t8\t11:56:30s 0:03:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t9\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t10\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t11\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t12\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t13\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t14\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t15\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t16\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t17\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t18\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t19\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t20\t11:56:30s 0:03:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t21\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t22\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t23\t11:56:40s 0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t24\t11:56:45s 0:03:15 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t25\t11:56:55s 0:03:05 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t26\t11:57:00s 0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t27\t11:57:05s 0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t28\t11:57:15s 0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t29\t11:57:20s 0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t30\t11:57:30s 0:02:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t31\t11:57:35s 0:02:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t1\t11:57:45s 0:02:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t2\t11:57:55s 0:02:05 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t3\t11:58:05s 0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t4\t11:58:15s 0:01:45 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t5\t11:58:25s 0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t6\t11:58:35s 0:01:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t7\t11:58:45s 0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t8\t11:59:00s 0:01:00 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t9\t11:59:10s 0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t10\t11:59:20s 0:00:40 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t11\t11:59:35s 0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t12\t11:59:45s 0:00:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t13\t12:00:00s 0:00:00 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t14\t12:00:10s -0:00:10 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t15\t12:00:25s -0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t16\t12:00:35s -0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t17\t12:00:50s -0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t18\t12:01:05s -0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t19\t12:01:15s -0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t20\t12:01:30s -0:01:30 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t21\t12:01:40s -0:01:40 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t22\t12:01:55s -0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t23\t12:02:10s -0:02:10 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t24\t12:02:20s -0:02:20 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t25\t12:02:35s -0:02:35 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t26\t12:02:45s -0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t27\t12:03:00s -0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t28\t12:03:10s -0:03:10 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t29\t12:03:25s -0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t30\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t1\t12:03:45s -0:03:45 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t2\t12:04:00s -0:04:00 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t3\t12:04:10s -0:04:10 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t4\t12:04:20s -0:04:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t5\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t6\t12:04:40s -0:04:40 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t7\t12:04:50s -0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t8\t12:05:00s -0:05:00 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t9\t12:05:10s -0:05:10 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t10\t12:05:20s -0:05:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t11\t12:05:25s -0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t12\t12:05:35s -0:05:35 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t13\t12:05:40s -0:05:40 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t14\t12:05:50s -0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t15\t12:05:55s -0:05:55 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t16\t12:06:00s -0:06:00 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t17\t12:06:05s -0:06:05 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t18\t12:06:10s -0:06:10 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t19\t12:06:15s -0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t20\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t21\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t22\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t23\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t24\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t25\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t26\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t27\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t28\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t29\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t30\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t31\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t1\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t2\t12:06:15s -0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t3\t12:06:10s -0:06:10 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t4\t12:06:05s -0:06:05 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t5\t12:06:00s -0:06:00 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t6\t12:05:50s -0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t7\t12:05:45s -0:05:45 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t8\t12:05:35s -0:05:35 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t9\t12:05:30s -0:05:30 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t10\t12:05:20s -0:05:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t11\t12:05:10s -0:05:10 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t12\t12:05:00s -0:05:00 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t13\t12:04:50s -0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t14\t12:04:40s -0:04:40 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t15\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t16\t12:04:15s -0:04:15 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t17\t12:04:05s -0:04:05 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t18\t12:03:50s -0:03:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t19\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t20\t12:03:25s -0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t21\t12:03:10s -0:03:10 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t22\t12:02:55s -0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t23\t12:02:40s -0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t24\t12:02:20s -0:02:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t25\t12:02:05s -0:02:05 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t26\t12:01:50s -0:01:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t27\t12:01:30s -0:01:30 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t28\t12:01:15s -0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t29\t12:00:55s -0:00:55 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t30\t12:00:40s -0:00:40 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t31\t12:00:20s -0:00:20 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t1\t12:00:00s 0:00:00 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t2\t11:59:45s 0:00:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t3\t11:59:25s 0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t4\t11:59:05s 0:00:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t5\t11:58:45s 0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t6\t11:58:25s 0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t7\t11:58:05s 0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t8\t11:57:45s 0:02:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t9\t11:57:20s 0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t10\t11:57:00s 0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t11\t11:56:40s 0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t12\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t13\t11:56:00s 0:04:00 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t14\t11:55:35s 0:04:25 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t15\t11:55:15s 0:04:45 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t16\t11:54:55s 0:05:05 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t17\t11:54:35s 0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t18\t11:54:10s 0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t19\t11:53:50s 0:06:10 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t20\t11:53:30s 0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t21\t11:53:10s 0:06:50 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t22\t11:52:45s 0:07:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t23\t11:52:25s 0:07:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t24\t11:52:05s 0:07:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t25\t11:51:45s 0:08:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t26\t11:51:25s 0:08:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t27\t11:51:05s 0:08:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t28\t11:50:40s 0:09:20 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t29\t11:50:20s 0:09:40 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t30\t11:50:00s 0:10:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t1\t11:49:45s 0:10:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t2\t11:49:25s 0:10:35 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t3\t11:49:05s 0:10:55 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t4\t11:48:45s 0:11:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t5\t11:48:30s 0:11:30 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t6\t11:48:10s 0:11:50 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t7\t11:47:50s 0:12:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t8\t11:47:35s 0:12:25 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t9\t11:47:20s 0:12:40 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t10\t11:47:00s 0:13:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t11\t11:46:45s 0:13:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t12\t11:46:30s 0:13:30 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t13\t11:46:15s 0:13:45 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t14\t11:46:00s 0:14:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t15\t11:45:50s 0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t16\t11:45:35s 0:14:25 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t17\t11:45:20s 0:14:40 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t18\t11:45:10s 0:14:50 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t19\t11:45:00s 0:15:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t20\t11:44:50s 0:15:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t21\t11:44:40s 0:15:20 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t22\t11:44:30s 0:15:30 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t23\t11:44:20s 0:15:40 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t24\t11:44:10s 0:15:50 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t25\t11:44:05s 0:15:55 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t26\t11:44:00s 0:16:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t27\t11:43:50s 0:16:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t28\t11:43:45s 0:16:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t29\t11:43:40s 0:16:20 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t30\t11:43:40s 0:16:20 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t31\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t1\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t2\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t3\t11:43:30s 0:16:30 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t4\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t5\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t6\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t7\t11:43:40s 0:16:20 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t8\t11:43:45s 0:16:15 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t9\t11:43:50s 0:16:10 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t10\t11:43:55s 0:16:05 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t11\t11:44:00s 0:16:00 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t12\t11:44:05s 0:15:55 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t13\t11:44:15s 0:15:45 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t14\t11:44:25s 0:15:35 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t15\t11:44:35s 0:15:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t16\t11:44:45s 0:15:15 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t17\t11:44:55s 0:15:05 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t18\t11:45:10s 0:14:50 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t19\t11:45:20s 0:14:40 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t20\t11:45:35s 0:14:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t21\t11:45:50s 0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t22\t11:46:05s 0:13:55 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t23\t11:46:25s 0:13:35 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t24\t11:46:40s 0:13:20 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t25\t11:47:00s 0:13:00 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t26\t11:47:20s 0:12:40 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t27\t11:47:35s 0:12:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t28\t11:47:55s 0:12:05 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t29\t11:48:20s 0:11:40 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t30\t11:48:40s 0:11:20 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t1\t11:49:00s 0:11:00 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t2\t11:49:25s 0:10:35 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t3\t11:49:50s 0:10:10 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t4\t11:50:15s 0:09:45 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t5\t11:50:35s 0:09:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t6\t11:51:00s 0:09:00 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t7\t11:51:30s 0:08:30 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t8\t11:51:55s 0:08:05 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t9\t11:52:20s 0:07:40 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t10\t11:52:50s 0:07:10 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t11\t11:53:15s 0:06:45 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t12\t11:53:45s 0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t13\t11:54:10s 0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t14\t11:54:40s 0:05:20 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t15\t11:55:10s 0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t16\t11:55:40s 0:04:20 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t17\t11:56:05s 0:03:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t18\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t19\t11:57:05s 0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t20\t11:57:35s 0:02:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t21\t11:58:05s 0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t22\t11:58:35s 0:01:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t23\t11:59:05s 0:00:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t24\t11:59:35s 0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t25\t12:00:05s -0:00:05 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t26\t12:00:35s -0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t27\t12:01:05s -0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t28\t12:01:35s -0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t29\t12:02:00s -0:02:00 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t30\t12:02:30s -0:02:30 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t31\t12:03:00s -0:03:00 -\n-\n-# Riyadh is at about 46 degrees 46 minutes East:  3 hrs, 7 mins, 4 secs\n-# Before and after 1989, we'll operate on local mean solar time.\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Riyadh89\t3:07:04\t-\t\tzzz\t1989\n-\t\t\t3:07:04\tsol89\t\tzzz\t1990\n-\t\t\t3:07:04\t-\t\tzzz\n-# For backward compatibility...\n-Link\tAsia\/Riyadh89\tMideast\/Riyadh89\n","filename":"src\/java.base\/share\/data\/tzdata\/solar89","additions":0,"deletions":418,"binary":false,"changes":418,"status":"deleted"},{"patch":"@@ -1,470 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# tzdb timezone descriptions (deprecated version)\n-#\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-#\n-# From Paul Eggert (2021-09-20):\n-# This file is intended as a backward-compatibility aid for older programs.\n-# New programs should use zone1970.tab.  This file is like zone1970.tab (see\n-# zone1970.tab's comments), but with the following additional restrictions:\n-#\n-# 1.  This file contains only ASCII characters.\n-# 2.  The first data column contains exactly one country code.\n-#\n-# Because of (2), each row stands for an area that is the intersection\n-# of a region identified by a country code and of a timezone where civil\n-# clocks have agreed since 1970; this is a narrower definition than\n-# that of zone1970.tab.\n-#\n-# Unlike zone1970.tab, a row's third column can be a Link from\n-# 'backward' instead of a Zone.\n-#\n-# This table is intended as an aid for users, to help them select timezones\n-# appropriate for their practical needs.  It is not intended to take or\n-# endorse any position on legal or territorial claims.\n-#\n-#country-\n-#code\tcoordinates\tTZ\t\t\tcomments\n-AD\t+4230+00131\tEurope\/Andorra\n-AE\t+2518+05518\tAsia\/Dubai\n-AF\t+3431+06912\tAsia\/Kabul\n-AG\t+1703-06148\tAmerica\/Antigua\n-AI\t+1812-06304\tAmerica\/Anguilla\n-AL\t+4120+01950\tEurope\/Tirane\n-AM\t+4011+04430\tAsia\/Yerevan\n-AO\t-0848+01314\tAfrica\/Luanda\n-AQ\t-7750+16636\tAntarctica\/McMurdo\tNew Zealand time - McMurdo, South Pole\n-AQ\t-6617+11031\tAntarctica\/Casey\tCasey\n-AQ\t-6835+07758\tAntarctica\/Davis\tDavis\n-AQ\t-6640+14001\tAntarctica\/DumontDUrville\tDumont-d'Urville\n-AQ\t-6736+06253\tAntarctica\/Mawson\tMawson\n-AQ\t-6448-06406\tAntarctica\/Palmer\tPalmer\n-AQ\t-6734-06808\tAntarctica\/Rothera\tRothera\n-AQ\t-690022+0393524\tAntarctica\/Syowa\tSyowa\n-AQ\t-720041+0023206\tAntarctica\/Troll\tTroll\n-AQ\t-7824+10654\tAntarctica\/Vostok\tVostok\n-AR\t-3436-05827\tAmerica\/Argentina\/Buenos_Aires\tBuenos Aires (BA, CF)\n-AR\t-3124-06411\tAmerica\/Argentina\/Cordoba\tArgentina (most areas: CB, CC, CN, ER, FM, MN, SE, SF)\n-AR\t-2447-06525\tAmerica\/Argentina\/Salta\tSalta (SA, LP, NQ, RN)\n-AR\t-2411-06518\tAmerica\/Argentina\/Jujuy\tJujuy (JY)\n-AR\t-2649-06513\tAmerica\/Argentina\/Tucuman\tTucuman (TM)\n-AR\t-2828-06547\tAmerica\/Argentina\/Catamarca\tCatamarca (CT), Chubut (CH)\n-AR\t-2926-06651\tAmerica\/Argentina\/La_Rioja\tLa Rioja (LR)\n-AR\t-3132-06831\tAmerica\/Argentina\/San_Juan\tSan Juan (SJ)\n-AR\t-3253-06849\tAmerica\/Argentina\/Mendoza\tMendoza (MZ)\n-AR\t-3319-06621\tAmerica\/Argentina\/San_Luis\tSan Luis (SL)\n-AR\t-5138-06913\tAmerica\/Argentina\/Rio_Gallegos\tSanta Cruz (SC)\n-AR\t-5448-06818\tAmerica\/Argentina\/Ushuaia\tTierra del Fuego (TF)\n-AS\t-1416-17042\tPacific\/Pago_Pago\n-AT\t+4813+01620\tEurope\/Vienna\n-AU\t-3133+15905\tAustralia\/Lord_Howe\tLord Howe Island\n-AU\t-5430+15857\tAntarctica\/Macquarie\tMacquarie Island\n-AU\t-4253+14719\tAustralia\/Hobart\tTasmania\n-AU\t-3749+14458\tAustralia\/Melbourne\tVictoria\n-AU\t-3352+15113\tAustralia\/Sydney\tNew South Wales (most areas)\n-AU\t-3157+14127\tAustralia\/Broken_Hill\tNew South Wales (Yancowinna)\n-AU\t-2728+15302\tAustralia\/Brisbane\tQueensland (most areas)\n-AU\t-2016+14900\tAustralia\/Lindeman\tQueensland (Whitsunday Islands)\n-AU\t-3455+13835\tAustralia\/Adelaide\tSouth Australia\n-AU\t-1228+13050\tAustralia\/Darwin\tNorthern Territory\n-AU\t-3157+11551\tAustralia\/Perth\tWestern Australia (most areas)\n-AU\t-3143+12852\tAustralia\/Eucla\tWestern Australia (Eucla)\n-AW\t+1230-06958\tAmerica\/Aruba\n-AX\t+6006+01957\tEurope\/Mariehamn\n-AZ\t+4023+04951\tAsia\/Baku\n-BA\t+4352+01825\tEurope\/Sarajevo\n-BB\t+1306-05937\tAmerica\/Barbados\n-BD\t+2343+09025\tAsia\/Dhaka\n-BE\t+5050+00420\tEurope\/Brussels\n-BF\t+1222-00131\tAfrica\/Ouagadougou\n-BG\t+4241+02319\tEurope\/Sofia\n-BH\t+2623+05035\tAsia\/Bahrain\n-BI\t-0323+02922\tAfrica\/Bujumbura\n-BJ\t+0629+00237\tAfrica\/Porto-Novo\n-BL\t+1753-06251\tAmerica\/St_Barthelemy\n-BM\t+3217-06446\tAtlantic\/Bermuda\n-BN\t+0456+11455\tAsia\/Brunei\n-BO\t-1630-06809\tAmerica\/La_Paz\n-BQ\t+120903-0681636\tAmerica\/Kralendijk\n-BR\t-0351-03225\tAmerica\/Noronha\tAtlantic islands\n-BR\t-0127-04829\tAmerica\/Belem\tPara (east), Amapa\n-BR\t-0343-03830\tAmerica\/Fortaleza\tBrazil (northeast: MA, PI, CE, RN, PB)\n-BR\t-0803-03454\tAmerica\/Recife\tPernambuco\n-BR\t-0712-04812\tAmerica\/Araguaina\tTocantins\n-BR\t-0940-03543\tAmerica\/Maceio\tAlagoas, Sergipe\n-BR\t-1259-03831\tAmerica\/Bahia\tBahia\n-BR\t-2332-04637\tAmerica\/Sao_Paulo\tBrazil (southeast: GO, DF, MG, ES, RJ, SP, PR, SC, RS)\n-BR\t-2027-05437\tAmerica\/Campo_Grande\tMato Grosso do Sul\n-BR\t-1535-05605\tAmerica\/Cuiaba\tMato Grosso\n-BR\t-0226-05452\tAmerica\/Santarem\tPara (west)\n-BR\t-0846-06354\tAmerica\/Porto_Velho\tRondonia\n-BR\t+0249-06040\tAmerica\/Boa_Vista\tRoraima\n-BR\t-0308-06001\tAmerica\/Manaus\tAmazonas (east)\n-BR\t-0640-06952\tAmerica\/Eirunepe\tAmazonas (west)\n-BR\t-0958-06748\tAmerica\/Rio_Branco\tAcre\n-BS\t+2505-07721\tAmerica\/Nassau\n-BT\t+2728+08939\tAsia\/Thimphu\n-BW\t-2439+02555\tAfrica\/Gaborone\n-BY\t+5354+02734\tEurope\/Minsk\n-BZ\t+1730-08812\tAmerica\/Belize\n-CA\t+4734-05243\tAmerica\/St_Johns\tNewfoundland, Labrador (SE)\n-CA\t+4439-06336\tAmerica\/Halifax\tAtlantic - NS (most areas), PE\n-CA\t+4612-05957\tAmerica\/Glace_Bay\tAtlantic - NS (Cape Breton)\n-CA\t+4606-06447\tAmerica\/Moncton\tAtlantic - New Brunswick\n-CA\t+5320-06025\tAmerica\/Goose_Bay\tAtlantic - Labrador (most areas)\n-CA\t+5125-05707\tAmerica\/Blanc-Sablon\tAST - QC (Lower North Shore)\n-CA\t+4339-07923\tAmerica\/Toronto\tEastern - ON & QC (most areas)\n-CA\t+6344-06828\tAmerica\/Iqaluit\tEastern - NU (most areas)\n-CA\t+484531-0913718\tAmerica\/Atikokan\tEST - ON (Atikokan), NU (Coral H)\n-CA\t+4953-09709\tAmerica\/Winnipeg\tCentral - ON (west), Manitoba\n-CA\t+744144-0944945\tAmerica\/Resolute\tCentral - NU (Resolute)\n-CA\t+624900-0920459\tAmerica\/Rankin_Inlet\tCentral - NU (central)\n-CA\t+5024-10439\tAmerica\/Regina\tCST - SK (most areas)\n-CA\t+5017-10750\tAmerica\/Swift_Current\tCST - SK (midwest)\n-CA\t+5333-11328\tAmerica\/Edmonton\tMountain - AB, BC(E), NT(E), SK(W)\n-CA\t+690650-1050310\tAmerica\/Cambridge_Bay\tMountain - NU (west)\n-CA\t+682059-1334300\tAmerica\/Inuvik\tMountain - NT (west)\n-CA\t+4906-11631\tAmerica\/Creston\tMST - BC (Creston)\n-CA\t+5546-12014\tAmerica\/Dawson_Creek\tMST - BC (Dawson Cr, Ft St John)\n-CA\t+5848-12242\tAmerica\/Fort_Nelson\tMST - BC (Ft Nelson)\n-CA\t+6043-13503\tAmerica\/Whitehorse\tMST - Yukon (east)\n-CA\t+6404-13925\tAmerica\/Dawson\tMST - Yukon (west)\n-CA\t+4916-12307\tAmerica\/Vancouver\tPacific - BC (most areas)\n-CC\t-1210+09655\tIndian\/Cocos\n-CD\t-0418+01518\tAfrica\/Kinshasa\tDem. Rep. of Congo (west)\n-CD\t-1140+02728\tAfrica\/Lubumbashi\tDem. Rep. of Congo (east)\n-CF\t+0422+01835\tAfrica\/Bangui\n-CG\t-0416+01517\tAfrica\/Brazzaville\n-CH\t+4723+00832\tEurope\/Zurich\n-CI\t+0519-00402\tAfrica\/Abidjan\n-CK\t-2114-15946\tPacific\/Rarotonga\n-CL\t-3327-07040\tAmerica\/Santiago\tmost of Chile\n-CL\t-5309-07055\tAmerica\/Punta_Arenas\tRegion of Magallanes\n-CL\t-2709-10926\tPacific\/Easter\tEaster Island\n-CM\t+0403+00942\tAfrica\/Douala\n-CN\t+3114+12128\tAsia\/Shanghai\tBeijing Time\n-CN\t+4348+08735\tAsia\/Urumqi\tXinjiang Time\n-CO\t+0436-07405\tAmerica\/Bogota\n-CR\t+0956-08405\tAmerica\/Costa_Rica\n-CU\t+2308-08222\tAmerica\/Havana\n-CV\t+1455-02331\tAtlantic\/Cape_Verde\n-CW\t+1211-06900\tAmerica\/Curacao\n-CX\t-1025+10543\tIndian\/Christmas\n-CY\t+3510+03322\tAsia\/Nicosia\tmost of Cyprus\n-CY\t+3507+03357\tAsia\/Famagusta\tNorthern Cyprus\n-CZ\t+5005+01426\tEurope\/Prague\n-DE\t+5230+01322\tEurope\/Berlin\tmost of Germany\n-DE\t+4742+00841\tEurope\/Busingen\tBusingen\n-DJ\t+1136+04309\tAfrica\/Djibouti\n-DK\t+5540+01235\tEurope\/Copenhagen\n-DM\t+1518-06124\tAmerica\/Dominica\n-DO\t+1828-06954\tAmerica\/Santo_Domingo\n-DZ\t+3647+00303\tAfrica\/Algiers\n-EC\t-0210-07950\tAmerica\/Guayaquil\tEcuador (mainland)\n-EC\t-0054-08936\tPacific\/Galapagos\tGalapagos Islands\n-EE\t+5925+02445\tEurope\/Tallinn\n-EG\t+3003+03115\tAfrica\/Cairo\n-EH\t+2709-01312\tAfrica\/El_Aaiun\n-ER\t+1520+03853\tAfrica\/Asmara\n-ES\t+4024-00341\tEurope\/Madrid\tSpain (mainland)\n-ES\t+3553-00519\tAfrica\/Ceuta\tCeuta, Melilla\n-ES\t+2806-01524\tAtlantic\/Canary\tCanary Islands\n-ET\t+0902+03842\tAfrica\/Addis_Ababa\n-FI\t+6010+02458\tEurope\/Helsinki\n-FJ\t-1808+17825\tPacific\/Fiji\n-FK\t-5142-05751\tAtlantic\/Stanley\n-FM\t+0725+15147\tPacific\/Chuuk\tChuuk\/Truk, Yap\n-FM\t+0658+15813\tPacific\/Pohnpei\tPohnpei\/Ponape\n-FM\t+0519+16259\tPacific\/Kosrae\tKosrae\n-FO\t+6201-00646\tAtlantic\/Faroe\n-FR\t+4852+00220\tEurope\/Paris\n-GA\t+0023+00927\tAfrica\/Libreville\n-GB\t+513030-0000731\tEurope\/London\n-GD\t+1203-06145\tAmerica\/Grenada\n-GE\t+4143+04449\tAsia\/Tbilisi\n-GF\t+0456-05220\tAmerica\/Cayenne\n-GG\t+492717-0023210\tEurope\/Guernsey\n-GH\t+0533-00013\tAfrica\/Accra\n-GI\t+3608-00521\tEurope\/Gibraltar\n-GL\t+6411-05144\tAmerica\/Nuuk\tmost of Greenland\n-GL\t+7646-01840\tAmerica\/Danmarkshavn\tNational Park (east coast)\n-GL\t+7029-02158\tAmerica\/Scoresbysund\tScoresbysund\/Ittoqqortoormiit\n-GL\t+7634-06847\tAmerica\/Thule\tThule\/Pituffik\n-GM\t+1328-01639\tAfrica\/Banjul\n-GN\t+0931-01343\tAfrica\/Conakry\n-GP\t+1614-06132\tAmerica\/Guadeloupe\n-GQ\t+0345+00847\tAfrica\/Malabo\n-GR\t+3758+02343\tEurope\/Athens\n-GS\t-5416-03632\tAtlantic\/South_Georgia\n-GT\t+1438-09031\tAmerica\/Guatemala\n-GU\t+1328+14445\tPacific\/Guam\n-GW\t+1151-01535\tAfrica\/Bissau\n-GY\t+0648-05810\tAmerica\/Guyana\n-HK\t+2217+11409\tAsia\/Hong_Kong\n-HN\t+1406-08713\tAmerica\/Tegucigalpa\n-HR\t+4548+01558\tEurope\/Zagreb\n-HT\t+1832-07220\tAmerica\/Port-au-Prince\n-HU\t+4730+01905\tEurope\/Budapest\n-ID\t-0610+10648\tAsia\/Jakarta\tJava, Sumatra\n-ID\t-0002+10920\tAsia\/Pontianak\tBorneo (west, central)\n-ID\t-0507+11924\tAsia\/Makassar\tBorneo (east, south), Sulawesi\/Celebes, Bali, Nusa Tengarra, Timor (west)\n-ID\t-0232+14042\tAsia\/Jayapura\tNew Guinea (West Papua \/ Irian Jaya), Malukus\/Moluccas\n-IE\t+5320-00615\tEurope\/Dublin\n-IL\t+314650+0351326\tAsia\/Jerusalem\n-IM\t+5409-00428\tEurope\/Isle_of_Man\n-IN\t+2232+08822\tAsia\/Kolkata\n-IO\t-0720+07225\tIndian\/Chagos\n-IQ\t+3321+04425\tAsia\/Baghdad\n-IR\t+3540+05126\tAsia\/Tehran\n-IS\t+6409-02151\tAtlantic\/Reykjavik\n-IT\t+4154+01229\tEurope\/Rome\n-JE\t+491101-0020624\tEurope\/Jersey\n-JM\t+175805-0764736\tAmerica\/Jamaica\n-JO\t+3157+03556\tAsia\/Amman\n-JP\t+353916+1394441\tAsia\/Tokyo\n-KE\t-0117+03649\tAfrica\/Nairobi\n-KG\t+4254+07436\tAsia\/Bishkek\n-KH\t+1133+10455\tAsia\/Phnom_Penh\n-KI\t+0125+17300\tPacific\/Tarawa\tGilbert Islands\n-KI\t-0247-17143\tPacific\/Kanton\tPhoenix Islands\n-KI\t+0152-15720\tPacific\/Kiritimati\tLine Islands\n-KM\t-1141+04316\tIndian\/Comoro\n-KN\t+1718-06243\tAmerica\/St_Kitts\n-KP\t+3901+12545\tAsia\/Pyongyang\n-KR\t+3733+12658\tAsia\/Seoul\n-KW\t+2920+04759\tAsia\/Kuwait\n-KY\t+1918-08123\tAmerica\/Cayman\n-KZ\t+4315+07657\tAsia\/Almaty\tmost of Kazakhstan\n-KZ\t+4448+06528\tAsia\/Qyzylorda\tQyzylorda\/Kyzylorda\/Kzyl-Orda\n-KZ\t+5312+06337\tAsia\/Qostanay\tQostanay\/Kostanay\/Kustanay\n-KZ\t+5017+05710\tAsia\/Aqtobe\tAqtobe\/Aktobe\n-KZ\t+4431+05016\tAsia\/Aqtau\tMangghystau\/Mankistau\n-KZ\t+4707+05156\tAsia\/Atyrau\tAtyrau\/Atirau\/Gur'yev\n-KZ\t+5113+05121\tAsia\/Oral\tWest Kazakhstan\n-LA\t+1758+10236\tAsia\/Vientiane\n-LB\t+3353+03530\tAsia\/Beirut\n-LC\t+1401-06100\tAmerica\/St_Lucia\n-LI\t+4709+00931\tEurope\/Vaduz\n-LK\t+0656+07951\tAsia\/Colombo\n-LR\t+0618-01047\tAfrica\/Monrovia\n-LS\t-2928+02730\tAfrica\/Maseru\n-LT\t+5441+02519\tEurope\/Vilnius\n-LU\t+4936+00609\tEurope\/Luxembourg\n-LV\t+5657+02406\tEurope\/Riga\n-LY\t+3254+01311\tAfrica\/Tripoli\n-MA\t+3339-00735\tAfrica\/Casablanca\n-MC\t+4342+00723\tEurope\/Monaco\n-MD\t+4700+02850\tEurope\/Chisinau\n-ME\t+4226+01916\tEurope\/Podgorica\n-MF\t+1804-06305\tAmerica\/Marigot\n-MG\t-1855+04731\tIndian\/Antananarivo\n-MH\t+0709+17112\tPacific\/Majuro\tmost of Marshall Islands\n-MH\t+0905+16720\tPacific\/Kwajalein\tKwajalein\n-MK\t+4159+02126\tEurope\/Skopje\n-ML\t+1239-00800\tAfrica\/Bamako\n-MM\t+1647+09610\tAsia\/Yangon\n-MN\t+4755+10653\tAsia\/Ulaanbaatar\tmost of Mongolia\n-MN\t+4801+09139\tAsia\/Hovd\tBayan-Olgii, Hovd, Uvs\n-MO\t+221150+1133230\tAsia\/Macau\n-MP\t+1512+14545\tPacific\/Saipan\n-MQ\t+1436-06105\tAmerica\/Martinique\n-MR\t+1806-01557\tAfrica\/Nouakchott\n-MS\t+1643-06213\tAmerica\/Montserrat\n-MT\t+3554+01431\tEurope\/Malta\n-MU\t-2010+05730\tIndian\/Mauritius\n-MV\t+0410+07330\tIndian\/Maldives\n-MW\t-1547+03500\tAfrica\/Blantyre\n-MX\t+1924-09909\tAmerica\/Mexico_City\tCentral Mexico\n-MX\t+2105-08646\tAmerica\/Cancun\tQuintana Roo\n-MX\t+2058-08937\tAmerica\/Merida\tCampeche, Yucatan\n-MX\t+2540-10019\tAmerica\/Monterrey\tDurango; Coahuila, Nuevo Leon, Tamaulipas (most areas)\n-MX\t+2550-09730\tAmerica\/Matamoros\tCoahuila, Nuevo Leon, Tamaulipas (US border)\n-MX\t+2838-10605\tAmerica\/Chihuahua\tChihuahua (most areas)\n-MX\t+3144-10629\tAmerica\/Ciudad_Juarez\tChihuahua (US border - west)\n-MX\t+2934-10425\tAmerica\/Ojinaga\tChihuahua (US border - east)\n-MX\t+2313-10625\tAmerica\/Mazatlan\tBaja California Sur, Nayarit (most areas), Sinaloa\n-MX\t+2048-10515\tAmerica\/Bahia_Banderas\tBahia de Banderas\n-MX\t+2904-11058\tAmerica\/Hermosillo\tSonora\n-MX\t+3232-11701\tAmerica\/Tijuana\tBaja California\n-MY\t+0310+10142\tAsia\/Kuala_Lumpur\tMalaysia (peninsula)\n-MY\t+0133+11020\tAsia\/Kuching\tSabah, Sarawak\n-MZ\t-2558+03235\tAfrica\/Maputo\n-NA\t-2234+01706\tAfrica\/Windhoek\n-NC\t-2216+16627\tPacific\/Noumea\n-NE\t+1331+00207\tAfrica\/Niamey\n-NF\t-2903+16758\tPacific\/Norfolk\n-NG\t+0627+00324\tAfrica\/Lagos\n-NI\t+1209-08617\tAmerica\/Managua\n-NL\t+5222+00454\tEurope\/Amsterdam\n-NO\t+5955+01045\tEurope\/Oslo\n-NP\t+2743+08519\tAsia\/Kathmandu\n-NR\t-0031+16655\tPacific\/Nauru\n-NU\t-1901-16955\tPacific\/Niue\n-NZ\t-3652+17446\tPacific\/Auckland\tmost of New Zealand\n-NZ\t-4357-17633\tPacific\/Chatham\tChatham Islands\n-OM\t+2336+05835\tAsia\/Muscat\n-PA\t+0858-07932\tAmerica\/Panama\n-PE\t-1203-07703\tAmerica\/Lima\n-PF\t-1732-14934\tPacific\/Tahiti\tSociety Islands\n-PF\t-0900-13930\tPacific\/Marquesas\tMarquesas Islands\n-PF\t-2308-13457\tPacific\/Gambier\tGambier Islands\n-PG\t-0930+14710\tPacific\/Port_Moresby\tmost of Papua New Guinea\n-PG\t-0613+15534\tPacific\/Bougainville\tBougainville\n-PH\t+143512+1205804\tAsia\/Manila\n-PK\t+2452+06703\tAsia\/Karachi\n-PL\t+5215+02100\tEurope\/Warsaw\n-PM\t+4703-05620\tAmerica\/Miquelon\n-PN\t-2504-13005\tPacific\/Pitcairn\n-PR\t+182806-0660622\tAmerica\/Puerto_Rico\n-PS\t+3130+03428\tAsia\/Gaza\tGaza Strip\n-PS\t+313200+0350542\tAsia\/Hebron\tWest Bank\n-PT\t+3843-00908\tEurope\/Lisbon\tPortugal (mainland)\n-PT\t+3238-01654\tAtlantic\/Madeira\tMadeira Islands\n-PT\t+3744-02540\tAtlantic\/Azores\tAzores\n-PW\t+0720+13429\tPacific\/Palau\n-PY\t-2516-05740\tAmerica\/Asuncion\n-QA\t+2517+05132\tAsia\/Qatar\n-RE\t-2052+05528\tIndian\/Reunion\n-RO\t+4426+02606\tEurope\/Bucharest\n-RS\t+4450+02030\tEurope\/Belgrade\n-RU\t+5443+02030\tEurope\/Kaliningrad\tMSK-01 - Kaliningrad\n-RU\t+554521+0373704\tEurope\/Moscow\tMSK+00 - Moscow area\n-# The obsolescent zone.tab format cannot represent Europe\/Simferopol well.\n-# Put it in RU section and list as UA.  See \"territorial claims\" above.\n-# Programs should use zone1970.tab instead; see above.\n-UA\t+4457+03406\tEurope\/Simferopol\tCrimea\n-RU\t+5836+04939\tEurope\/Kirov\tMSK+00 - Kirov\n-RU\t+4844+04425\tEurope\/Volgograd\tMSK+00 - Volgograd\n-RU\t+4621+04803\tEurope\/Astrakhan\tMSK+01 - Astrakhan\n-RU\t+5134+04602\tEurope\/Saratov\tMSK+01 - Saratov\n-RU\t+5420+04824\tEurope\/Ulyanovsk\tMSK+01 - Ulyanovsk\n-RU\t+5312+05009\tEurope\/Samara\tMSK+01 - Samara, Udmurtia\n-RU\t+5651+06036\tAsia\/Yekaterinburg\tMSK+02 - Urals\n-RU\t+5500+07324\tAsia\/Omsk\tMSK+03 - Omsk\n-RU\t+5502+08255\tAsia\/Novosibirsk\tMSK+04 - Novosibirsk\n-RU\t+5322+08345\tAsia\/Barnaul\tMSK+04 - Altai\n-RU\t+5630+08458\tAsia\/Tomsk\tMSK+04 - Tomsk\n-RU\t+5345+08707\tAsia\/Novokuznetsk\tMSK+04 - Kemerovo\n-RU\t+5601+09250\tAsia\/Krasnoyarsk\tMSK+04 - Krasnoyarsk area\n-RU\t+5216+10420\tAsia\/Irkutsk\tMSK+05 - Irkutsk, Buryatia\n-RU\t+5203+11328\tAsia\/Chita\tMSK+06 - Zabaykalsky\n-RU\t+6200+12940\tAsia\/Yakutsk\tMSK+06 - Lena River\n-RU\t+623923+1353314\tAsia\/Khandyga\tMSK+06 - Tomponsky, Ust-Maysky\n-RU\t+4310+13156\tAsia\/Vladivostok\tMSK+07 - Amur River\n-RU\t+643337+1431336\tAsia\/Ust-Nera\tMSK+07 - Oymyakonsky\n-RU\t+5934+15048\tAsia\/Magadan\tMSK+08 - Magadan\n-RU\t+4658+14242\tAsia\/Sakhalin\tMSK+08 - Sakhalin Island\n-RU\t+6728+15343\tAsia\/Srednekolymsk\tMSK+08 - Sakha (E), N Kuril Is\n-RU\t+5301+15839\tAsia\/Kamchatka\tMSK+09 - Kamchatka\n-RU\t+6445+17729\tAsia\/Anadyr\tMSK+09 - Bering Sea\n-RW\t-0157+03004\tAfrica\/Kigali\n-SA\t+2438+04643\tAsia\/Riyadh\n-SB\t-0932+16012\tPacific\/Guadalcanal\n-SC\t-0440+05528\tIndian\/Mahe\n-SD\t+1536+03232\tAfrica\/Khartoum\n-SE\t+5920+01803\tEurope\/Stockholm\n-SG\t+0117+10351\tAsia\/Singapore\n-SH\t-1555-00542\tAtlantic\/St_Helena\n-SI\t+4603+01431\tEurope\/Ljubljana\n-SJ\t+7800+01600\tArctic\/Longyearbyen\n-SK\t+4809+01707\tEurope\/Bratislava\n-SL\t+0830-01315\tAfrica\/Freetown\n-SM\t+4355+01228\tEurope\/San_Marino\n-SN\t+1440-01726\tAfrica\/Dakar\n-SO\t+0204+04522\tAfrica\/Mogadishu\n-SR\t+0550-05510\tAmerica\/Paramaribo\n-SS\t+0451+03137\tAfrica\/Juba\n-ST\t+0020+00644\tAfrica\/Sao_Tome\n-SV\t+1342-08912\tAmerica\/El_Salvador\n-SX\t+180305-0630250\tAmerica\/Lower_Princes\n-SY\t+3330+03618\tAsia\/Damascus\n-SZ\t-2618+03106\tAfrica\/Mbabane\n-TC\t+2128-07108\tAmerica\/Grand_Turk\n-TD\t+1207+01503\tAfrica\/Ndjamena\n-TF\t-492110+0701303\tIndian\/Kerguelen\n-TG\t+0608+00113\tAfrica\/Lome\n-TH\t+1345+10031\tAsia\/Bangkok\n-TJ\t+3835+06848\tAsia\/Dushanbe\n-TK\t-0922-17114\tPacific\/Fakaofo\n-TL\t-0833+12535\tAsia\/Dili\n-TM\t+3757+05823\tAsia\/Ashgabat\n-TN\t+3648+01011\tAfrica\/Tunis\n-TO\t-210800-1751200\tPacific\/Tongatapu\n-TR\t+4101+02858\tEurope\/Istanbul\n-TT\t+1039-06131\tAmerica\/Port_of_Spain\n-TV\t-0831+17913\tPacific\/Funafuti\n-TW\t+2503+12130\tAsia\/Taipei\n-TZ\t-0648+03917\tAfrica\/Dar_es_Salaam\n-UA\t+5026+03031\tEurope\/Kyiv\tmost of Ukraine\n-UG\t+0019+03225\tAfrica\/Kampala\n-UM\t+2813-17722\tPacific\/Midway\tMidway Islands\n-UM\t+1917+16637\tPacific\/Wake\tWake Island\n-US\t+404251-0740023\tAmerica\/New_York\tEastern (most areas)\n-US\t+421953-0830245\tAmerica\/Detroit\tEastern - MI (most areas)\n-US\t+381515-0854534\tAmerica\/Kentucky\/Louisville\tEastern - KY (Louisville area)\n-US\t+364947-0845057\tAmerica\/Kentucky\/Monticello\tEastern - KY (Wayne)\n-US\t+394606-0860929\tAmerica\/Indiana\/Indianapolis\tEastern - IN (most areas)\n-US\t+384038-0873143\tAmerica\/Indiana\/Vincennes\tEastern - IN (Da, Du, K, Mn)\n-US\t+410305-0863611\tAmerica\/Indiana\/Winamac\tEastern - IN (Pulaski)\n-US\t+382232-0862041\tAmerica\/Indiana\/Marengo\tEastern - IN (Crawford)\n-US\t+382931-0871643\tAmerica\/Indiana\/Petersburg\tEastern - IN (Pike)\n-US\t+384452-0850402\tAmerica\/Indiana\/Vevay\tEastern - IN (Switzerland)\n-US\t+415100-0873900\tAmerica\/Chicago\tCentral (most areas)\n-US\t+375711-0864541\tAmerica\/Indiana\/Tell_City\tCentral - IN (Perry)\n-US\t+411745-0863730\tAmerica\/Indiana\/Knox\tCentral - IN (Starke)\n-US\t+450628-0873651\tAmerica\/Menominee\tCentral - MI (Wisconsin border)\n-US\t+470659-1011757\tAmerica\/North_Dakota\/Center\tCentral - ND (Oliver)\n-US\t+465042-1012439\tAmerica\/North_Dakota\/New_Salem\tCentral - ND (Morton rural)\n-US\t+471551-1014640\tAmerica\/North_Dakota\/Beulah\tCentral - ND (Mercer)\n-US\t+394421-1045903\tAmerica\/Denver\tMountain (most areas)\n-US\t+433649-1161209\tAmerica\/Boise\tMountain - ID (south), OR (east)\n-US\t+332654-1120424\tAmerica\/Phoenix\tMST - AZ (except Navajo)\n-US\t+340308-1181434\tAmerica\/Los_Angeles\tPacific\n-US\t+611305-1495401\tAmerica\/Anchorage\tAlaska (most areas)\n-US\t+581807-1342511\tAmerica\/Juneau\tAlaska - Juneau area\n-US\t+571035-1351807\tAmerica\/Sitka\tAlaska - Sitka area\n-US\t+550737-1313435\tAmerica\/Metlakatla\tAlaska - Annette Island\n-US\t+593249-1394338\tAmerica\/Yakutat\tAlaska - Yakutat\n-US\t+643004-1652423\tAmerica\/Nome\tAlaska (west)\n-US\t+515248-1763929\tAmerica\/Adak\tAlaska - western Aleutians\n-US\t+211825-1575130\tPacific\/Honolulu\tHawaii\n-UY\t-345433-0561245\tAmerica\/Montevideo\n-UZ\t+3940+06648\tAsia\/Samarkand\tUzbekistan (west)\n-UZ\t+4120+06918\tAsia\/Tashkent\tUzbekistan (east)\n-VA\t+415408+0122711\tEurope\/Vatican\n-VC\t+1309-06114\tAmerica\/St_Vincent\n-VE\t+1030-06656\tAmerica\/Caracas\n-VG\t+1827-06437\tAmerica\/Tortola\n-VI\t+1821-06456\tAmerica\/St_Thomas\n-VN\t+1045+10640\tAsia\/Ho_Chi_Minh\n-VU\t-1740+16825\tPacific\/Efate\n-WF\t-1318-17610\tPacific\/Wallis\n-WS\t-1350-17144\tPacific\/Apia\n-YE\t+1245+04512\tAsia\/Aden\n-YT\t-1247+04514\tIndian\/Mayotte\n-ZA\t-2615+02800\tAfrica\/Johannesburg\n-ZM\t-1525+02817\tAfrica\/Lusaka\n-ZW\t-1750+03103\tAfrica\/Harare\n","filename":"src\/java.base\/share\/data\/tzdata\/zone.tab","additions":0,"deletions":470,"binary":false,"changes":470,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n-\tsolar87 solar88 solar89 southamerica \\\n-\tbackward\n+\tsouthamerica backward\n","filename":"test\/jdk\/java\/util\/TimeZone\/tools\/share\/Makefile","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * <code>BackEnd<\/code> is an abstract base class for a back-end of compiling\n- * Olson's zoneinfo database and generating Java zoneinfo database.\n- *\n- * @since 1.4\n- *\/\n-abstract class BackEnd {\n-\n-    \/**\n-     * Receives each zone's TimeZone information which was created by\n-     * {@link Zoneinfo#parse} in class <code>Zoneinfo<\/code>,\n-     * and processes it.\n-     *\n-     * @param tz Timezone object for each zone\n-     * @return 0 if no error occurred, otherwise 1.\n-     *\/\n-    abstract int processZoneinfo(Timezone tz);\n-\n-    \/**\n-     * Receives whole information which is generated by JavaZic's front-end\n-     * in the form of Mapping object and generates all Java zone information\n-     * files.\n-     *\n-     * @param m Mappings object which is generated by\n-     *          {@link Main#compile() Main.compile()}.\n-     * @return 0 if no error occurred, otherwise 1.\n-     *\/\n-    abstract int generateSrc(Mappings m);\n-\n-    \/**\n-     * Decides which backend class should be used and returns its instance.\n-     * @return an instance of backend class\n-     *\/\n-    static BackEnd getBackEnd() {\n-        if (Zoneinfo.isYearForTimeZoneDataSpecified) {\n-            return new Simple();\n-        } else if (Main.outputDoc) {\n-            return new GenDoc();\n-        } else {\n-            return new Gen();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/BackEnd.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8073446 8262110\n- * @summary Tests DST related beyond the year 2037\n- * @run testng Beyond2037\n- *\/\n-\n-import java.text.SimpleDateFormat;\n-import java.util.TimeZone;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n-public class Beyond2037 {\n-\n-    @DataProvider\n-    Object[][] dstTransition() {\n-        return new Object[][] {\n-            {\"2037\/03\/08 01:59:59:999\", \"2037\/03\/08 01:59:59:999\"},\n-            {\"2037\/03\/08 02:00:00:000\", \"2037\/03\/08 03:00:00:000\"},\n-            {\"2038\/03\/14 01:59:59:999\", \"2038\/03\/14 01:59:59:999\"},\n-            {\"2038\/03\/14 02:00:00:000\", \"2038\/03\/14 03:00:00:000\"},\n-            {\"2099\/03\/08 01:59:59:999\", \"2099\/03\/08 01:59:59:999\"},\n-            {\"2099\/03\/08 02:00:00:000\", \"2099\/03\/08 03:00:00:000\"},\n-            {\"2100\/03\/14 01:59:59:999\", \"2100\/03\/14 01:59:59:999\"},\n-            {\"2100\/03\/14 02:00:00:000\", \"2100\/03\/14 03:00:00:000\"},\n-            {\"8000\/03\/12 01:59:59:999\", \"8000\/03\/12 01:59:59:999\"},\n-            {\"8000\/03\/12 02:00:00:000\", \"8000\/03\/12 03:00:00:000\"},\n-        };\n-    }\n-\n-    @Test(dataProvider=\"dstTransition\")\n-    public void testDstTransition(String source, String expected) throws Exception {\n-        var timeZone = TimeZone.getTimeZone(\"America\/New_York\");\n-        var sdf = new SimpleDateFormat(\"yyyy\/MM\/dd HH:mm:ss:SSS\" );\n-        sdf.setTimeZone(timeZone);\n-        assertEquals(sdf.format(sdf.parse(source)), expected);\n-    }\n-\n-    @Test\n-    public void testGetOffset() throws Exception {\n-        var timeZone = TimeZone.getTimeZone(\"PST8PDT\");\n-        var df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n-        df.setTimeZone(timeZone);\n-        var tMilli = df.parse(\"7681-03-09 03:20:49\").getTime();\n-        assertEquals(timeZone.getOffset(tMilli), -25200000);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Beyond2037.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.zip.CRC32;\n-\n-\/**\n- * Checksum provides methods for calculating a CRC32 value for a\n- * transitions table.\n- *\n- * @since 1.4\n- *\/\n-public class Checksum extends CRC32\n-{\n-    \/**\n-     * Updates the CRC32 value from each byte of the given int\n-     * value. The bytes are used in the big endian order.\n-     * @param val the int value\n-     *\/\n-    public void update(int val) {\n-        byte[] b = new byte[4];\n-        b[0] = (byte)((val >>> 24) & 0xff);\n-        b[1] = (byte)((val >>> 16) & 0xff);\n-        b[2] = (byte)((val >>> 8) & 0xff);\n-        b[3] = (byte)(val & 0xff);\n-        update(b);\n-    }\n-\n-    \/**\n-     * Updates the CRC32 value from each byte of the given long\n-     * value. The bytes are used in the big endian order.\n-     * @param val the long value\n-     *\/\n-    void update(long val) {\n-        byte[] b = new byte[8];\n-        b[0] = (byte)((val >>> 56) & 0xff);\n-        b[1] = (byte)((val >>> 48) & 0xff);\n-        b[2] = (byte)((val >>> 40) & 0xff);\n-        b[3] = (byte)((val >>> 32) & 0xff);\n-        b[4] = (byte)((val >>> 24) & 0xff);\n-        b[5] = (byte)((val >>> 16) & 0xff);\n-        b[6] = (byte)((val >>> 8) & 0xff);\n-        b[7] = (byte)(val & 0xff);\n-        update(b);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Checksum.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Day of week enum.\n- *\n- * @since 1.6\n- *\/\n-\n-enum DayOfWeek {\n-    SUNDAY(\"Sun\"),\n-    MONDAY(\"Mon\"),\n-    TUESDAY(\"Tue\"),\n-    WEDNESDAY(\"Wed\"),\n-    THURSDAY(\"Thu\"),\n-    FRIDAY(\"Fri\"),\n-    SATURDAY(\"Sat\");\n-\n-    private final String abbr;\n-\n-    private DayOfWeek(String abbr) {\n-        this.abbr = abbr;\n-    }\n-\n-    String getAbbr() {\n-        return abbr;\n-    }\n-\n-    int value() {\n-        return ordinal() + 1;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/DayOfWeek.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,342 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.io.IOException;\n-import  java.io.File;\n-import  java.io.FileOutputStream;\n-import  java.io.DataOutputStream;\n-import  java.io.RandomAccessFile;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-\n-\/**\n- * <code>Gen<\/code> is one of back-end classes of javazic, and generates\n- * ZoneInfoMappings and zone-specific file for each zone.\n- *\/\n-class Gen extends BackEnd {\n-\n-    \/**\n-     * Generates datafile in binary TLV format for each time zone.\n-     * Regarding contents of output files, see {@link ZoneInfoFile}.\n-     *\n-     * @param Timezone\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int processZoneinfo(Timezone tz) {\n-        try {\n-            int size;\n-            String outputDir = Main.getOutputDir();\n-            String zonefile = ZoneInfoFile.getFileName(tz.getName());\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-\n-            \/* If zonefile includes file-separator, it's treated as part of\n-             * pathname. And make directory if necessary.\n-             *\/\n-            int index = zonefile.lastIndexOf(File.separatorChar);\n-            if (index != -1) {\n-                outputDir += zonefile.substring(0, index+1);\n-            }\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            FileOutputStream fos =\n-                new FileOutputStream(outputDir + zonefile.substring(index+1));\n-            DataOutputStream dos = new DataOutputStream(fos);\n-\n-            \/* Output Label *\/\n-            dos.write(ZoneInfoFile.JAVAZI_LABEL, 0,\n-                      ZoneInfoFile.JAVAZI_LABEL.length);\n-\n-            \/* Output Version of ZoneInfoFile *\/\n-            dos.writeByte(ZoneInfoFile.JAVAZI_VERSION);\n-\n-            List<Long> transitions = tz.getTransitions();\n-            if (transitions != null) {\n-                List<Integer> dstOffsets = tz.getDstOffsets();\n-                List<Integer> offsets = tz.getOffsets();\n-\n-                if ((dstOffsets == null && offsets != null) ||\n-                    (dstOffsets != null && offsets == null)) {\n-                    Main.panic(\"Data not exist. (dstOffsets or offsets)\");\n-                    return 1;\n-                }\n-\n-                \/* Output Transition records *\/\n-                dos.writeByte(ZoneInfoFile.TAG_Transition);\n-                size = transitions.size();\n-                dos.writeShort((size * 8) & 0xFFFF);\n-                int dstoffset;\n-                for (int i = 0; i < size; i++) {\n-                    \/* if DST offset is 0, this means DST isn't used.\n-                     * (NOT: offset's index is 0.)\n-                     *\/\n-                    if ((dstoffset = dstOffsets.get(i).intValue()) == -1) {\n-                        dstoffset = 0;\n-                    }\n-\n-                    dos.writeLong((transitions.get(i).longValue() << 12)\n-                                  | (dstoffset << 4)\n-                                  | offsets.get(i).intValue());\n-\n-                }\n-\n-                \/* Output data for GMTOffset *\/\n-                List<Integer> gmtoffset = tz.getGmtOffsets();\n-                dos.writeByte(ZoneInfoFile.TAG_Offset);\n-                size = gmtoffset.size();\n-                dos.writeShort((size * 4) & 0xFFFF);\n-                for (int i = 0; i < size; i++) {\n-                    dos.writeInt(gmtoffset.get(i));\n-                }\n-            }\n-\n-            \/* Output data for SimpleTimeZone *\/\n-            List<RuleRec> stz = tz.getLastRules();\n-            if (stz != null) {\n-                RuleRec[] rr = new RuleRec[2];\n-                boolean wall = true;\n-\n-                rr[0] = stz.get(0);\n-                rr[1] = stz.get(1);\n-\n-                dos.writeByte(ZoneInfoFile.TAG_SimpleTimeZone);\n-                wall = rr[0].getTime().isWall() && rr[1].getTime().isWall();\n-                if (wall) {\n-                    dos.writeShort(32);\n-                } else {\n-                    dos.writeShort(40);\n-                }\n-\n-                for (int i = 0; i < 2; i++) {\n-                    dos.writeInt(rr[i].getMonthNum() - 1); \/\/ 0-based month number\n-                    dos.writeInt(rr[i].getDay().getDayForSimpleTimeZone());\n-                    dos.writeInt(rr[i].getDay().getDayOfWeekForSimpleTimeZoneInt());\n-                    dos.writeInt((int)rr[i].getTime().getTime());\n-                    if (!wall) {\n-                        dos.writeInt((rr[i].getTime().getType() & 0xFF) - 1);\n-                    }\n-                }\n-            }\n-\n-            \/* Output RawOffset *\/\n-            dos.writeByte(ZoneInfoFile.TAG_RawOffset);\n-            dos.writeShort(4);\n-            dos.writeInt(tz.getRawOffset());\n-\n-            \/* Output willGMTOffsetChange flag *\/\n-            if (tz.willGMTOffsetChange()) {\n-                dos.writeByte(ZoneInfoFile.TAG_GMTOffsetWillChange);\n-                dos.writeShort(1);\n-                dos.writeByte(1);\n-            }\n-\n-            \/* Output LastDSTSaving *\/\n-            dos.writeByte(ZoneInfoFile.TAG_LastDSTSaving);\n-            dos.writeShort(2);\n-            dos.writeShort(tz.getLastDSTSaving()\/1000);\n-\n-            \/* Output checksum *\/\n-            dos.writeByte(ZoneInfoFile.TAG_CRC32);\n-            dos.writeShort(4);\n-            dos.writeInt(tz.getCRC32());\n-\n-            fos.close();\n-            dos.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Generates ZoneInfoMappings in binary TLV format for each zone.\n-     * Regarding contents of output files, see {@link ZoneInfoFile}.\n-     *\n-     * @param Mappings\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int generateSrc(Mappings map) {\n-        try {\n-            int index;\n-            int block_size;\n-            int roi_size;\n-            long fp;\n-            String outputDir = Main.getOutputDir();\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            \/* Open ZoneInfoMapping file to write. *\/\n-            RandomAccessFile raf =\n-                new RandomAccessFile(outputDir + ZoneInfoFile.JAVAZM_FILE_NAME, \"rw\");\n-\n-            \/* Whether rawOffsetIndex list exists or not. *\/\n-            List<Integer> roi = map.getRawOffsetsIndex();\n-            if (roi == null) {\n-                Main.panic(\"Data not exist. (rawOffsetsIndex)\");\n-                return 1;\n-            }\n-            roi_size = roi.size();\n-\n-            \/* Whether rawOffsetIndexTable list exists or not. *\/\n-            List<Set<String>> roit = map.getRawOffsetsIndexTable();\n-            if (roit == null || roit.size() != roi_size) {\n-                Main.panic(\"Data not exist. (rawOffsetsIndexTable) Otherwise, Invalid size\");\n-                return 1;\n-            }\n-\n-            \/* Output Label *\/\n-            raf.write(ZoneInfoFile.JAVAZM_LABEL, 0,\n-                      ZoneInfoFile.JAVAZM_LABEL.length);\n-\n-            \/* Output Version *\/\n-            raf.writeByte(ZoneInfoFile.JAVAZM_VERSION);\n-\n-            index = ZoneInfoFile.JAVAZM_LABEL.length + 2;\n-\n-            \/* Output Version of Olson's tzdata *\/\n-            byte[] b = Main.getVersionName().getBytes(\"UTF-8\");\n-            raf.writeByte(ZoneInfoFile.TAG_TZDataVersion);\n-            raf.writeShort((b.length+1) & 0xFFFF);\n-            raf.write(b);\n-            raf.writeByte(0x00);\n-            index += b.length + 4;\n-\n-            \/* Output ID list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_ZoneIDs);\n-            block_size = 2;\n-            raf.writeShort(block_size & 0xFFFF);\n-            short nID = 0;\n-            raf.writeShort(nID & 0xFFFF);\n-            for (int i = 0; i < roi_size; i++) {\n-                for (String key : roit.get(i)) {\n-                    byte size = (byte)key.getBytes(\"UTF-8\").length;\n-                    raf.writeByte(size & 0xFF);\n-                    raf.write(key.getBytes(\"UTF-8\"), 0, size);\n-                    block_size += 1 + size;\n-                    nID++;\n-                }\n-            }\n-            fp = raf.getFilePointer();\n-            raf.seek(index);\n-            raf.writeShort((block_size) & 0xFFFF);\n-            raf.writeShort(nID & 0xFFFF);\n-            raf.seek(fp);\n-\n-            \/* Output sorted rawOffset list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_RawOffsets);\n-            index += 3 + block_size;\n-            block_size = roi_size * 4;\n-            raf.writeShort(block_size & 0xFFFF);\n-            for (int i = 0; i < roi_size; i++) {\n-                raf.writeInt(Integer.parseInt(roi.get(i).toString()));\n-            }\n-\n-            \/* Output sorted rawOffsetIndex list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_RawOffsetIndices);\n-            index += 3 + block_size;\n-            block_size = 0;\n-            raf.writeShort(block_size & 0xFFFF);\n-            int num;\n-            for (int i = 0; i < roi_size; i++) {\n-                num = roit.get(i).size();\n-                block_size += num;\n-                for (int j = 0; j < num; j++) {\n-                    raf.writeByte(i);\n-                }\n-            }\n-            fp = raf.getFilePointer();\n-            raf.seek(index);\n-            raf.writeShort((block_size) & 0xFFFF);\n-            raf.seek(fp);\n-\n-            \/* Whether alias list exists or not. *\/\n-            Map<String,String> a = map.getAliases();\n-            if (a == null) {\n-                Main.panic(\"Data not exist. (aliases)\");\n-                return 0;\n-            }\n-\n-            \/* Output ID list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_ZoneAliases);\n-            index += 3 + block_size;\n-            block_size = 2;\n-            raf.writeShort(block_size & 0xFFFF);\n-            raf.writeShort(a.size() & 0xFFFF);\n-            for (String key : a.keySet()) {\n-                String alias = a.get(key);\n-                byte key_size = (byte)key.length();\n-                byte alias_size = (byte)alias.length();\n-                raf.writeByte(key_size & 0xFF);\n-                raf.write(key.getBytes(\"UTF-8\"), 0, key_size);\n-                raf.writeByte(alias_size & 0xFF);\n-                raf.write(alias.getBytes(\"UTF-8\"), 0, alias_size);\n-                block_size += 2 + key_size + alias_size;\n-            }\n-            fp = raf.getFilePointer();\n-            raf.seek(index);\n-            raf.writeShort((block_size) & 0xFFFF);\n-            raf.seek(fp);\n-\n-            \/* Output the exclude list if it exists. *\/\n-            List<String> excludedZones = map.getExcludeList();\n-            if (excludedZones != null) {\n-                raf.writeByte(ZoneInfoFile.TAG_ExcludedZones);\n-                index += 3 + block_size;\n-                block_size = 2;\n-                raf.writeShort(block_size & 0xFFFF);  \/\/ place holder\n-                raf.writeShort(excludedZones.size()); \/\/ the number of excluded zones\n-                for (String name : excludedZones) {\n-                    byte size = (byte) name.length();\n-                    raf.writeByte(size);                 \/\/ byte length\n-                    raf.write(name.getBytes(\"UTF-8\"), 0, size); \/\/ zone name\n-                    block_size += 1 + size;\n-                }\n-                fp = raf.getFilePointer();\n-                raf.seek(index);\n-                raf.writeShort(block_size & 0xFFFF);\n-                raf.seek(fp);\n-            }\n-\n-            \/* Close ZoneInfoMapping file. *\/\n-            raf.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Gen.java","additions":0,"deletions":342,"binary":false,"changes":342,"status":"deleted"},{"patch":"@@ -1,776 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.io.BufferedReader;\n-import  java.io.BufferedWriter;\n-import  java.io.File;\n-import  java.io.FileReader;\n-import  java.io.FileWriter;\n-import  java.io.IOException;\n-import  java.util.Date;\n-import  java.util.HashMap;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-import  java.util.SortedMap;\n-import  java.util.StringTokenizer;\n-import  java.util.TreeMap;\n-import  java.util.TreeSet;\n-\n-\/**\n- * <code>GenDoc<\/code> is one of back-end classes of javazic, and generates\n- * index.html and other html files which prints the detailed time zone\n- * information for each zone.\n- *\/\n-class GenDoc extends BackEnd {\n-\n-    private static final String docDir = \"doc\";\n-\n-    private static final String header1 =\n-        \"<!DOCTYPE HTML PUBLIC \\\"-\/\/W3C\/\/DTD HTML 4.0 Frameset\/\/EN\\\"\" +\n-        \"\\\"http:\/\/www.w3.org\/TR\/REC-html40\/frameset.dtd\\\">\\n\" +\n-        \"<HTML>\\n<HEAD>\\n<!-- Generated by javazic on \";\n-    private static final String header2 =\n-        \"-->\\n<TITLE>\\n\" +\n-        \"Java Platform, Standard Edition - TimeZone information based on \";\n-    private static final String header3 =\n-        \"-->\\n<TITLE>\\n\" +\n-        \"Java Platform, Standard Edition  TimeZone - \";\n-    private static final String header4 =\n-        \"<\/TITLE>\\n\" +\n-        \"<\/HEAD>\\n\\n\";\n-\n-    private static final String body1 =\n-        \"<BODY BGCOLOR=\\\"white\\\">\\n\";\n-    private static final String body2 =\n-        \"<\/BODY>\\n\";\n-\n-    private static final String footer =\n-        \"<\/HTML>\\n\";\n-\n-\n-    \/\/ list of time zone name and zonefile name\/real time zone name\n-    \/\/   e.g.\n-    \/\/      key (String)       : value (String)\n-    \/\/      \"America\/Denver\"   : \"America\/Denver.html\" (real time zone)\n-    \/\/      \"America\/Shiprock\" : \"America\/Denver\"      (alias)\n-    TreeMap<String,String> timezoneList = new TreeMap<String,String>();\n-\n-    \/\/ list of time zone's display name and time zone name\n-    \/\/   e.g.\n-    \/\/      key (String)                : value (String)\n-    \/\/      \"Tokyo, Asia\"               : \"Asia\/Tokyo\"\n-    \/\/      \"Marengo, Indiana, America\" : \"America\/Indiana\/Marengo\"\n-    \/\/          (aliases included)\n-    TreeMap<String,String> displayNameList = new TreeMap<String,String>();\n-\n-    \/\/ list of top level regions\n-    \/\/   e.g.\n-    \/\/      key (String) : value (String)\n-    \/\/      \"America\"    : \"America.html\"\n-    \/\/          (including entries in America\/Indiana\/, America\/Kentucky\/, ...)\n-    TreeMap<String,String> regionList = new TreeMap<String,String>();\n-\n-    \/\/ mapping list from zone name to latitude & longitude\n-    \/\/   This list is generated from zone.tab.\n-    \/\/   e.g.\n-    \/\/      key (String) : value (LatitudeAndLongitude object)\n-    \/\/      \"Asia\/Tokyo\" : latitude=35.3916, longitude=13.9444\n-    \/\/          (aliases not included)\n-    HashMap<String,LatitudeAndLongitude> mapList = null;\n-\n-    \/\/ SortedMap of zone IDs sorted by their GMT offsets. If zone's GMT\n-    \/\/ offset will change in the future, its last known offset is\n-    \/\/ used.\n-    SortedMap<Integer, Set<String>> zonesByOffset = new TreeMap<Integer, Set<String>>();\n-\n-    \/**\n-     * Generates HTML document for each zone.\n-     * @param Timezone\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int processZoneinfo(Timezone tz) {\n-        try {\n-            int size;\n-            int index;\n-            String outputDir = Main.getOutputDir();\n-            String zonename = tz.getName();\n-            String zonefile = ZoneInfoFile.getFileName(zonename) + \".html\";\n-            List<RuleRec> stz = tz.getLastRules();\n-            timezoneList.put(zonename, zonefile);\n-            displayNameList.put(transform(zonename), zonename);\n-\n-            \/\/ Populate zonesByOffset. (Zones that will change their\n-            \/\/ GMT offsets are also added to zonesByOffset here.)\n-            int lastKnownOffset = tz.getRawOffset();\n-            Set<String> set = zonesByOffset.get(lastKnownOffset);\n-            if (set == null) {\n-                set = new TreeSet<String>();\n-                zonesByOffset.put(lastKnownOffset, set);\n-            }\n-            set.add(zonename);\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-            outputDir += docDir + File.separatorChar;\n-\n-            index = zonename.indexOf('\/');\n-            if (index != -1) {\n-                regionList.put(zonename.substring(0, index),\n-                               zonename.substring(0, index) + \".html\");\n-            }\n-\n-            \/* If zonefile includes file-separator, it's treated as part of\n-             * pathname. And make directory if necessary.\n-             *\/\n-            index = zonefile.lastIndexOf('\/');\n-            if (index != -1) {\n-                zonefile.replace('\/', File.separatorChar);\n-                outputDir += zonefile.substring(0, index+1);\n-            }\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            \/* If mapfile is available, add a link to the appropriate map *\/\n-            if (mapList == null && Main.getMapFile() != null) {\n-                mapList = new HashMap<String, LatitudeAndLongitude>();\n-                FileReader fr = new FileReader(Main.getMapFile());\n-                BufferedReader in = new BufferedReader(fr);\n-                String line;\n-                while ((line = in.readLine()) != null) {\n-                    \/\/ skip blank and comment lines\n-                    if (line.length() == 0 || line.charAt(0) == '#') {\n-                        continue;\n-                    }\n-                    StringTokenizer tokens = new StringTokenizer(line);\n-                    String token = tokens.nextToken();  \/* We don't use the first token. *\/\n-                    token = tokens.nextToken();\n-                    LatitudeAndLongitude location = new LatitudeAndLongitude(token);\n-                    token = tokens.nextToken();\n-                    mapList.put(token, location);\n-                }\n-                in.close();\n-            }\n-\n-            \/* Open zoneinfo file to write. *\/\n-            FileWriter fw = new FileWriter(outputDir + zonefile.substring(index+1));\n-            BufferedWriter out = new BufferedWriter(fw);\n-\n-            out.write(header1 + new Date() + header3 + zonename + header4);\n-            out.write(body1 + \"<FONT size=\\\"+2\\\"><B>\" + zonename + \"<\/B><\/FONT>\");\n-            LatitudeAndLongitude location = (mapList != null ? mapList.get(zonename) : null);\n-            if (location != null) {\n-                int deg, min, sec;\n-\n-                deg = location.getLatDeg();\n-                min = location.getLatMin();\n-                sec = location.getLatSec();\n-                if (deg < 0) {\n-                    min = -min;\n-                    sec = -sec;\n-                } else if (min < 0) {\n-                    sec = -sec;\n-                }\n-                out.write(\"&nbsp;&nbsp;&nbsp;\" +\n-                          \"<A HREF=\\\"http:\/\/www.mapquest.com\/maps\/map.adp?\" +\n-                          \"latlongtype=degrees\" +\n-                          \"&latdeg=\" + deg +\n-                          \"&latmin=\" + min +\n-                          \"&latsec=\" + sec);\n-\n-                deg = location.getLongDeg();\n-                min = location.getLongMin();\n-                sec = location.getLongSec();\n-                if (deg < 0) {\n-                    min = -min;\n-                    sec = -sec;\n-                } else if (min < 0) {\n-                    sec = -sec;\n-                }\n-                out.write(\"&longdeg=\" + deg +\n-                          \"&longmin=\" + min +\n-                          \"&longsec=\" + sec +\n-                          \"\\\" target=\\\"_blank\\\">[map]<\/A>\");\n-            }\n-            out.write(\"\\n<P>\\n\");\n-\n-            List<ZoneRec> zone = tz.getZones();\n-            List<RuleRec> rule = tz.getRules();\n-            if (rule != null && zone != null) {\n-                out.write(\"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\" CELLPADDING=\\\"1\\\" CELLSPACING=\\\"0\\\">\\n\" +\n-                          \"<TR>\\n\" +\n-                          \"<TD BGCOLOR=\\\"#EEEEFF\\\" WIDTH=\\\"50%\\\" ALIGN=\\\"CENTER\\\"><BR>\" +\n-                          \"<A HREF=\\\"#Rules\\\">Rules<\/A><BR><\/TD>\\n\" +\n-                          \"<TD BGCOLOR=\\\"#EEEEFF\\\" WIDTH=\\\"50%\\\" ALIGN=\\\"CENTER\\\">\" +\n-                          \"<A HREF=\\\"#Zone\\\"><BR>Zone<BR><\/A><\/TD>\\n\" +\n-                          \"<\/TR>\\n<\/TABLE>\\n\");\n-            }\n-\n-            \/* Output Rule records. *\/\n-            if (rule != null) {\n-                size = rule.size();\n-                out.write(\"<P>\\n<A NAME=\\\"Rules\\\">\" +\n-                          \"<FONT SIZE=\\\"+1\\\"><B>Rules<\/B><\/FONT><\/A>\\n\" +\n-                          \"<TABLE BORDER=\\\"1\\\" WIDTH=\\\"100%\\\" CELLPADDING=\\\"3\\\" CELLSPACING=\\\"0\\\">\\n\" +\n-                          \"<TR BGCOLOR=\\\"#CCCCFF\\\">\\n\" +\n-                          \"<TD>NAME<\/TD><TD>FROM<\/TD><TD>TO<\/TD><TD>TYPE<\/TD>\" +\n-                          \"<TD>IN<\/TD><TD>ON<\/TD><TD>AT<\/TD><TD>SAVE<\/TD>\" +\n-                          \"<TD>LETTER\/S<\/TD><TD>NOTES<\/TD>\\n<\/TR>\\n\");\n-                for (int i = 0; i < size; i++) {\n-                    out.write(\"<TR BGCOLOR=\\\"#FFFFFF\\\">\\n\");\n-                    StringTokenizer st = new StringTokenizer(rule.get(i).getLine());\n-                    String s;\n-                    if (st.hasMoreTokens()) {   \/* RULE - truncated *\/\n-                        st.nextToken();\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* NAME *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* FROM *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* TO *\/\n-                        s = st.nextToken();\n-                        if (s.equals(\"min\") || s.equals(\"max\")) {\n-                            out.write(\"<TD><FONT COLOR=\\\"red\\\">\" + s + \"<\/FONT><\/TD>\");\n-                        } else {\n-                            out.write(\"<TD>\" + s + \"<\/TD>\");\n-                        }\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* TYPE *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* IN *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* ON *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* AT *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* SAVE *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* LETTER\/S *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* NOTES *\/\n-                        s = st.nextToken();\n-                        while (st.hasMoreTokens()) {\n-                            s += \" \" + st.nextToken();\n-                        }\n-                        index = s.indexOf('#');\n-                        out.write(\"<TD>\" + s.substring(index+1) + \"<\/TD>\\n\");\n-                    } else {\n-                        out.write(\"<TD>&nbsp;<\/TD>\\n\");\n-                    }\n-                    out.write(\"<\/TR>\\n\");\n-                }\n-                out.write(\"<\/TABLE>\\n<P>&nbsp;<P>\\n\");\n-            }\n-\n-            \/* Output Zone records. *\/\n-            if (zone != null) {\n-                size = zone.size();\n-                out.write(\"<P>\\n<A NAME=\\\"Zone\\\">\" +\n-                          \"<FONT SIZE=\\\"+1\\\"><B>Zone<\/B><\/FONT><\/A>\\n\" +\n-                          \"<TABLE BORDER=\\\"1\\\" WIDTH=\\\"100%\\\" CELLPADDING=\\\"3\\\" CELLSPACING=\\\"0\\\">\\n\" +\n-                          \"<TR BGCOLOR=\\\"#CCCCFF\\\">\\n<TD>GMTOFF<\/TD>\" +\n-                          \"<TD>RULES<\/TD><TD>FORMAT<\/TD><TD>UNTIL<\/TD>\" +\n-                          \"<TD>NOTES<\/TD>\\n<\/TR>\\n\");\n-                for (int i = 0; i < size; i++) {\n-                    out.write(\"<TR>\\n\");\n-                    StringTokenizer st = new StringTokenizer(zone.get(i).getLine());\n-                    String s = st.nextToken();\n-                    if (s.equals(\"Zone\")) {     \/* NAME *\/\n-                        s = st.nextToken();\n-                        s = st.nextToken();\n-                    }\n-                    out.write(\"<TD>\" + s + \"<\/TD>\");    \/* GMTOFFSET *\/\n-                    if (st.hasMoreTokens()) {   \/* RULES *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* FORMAT *\/\n-                        s = st.nextToken();\n-                        index = s.indexOf('#');\n-                        if (index != -1) {\n-                            if (index != 0) {\n-                                out.write(\"<TD>\" + s.substring(0, index-1) +\n-                                          \"<\/TD>\");     \/* FORMAT *\/\n-                                s = s.substring(index+1);\n-                            } else {\n-                                out.write(\"<TD>&nbsp;<\/TD>\");   \/* FORMAT *\/\n-                            }\n-                            while (st.hasMoreTokens()) {\n-                                s += \" \" + st.nextToken();\n-                            }\n-                            out.write(\"<TD>&nbsp;<\/TD>\");       \/* UNTIL *\/\n-                            out.write(\"<TD>\" + s + \"<\/TD>\\n<\/TR>\\n\");   \/* NOTES *\/\n-                            continue;\n-                        } else {\n-                            out.write(\"<TD>\" + s + \"<\/TD>\");    \/* FORMAT *\/\n-                        }\n-                    }\n-\n-                    if (st.hasMoreTokens()) {   \/* UNTIL *\/\n-                        s = st.nextToken();\n-                        while (st.hasMoreTokens()) {\n-                            s += \" \" + st.nextToken();\n-                        }\n-                        index = s.indexOf('#');\n-                        if (index != -1) {\n-                            if (index != 0) {\n-                                out.write(\"<TD>\" + s.substring(0, index-1) +\n-                                          \"<\/TD>\");     \/* UNTIL *\/\n-                            } else {\n-                                out.write(\"<TD>&nbsp;<\/TD>\");   \/* UNTIL *\/\n-                            }\n-                            out.write(\"<TD>\" + s.substring(index+1) +\n-                                      \"<\/TD>\\n\");       \/* NOTES *\/\n-                        } else {\n-                            out.write(\"<TD>\" + s + \"<\/TD>\");    \/* UNTIL *\/\n-                            out.write(\"<TD>&nbsp;<\/TD>\\n\");     \/* NOTES *\/\n-                        }\n-                    } else {\n-                        out.write(\"<TD>&nbsp;<\/TD>\");           \/* UNTIL *\/\n-                        out.write(\"<TD>&nbsp;<\/TD>\\n\");         \/* NOTES *\/\n-                    }\n-                    out.write(\"<\/TR>\\n\");\n-                }\n-                out.write(\"<\/TABLE>\\n\");\n-            }\n-            out.write(body2 + footer);\n-\n-            out.close();\n-            fw.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Generates index.html and other top-level frame files.\n-     * @param Mappings\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int generateSrc(Mappings map) {\n-        try {\n-            int len;\n-            Object o[];\n-            String outputDir = Main.getOutputDir();\n-            FileWriter fw1, fw2;\n-            BufferedWriter out1, out2;\n-\n-            \/* Whether alias list exists or not. *\/\n-            Map<String,String> a = map.getAliases();\n-            if (a == null) {\n-                Main.panic(\"Data not exist. (aliases)\");\n-                return 1;\n-            }\n-\n-            timezoneList.putAll(a);\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-            outputDir += docDir + File.separatorChar;\n-\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            \/* Creates index.html *\/\n-            fw1 = new FileWriter(outputDir + \"index.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 +\n-                       \"<FRAMESET cols=\\\"20%,80%\\\">\\n\" +\n-                       \"<FRAMESET rows=\\\"30%,70%\\\">\\n\" +\n-                       \"<FRAME src=\\\"overview-frame.html\\\" name=\\\"TimeZoneListFrame\\\">\\n\" +\n-                       \"<FRAME src=\\\"allTimeZone-frame1.html\\\" name=\\\"allTimeZoneFrame\\\">\\n\" +\n-                       \"<\/FRAMESET>\" +\n-                       \"<FRAME src=\\\"overview-summary.html\\\" name=\\\"rightFrame\\\">\\n\" +\n-                       \"<\/FRAMESET>\\n\" +\n-                       \"<NOFRAMES>\\n\" +\n-                       \"<H2>\\nFrame Alert\\n<\/H2>\\n\\n\" +\n-                       \"<P>\\n\\n\" +\n-                       \"This document is designed to be viewed using the frames feature. If you see this\\n\" +\n-                       \"message, you are using a non-frame-capable web client.\\n\" +\n-                       \"<BR>\\n\" +\n-                       \"Link to<A HREF=\\\"overview-summary.html\\\">Non-frame version.<\/A>\\n\" +\n-                       \"<\/NOFRAMES>\\n\" + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-\n-            \/* Creates overview-frame.html *\/\n-            fw1 = new FileWriter(outputDir + \"overview-frame.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n<TR>\\n\" +\n-                       \"<TD NOWRAP><FONT size=\\\"+1\\\">\\n\" +\n-                       \"<B>Java<sup><font size=-2>TM<\/font><\/sup>&nbsp;Platform<br>Standard&nbsp;Ed.<\/B><\/FONT><\/TD>\\n\" +\n-                       \"<\/TR>\\n<\/TABLE>\\n\\n\" +\n-                       \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n<TR>\\n<TD NOWRAP>\" +\n-                       \"<P>\\n<FONT size=\\\"+1\\\">\\nAll Time Zones Sorted By:<\/FONT>\\n<BR>\\n\" +\n-                       \"&nbsp;&nbsp;<A HREF=\\\"allTimeZone-frame1.html\\\" TARGET=\\\"allTimeZoneFrame\\\">GMT offsets<\/A><\/FONT>\\n<BR>\\n\" +\n-                       \"&nbsp;&nbsp;<A HREF=\\\"allTimeZone-frame2.html\\\" TARGET=\\\"allTimeZoneFrame\\\">Zone names<\/A><\/FONT>\\n<BR>\" +\n-                       \"&nbsp;&nbsp;<A HREF=\\\"allTimeZone-frame3.html\\\" TARGET=\\\"allTimeZoneFrame\\\">City names<\/A><\/FONT>\\n\" +\n-                       \"<P>\\n<FONT size=\\\"+1\\\">\\nContinents and Oceans<\/FONT>\\n<BR>\\n\");\n-\n-            for (String regionKey : regionList.keySet()) {\n-                out1.write(\"&nbsp;&nbsp;<A HREF=\\\"\" + regionList.get(regionKey) +\n-                           \"\\\" TARGET=\\\"allTimeZoneFrame\\\">\" + regionKey +\n-                           \"<\/A><BR>\\n\");\n-\n-                fw2 = new FileWriter(outputDir + regionList.get(regionKey),\n-                                     false);\n-                out2 = new BufferedWriter(fw2);\n-\n-                out2.write(header1 + new Date() + header3 + regionKey +\n-                           header4 + body1 + \"<FONT size=\\\"+1\\\"><B>\" +\n-                           regionKey + \"<\/B><\/FONT>\\n<BR>\\n<TABLE>\\n<TR>\\n<TD>\");\n-\n-                boolean found = false;\n-                for (String timezoneKey : timezoneList.keySet()) {\n-                    int regionIndex = timezoneKey.indexOf('\/');\n-                    if (regionIndex == -1 ||\n-                        !regionKey.equals(timezoneKey.substring(0, regionIndex))) {\n-                        if (found) {\n-                            break;\n-                        } else {\n-                            continue;\n-                        }\n-                    }\n-\n-                    found = true;\n-                    if (a.containsKey(timezoneKey)) {\n-                        Object realName = a.get(timezoneKey);\n-                        while (a.containsKey(realName)) {\n-                            realName = a.get(realName);\n-                        }\n-                        out2.write(timezoneKey +\n-                                   \" (alias for \" + \"<A HREF=\\\"\" +\n-                                   timezoneList.get(realName) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" +\n-                                   realName + \"<\/A>)\");\n-                    } else {\n-                        out2.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" + timezoneKey +\n-                                   \"<\/A>\");\n-                    }\n-                    out2.write(\"<BR>\\n\");\n-                }\n-                out2.write(\"<\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-                out2.close();\n-                fw2.close();\n-            }\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR><\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-\n-            \/* Creates allTimeZone-frame1.html (Sorted by GMT offsets) *\/\n-            fw1 = new FileWriter(outputDir + \"allTimeZone-frame1.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<FONT size=\\\"+1\\\"><B>Sorted by GMT offsets<\/B><\/FONT>\\n\" +\n-                       \"<BR>\\n\\n\" + \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n\" +\n-                       \"<TR>\\n<TD NOWRAP>\\n\");\n-\n-            List<Integer> roi = map.getRawOffsetsIndex();\n-            List<Set<String>> roit = map.getRawOffsetsIndexTable();\n-\n-            int index = 0;\n-            for (Integer offset : zonesByOffset.keySet()) {\n-                int off = roi.get(index);\n-                Set<String> perRO = zonesByOffset.get(offset);\n-                if (offset == off) {\n-                    \/\/ Merge aliases into zonesByOffset\n-                    perRO.addAll(roit.get(index));\n-                }\n-                index++;\n-\n-                for (String timezoneKey : perRO) {\n-                    out1.write(\"<TR>\\n<TD><FONT SIZE=\\\"-1\\\">(\" +\n-                               Time.toGMTFormat(offset.toString()) +\n-                               \")<\/FONT><\/TD>\\n<TD>\");\n-\n-                    if (a.containsKey(timezoneKey)) {\n-                        Object realName = a.get(timezoneKey);\n-                        while (a.containsKey(realName)) {\n-                            realName = a.get(realName);\n-                        }\n-                        out1.write(timezoneKey +\n-                                   \" (alias for \" + \"<A HREF=\\\"\" +\n-                                   timezoneList.get(realName) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" + realName +\n-                                   \"<\/A>)\");\n-                    } else {\n-                        out1.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" + timezoneKey +\n-                                   \"<\/A>\");\n-                    }\n-                    out1.write(\"<\/TD>\\n<\/TR>\\n\");\n-                }\n-            }\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-\n-            \/* Creates allTimeZone-frame2.html (Sorted by zone names) *\/\n-            fw1 = new FileWriter(outputDir + \"allTimeZone-frame2.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<FONT size=\\\"+1\\\"><B>Sorted by zone names<\/B><\/FONT>\\n\" +\n-                       \"<BR>\\n\\n\" + \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n\" +\n-                       \"<TR>\\n<TD NOWRAP>\\n\");\n-            o = timezoneList.keySet().toArray();\n-            len = timezoneList.size();\n-            for (int i = 0; i < len; i++) {\n-                Object timezoneKey = o[i];\n-                if (a.containsKey(timezoneKey)) {\n-                    Object realName = a.get(timezoneKey);\n-                    while (a.containsKey(realName)) {\n-                        realName = a.get(realName);\n-                    }\n-                    out1.write(timezoneKey +\n-                               \" (alias for \" +\n-                               \"<A HREF=\\\"\" + timezoneList.get(realName) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + realName +\n-                               \"<\/A>)\");\n-                } else {\n-                    out1.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + timezoneKey +\n-                               \"<\/A>\");\n-                }\n-                out1.write(\"<BR> \\n\");\n-            }\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-            \/* Creates allTimeZone-frame3.html (Sorted by city names) *\/\n-            fw1 = new FileWriter(outputDir + \"allTimeZone-frame3.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<FONT size=\\\"+1\\\"><B>Sorted by city names<\/B><\/FONT>\\n\" +\n-                       \"<BR>\\n\\n\" + \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n\" +\n-                       \"<TR>\\n<TD NOWRAP>\\n\");\n-\n-            Set<String> aliasSet = a.keySet();\n-            len = aliasSet.size();\n-            String aliasNames[] = aliasSet.toArray(new String[0]);\n-            for (int i = 0; i < len; i++) {\n-                displayNameList.put(transform(aliasNames[i]),\n-                                    aliasNames[i]);\n-            }\n-\n-            o = displayNameList.keySet().toArray();\n-            len = displayNameList.size();\n-            for (int i = 0; i < len; i++) {\n-                Object displayName = o[i];\n-                Object timezoneKey = displayNameList.get(o[i]);\n-                if (a.containsKey(timezoneKey)) {\n-                    Object realName = a.get(timezoneKey);\n-                    while (a.containsKey(realName)) {\n-                        realName = a.get(realName);\n-                    }\n-                    out1.write(displayName +\n-                               \" (alias for \" +\n-                               \"<A HREF=\\\"\" + timezoneList.get(realName) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + realName +\n-                               \"<\/A>)\");\n-                } else {\n-                    out1.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + displayName +\n-                               \"<\/A>\");\n-                }\n-                out1.write(\"<BR> \\n\");\n-            }\n-\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-            \/* Creates overview-summary.html *\/\n-            fw1 = new FileWriter(outputDir + \"overview-summary.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<p>This is the list of time zones generated from <B>\" +\n-                       Main.getVersionName() + \"<\/B> for Java Platform, \" +\n-                       \"Standard Edition. The source code can be obtained \" +\n-                       \"from ftp site <a href=\\\"ftp:\/\/elsie.nci.nih.gov\/pub\/\\\">\" +\n-                       \"ftp:\/\/elsie.nci.nih.gov\/pub\/<\/a>. A total of <B>\" +\n-                       len +\n-                       \"<\/B> time zones and aliases are supported \" +\n-                       \"in this edition. For the \" +\n-                       \"format of rules and zones, refer to the zic \" +\n-                       \"(zoneinfo compiler) man page on \" +\n-                       \"Solaris or Linux.<\/p>\\n\" +\n-                       \"<p>Note that the time zone data is not \" +\n-                       \"a public interface of the Java Platform. No \" +\n-                       \"applications should rely on the time zone data of \" +\n-                       \"this document. Time zone names and data \" +\n-                       \"may change without any prior notice.<\/p>\\n\" +\n-                       body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    String transform(String s) {\n-        int index = s.lastIndexOf(\"\/\");\n-\n-        \/* If the string doesn't include any delimiter, return *\/\n-        if (index == -1) {\n-            return s;\n-        }\n-\n-        int lastIndex = index;\n-        String str = s.substring(index+1);\n-        do {\n-            index = s.substring(0, lastIndex).lastIndexOf('\/');\n-            str += \", \" + s.substring(index+1, lastIndex);\n-            lastIndex = index;\n-        } while (index > -1);\n-\n-        return str;\n-    }\n-\n-    static class LatitudeAndLongitude {\n-\n-        private int latDeg, latMin, latSec, longDeg, longMin, longSec;\n-\n-        LatitudeAndLongitude(String s) {\n-            try {\n-                \/\/ First of all, check the string has the correct format:\n-                \/\/    either +-DDMM+-DDDMM or +-DDMMSS+-DDDMMSS\n-\n-                if (!s.startsWith(\"+\") && !s.startsWith(\"-\")) {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-                int index;\n-                if (((index = s.lastIndexOf(\"+\")) <= 0) &&\n-                    ((index = s.lastIndexOf(\"-\")) <= 0)) {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-\n-                if (index == 5) {\n-                    latDeg = Integer.parseInt(s.substring(1, 3));\n-                    latMin = Integer.parseInt(s.substring(3, 5));\n-                    latSec = 0;\n-                } else if (index == 7) {\n-                    latDeg = Integer.parseInt(s.substring(1, 3));\n-                    latMin = Integer.parseInt(s.substring(3, 5));\n-                    latSec = Integer.parseInt(s.substring(5, 7));\n-                } else {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-                if (s.startsWith(\"-\")){\n-                        latDeg = -latDeg;\n-                        latMin = -latMin;\n-                        latSec = -latSec;\n-                }\n-\n-                int len = s.length();\n-                if (index == 5 && len == 11) {\n-                    longDeg = Integer.parseInt(s.substring(index+1, index+4));\n-                    longMin = Integer.parseInt(s.substring(index+4, index+6));\n-                    longSec = 0;\n-                } else if (index == 7 && len == 15) {\n-                    longDeg = Integer.parseInt(s.substring(index+1, index+4));\n-                    longMin = Integer.parseInt(s.substring(index+4, index+6));\n-                    longSec = Integer.parseInt(s.substring(index+6, index+8));\n-                } else {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-                if (s.charAt(index) == '-'){\n-                        longDeg = -longDeg;\n-                        longMin = -longMin;\n-                        longSec = -longSec;\n-                }\n-            } catch(Exception e) {\n-                Main.warning(\"LatitudeAndLongitude() Parse error: \" + s);\n-            }\n-        }\n-\n-        int getLatDeg() {\n-            return latDeg;\n-        }\n-\n-        int getLatMin() {\n-            return latMin;\n-        }\n-\n-        int getLatSec() {\n-            return latSec;\n-        }\n-\n-        int getLongDeg() {\n-            return longDeg;\n-        }\n-\n-        int getLongMin() {\n-            return longMin;\n-        }\n-\n-        int getLongSec() {\n-            return longSec;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/GenDoc.java","additions":0,"deletions":776,"binary":false,"changes":776,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Main class for the javazic time zone data compiler.\n- *\n- * @since 1.4\n- *\/\n-public class Main {\n-\n-    private static boolean verbose = false;\n-    static boolean outputDoc = false;\n-\n-    private List<String> ziFiles = new ArrayList<String>();\n-    private static String zoneNamesFile = null;\n-    private static String versionName = \"unknown\";\n-    private static String outputDir = \"zoneinfo\";\n-    private static String mapFile = null;\n-\n-    \/**\n-     * Parses the specified arguments and sets up the variables.\n-     * @param argv the arguments\n-     *\/\n-    void processArgs(String[] argv) {\n-        for (int i = 0; i < argv.length; i++) {\n-            String arg = argv[i];\n-            if (arg.startsWith(\"-h\")) {\n-                usage();\n-                System.exit(0);\n-            } else if (arg.equals(\"-d\")) {\n-                outputDir = argv[++i];\n-            } else if (arg.equals(\"-v\")) {\n-                verbose = true;\n-            } else if (arg.equals(\"-V\")) {\n-                versionName = argv[++i];\n-            } else if (arg.equals(\"-doc\")) {\n-                outputDoc = true;\n-            } else if (arg.equals(\"-map\")) {\n-                outputDoc = true;\n-                mapFile = argv[++i];\n-            } else if (arg.equals(\"-f\")) {\n-                zoneNamesFile = argv[++i];\n-            } else if (arg.equals(\"-S\")) {\n-                try {\n-                    Zoneinfo.setYear(Integer.parseInt(argv[++i]));\n-                } catch (Exception e) {\n-                    error(\"invalid year: \" + argv[i]);\n-                    usage();\n-                    System.exit(1);\n-                }\n-            } else {\n-                boolean isStartYear = arg.equals(\"-s\");\n-                if (isStartYear || arg.equals(\"-e\")) {\n-                    try {\n-                        int year = Integer.parseInt(argv[++i]);\n-                        if (isStartYear) {\n-                            Zoneinfo.setStartYear(year);\n-                        } else {\n-                            Zoneinfo.setEndYear(year);\n-                        }\n-                    } catch (Exception e) {\n-                        error(\"invalid year: \" + argv[i]);\n-                        usage();\n-                        System.exit(1);\n-                    }\n-                } else {\n-                    \/\/ the rest of args are zoneinfo source files\n-                    while (i < argv.length) {\n-                        ziFiles.add(argv[i++]);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Parses zoneinfo source files\n-     *\/\n-    int compile() {\n-        int nFiles = ziFiles.size();\n-        int status = 0;\n-        Mappings maps = new Mappings();\n-        BackEnd backend = BackEnd.getBackEnd();\n-\n-        for (int i = 0; i < nFiles; i++) {\n-            Zoneinfo frontend = Zoneinfo.parse(ziFiles.get(i));\n-\n-            for (String key : frontend.getZones().keySet()) {\n-                info(key);\n-\n-                Timezone tz = frontend.phase2(key);\n-                status |= backend.processZoneinfo(tz);\n-            }\n-\n-            maps.add(frontend);\n-        }\n-\n-        \/\/ special code for dealing with the conflicting name \"MET\"\n-        Zone.addMET();\n-\n-        maps.resolve();\n-\n-        status |= backend.generateSrc(maps);\n-\n-        return status;\n-    }\n-\n-    public static void main(String[] argv) {\n-        Main zic = new Main();\n-\n-        \/*\n-         * Parse args\n-         *\/\n-        zic.processArgs(argv);\n-\n-        \/*\n-         * Read target zone names\n-         *\/\n-        if (zoneNamesFile != null) {\n-            Zone.readZoneNames(zoneNamesFile);\n-        }\n-\n-        zic.compile();\n-    }\n-\n-    void usage() {\n-        System.err.println(\"Usage: javazic [options] file...\\n\"+\n-                           \"         -f namefile  file containing zone names\\n\"+\n-                           \"                      to be generated (ie, generating subset)\\n\"+\n-                           \"         -d dir       output directory\\n\"+\n-                           \"         -v           verbose\\n\"+\n-                           \"         -V datavers  specifies the tzdata version string\\n\"+\n-                           \"                      (eg, \\\"tzdata2000g\\\")\"+\n-                           \"         -S year      output only SimleTimeZone data of that year\\n\"+\n-                           \"         -s year      start year (default: 1900)\\n\"+\n-                           \"         -e year      end year (default: 2037)\\n\"+\n-                           \"         -doc         generates HTML documents\\n\"+\n-                           \"         -map mapfile generates HTML documents with map information\\n\"+\n-                           \"         file...      zoneinfo source file(s)\");\n-    }\n-\n-    \/**\n-     * @return the output directory path name\n-     *\/\n-    static String getOutputDir() {\n-        return outputDir;\n-    }\n-\n-    \/**\n-     * @return the map file's path and name\n-     *\/\n-    static String getMapFile() {\n-        return mapFile;\n-    }\n-\n-    \/**\n-     * Returns the time zone data version string specified by the -V\n-     * option. If it is not specified, \"unknown\" is returned.\n-     * @return the time zone data version string\n-     *\/\n-    static String getVersionName() {\n-        return versionName;\n-    }\n-\n-    \/**\n-     * Prints out the specified fatal error message and calls {@link\n-     * java.lang.System#exit System.exit(1)}.\n-     * @param msg the fatal error message\n-     *\/\n-    static void panic(String msg) {\n-        printMessage(\"fatal error\", msg);\n-        System.exit(1);\n-    }\n-\n-    \/**\n-     * Prints out the specified error message.\n-     * @param msg the error message\n-     *\/\n-    static void error(String msg) {\n-        printMessage(\"error\", msg);\n-    }\n-\n-    \/**\n-     * Prints out the specified warning message.\n-     * @param msg the warning message\n-     *\/\n-    static void warning(String msg) {\n-        printMessage(\"warning\", msg);\n-    }\n-\n-    \/**\n-     * Prints out the informative message.\n-     * @param msg the informative message\n-     *\/\n-    static void info(String msg) {\n-        if (verbose) {\n-            printMessage(null, msg);\n-        }\n-    }\n-\n-    private static void printMessage(String type, String msg) {\n-        if (type != null) {\n-            type += \": \";\n-        } else {\n-            type = \"\";\n-        }\n-        System.err.println(\"javazic: \" + type + msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Main.java","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -1,193 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.util.ArrayList;\n-import  java.util.HashMap;\n-import  java.util.LinkedList;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-import  java.util.TreeMap;\n-import  java.util.TreeSet;\n-\n-\/**\n- * <code>Mappings<\/code> generates two Maps and a List which are used by\n- * javazic BackEnd.\n- *\n- * @since 1.4\n- *\/\n-class Mappings {\n-    \/\/ All aliases specified by Link statements. It's alias name to\n-    \/\/ real name mappings.\n-    private Map<String,String> aliases;\n-\n-    private List<Integer> rawOffsetsIndex;\n-\n-    private List<Set<String>> rawOffsetsIndexTable;\n-\n-    \/\/ Zone names to be excluded from rawOffset table. Those have GMT\n-    \/\/ offsets to change some future time.\n-    private List<String> excludeList;\n-\n-    \/**\n-     * Constructor creates some necessary instances.\n-     *\/\n-    Mappings() {\n-        aliases = new TreeMap<String,String>();\n-        rawOffsetsIndex = new LinkedList<Integer>();\n-        rawOffsetsIndexTable = new LinkedList<Set<String>>();\n-    }\n-\n-    \/**\n-     * Generates aliases and rawOffsets tables.\n-     * @param zi a Zoneinfo containing Zones\n-     *\/\n-    void add(Zoneinfo zi) {\n-        Map<String,Zone> zones = zi.getZones();\n-\n-        for (String zoneName : zones.keySet()) {\n-            Zone zone = zones.get(zoneName);\n-            String zonename = zone.getName();\n-            int rawOffset = zone.get(zone.size()-1).getGmtOffset();\n-\n-            \/\/ If the GMT offset of this Zone will change in some\n-            \/\/ future time, this Zone is added to the exclude list.\n-            boolean isExcluded = false;\n-            for (int i = 0; i < zone.size(); i++) {\n-                ZoneRec zrec = zone.get(i);\n-                if ((zrec.getGmtOffset() != rawOffset)\n-                    && (zrec.getUntilTime(0) > Time.getCurrentTime())) {\n-                    if (excludeList == null) {\n-                        excludeList = new ArrayList<String>();\n-                    }\n-                    excludeList.add(zone.getName());\n-                    isExcluded = true;\n-                    break;\n-                }\n-            }\n-\n-            if (!rawOffsetsIndex.contains(new Integer(rawOffset))) {\n-                \/\/ Find the index to insert this raw offset zones\n-                int n = rawOffsetsIndex.size();\n-                int i;\n-                for (i = 0; i < n; i++) {\n-                    if (rawOffsetsIndex.get(i) > rawOffset) {\n-                        break;\n-                    }\n-                }\n-                rawOffsetsIndex.add(i, rawOffset);\n-\n-                Set<String> perRawOffset = new TreeSet<String>();\n-                if (!isExcluded) {\n-                    perRawOffset.add(zonename);\n-                }\n-                rawOffsetsIndexTable.add(i, perRawOffset);\n-            } else if (!isExcluded) {\n-                int i = rawOffsetsIndex.indexOf(new Integer(rawOffset));\n-                Set<String> perRawOffset = rawOffsetsIndexTable.get(i);\n-                perRawOffset.add(zonename);\n-            }\n-        }\n-\n-        Map<String,String> a = zi.getAliases();\n-        \/\/ If there are time zone names which refer to any of the\n-        \/\/ excluded zones, add those names to the excluded list.\n-        if (excludeList != null) {\n-            for (String zoneName : a.keySet()) {\n-                String realname = a.get(zoneName);\n-                if (excludeList.contains(realname)) {\n-                    excludeList.add(zoneName);\n-                }\n-            }\n-        }\n-        aliases.putAll(a);\n-    }\n-\n-    \/**\n-     * Adds valid aliases to one of per-RawOffset table and removes\n-     * invalid aliases from aliases List. Aliases referring to\n-     * excluded zones are not added to a per-RawOffset table.\n-     *\/\n-    void resolve() {\n-        int index = rawOffsetsIndexTable.size();\n-        List<String> toBeRemoved = new ArrayList<String>();\n-        for (String key : aliases.keySet()) {\n-            boolean validname = false;\n-            for (int j = 0; j < index; j++) {\n-                Set<String> perRO = rawOffsetsIndexTable.get(j);\n-                boolean isExcluded = (excludeList == null) ?\n-                                        false : excludeList.contains(key);\n-\n-                if ((perRO.contains(aliases.get(key)) || isExcluded)\n-                    && Zone.isTargetZone(key)) {\n-                    validname = true;\n-                    if (!isExcluded) {\n-                        perRO.add(key);\n-                        Main.info(\"Alias <\"+key+\"> added to the list.\");\n-                    }\n-                    break;\n-                }\n-            }\n-\n-            if (!validname) {\n-                Main.info(\"Alias <\"+key+\"> removed from the list.\");\n-                toBeRemoved.add(key);\n-            }\n-        }\n-\n-        \/\/ Remove zones, if any, from the list.\n-        for (String key : toBeRemoved) {\n-            aliases.remove(key);\n-        }\n-        \/\/ Eliminate any alias-to-alias mappings. For example, if\n-        \/\/ there are A->B and B->C, A->B is changed to A->C.\n-        Map<String, String> newMap = new HashMap<String, String>();\n-        for (String key : aliases.keySet()) {\n-            String realid = aliases.get(key);\n-            String leaf = realid;\n-            while (aliases.get(leaf) != null) {\n-                leaf = aliases.get(leaf);\n-            }\n-            if (!realid.equals(leaf)) {\n-                newMap.put(key, leaf);\n-            }\n-        }\n-        aliases.putAll(newMap);\n-    }\n-\n-    Map<String,String> getAliases() {\n-        return(aliases);\n-    }\n-\n-    List<Integer> getRawOffsetsIndex() {\n-        return(rawOffsetsIndex);\n-    }\n-\n-    List<Set<String>> getRawOffsetsIndexTable() {\n-        return(rawOffsetsIndexTable);\n-    }\n-\n-    List<String> getExcludeList() {\n-        return excludeList;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Mappings.java","additions":0,"deletions":193,"binary":false,"changes":193,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Month enum handles month related manipulation.\n- *\n- * @since 1.4\n- *\/\n-enum Month {\n-    JANUARY(\"Jan\"),\n-    FEBRUARY(\"Feb\"),\n-    MARCH(\"Mar\"),\n-    APRIL(\"Apr\"),\n-    MAY(\"May\"),\n-    JUNE(\"Jun\"),\n-    JULY(\"Jul\"),\n-    AUGUST(\"Aug\"),\n-    SEPTEMBER(\"Sep\"),\n-    OCTOBER(\"Oct\"),\n-    NOVEMBER(\"Nov\"),\n-    DECEMBER(\"Dec\");\n-\n-    private final String abbr;\n-\n-    private Month(String abbr) {\n-        this.abbr = abbr;\n-    }\n-\n-    int value() {\n-        return ordinal() + 1;\n-    }\n-\n-    \/**\n-     * Parses the specified string as a month abbreviation.\n-     * @param name the month abbreviation\n-     * @return the Month value\n-     *\/\n-    static Month parse(String name) {\n-        int len = name.length();\n-\n-        if (name.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n-        if (name.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n-        if (name.regionMatches(true, 0, \"March\", 0, len)) return Month.MARCH;\n-        if (name.regionMatches(true, 0, \"April\", 0, len)) return Month.APRIL;\n-        if (name.regionMatches(true, 0, \"May\", 0, len)) return Month.MAY;\n-        if (name.regionMatches(true, 0, \"June\", 0, len)) return Month.JUNE;\n-        if (name.regionMatches(true, 0, \"July\", 0, len)) return Month.JULY;\n-        if (name.regionMatches(true, 0, \"August\", 0, len)) return Month.AUGUST;\n-        if (name.regionMatches(true, 0, \"September\", 0, len)) return Month.SEPTEMBER;\n-        if (name.regionMatches(true, 0, \"October\", 0, len)) return Month.OCTOBER;\n-        if (name.regionMatches(true, 0, \"November\", 0, len)) return Month.NOVEMBER;\n-        if (name.regionMatches(true, 0, \"December\", 0, len)) return Month.DECEMBER;\n-\n-        throw new IllegalArgumentException(\"Unknown month: \" + name);\n-    }\n-\n-    \/**\n-     * @param month the nunmth number (1-based)\n-     * @return the month name in uppercase of the specified month\n-     *\/\n-    static String toString(int month) {\n-        if (month >= JANUARY.value() && month <= DECEMBER.value()) {\n-            return \"Calendar.\" + Month.values()[month - 1];\n-        }\n-        throw new IllegalArgumentException(\"wrong month number: \" + month);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Month.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * Rule manipulates Rule records.\n- *\n- * @since 1.4\n- *\/\n-class Rule {\n-\n-    private List<RuleRec> list;\n-    private String name;\n-\n-    \/**\n-     * Constructs a Rule which consists of a Rule record list. The\n-     * specified name is given to this Rule.\n-     * @param name the Rule name\n-     *\/\n-    Rule(String name) {\n-        this.name = name;\n-        list = new ArrayList<RuleRec>();\n-    }\n-\n-    \/**\n-     * Added a RuleRec to the Rule record list.\n-     *\/\n-    void add(RuleRec rec) {\n-        list.add(rec);\n-    }\n-\n-    \/**\n-     * @return the Rule name\n-     *\/\n-    String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Gets all rule records that cover the given year.\n-     *\n-     * @param year the year number for which the rule is applicable.\n-     * @return rules in List that are collated in time. If no rule is found, an empty\n-     * List is returned.\n-     *\/\n-    List<RuleRec> getRules(int year) {\n-        List<RuleRec> rules = new ArrayList<RuleRec>(3);\n-        for (RuleRec rec : list) {\n-            if (year >= rec.getFromYear() && year <= rec.getToYear()) {\n-                if ((rec.isOdd() && year % 2 == 0) || (rec.isEven() && year % 2 == 1))\n-                    continue;\n-                rules.add(rec);\n-            }\n-        }\n-        int n = rules.size();\n-        if (n <= 1) {\n-            return rules;\n-        }\n-        if (n == 2) {\n-            RuleRec rec1 = rules.get(0);\n-            RuleRec rec2 = rules.get(1);\n-            if (rec1.getMonthNum() > rec2.getMonthNum()) {\n-                rules.set(0, rec2);\n-                rules.set(1, rec1);\n-            } else if (rec1.getMonthNum() == rec2.getMonthNum()) {\n-                \/\/ TODO: it's not accurate to ignore time types (STD, WALL, UTC)\n-                long t1 = Time.getLocalTime(year, rec1.getMonth(),\n-                                            rec1.getDay(), rec1.getTime().getTime());\n-                long t2 = Time.getLocalTime(year, rec2.getMonth(),\n-                                            rec2.getDay(), rec2.getTime().getTime());\n-                if (t1 > t2) {\n-                    rules.set(0, rec2);\n-                    rules.set(1, rec1);\n-                }\n-            }\n-            return rules;\n-        }\n-\n-        final int y = year;\n-        RuleRec[] recs = new RuleRec[rules.size()];\n-        rules.toArray(recs);\n-\n-        Arrays.sort(recs, new Comparator<RuleRec>() {\n-                public int compare(RuleRec r1, RuleRec r2) {\n-                    int n = r1.getMonthNum() - r2.getMonthNum();\n-                    if (n != 0) {\n-                        return n;\n-                    }\n-                    \/\/ TODO: it's not accurate to ignore time types (STD, WALL, UTC)\n-                    long t1 = Time.getLocalTime(y, r1.getMonth(),\n-                                                r1.getDay(), r1.getTime().getTime());\n-                    long t2 = Time.getLocalTime(y, r2.getMonth(),\n-                                                r2.getDay(), r2.getTime().getTime());\n-                    return Long.compare(t1, t2);\n-                }\n-                public boolean equals(Object o) {\n-                    return this == o;\n-                }\n-            });\n-        rules.clear();\n-        for (int i = 0; i < n; i++) {\n-            if (i != 0 && recs[i -1].getSave() == recs[i].getSave()) {\n-                \/\/ we have two recs back to back with same saving for the same year.\n-                if (recs[i].isLastRule()) {\n-                    continue;\n-                } else if (recs[i - 1].isLastRule()) {\n-                    rules.remove(rules.size() - 1);\n-                }\n-            }\n-            rules.add(recs[i]);\n-        }\n-        return rules;\n-    }\n-\n-    \/**\n-     * Gets rule records that have either \"max\" or cover the endYear\n-     * value in its DST schedule.\n-     *\n-     * @return rules that contain last DST schedule. An empty\n-     * ArrayList is returned if no last rules are found.\n-     *\/\n-    List<RuleRec> getLastRules() {\n-        RuleRec start = null;\n-        RuleRec end = null;\n-\n-        for (int i = 0; i < list.size(); i++) {\n-            RuleRec rec = list.get(i);\n-            if (rec.isLastRule()) {\n-                if (rec.getSave() > 0) {\n-                    start = rec;\n-                } else {\n-                    end = rec;\n-                }\n-            }\n-        }\n-        if (start == null || end == null) {\n-            int endYear = Zoneinfo.getEndYear();\n-            for (int i  = 0; i < list.size(); i++) {\n-                RuleRec rec = list.get(i);\n-                if (endYear >= rec.getFromYear() && endYear <= rec.getToYear()) {\n-                    if (start == null && rec.getSave() > 0) {\n-                        start = rec;\n-                    } else {\n-                        if (end == null && rec.getSave() == 0) {\n-                            end = rec;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        List<RuleRec> r = new ArrayList<RuleRec>(2);\n-        if (start == null || end == null) {\n-            if (start != null || end != null) {\n-                Main.warning(\"found last rules for \"+name+\" inconsistent.\");\n-            }\n-            return r;\n-        }\n-\n-        r.add(start);\n-        r.add(end);\n-        return r;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Rule.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * RuleDay class represents the value of the \"ON\" field.  The day of\n- * week values start from 1 following the {@link java.util.Calendar}\n- * convention.\n- *\n- * @since 1.4\n- *\/\n-class RuleDay {\n-    private String dayName = null;\n-    private DayOfWeek dow;\n-    private boolean lastOne = false;\n-    private int soonerOrLater = 0;\n-    private int thanDayOfMonth; \/\/ day of month (e.g., 8 for \"Sun>=8\")\n-\n-    RuleDay() {\n-    }\n-\n-    RuleDay(int day) {\n-        thanDayOfMonth = day;\n-    }\n-\n-    int getDay() {\n-        return thanDayOfMonth;\n-    }\n-\n-    \/**\n-     * @return the day of week value (1-based)\n-     *\/\n-    int getDayOfWeekNum() {\n-        return dow.value();\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents the last day of\n-     * week. (e.g., lastSun).\n-     *\/\n-    boolean isLast() {\n-        return lastOne;\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents the day of week on or\n-     * later than (after) the {@link #getDay}. (e.g., Sun>=1)\n-     *\/\n-    boolean isLater() {\n-        return soonerOrLater > 0;\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents the day of week on or\n-     * earlier than (before) the {@link #getDay}. (e.g., Sun<=15)\n-     *\/\n-    boolean isEarlier() {\n-        return soonerOrLater < 0;\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents an exact day.\n-     *\/\n-    boolean isExact() {\n-        return soonerOrLater == 0;\n-    }\n-\n-    \/**\n-     * Parses the \"ON\" field and constructs a RuleDay.\n-     * @param day an \"ON\" field string (e.g., \"Sun>=1\")\n-     * @return a RuleDay representing the given \"ON\" field\n-     *\/\n-    static RuleDay parse(String day) {\n-        RuleDay d = new RuleDay();\n-        if (day.startsWith(\"last\")) {\n-            d.lastOne = true;\n-            d.dayName = day.substring(4);\n-            d.dow = getDOW(d.dayName);\n-        } else {\n-            int index;\n-            if ((index = day.indexOf(\">=\")) != -1) {\n-                d.dayName = day.substring(0, index);\n-                d.dow = getDOW(d.dayName);\n-                d.soonerOrLater = 1; \/\/ greater or equal\n-                d.thanDayOfMonth = Integer.parseInt(day.substring(index+2));\n-            } else if ((index = day.indexOf(\"<=\")) != -1) {\n-                d.dayName = day.substring(0, index);\n-                d.dow = getDOW(d.dayName);\n-                d.soonerOrLater = -1; \/\/ less or equal\n-                d.thanDayOfMonth = Integer.parseInt(day.substring(index+2));\n-            } else {\n-                \/\/ it should be an integer value.\n-                d.thanDayOfMonth = Integer.parseInt(day);\n-            }\n-        }\n-        return d;\n-    }\n-\n-    \/**\n-     * Converts this RuleDay to the SimpleTimeZone day rule.\n-     * @return the converted SimpleTimeZone day rule\n-     *\/\n-    int getDayForSimpleTimeZone() {\n-        if (isLast()) {\n-            return -1;\n-        }\n-        return isEarlier() ? -getDay() : getDay();\n-    }\n-\n-    \/**\n-     * Converts this RuleDay to the SimpleTimeZone day-of-week rule.\n-     * @return the SimpleTimeZone day-of-week rule value\n-     *\/\n-    int getDayOfWeekForSimpleTimeZoneInt() {\n-        if (isEarlier() || isLater()) {\n-            return -getDayOfWeekNum();\n-        }\n-        return isLast() ? getDayOfWeekNum() : 0;\n-    }\n-\n-    \/**\n-     * @return the string representation of the {@link\n-     * #getDayOfWeekForSimpleTimeZoneInt} value\n-     *\/\n-    String getDayOfWeekForSimpleTimeZone() {\n-        int d = getDayOfWeekForSimpleTimeZoneInt();\n-        if (d == 0) {\n-            return \"0\";\n-        }\n-        String sign = \"\";\n-        if (d < 0) {\n-            sign = \"-\";\n-            d = -d;\n-        }\n-        return sign + toString(d);\n-    }\n-\n-    private static DayOfWeek getDOW(String name) {\n-        int len = name.length();\n-\n-        if (name.regionMatches(true, 0, \"Monday\", 0, len)) return DayOfWeek.MONDAY;\n-        if (name.regionMatches(true, 0, \"Tuesday\", 0, len)) return DayOfWeek.TUESDAY;\n-        if (name.regionMatches(true, 0, \"Wednesday\", 0, len)) return DayOfWeek.WEDNESDAY;\n-        if (name.regionMatches(true, 0, \"Thursday\", 0, len)) return DayOfWeek.THURSDAY;\n-        if (name.regionMatches(true, 0, \"Friday\", 0, len)) return DayOfWeek.FRIDAY;\n-        if (name.regionMatches(true, 0, \"Saturday\", 0, len)) return DayOfWeek.SATURDAY;\n-        if (name.regionMatches(true, 0, \"Sunday\", 0, len)) return DayOfWeek.SUNDAY;\n-\n-        throw new IllegalArgumentException(\"Unknown day-of-week: \" + name);\n-    }\n-\n-    \/**\n-     * Converts the specified day of week value to the day-of-week\n-     * name defined in {@link java.util.Calendar}.\n-     * @param dow 1-based day of week value\n-     * @return the Calendar day of week name with \"Calendar.\" prefix.\n-     * @throws IllegalArgumentException if the specified dow value is out of range.\n-     *\/\n-    static String toString(int dow) {\n-        if (dow >= DayOfWeek.SUNDAY.value() && dow <= DayOfWeek.SATURDAY.value()) {\n-            return \"Calendar.\" + DayOfWeek.values()[dow - 1];\n-        }\n-        throw new IllegalArgumentException(\"wrong Day_of_Week number: \" + dow);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleDay.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,229 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.StringTokenizer;\n-\n-\/**\n- * RuleRec class represents one record of the Rule set.\n- *\n- * @since 1.4\n- *\/\n-class RuleRec {\n-    private int fromYear;\n-    private int toYear;\n-    private String type;\n-    private Month inMonth;\n-    private RuleDay onDay;\n-    private Time atTime;\n-    private int save;\n-    private String letters;\n-    private String line;\n-    private boolean isLastRule;\n-\n-    int getFromYear() {\n-        return fromYear;\n-    }\n-\n-    int getToYear() {\n-        return toYear;\n-    }\n-\n-    Month getMonth() {\n-        return inMonth;\n-    }\n-\n-    int getMonthNum() {\n-        return inMonth.value();\n-    }\n-\n-    RuleDay getDay() {\n-        return onDay;\n-    }\n-\n-    Time getTime() {\n-        return atTime;\n-    }\n-\n-    int getSave() {\n-        return save;\n-    }\n-\n-    String getLine() {\n-        return line;\n-    }\n-\n-    \/**\n-     * Sets the line from the text file.\n-     * @param line the text of the line\n-     *\/\n-    void setLine(String line) {\n-        this.line = line;\n-    }\n-\n-    \/**\n-     * @return true if the rule type is \"odd\".\n-     *\/\n-    boolean isOdd() {\n-        return \"odd\".equals(type);\n-    }\n-\n-    \/**\n-     * @return true if the rule type is \"even\".\n-     *\/\n-    boolean isEven() {\n-        return \"even\".equals(type);\n-    }\n-\n-    \/**\n-     * Determines if this rule record is the last DST schedule rule.\n-     *\n-     * @return true if this rule record has \"max\" as TO (year).\n-     *\/\n-    boolean isLastRule() {\n-        return isLastRule;\n-    }\n-\n-    \/**\n-     * Determines if the unadjusted until time of the specified ZoneRec\n-     * is the same as the transition time of this rule in the same\n-     * year as the ZoneRec until year.\n-     *\n-     * @param zrec ZoneRec to compare to\n-     * @param save the amount of daylight saving in milliseconds\n-     * @param gmtOffset the GMT offset value in milliseconds\n-     * @return true if the unadjusted until time is the same as rule's\n-     * transition time.\n-     *\/\n-    boolean isSameTransition(ZoneRec zrec, int save, int gmtOffset) {\n-        long    until, transition;\n-\n-        if (zrec.getUntilTime().getType() != atTime.getType()) {\n-            until = zrec.getLocalUntilTime(save, gmtOffset);\n-            transition = Time.getLocalTime(zrec.getUntilYear(),\n-                                           getMonth(),\n-                                           getDay(),\n-                                           save,\n-                                           gmtOffset,\n-                                           atTime);\n-        } else {\n-            until = zrec.getLocalUntilTime();\n-            transition = Time.getLocalTime(zrec.getUntilYear(),\n-                                           getMonth(),\n-                                           getDay(),\n-                                           atTime.getTime());\n-        }\n-\n-        return until == transition;\n-    }\n-\n-    \/**\n-     * Parses a Rule line and returns a RuleRec object.\n-     *\n-     * @param tokens a StringTokenizer object that should contain a\n-     * token for the \"FROM\" field and the rest.\n-     * @return a RuleRec object.\n-     *\/\n-    static RuleRec parse(StringTokenizer tokens) {\n-        RuleRec rec = new RuleRec();\n-        try {\n-            \/\/ FROM\n-            String token = tokens.nextToken();\n-            try {\n-                rec.fromYear = Integer.parseInt(token);\n-            } catch (NumberFormatException e) {\n-                \/\/ it's not integer\n-                if (\"min\".equals(token) || \"minimum\".equals(token)) {\n-                    rec.fromYear = Zoneinfo.getMinYear();\n-                } else if (\"max\".equals(token) || \"maximum\".equals(token)) {\n-                    rec.fromYear = Zoneinfo.getMaxYear();\n-                } else {\n-                    Main.panic(\"invalid year value: \"+token);\n-                }\n-            }\n-\n-            \/\/ TO\n-            token = tokens.nextToken();\n-            rec.isLastRule = false;\n-            try {\n-                rec.toYear = Integer.parseInt(token);\n-            } catch (NumberFormatException e) {\n-                \/\/ it's not integer\n-                int len = token.length();\n-                if (token.regionMatches(true, 0, \"minimum\", 0, len)) {\n-                    rec.fromYear = Zoneinfo.getMinYear();\n-                } else if (token.regionMatches(true, 0, \"maximum\", 0, len)) {\n-                    rec.toYear = Integer.MAX_VALUE;\n-                    rec.isLastRule = true;\n-                } else if (token.regionMatches(true, 0, \"only\", 0, len)) {\n-                    rec.toYear = rec.fromYear;\n-                } else {\n-                    Main.panic(\"invalid year value: \"+token);\n-                }\n-            }\n-\n-            \/\/ TYPE\n-            rec.type = tokens.nextToken();\n-\n-            \/\/ IN\n-            rec.inMonth = Month.parse(tokens.nextToken());\n-\n-            \/\/ ON\n-            rec.onDay = RuleDay.parse(tokens.nextToken());\n-\n-            \/\/ AT\n-            rec.atTime = Time.parse(tokens.nextToken());\n-\n-            \/\/ SAVE\n-            rec.save = (int) Time.parse(tokens.nextToken()).getTime();\n-\n-            \/\/ LETTER\/S\n-            rec.letters = tokens.nextToken();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-        return rec;\n-    }\n-\n-    \/**\n-     * Calculates the transition time of the given year under this rule.\n-     * @param year the year value\n-     * @param gmtOffset the GMT offset value in milliseconds\n-     * @param save the amount of daylight save time\n-     * @return the transition time in milliseconds of the given year in UTC.\n-     *\/\n-    long getTransitionTime(int year, int gmtOffset, int save) {\n-        long time = Time.getLocalTime(year, getMonth(),\n-                                      getDay(), atTime.getTime());\n-        if (atTime.isSTD()) {\n-            time -= gmtOffset;\n-        } else if (atTime.isWall()) {\n-            time -= gmtOffset + save;\n-        }\n-        return time;\n-    }\n-\n-    private static int getInt(StringTokenizer tokens) {\n-        String token = tokens.nextToken();\n-        return Integer.parseInt(token);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleRec.java","additions":0,"deletions":229,"binary":false,"changes":229,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.io.BufferedWriter;\n-import  java.io.File;\n-import  java.io.FileWriter;\n-import  java.io.IOException;\n-import  java.util.HashMap;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-import  java.util.SortedMap;\n-import  java.util.TreeMap;\n-import  java.util.TreeSet;\n-\n-\/**\n- * <code>Simple<\/code> generates TimeZoneData, which had been used as internal\n- * data of TimeZone before J2SDK1.3.\n- * Since J2SDK1.4 doesn't need TimeZoneData, this class is for maintenance\n- * of old JDK release.\n- *\/\n-class Simple extends BackEnd {\n-\n-    \/**\n-     * Zone records which are applied for given year.\n-     *\/\n-    private static Map<String,ZoneRec> lastZoneRecs = new HashMap<>();\n-\n-    \/**\n-     * Rule records which are applied for given year.\n-     *\/\n-    private static Map<String,List<RuleRec>> lastRules = new TreeMap<>();\n-\n-    \/**\n-     * zone IDs sorted by their GMT offsets. If zone's GMT\n-     * offset will change in the future, its last known offset is\n-     * used.\n-     *\/\n-    private SortedMap<Integer, Set<String>> zonesByOffset = new TreeMap<>();\n-\n-    \/**\n-     * Sets last Rule records and Zone records for given timezone to\n-     * each Map.\n-     *\n-     * @param tz Timezone object for each zone\n-     * @return always 0\n-     *\/\n-    int processZoneinfo(Timezone tz) {\n-        String zonename = tz.getName();\n-\n-        lastRules.put(zonename, tz.getLastRules());\n-        lastZoneRecs.put(zonename, tz.getLastZoneRec());\n-\n-        \/\/ Populate zonesByOffset. (Zones that will change their\n-        \/\/ GMT offsets are also added to zonesByOffset here.)\n-        int lastKnownOffset = tz.getRawOffset();\n-        Set<String> set = zonesByOffset.get(lastKnownOffset);\n-        if (set == null) {\n-            set = new TreeSet<>();\n-            zonesByOffset.put(lastKnownOffset, set);\n-        }\n-        set.add(zonename);\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Generates TimeZoneData to output SimpleTimeZone data.\n-     * @param map Mappings object which is generated by {@link Main#compile}.\n-     * @return 0 if no error occurred, otherwise 1.\n-     *\/\n-    int generateSrc(Mappings map) {\n-        try {\n-            File outD = new File(Main.getOutputDir());\n-            outD.mkdirs();\n-\n-            FileWriter fw =\n-                new FileWriter(new File(outD, \"TimeZoneData.java\"), false);\n-            BufferedWriter out = new BufferedWriter(fw);\n-\n-            out.write(\"import java.util.SimpleTimeZone;\\n\\n\");\n-            out.write(\"    static SimpleTimeZone zones[] = {\\n\");\n-\n-            Map<String,String> a = map.getAliases();\n-            List<Integer> roi = map.getRawOffsetsIndex();\n-            List<Set<String>> roit = map.getRawOffsetsIndexTable();\n-\n-            int index = 0;\n-            for (int offset : zonesByOffset.keySet()) {\n-                int o = roi.get(index);\n-                Set<String> set = zonesByOffset.get(offset);\n-                if (offset == o) {\n-                    \/\/ Merge aliases into zonesByOffset\n-                    set.addAll(roit.get(index));\n-                }\n-                index++;\n-\n-                for (String key : set) {\n-                    ZoneRec zrec;\n-                    String realname;\n-                    List<RuleRec> stz;\n-                    if ((realname = a.get(key)) != null) {\n-                        \/\/ if this alias is not targeted, ignore it.\n-                        if (!Zone.isTargetZone(key)) {\n-                            continue;\n-                        }\n-                        stz = lastRules.get(realname);\n-                        zrec = lastZoneRecs.get(realname);\n-                    } else {\n-                        stz = lastRules.get(key);\n-                        zrec = lastZoneRecs.get(key);\n-                    }\n-\n-                    out.write(\"\\t\/\/--------------------------------------------------------------------\\n\");\n-                    String s = Time.toFormedString(offset);\n-                    out.write(\"\\tnew SimpleTimeZone(\" +\n-                        Time.toFormedString(offset) + \", \\\"\" + key + \"\\\"\");\n-                    if (realname != null) {\n-                        out.write(\" \/* \" + realname + \" *\/\");\n-                    }\n-\n-                    if (stz == null) {\n-                        out.write(\"),\\n\");\n-                    } else {\n-                        RuleRec rr0 = stz.get(0);\n-                        RuleRec rr1 = stz.get(1);\n-\n-                        out.write(\",\\n\\t  \" + Month.toString(rr0.getMonthNum()) +\n-                                  \", \" + rr0.getDay().getDayForSimpleTimeZone() + \", \" +\n-                                  rr0.getDay().getDayOfWeekForSimpleTimeZone() + \", \" +\n-                                  Time.toFormedString((int)rr0.getTime().getTime()) + \", \" +\n-                                  rr0.getTime().getTypeForSimpleTimeZone() + \",\\n\" +\n-\n-                                  \"\\t  \" + Month.toString(rr1.getMonthNum()) + \", \" +\n-                                  rr1.getDay().getDayForSimpleTimeZone() + \", \" +\n-                                  rr1.getDay().getDayOfWeekForSimpleTimeZone() + \", \" +\n-                                  Time.toFormedString((int)rr1.getTime().getTime())+ \", \" +\n-                                  rr1.getTime().getTypeForSimpleTimeZone() + \",\\n\" +\n-\n-                                  \"\\t  \" + Time.toFormedString(rr0.getSave()) + \"),\\n\");\n-\n-                        out.write(\"\\t\/\/ \" + rr0.getLine() + \"\\n\");\n-                        out.write(\"\\t\/\/ \" + rr1.getLine() + \"\\n\");\n-                    }\n-\n-                    String zline = zrec.getLine();\n-                    if (zline.indexOf(\"Zone\") == -1) {\n-                        zline = \"Zone \" + key + \"\\t\" + zline.trim();\n-                    }\n-                    out.write(\"\\t\/\/ \" + zline + \"\\n\");\n-                }\n-            }\n-            out.write(\"    };\\n\");\n-\n-            out.close();\n-            fw.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Simple.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,283 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8007572 8008161 8157792 8212970 8224560 8324065\n- * @summary Test whether the TimeZone generated from JSR310 tzdb is the same\n- * as the one from the tz data from javazic\n- * @modules java.base\/sun.util.calendar:+open\n- * @build BackEnd Checksum DayOfWeek Gen GenDoc Main Mappings Month\n- *        Rule RuleDay RuleRec Simple TestZoneInfo310 Time Timezone\n- *        TzIDOldMapping Zone ZoneInfoFile ZoneInfoOld ZoneRec Zoneinfo\n- * @run main TestZoneInfo310\n- *\/\n-\n-import java.io.File;\n-import java.lang.reflect.*;\n-import java.nio.file.*;\n-import java.util.*;\n-import java.util.regex.*;\n-import java.time.zone.*;\n-import java.time.ZoneId;\n-\n-public class TestZoneInfo310 {\n-\n-    public static void main(String[] args) throws Throwable {\n-\n-        String TESTDIR = System.getProperty(\"test.dir\", \".\");\n-        Path tzdir = Paths.get(System.getProperty(\"test.root\"),\n-            \"..\/..\/src\/java.base\/share\/data\/tzdata\");\n-        String tzfiles = \"africa antarctica asia australasia europe northamerica southamerica backward etcetera gmt\";\n-        Path jdk_tzdir = Paths.get(System.getProperty(\"test.src\"), \"tzdata_jdk\");\n-        String jdk_tzfiles = \"jdk11_backward\";\n-        String zidir = TESTDIR + File.separator + \"zi\";\n-        File fZidir = new File(zidir);\n-        if (!fZidir.exists()) {\n-            fZidir.mkdirs();\n-        }\n-        Matcher m = Pattern.compile(\"tzdata(?<ver>[0-9]{4}[A-z])\")\n-                           .matcher(new String(Files.readAllBytes(tzdir.resolve(\"VERSION\")), \"ascii\"));\n-        String ver = m.find() ? m.group(\"ver\") : \"NULL\";\n-\n-        ArrayList<String> alist = new ArrayList<>();\n-        alist.add(\"-V\");\n-        alist.add(ver);\n-        alist.add(\"-d\");\n-        alist.add(zidir);\n-        for (String f : tzfiles.split(\" \")) {\n-            alist.add(tzdir.resolve(f).toString());\n-        }\n-        for (String f : jdk_tzfiles.split(\" \")) {\n-            alist.add(jdk_tzdir.resolve(f).toString());\n-        }\n-        System.out.println(\"Compiling tz files!\");\n-        Main.main(alist.toArray(new String[alist.size()]));\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        System.out.println(\"testing!\");\n-        ZoneInfoFile.ziDir = zidir;\n-        long t0, t1;\n-\n-        t0 = System.nanoTime();\n-        ZoneInfoOld.getTimeZone(\"America\/Los_Angeles\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getZoneInfoOld()[1]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        ZoneInfoOld.getTimeZone(\"America\/New_York\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getZoneInfoOld()[2]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        ZoneInfoOld.getTimeZone(\"America\/Denver\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getZoneInfoOld()[3]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        String[] zids_old = ZoneInfoOld.getAvailableIDs();\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getAvailableIDs()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, zids_old.length);\n-        Arrays.sort(zids_old);\n-\n-        t0 = System.nanoTime();\n-        String[] alias_old = ZoneInfoOld.getAliasTable()\n-                                 .keySet().toArray(new String[0]);\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getAliasTable()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, alias_old.length);\n-        Arrays.sort(alias_old);\n-\n-        t0 = System.currentTimeMillis();\n-        for (String zid : zids_old) {\n-            ZoneInfoOld.getTimeZone(zid);\n-        }\n-        t1 = System.currentTimeMillis();\n-        System.out.printf(\"OLD.TotalTZ()=%d (ms)%n\", t1 - t0);\n-\n-\/*\n-        t0 = System.nanoTime();\n-        ZoneId.of(\"America\/Los_Angeles\").getRules();\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.ZoneId.of()[1]=%d%n\", (t1 - t0) \/ 1000);\n-*\/\n-        t0 = System.nanoTime();\n-        TimeZone tz = TimeZone.getTimeZone(\"America\/Los_Angeles\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getTimeZone()[1]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        tz = TimeZone.getTimeZone(\"America\/New_York\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getTimeZone()[2]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        tz = TimeZone.getTimeZone(\"America\/Denver\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getTimeZone()[3]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        String[] zids_new = TimeZone.getAvailableIDs();\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getAvailableIDs()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, zids_new.length);\n-        Arrays.sort(zids_new);\n-\n-        t0 = System.nanoTime();\n-        String[] alias_new = sun.util.calendar.ZoneInfo.getAliasTable()\n-                                 .keySet().toArray(new String[0]);\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getAliasTable()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, alias_new.length);\n-        Arrays.sort(alias_new);\n-\n-        t0 = System.currentTimeMillis();\n-        for (String zid : zids_new) {\n-            TimeZone.getTimeZone(zid);\n-        }\n-        t1 = System.currentTimeMillis();\n-        System.out.printf(\"NEW.TotalTZ()=%d (ms)%n\", t1 - t0);\n-\n-        if (!Arrays.equals(zids_old, zids_new)) {\n-            throw new RuntimeException(\"  FAILED:  availableIds don't match\");\n-        }\n-\n-        if (!Arrays.equals(alias_old, alias_new)) {\n-            throw new RuntimeException(\"  FAILED:  aliases don't match\");\n-        }\n-\n-        for (String zid : zids_new) {\n-            ZoneInfoOld zi = toZoneInfoOld(TimeZone.getTimeZone(zid));\n-            ZoneInfoOld ziOLD = (ZoneInfoOld)ZoneInfoOld.getTimeZone(zid);\n-            \/*\n-             * Ignoring the failing TimeZones which have negative DST\n-             * save time in IANA tzdata, as javazic\/ZoneInfoOld cannot\n-             * handle the negative DST.\n-             *\n-             * These are the zones\/rules that employ negative DST in vanguard\n-             * format (as of 2019a), Palestine added in 2022d:\n-             *\n-             *  - Rule \"Eire\"\n-             *  - Rule \"Morocco\"\n-             *  - Rule \"Namibia\"\n-             *  - Rule \"Palestine\"\n-             *  - Zone \"Europe\/Prague\"\n-             *\/\n-            if (zid.equals(\"Africa\/Casablanca\") || \/\/ uses \"Morocco\" rule\n-                zid.equals(\"Africa\/El_Aaiun\") || \/\/ uses \"Morocco\" rule\n-                zid.equals(\"Africa\/Windhoek\") || \/\/ uses \"Namibia\" rule\n-                zid.equals(\"Eire\") ||\n-                zid.equals(\"Europe\/Bratislava\") || \/\/ link to \"Europe\/Prague\"\n-                zid.equals(\"Europe\/Dublin\") || \/\/ uses \"Eire\" rule\n-                zid.equals(\"Europe\/Prague\") ||\n-                zid.equals(\"Asia\/Gaza\") || \/\/ uses \"Palestine\" rule\n-                zid.equals(\"Asia\/Hebron\")) { \/\/ uses \"Palestine\" rule\n-                    continue;\n-            }\n-            if (! zi.equalsTo(ziOLD)) {\n-                System.out.println(zi.diffsTo(ziOLD));\n-                throw new RuntimeException(\"  FAILED:  \" + zid);\n-            }\n-        }\n-        delete(fZidir);\n-\n-        \/\/ test tzdb version\n-        if (!ver.equals(sun.util.calendar.ZoneInfoFile.getVersion())) {\n-            System.out.printf(\"  FAILED:  ver=%s, expected=%s%n\",\n-                              sun.util.calendar.ZoneInfoFile.getVersion(), ver);\n-            throw new RuntimeException(\"Version test failed\");\n-        }\n-\n-        \/\/ test getAvailableIDs(raw);\n-        zids_new = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);\n-        Arrays.sort(zids_new);\n-        zids_old = ZoneInfoOld.getAvailableIDs(-8 * 60 * 60 * 1000);\n-        Arrays.sort(zids_old);\n-        if (!Arrays.equals(zids_new, zids_old)) {\n-            System.out.println(\"------------------------\");\n-            System.out.println(\"NEW.getAvailableIDs(-8:00)\");\n-            for (String zid : zids_new) {\n-                System.out.println(zid);\n-            }\n-            System.out.println(\"------------------------\");\n-            System.out.println(\"OLD.getAvailableIDs(-8:00)\");\n-            for (String zid : zids_old) {\n-                System.out.println(zid);\n-            }\n-            throw new RuntimeException(\"  FAILED:  availableIds(offset) don't match\");\n-        }\n-    }\n-\n-    private static void delete(File f) {\n-        if (f.isDirectory()) {\n-            for (File f0 : f.listFiles()) {\n-               delete(f0);\n-            }\n-        }\n-        f.delete();\n-     }\n-\n-    \/\/ to access sun.util.calendar.ZoneInfo's private fields\n-    static Class<?> ziClz;\n-    static Field rawOffset;\n-    static Field checksum;\n-    static Field dstSavings;\n-    static Field transitions;\n-    static Field offsets;\n-    static Field simpleTimeZoneParams;\n-    static Field willGMTOffsetChange;\n-    static {\n-        try {\n-            ziClz = Class.forName(\"sun.util.calendar.ZoneInfo\");\n-            rawOffset = ziClz.getDeclaredField(\"rawOffset\");\n-            checksum = ziClz.getDeclaredField(\"checksum\");\n-            dstSavings = ziClz.getDeclaredField(\"dstSavings\");\n-            transitions = ziClz.getDeclaredField(\"transitions\");\n-            offsets = ziClz.getDeclaredField(\"offsets\");\n-            simpleTimeZoneParams = ziClz.getDeclaredField(\"simpleTimeZoneParams\");\n-            willGMTOffsetChange = ziClz.getDeclaredField(\"willGMTOffsetChange\");\n-            rawOffset.setAccessible(true);\n-            checksum.setAccessible(true);\n-            dstSavings.setAccessible(true);\n-            transitions.setAccessible(true);\n-            offsets.setAccessible(true);\n-            simpleTimeZoneParams.setAccessible(true);\n-            willGMTOffsetChange.setAccessible(true);\n-        } catch (Exception x) {\n-            throw new RuntimeException(x);\n-        }\n-    }\n-\n-    private static ZoneInfoOld toZoneInfoOld(TimeZone tz) throws Exception {\n-        return new ZoneInfoOld(tz.getID(),\n-                               rawOffset.getInt(tz),\n-                               dstSavings.getInt(tz),\n-                               checksum.getInt(tz),\n-                               (long[])transitions.get(tz),\n-                               (int[])offsets.get(tz),\n-                               (int[])simpleTimeZoneParams.get(tz),\n-                               willGMTOffsetChange.getBoolean(tz));\n-    }\n-\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/TestZoneInfo310.java","additions":0,"deletions":283,"binary":false,"changes":283,"status":"deleted"},{"patch":"@@ -1,339 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.Locale;\n-import sun.util.calendar.CalendarDate;\n-import sun.util.calendar.CalendarSystem;\n-import sun.util.calendar.Gregorian;\n-\n-\/**\n- * Time class represents the \"AT\" field and other time related information.\n- *\n- * @since 1.4\n- *\/\n-class Time {\n-\n-    static final Gregorian gcal = CalendarSystem.getGregorianCalendar();\n-\n-    \/\/ type is wall clock time\n-    private static final int WALL = 1;\n-\n-    \/\/ type is standard time\n-    private static final int STD = 2;\n-\n-    \/\/ type is UTC\n-    private static final int UTC = 3;\n-\n-    \/\/ type of representing time\n-    private int type;\n-\n-    \/**\n-     * Time from the EPOCH in milliseconds\n-     *\/\n-    private long time;\n-\n-    \/**\n-     * Current time in milliseconds\n-     *\/\n-    private static final long currentTime = System.currentTimeMillis();\n-\n-    Time() {\n-        time = 0L;\n-    }\n-\n-    Time(long time) {\n-        this.time = time;\n-    }\n-\n-    void setType(int type) {\n-        this.type = type;\n-    }\n-\n-    long getTime() {\n-        return time;\n-    }\n-\n-    int getType() {\n-        return type;\n-    }\n-\n-    static long getCurrentTime() {\n-        return currentTime;\n-    }\n-\n-    \/**\n-     * @return true if the time is represented in wall-clock time.\n-     *\/\n-    boolean isWall() {\n-        return type == WALL;\n-    }\n-\n-    \/**\n-     * @return true if the time is represented in standard time.\n-     *\/\n-    boolean isSTD() {\n-        return type == STD;\n-    }\n-\n-    \/**\n-     * @return true if the time is represented in UTC time.\n-     *\/\n-    boolean isUTC() {\n-        return type == UTC;\n-    }\n-\n-    \/**\n-     * Converts the type to a string that represents the type in the\n-     * SimpleTimeZone time mode. (e.g., \"SimpleTimeZone.WALL_TIME\").\n-     * @return the converted string or null if the type is undefined.\n-     *\/\n-    String getTypeForSimpleTimeZone() {\n-        String  stz = \"SimpleTimeZone.\";\n-        if (isWall()) {\n-            return stz+\"WALL_TIME\";\n-        }\n-        else if (isSTD()) {\n-            return stz+\"STANDARD_TIME\";\n-        }\n-        else if (isUTC()) {\n-            return stz+\"UTC_TIME\";\n-        }\n-        else {\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Converts the given Gregorian calendar field values to local time.\n-     * Local time is represented by the amount of milliseconds from\n-     * January 1, 1970 0:00 GMT.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day represented by {@link RuleDay}\n-     * @param save the amount of daylight time in milliseconds\n-     * @param gmtOffset the GMT offset in milliseconds\n-     * @param time the time of the day represented by {@link Time}\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, RuleDay day, int save,\n-                             int gmtOffset, Time time) {\n-        long    t = time.getTime();\n-\n-        if (time.isSTD())\n-            t = time.getTime() + save;\n-        else if (time.isUTC())\n-            t = time.getTime() + save + gmtOffset;\n-\n-        return getLocalTime(year, month, day, t);\n-    }\n-\n-    \/**\n-     * Converts the given Gregorian calendar field values to local time.\n-     * Local time is represented by the amount of milliseconds from\n-     * January 1, 1970 0:00 GMT.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day value\n-     * @param time the time of the day in milliseconds\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, int day, long time) {\n-        CalendarDate date = gcal.newCalendarDate(null);\n-        date.setDate(year, month.value(), day);\n-        long millis = gcal.getTime(date);\n-        return millis + time;\n-    }\n-\n-    \/**\n-     * Equivalent to <code>getLocalTime(year, month, day, (long)time)<\/code>.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day value\n-     * @param time the time of the day in milliseconds\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, int day, int time) {\n-        return getLocalTime(year, month, day, (long)time);\n-    }\n-\n-    \/**\n-     * Equivalent to {@link #getLocalTime(int, Month, RuleDay, int)\n-     * getLocalTime(year, month, day, (int) time)}.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day represented by {@link RuleDay}\n-     * @param time the time of the day represented by {@link Time}\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, RuleDay day, long time) {\n-        return getLocalTime(year, month, day, (int) time);\n-    }\n-\n-    \/**\n-     * Converts the given Gregorian calendar field values to local time.\n-     * Local time is represented by the amount of milliseconds from\n-     * January 1, 1970 0:00 GMT.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day represented by {@link RuleDay}\n-     * @param time the time of the day represented by {@link Time}\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, RuleDay day, int time) {\n-        CalendarDate cdate = gcal.newCalendarDate(null);\n-        int monthValue = month.value();\n-\n-        if (day.isLast()) {     \/\/ e.g., \"lastSun\"\n-            cdate.setDate(year, monthValue, 1);\n-            cdate.setDayOfMonth(gcal.getMonthLength(cdate));\n-            cdate = gcal.getNthDayOfWeek(-1, day.getDayOfWeekNum(), cdate);\n-        } else if (day.isLater()) { \/\/ e.g., \"Sun>=1\"\n-            cdate.setDate(year, monthValue, day.getDay());\n-            cdate = gcal.getNthDayOfWeek(1, day.getDayOfWeekNum(), cdate);\n-        } else if (day.isExact()) {\n-            cdate.setDate(year, monthValue, day.getDay());\n-        } else if (day.isEarlier()) {   \/\/ e.g., \"Sun<=15\"\n-            cdate.setDate(year, monthValue, day.getDay());\n-            cdate = gcal.getNthDayOfWeek(-1, day.getDayOfWeekNum(), cdate);\n-        } else {\n-            Main.panic(\"invalid day type: \" + day);\n-        }\n-        return gcal.getTime(cdate) + time;\n-    }\n-\n-    \/**\n-     * Parses the given \"AT\" field and constructs a Time object.\n-     * @param the \"AT\" field string\n-     * @return the Time object\n-     *\/\n-    static Time parse(String time) {\n-        int sign;\n-        int index = 0;\n-        Time tm;\n-\n-        if (time.charAt(0) == '-') {\n-            sign = -1;\n-            index++;\n-        } else {\n-            sign = 1;\n-        }\n-        int val = 0;\n-        int num = 0;\n-        int countDelim = 0;\n-        while (index < time.length()) {\n-            char c = time.charAt(index++);\n-            if (c == ':') {\n-                val = val * 60 + num;\n-                countDelim++;\n-                num = 0;\n-                continue;\n-            }\n-            int d = Character.digit(c, 10);\n-            if (d == -1) {\n-                --index;\n-                break;\n-            }\n-            num = num * 10 + d;\n-        }\n-        val = val * 60 + num;\n-        \/\/ convert val to second\n-        for (; countDelim < 2; countDelim++) {\n-            val *= 60;\n-        }\n-        tm = new Time((long)val * 1000 * sign);\n-        if (index < time.length()) {\n-            char c = time.charAt(index++);\n-            if (c == 's') {\n-                tm.setType(Time.STD);\n-            } else if (c == 'u' || c == 'g' || c == 'z') {\n-                tm.setType(Time.UTC);\n-            } else if (c == 'w') {\n-                tm.setType(Time.WALL);\n-            } else {\n-                Main.panic(\"unknown time mode: \"+c);\n-            }\n-        } else {\n-            tm.setType(Time.WALL);\n-        }\n-        return tm;\n-    }\n-\n-    \/**\n-     * Converts the given milliseconds string to a \"[+-]hh:mm\" string.\n-     * @param ms the milliseconds string\n-     *\/\n-    static String toGMTFormat(String ms) {\n-        long sec = Long.parseLong(ms) \/ 1000;\n-        char sign;\n-        if (sec < 0) {\n-            sign = '-';\n-            sec = -sec;\n-        } else {\n-            sign = '+';\n-        }\n-        return String.format((Locale)null, \"%c%02d:%02d\",\n-                             sign, sec\/3600, (sec%3600)\/60);\n-    }\n-\n-    \/**\n-     * Converts the given millisecond value to a string for a\n-     * SimpleTimeZone parameter.\n-     * @param ms the millisecond value\n-     * @return the string in a human readable form\n-     *\/\n-    static String toFormedString(int ms) {\n-        StringBuilder s = new StringBuilder();\n-        boolean minus = false;\n-\n-        if (ms < 0) {\n-            s.append(\"-\");\n-            minus = true;\n-            ms = -ms;\n-        } else if (ms == 0) {\n-            return \"0\";\n-        }\n-\n-        int hour = ms \/ (60 * 60 * 1000);\n-        ms %= (60 * 60 * 1000);\n-        int minute = ms \/ (60 * 1000);\n-\n-        if (hour != 0) {\n-            if (minus && minute != 0) {\n-                s.append(\"(\");\n-            }\n-            s.append(Integer.toString(hour) + \"*ONE_HOUR\");\n-        }\n-\n-        if (minute != 0) {\n-            if (hour != 0) {\n-                s.append(\"+\");\n-            }\n-            s.append(Integer.toString(minute) + \"*ONE_MINUTE\");\n-            if (minus && hour != 0) {\n-                s.append(\")\");\n-            }\n-        }\n-\n-        return s.toString();\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Time.java","additions":0,"deletions":339,"binary":false,"changes":339,"status":"deleted"},{"patch":"@@ -1,450 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Timezone represents all information of a single point of time to\n- * generate its time zone database.\n- *\n- * @since 1.4\n- *\/\n-class Timezone {\n-    \/**\n-     * zone name of this time zone\n-     *\/\n-    private String name;\n-\n-    \/**\n-     * transition time values in UTC (millisecond)\n-     *\/\n-    private List<Long> transitions;\n-\n-    \/**\n-     * All offset values in millisecond\n-     * @see sun.util.calendar.ZoneInfo\n-     *\/\n-    private List<Integer> offsets;\n-\n-    \/**\n-     * Indices of GMT offset values (both raw and raw+saving)\n-     * at transitions\n-     *\/\n-    private List<Integer> gmtOffsets;\n-\n-    \/**\n-     * Indices of regular or \"direct\" saving time values\n-     * at transitions\n-     *\/\n-    private List<Integer> dstOffsets;\n-\n-    \/**\n-     * Zone records of this time zone\n-     *\/\n-    private List<ZoneRec> usedZoneRecs;\n-\n-    \/**\n-     * Rule records referred to by this time zone\n-     *\/\n-    private List<RuleRec> usedRuleRecs;\n-\n-    \/**\n-     * Type of DST rules in this time zone\n-     *\/\n-    private int dstType;\n-    static final int UNDEF_DST = 0;     \/\/ DST type not set yet\n-    static final int NO_DST = 1;        \/\/ never observed DST\n-    static final int LAST_DST = 2;      \/\/ last rule ends in DST (all year round DST-only)\n-    static final int X_DST = 3;         \/\/ used to observe DST\n-    static final int DST = 4;           \/\/ observing DST regularly\n-\n-    \/**\n-     * Raw GMT offset of this time zone in the last rule\n-     *\/\n-    private int rawOffset;\n-\n-    \/**\n-     * The CRC32 value of the transitions data\n-     *\/\n-    private int crc32;\n-\n-    \/**\n-     * The last ZoneRec\n-     *\/\n-    private ZoneRec lastZoneRec;\n-\n-    \/**\n-     * The last DST rules. lastRules[0] is the DST start\n-     * rule. lastRules[1] is the DST end rules.\n-     *\/\n-    private List<RuleRec> lastRules;\n-\n-    \/**\n-     * The amount of DST saving value (millisecond) in the last DST\n-     * rule.\n-     *\/\n-    private int lastSaving;\n-\n-    \/**\n-     * true if the raw offset will change in the future time.\n-     *\/\n-    private boolean willRawOffsetChange = false;\n-\n-\n-    \/**\n-     * Constracts a Timezone object with the given zone name.\n-     * @param name the zone name\n-     *\/\n-    Timezone(String name) {\n-        this.name = name;\n-    }\n-\n-    \/**\n-     * @return the number of transitions\n-     *\/\n-    int getNTransitions() {\n-        if (transitions == null) {\n-            return 0;\n-        }\n-        return transitions.size();\n-    }\n-\n-    \/**\n-     * @return the zone name\n-     *\/\n-    String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Returns the list of all rule records that have been referred to\n-     * by this time zone.\n-     * @return the rule records list\n-     *\/\n-    List<RuleRec> getRules() {\n-        return usedRuleRecs;\n-    }\n-\n-    \/**\n-     * Returns the list of all zone records that have been referred to\n-     * by this time zone.\n-     * @return the zone records list\n-     *\/\n-    List<ZoneRec> getZones() {\n-        return usedZoneRecs;\n-    }\n-\n-    \/**\n-     * @return the transition table (list)\n-     *\/\n-    List<Long> getTransitions() {\n-        return transitions;\n-    }\n-\n-    \/**\n-     * @return the offsets list\n-     *\/\n-    List<Integer> getOffsets() {\n-        return offsets;\n-    }\n-\n-    \/**\n-     * @return the DST saving offsets list\n-     *\/\n-    List<Integer> getDstOffsets() {\n-        return dstOffsets;\n-    }\n-\n-    \/**\n-     * @return the GMT offsets list\n-     *\/\n-    List<Integer> getGmtOffsets() {\n-        return gmtOffsets;\n-    }\n-\n-    \/**\n-     * @return the checksum (crc32) value of the trasition table\n-     *\/\n-    int getCRC32() {\n-        return crc32;\n-    }\n-\n-    \/**\n-     * @return true if the GMT offset of this time zone would change\n-     * after the time zone database has been generated, false, otherwise.\n-     *\/\n-    boolean willGMTOffsetChange() {\n-        return willRawOffsetChange;\n-    }\n-\n-    \/**\n-     * @return the last known GMT offset value in milliseconds\n-     *\/\n-    int getRawOffset() {\n-        return rawOffset;\n-    }\n-\n-    \/**\n-     * Sets time zone's GMT offset to <code>offset<\/code>.\n-     * @param offset the GMT offset value in milliseconds\n-     *\/\n-    void setRawOffset(int offset) {\n-        rawOffset = offset;\n-    }\n-\n-    \/**\n-     * Sets time zone's GMT offset value to <code>offset<\/code>. If\n-     * <code>startTime<\/code> is future time, then the {@link\n-     * #willRawOffsetChange} value is set to true.\n-     * @param offset the GMT offset value in milliseconds\n-     * @param startTime the UTC time at which the GMT offset is in effective\n-     *\/\n-    void setRawOffset(int offset, long startTime) {\n-        \/\/ if this rawOffset is for the future time, let the run-time\n-        \/\/ look for the current GMT offset.\n-        if (startTime > Time.getCurrentTime()) {\n-            willRawOffsetChange = true;\n-        }\n-        setRawOffset(offset);\n-    }\n-\n-    \/**\n-     * Adds the specified transition information to the end of the transition table.\n-     * @param time the UTC time at which this transition happens\n-     * @param offset the total amount of the offset from GMT in milliseconds\n-     * @param dstOffset the amount of time in milliseconds saved at this transition\n-     *\/\n-    void addTransition(long time, int offset, int dstOffset) {\n-        if (transitions == null) {\n-            transitions = new ArrayList<Long>();\n-            offsets = new ArrayList<Integer>();\n-            dstOffsets = new ArrayList<Integer>();\n-        }\n-        transitions.add(time);\n-        offsets.add(offset);\n-        dstOffsets.add(dstOffset);\n-    }\n-\n-    \/**\n-     * Sets the type of historical daylight saving time\n-     * observation. For example, China used to observed daylight\n-     * saving time, but it no longer does. Then, X_DST is set to the\n-     * China time zone.\n-     * @param type the type of daylight saving time\n-     *\/\n-    void setDSTType(int type) {\n-        dstType = type;\n-    }\n-\n-    \/**\n-     * @return the type of historical daylight saving time\n-     * observation.\n-     *\/\n-    int getDSTType() {\n-        return dstType;\n-    }\n-\n-    \/**\n-     * Adds the specified zone record to the zone records list.\n-     * @param rec the zone record\n-     *\/\n-    void addUsedRec(ZoneRec rec) {\n-        if (usedZoneRecs == null) {\n-            usedZoneRecs = new ArrayList<ZoneRec>();\n-        }\n-        usedZoneRecs.add(rec);\n-    }\n-\n-    \/**\n-     * Adds the specified rule record to the rule records list.\n-     * @param rec the rule record\n-     *\/\n-    void addUsedRec(RuleRec rec) {\n-        if (usedRuleRecs == null) {\n-            usedRuleRecs = new ArrayList<RuleRec>();\n-        }\n-        \/\/ if the last used rec is the same as the given rec, avoid\n-        \/\/ putting the same rule.\n-        int n = usedRuleRecs.size();\n-        for (int i = 0; i < n; i++) {\n-            if (usedRuleRecs.get(i).equals(rec)) {\n-                return;\n-            }\n-        }\n-        usedRuleRecs.add(rec);\n-    }\n-\n-    \/**\n-     * Sets the last zone record for this time zone.\n-     * @param the last zone record\n-     *\/\n-    void setLastZoneRec(ZoneRec zrec) {\n-        lastZoneRec = zrec;\n-    }\n-\n-    \/**\n-     * @return the last zone record for this time zone.\n-     *\/\n-    ZoneRec getLastZoneRec() {\n-        return lastZoneRec;\n-    }\n-\n-    \/**\n-     * Sets the last rule records for this time zone. Those are used\n-     * for generating SimpleTimeZone parameters.\n-     * @param rules the last rule records\n-     *\/\n-    void setLastRules(List<RuleRec> rules) {\n-        int n = rules.size();\n-        if (n > 0) {\n-            lastRules = rules;\n-            RuleRec rec = rules.get(0);\n-            int offset = rec.getSave();\n-            if (offset > 0) {\n-                setLastDSTSaving(offset);\n-            } else {\n-                System.err.println(\"\\t    No DST starting rule in the last rules.\");\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * @return the last rule records for this time zone.\n-     *\/\n-    List<RuleRec> getLastRules() {\n-        return lastRules;\n-    }\n-\n-    \/**\n-     * Sets the last daylight saving amount.\n-     * @param the daylight saving amount\n-     *\/\n-    void setLastDSTSaving(int offset) {\n-        lastSaving = offset;\n-    }\n-\n-    \/**\n-     * @return the last daylight saving amount.\n-     *\/\n-    int getLastDSTSaving() {\n-        return lastSaving;\n-    }\n-\n-    \/**\n-     * Calculates the CRC32 value from the transition table and sets\n-     * the value to <code>crc32<\/code>.\n-     *\/\n-    void checksum() {\n-        if (transitions == null) {\n-            crc32 = 0;\n-            return;\n-        }\n-        Checksum sum = new Checksum();\n-        for (int i = 0; i < transitions.size(); i++) {\n-            int offset = offsets.get(i);\n-            \/\/ adjust back to make the transition in local time\n-            sum.update(transitions.get(i) + offset);\n-            sum.update(offset);\n-            sum.update(dstOffsets.get(i));\n-        }\n-        crc32 = (int)sum.getValue();\n-    }\n-\n-    \/**\n-     * Removes unnecessary transitions for Java time zone support.\n-     *\/\n-    void optimize() {\n-        \/\/ if there is only one offset, delete all transitions. This\n-        \/\/ could happen if only time zone abbreviations changed.\n-        if (gmtOffsets.size() == 1) {\n-            transitions = null;\n-            usedRuleRecs =  null;\n-            setDSTType(NO_DST);\n-            return;\n-        }\n-        for (int i = 0; i < (transitions.size() - 2); i++) { \/\/ don't remove the last one\n-            if (transitions.get(i) == transitions.get(i+1)) {\n-                transitions.remove(i);\n-                offsets.remove(i);\n-                dstOffsets.remove(i);\n-                i--;\n-            }\n-        }\n-\n-        for (int i = 0; i < (transitions.size() - 2); i++) { \/\/ don't remove the last one\n-            if (offsets.get(i) == offsets.get(i+1)\n-                && dstOffsets.get(i) == dstOffsets.get(i+1)) {\n-                transitions.remove(i+1);\n-                offsets.remove(i+1);\n-                dstOffsets.remove(i+1);\n-                i--;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Stores the specified offset value from GMT in the GMT offsets\n-     * table and returns its index. The offset value includes the base\n-     * GMT offset and any additional daylight saving if applicable. If\n-     * the same value as the specified offset is already in the table,\n-     * its index is returned.\n-     * @param offset the offset value in milliseconds\n-     * @return the index to the offset value in the GMT offsets table.\n-     *\/\n-    int getOffsetIndex(int offset) {\n-        return getOffsetIndex(offset, 0);\n-    }\n-\n-    \/**\n-     * Stores the specified daylight saving value in the GMT offsets\n-     * table and returns its index. If the same value as the specified\n-     * offset is already in the table, its index is returned. If 0 is\n-     * specified, it's not stored in the table and -1 is returned.\n-     * @param offset the offset value in milliseconds\n-     * @return the index to the specified offset value in the GMT\n-     * offsets table, or -1 if 0 is specified.\n-     *\/\n-    int getDstOffsetIndex(int offset) {\n-        if (offset == 0) {\n-            return -1;\n-        }\n-        return getOffsetIndex(offset, 1);\n-    }\n-\n-    private int getOffsetIndex(int offset, int index) {\n-        if (gmtOffsets == null) {\n-            gmtOffsets = new ArrayList<Integer>();\n-        }\n-        for (int i = index; i < gmtOffsets.size(); i++) {\n-            if (offset == gmtOffsets.get(i)) {\n-                return i;\n-            }\n-        }\n-        if (gmtOffsets.size() < index) {\n-            gmtOffsets.add(0);\n-        }\n-        gmtOffsets.add(offset);\n-        return gmtOffsets.size() - 1;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Timezone.java","additions":0,"deletions":450,"binary":false,"changes":450,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.Map;\n-import java.util.HashMap;\n-\n-class TzIDOldMapping {\n-    static final Map<String, String> MAP = new HashMap<String, String>();\n-    static {\n-        String[][] oldmap = {\n-            { \"ACT\", \"Australia\/Darwin\" },\n-            { \"AET\", \"Australia\/Sydney\" },\n-            { \"AGT\", \"America\/Argentina\/Buenos_Aires\" },\n-            { \"ART\", \"Africa\/Cairo\" },\n-            { \"AST\", \"America\/Anchorage\" },\n-            { \"BET\", \"America\/Sao_Paulo\" },\n-            { \"BST\", \"Asia\/Dhaka\" },\n-            { \"CAT\", \"Africa\/Harare\" },\n-            { \"CNT\", \"America\/St_Johns\" },\n-            { \"CST\", \"America\/Chicago\" },\n-            { \"CTT\", \"Asia\/Shanghai\" },\n-            { \"EAT\", \"Africa\/Addis_Ababa\" },\n-            { \"ECT\", \"Europe\/Paris\" },\n-            { \"EST\", \"America\/New_York\" },\n-            { \"HST\", \"Pacific\/Honolulu\" },\n-            { \"IET\", \"America\/Indianapolis\" },\n-            { \"IST\", \"Asia\/Calcutta\" },\n-            { \"JST\", \"Asia\/Tokyo\" },\n-            { \"MIT\", \"Pacific\/Apia\" },\n-            { \"MST\", \"America\/Denver\" },\n-            { \"NET\", \"Asia\/Yerevan\" },\n-            { \"NST\", \"Pacific\/Auckland\" },\n-            { \"PLT\", \"Asia\/Karachi\" },\n-            { \"PNT\", \"America\/Phoenix\" },\n-            { \"PRT\", \"America\/Puerto_Rico\" },\n-            { \"PST\", \"America\/Los_Angeles\" },\n-            { \"SST\", \"Pacific\/Guadalcanal\" },\n-            { \"VST\", \"Asia\/Saigon\" },\n-        };\n-        for (String[] pair : oldmap) {\n-            MAP.put(pair[0], pair[1]);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/TzIDOldMapping.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * Zone holds information corresponding to a \"Zone\" part of a time\n- * zone definition file.\n- *\n- * @since 1.4\n- *\/\n-class Zone {\n-    \/\/ zone name (e.g., \"America\/Los_Angeles\")\n-    private String name;\n-\n-    \/\/ zone records\n-    private List<ZoneRec> list;\n-\n-    \/\/ target zone names for this compilation\n-    private static Set<String> targetZones;\n-\n-    \/**\n-     * Constructs a Zone with the specified zone name.\n-     * @param name the zone name\n-     *\/\n-    Zone(String name) {\n-        this.name = name;\n-        list = new ArrayList<ZoneRec>();\n-    }\n-\n-    \/**\n-     * Reads time zone names to be generated, called \"target zone\n-     * name\", from the specified text file and creats an internal hash\n-     * table to keep those names. It's assumed that one text line\n-     * contains a zone name or comments if it starts with\n-     * '#'. Comments can't follow a zone name in a single line.\n-     * @param fileName the text file name\n-     *\/\n-    static void readZoneNames(String fileName) {\n-        if (fileName == null) {\n-            return;\n-        }\n-        BufferedReader in = null;\n-        try {\n-            FileReader fr = new FileReader(fileName);\n-            in = new BufferedReader(fr);\n-        } catch (FileNotFoundException e) {\n-            Main.panic(\"can't open file: \" + fileName);\n-        }\n-        targetZones = new HashSet<String>();\n-        String line;\n-\n-        try {\n-            while ((line = in.readLine()) != null) {\n-                line = line.trim();\n-                if (line.length() == 0 || line.charAt(0) == '#') {\n-                    continue;\n-                }\n-                if (!targetZones.add(line)) {\n-                    Main.warning(\"duplicated target zone name: \" + line);\n-                }\n-            }\n-            in.close();\n-        } catch (IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-        }\n-    }\n-\n-    \/**\n-     * Determines whether the specified zone is one of the target zones.\n-     * If no target zones are specified, this method always returns\n-     * true for any zone name.\n-     * @param zoneName the zone name\n-     * @return true if the specified name is a target zone.\n-     *\/\n-    static boolean isTargetZone(String zoneName) {\n-        if (targetZones == null) {\n-            return true;\n-        }\n-        return targetZones.contains(zoneName);\n-    }\n-\n-    \/**\n-     * Forces to add \"MET\" to the target zone table. This is because\n-     * there is a conflict between Java zone name \"WET\" and Olson zone\n-     * name.\n-     *\/\n-    static void addMET() {\n-        if (targetZones != null) {\n-            targetZones.add(\"MET\");\n-        }\n-    }\n-\n-    \/**\n-     * @return the zone name\n-     *\/\n-    String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Adds the specified zone record to the zone record list.\n-     *\/\n-    void add(ZoneRec rec) {\n-        list.add(rec);\n-    }\n-\n-    \/**\n-     * @param index the index at which the zone record in the list is returned.\n-     * @return the zone record specified by the index.\n-     *\/\n-    ZoneRec get(int index) {\n-        return list.get(index);\n-    }\n-\n-    \/**\n-     * @return the size of the zone record list\n-     *\/\n-    int size() {\n-        return list.size();\n-    }\n-\n-    \/**\n-     * Resolves the reference to a rule in each zone record.\n-     * @param zi the Zoneinfo object with which the rule reference is\n-     * resolved.\n-     *\/\n-    void resolve(Zoneinfo zi) {\n-        for (int i = 0; i < list.size(); i++) {\n-            ZoneRec rec = list.get(i);\n-            rec.resolve(zi);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Zone.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -1,1049 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.lang.ref.SoftReference;\n-import java.nio.file.FileSystems;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import sun.util.calendar.*;\n-\n-\/**\n- * <code>ZoneInfoFile<\/code> reads Zone information files in the\n- * &lt;java.home&gt;\/lib\/zi directory and provides time zone\n- * information in the form of a {@link ZoneInfo} object. Also, it\n- * reads the ZoneInfoMappings file to obtain time zone IDs information\n- * that is used by the {@link ZoneInfo} class. The directory layout\n- * and data file formats are as follows.\n- *\n- * <p><strong>Directory layout<\/strong><p>\n- *\n- * All zone data files and ZoneInfoMappings are put under the\n- * &lt;java.home&gt;\/lib\/zi directory. A path name for a given time\n- * zone ID is a concatenation of &lt;java.home&gt;\/lib\/zi\/ and the\n- * time zone ID. (The file separator is replaced with the platform\n- * dependent value. e.g., '\\' for Win32.) An example layout will look\n- * like as follows.\n- * <blockquote>\n- * <pre>\n- * &lt;java.home&gt;\/lib\/zi\/Africa\/Addis_Ababa\n- *                   \/Africa\/Dakar\n- *                   \/America\/Los_Angeles\n- *                   \/Asia\/Singapore\n- *                   \/EET\n- *                   \/Europe\/Oslo\n- *                   \/GMT\n- *                   \/Pacific\/Galapagos\n- *                       ...\n- *                   \/ZoneInfoMappings\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * A zone data file has specific information of each zone.\n- * <code>ZoneInfoMappings<\/code> has global information of zone IDs so\n- * that the information can be obtained without instantiating all time\n- * zones.\n- *\n- * <p><strong>File format<\/strong><p>\n- *\n- * Two binary-file formats based on a simple Tag-Length-Value format are used\n- * to describe TimeZone information. The generic format of a data file is:\n- * <blockquote>\n- * <pre>\n- *    DataFile {\n- *      u1              magic[7];\n- *      u1              version;\n- *      data_item       data[];\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * where <code>magic<\/code> is a magic number identifying a file\n- * format, <code>version<\/code> is the format version number, and\n- * <code>data<\/code> is one or more <code>data_item<\/code>s. The\n- * <code>data_item<\/code> structure is:\n- * <blockquote>\n- * <pre>\n- *    data_item {\n- *      u1              tag;\n- *      u2              length;\n- *      u1              value[length];\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * where <code>tag<\/code> indicates the data type of the item,\n- * <code>length<\/code> is a byte count of the following\n- * <code>value<\/code> that is the content of item data.\n- * <p>\n- * All data is stored in the big-endian order. There is no boundary\n- * alignment between date items.\n- *\n- * <p><strong>1. ZoneInfo data file<\/strong><p>\n- *\n- * Each ZoneInfo data file consists of the following members.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    ZoneInfoDataFile {\n- *      u1              magic[7];\n- *      u1              version;\n- *      SET OF<sup>1<\/sup> {\n- *        transition            transitions<sup>2<\/sup>;\n- *        offset_table          offsets<sup>2<\/sup>;\n- *        simpletimezone        stzparams<sup>2<\/sup>;\n- *        raw_offset            rawoffset;\n- *        dstsaving             dst;\n- *        checksum              crc32;\n- *        gmtoffsetwillchange   gmtflag<sup>2<\/sup>;\n- *      }\n- *   }\n- *   1: an unordered collection of zero or one occurrences of each item\n- *   2: optional item\n- * <\/pre>\n- * <\/blockquote>\n- * <code>magic<\/code> is a byte-string constant identifying the\n- * ZoneInfo data file.  This field must be <code>\"javazi&#92;0\"<\/code>\n- * defined as {@link #JAVAZI_LABEL}.\n- * <p>\n- * <code>version<\/code> is the version number of the file format. This\n- * will be used for compatibility check. This field must be\n- * <code>0x01<\/code> in this version.\n- * <p>\n- * <code>transition<\/code>, <code>offset_table<\/code> and\n- * <code>simpletimezone<\/code> have information of time transition\n- * from the past to the future.  Therefore, these structures don't\n- * exist if the zone didn't change zone names and haven't applied DST in\n- * the past, and haven't planned to apply it.  (e.g. Asia\/Tokyo zone)\n- * <p>\n- * <code>raw_offset<\/code>, <code>dstsaving<\/code> and <code>checksum<\/code>\n- * exist in every zoneinfo file. They are used by TimeZone.class indirectly.\n- *\n- * <p><strong>1.1 <code>transition<\/code> structure<\/strong><p><a name=\"transition\"><\/a>\n- * <blockquote>\n- * <pre>\n- *    transition {\n- *      u1      tag;              \/\/ 0x04 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s8      value[length\/8];  \/\/ transitions in `long'\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#transitions ZoneInfo.transitions} about the value.\n- *\n- * <p><strong>1.2 <code>offset_table<\/code> structure<\/strong><p>\n- * <blockquote>\n- * <pre>\n- *    offset_table {\n- *      u1      tag;              \/\/ 0x05 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s4      value[length\/4];  \/\/ offset values in `int'\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>1.3 <code>simpletimezone<\/code> structure<\/strong><p>\n- * See {@link ZoneInfo#simpleTimeZoneParams ZoneInfo.simpleTimeZoneParams}\n- * about the value.\n- * <blockquote>\n- * <pre>\n- *    simpletimezone {\n- *      u1      tag;              \/\/ 0x06 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s4      value[length\/4];  \/\/ SimpleTimeZone parameters\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#offsets ZoneInfo.offsets} about the value.\n- *\n- * <p><strong>1.4 <code>raw_offset<\/code> structure<\/strong><p>\n- * <blockquote>\n- * <pre>\n- *    raw_offset {\n- *      u1      tag;              \/\/ 0x01 : constant\n- *      u2      length;           \/\/ must be 4.\n- *      s4      value;            \/\/ raw GMT offset [millisecond]\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#rawOffset ZoneInfo.rawOffset} about the value.\n- *\n- * <p><strong>1.5 <code>dstsaving<\/code> structure<\/strong><p>\n- * Value has dstSaving in seconds.\n- * <blockquote>\n- * <pre>\n- *    dstsaving {\n- *      u1      tag;              \/\/ 0x02 : constant\n- *      u2      length;           \/\/ must be 2.\n- *      s2      value;            \/\/ DST save value [second]\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#dstSavings ZoneInfo.dstSavings} about value.\n- *\n- * <p><strong>1.6 <code>checksum<\/code> structure<\/strong><p>\n- * <blockquote>\n- * <pre>\n- *    checksum {\n- *      u1      tag;              \/\/ 0x03 : constant\n- *      u2      length;           \/\/ must be 4.\n- *      s4      value;            \/\/ CRC32 value of transitions\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#checksum ZoneInfo.checksum}.\n- *\n- * <p><strong>1.7 <code>gmtoffsetwillchange<\/code> structure<\/strong><p>\n- * This record has a flag value for {@link ZoneInfo#rawOffsetWillChange}.\n- * If this record is not present in a zoneinfo file, 0 is assumed for\n- * the value.\n- * <blockquote>\n- * <pre>\n- *    gmtoffsetwillchange {\n- *      u1      tag;             \/\/ 0x07 : constant\n- *      u2      length;          \/\/ must be 1.\n- *      u1      value;           \/\/ 1: if the GMT raw offset will change\n- *                               \/\/ in the future, 0, otherwise.\n- *     }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- *\n- * <p><strong>2. ZoneInfoMappings file<\/strong><p>\n- *\n- * The ZoneInfoMappings file consists of the following members.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    ZoneInfoMappings {\n- *      u1      magic[7];\n- *      u1      version;\n- *      SET OF {\n- *        versionName                   version;\n- *        zone_id_table                 zoneIDs;\n- *        raw_offset_table              rawoffsets;\n- *        raw_offset_index_table        rawoffsetindices;\n- *        alias_table                   aliases;\n- *        excluded_list                 excludedList;\n- *      }\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <code>magic<\/code> is a byte-string constant which has the file type.\n- * This field must be <code>\"javazm&#92;0\"<\/code> defined as {@link #JAVAZM_LABEL}.\n- * <p>\n- * <code>version<\/code> is the version number of this file\n- * format. This will be used for compatibility check. This field must\n- * be <code>0x01<\/code> in this version.\n- * <p>\n- * <code>versionName<\/code> shows which version of Olson's data has been used\n- * to generate this ZoneInfoMappings. (e.g. <code>tzdata2000g<\/code>) <br>\n- * This field is for trouble-shooting and isn't usually used in runtime.\n- * <p>\n- * <code>zone_id_table<\/code>, <code>raw_offset_index_table<\/code> and\n- * <code>alias_table<\/code> are general information of supported\n- * zones.\n- *\n- * <p><strong>2.1 <code>zone_id_table<\/code> structure<\/strong><p>\n- * The list of zone IDs included in the zi database. The list does\n- * <em>not<\/em> include zone IDs, if any, listed in excludedList.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    zone_id_table {\n- *      u1      tag;              \/\/ 0x40 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u2      zone_id_count;\n- *      zone_id value[zone_id_count];\n- *    }\n- *\n- *    zone_id {\n- *      u1      byte_length;      \/\/ byte length of id\n- *      u1      id[byte_length];  \/\/ zone name string\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.2 <code>raw_offset_table<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    raw_offset_table {\n- *      u1      tag;              \/\/ 0x41 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s4      value[length\/4];  \/\/ raw GMT offset in milliseconds\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.3 <code>raw_offset_index_table<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    raw_offset_index_table {\n- *      u1      tag;              \/\/ 0x42 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u1      value[length];\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.4 <code>alias_table<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *   alias_table {\n- *      u1      tag;              \/\/ 0x43 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u2      nentries;         \/\/ number of id-pairs\n- *      id_pair value[nentries];\n- *   }\n- *\n- *   id_pair {\n- *      zone_id aliasname;\n- *      zone_id ID;\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.5 <code>versionName<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *   versionName {\n- *      u1      tag;              \/\/ 0x44 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u1      value[length];\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.6 <code>excludeList<\/code> structure<\/strong><p>\n- * The list of zone IDs whose zones will change their GMT offsets\n- * (a.k.a. raw offsets) some time in the future. Those IDs must be\n- * added to the list of zone IDs for getAvailableIDs(). Also they must\n- * be examined for getAvailableIDs(int) to determine the\n- * <em>current<\/em> GMT offsets.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *   excluded_list {\n- *      u1      tag;              \/\/ 0x45 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u2      nentries;         \/\/ number of zone_ids\n- *      zone_id value[nentries];  \/\/ excluded zone IDs\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * @since 1.4\n- *\/\n-\n-public class ZoneInfoFile {\n-\n-    \/**\n-     * The magic number for the ZoneInfo data file format.\n-     *\/\n-    public static final byte[]  JAVAZI_LABEL = {\n-        (byte)'j', (byte)'a', (byte)'v', (byte)'a', (byte)'z', (byte)'i', (byte)'\\0'\n-    };\n-    private static final int    JAVAZI_LABEL_LENGTH = JAVAZI_LABEL.length;\n-\n-    \/**\n-     * The ZoneInfo data file format version number. Must increase\n-     * one when any incompatible change has been made.\n-     *\/\n-    public static final byte    JAVAZI_VERSION = 0x01;\n-\n-    \/**\n-     * Raw offset data item tag.\n-     *\/\n-    public static final byte    TAG_RawOffset = 1;\n-\n-    \/**\n-     * Known last Daylight Saving Time save value data item tag.\n-     *\/\n-    public static final byte    TAG_LastDSTSaving = 2;\n-\n-    \/**\n-     * Checksum data item tag.\n-     *\/\n-    public static final byte    TAG_CRC32 = 3;\n-\n-    \/**\n-     * Transition data item tag.\n-     *\/\n-    public static final byte    TAG_Transition = 4;\n-\n-    \/**\n-     * Offset table data item tag.\n-     *\/\n-    public static final byte    TAG_Offset = 5;\n-\n-    \/**\n-     * SimpleTimeZone parameters data item tag.\n-     *\/\n-    public static final byte    TAG_SimpleTimeZone = 6;\n-\n-    \/**\n-     * Raw GMT offset will change in the future.\n-     *\/\n-    public static final byte    TAG_GMTOffsetWillChange = 7;\n-\n-\n-    \/**\n-     * The ZoneInfoMappings file name.\n-     *\/\n-    public static final String  JAVAZM_FILE_NAME = \"ZoneInfoMappings\";\n-\n-    \/**\n-     * The magic number for the ZoneInfoMappings file format.\n-     *\/\n-    public static final byte[]  JAVAZM_LABEL = {\n-        (byte)'j', (byte)'a', (byte)'v', (byte)'a', (byte)'z', (byte)'m', (byte)'\\0'\n-    };\n-    private static final int    JAVAZM_LABEL_LENGTH = JAVAZM_LABEL.length;\n-\n-    \/**\n-     * The ZoneInfoMappings file format version number. Must increase\n-     * one when any incompatible change has been made.\n-     *\/\n-    public static final byte    JAVAZM_VERSION = 0x01;\n-\n-    \/**\n-     * Time zone IDs data item tag.\n-     *\/\n-    public static final byte    TAG_ZoneIDs = 64;\n-\n-    \/**\n-     * Raw GMT offsets table data item tag.\n-     *\/\n-    public static final byte    TAG_RawOffsets = 65;\n-\n-    \/**\n-     * Indices to the raw GMT offset table data item tag.\n-     *\/\n-    public static final byte    TAG_RawOffsetIndices = 66;\n-\n-    \/**\n-     * Time zone aliases table data item tag.\n-     *\/\n-    public static final byte    TAG_ZoneAliases = 67;\n-\n-    \/**\n-     * Olson's public zone information version tag.\n-     *\/\n-    public static final byte    TAG_TZDataVersion = 68;\n-\n-    \/**\n-     * Excluded zones item tag. (Added in Mustang)\n-     *\/\n-    public static final byte    TAG_ExcludedZones = 69;\n-\n-    private static Map<String, ZoneInfoOld> zoneInfoObjects = null;\n-\n-    private static final ZoneInfoOld GMT = new ZoneInfoOld(\"GMT\", 0);\n-\n-    static String ziDir;\n-\n-    \/**\n-     * Converts the given time zone ID to a platform dependent path\n-     * name. For example, \"America\/Los_Angeles\" is converted to\n-     * \"America\\Los_Angeles\" on Win32.\n-     * @return a modified ID replacing '\/' with {@link\n-     * java.io.File#separatorChar File.separatorChar} if needed.\n-     *\/\n-    public static String getFileName(String ID) {\n-        if (File.separatorChar == '\/') {\n-            return ID;\n-        }\n-        return ID.replace('\/', File.separatorChar);\n-    }\n-\n-    \/**\n-     * Gets a ZoneInfo with the given GMT offset. The object\n-     * has its ID in the format of GMT{+|-}hh:mm.\n-     *\n-     * @param originalId the given custom id (before normalized such as \"GMT+9\")\n-     * @param gmtOffset GMT offset <em>in milliseconds<\/em>\n-     * @return a ZoneInfo constructed with the given GMT offset\n-     *\/\n-    public static ZoneInfoOld getCustomTimeZone(String originalId, int gmtOffset) {\n-        String id = toCustomID(gmtOffset);\n-\n-        ZoneInfoOld zi = getFromCache(id);\n-        if (zi == null) {\n-            zi = new ZoneInfoOld(id, gmtOffset);\n-            zi = addToCache(id, zi);\n-            if (!id.equals(originalId)) {\n-                zi = addToCache(originalId, zi);\n-            }\n-        }\n-        return (ZoneInfoOld) zi.clone();\n-    }\n-\n-    public static String toCustomID(int gmtOffset) {\n-        char sign;\n-        int offset = gmtOffset \/ 60000;\n-\n-        if (offset >= 0) {\n-            sign = '+';\n-        } else {\n-            sign = '-';\n-            offset = -offset;\n-        }\n-        int hh = offset \/ 60;\n-        int mm = offset % 60;\n-\n-        char[] buf = new char[] { 'G', 'M', 'T', sign, '0', '0', ':', '0', '0' };\n-        if (hh >= 10) {\n-            buf[4] += hh \/ 10;\n-        }\n-        buf[5] += hh % 10;\n-        if (mm != 0) {\n-            buf[7] += mm \/ 10;\n-            buf[8] += mm % 10;\n-        }\n-        return new String(buf);\n-    }\n-\n-    \/**\n-     * @return a ZoneInfo instance created for the specified id, or\n-     * null if there is no time zone data file found for the specified\n-     * id.\n-     *\/\n-    public static ZoneInfoOld getZoneInfoOld(String id) {\n-        \/\/treat GMT zone as special\n-        if (\"GMT\".equals(id))\n-            return (ZoneInfoOld) GMT.clone();\n-        ZoneInfoOld zi = getFromCache(id);\n-        if (zi == null) {\n-            Map<String, String> aliases = ZoneInfoOld.getCachedAliasTable();\n-            if (aliases != null && aliases.get(id) != null) {\n-                return null;\n-            }\n-            zi = createZoneInfoOld(id);\n-            if (zi == null) {\n-                return null;\n-            }\n-            zi = addToCache(id, zi);\n-        }\n-        return (ZoneInfoOld) zi.clone();\n-    }\n-\n-    synchronized static ZoneInfoOld getFromCache(String id) {\n-        if (zoneInfoObjects == null) {\n-            return null;\n-        }\n-        return zoneInfoObjects.get(id);\n-    }\n-\n-    synchronized static ZoneInfoOld addToCache(String id, ZoneInfoOld zi) {\n-        if (zoneInfoObjects == null) {\n-            zoneInfoObjects = new HashMap<>();\n-        } else {\n-            ZoneInfoOld zone = zoneInfoObjects.get(id);\n-            if (zone != null) {\n-                return zone;\n-            }\n-        }\n-        zoneInfoObjects.put(id, zi);\n-        return zi;\n-    }\n-\n-    private static ZoneInfoOld createZoneInfoOld(String id) {\n-        byte[] buf = readZoneInfoFile(getFileName(id));\n-        if (buf == null) {\n-            return null;\n-        }\n-\n-        int index = 0;\n-        int filesize = buf.length;\n-        int rawOffset = 0;\n-        int dstSavings = 0;\n-        int checksum = 0;\n-        boolean willGMTOffsetChange = false;\n-        long[] transitions = null;\n-        int[] offsets = null;\n-        int[] simpleTimeZoneParams = null;\n-\n-        try {\n-            for (index = 0; index < JAVAZI_LABEL.length; index++) {\n-                if (buf[index] != JAVAZI_LABEL[index]) {\n-                    System.err.println(\"ZoneInfoOld: wrong magic number: \" + id);\n-                    return null;\n-                }\n-            }\n-            if (buf[index++] > JAVAZI_VERSION) {\n-                System.err.println(\"ZoneInfo: incompatible version (\"\n-                                   + buf[index - 1] + \"): \" + id);\n-                return null;\n-            }\n-\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int  len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                if (filesize < index+len) {\n-                    break;\n-                }\n-\n-                switch (tag) {\n-                case TAG_CRC32:\n-                    {\n-                        int val = buf[index++] & 0xff;\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        checksum = val;\n-                    }\n-                    break;\n-\n-                case TAG_LastDSTSaving:\n-                    {\n-                        short val = (short)(buf[index++] & 0xff);\n-                        val = (short)((val << 8) + (buf[index++] & 0xff));\n-                        dstSavings = val * 1000;\n-                    }\n-                    break;\n-\n-                case TAG_RawOffset:\n-                    {\n-                        int val = buf[index++] & 0xff;\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        rawOffset = val;\n-                    }\n-                    break;\n-\n-                case TAG_Transition:\n-                    {\n-                        int n = len \/ 8;\n-                        transitions = new long[n];\n-                        for (int i = 0; i < n; i ++) {\n-                            long val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            transitions[i] = val;\n-                        }\n-                    }\n-                    break;\n-\n-                case TAG_Offset:\n-                    {\n-                        int n = len \/ 4;\n-                        offsets = new int[n];\n-                        for (int i = 0; i < n; i ++) {\n-                            int val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            offsets[i] = val;\n-                        }\n-                    }\n-                    break;\n-\n-                case TAG_SimpleTimeZone:\n-                    {\n-                        if (len != 32 && len != 40) {\n-                            System.err.println(\"ZoneInfo: wrong SimpleTimeZone parameter size\");\n-                            return null;\n-                        }\n-                        int n = len \/ 4;\n-                        simpleTimeZoneParams = new int[n];\n-                        for (int i = 0; i < n; i++) {\n-                            int val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            simpleTimeZoneParams[i] = val;\n-                        }\n-                    }\n-                    break;\n-\n-                case TAG_GMTOffsetWillChange:\n-                    {\n-                        if (len != 1) {\n-                            System.err.println(\"ZoneInfo: wrong byte length for TAG_GMTOffsetWillChange\");\n-                        }\n-                        willGMTOffsetChange = buf[index++] == 1;\n-                    }\n-                    break;\n-\n-                default:\n-                    System.err.println(\"ZoneInfo: unknown tag < \" + tag + \">. ignored.\");\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfo: corrupted zoneinfo file: \" + id);\n-            return null;\n-        }\n-\n-        if (index != filesize) {\n-            System.err.println(\"ZoneInfo: wrong file size: \" + id);\n-            return null;\n-        }\n-\n-        return new ZoneInfoOld(id, rawOffset, dstSavings, checksum,\n-                            transitions, offsets, simpleTimeZoneParams,\n-                            willGMTOffsetChange);\n-    }\n-\n-    private volatile static SoftReference<List<String>> zoneIDs = null;\n-\n-    static List<String> getZoneIDs() {\n-        List<String> ids = null;\n-        SoftReference<List<String>> cache = zoneIDs;\n-        if (cache != null) {\n-            ids = cache.get();\n-            if (ids != null) {\n-                return ids;\n-            }\n-        }\n-        byte[] buf = null;\n-        buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_ZoneIDs:\n-                    {\n-                        int n = (buf[index++] << 8) + (buf[index++] & 0xFF);\n-                        ids = new ArrayList<>(n);\n-\n-                        for (int i = 0; i < n; i++) {\n-                            byte m = buf[index++];\n-                            ids.add(new String(buf, index, m, \"UTF-8\"));\n-                            index += m;\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-        }\n-\n-        zoneIDs = new SoftReference<>(ids);\n-        return ids;\n-    }\n-\n-    \/**\n-     * @return an alias table in HashMap where a key is an alias ID\n-     * (e.g., \"PST\") and its value is a real time zone ID (e.g.,\n-     * \"America\/Los_Angeles\").\n-     *\/\n-    static Map<String, String> getZoneAliases() {\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-        Map<String, String> aliases = null;\n-\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_ZoneAliases:\n-                    {\n-                        int n = (buf[index++] << 8) + (buf[index++] & 0xFF);\n-                        aliases = new HashMap<>(n);\n-                        for (int i = 0; i < n; i++) {\n-                            byte m = buf[index++];\n-                            String name = new String(buf, index, m, \"UTF-8\");\n-                            index += m;\n-                            m = buf[index++];\n-                            String realName = new String(buf, index, m, \"UTF-8\");\n-                            index += m;\n-                            aliases.put(name, realName);\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-            return null;\n-        }\n-        return aliases;\n-    }\n-\n-    private volatile static SoftReference<List<String>> excludedIDs = null;\n-    private volatile static boolean hasNoExcludeList = false;\n-\n-    \/**\n-     * @return a List of zone IDs for zones that will change their GMT\n-     * offsets in some future time.\n-     *\n-     * @since 1.6\n-     *\/\n-    static List<String> getExcludedZones() {\n-        if (hasNoExcludeList) {\n-            return null;\n-        }\n-\n-        List<String> excludeList = null;\n-\n-        SoftReference<List<String>> cache = excludedIDs;\n-        if (cache != null) {\n-            excludeList = cache.get();\n-            if (excludeList != null) {\n-                return excludeList;\n-            }\n-        }\n-\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-\n-        try {\n-          loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_ExcludedZones:\n-                    {\n-                        int n = (buf[index++] << 8) + (buf[index++] & 0xFF);\n-                        excludeList = new ArrayList<>();\n-                        for (int i = 0; i < n; i++) {\n-                            byte m = buf[index++];\n-                            String name = new String(buf, index, m, \"UTF-8\");\n-                            index += m;\n-                            excludeList.add(name);\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-            return null;\n-        }\n-\n-        if (excludeList != null) {\n-            excludedIDs = new SoftReference<>(excludeList);\n-        } else {\n-            hasNoExcludeList = true;\n-        }\n-        return excludeList;\n-    }\n-\n-    private volatile static SoftReference<byte[]> rawOffsetIndices = null;\n-\n-    static byte[] getRawOffsetIndices() {\n-        byte[] indices = null;\n-\n-        SoftReference<byte[]> cache = rawOffsetIndices;\n-        if (cache != null) {\n-            indices = cache.get();\n-            if (indices != null) {\n-                return indices;\n-            }\n-        }\n-\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_RawOffsetIndices:\n-                    {\n-                        indices = new byte[len];\n-                        for (int i = 0; i < len; i++) {\n-                            indices[i] = buf[index++];\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-        }\n-\n-        rawOffsetIndices = new SoftReference<>(indices);\n-        return indices;\n-    }\n-\n-    private volatile static SoftReference<int[]> rawOffsets = null;\n-\n-    static int[] getRawOffsets() {\n-        int[] offsets = null;\n-\n-        SoftReference<int[]> cache = rawOffsets;\n-        if (cache != null) {\n-            offsets = cache.get();\n-            if (offsets != null) {\n-                return offsets;\n-            }\n-        }\n-\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_RawOffsets:\n-                    {\n-                        int n = len\/4;\n-                        offsets = new int[n];\n-                        for (int i = 0; i < n; i++) {\n-                            int val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            offsets[i] = val;\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-        }\n-\n-        rawOffsets = new SoftReference<>(offsets);\n-        return offsets;\n-    }\n-\n-    private volatile static SoftReference<byte[]> zoneInfoMappings = null;\n-\n-    private static byte[] getZoneInfoOldMappings() {\n-        byte[] data;\n-        SoftReference<byte[]> cache = zoneInfoMappings;\n-        if (cache != null) {\n-            data = cache.get();\n-            if (data != null) {\n-                return data;\n-            }\n-        }\n-        data = readZoneInfoFile(JAVAZM_FILE_NAME);\n-        if (data == null) {\n-            throw new RuntimeException(\"ZoneInfoOldMapping \" +\n-                JAVAZM_FILE_NAME + \" either doesn't exist or doesn't have data\");\n-        }\n-\n-        int index;\n-        for (index = 0; index < JAVAZM_LABEL.length; index++) {\n-            if (data[index] != JAVAZM_LABEL[index]) {\n-                System.err.println(\"ZoneInfoOld: wrong magic number: \" + JAVAZM_FILE_NAME);\n-                return null;\n-            }\n-        }\n-        if (data[index++] > JAVAZM_VERSION) {\n-            System.err.println(\"ZoneInfoOld: incompatible version (\"\n-                               + data[index - 1] + \"): \" + JAVAZM_FILE_NAME);\n-            return null;\n-        }\n-\n-        zoneInfoMappings = new SoftReference<>(data);\n-        return data;\n-    }\n-\n-    \/**\n-     * Reads the specified file under &lt;java.home&gt;\/lib\/zi into a buffer.\n-     * @return the buffer, or null if any I\/O error occurred.\n-     *\/\n-    private static byte[] readZoneInfoFile(final String fileName) {\n-        if (fileName.indexOf(\"..\") >= 0) {\n-            return null;\n-        }\n-        byte[] buffer = null;\n-        File file = new File(ziDir, fileName);\n-        try {\n-            int filesize = (int)file.length();\n-            if (filesize > 0) {\n-                FileInputStream fis = new FileInputStream(file);\n-                buffer = new byte[filesize];\n-                try {\n-                    if (fis.read(buffer) != filesize) {\n-                        throw new IOException(\"read error on \" + fileName);\n-                    }\n-                } finally {\n-                    fis.close();\n-                }\n-            }\n-        } catch (Exception ex) {\n-            if (!(ex instanceof FileNotFoundException) || JAVAZM_FILE_NAME.equals(fileName)) {\n-                System.err.println(\"ZoneInfoOld: \" + ex.getMessage());\n-            }\n-        }\n-        return buffer;\n-    }\n-\n-    private ZoneInfoFile() {\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneInfoFile.java","additions":0,"deletions":1049,"binary":false,"changes":1049,"status":"deleted"},{"patch":"@@ -1,1022 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.lang.ref.SoftReference;\n-import java.time.ZoneOffset;\n-import java.time.LocalDateTime;\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.SimpleTimeZone;\n-import java.util.TimeZone;\n-\n-import sun.util.calendar.CalendarSystem;\n-import sun.util.calendar.CalendarDate;\n-\n-\/**\n- * <code>ZoneInfoOld<\/code> is an implementation subclass of {@link\n- * java.util.TimeZone TimeZone} that represents GMT offsets and\n- * daylight saving time transitions of a time zone.\n- * <p>\n- * The daylight saving time transitions are described in the {@link\n- * #transitions transitions} table consisting of a chronological\n- * sequence of transitions of GMT offset and\/or daylight saving time\n- * changes. Since all transitions are represented in UTC, in theory,\n- * <code>ZoneInfoOld<\/code> can be used with any calendar systems except\n- * for the {@link #getOffset(int,int,int,int,int,int) getOffset}\n- * method that takes Gregorian calendar date fields.\n- * <p>\n- * This table covers transitions from 1900 until 2100 (as of version\n- * 23), Before 1900, it assumes that there was no daylight saving\n- * time and the <code>getOffset<\/code> methods always return the\n- * {@link #getRawOffset} value. No Local Mean Time is supported. If a\n- * specified date is beyond the transition table and this time zone is\n- * supposed to observe daylight saving time in 2100, it delegates\n- * operations to a {@link java.util.SimpleTimeZone SimpleTimeZone}\n- * object created using the daylight saving time schedule as of 2100.\n- * <p>\n- * The date items, transitions, GMT offset(s), etc. are read from a database\n- * file. See {@link ZoneInfoFile} for details.\n- * @see java.util.SimpleTimeZone\n- * @since 1.4\n- *\/\n-\n-public class ZoneInfoOld extends TimeZone {\n-\n-    \/\/ The constants assume no leap seconds support.\n-    static final int SECOND_IN_MILLIS = 1000;\n-    static final int MINUTE_IN_MILLIS = SECOND_IN_MILLIS * 60;\n-    static final int HOUR_IN_MILLIS = MINUTE_IN_MILLIS * 60;\n-    static final int DAY_IN_MILLIS = HOUR_IN_MILLIS * 24;\n-\n-    private static final int UTC_TIME = 0;\n-    private static final int STANDARD_TIME = 1;\n-    private static final int WALL_TIME = 2;\n-\n-    private static final long OFFSET_MASK = 0x0fL;\n-    private static final long DST_MASK = 0xf0L;\n-    private static final int DST_NSHIFT = 4;\n-    \/\/ this bit field is reserved for abbreviation support\n-    private static final long ABBR_MASK = 0xf00L;\n-    private static final int TRANSITION_NSHIFT = 12;\n-\n-    \/\/ IDs having conflicting data between Olson and JDK 1.1\n-    static final Map<String, String> conflictingIDs = Map.of(\n-        \"EST\", \"America\/Panama\",\n-        \"MST\", \"America\/Phoenix\");\n-\n-    private static final CalendarSystem gcal = CalendarSystem.getGregorianCalendar();\n-\n-    \/**\n-     * The raw GMT offset in milliseconds between this zone and GMT.\n-     * Negative offsets are to the west of Greenwich.  To obtain local\n-     * <em>standard<\/em> time, add the offset to GMT time.\n-     * @serial\n-     *\/\n-    int rawOffset;\n-\n-    \/**\n-     * Difference in milliseconds from the original GMT offset in case\n-     * the raw offset value has been modified by calling {@link\n-     * #setRawOffset}. The initial value is 0.\n-     * @serial\n-     *\/\n-    int rawOffsetDiff = 0;\n-\n-    \/**\n-     * A CRC32 value of all pairs of transition time (in milliseconds\n-     * in <code>long<\/code>) in local time and its GMT offset (in\n-     * seconds in <code>int<\/code>) in the chronological order. Byte\n-     * values of each <code>long<\/code> and <code>int<\/code> are taken\n-     * in the big endian order (i.e., MSB to LSB).\n-     * @serial\n-     *\/\n-    int checksum;\n-\n-    \/**\n-     * The amount of time in milliseconds saved during daylight saving\n-     * time. If <code>useDaylight<\/code> is false, this value is 0.\n-     * @serial\n-     *\/\n-    int dstSavings;\n-\n-    \/**\n-     * This array describes transitions of GMT offsets of this time\n-     * zone, including both raw offset changes and daylight saving\n-     * time changes.\n-     * A long integer consists of four bit fields.\n-     * <ul>\n-     * <li>The most significant 52-bit field represents transition\n-     * time in milliseconds from Gregorian January 1 1970, 00:00:00\n-     * GMT.<\/li>\n-     * <li>The next 4-bit field is reserved and must be 0.<\/li>\n-     * <li>The next 4-bit field is an index value to {@link #offsets\n-     * offsets[]} for the amount of daylight saving at the\n-     * transition. If this value is zero, it means that no daylight\n-     * saving, not the index value zero.<\/li>\n-     * <li>The least significant 4-bit field is an index value to\n-     * {@link #offsets offsets[]} for <em>total<\/em> GMT offset at the\n-     * transition.<\/li>\n-     * <\/ul>\n-     * If this time zone doesn't observe daylight saving time and has\n-     * never changed any GMT offsets in the past, this value is null.\n-     * @serial\n-     *\/\n-    long[] transitions;\n-\n-    \/**\n-     * This array holds all unique offset values in\n-     * milliseconds. Index values to this array are stored in the\n-     * transitions array elements.\n-     * @serial\n-     *\/\n-    int[] offsets;\n-\n-    \/**\n-     * SimpleTimeZone parameter values. It has to have either 8 for\n-     * {@link java.util.SimpleTimeZone#SimpleTimeZone(int, String,\n-     * int, int , int , int , int , int , int , int , int) the\n-     * 11-argument SimpleTimeZone constructor} or 10 for {@link\n-     * java.util.SimpleTimeZone#SimpleTimeZone(int, String, int, int,\n-     * int , int , int , int , int , int , int, int, int) the\n-     * 13-argument SimpleTimeZone constructor} parameters.\n-     * @serial\n-     *\/\n-    int[] simpleTimeZoneParams;\n-\n-    \/**\n-     * True if the raw GMT offset value would change after the time\n-     * zone data has been generated; false, otherwise. The default\n-     * value is false.\n-     * @serial\n-     *\/\n-    boolean willGMTOffsetChange = false;\n-\n-    \/**\n-     * True if the object has been modified after its instantiation.\n-     *\/\n-    transient private boolean dirty = false;\n-\n-    private static final long serialVersionUID = 2653134537216586139L;\n-\n-    \/**\n-     * A constructor.\n-     *\/\n-    public ZoneInfoOld() {\n-    }\n-\n-    \/**\n-     * A Constructor for CustomID.\n-     *\/\n-    public ZoneInfoOld(String ID, int rawOffset) {\n-        this(ID, rawOffset, 0, 0, null, null, null, false);\n-    }\n-\n-    \/**\n-     * Constructs a ZoneInfoOld instance.\n-     *\n-     * @param ID time zone name\n-     * @param rawOffset GMT offset in milliseconds\n-     * @param dstSavings daylight saving value in milliseconds or 0\n-     * (zero) if this time zone doesn't observe Daylight Saving Time.\n-     * @param checksum CRC32 value with all transitions table entry\n-     * values\n-     * @param transitions transition table\n-     * @param offsets offset value table\n-     * @param simpleTimeZoneParams parameter values for constructing\n-     * SimpleTimeZone\n-     * @param willGMTOffsetChange the value of willGMTOffsetChange\n-     *\/\n-    ZoneInfoOld(String ID,\n-             int rawOffset,\n-             int dstSavings,\n-             int checksum,\n-             long[] transitions,\n-             int[] offsets,\n-             int[] simpleTimeZoneParams,\n-             boolean willGMTOffsetChange) {\n-        setID(ID);\n-        this.rawOffset = rawOffset;\n-        this.dstSavings = dstSavings;\n-        this.checksum = checksum;\n-        this.transitions = transitions;\n-        this.offsets = offsets;\n-        this.simpleTimeZoneParams = simpleTimeZoneParams;\n-        this.willGMTOffsetChange = willGMTOffsetChange;\n-    }\n-\n-    \/**\n-     * Returns the difference in milliseconds between local time and UTC\n-     * of given time, taking into account both the raw offset and the\n-     * effect of daylight savings.\n-     *\n-     * @param date the milliseconds in UTC\n-     * @return the milliseconds to add to UTC to get local wall time\n-     *\/\n-    public int getOffset(long date) {\n-        return getOffsets(date, null, UTC_TIME);\n-    }\n-\n-    public int getOffsets(long utc, int[] offsets) {\n-        return getOffsets(utc, offsets, UTC_TIME);\n-    }\n-\n-    public int getOffsetsByStandard(long standard, int[] offsets) {\n-        return getOffsets(standard, offsets, STANDARD_TIME);\n-    }\n-\n-    public int getOffsetsByWall(long wall, int[] offsets) {\n-        return getOffsets(wall, offsets, WALL_TIME);\n-    }\n-\n-    private int getOffsets(long date, int[] offsets, int type) {\n-        \/\/ if dst is never observed, there is no transition.\n-        if (transitions == null) {\n-            int offset = getLastRawOffset();\n-            if (offsets != null) {\n-                offsets[0] = offset;\n-                offsets[1] = 0;\n-            }\n-            return offset;\n-        }\n-\n-        date -= rawOffsetDiff;\n-        int index = getTransitionIndex(date, type);\n-\n-        \/\/ prior to the transition table, returns the raw offset.\n-        \/\/ FIXME: should support LMT.\n-        if (index < 0) {\n-            int offset = getLastRawOffset();\n-            if (offsets != null) {\n-                offsets[0] = offset;\n-                offsets[1] = 0;\n-            }\n-            return offset;\n-        }\n-\n-        if (index < transitions.length) {\n-            long val = transitions[index];\n-            int offset = this.offsets[(int)(val & OFFSET_MASK)] + rawOffsetDiff;\n-            if (offsets != null) {\n-                int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-                int save = (dst == 0) ? 0 : this.offsets[dst];\n-                offsets[0] = offset - save;\n-                offsets[1] = save;\n-            }\n-            return offset;\n-        }\n-\n-        \/\/ beyond the transitions, delegate to SimpleTimeZone if there\n-        \/\/ is a rule; otherwise, return rawOffset.\n-        SimpleTimeZone tz = getLastRule();\n-        if (tz != null) {\n-            int rawoffset = tz.getRawOffset();\n-            long msec = date;\n-            if (type != UTC_TIME) {\n-                msec -= rawOffset;\n-            }\n-            int dstoffset = tz.getOffset(msec) - rawOffset;\n-\n-            \/\/ Check if it's in a standard-to-daylight transition.\n-            if (dstoffset > 0 && tz.getOffset(msec - dstoffset) == rawoffset) {\n-                dstoffset = 0;\n-            }\n-\n-            if (offsets != null) {\n-                offsets[0] = rawoffset;\n-                offsets[1] = dstoffset;\n-            }\n-            return rawoffset + dstoffset;\n-        }\n-        int offset = getLastRawOffset();\n-        if (offsets != null) {\n-            offsets[0] = offset;\n-            offsets[1] = 0;\n-        }\n-        return offset;\n-    }\n-\n-    private int getTransitionIndex(long date, int type) {\n-        int low = 0;\n-        int high = transitions.length - 1;\n-\n-        while (low <= high) {\n-            int mid = (low + high) \/ 2;\n-            long val = transitions[mid];\n-            long midVal = val >> TRANSITION_NSHIFT; \/\/ sign extended\n-            if (type != UTC_TIME) {\n-                midVal += offsets[(int)(val & OFFSET_MASK)]; \/\/ wall time\n-            }\n-            if (type == STANDARD_TIME) {\n-                int dstIndex = (int)((val >>> DST_NSHIFT) & 0xfL);\n-                if (dstIndex != 0) {\n-                    midVal -= offsets[dstIndex]; \/\/ make it standard time\n-                }\n-            }\n-\n-            if (midVal < date) {\n-                low = mid + 1;\n-            } else if (midVal > date) {\n-                high = mid - 1;\n-            } else {\n-                return mid;\n-            }\n-        }\n-\n-        \/\/ if beyond the transitions, returns that index.\n-        if (low >= transitions.length) {\n-            return low;\n-        }\n-        return low - 1;\n-    }\n-\n-   \/**\n-     * Returns the difference in milliseconds between local time and\n-     * UTC, taking into account both the raw offset and the effect of\n-     * daylight savings, for the specified date and time.  This method\n-     * assumes that the start and end month are distinct.  This method\n-     * assumes a Gregorian calendar for calculations.\n-     * <p>\n-     * <em>Note: In general, clients should use\n-     * {@link Calendar#ZONE_OFFSET Calendar.get(ZONE_OFFSET)} +\n-     * {@link Calendar#DST_OFFSET Calendar.get(DST_OFFSET)}\n-     * instead of calling this method.<\/em>\n-     *\n-     * @param era       The era of the given date. The value must be either\n-     *                  GregorianCalendar.AD or GregorianCalendar.BC.\n-     * @param year      The year in the given date.\n-     * @param month     The month in the given date. Month is 0-based. e.g.,\n-     *                  0 for January.\n-     * @param day       The day-in-month of the given date.\n-     * @param dayOfWeek The day-of-week of the given date.\n-     * @param millis    The milliseconds in day in <em>standard<\/em> local time.\n-     * @return The milliseconds to add to UTC to get local time.\n-     *\/\n-    public int getOffset(int era, int year, int month, int day,\n-                         int dayOfWeek, int milliseconds) {\n-        if (milliseconds < 0 || milliseconds >= DAY_IN_MILLIS) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (era == java.util.GregorianCalendar.BC) { \/\/ BC\n-            year = 1 - year;\n-        } else if (era != java.util.GregorianCalendar.AD) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        CalendarDate date = gcal.newCalendarDate(null);\n-        date.setDate(year, month + 1, day);\n-        if (gcal.validate(date) == false) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        \/\/ bug-for-bug compatible argument checking\n-        if (dayOfWeek < java.util.GregorianCalendar.SUNDAY\n-            || dayOfWeek > java.util.GregorianCalendar.SATURDAY) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (transitions == null) {\n-            return getLastRawOffset();\n-        }\n-\n-        long dateInMillis = gcal.getTime(date) + milliseconds;\n-        dateInMillis -= (long) rawOffset; \/\/ make it UTC\n-        return getOffsets(dateInMillis, null, UTC_TIME);\n-    }\n-\n-    \/**\n-     * Sets the base time zone offset from GMT. This operation\n-     * modifies all the transitions of this ZoneInfoOld object, including\n-     * historical ones, if applicable.\n-     *\n-     * @param offsetMillis the base time zone offset to GMT.\n-     * @see getRawOffset\n-     *\/\n-    public synchronized void setRawOffset(int offsetMillis) {\n-        if (offsetMillis == rawOffset + rawOffsetDiff) {\n-            return;\n-        }\n-        rawOffsetDiff = offsetMillis - rawOffset;\n-        if (lastRule != null) {\n-            lastRule.setRawOffset(offsetMillis);\n-        }\n-        dirty = true;\n-    }\n-\n-    \/**\n-     * Returns the GMT offset of the current date. This GMT offset\n-     * value is not modified during Daylight Saving Time.\n-     *\n-     * @return the GMT offset value in milliseconds to add to UTC time\n-     * to get local standard time\n-     *\/\n-    public int getRawOffset() {\n-        if (!willGMTOffsetChange) {\n-            return rawOffset + rawOffsetDiff;\n-        }\n-\n-        int[] offsets = new int[2];\n-        getOffsets(System.currentTimeMillis(), offsets, UTC_TIME);\n-        return offsets[0];\n-    }\n-\n-    public boolean isDirty() {\n-        return dirty;\n-    }\n-\n-    int getLastRawOffset() {\n-        return rawOffset + rawOffsetDiff;\n-    }\n-\n-    \/**\n-     * Queries if this time zone uses Daylight Saving Time in the last known rule.\n-     *\/\n-    public boolean useDaylightTime() {\n-        return (simpleTimeZoneParams != null);\n-    }\n-\n-    @Override\n-    public boolean observesDaylightTime() {\n-        if (simpleTimeZoneParams != null) {\n-            return true;\n-        }\n-        if (transitions == null) {\n-            return false;\n-        }\n-\n-        \/\/ Look up the transition table to see if it's in DST right\n-        \/\/ now or if there's any standard-to-daylight transition at\n-        \/\/ any future.\n-        long utc = System.currentTimeMillis() - rawOffsetDiff;\n-        int index = getTransitionIndex(utc, UTC_TIME);\n-\n-        \/\/ before transitions in the transition table\n-        if (index < 0) {\n-            return false;\n-        }\n-\n-        \/\/ the time is in the table range.\n-        for (int i = index; i < transitions.length; i++) {\n-            if ((transitions[i] & DST_MASK) != 0) {\n-                return true;\n-            }\n-        }\n-        \/\/ No further DST is observed.\n-        return false;\n-    }\n-\n-    \/**\n-     * Queries if the specified date is in Daylight Saving Time.\n-     *\/\n-    public boolean inDaylightTime(Date date) {\n-        if (date == null) {\n-            throw new NullPointerException();\n-        }\n-\n-        if (transitions == null) {\n-            return false;\n-        }\n-\n-        long utc = date.getTime() - rawOffsetDiff;\n-        int index = getTransitionIndex(utc, UTC_TIME);\n-\n-        \/\/ before transitions in the transition table\n-        if (index < 0) {\n-            return false;\n-        }\n-\n-        \/\/ the time is in the table range.\n-        if (index < transitions.length) {\n-            return (transitions[index] & DST_MASK) != 0;\n-        }\n-\n-        \/\/ beyond the transition table\n-        SimpleTimeZone tz = getLastRule();\n-        if (tz != null) {\n-            return tz.inDaylightTime(date);\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns the amount of time in milliseconds that the clock is advanced\n-     * during daylight saving time is in effect in its last daylight saving time rule.\n-     *\n-     * @return the number of milliseconds the time is advanced with respect to\n-     * standard time when daylight saving time is in effect.\n-     *\/\n-    public int getDSTSavings() {\n-        return dstSavings;\n-    }\n-\n-\/\/    \/**\n-\/\/     * @return the last year in the transition table or -1 if this\n-\/\/     * time zone doesn't observe any daylight saving time.\n-\/\/     *\/\n-\/\/    public int getMaxTransitionYear() {\n-\/\/      if (transitions == null) {\n-\/\/          return -1;\n-\/\/      }\n-\/\/      long val = transitions[transitions.length - 1];\n-\/\/      int offset = this.offsets[(int)(val & OFFSET_MASK)] + rawOffsetDiff;\n-\/\/      val = (val >> TRANSITION_NSHIFT) + offset;\n-\/\/      CalendarDate lastDate = Gregorian.getCalendarDate(val);\n-\/\/      return lastDate.getYear();\n-\/\/    }\n-\n-    \/**\n-     * Returns a string representation of this time zone.\n-     * @return the string\n-     *\/\n-    public String toString() {\n-        return getClass().getName() +\n-            \"[id=\\\"\" + getID() + \"\\\"\" +\n-            \",offset=\" + getLastRawOffset() +\n-            \",dstSavings=\" + dstSavings +\n-            \",useDaylight=\" + useDaylightTime() +\n-            \",transitions=\" + ((transitions != null) ? transitions.length : 0) +\n-            \",lastRule=\" + (lastRule == null ? getLastRuleInstance() : lastRule) +\n-            \"]\";\n-    }\n-\n-    \/**\n-     * Gets all available IDs supported in the Java run-time.\n-     *\n-     * @return an array of time zone IDs.\n-     *\/\n-    public static String[] getAvailableIDs() {\n-        List<String> idList = ZoneInfoFile.getZoneIDs();\n-        List<String> excluded = ZoneInfoFile.getExcludedZones();\n-        if (excluded != null) {\n-            \/\/ List all zones from the idList and excluded lists\n-            List<String> list = new ArrayList<>(idList.size() + excluded.size());\n-            list.addAll(idList);\n-            list.addAll(excluded);\n-            idList = list;\n-        }\n-        String[] ids = new String[idList.size()];\n-        return idList.toArray(ids);\n-    }\n-\n-    \/**\n-     * Gets all available IDs that have the same value as the\n-     * specified raw GMT offset.\n-     *\n-     * @param rawOffset the GMT offset in milliseconds. This\n-     * value should not include any daylight saving time.\n-     *\n-     * @return an array of time zone IDs.\n-     *\/\n-    public static String[] getAvailableIDs(int rawOffset) {\n-        String[] result;\n-        List<String> matched = new ArrayList<>();\n-        List<String> IDs = ZoneInfoFile.getZoneIDs();\n-        int[] rawOffsets = ZoneInfoFile.getRawOffsets();\n-\n-    loop:\n-        for (int index = 0; index < rawOffsets.length; index++) {\n-            if (rawOffsets[index] == rawOffset) {\n-                byte[] indices = ZoneInfoFile.getRawOffsetIndices();\n-                for (int i = 0; i < indices.length; i++) {\n-                    if (indices[i] == index) {\n-                        matched.add(IDs.get(i++));\n-                        while (i < indices.length && indices[i] == index) {\n-                            matched.add(IDs.get(i++));\n-                        }\n-                        break loop;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ We need to add any zones from the excluded zone list that\n-        \/\/ currently have the same GMT offset as the specified\n-        \/\/ rawOffset. The zones returned by this method may not be\n-        \/\/ correct as of return to the caller if any GMT offset\n-        \/\/ transition is happening during this GMT offset checking...\n-        List<String> excluded = ZoneInfoFile.getExcludedZones();\n-        if (excluded != null) {\n-            for (String id : excluded) {\n-                TimeZone zi = getTimeZone(id);\n-                if (zi != null && zi.getRawOffset() == rawOffset) {\n-                    matched.add(id);\n-                }\n-            }\n-        }\n-\n-        result = new String[matched.size()];\n-        matched.toArray(result);\n-        return result;\n-    }\n-\n-    \/**\n-     * Gets the ZoneInfoOld for the given ID.\n-     *\n-     * @param ID the ID for a ZoneInfoOld. See TimeZone for detail.\n-     *\n-     * @return the specified ZoneInfoOld object, or null if there is no\n-     * time zone of the ID.\n-     *\/\n-    public static TimeZone getTimeZone(String ID) {\n-        String givenID = null;\n-\n-        ZoneInfoOld zi = ZoneInfoFile.getZoneInfoOld(ID);\n-        if (zi == null) {\n-            \/\/ if we can't create an object for the ID, try aliases.\n-            try {\n-                Map<String, String> map = getAliasTable();\n-                String alias = ID;\n-                while ((alias = map.get(alias)) != null) {\n-                    zi = ZoneInfoFile.getZoneInfoOld(alias);\n-                    if (zi != null) {\n-                        zi.setID(ID);\n-                        zi = ZoneInfoFile.addToCache(ID, zi);\n-                        zi = (ZoneInfoOld) zi.clone();\n-                        break;\n-                    }\n-                }\n-            } catch (Exception e) {\n-                \/\/ ignore exceptions\n-            }\n-        }\n-\n-        if (givenID != null && zi != null) {\n-            zi.setID(givenID);\n-        }\n-        return zi;\n-    }\n-\n-    private transient SimpleTimeZone lastRule;\n-\n-    \/**\n-     * Returns a SimpleTimeZone object representing the last GMT\n-     * offset and DST schedule or null if this time zone doesn't\n-     * observe DST.\n-     *\/\n-    synchronized SimpleTimeZone getLastRule() {\n-        if (lastRule == null) {\n-            lastRule = getLastRuleInstance();\n-        }\n-        return lastRule;\n-    }\n-\n-    \/**\n-     * Returns a SimpleTimeZone object that represents the last\n-     * known daylight saving time rules.\n-     *\n-     * @return a SimpleTimeZone object or null if this time zone\n-     * doesn't observe DST.\n-     *\/\n-    public SimpleTimeZone getLastRuleInstance() {\n-        if (simpleTimeZoneParams == null) {\n-            return null;\n-        }\n-        if (simpleTimeZoneParams.length == 10) {\n-            return new SimpleTimeZone(getLastRawOffset(), getID(),\n-                                      simpleTimeZoneParams[0],\n-                                      simpleTimeZoneParams[1],\n-                                      simpleTimeZoneParams[2],\n-                                      simpleTimeZoneParams[3],\n-                                      simpleTimeZoneParams[4],\n-                                      simpleTimeZoneParams[5],\n-                                      simpleTimeZoneParams[6],\n-                                      simpleTimeZoneParams[7],\n-                                      simpleTimeZoneParams[8],\n-                                      simpleTimeZoneParams[9],\n-                                      dstSavings);\n-        }\n-        return new SimpleTimeZone(getLastRawOffset(), getID(),\n-                                  simpleTimeZoneParams[0],\n-                                  simpleTimeZoneParams[1],\n-                                  simpleTimeZoneParams[2],\n-                                  simpleTimeZoneParams[3],\n-                                  simpleTimeZoneParams[4],\n-                                  simpleTimeZoneParams[5],\n-                                  simpleTimeZoneParams[6],\n-                                  simpleTimeZoneParams[7],\n-                                  dstSavings);\n-    }\n-\n-    \/**\n-     * Returns a copy of this <code>ZoneInfoOld<\/code>.\n-     *\/\n-    public Object clone() {\n-        ZoneInfoOld zi = (ZoneInfoOld) super.clone();\n-        zi.lastRule = null;\n-        return zi;\n-    }\n-\n-    \/**\n-     * Returns a hash code value calculated from the GMT offset and\n-     * transitions.\n-     * @return a hash code of this time zone\n-     *\/\n-    public int hashCode() {\n-        return getLastRawOffset() ^ checksum;\n-    }\n-\n-    \/**\n-     * Compares the equity of two ZoneInfoOld objects.\n-     *\n-     * @param obj the object to be compared with\n-     * @return true if given object is same as this ZoneInfoOld object,\n-     * false otherwise.\n-     *\/\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (!(obj instanceof ZoneInfoOld)) {\n-            return false;\n-        }\n-        ZoneInfoOld that = (ZoneInfoOld) obj;\n-        return (getID().equals(that.getID())\n-                && (getLastRawOffset() == that.getLastRawOffset())\n-                && (checksum == that.checksum));\n-    }\n-\n-    \/**\n-     * Returns true if this zone has the same raw GMT offset value and\n-     * transition table as another zone info. If the specified\n-     * TimeZone object is not a ZoneInfoOld instance, this method returns\n-     * true if the specified TimeZone object has the same raw GMT\n-     * offset value with no daylight saving time.\n-     *\n-     * @param other the ZoneInfoOld object to be compared with\n-     * @return true if the given <code>TimeZone<\/code> has the same\n-     * GMT offset and transition information; false, otherwise.\n-     *\/\n-    public boolean hasSameRules(TimeZone other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (other == null) {\n-            return false;\n-        }\n-        if (!(other instanceof ZoneInfoOld)) {\n-            if (getRawOffset() != other.getRawOffset()) {\n-                return false;\n-            }\n-            \/\/ if both have the same raw offset and neither observes\n-            \/\/ DST, they have the same rule.\n-            if ((transitions == null)\n-                && (useDaylightTime() == false)\n-                && (other.useDaylightTime() == false)) {\n-                return true;\n-            }\n-            return false;\n-        }\n-        if (getLastRawOffset() != ((ZoneInfoOld)other).getLastRawOffset()) {\n-            return false;\n-        }\n-        return (checksum == ((ZoneInfoOld)other).checksum);\n-    }\n-\n-    private static SoftReference<Map<String, String>> aliasTable;\n-\n-    static Map<String, String> getCachedAliasTable() {\n-        Map<String, String> aliases = null;\n-\n-        SoftReference<Map<String, String>> cache = aliasTable;\n-        if (cache != null) {\n-            aliases = cache.get();\n-        }\n-        return aliases;\n-    }\n-\n-    \/**\n-     * Returns a Map from alias time zone IDs to their standard\n-     * time zone IDs.\n-     *\n-     * @return the Map that holds the mappings from alias time zone IDs\n-     *    to their standard time zone IDs, or null if\n-     *    <code>ZoneInfoOldMappings<\/code> file is not available.\n-     *\/\n-     public synchronized static Map<String, String> getAliasTable() {\n-         Map<String, String> aliases = getCachedAliasTable();\n-         if (aliases == null) {\n-             aliases = ZoneInfoFile.getZoneAliases();\n-             if (aliases != null) {\n-                 \/\/ Replace old mappings from `jdk11_backward`\n-                 aliases.putAll(conflictingIDs);\n-                 aliasTable = new SoftReference<Map<String, String>>(aliases);\n-             }\n-         }\n-         return aliases;\n-     }\n-\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        \/\/ We don't know how this object from 1.4.x or earlier has\n-        \/\/ been mutated. So it should always be marked as `dirty'.\n-        dirty = true;\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    public boolean equalsTo(ZoneInfoOld other) {\n-        return (getID().equals(other.getID())\n-                && (getLastRawOffset() == other.getLastRawOffset())\n-                && (dstSavings == other.dstSavings)\n-                && (willGMTOffsetChange == other.willGMTOffsetChange)\n-                && (checksum == other.checksum)\n-                && equalsTransOffsets(other)\n-                && (Arrays.equals(simpleTimeZoneParams, other.simpleTimeZoneParams) ||\n-                    getLastRule().equals(other.getLastRule())));\n-    }\n-\n-    private boolean equalsTransOffsets(ZoneInfoOld other) {\n-        if (transitions == null) {\n-            return (other.transitions == null &&\n-                    Arrays.equals(offsets, other.offsets));\n-        }\n-        if (other.transitions == null ||\n-            transitions.length != other.transitions.length) {\n-            return false;\n-        }\n-        \/\/ if offsets and other.offsets have different order\n-        \/\/ the last 4-bit in trans are different.\n-        for (int i = 0; i < transitions.length; i++) {\n-            long val = transitions[i];\n-            int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-            int save = (dst == 0) ? 0 : offsets[dst] \/ 1000;\n-            int off = offsets[(int)(val & OFFSET_MASK)]\/1000;\n-            long second = (val >> TRANSITION_NSHIFT)\/1000;\n-\n-            val = other.transitions[i];\n-            int dstO = (int)((val >>> DST_NSHIFT) & 0xfL);\n-            int saveO = (dstO == 0) ? 0 : other.offsets[dstO] \/ 1000;\n-            int offO = other.offsets[(int)(val & OFFSET_MASK)]\/1000;\n-            long secondO = (val >> TRANSITION_NSHIFT)\/1000;\n-            if ((dst == 0) != (dstO == 0) || save != saveO || off != offO || second != secondO)\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    private int transToString(long val, int off_old, int[] offsets, StringBuilder sb) {\n-        int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-        int save = (dst == 0) ? 0 : offsets[dst] \/ 1000;\n-        int off = offsets[(int)(val & OFFSET_MASK)]\/1000;\n-        long second = (val >> TRANSITION_NSHIFT)\/1000;\n-        ZoneOffset offset_old = ZoneOffset.ofTotalSeconds(off_old);\n-        ZoneOffset offset = ZoneOffset.ofTotalSeconds(off);\n-        sb.append(\"          \" + LocalDateTime.ofEpochSecond(second, 0, offset_old));\n-\n-        sb.append(\"  [utc=\" + second +\n-                  \"   raw=\" + Long.toHexString(val >> TRANSITION_NSHIFT) +\n-                  \", offset=\" + off + \"\/\" + offset + \", saving=\" + save + \"]\");\n-        return off;\n-    }\n-\n-    public String diffsTo(ZoneInfoOld other) {\n-\n-        int rawOffset0                = other.rawOffset;\n-        int checksum0                 = other.checksum;\n-        int dstSavings0               = other.dstSavings;\n-        long[] transitions0           = other.transitions;\n-        int[] offsets0                = other.offsets;\n-        int[] simpleTimeZoneParams0   = other.simpleTimeZoneParams;\n-        boolean willGMTOffsetChange0  = other.willGMTOffsetChange;\n-\n-\n-        \/\/return getClass().getName() +\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"******************************\\n\" +\n-                  getID() + \" : \" + other.getID());\n-        \/\/ ROC is excluded by ZoneInfoOld\n-        if (\"ROC\".equals(getID())) {\n-            return sb.toString();\n-        }\n-        if (rawOffset != rawOffset0 ||\n-            dstSavings != dstSavings0 ||\n-            checksum != checksum0 ||\n-            willGMTOffsetChange != willGMTOffsetChange0 ||\n-            (simpleTimeZoneParams != null ) != (simpleTimeZoneParams0 != null) ||\n-            (transitions != null && transitions0 != null &&\n-            transitions.length != transitions0.length))\n-        {\n-            sb.append(\"\\n    offset=\" + getLastRawOffset() +\n-                  \",dstSavings=\" + dstSavings +\n-                  \",useDaylight=\" + useDaylightTime() +\n-                  \",transitions=\" + ((transitions != null) ? transitions.length : 0) +\n-                  \",offsets=\" + ((offsets != null) ? offsets.length : 0) +\n-                  \",checksum=\" + checksum +\n-                  \",gmtChanged=\" + willGMTOffsetChange)\n-              .append(\"\\n[NG]offset=\" + rawOffset0 +\n-                      \",dstSavings=\" + dstSavings0 +\n-                      \",useDaylight=\" + (simpleTimeZoneParams != null) +\n-                      \",transitions=\" + ((transitions0 != null) ? transitions0.length : 0) +\n-                      \",offsets=\" + ((offsets0 != null) ? offsets0.length : 0) +\n-                      \",checksum=\" + checksum0 +\n-                      \",gmtChanged=\" + willGMTOffsetChange0 +\n-                      \"\");\n-        }\n-        \/\/ offsets\n-        if (!Arrays.equals(offsets, offsets0)) {\n-            sb.append(\"\\n    offset.len=\" + ((offsets != null)? offsets.length : \"null\") +\n-                      \"    \" + ((offsets0 != null)? offsets0.length : \"null\"));\n-            if (offsets != null && offsets0.length != 0) {\n-                int len = Math.min(offsets.length, offsets0.length);\n-                int i = 0;\n-                for (i = 0; i < len; i++) {\n-                    sb.append(\"\\n        \" +\n-                              ZoneOffset.ofTotalSeconds(offsets[i]\/1000) + \"    \" +\n-                              ZoneOffset.ofTotalSeconds(offsets0[i]\/1000));\n-                }\n-                for (; i < offsets0.length; i++) {\n-                    sb.append(\"\\n                  \" + ZoneOffset.ofTotalSeconds(offsets0[i]\/1000));\n-                }\n-            }\n-        }\n-        \/\/ trans\n-        int offset = 0;\n-        int offset0 = 0;\n-        if (!equalsTransOffsets(other)) {\n-            sb.append(\"\\n    -------------\");\n-            if ((transitions == null) != (transitions0 == null)) {\n-                sb.append(\"\\n     (NG) Different trans(null) :\" +\n-                transitions + \", \" + transitions0);\n-                if (transitions != null) {\n-                    for (int i = 0; i < transitions.length; i++) {\n-                        sb.append(\"\\n    (NG)\");\n-                        offset = transToString(transitions[i], offset, offsets, sb);\n-                    }\n-                }\n-            } else {\n-                if (transitions.length != transitions0.length) {\n-                    sb.append(\"\\n    (NG) Different trans size :\" +\n-                              transitions.length + \", \" + transitions0.length);\n-                }\n-                int length = Math.min(transitions.length, transitions0.length);\n-                for (int i = 0; i < length; i++) {\n-                    \/\/ sb.append(\"\\n[\" + i + \"]    \");\n-                    \/\/ offset = transToString(transitions[i], offset, offsets, sb);\n-                    long val = transitions[i];\n-                    int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-                    int save = (dst == 0) ? 0 : offsets[dst] \/ 1000;\n-                    int off = offsets[(int)(val & OFFSET_MASK)]\/1000;\n-                    long second = (val >> TRANSITION_NSHIFT)\/1000;\n-                    sb.append(\"\\n        \");\n-                    offset = transToString(transitions[i], offset, offsets, sb);\n-                    if (transitions0 == null || i >= transitions0.length) {\n-                        sb.append(\"\\n    \");\n-                        offset = transToString(transitions[i], offset, offsets, sb);\n-                        sb.append(\"\\n     (NG) trans0 is null or < trans.length\");\n-                    } else {\n-                        long val0 = transitions0[i];\n-                        int dst0 = (int)((val0 >>> DST_NSHIFT) & 0xfL);\n-                        int save0 = (dst0 == 0) ? 0 : offsets0[dst0] \/ 1000;\n-                        int off0 = offsets0[(int)(val0 & OFFSET_MASK)]\/1000;\n-                        long second0 = (val0 >> TRANSITION_NSHIFT)\/1000;\n-                        if (save != save0 || off != off0 || second != second0) {\n-                            sb.append(\"\\n    (NG)\");\n-                        } else {\n-                            sb.append(\"\\n    (OK)\");\n-                        }\n-                        offset0 = transToString(transitions0[i], offset0, offsets0, sb);\n-                        sb.append(\"\\n            -----\");\n-                    }\n-                }\n-            }\n-        }\n-        SimpleTimeZone stz = getLastRuleInstance();\n-        if (stz != null) {\n-            SimpleTimeZone stz0 = other.getLastRule();\n-            if (!stz.hasSameRules(stz0)) {\n-                sb.append(\"\\n    -------------\")\n-                  .append(\"\\n    SimpleTimeZone (NG)\")\n-                  .append(\"\\n       stz=\" + stz)\n-                  .append(\"\\n      stz0=\" + stz0);\n-            }\n-        }\n-        sb.append(\"\\n    -------------\");\n-        return sb.toString();\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneInfoOld.java","additions":0,"deletions":1022,"binary":false,"changes":1022,"status":"deleted"},{"patch":"@@ -1,248 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * ZoneRec hold information of time zone corresponding to each text\n- * line of the \"Zone\" part.\n- *\n- * @since 1.4\n- *\/\n-class ZoneRec {\n-    private int gmtOffset;\n-    private String ruleName;\n-    private int directSave;\n-    private Rule ruleRef;\n-    private String format;\n-    private boolean hasUntil;\n-    private int untilYear;\n-    private Month untilMonth;\n-    private RuleDay untilDay;\n-    private Time untilTime;\n-    private long untilInMillis;\n-    private String line;\n-\n-    \/**\n-     * @return the \"UNTIL\" value in milliseconds\n-     *\/\n-    Time getUntilTime() {\n-        return untilTime;\n-    }\n-\n-    \/**\n-     * @return the GMT offset value in milliseconds\n-     *\/\n-    int getGmtOffset() {\n-        return gmtOffset;\n-    }\n-\n-    \/**\n-     * @return the rule name to which this zone record refers\n-     *\/\n-    String getRuleName() {\n-        return ruleName;\n-    }\n-\n-    \/**\n-     * @return the amount of saving time directly defined in the\n-     * \"RULES\/SAVE\" field.\n-     *\/\n-    int getDirectSave() {\n-        return directSave;\n-    }\n-\n-    \/**\n-     * @return true if this zone record has a reference to a rule\n-     *\/\n-    boolean hasRuleReference() {\n-        return ruleRef != null;\n-    }\n-\n-    \/**\n-     * Returns the \"FORMAT\" field string of this zone record. This\n-     * @return the \"FORMAT\" field\n-     *\/\n-    String getFormat() {\n-        return format;\n-    }\n-\n-    \/**\n-     * @return the year in the \"UNTIL\" field\n-     *\/\n-    int getUntilYear() {\n-        return untilYear;\n-    }\n-\n-    \/**\n-     * Returns the \"UNTIL\" field value in milliseconds from Janurary\n-     * 1, 1970 0:00 GMT.\n-     * @param currentSave the amount of daylight saving in\n-     * milliseconds that is used to adjust wall-clock time.\n-     * @return the milliseconds value of the \"UNTIL\" field\n-     *\/\n-    long getUntilTime(int currentSave) {\n-        if (untilTime.isWall()) {\n-            return untilInMillis - currentSave;\n-        }\n-        return untilInMillis;\n-    }\n-\n-    \/**\n-     * Returns the \"UNTIL\" time in milliseconds without adjusting GMT\n-     * offsets or daylight saving.\n-     * @return local \"UNTIL\" time in milliseconds\n-     *\/\n-    long getLocalUntilTime() {\n-        return Time.getLocalTime(untilYear,\n-                                 untilMonth,\n-                                 untilDay,\n-                                 untilTime.getTime());\n-    }\n-\n-    \/**\n-     * Returns the \"UNTIL\" time in milliseconds with adjusting GMT offsets and daylight saving.\n-     * @return the \"UNTIL\" time after the adjustment\n-     *\/\n-    long getLocalUntilTime(int save, int gmtOffset) {\n-        return Time.getLocalTime(untilYear,\n-                                 untilMonth,\n-                                 untilDay,\n-                                 save,\n-                                 gmtOffset,\n-                                 untilTime);\n-    }\n-\n-    \/**\n-     * @return the text line of this zone record\n-     *\/\n-    String getLine() {\n-        return line;\n-    }\n-\n-    \/**\n-     * Sets the specified text line to this zone record\n-     *\/\n-    void setLine(String line) {\n-        this.line = line;\n-    }\n-\n-    \/**\n-     * @return true if this zone record has the \"UNTIL\" field\n-     *\/\n-    boolean hasUntil() {\n-        return this.hasUntil;\n-    }\n-\n-    \/**\n-     * Adjusts the \"UNTIL\" time to GMT offset if this zone record has\n-     * it.  <code>untilTime<\/code> is not adjusted to daylight saving\n-     * in this method.\n-     *\/\n-    void adjustTime() {\n-        if (!hasUntil()) {\n-            return;\n-        }\n-        if (untilTime.isSTD() || untilTime.isWall()) {\n-            \/\/ adjust to gmt offset only here.  adjust to real\n-            \/\/ wall-clock time when tracking rules\n-            untilInMillis -= gmtOffset;\n-        }\n-    }\n-\n-    \/**\n-     * @return the reference to the Rule object\n-     *\/\n-    Rule getRuleRef() {\n-        return ruleRef;\n-    }\n-\n-    \/**\n-     * Resolves the reference to a Rule and adjusts its \"UNTIL\" time\n-     * to GMT offset.\n-     *\/\n-    void resolve(Zoneinfo zi) {\n-        if (ruleName != null && (!\"-\".equals(ruleName))) {\n-                ruleRef = zi.getRule(ruleName);\n-        }\n-        adjustTime();\n-    }\n-\n-    \/**\n-     * Parses a Zone text line that is described by a StringTokenizer.\n-     * @param tokens represents tokens of a Zone text line\n-     * @return the zone record produced by parsing the text\n-     *\/\n-    static ZoneRec parse(StringTokenizer tokens) {\n-        ZoneRec rec = new ZoneRec();\n-        try {\n-            rec.gmtOffset = (int) Time.parse(tokens.nextToken()).getTime();\n-            String token = tokens.nextToken();\n-            char c = token.charAt(0);\n-            if (c >= '0' && c <= '9') {\n-                rec.directSave = (int) Time.parse(token).getTime();\n-            } else {\n-                rec.ruleName = token;\n-            }\n-            rec.format = tokens.nextToken();\n-            if (tokens.hasMoreTokens()) {\n-                rec.hasUntil = true;\n-                rec.untilYear = Integer.parseInt(tokens.nextToken());\n-                if (tokens.hasMoreTokens()) {\n-                    rec.untilMonth = Month.parse(tokens.nextToken());\n-                } else {\n-                    rec.untilMonth = Month.JANUARY;\n-                }\n-                if (tokens.hasMoreTokens()) {\n-                    rec.untilDay = RuleDay.parse(tokens.nextToken());\n-                } else {\n-                    rec.untilDay = new RuleDay(1);\n-                }\n-                if (tokens.hasMoreTokens()) {\n-                    rec.untilTime = Time.parse(tokens.nextToken());\n-                } else {\n-                    rec.untilTime = Time.parse(\"0:00\");\n-                }\n-                rec.untilInMillis = rec.getLocalUntilTime();\n-            }\n-        } catch (Exception e) {\n-            \/\/ TODO: error reporting\n-            e.printStackTrace();\n-        }\n-        return rec;\n-    }\n-\n-    private static void panic(String msg) {\n-        Main.panic(msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneRec.java","additions":0,"deletions":248,"binary":false,"changes":248,"status":"deleted"},{"patch":"@@ -1,579 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * Zoneinfo provides javazic compiler front-end functionality.\n- * @since 1.4\n- *\/\n-class Zoneinfo {\n-\n-    private static final int minYear = 1900;\n-    private static final int maxYear = 2100;\n-    private static final long minTime = Time.getLocalTime(minYear, Month.JANUARY, 1, 0);\n-    private static int startYear = minYear;\n-    private static int endYear = maxYear;\n-\n-    \/**\n-     * True if javazic should generate a list of SimpleTimeZone\n-     * instances for the SimpleTimeZone-based time zone support.\n-     *\/\n-    static boolean isYearForTimeZoneDataSpecified = false;\n-\n-    \/**\n-     * Zone name to Zone mappings\n-     *\/\n-    private Map<String,Zone> zones;\n-\n-    \/**\n-     * Rule name to Rule mappings\n-     *\/\n-    private Map<String,Rule> rules;\n-\n-    \/**\n-     * Alias name to real name mappings\n-     *\/\n-    private Map<String,String> aliases;\n-\n-    \/**\n-     * Constracts a Zoneinfo.\n-     *\/\n-    Zoneinfo() {\n-        zones = new HashMap<String,Zone>();\n-        rules = new HashMap<String,Rule>();\n-        aliases = new HashMap<String,String>();\n-    }\n-\n-    \/**\n-     * Adds the given zone to the list of Zones.\n-     * @param zone Zone to be added to the list.\n-     *\/\n-    void add(Zone zone) {\n-        String name = zone.getName();\n-        zones.put(name, zone);\n-    }\n-\n-    \/**\n-     * Adds the given rule to the list of Rules.\n-     * @param rule Rule to be added to the list.\n-     *\/\n-    void add(Rule rule) {\n-        String name = rule.getName();\n-        rules.put(name, rule);\n-    }\n-\n-    \/**\n-     * Puts the specifid name pair to the alias table.\n-     * @param name1 an alias time zone name\n-     * @param name2 the real time zone of the alias name\n-     *\/\n-    void putAlias(String name1, String name2) {\n-        aliases.put(name1, name2);\n-    }\n-\n-    \/**\n-     * Sets the given year for SimpleTimeZone list output.\n-     * This method is called when the -S option is specified.\n-     * @param year the year for which SimpleTimeZone list should be generated\n-     *\/\n-    static void setYear(int year) {\n-        setStartYear(year);\n-        setEndYear(year);\n-        isYearForTimeZoneDataSpecified = true;\n-    }\n-\n-    \/**\n-     * Sets the start year.\n-     * @param year the start year value\n-     * @throws IllegalArgumentException if the specified year value is\n-     * smaller than the minimum year or greater than the end year.\n-     *\/\n-    static void setStartYear(int year) {\n-        if (year < minYear || year > endYear) {\n-            throw new IllegalArgumentException(\"invalid start year specified: \" + year);\n-        }\n-        startYear = year;\n-    }\n-\n-    \/**\n-     * @return the start year value\n-     *\/\n-    static int getStartYear() {\n-        return startYear;\n-    }\n-\n-    \/**\n-     * Sets the end year.\n-     * @param year the end year value\n-     * @throws IllegalArgumentException if the specified year value is\n-     * smaller than the start year or greater than the maximum year.\n-     *\/\n-    static void setEndYear(int year) {\n-        if (year < startYear || year > maxYear) {\n-            throw new IllegalArgumentException();\n-        }\n-        endYear = year;\n-    }\n-\n-    \/**\n-     * @return the end year value\n-     *\/\n-    static int getEndYear() {\n-        return endYear;\n-    }\n-\n-    \/**\n-     * @return the minimum year value\n-     *\/\n-    static int getMinYear() {\n-        return minYear;\n-    }\n-\n-    \/**\n-     * @return the maximum year value\n-     *\/\n-    static int getMaxYear() {\n-        return maxYear;\n-    }\n-\n-    \/**\n-     * @return the alias table\n-     *\/\n-    Map<String,String> getAliases() {\n-        return aliases;\n-    }\n-\n-    \/**\n-     * @return the Zone list\n-     *\/\n-    Map<String,Zone> getZones() {\n-        return zones;\n-    }\n-\n-    \/**\n-     * @return a Zone specified by name.\n-     * @param name a zone name\n-     *\/\n-    Zone getZone(String name) {\n-        return zones.get(name);\n-    }\n-\n-    \/**\n-     * @return a Rule specified by name.\n-     * @param name a rule name\n-     *\/\n-    Rule getRule(String name) {\n-        return rules.get(name);\n-    }\n-\n-    private static String line;\n-\n-    private static int lineNum;\n-\n-    \/**\n-     * Parses the specified time zone data file and creates a Zoneinfo\n-     * that has all Rules, Zones and Links (aliases) information.\n-     * @param fname the time zone data file name\n-     * @return a Zoneinfo object\n-     *\/\n-    static Zoneinfo parse(String fname) {\n-        BufferedReader in = null;\n-        try {\n-            FileReader fr = new FileReader(fname);\n-            in = new BufferedReader(fr);\n-        } catch (FileNotFoundException e) {\n-            panic(\"can't open file: \"+fname);\n-        }\n-        Zoneinfo zi = new Zoneinfo();\n-        boolean continued = false;\n-        Zone zone = null;\n-        String l;\n-        lineNum = 0;\n-\n-        try {\n-            while ((line = in.readLine()) != null) {\n-                lineNum++;\n-                \/\/ skip blank and comment lines\n-                if (line.length() == 0 || line.charAt(0) == '#') {\n-                    continue;\n-                }\n-\n-                \/\/ trim trailing comments\n-                int rindex = line.lastIndexOf('#');\n-                if (rindex != -1) {\n-                    \/\/ take the data part of the line\n-                    l = line.substring(0, rindex);\n-                } else {\n-                    l = line;\n-                }\n-\n-                StringTokenizer tokens = new StringTokenizer(l);\n-                if (!tokens.hasMoreTokens()) {\n-                    continue;\n-                }\n-                String token = tokens.nextToken();\n-                int len = token.length();\n-\n-                if (continued || token.regionMatches(true, 0, \"Zone\", 0, len)){\n-                    if (zone == null) {\n-                        if (!tokens.hasMoreTokens()) {\n-                            panic(\"syntax error: zone no more token\");\n-                        }\n-                        token = tokens.nextToken();\n-                        \/\/ if the zone name is in \"GMT+hh\" or \"GMT-hh\"\n-                        \/\/ format, ignore it due to spec conflict.\n-                        if (token.startsWith(\"GMT+\") || token.startsWith(\"GMT-\")) {\n-                            continue;\n-                        }\n-                        zone = new Zone(token);\n-                    } else {\n-                        \/\/ no way to push the current token back...\n-                        tokens = new StringTokenizer(l);\n-                    }\n-\n-                    ZoneRec zrec = ZoneRec.parse(tokens);\n-                    zrec.setLine(line);\n-                    zone.add(zrec);\n-                    if ((continued = zrec.hasUntil()) == false) {\n-                        if (Zone.isTargetZone(zone.getName())) {\n-                            \/\/ zone.resolve(zi);\n-                            zi.add(zone);\n-                        }\n-                        zone = null;\n-                    }\n-                } else if (token.regionMatches(true, 0, \"Rule\", 0, len)) {\n-                    if (!tokens.hasMoreTokens()) {\n-                        panic(\"syntax error: rule no more token\");\n-                    }\n-                    token = tokens.nextToken();\n-                    Rule rule = zi.getRule(token);\n-                    if (rule == null) {\n-                        rule = new Rule(token);\n-                        zi.add(rule);\n-                    }\n-                    RuleRec rrec = RuleRec.parse(tokens);\n-                    rrec.setLine(line);\n-                    rule.add(rrec);\n-                } else if (token.regionMatches(true, 0, \"Link\", 0, len)) {\n-                    \/\/ Link <newname> <oldname>\n-                    try {\n-                        String name1 = tokens.nextToken();\n-                        String name2 = tokens.nextToken();\n-\n-                        \/\/ if the zone name is in \"GMT+hh\" or \"GMT-hh\"\n-                        \/\/ format, ignore it due to spec conflict with\n-                        \/\/ custom time zones. Also, ignore \"ROC\" for\n-                        \/\/ PC-ness.\n-                        if (name2.startsWith(\"GMT+\") || name2.startsWith(\"GMT-\")\n-                            || \"ROC\".equals(name2)) {\n-                            continue;\n-                        }\n-                        zi.putAlias(name2, name1);\n-                    } catch (Exception e) {\n-                        panic(\"syntax error: no more token for Link\");\n-                    }\n-                }\n-            }\n-            in.close();\n-        } catch (IOException ex) {\n-            panic(\"IO error: \" + ex.getMessage());\n-        }\n-\n-        return zi;\n-    }\n-\n-    \/**\n-     * Interprets a zone and constructs a Timezone object that\n-     * contains enough information on GMT offsets and DST schedules to\n-     * generate a zone info database.\n-     *\n-     * @param zoneName the zone name for which a Timezone object is\n-     * constructed.\n-     *\n-     * @return a Timezone object that contains all GMT offsets and DST\n-     * rules information.\n-     *\/\n-    Timezone phase2(String zoneName) {\n-        Timezone tz = new Timezone(zoneName);\n-        Zone zone = getZone(zoneName);\n-        zone.resolve(this);\n-\n-        \/\/ TODO: merge phase2's for the regular and SimpleTimeZone ones.\n-        if (isYearForTimeZoneDataSpecified) {\n-            ZoneRec zrec = zone.get(zone.size()-1);\n-            tz.setLastZoneRec(zrec);\n-            tz.setRawOffset(zrec.getGmtOffset());\n-            if (zrec.hasRuleReference()) {\n-                \/*\n-                 * This part assumes that the specified year is covered by\n-                 * the rules referred to by the last zone record.\n-                 *\/\n-                List<RuleRec> rrecs = zrec.getRuleRef().getRules(startYear);\n-\n-                if (rrecs.size() == 2) {\n-                    \/\/ make sure that one is a start rule and the other is\n-                    \/\/ an end rule.\n-                    RuleRec r0 = rrecs.get(0);\n-                    RuleRec r1 = rrecs.get(1);\n-                    if (r0.getSave() == 0 && r1.getSave() > 0) {\n-                        rrecs.set(0, r1);\n-                        rrecs.set(1, r0);\n-                    } else if (!(r0.getSave() > 0 && r1.getSave() == 0)) {\n-                        rrecs = null;\n-                        Main.error(zoneName + \": rules for \" +  startYear + \" not found.\");\n-                    }\n-                } else {\n-                    rrecs = null;\n-                }\n-                if (rrecs != null) {\n-                    tz.setLastRules(rrecs);\n-                }\n-            }\n-            return tz;\n-        }\n-\n-        int gmtOffset;\n-        int year = minYear;\n-        int fromYear = year;\n-        long fromTime = Time.getLocalTime(startYear,\n-                                          Month.JANUARY,\n-                                          1, 0);\n-\n-        \/\/ take the index 0 for the GMT offset of the last zone record\n-        ZoneRec zrec = zone.get(zone.size()-1);\n-        tz.getOffsetIndex(zrec.getGmtOffset());\n-\n-        int lastGmtOffsetValue = -1;\n-        ZoneRec prevzrec = null;\n-        int currentSave = 0;\n-        boolean usedZone;\n-        for (int zindex = 0; zindex < zone.size(); zindex++) {\n-            zrec = zone.get(zindex);\n-            usedZone = false;\n-            gmtOffset = zrec.getGmtOffset();\n-            int stdOffset = zrec.getDirectSave();\n-\n-            if (gmtOffset != lastGmtOffsetValue) {\n-                tz.setRawOffset(gmtOffset, fromTime);\n-                lastGmtOffsetValue = gmtOffset;\n-            }\n-            \/\/ If this is the last zone record, take the last rule info.\n-            if (!zrec.hasUntil()) {\n-                if (zrec.hasRuleReference()) {\n-                    tz.setLastRules(zrec.getRuleRef().getLastRules());\n-                } else if (stdOffset != 0) {\n-                    \/\/ in case the last rule is all year round DST-only\n-                    \/\/ (Asia\/Amman once announced this rule.)\n-                    tz.setLastDSTSaving(stdOffset);\n-                }\n-            }\n-            if (!zrec.hasRuleReference()) {\n-                if (!zrec.hasUntil() || zrec.getUntilTime(stdOffset) >= fromTime) {\n-                    tz.addTransition(fromTime,\n-                                     tz.getOffsetIndex(gmtOffset+stdOffset),\n-                                     tz.getDstOffsetIndex(stdOffset));\n-                    usedZone = true;\n-                }\n-                currentSave = stdOffset;\n-                \/\/ optimization in case the last rule is fixed.\n-                if (!zrec.hasUntil()) {\n-                    if (tz.getNTransitions() > 0) {\n-                        if (stdOffset == 0) {\n-                            tz.setDSTType(Timezone.X_DST);\n-                        } else {\n-                            tz.setDSTType(Timezone.LAST_DST);\n-                        }\n-                        long time = Time.getLocalTime(maxYear,\n-                                                      Month.JANUARY, 1, 0);\n-                        time -= zrec.getGmtOffset();\n-                        tz.addTransition(time,\n-                                         tz.getOffsetIndex(gmtOffset+stdOffset),\n-                                         tz.getDstOffsetIndex(stdOffset));\n-                        tz.addUsedRec(zrec);\n-                    } else {\n-                        tz.setDSTType(Timezone.NO_DST);\n-                    }\n-                    break;\n-                }\n-            } else {\n-                Rule rule = zrec.getRuleRef();\n-                boolean fromTimeUsed = false;\n-                currentSave = 0;\n-            year_loop:\n-                for (year = getMinYear(); year <= endYear; year++) {\n-                    if (zrec.hasUntil() && year > zrec.getUntilYear()) {\n-                        break;\n-                    }\n-                    List<RuleRec> rules = rule.getRules(year);\n-                    if (rules.size() > 0) {\n-                        for (int i = 0; i < rules.size(); i++) {\n-                            RuleRec rrec = rules.get(i);\n-                            long transition = rrec.getTransitionTime(year,\n-                                                                     gmtOffset,\n-                                                                     currentSave);\n-                            if (zrec.hasUntil()) {\n-                                if (transition >= zrec.getUntilTime(currentSave)) {\n-                                    \/\/ If the GMT offset changed from the previous one,\n-                                    \/\/ record fromTime as a transition.\n-                                    if (!fromTimeUsed && prevzrec != null\n-                                        && gmtOffset != prevzrec.getGmtOffset()) {\n-                                        tz.addTransition(fromTime,\n-                                                         tz.getOffsetIndex(gmtOffset+currentSave),\n-                                                         tz.getDstOffsetIndex(currentSave));\n-                                        fromTimeUsed = true; \/\/ for consistency\n-                                    }\n-                                    break year_loop;\n-                                }\n-                            }\n-\n-                            if (fromTimeUsed == false) {\n-                                if (fromTime <= transition) {\n-                                    fromTimeUsed = true;\n-\n-                                    if (fromTime != minTime) {\n-                                        int prevsave;\n-\n-                                        \/\/ See if until time in the previous\n-                                        \/\/ ZoneRec is the same thing as the\n-                                        \/\/ local time in the next rule.\n-                                        \/\/ (examples are Asia\/Ashkhabad in 1991,\n-                                        \/\/ Europe\/Riga in 1989)\n-\n-                                        if (i > 0) {\n-                                            prevsave = rules.get(i-1).getSave();\n-                                        } else {\n-                                            List<RuleRec> prevrules = rule.getRules(year-1);\n-\n-                                            if (prevrules.size() > 0) {\n-                                                prevsave = prevrules.get(prevrules.size()-1).getSave();\n-                                            } else {\n-                                                prevsave = 0;\n-                                            }\n-                                        }\n-\n-                                        if (rrec.isSameTransition(prevzrec, prevsave, gmtOffset)) {\n-                                            currentSave = rrec.getSave();\n-                                            tz.addTransition(fromTime,\n-                                                         tz.getOffsetIndex(gmtOffset+currentSave),\n-                                                         tz.getDstOffsetIndex(currentSave));\n-                                            tz.addUsedRec(rrec);\n-                                            usedZone = true;\n-                                            continue;\n-                                        }\n-                                        if (!prevzrec.hasRuleReference()\n-                                            || rule != prevzrec.getRuleRef()\n-                                            || (rule == prevzrec.getRuleRef()\n-                                                && gmtOffset != prevzrec.getGmtOffset())) {\n-                                            int save = (fromTime == transition) ? rrec.getSave() : currentSave;\n-                                            tz.addTransition(fromTime,\n-                                                         tz.getOffsetIndex(gmtOffset+save),\n-                                                         tz.getDstOffsetIndex(save));\n-                                            tz.addUsedRec(rrec);\n-                                            usedZone = true;\n-                                        }\n-                                    } else {  \/\/ fromTime == minTime\n-                                        int save = rrec.getSave();\n-                                        tz.addTransition(minTime,\n-                                                         tz.getOffsetIndex(gmtOffset),\n-                                                         tz.getDstOffsetIndex(0));\n-\n-                                        tz.addTransition(transition,\n-                                                         tz.getOffsetIndex(gmtOffset+save),\n-                                                         tz.getDstOffsetIndex(save));\n-\n-                                        tz.addUsedRec(rrec);\n-                                        usedZone = true;\n-                                    }\n-                                } else if (year == fromYear && i == rules.size()-1) {\n-                                    int save = rrec.getSave();\n-                                    tz.addTransition(fromTime,\n-                                                     tz.getOffsetIndex(gmtOffset+save),\n-                                                     tz.getDstOffsetIndex(save));\n-                                }\n-                            }\n-\n-                            currentSave = rrec.getSave();\n-                            if (fromTime < transition) {\n-                                tz.addTransition(transition,\n-                                                 tz.getOffsetIndex(gmtOffset+currentSave),\n-                                                 tz.getDstOffsetIndex(currentSave));\n-                                tz.addUsedRec(rrec);\n-                                usedZone = true;\n-                            }\n-                        }\n-                    } else {\n-                        if (year == fromYear) {\n-                            tz.addTransition(fromTime,\n-                                             tz.getOffsetIndex(gmtOffset+currentSave),\n-                                             tz.getDstOffsetIndex(currentSave));\n-                            fromTimeUsed = true;\n-                        }\n-                        if (year == endYear && !zrec.hasUntil()) {\n-                            if (tz.getNTransitions() > 0) {\n-                                \/\/ Assume that this Zone stopped DST\n-                                tz.setDSTType(Timezone.X_DST);\n-                                long time = Time.getLocalTime(maxYear, Month.JANUARY,\n-                                                              1, 0);\n-                                time -= zrec.getGmtOffset();\n-                                tz.addTransition(time,\n-                                                 tz.getOffsetIndex(gmtOffset),\n-                                                 tz.getDstOffsetIndex(0));\n-                                usedZone = true;\n-                            } else {\n-                                tz.setDSTType(Timezone.NO_DST);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            if (usedZone) {\n-                tz.addUsedRec(zrec);\n-            }\n-            if (zrec.hasUntil() && zrec.getUntilTime(currentSave) > fromTime) {\n-                fromTime = zrec.getUntilTime(currentSave);\n-                fromYear = zrec.getUntilYear();\n-                year = zrec.getUntilYear();\n-            }\n-            prevzrec = zrec;\n-        }\n-\n-        if (tz.getDSTType() == Timezone.UNDEF_DST) {\n-            tz.setDSTType(Timezone.DST);\n-        }\n-        tz.optimize();\n-        tz.checksum();\n-        return tz;\n-    }\n-\n-    private static void panic(String msg) {\n-        Main.panic(msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Zoneinfo.java","additions":0,"deletions":579,"binary":false,"changes":579,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-#\n-# Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# JDK 1.1.x compatible time zone IDs\n-#\n-\n-Link Australia\/Darwin ACT\n-Link Australia\/Sydney AET\n-Link America\/Argentina\/Buenos_Aires AGT\n-Link Africa\/Cairo ART\n-Link America\/Anchorage AST\n-Link America\/Sao_Paulo BET\n-Link Asia\/Dhaka BST\n-Link Africa\/Harare CAT\n-Link America\/St_Johns CNT\n-Link America\/Chicago CST\n-Link Asia\/Shanghai CTT\n-Link Africa\/Addis_Ababa EAT\n-Link Europe\/Paris ECT\n-Link America\/New_York EST\n-Link Pacific\/Honolulu HST\n-Link America\/Indianapolis IET\n-Link Asia\/Calcutta IST\n-Link Asia\/Tokyo JST\n-Link Pacific\/Apia MIT\n-Link America\/Denver MST\n-Link Asia\/Yerevan NET\n-Link Pacific\/Auckland NST\n-Link Asia\/Karachi PLT\n-Link America\/Phoenix PNT\n-Link America\/Puerto_Rico PRT\n-Link America\/Los_Angeles PST\n-Link Pacific\/Guadalcanal SST\n-Link Asia\/Saigon VST\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tSystemV\tmin\t1973\t-\tApr\tlastSun\t2:00\t1:00\tD\n-Rule\tSystemV\tmin\t1973\t-\tOct\tlastSun\t2:00\t0\tS\n-Rule\tSystemV\t1974\tonly\t-\tJan\t6\t2:00\t1:00\tD\n-Rule\tSystemV\t1974\tonly\t-\tNov\tlastSun\t2:00\t0\tS\n-Rule\tSystemV\t1975\tonly\t-\tFeb\t23\t2:00\t1:00\tD\n-Rule\tSystemV\t1975\tonly\t-\tOct\tlastSun\t2:00\t0\tS\n-Rule\tSystemV\t1976\tmax\t-\tApr\tlastSun\t2:00\t1:00\tD\n-Rule\tSystemV\t1976\tmax\t-\tOct\tlastSun\t2:00\t0\tS\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tSystemV\/AST4ADT\t-4:00\tSystemV\t\tA%sT\n-Zone\tSystemV\/EST5EDT\t-5:00\tSystemV\t\tE%sT\n-Zone\tSystemV\/CST6CDT\t-6:00\tSystemV\t\tC%sT\n-Zone\tSystemV\/MST7MDT\t-7:00\tSystemV\t\tM%sT\n-Zone\tSystemV\/PST8PDT\t-8:00\tSystemV\t\tP%sT\n-Zone\tSystemV\/YST9YDT\t-9:00\tSystemV\t\tY%sT\n-Zone\tSystemV\/AST4\t-4:00\t-\t\tAST\n-Zone\tSystemV\/EST5\t-5:00\t-\t\tEST\n-Zone\tSystemV\/CST6\t-6:00\t-\t\tCST\n-Zone\tSystemV\/MST7\t-7:00\t-\t\tMST\n-Zone\tSystemV\/PST8\t-8:00\t-\t\tPST\n-Zone\tSystemV\/YST9\t-9:00\t-\t\tYST\n-Zone\tSystemV\/HST10\t-10:00\t-\t\tHST\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/tzdata_jdk\/jdk11_backward","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"}]}