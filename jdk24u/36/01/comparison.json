{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=jdk-updates\n@@ -4,1 +4,1 @@\n-version=24\n+version=24.0.1\n","filename":".jcheck\/conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=0\n+DEFAULT_VERSION_UPDATE=1\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2025-03-18\n+DEFAULT_VERSION_DATE=2025-04-15\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static bool supports_shared_stubs() { return false; }\n+  static bool supports_shared_stubs() { return true; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-static const char* cg_controller_name[] = { \"cpu\", \"cpuset\", \"cpuacct\", \"memory\", \"pids\" };\n+static const char* cg_controller_name[] = { \"cpuset\", \"cpu\", \"cpuacct\", \"memory\", \"pids\" };\n@@ -229,1 +229,1 @@\n-  \/\/ true iff all required controllers, memory, cpu, cpuset, cpuacct are enabled\n+  \/\/ true iff all required controllers, memory, cpu, cpuacct are enabled\n@@ -232,0 +232,1 @@\n+  \/\/ cpuset might not be enabled on newer Linux distros (Fedora 41)\n@@ -263,0 +264,1 @@\n+      log_debug(os, container)(\"Detected optional cpuset controller entry in %s\", proc_cgroups);\n@@ -286,2 +288,2 @@\n-    \/\/ pids controller is optional. All other controllers are required\n-    if (i != PIDS_IDX) {\n+    \/\/ pids and cpuset controllers are optional. All other controllers are required\n+    if (i != PIDS_IDX && i != CPUSET_IDX) {\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,12 +35,0 @@\n-  \/\/ Warn users that non-resizable heap might be better for some configurations.\n-  \/\/ We are not adjusting the heap size by ourselves, because it affects startup time.\n-  if (InitialHeapSize != MaxHeapSize) {\n-    log_warning(gc, init)(\"Consider setting -Xms equal to -Xmx to avoid resizing hiccups\");\n-  }\n-\n-  \/\/ Warn users that AlwaysPreTouch might be better for some configurations.\n-  \/\/ We are not turning this on by ourselves, because it affects startup time.\n-  if (FLAG_IS_DEFAULT(AlwaysPreTouch) && !AlwaysPreTouch) {\n-    log_warning(gc, init)(\"Consider enabling -XX:+AlwaysPreTouch to avoid memory commit hiccups\");\n-  }\n-\n@@ -60,0 +48,12 @@\n+\n+  \/\/ Suggest that non-resizable heap might be better for some configurations.\n+  \/\/ We are not adjusting the heap size by ourselves, because it affects startup time.\n+  if (InitialHeapSize != MaxHeapSize) {\n+    log_info(gc)(\"Consider setting -Xms equal to -Xmx to avoid resizing hiccups\");\n+  }\n+\n+  \/\/ Suggest that AlwaysPreTouch might be better for some configurations.\n+  \/\/ We are not turning this on by ourselves, because it affects startup time.\n+  if (FLAG_IS_DEFAULT(AlwaysPreTouch) && !AlwaysPreTouch) {\n+    log_info(gc)(\"Consider enabling -XX:+AlwaysPreTouch to avoid memory commit hiccups\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonInitLogger.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -207,15 +207,18 @@\n-  size_t v_used = used();\n-  size_t v_used_regions = used_regions_size();\n-  size_t v_soft_max_capacity = soft_max_capacity();\n-  size_t v_max_capacity = max_capacity();\n-  size_t v_available = available();\n-  size_t v_humongous_waste = get_humongous_waste();\n-  LogGcInfo::print(\"%s: %s generation used: \" SIZE_FORMAT \"%s, used regions: \" SIZE_FORMAT \"%s, \"\n-                   \"humongous waste: \" SIZE_FORMAT \"%s, soft capacity: \" SIZE_FORMAT \"%s, max capacity: \" SIZE_FORMAT \"%s, \"\n-                   \"available: \" SIZE_FORMAT \"%s\", msg, name(),\n-                   byte_size_in_proper_unit(v_used),              proper_unit_for_byte_size(v_used),\n-                   byte_size_in_proper_unit(v_used_regions),      proper_unit_for_byte_size(v_used_regions),\n-                   byte_size_in_proper_unit(v_humongous_waste),   proper_unit_for_byte_size(v_humongous_waste),\n-                   byte_size_in_proper_unit(v_soft_max_capacity), proper_unit_for_byte_size(v_soft_max_capacity),\n-                   byte_size_in_proper_unit(v_max_capacity),      proper_unit_for_byte_size(v_max_capacity),\n-                   byte_size_in_proper_unit(v_available),         proper_unit_for_byte_size(v_available));\n+  const size_t v_used = used();\n+  const size_t v_used_regions = used_regions_size();\n+  const size_t v_soft_max_capacity = soft_max_capacity();\n+  const size_t v_max_capacity = max_capacity();\n+  const size_t v_available = available();\n+  const size_t v_humongous_waste = get_humongous_waste();\n+\n+  const LogGcInfo target;\n+  LogStream ls(target);\n+  ls.print(\"%s: \", msg);\n+  if (_type != NON_GEN) {\n+    ls.print(\"%s generation \", name());\n+  }\n+\n+  ls.print_cr(\"used: \" PROPERFMT \", used regions: \" PROPERFMT \", humongous waste: \" PROPERFMT\n+              \", soft capacity: \" PROPERFMT \", max capacity: \" PROPERFMT \", available: \" PROPERFMT,\n+              PROPERFMTARGS(v_used), PROPERFMTARGS(v_used_regions), PROPERFMTARGS(v_humongous_waste),\n+              PROPERFMTARGS(v_soft_max_capacity), PROPERFMTARGS(v_max_capacity), PROPERFMTARGS(v_available));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -67,1 +67,2 @@\n-          log_debug(gc)(\"Heuristics request for global (unload classes) accepted.\");\n+          \/\/ Some of vmTestbase\/metaspace tests depend on following line to count GC cycles\n+          _global_heuristics->log_trigger(\"%s\", GCCause::to_string(GCCause::_metadata_GC_threshold));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3798,0 +3798,1 @@\n+    thread->unregister_thread_stack_with_NMT();\n@@ -3842,0 +3843,2 @@\n+    thread->unregister_thread_stack_with_NMT();\n+    thread->smr_delete();\n@@ -3938,0 +3941,1 @@\n+  thread->unregister_thread_stack_with_NMT();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  static Iterator all();\n@@ -85,0 +84,1 @@\n+  static Iterator all();\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1053,1 +1053,0 @@\n-  this->smr_delete();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -1124,0 +1125,25 @@\n+void os::print_jvmti_agent_info(outputStream* st) {\n+#if INCLUDE_JVMTI\n+  const JvmtiAgentList::Iterator it = JvmtiAgentList::all();\n+  if (it.has_next()) {\n+    st->print_cr(\"JVMTI agents:\");\n+  } else {\n+    st->print_cr(\"JVMTI agents: none\");\n+  }\n+  while (it.has_next()) {\n+    const JvmtiAgent* agent = it.next();\n+    if (agent != nullptr) {\n+      const char* dyninfo = agent->is_dynamic() ? \"dynamic \" : \"\";\n+      const char* instrumentinfo = agent->is_instrument_lib() ? \"instrumentlib \" : \"\";\n+      const char* loadinfo = agent->is_loaded() ? \"loaded\" : \"not loaded\";\n+      const char* initinfo = agent->is_initialized() ? \"initialized\" : \"not initialized\";\n+      const char* optionsinfo = agent->options();\n+      const char* pathinfo = agent->os_lib_path();\n+      if (optionsinfo == nullptr) optionsinfo = \"none\";\n+      if (pathinfo == nullptr) pathinfo = \"none\";\n+      st->print_cr(\"%s path:%s, %s, %s, %s%soptions:%s\", agent->name(), pathinfo, loadinfo, initinfo, dyninfo, instrumentinfo, optionsinfo);\n+    }\n+  }\n+#endif\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -809,0 +809,1 @@\n+  static void print_jvmti_agent_info(outputStream* st);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -250,0 +250,3 @@\n+  \/\/ Logically we should do this->unregister_thread_stack_with_NMT() here, but we\n+  \/\/ had to move that into post_run() because of the `this` deletion issue.\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1278,0 +1278,6 @@\n+#if INCLUDE_JVMTI\n+  STEP_IF(\"printing jvmti agent info\", _verbose)\n+    os::print_jvmti_agent_info(st);\n+    st->cr();\n+#endif\n+\n@@ -1456,0 +1462,5 @@\n+#if INCLUDE_JVMTI\n+  os::print_jvmti_agent_info(st);\n+  st->cr();\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012 SAP SE. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -29,2 +29,1 @@\n-import java.nio.channels.spi.AsynchronousChannelProvider;\n-import sun.nio.ch.Pollset;\n+import java.io.FileDescriptor;\n@@ -32,2 +31,1 @@\n-import java.util.HashSet;\n-import java.util.Iterator;\n+import java.nio.channels.spi.AsynchronousChannelProvider;\n@@ -35,1 +33,0 @@\n-import java.util.concurrent.RejectedExecutionException;\n@@ -38,0 +35,5 @@\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import sun.nio.ch.IOUtil;\n+import sun.nio.ch.Pollset;\n@@ -144,0 +146,2 @@\n+            \/\/ make the reading part of the socket nonblocking, so the drain (drain_all) method works\n+            IOUtil.configureBlocking(IOUtil.newFD(sv[0]), false);\n@@ -274,14 +278,11 @@\n-        synchronized (controlQueue) {\n-            \/\/ On Aix it is only possible to set the event\n-            \/\/ bits on the first call of pollsetCtl. Later\n-            \/\/ calls only add bits, but cannot remove them.\n-            \/\/ Therefore, we always remove the file\n-            \/\/ descriptor ignoring the error and then add it.\n-            Iterator<ControlEvent> iter = controlQueue.iterator();\n-            while (iter.hasNext()) {\n-                ControlEvent ev = iter.next();\n-                Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, ev.fd(), 0);\n-                if (!ev.removeOnly()) {\n-                    ev.setError(Pollset.pollsetCtl(pollset, Pollset.PS_MOD, ev.fd(), ev.events()));\n-                }\n-                iter.remove();\n+        \/\/ On Aix it is only possible to set the event\n+        \/\/ bits on the first call of pollsetCtl. Later\n+        \/\/ calls only add bits, but cannot remove them.\n+        \/\/ Therefore, we always remove the file\n+        \/\/ descriptor ignoring the error and then add it.\n+        Iterator<ControlEvent> iter = controlQueue.iterator();\n+        while (iter.hasNext()) {\n+            ControlEvent ev = iter.next();\n+            Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, ev.fd(), 0);\n+            if (!ev.removeOnly()) {\n+                ev.setError(Pollset.pollsetCtl(pollset, Pollset.PS_MOD, ev.fd(), ev.events()));\n@@ -289,1 +290,1 @@\n-            controlQueue.notifyAll();\n+            iter.remove();\n@@ -291,0 +292,1 @@\n+        controlQueue.notifyAll();\n@@ -309,1 +311,2 @@\n-                        n = Pollset.pollsetPoll(pollset, address,\n+                        int m;\n+                        m = n = Pollset.pollsetPoll(pollset, address,\n@@ -311,0 +314,12 @@\n+                        while (m-- > 0) {\n+                            long eventAddress = Pollset.getEvent(address, m);\n+                            int fd = Pollset.getDescriptor(eventAddress);\n+\n+                            \/\/ To emulate one shot semantic we need to remove\n+                            \/\/ the file descriptor here.\n+                            if (fd != sp[0] && fd != ctlSp[0]) {\n+                                synchronized (controlQueue) {\n+                                    Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, fd, 0);\n+                                }\n+                            }\n+                        }\n@@ -326,8 +341,0 @@\n-                            \/\/ To emulate one shot semantic we need to remove\n-                            \/\/ the file descriptor here.\n-                            if (fd != sp[0] && fd != ctlSp[0]) {\n-                                synchronized (controlQueue) {\n-                                    Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, fd, 0);\n-                                }\n-                            }\n-\n@@ -353,1 +360,1 @@\n-                                    Pollset.drain1(ctlSp[0]);\n+                                    IOUtil.drain(ctlSp[0]);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/AixPollPort.java","additions":39,"deletions":32,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-                            \"Duplicate annotation for class: \"+klass+\": \" + a);\n+                            \"Duplicate annotation \" + klass + \" in \" + container);\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,1 +245,1 @@\n-        if(::DrawFocusRect(hDC, &focusRect) == 0)\n+        if (!::IsRectEmpty(&focusRect) && (::DrawFocusRect(hDC, &focusRect) == 0))\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Button.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -293,1 +293,1 @@\n-        if(::DrawFocusRect(hDC, &focusRect) == 0)\n+        if (!::IsRectEmpty(&focusRect) && (::DrawFocusRect(hDC, &focusRect) == 0))\n@@ -299,1 +299,1 @@\n-        if(::DrawFocusRect(hDC, &focusRect) == 0)\n+        if (!::IsRectEmpty(&focusRect) && (::DrawFocusRect(hDC, &focusRect) == 0))\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Checkbox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -4468,1 +4468,1 @@\n-          if(::DrawFocusRect(hDC, &rect) == 0)\n+          if (!::IsRectEmpty(&rect) && (::DrawFocusRect(hDC, &rect) == 0))\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Red Hat, Inc.\n+ * Copyright (c) 2024, 2025, Red Hat, Inc.\n@@ -27,0 +27,3 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n@@ -52,0 +55,1 @@\n+        public InputStream getResource(String name);\n@@ -74,1 +78,0 @@\n-                byte[] baseBytes = base.getResourceBytes(item);\n@@ -85,1 +88,1 @@\n-                           .setResourceBytes(baseBytes)\n+                           .setResourceBytes(base.getResourceBytes(item))\n@@ -91,2 +94,1 @@\n-                boolean contentEquals = Arrays.equals(baseBytes, image.getResourceBytes(item));\n-                if (!contentEquals) {\n+                if (!compareStreams(base.getResource(item), image.getResource(item))) {\n@@ -97,1 +99,1 @@\n-                        .setResourceBytes(baseBytes)\n+                        .setResourceBytes(base.getResourceBytes(item))\n@@ -115,0 +117,33 @@\n+    \/**\n+     * Compare the contents of the two input streams (byte-by-byte).\n+     *\n+     * @param is1 The first input stream\n+     * @param is2 The second input stream\n+     * @return {@code true} iff the two streams contain the same number of\n+     *         bytes and each byte of the streams are equal. {@code false}\n+     *         otherwise.\n+     *\/\n+    private boolean compareStreams(InputStream is1, InputStream is2) {\n+        byte[] buf1 = new byte[1024];\n+        byte[] buf2 = new byte[1024];\n+        int bytesRead1, bytesRead2;\n+        try (is1; is2) {\n+            while (true) {\n+                bytesRead1 = is1.readNBytes(buf1, 0, buf1.length);\n+                bytesRead2 = is2.readNBytes(buf2, 0, buf2.length);\n+                if (!Arrays.equals(buf1, 0, bytesRead1,\n+                                   buf2, 0, bytesRead2)) {\n+                    return false;\n+                }\n+                if (bytesRead1 == 0) {\n+                    \/\/ If we reach here, bytesRead2 must be 0 as well, otherwise\n+                    \/\/ we return false on the !Arrays.equals() check above.\n+                    assert bytesRead2 == 0 : \"Arrays must have been read to the end\";\n+                    return true;\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"IO exception when comparing bytes\", e);\n+        }\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/JimageDiffGenerator.java","additions":41,"deletions":6,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.InputStream;\n@@ -59,0 +60,5 @@\n+    @Override\n+    public InputStream getResource(String name) {\n+        return pool.findEntry(name).orElseThrow().content();\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourcePoolReader.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -277,2 +277,7 @@\n-        if (containerMetrics != null && containerMetrics.getCpuSetCpus() != null) {\n-            return containerMetrics.getCpuSetCpus().length == getHostOnlineCpuCount0();\n+        if (containerMetrics != null) {\n+            \/\/ The return value may change (including from non-null to null) and\n+            \/\/ the call may involve I\/O, so keep the result in a local variable.\n+            int[] cpuSetCpus = containerMetrics.getCpuSetCpus();\n+            if (cpuSetCpus != null) {\n+                return cpuSetCpus.length == getHostOnlineCpuCount0();\n+            }\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,2 +151,0 @@\n-serviceability\/attach\/ConcAttachTest.java 8290043 linux-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @requires os.arch==\"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/sharedstubs\/SharedTrampolineTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @test TestPLABAdaptToMinTLABSize\n+ * @test TestPLABAdaptToMinTLABSizeG1\n@@ -30,1 +30,1 @@\n- * @requires vm.gc.Parallel | vm.gc.G1\n+ * @requires vm.gc.G1\n@@ -34,1 +34,12 @@\n- * @run driver gc.TestPLABAdaptToMinTLABSize\n+ * @run driver gc.TestPLABAdaptToMinTLABSize -XX:+UseG1GC\n+ *\/\n+\n+\/*\n+ * @test TestPLABAdaptToMinTLABSizeParallel\n+ * @bug 8289137\n+ * @summary Make sure that Young\/OldPLABSize adapt to MinTLABSize setting.\n+ * @requires vm.gc.Parallel\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver gc.TestPLABAdaptToMinTLABSize -XX:+UseParallelGC\n@@ -38,0 +49,1 @@\n+import java.util.Arrays;\n@@ -71,1 +83,2 @@\n-        runTest(true, \"-XX:MinTLABSize=100k\");\n+        String gc = args[0];\n+        runTest(true, gc, \"-XX:MinTLABSize=100k\");\n@@ -73,2 +86,2 @@\n-        runTest(false, \"-XX:MinTLABSize=100k\", \"-XX:OldPLABSize=5k\");\n-        runTest(false, \"-XX:MinTLABSize=100k\", \"-XX:YoungPLABSize=5k\");\n+        runTest(false, gc, \"-XX:MinTLABSize=100k\", \"-XX:OldPLABSize=5k\");\n+        runTest(false, gc, \"-XX:MinTLABSize=100k\", \"-XX:YoungPLABSize=5k\");\n","filename":"test\/hotspot\/jtreg\/gc\/TestPLABAdaptToMinTLABSize.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- *      -XX:VerifyGCType=full -XX:+VerifyDuringGC -XX:+VerifyAfterGC -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:VerifyGCType=full -XX:+VerifyDuringGC -XX:+VerifyAfterGC -XX:+WhiteBoxAPI -XX:+UseG1GC -Xbootclasspath\/a:.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedHumongousFragmentation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -XX:+ZapUnusedHeapArea -Xlog:gc,gc+ergo+cset=trace gc.g1.pinnedobjs.TestPinnedObjectContents\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC\n+ *      -Xbootclasspath\/a:. -XX:+ZapUnusedHeapArea -Xlog:gc,gc+ergo+cset=trace gc.g1.pinnedobjs.TestPinnedObjectContents\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedObjectContents.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,4 @@\n- * @comment The native code only supports POSIX so no windows testing\n- * @run main\/othervm\/native TestTerminatedThread\n+ * @comment The native code only supports POSIX so no windows testing.\n+ * @comment Disable -Xcheck:jni else NMT can report a fatal error because\n+ *          we did not detach before exiting.\n+ * @run main\/othervm\/native -XX:-CheckJNICalls TestTerminatedThread\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/terminatedThread\/TestTerminatedThread.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -588,2 +588,0 @@\n-java\/nio\/channels\/AsynchronousSocketChannel\/StressLoopback.java 8211851 aix-ppc64\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 6968351\n- * @summary  tcp no delay not required for small payloads\n- * @requires vm.compMode != \"Xcomp\"\n- * @library \/test\/lib\n- * @run main\/othervm\/timeout=5 -Dsun.net.httpserver.nodelay=false  TcpNoDelayNotRequired\n- *\/\n-\n-import com.sun.net.httpserver.Headers;\n-import com.sun.net.httpserver.HttpContext;\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import com.sun.net.httpserver.HttpsConfigurator;\n-import com.sun.net.httpserver.HttpsServer;\n-import jdk.test.lib.net.SimpleSSLContext;\n-import jdk.test.lib.net.URIBuilder;\n-\n-import javax.net.ssl.SSLContext;\n-import java.io.IOException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.nio.charset.StandardCharsets;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import java.util.logging.SimpleFormatter;\n-import java.util.logging.StreamHandler;\n-\n-public class TcpNoDelayNotRequired {\n-\n-    public static final Logger LOGGER = Logger.getLogger(\"sun.net.www.protocol.http\");\n-\n-    public static void main (String[] args) throws Exception {\n-\n-        java.util.logging.Handler outHandler = new StreamHandler(System.out,\n-                new SimpleFormatter());\n-        outHandler.setLevel(Level.FINEST);\n-        LOGGER.setLevel(Level.FINEST);\n-        LOGGER.addHandler(outHandler);\n-\n-        InetAddress loopback = InetAddress.getLoopbackAddress();\n-        InetSocketAddress addr = new InetSocketAddress (loopback, 0);\n-\n-        SSLContext sslContext = new SimpleSSLContext().get();\n-\n-        HttpServer httpServer = HttpServer.create (addr, 0);\n-        testHttpServer(\"http\",httpServer,sslContext);\n-\n-        HttpsServer httpsServer = HttpsServer.create (addr, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-\n-        testHttpServer(\"https\",httpsServer,sslContext);\n-    }\n-\n-    private static void testHttpServer(String scheme,HttpServer server,SSLContext sslContext) throws Exception {\n-        HttpContext ctx = server.createContext (\"\/test\", new Handler());\n-        HttpContext ctx2 = server.createContext (\"\/chunked\", new ChunkedHandler());\n-        ExecutorService executor = Executors.newCachedThreadPool();\n-        server.setExecutor (executor);\n-        server.start ();\n-        try {\n-            try (HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build()) {\n-                long start = System.currentTimeMillis();\n-                for (int i = 0; i < 1000; i++) {\n-                    var uri = URIBuilder.newBuilder().scheme(scheme).loopback().port(server.getAddress().getPort()).path(\"\/test\").build();\n-                    var response = client.send(HttpRequest.newBuilder(uri).build(), HttpResponse.BodyHandlers.ofString());\n-                    if (!response.body().equals(\"hello\"))\n-                        throw new IllegalStateException(\"incorrect body \" + response.body());\n-                }\n-                for (int i = 0; i < 1000; i++) {\n-                    var uri = URIBuilder.newBuilder().scheme(scheme).loopback().port(server.getAddress().getPort()).path(\"\/chunked\").build();\n-                    var response = client.send(HttpRequest.newBuilder(uri).build(), HttpResponse.BodyHandlers.ofString());\n-                    if (!response.body().equals(\"hello\"))\n-                        throw new IllegalStateException(\"incorrect body \" + response.body());\n-                }\n-                long time = System.currentTimeMillis() - start;\n-                System.out.println(\"time \" + time);\n-            }\n-        } finally {\n-            server.stop(0);\n-        }\n-        executor.shutdown();\n-    }\n-\n-    static class Handler implements HttpHandler {\n-        public void handle (HttpExchange t)\n-                throws IOException\n-        {\n-            Headers rmap = t.getResponseHeaders();\n-            try (var is = t.getRequestBody()) {\n-                is.readAllBytes();\n-            }\n-            rmap.add(\"content-type\",\"text\/plain\");\n-            t.sendResponseHeaders(200,5);\n-            try (var os = t.getResponseBody()) {\n-                os.write(\"hello\".getBytes(StandardCharsets.ISO_8859_1));\n-            }\n-        }\n-    }\n-    static class ChunkedHandler implements HttpHandler {\n-        public void handle (HttpExchange t)\n-                throws IOException\n-        {\n-            Headers rmap = t.getResponseHeaders();\n-            try (var is = t.getRequestBody()) {\n-                is.readAllBytes();\n-            }\n-            rmap.add(\"content-type\",\"text\/plain\");\n-            t.sendResponseHeaders(200,0);\n-            try (var os = t.getResponseBody()) {\n-                os.write(\"hello\".getBytes(StandardCharsets.ISO_8859_1));\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/TcpNoDelayNotRequired.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,7 @@\n- * @run driver jdk.jfr.jvm.TestModularImage\n+ * @modules jdk.compiler jdk.jlink\n+ * @comment Test is being run in othervm to support JEP 493 enabled\n+ *          JDKs which don't allow patched modules. Note that jtreg patches\n+ *          module java.base to add java.lang.JTRegModuleHelper. If then a\n+ *          jlink run is attempted in-process - using the ToolProvider API -\n+ *          on a JEP 493 enabled JDK, the test fails.\n+ * @run main\/othervm jdk.jfr.jvm.TestModularImage\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestModularImage.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.x509\n+ * @run main LeadingPeriod\n@@ -41,16 +40,4 @@\n-    private static CertPath makeCertPath(String targetCertStr,\n-        PKIXParameters params) throws CertificateException {\n-        \/\/ generate certificate from cert strings\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is;\n-\n-        is = new ByteArrayInputStream(targetCertStr.getBytes());\n-        Certificate targetCert = cf.generateCertificate(is);\n-        \/\/ set validity date so that validation won't fail when cert expires\n-        params.setDate(((X509Certificate)targetCert).getNotBefore());\n-\n-        \/\/ generate certification path\n-        List<Certificate> list = List.of(targetCert);\n-\n-        return cf.generateCertPath(list);\n+    public static void main(String[] args) throws Exception {\n+        String certs = System.getProperty(\"test.src\", \".\/\") + \"\/certs\/\";\n+        validate(certs + \"withoutLeadingPeriod\");\n+        validate(certs + \"withLeadingPeriod\");\n@@ -59,6 +46,3 @@\n-    private static PKIXParameters genParams(String caStr) throws Exception {\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is = new ByteArrayInputStream(caStr.getBytes());\n-        Certificate selfSignedCert = cf.generateCertificate(is);\n+    public static void validate(String certPath) throws Exception {\n+        byte[] targetCertBytes = Files.readAllBytes(Paths.get(certPath + \"\/leaf.pem\"));\n+        byte[] caCertBytes = Files.readAllBytes(Paths.get(certPath + \"\/ca.pem\"));\n@@ -66,2 +50,3 @@\n-        \/\/ generate a trust anchor\n-        TrustAnchor anchor = new TrustAnchor((X509Certificate) selfSignedCert, null);\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        Certificate caCert = cf.generateCertificate(new ByteArrayInputStream(caCertBytes));\n+        Certificate targetCert = cf.generateCertificate(new ByteArrayInputStream(targetCertBytes));\n@@ -69,1 +54,1 @@\n-        Set<TrustAnchor> anchors = Collections.singleton(anchor);\n+        TrustAnchor anchor = new TrustAnchor((X509Certificate) caCert, null);\n@@ -71,1 +56,1 @@\n-        PKIXParameters params = new PKIXParameters(anchors);\n+        PKIXParameters params = new PKIXParameters(Collections.singleton(anchor));\n@@ -73,1 +58,1 @@\n-        \/\/ disable certificate revocation checking\n+        \/\/ Disable certificate revocation checking\n@@ -76,2 +61,2 @@\n-        return params;\n-    }\n+        \/\/ Set validity date, so that validation won't fail when cert expires\n+        params.setDate(((X509Certificate)targetCert).getNotBefore());\n@@ -79,1 +64,1 @@\n-    public static void main(String[] args) throws Exception {\n+        CertPath path = cf.generateCertPath(List.of(targetCert, caCert));\n@@ -82,29 +67,1 @@\n-\n-        \/\/ Load certs with a NameConstraint where DNS value does not begin with a period\n-        Path targetFromCAWithoutPeriodPath = Paths.get(System.getProperty(\n-            \"test.src\", \".\/\") + \"\/certs\/withoutLeadingPeriod\/leaf.pem\");\n-        String targetFromCAWithoutPeriod = Files.readString(targetFromCAWithoutPeriodPath);\n-\n-        Path caWithoutLeadingPeriodPath = Paths.get(System.getProperty(\n-            \"test.src\", \".\/\") + \"\/certs\/withoutLeadingPeriod\/ca.pem\");\n-        String caWithoutLeadingPeriod = Files.readString(caWithoutLeadingPeriodPath);\n-\n-        PKIXParameters paramsForCAWithoutLeadingPeriod = genParams(caWithoutLeadingPeriod);\n-        CertPath pathWithoutLeadingPeriod = makeCertPath(\n-            targetFromCAWithoutPeriod, paramsForCAWithoutLeadingPeriod);\n-\n-        validator.validate(pathWithoutLeadingPeriod, paramsForCAWithoutLeadingPeriod);\n-\n-        \/\/ Load certificates with a NameConstraint where the DNS value does begin with a period\n-        Path targetFromCAWithPeriodPath = Paths.get(System.getProperty(\n-            \"test.src\", \".\/\") + \"\/certs\/withLeadingPeriod\/leaf.pem\");\n-        String targetFromCAWithPeriod = Files.readString(targetFromCAWithPeriodPath);\n-\n-        Path caWithLeadingPeriodPath = Paths.get(System.getProperty(\n-            \"test.src\", \".\/\") + \"\/certs\/withLeadingPeriod\/ca.pem\");\n-        String caWithLeadingPeriod = Files.readString(caWithLeadingPeriodPath);\n-\n-        PKIXParameters paramsForCAWithLeadingPeriod = genParams(caWithLeadingPeriod);\n-        CertPath pathWithLeadingPeriod = makeCertPath(targetFromCAWithPeriod, paramsForCAWithLeadingPeriod);\n-\n-        validator.validate(pathWithLeadingPeriod, paramsForCAWithLeadingPeriod);\n+        validator.validate(path, params);\n","filename":"test\/jdk\/sun\/security\/x509\/DNSName\/LeadingPeriod.java","additions":19,"deletions":62,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m AddOptionsTest\n+ * @run main\/othervm -Xmx1g AddOptionsTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AddOptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx1400m BasicJlinkMissingJavaBase\n+ * @run main\/othervm -Xmx1g BasicJlinkMissingJavaBase\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkMissingJavaBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m BasicJlinkTest false\n+ * @run main\/othervm -Xmx1g BasicJlinkTest false\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m CustomModuleJlinkTest\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/CustomModuleJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m GenerateJLIClassesTest\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/GenerateJLIClassesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m JavaSEReproducibleTest\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JavaSEReproducibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,327 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.util.List;\n+\n+import org.testng.annotations.Test;\n+\n+import jdk.tools.jlink.internal.runtimelink.JimageDiffGenerator;\n+import jdk.tools.jlink.internal.runtimelink.JimageDiffGenerator.ImageResource;\n+import jdk.tools.jlink.internal.runtimelink.ResourceDiff;\n+\n+\/*\n+ * @test\n+ * @summary Unit test the diff generator logic for JEP 493\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal.runtimelink\n+ * @run testng JimageDiffGeneratorTest\n+ *\/\n+public class JimageDiffGeneratorTest {\n+\n+    \/*\n+     * Expect a resource diff since the \"b\" item is removed in\n+     * the optimized image.\n+     *\/\n+    @Test\n+    public void testItemsRemovedInOpt() throws Exception {\n+        List<String> entriesOpt = List.of(\"a\", \"c\", \"d\");\n+        byte[][] bytesOpt = new byte[][] {\n+                    { 0x01, 0x03, 0x03 }, \/* a *\/\n+                    { 0x09, 0x11, 0x11 }, \/* c *\/\n+                    { 0x22, 0x22, 0x30 }, \/* d *\/\n+        };\n+        ImageResource opt = new BasicImageResource(entriesOpt, bytesOpt);\n+        List<String> entriesBase = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesBase = new byte[][] {\n+            { 0x01, 0x03, 0x03 }, \/* a *\/\n+            { 0x08, 0x04, 0x04 }, \/* b *\/\n+            { 0x09, 0x11, 0x11 }, \/* c *\/\n+            { 0x22, 0x22, 0x30 }, \/* d *\/\n+        };\n+        ImageResource base = new BasicImageResource(entriesBase, bytesBase);\n+        JimageDiffGenerator gen = new JimageDiffGenerator();\n+        List<ResourceDiff> result = gen.generateDiff(base, opt);\n+        assertEquals(result.size(), 1);\n+        assertEquals(result.get(0).getKind(), ResourceDiff.Kind.REMOVED);\n+        assertEquals(result.get(0).getName(), \"b\");\n+        assertEquals(result.get(0).getResourceBytes(), bytesBase[1]);\n+    }\n+\n+    \/*\n+     * Expect no difference as streams are the same\n+     *\/\n+    @Test\n+    public void testNoDiff() throws Exception {\n+        List<String> entriesBase = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesBase = new byte[][] {\n+            { 0x01, 0x03, 0x03 }, \/* a *\/\n+            { 0x08, 0x04, 0x04 }, \/* b *\/\n+            { 0x09, 0x11, 0x11 }, \/* c *\/\n+            { 0x22, 0x22, 0x30 }, \/* d *\/\n+        };\n+        ImageResource base = new BasicImageResource(entriesBase, bytesBase);\n+        ImageResource opt = new BasicImageResource(entriesBase, bytesBase);\n+        JimageDiffGenerator gen = new JimageDiffGenerator();\n+        List<ResourceDiff> result = gen.generateDiff(base, opt);\n+        assertTrue(result.isEmpty());\n+    }\n+\n+    \/*\n+     * Expect a resource diff since the \"b\" item has been added in\n+     * the optimized image.\n+     *\/\n+    @Test\n+    public void testItemsAddedInOpt() throws Exception {\n+        List<String> entriesBase = List.of(\"a\", \"c\", \"d\");\n+        byte[][] bytesBase = new byte[][] {\n+                    { 0x01, 0x03, 0x03 }, \/* a *\/\n+                    { 0x09, 0x11, 0x11 }, \/* c *\/\n+                    { 0x22, 0x22, 0x30 }, \/* d *\/\n+        };\n+        ImageResource base = new BasicImageResource(entriesBase, bytesBase);\n+        List<String> entriesOpt = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesOpt = new byte[][] {\n+            { 0x01, 0x03, 0x03 }, \/* a *\/\n+            { 0x08, 0x04, 0x04 }, \/* b *\/\n+            { 0x09, 0x11, 0x11 }, \/* c *\/\n+            { 0x22, 0x22, 0x30 }, \/* d *\/\n+        };\n+        ImageResource opt = new BasicImageResource(entriesOpt, bytesOpt);\n+        JimageDiffGenerator gen = new JimageDiffGenerator();\n+        List<ResourceDiff> result = gen.generateDiff(base, opt);\n+        assertEquals(result.size(), 1);\n+        assertEquals(result.get(0).getKind(), ResourceDiff.Kind.ADDED);\n+        assertEquals(result.get(0).getName(), \"b\");\n+        assertEquals(result.get(0).getResourceBytes(), null, \"Added entries in opt don't have resource bytes\");\n+    }\n+\n+    \/*\n+     * Expect a resource diff since the \"d\" item has modified bytes in the\n+     * optimized image resource.\n+     *\/\n+    @Test\n+    public void testBytesDiffer() throws Exception {\n+        List<String> entriesBase = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesBase = new byte[][] {\n+                    { 0x01, 0x03, 0x03 }, \/* a *\/\n+                    { 0x08, 0x04, 0x04 }, \/* b *\/\n+                    { 0x09, 0x11, 0x11 }, \/* c *\/\n+                    { 0x11, 0x12, 0x31 }, \/* d *\/\n+        };\n+        ImageResource base = new BasicImageResource(entriesBase, bytesBase);\n+        List<String> entriesOpt = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesOpt = new byte[][] {\n+            { 0x01, 0x03, 0x03 }, \/* a *\/\n+            { 0x08, 0x04, 0x04 }, \/* b *\/\n+            { 0x09, 0x11, 0x11 }, \/* c *\/\n+            { 0x22, 0x22, 0x30 }, \/* d - differs to base! *\/\n+        };\n+        ImageResource opt = new BasicImageResource(entriesOpt, bytesOpt);\n+        JimageDiffGenerator gen = new JimageDiffGenerator();\n+        List<ResourceDiff> result = gen.generateDiff(base, opt);\n+        assertEquals(result.size(), 1);\n+        assertEquals(result.get(0).getKind(), ResourceDiff.Kind.MODIFIED);\n+        assertEquals(result.get(0).getName(), \"d\");\n+        assertEquals(result.get(0).getResourceBytes(), bytesBase[3]);\n+    }\n+\n+    \/*\n+     * Expect a resource diff since an item has modified bytes. Test\n+     * for a resource that has more than 1K bytes (the buffer size used\n+     * internally).\n+     *\/\n+    @Test\n+    public void testBytesDifferLarge() throws Exception {\n+        List<String> entriesBase = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesBase = new byte[][] {\n+                    { 0x01, 0x03, 0x03 }, \/* a *\/\n+                    { 0x08, 0x04, 0x04 }, \/* b *\/\n+                    { },                  \/* c *\/\n+                    { 0x11, 0x12, 0x31 }, \/* d *\/\n+        };\n+        bytesBase[2] = generateBytes();\n+        ImageResource base = new BasicImageResource(entriesBase, bytesBase);\n+        List<String> entriesOpt = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesOpt = new byte[][] {\n+            { 0x01, 0x03, 0x03 }, \/* a *\/\n+            { 0x08, 0x04, 0x04 }, \/* b *\/\n+            { },                  \/* c *\/\n+            { 0x22, 0x22, 0x30 }, \/* d *\/\n+        };\n+        bytesOpt[2] = generateBytes();\n+        \/\/ Change the first byte of 'c' in the opt bytes\n+        bytesOpt[2][0] = -1;\n+        \/\/ assert pre-condition\n+        assertTrue(bytesOpt[2][0] != bytesBase[2][0]);\n+\n+        ImageResource opt = new BasicImageResource(entriesOpt, bytesOpt);\n+        JimageDiffGenerator gen = new JimageDiffGenerator();\n+        List<ResourceDiff> result = gen.generateDiff(base, opt);\n+        assertEquals(result.size(), 2);\n+        \/\/ assertions for 'c' differences\n+        assertEquals(result.get(0).getKind(), ResourceDiff.Kind.MODIFIED);\n+        assertEquals(result.get(0).getName(), \"c\");\n+        assertEquals(result.get(0).getResourceBytes(), bytesBase[2]);\n+\n+        \/\/ assertion for 'd' differences\n+        assertEquals(result.get(1).getKind(), ResourceDiff.Kind.MODIFIED);\n+        assertEquals(result.get(1).getName(), \"d\");\n+        assertEquals(result.get(1).getResourceBytes(), bytesBase[3]);\n+    }\n+\n+    \/*\n+     * Expect a no resource difference since the steams are both empty\n+     *\/\n+    @Test\n+    public void testEmptyStreams() throws Exception {\n+        List<String> entriesBase = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesBase = new byte[][] {\n+            { }, \/* a *\/\n+            { }, \/* b *\/\n+            { }, \/* c *\/\n+            { }, \/* d *\/\n+        };\n+        ImageResource base = new BasicImageResource(entriesBase, bytesBase);\n+        ImageResource opt = new BasicImageResource(entriesBase, bytesBase);\n+        JimageDiffGenerator gen = new JimageDiffGenerator();\n+        List<ResourceDiff> result = gen.generateDiff(base, opt);\n+        assertTrue(result.isEmpty());\n+    }\n+\n+    \/*\n+     * Expect a difference since entry 'a' has zero bytes in opt.\n+     *\/\n+    @Test\n+    public void testNotEqualLength() throws Exception {\n+        List<String> entriesBase = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesBase = new byte[][] {\n+            { 0x01, 0x03, 0x03 }, \/* a *\/\n+            { 0x08, 0x04, 0x04 }, \/* b *\/\n+            { 0x09, 0x11, 0x11 }, \/* c *\/\n+            { 0x11, 0x12, 0x31 }, \/* d *\/\n+        };\n+        byte[][] bytesOpt = new byte[][] {\n+            { }, \/* a *\/\n+            { 0x08, 0x04, 0x04 }, \/* b *\/\n+            { 0x09, 0x11, 0x11 }, \/* c *\/\n+            { 0x11, 0x12, 0x31 }, \/* d *\/\n+        };\n+        ImageResource base = new BasicImageResource(entriesBase, bytesBase);\n+        ImageResource opt = new BasicImageResource(entriesBase, bytesOpt);\n+        JimageDiffGenerator gen = new JimageDiffGenerator();\n+        List<ResourceDiff> result = gen.generateDiff(base, opt);\n+        assertEquals(result.size(), 1);\n+        assertEquals(result.get(0).getKind(), ResourceDiff.Kind.MODIFIED);\n+        assertEquals(result.get(0).getName(), \"a\");\n+        assertEquals(result.get(0).getResourceBytes(), bytesBase[0]);\n+    }\n+\n+    \/*\n+     * Expect a difference since entry 'a' on the optimized version is\n+     * one byte longer.\n+     *\/\n+    @Test\n+    public void testBytesDifferExactBufferSize() throws Exception {\n+        List<String> entriesBase = List.of(\"a\", \"b\", \"c\", \"d\");\n+        byte[][] bytesBase = new byte[][] {\n+            { }, \/* a *\/\n+            { 0x08, 0x04, 0x04 }, \/* b *\/\n+            { 0x09, 0x11, 0x11 }, \/* c *\/\n+            { 0x11, 0x12, 0x31 }, \/* d *\/\n+        };\n+        byte[][] bytesOpt = new byte[][] {\n+            { }, \/* a *\/\n+            { 0x08, 0x04, 0x04 }, \/* b *\/\n+            { 0x09, 0x11, 0x11 }, \/* c *\/\n+            { 0x11, 0x12, 0x31 }, \/* d *\/\n+        };\n+        bytesBase[0] = genBytesOfSize(1024);    \/\/ exact buffer size\n+        bytesOpt[0] = genBytesOfSize(1024 + 1); \/\/ buffer size + 1\n+\n+        ImageResource base = new BasicImageResource(entriesBase, bytesBase);\n+        ImageResource opt = new BasicImageResource(entriesBase, bytesOpt);\n+        JimageDiffGenerator gen = new JimageDiffGenerator();\n+        List<ResourceDiff> result = gen.generateDiff(base, opt);\n+        assertEquals(result.size(), 1);\n+        assertEquals(result.get(0).getKind(), ResourceDiff.Kind.MODIFIED);\n+        assertEquals(result.get(0).getName(), \"a\");\n+        assertEquals(result.get(0).getResourceBytes(), bytesBase[0]);\n+    }\n+\n+    private byte[] generateBytes() {\n+        int size = 1024 + 254;\n+        return genBytesOfSize(size);\n+    }\n+\n+    private byte[] genBytesOfSize(int size) {\n+        byte[] result = new byte[size];\n+        for (int i = 0; i < size; i++) {\n+            result[i] = (byte)(i % Byte.MAX_VALUE);\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Simple stub ImageResource for test purposes\n+    static class BasicImageResource implements ImageResource {\n+\n+        private final List<String> entries;\n+        private final byte[][] entryBytes;\n+\n+        public BasicImageResource(List<String> entries, byte[][] entryBytes) {\n+            this.entries = entries;\n+            this.entryBytes = entryBytes;\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            \/\/ nothing\n+        }\n+\n+        @Override\n+        public List<String> getEntries() {\n+            return entries;\n+        }\n+\n+        @Override\n+        public byte[] getResourceBytes(String name) {\n+            for (int i = 0; i < entries.size(); i++) {\n+                if (entries.get(i).equals(name)) {\n+                    return entryBytes[i];\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public InputStream getResource(String name) {\n+            byte[] bytes = getResourceBytes(name);\n+            return new ByteArrayInputStream(bytes);\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JimageDiffGeneratorTest.java","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx1400m KeepPackagedModulesFailTest\n+ * @run main\/othervm -Xmx1g KeepPackagedModulesFailTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/KeepPackagedModulesFailTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m ModifiedFilesExitTest\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesExitTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m ModifiedFilesWarningTest\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesWarningTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m MultiHopTest\n+ * @run main\/othervm -Xmx1g MultiHopTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/MultiHopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run main\/othervm\/timeout=1200 -Xmx1400m PackagedModulesVsRuntimeImageLinkTest\n+ * @run main\/othervm\/timeout=1200 -Xmx1g PackagedModulesVsRuntimeImageLinkTest\n@@ -79,1 +79,0 @@\n-        System.out.println(\"Now comparing jmod-less and jmod-full) images\");\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PackagedModulesVsRuntimeImageLinkTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xmx1400m PatchedJDKModuleJlinkTest\n+ * @run main\/othervm -Xmx1g PatchedJDKModuleJlinkTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PatchedJDKModuleJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx1400m SystemModulesTest\n+ * @run main\/othervm -Xmx1g SystemModulesTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xmx1400m SystemModulesTest2\n+ * @run main\/othervm -Xmx1g SystemModulesTest2\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,6 @@\n- * @run main SourceMode\n+ * @comment Test is being run in othervm to support JEP 493 enabled\n+ *          JDKs which don't allow patched modules. Note that jtreg patches\n+ *          module java.base to add java.lang.JTRegModuleHelper. If then a\n+ *          jlink run is attempted in-process - using the ToolProvider API -\n+ *          on a JEP 493 enabled JDK, the test fails.\n+ * @run main\/othervm SourceMode\n","filename":"test\/jdk\/tools\/launcher\/SourceMode.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}