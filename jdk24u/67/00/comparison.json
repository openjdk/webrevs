{"files":[{"patch":"@@ -4677,1 +4677,2 @@\n-int java_lang_invoke_CallSite::_context_offset;\n+int java_lang_invoke_CallSite::_vmdependencies_offset;\n+int java_lang_invoke_CallSite::_last_cleanup_offset;\n@@ -4681,1 +4682,0 @@\n-  macro(_context_offset, k, \"context\", java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)\n@@ -4686,0 +4686,1 @@\n+  CALLSITE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n@@ -4691,0 +4692,1 @@\n+  CALLSITE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n@@ -4694,1 +4696,1 @@\n-oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {\n+DependencyContext java_lang_invoke_CallSite::vmdependencies(oop call_site) {\n@@ -4696,3 +4698,4 @@\n-\n-  oop dep_oop = call_site->obj_field_access<AS_NO_KEEPALIVE>(_context_offset);\n-  return dep_oop;\n+  nmethodBucket* volatile* vmdeps_addr = call_site->field_addr<nmethodBucket* volatile>(_vmdependencies_offset);\n+  volatile uint64_t* last_cleanup_addr = call_site->field_addr<volatile uint64_t>(_last_cleanup_offset);\n+  DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);\n+  return dep_ctx;\n@@ -4719,24 +4722,0 @@\n-\/\/ Support for java_lang_invoke_MethodHandleNatives_CallSiteContext\n-\n-int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;\n-int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;\n-\n-void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {\n-  InstanceKlass* k = vmClasses::Context_klass();\n-  CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {\n-  CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n-DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {\n-  assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), \"\");\n-  nmethodBucket* volatile* vmdeps_addr = call_site->field_addr<nmethodBucket* volatile>(_vmdependencies_offset);\n-  volatile uint64_t* last_cleanup_addr = call_site->field_addr<volatile uint64_t>(_last_cleanup_offset);\n-  DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);\n-  return dep_ctx;\n-}\n-\n@@ -5392,1 +5371,0 @@\n-  f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \\\n@@ -5458,2 +5436,1 @@\n-        klass == vmClasses::MemberName_klass() ||\n-        klass == vmClasses::Context_klass()) {\n+        klass == vmClasses::MemberName_klass()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":10,"deletions":33,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1412,0 +1412,3 @@\n+#define CALLSITE_INJECTED_FIELDS(macro) \\\n+  macro(java_lang_invoke_CallSite, vmdependencies, intptr_signature, false) \\\n+  macro(java_lang_invoke_CallSite, last_cleanup, long_signature, false)\n@@ -1418,1 +1421,2 @@\n-  static int _context_offset;\n+  static int _vmdependencies_offset;\n+  static int _last_cleanup_offset;\n@@ -1429,1 +1433,1 @@\n-  static oop context_no_keepalive(oop site);\n+  static DependencyContext vmdependencies(oop call_site);\n@@ -1439,1 +1443,0 @@\n-  static int context_offset() { CHECK_INIT(_context_offset); }\n@@ -1464,29 +1467,0 @@\n-\/\/ Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects\n-\n-#define CALLSITECONTEXT_INJECTED_FIELDS(macro) \\\n-  macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \\\n-  macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)\n-\n-class DependencyContext;\n-\n-class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {\n-  friend class JavaClasses;\n-\n-private:\n-  static int _vmdependencies_offset;\n-  static int _last_cleanup_offset;\n-\n-  static void compute_offsets();\n-\n-public:\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-  \/\/ Accessors\n-  static DependencyContext vmdependencies(oop context);\n-\n-  \/\/ Testers\n-  static bool is_subclass(Klass* klass) {\n-    return klass->is_subclass_of(vmClasses::Context_klass());\n-  }\n-  static bool is_instance(oop obj);\n-};\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":6,"deletions":32,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -264,4 +264,0 @@\n-}\n-\n-inline bool java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(oop obj) {\n-  return obj != nullptr && is_subclass(obj->klass());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  CALLSITECONTEXT_INJECTED_FIELDS(macro)    \\\n+  CALLSITE_INJECTED_FIELDS(macro)           \\\n","filename":"src\/hotspot\/share\/classfile\/javaClassesImpl.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-  do_klass(Context_klass,                               java_lang_invoke_MethodHandleNatives_CallSiteContext  ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -329,1 +329,0 @@\n-  template(java_lang_invoke_MethodHandleNatives_CallSiteContext, \"java\/lang\/invoke\/MethodHandleNatives$CallSiteContext\") \\\n@@ -333,1 +332,0 @@\n-  template(java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, \"Ljava\/lang\/invoke\/MethodHandleNatives$CallSiteContext;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,6 +171,0 @@\n-nmethodBucket* DependencyContext::release_and_get_next_not_unloading(nmethodBucket* b) {\n-  nmethodBucket* next = b->next_not_unloading();\n-  release(b);\n-  return next;\n- }\n-\n@@ -217,12 +211,0 @@\n-void DependencyContext::remove_and_mark_for_deoptimization_all_dependents(DeoptimizationScope* deopt_scope) {\n-  nmethodBucket* b = dependencies_not_unloading();\n-  set_dependencies(nullptr);\n-  while (b != nullptr) {\n-    nmethod* nm = b->get_nmethod();\n-    \/\/ Also count already (concurrently) marked nmethods to make sure\n-    \/\/ deoptimization is triggered before execution in this thread continues.\n-    deopt_scope->mark(nm);\n-    b = release_and_get_next_not_unloading(b);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-\/\/ or CallSiteContext oop for call_site_target dependencies (see javaClasses.hpp).\n+\/\/ or CallSite oop for call_site_target dependencies (see javaClasses.hpp).\n@@ -95,1 +95,0 @@\n-  \/\/ (e.g. CallSiteContext Java object).\n@@ -117,1 +116,0 @@\n-  void remove_and_mark_for_deoptimization_all_dependents(DeoptimizationScope* deopt_scope);\n@@ -119,1 +117,0 @@\n-  static nmethodBucket* release_and_get_next_not_unloading(nmethodBucket* b);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -935,7 +935,1 @@\n-  oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);\n-  DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);\n-  \/\/ Try to purge stale entries on updates.\n-  \/\/ Since GC doesn't clean dependency contexts rooted at CallSiteContext objects,\n-  \/\/ in order to avoid memory leak, stale entries are purged whenever a dependency list\n-  \/\/ is changed (both on addition and removal). Though memory reclamation is delayed,\n-  \/\/ it avoids indefinite memory usage growth.\n+  DependencyContext deps = java_lang_invoke_CallSite::vmdependencies(call_site);\n@@ -946,2 +940,1 @@\n-  oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site);\n-  DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);\n+  DependencyContext deps = java_lang_invoke_CallSite::vmdependencies(call_site);\n@@ -959,2 +952,1 @@\n-    oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());\n-    DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);\n+    DependencyContext deps = java_lang_invoke_CallSite::vmdependencies(call_site());\n@@ -1325,17 +1317,0 @@\n-\/\/ It is called by a Cleaner object which ensures that dropped CallSites properly\n-\/\/ deallocate their dependency information.\n-JVM_ENTRY(void, MHN_clearCallSiteContext(JNIEnv* env, jobject igcls, jobject context_jh)) {\n-  Handle context(THREAD, JNIHandles::resolve_non_null(context_jh));\n-  DeoptimizationScope deopt_scope;\n-  {\n-    NoSafepointVerifier nsv;\n-    MutexLocker ml(THREAD, CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-    DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context());\n-    deps.remove_and_mark_for_deoptimization_all_dependents(&deopt_scope);\n-    \/\/ This is assumed to be an 'atomic' operation by verification.\n-    \/\/ So keep it under lock for now.\n-    deopt_scope.deoptimize_marked();\n-  }\n-}\n-JVM_END\n-\n@@ -1388,1 +1363,0 @@\n-#define CTX   JLINV \"MethodHandleNatives$CallSiteContext;\"\n@@ -1404,1 +1378,0 @@\n-  {CC \"clearCallSiteContext\",      CC \"(\" CTX \")V\",                          FN_PTR(MHN_clearCallSiteContext)},\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":3,"deletions":30,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -141,6 +141,0 @@\n-    \/**\n-     * {@code CallSite} dependency context.\n-     * JVM uses CallSite.context to store nmethod dependencies on the call site target.\n-     *\/\n-    private final MethodHandleNatives.CallSiteContext context = MethodHandleNatives.CallSiteContext.make(this);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/CallSite.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,25 +74,0 @@\n-    \/** Represents a context to track nmethod dependencies on CallSite instance target. *\/\n-    static class CallSiteContext implements Runnable {\n-        \/\/@Injected JVM_nmethodBucket* vmdependencies;\n-        \/\/@Injected jlong last_cleanup;\n-\n-        static CallSiteContext make(CallSite cs) {\n-            final CallSiteContext newContext = new CallSiteContext();\n-            \/\/ CallSite instance is tracked by a Cleanable which clears native\n-            \/\/ structures allocated for CallSite context. Though the CallSite can\n-            \/\/ become unreachable, its Context is retained by the Cleanable instance\n-            \/\/ (which is referenced from Cleaner instance which is referenced from\n-            \/\/ CleanerFactory class) until cleanup is performed.\n-            CleanerFactory.cleaner().register(cs, newContext);\n-            return newContext;\n-        }\n-\n-        @Override\n-        public void run() {\n-            MethodHandleNatives.clearCallSiteContext(this);\n-        }\n-    }\n-\n-    \/** Invalidate all recorded nmethods. *\/\n-    private static native void clearCallSiteContext(CallSiteContext context);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -126,2 +126,2 @@\n-            Field f = MethodHandleHelper.MHN_CALL_SITE_CONTEXT_CLASS.getDeclaredField(\"vmdependencies\");\n-            throw new AssertionError(\"Context.dependencies field should be hidden\");\n+            Field f = MethodHandleHelper.JLI_CALL_SITE_CLASS.getDeclaredField(\"vmdependencies\");\n+            throw new AssertionError(\"CallSite.dependencies field should be hidden\");\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/CallSiteDepContextTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-    public static final Class<?> MHN_CALL_SITE_CONTEXT_CLASS\n-            = MethodHandleNatives.CallSiteContext.class;\n+    public static final Class<?> JLI_CALL_SITE_CLASS\n+            = java.lang.invoke.CallSite.class;\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/patches\/java.base\/java\/lang\/invoke\/MethodHandleHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}