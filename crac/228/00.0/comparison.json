{"files":[{"patch":"@@ -3258,0 +3258,2 @@\n+      set_numa_bitmask_equal(CAST_TO_FN_PTR(numa_bitmask_equal_func_t,\n+                                            libnuma_dlsym(handle, \"numa_bitmask_equal\")));\n@@ -3268,0 +3270,2 @@\n+      set_numa_get_run_node_mask(CAST_TO_FN_PTR(numa_get_run_node_mask_func_t,\n+                                                libnuma_v2_dlsym(handle, \"numa_get_run_node_mask\")));\n@@ -3275,0 +3279,1 @@\n+        set_numa_cpunodebind_bitmask(_numa_get_run_node_mask());\n@@ -3451,0 +3456,1 @@\n+os::Linux::numa_bitmask_equal_func_t os::Linux::_numa_bitmask_equal;\n@@ -3454,0 +3460,1 @@\n+os::Linux::numa_get_run_node_mask_func_t os::Linux::_numa_get_run_node_mask;\n@@ -3462,0 +3469,1 @@\n+struct bitmask* os::Linux::_numa_cpunodebind_bitmask;\n@@ -4486,2 +4494,1 @@\n-    FLAG_SET_ERGO(UseNUMA, false);\n-    FLAG_SET_ERGO(UseNUMAInterleaving, false); \/\/ Also depends on libnuma.\n+    disable_numa(\"Failed to initialize libnuma\");\n@@ -4489,4 +4496,7 @@\n-    if ((Linux::numa_max_node() < 1) || Linux::is_bound_to_single_node()) {\n-      \/\/ If there's only one node (they start from 0) or if the process\n-      \/\/ is bound explicitly to a single node using membind, disable NUMA\n-      UseNUMA = false;\n+    Linux::set_configured_numa_policy(Linux::identify_numa_policy());\n+    if (Linux::numa_max_node() < 1) {\n+      disable_numa(\"Only a single NUMA node is available\");\n+    } else if (Linux::is_bound_to_single_mem_node()) {\n+      disable_numa(\"The process is bound to a single NUMA node\");\n+    } else if (Linux::mem_and_cpu_node_mismatch()) {\n+      disable_numa(\"The process memory and cpu node configuration does not match\");\n@@ -4497,2 +4507,0 @@\n-      Linux::set_configured_numa_policy(Linux::identify_numa_policy());\n-\n@@ -4536,0 +4544,10 @@\n+void os::Linux::disable_numa(const char* reason) {\n+  if ((UseNUMA && FLAG_IS_CMDLINE(UseNUMA)) ||\n+      (UseNUMAInterleaving && FLAG_IS_CMDLINE(UseNUMAInterleaving))) {\n+    \/\/ Only issue a warning if the user explicitly asked for NUMA support\n+    log_warning(os)(\"NUMA support disabled: %s\", reason);\n+  }\n+  FLAG_SET_ERGO(UseNUMA, false);\n+  FLAG_SET_ERGO(UseNUMAInterleaving, false);\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+  static void disable_numa(const char* reason);\n@@ -209,0 +210,1 @@\n+  typedef struct bitmask* (*numa_get_run_node_mask_func_t)(void);\n@@ -213,0 +215,1 @@\n+  typedef int (*numa_bitmask_equal_func_t)(struct bitmask *bmp1, struct bitmask *bmp2);\n@@ -226,0 +229,1 @@\n+  static numa_bitmask_equal_func_t _numa_bitmask_equal;\n@@ -228,0 +232,1 @@\n+  static numa_get_run_node_mask_func_t _numa_get_run_node_mask;\n@@ -236,0 +241,1 @@\n+  static struct bitmask* _numa_cpunodebind_bitmask;\n@@ -248,0 +254,1 @@\n+  static void set_numa_bitmask_equal(numa_bitmask_equal_func_t func) { _numa_bitmask_equal = func; }\n@@ -250,0 +257,1 @@\n+  static void set_numa_get_run_node_mask(numa_get_run_node_mask_func_t func) { _numa_get_run_node_mask = func; }\n@@ -258,0 +266,1 @@\n+  static void set_numa_cpunodebind_bitmask(struct bitmask* ptr)        { _numa_cpunodebind_bitmask = ptr ;      }\n@@ -370,3 +379,3 @@\n-  \/\/ Check if bound to only one numa node.\n-  \/\/ Returns true if bound to a single numa node, otherwise returns false.\n-  static bool is_bound_to_single_node() {\n+  \/\/ Check if memory is bound to only one numa node.\n+  \/\/ Returns true if memory is bound to a single numa node, otherwise returns false.\n+  static bool is_bound_to_single_mem_node() {\n@@ -377,1 +386,6 @@\n-    if (_numa_membind_bitmask != nullptr && _numa_max_node != nullptr && _numa_bitmask_isbitset != nullptr) {\n+    struct bitmask* mem_nodes_bitmask = Linux::_numa_membind_bitmask;\n+    if (Linux::is_running_in_interleave_mode()) {\n+      mem_nodes_bitmask = Linux::_numa_interleave_bitmask;\n+    }\n+\n+    if (mem_nodes_bitmask != nullptr && _numa_max_node != nullptr && _numa_bitmask_isbitset != nullptr) {\n@@ -384,1 +398,1 @@\n-      if (_numa_bitmask_isbitset(_numa_membind_bitmask, node)) {\n+      if (_numa_bitmask_isbitset(mem_nodes_bitmask, node)) {\n@@ -395,0 +409,13 @@\n+  \/\/ Check if cpu and memory nodes are aligned, returns true if nodes misalign\n+  static bool mem_and_cpu_node_mismatch() {\n+    struct bitmask* mem_nodes_bitmask = Linux::_numa_membind_bitmask;\n+    if (Linux::is_running_in_interleave_mode()) {\n+      mem_nodes_bitmask = Linux::_numa_interleave_bitmask;\n+    }\n+\n+    if (mem_nodes_bitmask == nullptr || Linux::_numa_cpunodebind_bitmask == nullptr) {\n+      return false;\n+    }\n+\n+    return !_numa_bitmask_equal(mem_nodes_bitmask, Linux::_numa_cpunodebind_bitmask);\n+  }\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -201,0 +201,8 @@\n+  assert(free_ratio <= 100, \"precondition\");\n+  if (free_ratio == 100) {\n+    \/\/ If 100 then below calculations will divide by zero and return min of\n+    \/\/ resulting infinity and MaxHeapSize.  Avoid issues of UB vs is_iec559\n+    \/\/ and ubsan warnings, and just immediately return MaxHeapSize.\n+    return MaxHeapSize;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -365,0 +365,15 @@\n+\/\/ Enable collection of TaskQueue statistics.\n+\/\/ Enabled by default in debug builds.  Otherwise, disabled by default.\n+#ifndef TASKQUEUE_STATS\n+#ifdef ASSERT\n+#define TASKQUEUE_STATS 1\n+#else\n+#define TASKQUEUE_STATS 0\n+#endif \/\/ ASSERT\n+#endif \/\/ TASKQUEUE_STATS\n+#if TASKQUEUE_STATS\n+#define TASKQUEUE_STATS_ONLY(code) code\n+#else\n+#define TASKQUEUE_STATS_ONLY(code)\n+#endif \/\/ TASKQUEUE_STATS\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -233,1 +233,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.graal.compiler;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1310,1 +1310,2 @@\n-    when an `OutOfMemoryError` exception is first thrown. If the string\n+    when an `OutOfMemoryError` exception is first thrown by the JVM.\n+    If the string\n@@ -1314,0 +1315,4 @@\n+    This applies only to `OutOfMemoryError` exceptions caused by Java Heap\n+    exhaustion; it does not apply to `OutOfMemoryError` exceptions thrown\n+    directly from Java code, nor by the JVM for other types of resource\n+    exhaustion (such as native thread creation errors).\n@@ -2218,1 +2223,1 @@\n-    exception is thrown. You can explicitly set the heap dump file path and\n+    exception is thrown by the JVM. You can explicitly set the heap dump file path and\n@@ -2222,0 +2227,4 @@\n+    This applies only to `OutOfMemoryError` exceptions caused by Java Heap\n+    exhaustion; it does not apply to `OutOfMemoryError` exceptions thrown\n+    directly from Java code, nor by the JVM for other types of resource\n+    exhaustion (such as native thread creation errors).\n","filename":"src\/java.base\/share\/man\/java.md","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -176,1 +176,0 @@\n-vmTestbase\/gc\/memory\/Nio\/Nio.java 8340728 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -736,0 +736,2 @@\n+com\/sun\/jdi\/ProcessAttachTest.java         8346827 linux-all\n+com\/sun\/jdi\/ReattachStressTest.java        8346827 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}