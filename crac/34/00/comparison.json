{"files":[{"patch":"@@ -28,3 +28,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.internal.crac.JDKResource;\n@@ -251,2 +248,0 @@\n-    private static JDKResource referenceHandlerResource;\n-\n@@ -335,19 +330,0 @@\n-\n-        referenceHandlerResource = new JDKResource() {\n-            @Override\n-            public Priority getPriority() {\n-                return Priority.REFERENCE_HANDLER;\n-            }\n-\n-            @Override\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-                System.gc();\n-                \/\/ TODO ensure GC done processing all References\n-                while (waitForReferenceProcessing());\n-            }\n-\n-            @Override\n-            public void afterRestore(Context<? extends Resource> context) throws Exception {\n-            }\n-        };\n-        jdk.internal.crac.Core.getJDKContext().register(referenceHandlerResource);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-    private int nWaiters = 0;\n@@ -156,2 +155,0 @@\n-                ++nWaiters;\n-                lock.notifyAll();\n@@ -159,1 +156,0 @@\n-                --nWaiters;\n@@ -211,13 +207,0 @@\n-\n-    \/**\n-     * Blocks calling thread until the specified number of threads are blocked with no reference available.\n-     * @param nWaiters number of threads to wait\n-     * @throws InterruptedException If the wait is interrupted\n-     *\/\n-    public void waitForWaiters(int nWaiters) throws InterruptedException {\n-        synchronized (lock) {\n-            while (head != null || this.nWaiters < nWaiters) {\n-                lock.wait();\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -71,15 +71,1 @@\n-        SEEDER_HOLDER,\n-\n-        \/* Keep next priorities last to ensure handling of pending References\n-         * appeared on earlier priorities. *\/\n-\n-        \/**\n-         * Priority of the\n-         * java.lan.ref.Reference static resource\n-         *\/\n-        REFERENCE_HANDLER,\n-        \/**\n-         * Priority of the\n-         * jdk.internal.ref.CleanerImpl resources\n-         *\/\n-        CLEANERS,\n+        SEEDER_HOLDER\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,3 +37,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.internal.crac.JDKResource;\n@@ -46,1 +43,1 @@\n-public final class CleanerImpl implements Runnable, JDKResource {\n+public final class CleanerImpl implements Runnable {\n@@ -89,1 +86,0 @@\n-        jdk.internal.crac.Core.getJDKContext().register(this);\n@@ -155,14 +151,0 @@\n-    @Override\n-    public Priority getPriority() {\n-        return Priority.CLEANERS;\n-    }\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        queue.waitForWaiters(1);\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws Exception {\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.lang.ref.Cleaner;\n-\n-import jdk.crac.*;\n-\n-\/**\n- * @test\n- * @run main\/othervm -XX:CREngine=simengine -XX:CRaCCheckpointTo=.\/cr RefQueueTest\n- *\/\n-public class RefQueueTest {\n-    private static final Cleaner cleaner = Cleaner.create();\n-\n-    static public void main(String[] args) throws Exception {\n-\n-        File badFile = File.createTempFile(\"jtreg-RefQueueTest\", null);\n-        OutputStream badStream = new FileOutputStream(badFile);\n-        badStream.write('j');\n-        badFile.delete();\n-\n-        \/\/ the cleaner would be able to run right away\n-        cleaner.register(new Object(), () -> {\n-            try {\n-                badStream.close();\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        });\n-\n-        \/\/ should close the file and only then go to the native checkpoint\n-        Core.checkpointRestore();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"}]}