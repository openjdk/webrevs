{"files":[{"patch":"@@ -67,2 +67,4 @@\n-  static void crac_restore() {}\n-  static void crac_restore_finalize() {}\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,2 +44,4 @@\n-  static void crac_restore() {}\n-  static void crac_restore_finalize() {}\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,2 +90,4 @@\n-  static void crac_restore() {}\n-  static void crac_restore_finalize() {}\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -282,2 +282,4 @@\n-  static void crac_restore() {}\n-  static void crac_restore_finalize() {}\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -417,2 +417,4 @@\n-  static void crac_restore() {}\n-  static void crac_restore_finalize() {}\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+# if defined(__clang__) && defined(__STRICT_ANSI__)\n+\/\/ clang <stdbool.h> is missing this definition compared to gcc\n+#  define _Bool bool\n+# endif\n@@ -55,0 +59,2 @@\n+uint64_t VM_Version::_features_saved;\n+uint64_t VM_Version::_glibc_features_saved;\n@@ -877,1 +883,1 @@\n-uint64_t VM_Version::CPUFeatures_parse(uint64_t &glibc_features) {\n+uint64_t VM_Version::CPUFeatures_parse(const char *str, uint64_t &glibc_features) {\n@@ -883,1 +889,1 @@\n-  if (CPUFeatures == NULL || strcmp(CPUFeatures, \"native\") == 0) {\n+  if (str == NULL || strcmp(str, \"native\") == 0) {\n@@ -886,1 +892,1 @@\n-  if (strcmp(CPUFeatures, \"ignore\") == 0) {\n+  if (strcmp(str, \"ignore\") == 0) {\n@@ -891,1 +897,1 @@\n-  if (strcmp(CPUFeatures, \"generic\") == 0) {\n+  if (strcmp(str, \"generic\") == 0) {\n@@ -912,1 +918,1 @@\n-  unsigned long long ull = strtoull(CPUFeatures, &endptr, 0);\n+  unsigned long long ull = strtoull(str, &endptr, 0);\n@@ -921,1 +927,1 @@\n-  vm_exit_during_initialization(err_msg(\"VM option 'CPUFeatures=%s' must be of the form: 0xnum,0xnum\", CPUFeatures));\n+  vm_exit_during_initialization(err_msg(\"VM option 'CPUFeatures=%s' must be of the form: 0xnum,0xnum\", str));\n@@ -926,1 +932,0 @@\n-bool VM_Version::_crac_restore_missing_features;\n@@ -944,12 +949,10 @@\n-  char env_buf[strlen(disable_str) + (!env ? 0 : strlen(env) + 100)];\n-  if (env) {\n-    if (ShowCPUFeatures) {\n-      tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n-    }\n-    const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n-    if (!hwcaps) {\n-      strcpy(env_buf, env);\n-      strcat(env_buf, disable_str);\n-    } else {\n-      const char *colon = strchr(hwcaps, ':');\n-      if (!colon) {\n+  {\n+    ResourceMark rm;\n+    size_t env_buf_size = strlen(disable_str) + (!env ? 0 : strlen(env) + 100);\n+    char *env_buf = NEW_RESOURCE_ARRAY(char, env_buf_size);\n+    if (env) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n+      if (!hwcaps) {\n@@ -957,1 +960,1 @@\n-        strcat(env_buf, disable_str + glibc_prefix_len);\n+        strcat(env_buf, disable_str);\n@@ -959,2 +962,8 @@\n-        int err = jio_snprintf(env_buf, sizeof(env_buf), \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n-        assert(err >= 0 && (unsigned)err < sizeof(env_buf), \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+        const char *colon = strchr(hwcaps, ':');\n+        if (!colon) {\n+          strcpy(env_buf, env);\n+          strcat(env_buf, disable_str + glibc_prefix_len);\n+        } else {\n+          int err = jio_snprintf(env_buf, env_buf_size, \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n+          assert(err >= 0 && (unsigned) err < env_buf_size, \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+        }\n@@ -962,0 +971,7 @@\n+      env_val = env_buf;\n+    }\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+    }\n+    if (setenv(TUNABLES_NAME, env_val, 1)) {\n+      vm_exit_during_initialization(err_msg(\"setenv \" TUNABLES_NAME \" error: %m\"));\n@@ -963,4 +979,0 @@\n-    env_val = env_buf;\n-  }\n-  if (ShowCPUFeatures) {\n-    tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n@@ -968,3 +980,0 @@\n-  int err = setenv(TUNABLES_NAME, env_val, 1);\n-  if (err)\n-    vm_exit_during_initialization(err_msg(\"setenv \" TUNABLES_NAME \" error: %m\"));\n@@ -972,1 +981,1 @@\n-  if (getenv(REEXEC_NAME))\n+  if (getenv(REEXEC_NAME)) {\n@@ -974,1 +983,2 @@\n-  if (setenv(REEXEC_NAME, \"1\", 1))\n+  }\n+  if (setenv(REEXEC_NAME, \"1\", 1)) {\n@@ -976,0 +986,1 @@\n+  }\n@@ -977,1 +988,0 @@\n-#undef TUNABLES_NAME\n@@ -1033,1 +1043,14 @@\n-void VM_Version::glibc_not_using(uint64_t shouldnotuse_CPU, uint64_t shouldnotuse_GLIBC) {\n+\/\/ Returns whether we should have got set a GLIBC_TUNABLES environment variables but did not get any.\n+bool VM_Version::glibc_not_using() {\n+  if (_ignore_glibc_not_using)\n+    return true;\n+\n+  uint64_t       features_expected =   MAX_CPU - 1;\n+  uint64_t glibc_features_expected = MAX_GLIBC - 1;\n+  if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+          features_expected =       _features;\n+    glibc_features_expected = _glibc_features;\n+  }\n+  uint64_t shouldnotuse_CPU   =       features_expected & ~      _features;\n+  uint64_t shouldnotuse_GLIBC = glibc_features_expected & ~_glibc_features;\n+\n@@ -1036,1 +1059,1 @@\n-    return;\n+    return true;\n@@ -1255,1 +1278,1 @@\n-    return;\n+    return true;\n@@ -1257,2 +1280,2 @@\n-    return;\n-  glibc_reexec();\n+    return true;\n+  return false;\n@@ -1262,21 +1285,0 @@\n-void VM_Version::nonlibc_tty_print_uint64(uint64_t num) {\n-  static const char prefix[] = \"0x\";\n-  tty->write(prefix, sizeof(prefix) - 1);\n-  bool first = true;\n-  for (int pos = 64 - 4; pos >= 0; pos -= 4) {\n-    unsigned nibble = (num >> pos) & 0xf;\n-    if (first && nibble == 0 && pos)\n-      continue;\n-    first = false;\n-    char c = nibble >= 0xa ? 'a' + nibble - 0xa : '0' + nibble;\n-    tty->write(&c, sizeof(c));\n-  }\n-}\n-\n-void VM_Version::nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2) {\n-  nonlibc_tty_print_uint64(num1);\n-  static const char comma = ',';\n-  tty->print_raw(&comma, sizeof(comma));\n-  nonlibc_tty_print_uint64(num2);\n-}\n-\n@@ -1327,4 +1329,1 @@\n-    static const char prefix[] = \"This machine's CPU features are: -XX:CPUFeatures=\";\n-    tty->print_raw(prefix, sizeof(prefix) - 1);\n-    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n-    tty->cr();\n+    tty->print_cr(\"This machine's CPU features are: -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, _features, _glibc_features);\n@@ -2593,5 +2592,1 @@\n-  static const char part1[] = \"; missing features of this CPU are \";\n-  tty->print_raw(part1, sizeof(part1) - 1);\n-  nonlibc_tty_print_uint64_comma_uint64(features_missing, glibc_features_missing);\n-  static const char part2[] = \" =\";\n-  tty->print_raw(part2, sizeof(part2) - 1);\n+  tty->print(\"; missing features of this CPU are \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X \" =\", features_missing, glibc_features_missing);\n@@ -2601,3 +2596,1 @@\n-  char *s = buf;\n-  while (*s)\n-    ++s;\n+  char *s = buf + strlen(buf);\n@@ -2605,8 +2598,5 @@\n-  while (*s)\n-    ++s;\n-  \/* +1 to skip the first ','. *\/\n-  tty->print_raw(buf + 1, s - (buf + 1));\n-  tty->cr();\n-  static const char line2[] = \"If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures .\";\n-  tty->print_raw(line2, sizeof(line2) - 1);\n-  tty->cr();\n+  tty->print_cr(\n+    \"%s\\n\"\n+    \"If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures .\",\n+    \/* + 1 to skip the first ','. *\/\n+    buf + 1);\n@@ -2615,2 +2605,6 @@\n-void VM_Version::crac_restore() {\n-  assert(CRaCCheckpointTo != NULL, \"\");\n+static_assert(sizeof(VM_Version::CPUFeaturesBinary) == 2 * 8, \"unexpected sizeof\");\n+bool VM_Version::cpu_features_binary(VM_Version::CPUFeaturesBinary *data) {\n+  data->cpu = _features;\n+  data->glibc = _glibc_features;\n+  return true;\n+}\n@@ -2618,5 +2612,6 @@\n-  if (ShowCPUFeatures) {\n-    static const char prefix[] = \"This snapshot's stored CPU features are: -XX:CPUFeatures=\";\n-    tty->print_raw(prefix, sizeof(prefix) - 1);\n-    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n-    tty->cr();\n+bool VM_Version::cpu_features_binary_check(const CPUFeaturesBinary *data) {\n+  ResourceMark rm;\n+\n+  if (CPUFeatures) {\n+    warning(\"-XX:CRaCRestoreFrom is mutually exclusive with -XX:CPUFeatures; specify -XX:CPUFeatures during -XX:CRaCCheckpointTo\");\n+    return false;\n@@ -2625,3 +2620,3 @@\n-  VM_Version::CpuidInfo cpuid_info = { 0, };\n-  get_cpu_info_stub(&cpuid_info);\n-  cpuid_info.assert_is_initialized();\n+  if (!data) {\n+    return false;\n+  }\n@@ -2629,5 +2624,2 @@\n-  uint64_t       new_cpu_features = 0;\n-  uint64_t new_cpu_glibc_features = 0;\n-  if (cpuid_info.extended_cpu_family() > 4) { \/\/ it supports CPUID\n-    new_cpu_features = cpuid_info.feature_flags();\n-    LINUX_ONLY(new_cpu_glibc_features = cpuid_info.glibc_flags();)\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"This snapshot's stored CPU features are: -XX:CPUFeatures=0x%\" PRIx64 \",0x%\" PRIx64, data->cpu, data->glibc);\n@@ -2636,2 +2628,5 @@\n-  uint64_t       features_missing =       _features & ~      new_cpu_features;\n-  uint64_t glibc_features_missing = _glibc_features & ~new_cpu_glibc_features;\n+  uint64_t   CPUFeatures_x64 = data->cpu;\n+  uint64_t GLIBCFeatures_x64 = data->glibc;\n+\n+  uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+  uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n@@ -2642,8 +2637,6 @@\n-  _crac_restore_missing_features = features_missing || glibc_features_missing;\n-  if (_crac_restore_missing_features) {\n-    static const char part1[] = \"You have to specify -XX:CPUFeatures=\";\n-    tty->print_raw(part1, sizeof(part1) - 1);\n-    nonlibc_tty_print_uint64_comma_uint64(new_cpu_features & _features, new_cpu_glibc_features & _glibc_features);\n-    static const char part2[] = \" together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features \";\n-    tty->print_raw(part2, sizeof(part2) - 1);\n-    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+  if (features_missing || glibc_features_missing) {\n+    tty->print(\n+      \"You have to specify -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X\n+      \" together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X,\n+      CPUFeatures_x64 & _features, GLIBCFeatures_x64 & _glibc_features,\n+      CPUFeatures_x64, GLIBCFeatures_x64);\n@@ -2651,0 +2644,3 @@\n+    if (!IgnoreCPUFeatures) {\n+      vm_exit_during_initialization();\n+    }\n@@ -2653,3 +2649,2 @@\n-  if (ShowCPUFeatures)\n-    print_using_features_cr();\n-}\n+        _features_saved =       _features;\n+  _glibc_features_saved = _glibc_features;\n@@ -2657,3 +2652,5 @@\n-void VM_Version::crac_restore_finalize() {\n-  if (_crac_restore_missing_features && !IgnoreCPUFeatures) {\n-    vm_exit_during_initialization();\n+        _features =   CPUFeatures_x64;\n+  _glibc_features = GLIBCFeatures_x64;\n+\n+  if (ShowCPUFeatures && !CRaCRestoreFrom) {\n+    print_using_features_cr();\n@@ -2661,0 +2658,8 @@\n+\n+#ifdef LINUX\n+  \/\/ glibc_not_using() has done setenv(TUNABLES_NAME) and it expects us to re-exec ourselves.\n+  \/\/ But we were only checking the cpufeatures file before restoring the process so we ignore the result.\n+  glibc_not_using();\n+#endif\n+\n+  return true;\n@@ -2720,0 +2725,1 @@\n+\n@@ -2721,1 +2727,2 @@\n-  uint64_t   CPUFeatures_x64 = CPUFeatures_parse(GLIBCFeatures_x64);\n+  uint64_t   CPUFeatures_x64 = CPUFeatures_parse(CPUFeatures, GLIBCFeatures_x64);\n+\n@@ -2729,6 +2736,5 @@\n-    static const char part1[] = \"Specified -XX:CPUFeatures=\";\n-    tty->print_raw(part1, sizeof(part1) - 1);\n-    nonlibc_tty_print_uint64_comma_uint64(CPUFeatures_x64, GLIBCFeatures_x64);\n-    static const char part2[] = \"; this machine's CPU features are \";\n-    tty->print_raw(part2, sizeof(part2) - 1);\n-    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    tty->print(\n+      \"Specified -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X\n+      \"; this machine's CPU features are \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X,\n+      CPUFeatures_x64, GLIBCFeatures_x64,\n+      _features, _glibc_features);\n@@ -2739,2 +2745,2 @@\n-  uint64_t       features_saved =       _features;\n-  uint64_t glibc_features_saved = _glibc_features;\n+        _features_saved =       _features;\n+  _glibc_features_saved = _glibc_features;\n@@ -2745,1 +2751,1 @@\n-  if (ShowCPUFeatures)\n+  if (ShowCPUFeatures && !CRaCRestoreFrom) {\n@@ -2747,0 +2753,1 @@\n+  }\n@@ -2749,10 +2756,2 @@\n-  if (!_ignore_glibc_not_using) {\n-    uint64_t       features_expected =   MAX_CPU - 1;\n-    uint64_t glibc_features_expected = MAX_GLIBC - 1;\n-    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n-            features_expected =       features_saved;\n-      glibc_features_expected = glibc_features_saved;\n-    }\n-    glibc_not_using(      features_expected & ~      _features,\n-                    glibc_features_expected & ~_glibc_features);\n-  }\n+  if (!glibc_not_using())\n+    glibc_reexec();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":128,"deletions":129,"binary":false,"changes":257,"status":"modified"},{"patch":"@@ -455,0 +455,2 @@\n+  static uint64_t _features_saved, _glibc_features_saved;\n+\n@@ -656,1 +658,1 @@\n-  static uint64_t CPUFeatures_parse(uint64_t &glibc_features);\n+  static uint64_t CPUFeatures_parse(const char *str, uint64_t &glibc_features);\n@@ -658,1 +660,1 @@\n-  static void glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC);\n+  static bool glibc_not_using();\n@@ -667,3 +669,0 @@\n-  static bool _crac_restore_missing_features;\n-  static void nonlibc_tty_print_uint64(uint64_t num);\n-  static void nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2);\n@@ -729,2 +728,7 @@\n-  static void crac_restore();\n-  static void crac_restore_finalize();\n+  struct CPUFeaturesBinary {\n+    uint64_t cpu, glibc;\n+  };\n+  static bool cpu_features_binary(CPUFeaturesBinary *data);\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data);\n+  static bool ignore_cpu_features() { return _ignore_glibc_not_using; }\n+  static void restore_check(const char* str, const char* msg_prefix);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,2 +35,4 @@\n-  static void crac_restore() {}\n-  static void crac_restore_finalize() {}\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -403,9 +403,0 @@\n-  \/\/ VM_Version::crac_restore()->VM_Version::get_processor_features_hardware()\n-  \/\/ executes cpuinfo without a started Java thread.\n-  if (info != nullptr && uc != nullptr && thread == nullptr && sig == SIGSEGV) {\n-    pc = (address) os::Posix::ucontext_get_pc(uc);\n-    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n-      stub = VM_Version::cpuinfo_cont_addr();\n-    }\n-  }\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -223,9 +223,0 @@\n-  \/\/ VM_Version::crac_restore()->VM_Version::get_processor_features_hardware()\n-  \/\/ executes cpuinfo without a started Java thread.\n-  if (info != nullptr && uc != nullptr && thread == nullptr && sig == SIGSEGV) {\n-    pc = (address) os::Posix::ucontext_get_pc(uc);\n-    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n-      stub = VM_Version::cpuinfo_cont_addr();\n-    }\n-  }\n-\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CRLIB_USER_DATA_H\n+#define CRLIB_USER_DATA_H\n+\n+#include \"crlib.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CRLIB_EXTENSION_USER_DATA_NAME \"user data\"\n+#define CRLIB_EXTENSION_USER_DATA(api) \\\n+  CRLIB_EXTENSION(api, crlib_user_data_t, CRLIB_EXTENSION_USER_DATA_NAME)\n+\n+typedef struct crlib_user_data_storage crlib_user_data_storage_t;\n+\n+\/\/ API for storing additional arbitrary data (user data) in checkpoint image.\n+struct crlib_user_data {\n+  crlib_extension_t header;\n+\n+  \/\/ Records data to be stored under the specified name in a checkpoint image. Returns true on\n+  \/\/ success.\n+  \/\/ 'name' must be a valid non-empty C-string; if 'size' is positive 'data' must reference 'size'\n+  \/\/ bytes of data, if 'size' is 0 any data previously recorded under this name is cleared.\n+  bool (*set_user_data)(crlib_conf_t *, const char *name, const void *data, size_t size);\n+\n+  \/\/ Prepares user data to be looked-up from a previously created and configured checkpoint image.\n+  \/\/ Returning a pointer to a managing structure or null on error.\n+  \/\/\n+  \/\/ The other methods of this API can be used to interact with the returned structure.\n+  \/\/\n+  \/\/ The caller should destroy the structure after they are done using it. This should be done\n+  \/\/ before destroying the engine configuration that was used to create it.\n+  crlib_user_data_storage_t *(*load_user_data)(crlib_conf_t *);\n+\n+  \/\/ Finds data with the specified name and writes a pointer to it to '*data_p' and the size of the\n+  \/\/ data to '*size_p'. Returns true on success.\n+  \/\/ 'user_data', 'data_p' and 'size_p' must not be null. 'name' must be a valid C-string.\n+  \/\/ Stored data should not be freed directly - destroy the managing structure instead.\n+  bool (*lookup_user_data)(crlib_user_data_storage_t *storage,\n+                           const char *name, const void **data_p, size_t *size_p);\n+\n+  \/\/ Destroys the managing structure.\n+  void (*destroy_user_data)(crlib_user_data_storage_t *storage);\n+};\n+typedef const struct crlib_user_data crlib_user_data_t;\n+\n+#ifdef __cplusplus\n+} \/\/ extern \"C\"\n+#endif\n+\n+#endif \/\/ CRLIB_USER_DATA_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib_user_data.h","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -311,10 +311,4 @@\n-      \/\/ Do not use any libc string functions. Our caller VM_Version::fatal_missing_features may have GNU_IFUNC-misconfigured glibc.\n-      if (buflen-- > 0)\n-        *buf++ = ',';\n-      if (buflen-- > 0)\n-        *buf++ = ' ';\n-      for (const char *src = features_names[features_names_index]; *src; ++src)\n-      if (buflen-- > 0)\n-        *buf++ = *src;\n-      assert(buflen > 0, \"not enough temporary space allocated\");\n-      *buf = 0;\n+      int res = jio_snprintf(buf, buflen, \", %s\", features_names[features_names_index]);\n+      assert(res > 0, \"not enough temporary space allocated\");\n+      buf += res;\n+      buflen -= res;\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -118,0 +118,17 @@\n+  switch (_engine->prepare_user_data_api()) {\n+    case CracEngine::ApiStatus::OK: {\n+      VM_Version::CPUFeaturesBinary data;\n+      if (!VM_Version::cpu_features_binary(&data)) {\n+        \/\/ This backend does not use CPUFeatures. That is OK.\n+      } else if (!_engine->cpufeatures_store(&data)) {\n+        return JVM_CHECKPOINT_ERROR;\n+      }\n+      } break;\n+    case CracEngine::ApiStatus::ERR:\n+      return JVM_CHECKPOINT_ERROR;\n+    case CracEngine::ApiStatus::UNSUPPORTED:\n+      log_warning(crac)(\"Cannot store CPUFeatures for checkpoint \"\n+        \"with the selected CRaC engine\");\n+      break;\n+  }\n+\n@@ -263,2 +280,0 @@\n-  \/\/ It needs to check CPU features before any other code (such as VM_Crac::read_shm) depends on them.\n-  VM_Version::crac_restore();\n@@ -283,3 +298,0 @@\n-  \/\/ VM_Crac::read_shm needs to be already called to read RESTORE_SETTABLE parameters.\n-  VM_Version::crac_restore_finalize();\n-\n@@ -511,0 +523,22 @@\n+  if (!VM_Version::ignore_cpu_features()) {\n+    switch (engine.prepare_user_data_api()) {\n+      case CracEngine::ApiStatus::OK: {\n+        VM_Version::CPUFeaturesBinary data;\n+        bool present;\n+        if (!engine.cpufeatures_load(&data, &present)) {\n+          return;\n+        }\n+        if (!VM_Version::cpu_features_binary_check(present ? &data : nullptr)) {\n+          log_error(crac)(\"Image %s has incompatible CPU features in its user data\", CRaCRestoreFrom);\n+          return;\n+        }\n+        } break;\n+      case CracEngine::ApiStatus::ERR:\n+        return;\n+      case CracEngine::ApiStatus::UNSUPPORTED:\n+        log_warning(crac)(\"Cannot verify CPUFeatures for restore \"\n+          \"with the selected CRaC engine\");\n+        break;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":39,"deletions":5,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"crlib\/crlib_user_data.h\"\n@@ -412,0 +413,63 @@\n+\n+static constexpr char cpufeatures_userdata_name[] = \"cpufeatures\";\n+\n+CracEngine::ApiStatus CracEngine::prepare_user_data_api() {\n+  precond(is_initialized());\n+  if (_user_data_api != nullptr) {\n+    return ApiStatus::OK;\n+  }\n+\n+  crlib_user_data_t * const user_data_api = CRLIB_EXTENSION_USER_DATA(_api);\n+  if (user_data_api == nullptr) {\n+    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_USER_DATA_NAME);\n+    return ApiStatus::UNSUPPORTED;\n+  }\n+  if (user_data_api->set_user_data == nullptr || user_data_api->load_user_data == nullptr\n+      || user_data_api->lookup_user_data == nullptr || user_data_api->destroy_user_data == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid API for extension: \" CRLIB_EXTENSION_USER_DATA_NAME);\n+    return ApiStatus::ERR;\n+  }\n+  _user_data_api = user_data_api;\n+  return ApiStatus::OK;\n+}\n+\n+\/\/ Return success.\n+bool CracEngine::cpufeatures_store(const VM_Version::CPUFeaturesBinary *datap) const {\n+  log_debug(crac)(\"cpufeatures_store user data %s to %s...\", cpufeatures_userdata_name, CRaCRestoreFrom);\n+  return _user_data_api->set_user_data(_conf, cpufeatures_userdata_name, datap, sizeof(*datap));\n+}\n+\n+\/\/ Return success.\n+bool CracEngine::cpufeatures_load(VM_Version::CPUFeaturesBinary *datap, bool *presentp) const {\n+  static const char s3method[] = \"s3:\/\/\";\n+  if (strncasecmp(CRaCRestoreFrom, s3method, sizeof(s3method) - 1) == 0) {\n+    \/\/ s3->set_image_bitmask did handle it already, load_user_data() is too expensive for S3.\n+    return true;\n+  }\n+  log_debug(crac)(\"cpufeatures_load user data %s from %s...\", cpufeatures_userdata_name, CRaCRestoreFrom);\n+  crlib_user_data_storage_t *user_data;\n+  if (!(user_data = _user_data_api->load_user_data(_conf))) {\n+    log_error(crac)(\"CRaC engine failed to load user data %s\", cpufeatures_userdata_name);\n+    return false;\n+  }\n+  const VM_Version::CPUFeaturesBinary *cdatap;\n+  size_t size;\n+  if (_user_data_api->lookup_user_data(user_data, cpufeatures_userdata_name, (const void **) &cdatap, &size)) {\n+    if (size != sizeof(VM_Version::CPUFeaturesBinary)) {\n+      _user_data_api->destroy_user_data(user_data);\n+      log_error(crac)(\"User data %s in %s has unexpected size %zu (expected %zu)\", cpufeatures_userdata_name, CRaCRestoreFrom, size, sizeof(VM_Version::CPUFeaturesBinary));\n+      return false;\n+    }\n+    if (cdatap == nullptr) {\n+      _user_data_api->destroy_user_data(user_data);\n+      log_error(crac)(\"lookup_user_data %s should return non-null data pointer\", cpufeatures_userdata_name);\n+      return false;\n+    }\n+    *datap = *cdatap;\n+    *presentp = true;\n+  } else {\n+    *presentp = false;\n+  }\n+  _user_data_api->destroy_user_data(user_data);\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"crlib\/crlib_user_data.h\"\n@@ -32,0 +33,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -68,0 +70,4 @@\n+  ApiStatus prepare_user_data_api();\n+  bool cpufeatures_store(const VM_Version::CPUFeaturesBinary *datap) const;\n+  bool cpufeatures_load(VM_Version::CPUFeaturesBinary *datap, bool *presentp) const;\n+\n@@ -75,0 +81,1 @@\n+  crlib_user_data_t *_user_data_api = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-static jint check_for_restore(JavaVMInitArgs* args, crac::crac_restore_data& restore_data) {\n+static jint check_for_restore(JavaVMInitArgs* args) {\n@@ -434,6 +434,0 @@\n-    crac::restore(restore_data);\n-    if (!CRaCIgnoreRestoreIfUnavailable) {\n-      \/\/ FIXME switch to unified hotspot logging\n-      warning(\"cannot restore\");\n-      return JNI_ERR;\n-    }\n@@ -485,3 +479,1 @@\n-  \/\/ Output stream module should be already initialized for error reporting during restore.\n-  \/\/ JDK version should also be intialized for arguments parsing.\n-  if (check_for_restore(args, restore_data) != JNI_OK) return JNI_ERR;\n+  if (check_for_restore(args) != JNI_OK) return JNI_ERR;\n@@ -611,0 +603,11 @@\n+  \/\/ Output stream module should be already initialized for error reporting during restore.\n+  \/\/ JDK version should also be intialized. There is lot of initializations needed to read\n+  \/\/ the current machine's CPUFeatures.\n+  if (CRaCRestoreFrom) {\n+    crac::restore(restore_data);\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      log_error(crac)(\"Failed to restore %s\", CRaCRestoreFrom);\n+      return JNI_ERR;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1834,6 +1834,5 @@\n-`-XX:CPUFeatures=`*0xnumber*\n-:   CPU feature set, use `-XX:CPUFeatures=`*0xnumber* with `-XX:CRaCCheckpointTo` when\n-    you get an error during `-XX:CRaCRestoreFrom` on a different machine.\n-    `-XX:CPUFeatures=native` is the default.\n-    `-XX:CPUFeatures=generic` is compatible with any CPU but not as slow\n-    as `-XX:CPUFeatures=0`.\n+`-XX:CPUFeatures=`*0xnumber,0xnumber*\n+:   CPU feature set, use `-XX:CPUFeatures=`*0xnumber,0xnumber* with\n+    `-XX:CRaCCheckpointTo` when you get an error during `-XX:CRaCRestoreFrom`\n+    on a different machine. `-XX:CPUFeatures=native` is the default.\n+    `-XX:CPUFeatures=generic` is compatible with any CPU.\n@@ -1845,0 +1844,5 @@\n+`-XX:+IgnoreCPUFeatures`\n+:   Skip any verifications of `-XX:CPUFeatures`. It may lead to a crash\n+    if `-XX:CRaCRestoreFrom` is used on a CPU with less features than the CPU\n+    where `-XX:CRaCCheckpointTo` was made.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <cerrno>\n@@ -36,0 +37,1 @@\n+#include \"crlib\/crlib_user_data.h\"\n@@ -45,0 +47,4 @@\n+#ifndef PATH_MAX\n+# define PATH_MAX 1024\n+#endif\n+\n@@ -66,0 +72,5 @@\n+static bool set_user_data(crlib_conf_t *conf, const char *name, const void *data, size_t size);\n+static crlib_user_data_storage_t *load_user_data(crlib_conf_t *conf);\n+static bool lookup_user_data(crlib_user_data_storage_t *user_data, const char *name, const void **data_p, size_t *size_p);\n+static void destroy_user_data(crlib_user_data_storage_t *user_data);\n+\n@@ -99,0 +110,11 @@\n+static crlib_user_data_t user_data_extension = {\n+  {\n+    CRLIB_EXTENSION_USER_DATA_NAME,\n+    sizeof(user_data_extension)\n+  },\n+  set_user_data,\n+  load_user_data,\n+  lookup_user_data,\n+  destroy_user_data,\n+};\n+\n@@ -102,0 +124,1 @@\n+  &user_data_extension.header,\n@@ -525,0 +548,159 @@\n+static bool set_user_data(crlib_conf_t *conf, const char *name, const void *data, size_t size) {\n+  if (!conf->argv()[ARGV_IMAGE_LOCATION]) {\n+    fprintf(stderr, CREXEC \"configure_image_location has not been called\\n\");\n+    return false;\n+  }\n+  char fname[PATH_MAX];\n+  if (snprintf(fname, sizeof(fname), \"%s\/%s\", conf->argv()[ARGV_IMAGE_LOCATION], name) >= (int) sizeof(fname) - 1) {\n+    fprintf(stderr, CREXEC \"filename too long: %s\/%s\\n\", conf->argv()[ARGV_IMAGE_LOCATION], name);\n+    return false;\n+  }\n+  FILE *f = fopen(fname, \"w\");\n+  if (f == NULL) {\n+    fprintf(stderr, CREXEC \"cannot create %s: %s\\n\", fname, strerror(errno));\n+    return false;\n+  }\n+  while (size--) {\n+    uint8_t byte = *(const uint8_t *) data;\n+    data = (const void *) ((uintptr_t) data + 1);\n+    if (fprintf(f, \"%02x\", byte) != 2) {\n+      fclose(f);\n+      fprintf(stderr, CREXEC \"cannot write to %s: %s\\n\", fname, strerror(errno));\n+      return false;\n+    }\n+  }\n+  if (fputc('\\n', f) != '\\n') {\n+    fclose(f);\n+    fprintf(stderr, CREXEC \"cannot write to %s: %s\\n\", fname, strerror(errno));\n+    return false;\n+  }\n+  if (fclose(f)) {\n+    fprintf(stderr, CREXEC \"cannot write to %s: %s\\n\", fname, strerror(errno));\n+    return false;\n+  }\n+  return true;\n+}\n+\n+struct user_data_chunk {\n+  struct user_data_chunk *next;\n+  size_t size;\n+  uint8_t *data;\n+};\n+\n+struct crlib_user_data_storage {\n+  crlib_conf_t *conf;\n+  struct user_data_chunk *chunk;\n+};\n+\n+static crlib_user_data_storage_t *load_user_data(crlib_conf_t *conf) {\n+  crlib_user_data_storage_t *user_data = static_cast<crlib_user_data_storage_t *>(malloc(sizeof(*user_data)));\n+  if (user_data == NULL) {\n+    fprintf(stderr, CREXEC \"cannot allocate memory\\n\");\n+    return NULL;\n+  }\n+  user_data->conf = conf;\n+  user_data->chunk = NULL;\n+  return user_data;\n+}\n+\n+static bool lookup_user_data(crlib_user_data_storage_t *user_data, const char *name, const void **data_p, size_t *size_p) {\n+  const crlib_conf_t *conf = user_data->conf;\n+  if (!conf->argv()[ARGV_IMAGE_LOCATION]) {\n+    fprintf(stderr, CREXEC \"configure_image_location has not been called\\n\");\n+    return false;\n+  }\n+  char fname[PATH_MAX];\n+  if (snprintf(fname, sizeof(fname), \"%s\/%s\", conf->argv()[ARGV_IMAGE_LOCATION], name) >= (int) sizeof(fname) - 1) {\n+    fprintf(stderr, CREXEC \"filename is too long: %s\/%s\\n\", conf->argv()[ARGV_IMAGE_LOCATION], name);\n+    return false;\n+  }\n+  FILE *f = fopen(fname, \"r\");\n+  if (f == NULL) {\n+    if (errno != ENOENT) {\n+      fprintf(stderr, CREXEC \"cannot open %s: %s\\n\", fname, strerror(errno));\n+    }\n+    return false;\n+  }\n+  uint8_t *data = NULL;\n+  size_t data_used = 0;\n+  size_t data_allocated = 0;\n+  int nibble = -1;\n+  for (;;) {\n+    int gotc = fgetc(f);\n+    if (gotc == EOF) {\n+      fclose(f);\n+      free(data);\n+      fprintf(stderr, CREXEC \"unexpected EOF or error in %s after %zu parsed bytes\\n\", fname, data_used);\n+      return false;\n+    }\n+    if (gotc == '\\n' && nibble == -1) {\n+      break;\n+    }\n+    if (gotc >= '0' && gotc <= '9') {\n+      gotc += -'0';\n+    } else if (gotc >= 'a' && gotc <= 'f') {\n+      gotc += -'a' + 0xa;\n+    } else {\n+      fclose(f);\n+      free(data);\n+      fprintf(stderr, CREXEC \"unexpected character 0x%02x in %s after %zu parsed bytes\\n\", gotc, fname, data_used);\n+      return false;\n+    }\n+    if (nibble == -1) {\n+      nibble = gotc;\n+      continue;\n+    }\n+    if (data_used == data_allocated) {\n+      data_allocated *= 2;\n+      if (!data_allocated) {\n+        data_allocated = 0x100;\n+      }\n+      uint8_t *data_new = static_cast<uint8_t *>(realloc(data, data_allocated));\n+      if (data_new == NULL) {\n+        fclose(f);\n+        free(data);\n+        fprintf(stderr, CREXEC \"cannot allocate memory for %s after %zu parsed bytes\\n\", fname, data_used);\n+        return false;\n+      }\n+      data = data_new;\n+    }\n+    assert(data_used < data_allocated);\n+    data[data_used++] = (nibble << 4) | gotc;\n+    nibble = -1;\n+  }\n+  if (fgetc(f) != EOF || !feof(f) || ferror(f)) {\n+    fclose(f);\n+    free(data);\n+    fprintf(stderr, CREXEC \"EOF expected after newline in %s after %zu parsed bytes\\n\", fname, data_used);\n+    return false;\n+  }\n+  if (fclose(f)) {\n+    free(data);\n+    fprintf(stderr, CREXEC \"error closing %s after %zu parsed bytes\\n\", fname, data_used);\n+    return false;\n+  }\n+  *data_p = data;\n+  *size_p = data_used;\n+  struct user_data_chunk *chunk = static_cast<struct user_data_chunk *>(malloc(sizeof(*chunk)));\n+  if (chunk == NULL) {\n+    free(data);\n+    fprintf(stderr, CREXEC \"cannot allocate memory\\n\");\n+    return false;\n+  }\n+  chunk->next = user_data->chunk;\n+  user_data->chunk = chunk;\n+  chunk->size = data_used;\n+  chunk->data = data;\n+  return true;\n+}\n+\n+static void destroy_user_data(crlib_user_data_storage_t *user_data) {\n+  while (user_data->chunk) {\n+    struct user_data_chunk *chunk = user_data->chunk;\n+    user_data->chunk = chunk->next;\n+    free(chunk->data);\n+    free(chunk);\n+  }\n+  free(user_data);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.cpp","additions":182,"deletions":0,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class CPUFeatures {\n+  public static void main(String[] args) {\n+    for (int i = 0;; ++i) {\n+      System.out.println(\"CPUFeaturesCheck \" + i);\n+      try {\n+        Thread.sleep(1000);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+  }\n+}\n","filename":"test\/jdk\/jdk\/crac\/CPUFeatures\/CPUFeatures.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,369 @@\n+#! \/bin\/bash\n+# Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+# @test\n+# @compile CPUFeatures.java\n+# @comment It will be always skipped unless you use jtreg option \"-manual\" which conflicts with JDK's default option \"-automatic\".\n+# @comment Therefore either change it in make\/RunTests.gmk or run jtreg by hand.\n+# @run shell\/manual CPUFeatures.sh\n+\n+set -ex -o pipefail\n+exec >&2\n+\n+JAVA_HOME=$TESTJAVA\n+javafiles=\"{bin\/{java,jcmd},lib\/{jvm.cfg,lib{crexec,java,jimage,jli,jsvml,net,nio,attach,zip}.so,modules,tzdb.dat,server\/{classes.jsa,libjvm.so},criuengine,criu,libwarp.so},conf\/security\/java.security}\"\n+qemuimgurl=https:\/\/download.fedoraproject.org\/pub\/fedora\/linux\/releases\/41\/Cloud\/x86_64\/images\/Fedora-Cloud-Base-Generic-41-1.4.x86_64.qcow2\n+qemuimgsumurl=https:\/\/download.fedoraproject.org\/pub\/fedora\/linux\/releases\/41\/Cloud\/x86_64\/images\/Fedora-Cloud-41-1.4-x86_64-CHECKSUM\n+# FIXME: warp+criu need an update for new kernels:\n+#qemuimgurl=https:\/\/download.fedoraproject.org\/pub\/fedora\/linux\/releases\/42\/Cloud\/x86_64\/images\/Fedora-Cloud-Base-Generic-42-1.1.x86_64.qcow2\n+#qemuimgsumurl=https:\/\/download.fedoraproject.org\/pub\/fedora\/linux\/releases\/42\/Cloud\/x86_64\/images\/Fedora-Cloud-42-1.1-x86_64-CHECKSUM\n+qemuimgdir=\/tmp\n+qemuimgfile=$qemuimgdir\/$(basename $qemuimgurl)\n+qemuimgsumfile=$qemuimgdir\/$(basename $qemuimgsumurl)\n+# SHA256 (Fedora-Cloud-Base-Generic.x86_64-40-1.14.qcow2) = ac58f3c35b73272d5986fa6d3bc44fd246b45df4c334e99a07b3bbd00684adee\n+qemuimgsumgrep=\"^SHA256 ($(basename $qemuimgurl)) = \"\n+if ! grep \"$qemuimgsumgrep\" $qemuimgsumfile;then\n+  flock $qemuimgsumfile.lock -c \"wget -O $qemuimgsumfile $qemuimgsumurl\"\n+  if ! grep \"$qemuimgsumgrep\" $qemuimgsumfile;then\n+    echo >&2 \"Failed to download: $qemuimgsumurl\"\n+    exit 1\n+  fi\n+fi\n+function checksum\n+{\n+  (cd $qemuimgdir\n+    grep \"^[^#].*$(basename $qemuimgfile)\" $qemuimgsumfile|sha256sum -c -|grep \"^$(basename $qemuimgurl): OK$\"\n+  )\n+}\n+if ! checksum;then\n+  flock $qemuimgfile.lock -c \"wget -O $qemuimgfile $qemuimgurl\"\n+  if ! checksum;then\n+    echo >&2 \"Failed to download: $qemuimgurl\"\n+    exit 1\n+  fi\n+fi\n+tmpdir=\/tmp\/CPUFeatures.$$\n+rm -rf $tmpdir\n+mkdir $tmpdir\n+qemuimg=$tmpdir\/CPUFeatures.qcow2\n+sshkey=$qemuimg.key\n+mountdir=$qemuimg.d\n+\n+test ! -e $mountdir\n+test ! -e $qemuimg\n+test ! -e $sshkey\n+test ! -e $sshkey.pub\n+ssh-keygen -f $sshkey -N \"\"\n+test -f $sshkey\n+test -f $sshkey.pub\n+qemu-img create -b $qemuimgfile -F qcow2 -f qcow2 $qemuimg\n+test -f $qemuimg\n+mkdir $mountdir\n+LIBGUESTFS_BACKEND=direct guestmount -a $qemuimg -i $mountdir\n+sed -i -e 's\/^options \/&selinux=0 \/' $mountdir\/boot\/loader\/entries\/*.conf\n+sed -i -e 's\/^root:x:\/root::\/' $mountdir\/etc\/passwd\n+cat $sshkey.pub >>$mountdir\/root\/.ssh\/authorized_keys\n+rm -f $mountdir\/usr\/lib\/systemd\/zram-generator.conf\n+echo kernel.core_pattern=core >>$mountdir\/etc\/sysctl.d\/CPUFeatures.conf\n+guestunmount $mountdir\n+rmdir $mountdir\n+\n+# -nographic may not be suitable for every OS\/image\n+for try in $(seq 1 10);do\n+  sshport=$[$RANDOM+1024]\n+  sshporthex=$(printf %04X $sshport)\n+  if ! grep -q \"^..............:$sshporthex 00000000:0000 0A \" \/proc\/net\/tcp \\\n+  && ! grep -q \"^....: 00000000000000000000000000000000:$sshporthex 00000000000000000000000000000000:0000 0A \" \/proc\/net\/tcp6 \\\n+  ;then\n+    break\n+  fi\n+  unset sshport\n+done\n+test -n \"$sshport\"\n+\n+qemuimg2=$tmpdir\/CPUFeatures-run.qcow2\n+qemuargs=\"-m 4096 -net nic -net user,hostfwd=tcp::$sshport-:22 -drive format=qcow2,media=disk,cache=unsafe,file=$qemuimg2 -nographic\"\n+\n+function runssh {\n+  ssh -i $sshkey -p $sshport -o \"UserKnownHostsFile \/dev\/null\" -o \"StrictHostKeyChecking no\" -o \"ConnectTimeout $[10*$timeoutmultiply]\" root@127.0.0.1 \"$@\"\n+}\n+# Do not use \/tmp as that may not survive a reboot on some Linux distributions.\n+qemudir=\"\/root\/CPUFeatures\"\n+# in reality it is about 20\n+qemustarttimeout=120\n+for file in $(eval echo $JAVA_HOME\/$javafiles);do\n+  test -e $file\n+done\n+rm -f $qemuimg2\n+\n+missingfiles=true\n+function qemucopyfiles {\n+  missingfiles=false\n+  (cd $JAVA_HOME;tar chf - $(eval echo $javafiles))|runssh \"set -ex;mkdir $qemudir;cd $qemudir;tar xf -;JAVA_HOME=\\$PWD bin\/java -XX:+ShowCPUFeatures --version\"\n+  (cd $TESTCLASSES;tar cf - CPUFeatures.class)|runssh \"set -ex;cd $qemudir;tar xf -\"\n+}\n+qemustarted=\"\"\n+function qemustart {\n+  type=$1\n+  cpu=$2\n+  accel=\"\"\n+  case $type in\n+    kvm)\n+      timeoutmultiply=1\n+      accel=\"-accel kvm\"\n+      ;;\n+    system-x86_64)\n+      timeoutmultiply=6\n+      ;;\n+    *)\n+      fatal \"internal error: unknown type: $1\"\n+      ;;\n+  esac\n+  qemustarted_check=\"$type $cpu\"\n+  if [ \"$qemustarted\" != \"$qemustarted_check\" ];then\n+    if [ ! -e $qemuimg2 ];then\n+      qemuimg2rebuild\n+    fi\n+    qemustop\n+    qemu-system-x86_64 $accel $qemuargs -cpu $cpu <\/dev\/null & qemupid=$!\n+    # If SSH times out it may be a 32-bit arch but still qemu is already running.\n+    qemustarted=\"$qemustarted_check\"\n+    t0=$(date +%s)\n+    while true;do\n+      if [ $[$(date +%s)-$t0] -ge $[$qemustarttimeout*$timeoutmultiply] ];then\n+\techo >&2 \"qemu timeout, qemu PID=$qemupid\"\n+\treturn 1\n+      fi\n+      runssh true && break\n+      sleep 1\n+    done\n+  fi\n+  if $missingfiles;then\n+    qemucopyfiles\n+  fi\n+}\n+function qemustop {\n+  if [ -z \"$qemustarted\" ];then\n+    return\n+  fi\n+  runssh poweroff || kill $qemupid || :\n+  wait || :\n+  qemustarted=\"\"\n+}\n+function qemuimg2rebuild {\n+  qemustop\n+  qemu-img create -b $qemuimg -F qcow2 -f qcow2 $qemuimg2\n+  test -e $qemuimg2\n+  # FIXME: why?\n+  # qemu-kvm: -drive format=qcow2,media=disk,cache=unsafe,file=\/tmp\/CPUFeatures.3035545\/CPUFeatures-run.qcow2: Could not open backing file: Failed to get shared \"write\" lock\n+  # Is another process using the image [\/tmp\/CPUFeatures.3035545\/CPUFeatures.qcow2]?\n+  sleep 1\n+  missingfiles=true\n+}\n+javasetup=\"cd $qemudir;export JAVA_HOME=\\$PWD;ulimit -c unlimited\"\n+function checkpoint {\n+  checkpoint_args=\"$1\"\n+  runssh \"$javasetup;rm -rf cr || exit 1; \\\n+    $(: 'Prevent on CRIU: Error (criu\/pie\/restorer.c:2057): Unable to create a thread: -17') \\\n+    for i in \\$(seq 1 1000);do \/bin\/true;done; \\\n+    bin\/java $warp -XX:CRaCCheckpointTo=cr -XX:+ShowCPUFeatures $checkpoint_args CPUFeatures&p=\\$!;sleep $[3*$timeoutmultiply];bin\/jcmd CPUFeatures JDK.checkpoint; \\\n+    wait \\$p;true\"\n+}\n+function restore {\n+  restore_args=\"$1\"\n+  restore=\"$(runssh \"$javasetup;bin\/java $warp -XX:CRaCRestoreFrom=cr $restore_args&p=\\$!;(sleep $[6*$timeoutmultiply];kill \\$p)&wait \\$p;echo RC=\\$?\" 2>&1|tee \/proc\/self\/fd\/2)\"\n+}\n+failfile=$tmpdir\/failfile\n+rm -f $failfile\n+function checkpoint_restore_one {\n+  kind_checkpoint=\"$1\"\n+  kind_restore=\"$2\"\n+  check=\"${3:-CPUFeaturesCheck }\"\n+  checkpoint_args=\"$4\"\n+  restore_args=\"$5\"\n+  qemuimg2rebuild\n+  qemustart $kind_checkpoint\n+  checkpoint \"$checkpoint_args\"\n+  qemustart $kind_restore\n+  restore \"$restore_args\"\n+  if [ \"$check\" != - ];then\n+    (set +e;echo $restore|grep \"$check\";checkpoint_restore_result)\n+  fi\n+}\n+# FIXME: Make both snapshots first and both restores second to better reuse the VMs.\n+function checkpoint_restore {\n+  checkpoint_restore=\"criu: $*\"\n+  warp=\"\"\n+  checkpoint_restore_one \"$@\"\n+  if ! echo \"$*\"|grep -q \"x86: FPU xsave area present, but host cpu doesn't support it\";then\n+    checkpoint_restore=\"warp: $*\"\n+    warp=\"-XX:CRaCEngine=warp\"\n+    checkpoint_restore_one \"$@\"\n+  fi\n+}\n+# SIGTERM+128; see 'kill \\$p' above\n+expectRC=143\n+function checkpoint_restore_result {\n+  rc=$?\n+  if ! echo $restore|grep RC=$expectRC;then\n+    rc=99\n+  fi\n+  set +x\n+  echo\n+  if [ $rc -eq 0 ];then\n+    echo -n \"PASS\";\n+  else\n+    echo -n \"FAIL\"\n+    touch $failfile\n+  fi\n+  echo \": $checkpoint_restore\"\n+  set -x\n+}\n+function get_features {\n+  runssh \"set -ex;cd $qemudir;JAVA_HOME=\\$PWD bin\/java -XX:+ShowCPUFeatures --version\"|sed -n 's\/^This machine.s CPU features are: -XX:CPUFeatures=\/\/p'\n+}\n+exitcode=0\n+shutdown_done=false\n+function shutdown {\n+  if $shutdown_done;then return;fi\n+  shutdown_done=true\n+  qemustop\n+  rm -f $qemuimg2 # CPUFeatures.class\n+  rm -f $qemuimg $sshkey $sshkey.pub\n+  if [ -e $failfile ];then exitcode=1;fi\n+  rm -f $failfile\n+  rmdir $tmpdir\n+}\n+trap shutdown EXIT\n+function fatal {\n+  shutdown\n+  echo >&2 \"$*\"\n+  exit 1\n+}\n+\n+if [ -z \"$*\" ];then\n+\n+# Verify reproducibility of: https:\/\/jira.azulsystems.com\/browse\/ZULU-53749\n+qemuimg2rebuild\n+qemustart kvm host\n+if ! get_features|perl -lne '\n+  $a=0x4ff7fff9dfcfbf7;\n+  $b=0x1e6;\n+  \/^(.*),(.*)$\/ or die;\n+  die sprintf \"FA\".\"IL: 0x%x required vs. 0x%x found. 0x%x required vs. 0x%x found.\\n\",$a,eval $1,$b,eval $2 if $a&~eval $1||$b&~eval $2;\n+  print \"PA\".\"SS: Initial CPU check\"\n+';then\n+  # One could verify whether lower CPU isn't sufficient. E5-2630v3 is too old, it does not reproduce ZULU-53749.\n+  fatal \"FA$(: )IL: CPU i7-1165G7 or higher required\"\n+fi\n+\n+# Opteron_G1 is the most basic CPU (x86_64)\n+# SandyBridge is the first CPU with OSXSAVE+XSAVE (0x0,0x24)\n+expectRC_save=$expectRC\n+expectRC=1\n+checkpoint_restore \"kvm           SandyBridge\" \"kvm           Opteron_G1\" \"x86: FPU xsave area present, but host cpu doesn't support it\" \"\" \"-XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures\"\n+expectRC=$expectRC_save\n+checkpoint_restore \"kvm           Opteron_G1\"  \"kvm           Opteron_G1\"\n+checkpoint_restore \"kvm           Opteron_G1\"  \"kvm           host\"\n+checkpoint_restore \"kvm           host\"        \"kvm           host\"\n+# \"kvm max\" works only as \"kvm host\"\n+# \"system-x86_64 host\" is unsupported by qemu\n+# These may be too slow to run and they do not test much.\n+#checkpoint_restore \"system-x86_64 SandyBridge\" \"system-x86_64 SandyBridge\"\n+#checkpoint_restore \"system-x86_64 max\"         \"system-x86_64 max\"\n+\n+# IvyBridge is the first superset of SandyBridge\n+expectRC_save=$expectRC\n+expectRC=1\n+checkpoint_restore \"kvm           IvyBridge\"   \"kvm           SandyBridge\" -\n+(set +e;  echo \"$restore\"|grep \"You have to specify\" && ! echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n+expectRC=$expectRC_save\n+\n+checkpoint_restore \"kvm           IvyBridge\"   \"kvm           SandyBridge\" - \"-XX:CPUFeatures=0x142100054bbd7,0xe4\"\n+(set +e;! echo \"$restore\"|grep \"You have to specify\" &&   echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n+\n+# This does not crash the guest despite it could.\n+checkpoint_restore \"kvm           IvyBridge\"   \"kvm           SandyBridge\" - \"\" \"-XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures\"\n+(set +e;  echo \"$restore\"|grep \"You have to specify\" &&   echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n+\n+# IgnoreCPUFeatures is not inherited from snapshot to restore.\n+expectRC_save=$expectRC\n+expectRC=1\n+checkpoint_restore \"kvm           IvyBridge\"   \"kvm           SandyBridge\" - \"-XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures\" \"\"\n+(set +e;  echo \"$restore\"|grep \"You have to specify\" && ! echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n+expectRC=$expectRC_save\n+\n+checkpoint_restore \"kvm           IvyBridge\"   \"kvm           SandyBridge\" - \"-XX:+UnlockExperimentalVMOptions -XX:-IgnoreCPUFeatures\" \\\n+                                                                             \"-XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures\"\n+(set +e;  echo \"$restore\"|grep \"You have to specify\" &&   echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n+checkpoint_restore \"kvm           IvyBridge\"   \"kvm           SandyBridge\" - \"-XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures\" \\\n+                                                                             \"-XX:+UnlockExperimentalVMOptions -XX:-IgnoreCPUFeatures\"\n+expectRC=1\n+(set +e;  echo \"$restore\"|grep \"You have to specify\" && ! echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n+expectRC=$expectRC_save\n+\n+# FAIL: https:\/\/jira.azulsystems.com\/browse\/ZULU-53749\n+# reproducible on i7-1165G7, not reproducible on E5-2630v3\n+checkpoint_restore \"kvm host\"                  \"kvm           SandyBridge\" - # verified, fastest\n+#checkpoint_restore \"kvm host\"                  \"system-x86_64 SandyBridge\" - # verified, slower\n+#checkpoint_restore \"system-x86_64 max\"         \"kvm           SandyBridge\" - # it does not work\n+# The crash was RC=139\n+expectRC=1\n+(set +e;echo \"$restore\"|grep \"You have to specify\" && ! echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n+expectRC=$expectRC_save\n+\n+checkpoint_restore \"kvm host\"                  \"kvm           SandyBridge\" - \"\" \"-XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures\"\n+expectRC=139\n+(set +e;echo \"$restore\"|grep \"You have to specify\" && ! echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n+expectRC=$expectRC_save\n+\n+checkpoint_restore \"kvm IvyBridge\"             \"kvm           IvyBridge\"   \"\" \"-XX:CPUFeatures=native\"\n+checkpoint_restore \"kvm IvyBridge\"             \"kvm           IvyBridge\"   \"\" \"-XX:CPUFeatures=ignore\"\n+checkpoint_restore \"kvm IvyBridge\"             \"kvm           SandyBridge\" \"\" \"-XX:CPUFeatures=generic\"\n+\n+if false;then # too slow, failing\n+checkpoint_restore \"system-x86_64 max\"         \"kvm           SandyBridge\" \"\" \"-XX:CPUFeatures=0x142100054bbd7,0xe4\"\n+checkpoint_restore \"system-x86_64 max\"         \"system-x86_64 SandyBridge\" \"\" \"-XX:CPUFeatures=0x4200000081d7,0x0\"\n+fi\n+\n+elif [ $# -eq 2 -a \"$1\" = \"--cpu-list\" ];then\n+  list=\"\"\n+  for cpu in $(qemu-$2 -cpu help|sed -n 's\/^x86 \\([^ ]*\\) .*\/\\1\/p');do\n+    qemustart $2 $cpu && list=\"$list$(echo \"$(get_features) $cpu\")\n+\" || kill $qemupid || :\n+    qemustop\n+  done\n+  set +x\n+  echo\n+  echo -n \"$list\"|perl -lne '\/^(\\S+),(\\S+)( \\S+)$\/ or die;$x{sprintf \"0x%016x,0x%03x\",eval $1,eval $2,$3}.=$3;END{print $_.$x{$_} for sort keys %x}'\n+  echo\n+else\n+  set +x\n+  echo\n+  echo >&2 \"$0: [--cpu-list {kvm|system-x86_64}]\"\n+  echo\n+fi\n+set -x\n+\n+shutdown\n+echo done, exitcode=$exitcode\n+exit $exitcode\n","filename":"test\/jdk\/jdk\/crac\/CPUFeatures\/CPUFeatures.sh","additions":369,"deletions":0,"binary":false,"changes":369,"status":"added"},{"patch":"@@ -2,0 +2,21 @@\n+# Copyright (c) 2023, 2025, Azul Systems, Inc. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n@@ -11,1 +32,0 @@\n-\n@@ -13,0 +33,5 @@\n+\n+unset GLIBC_TUNABLES\n+$JAVA_HOME\/bin\/java -XX:CPUFeatures=generic -XX:+ShowCPUFeatures -version 2>&1 | tee \/proc\/self\/fd\/2 | grep -q 'openjdk version'\n+\n+# The test from summary:\n@@ -16,0 +41,8 @@\n+for GLIBC_TUNABLES in \\\n+                       glibc.cpu.hwcaps=-AVX                      \\\n+  glibc.pthread.rseq=0:glibc.cpu.hwcaps=-AVX                      \\\n+                       glibc.cpu.hwcaps=-AVX:glibc.pthread.rseq=0 \\\n+  ; do\n+  $JAVA_HOME\/bin\/java -XX:CPUFeatures=generic -XX:+ShowCPUFeatures -version 2>&1 | tee \/proc\/self\/fd\/2 | grep -q 'openjdk version'\n+done\n+\n","filename":"test\/jdk\/jdk\/crac\/CPUFeatures\/SimpleCPUFeatures.sh","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -79,1 +79,7 @@\n-            assertFalse(Files.exists(logPathR));\n+            if (scenario1) {\n+                \/\/ As the CRaC restore is started later during JDK initialization the LogFile got already created.\n+                assertTrue(Files.exists(logPathR));\n+            } else {\n+                \/\/ Here a check of invalid parameters happens before the LogFile gets created.\n+                assertFalse(Files.exists(logPathR));\n+            }\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/LoggingVMlogOpenTestNegative.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}