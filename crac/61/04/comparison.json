{"files":[{"patch":"@@ -77,0 +77,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -280,0 +281,1 @@\n+    int _nflags;\n@@ -332,0 +334,1 @@\n+      const char* const* flags, int num_flags,\n@@ -339,0 +342,1 @@\n+      num_flags,\n@@ -347,0 +351,6 @@\n+    for (int i = 0; i < num_flags; ++i) {\n+      if (!write_check_error(fd, flags[i], strlen(flags[i]) + 1)) {\n+        return false;\n+      }\n+    }\n+\n@@ -6237,0 +6247,1 @@\n+          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n@@ -6342,0 +6353,25 @@\n+  for (int i = 0; i < hdr->_nflags; i++) {\n+    FormatBuffer<80> err_msg(\"%s\", \"\");\n+    JVMFlag::Error result;\n+    const char *name = cursor;\n+    if (*cursor == '+' || *cursor == '-') {\n+      name = cursor + 1;\n+      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n+        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+      cursor += strlen(cursor) + 1;\n+    } else {\n+      char* eq = strchrnul(cursor, '=');\n+      if (*eq == '\\0') {\n+        result = JVMFlag::Error::MISSING_VALUE;\n+        cursor = eq + 1;\n+      } else {\n+        *eq = '\\0';\n+        char* value = eq + 1;\n+        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+        cursor = value + strlen(value) + 1;\n+      }\n+    }\n+    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %s\",\n+        name, JVMFlag::flag_error_str(result));\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+    case JVMFlagOrigin::CRAC_RESTORE: return \"CRaC restore\";\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1158,0 +1158,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == NULL) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1167,4 +1180,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1172,6 +1182,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == NULL) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -2338,16 +2344,16 @@\n-    if (!match_option(option, \"-Djava.class.path\", &tail) &&\n-        !match_option(option, \"-Dsun.java.launcher\", &tail)) {\n-      if (match_option(option, \"-D\", &tail)) {\n-        const char* key = NULL;\n-        const char* value = NULL;\n-\n-        get_key_value(tail, &key, &value);\n-\n-        if (strcmp(key, \"sun.java.command\") == 0) {\n-          char *old_java_command = _java_command;\n-          _java_command = os::strdup_check_oom(value, mtArguments);\n-          if (old_java_command != NULL) {\n-            os::free(old_java_command);\n-          }\n-        } else {\n-          add_property(tail);\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = NULL;\n+      const char* value = NULL;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.command\") == 0) {\n+        char *old_java_command = _java_command;\n+        _java_command = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != NULL) {\n+          os::free(old_java_command);\n@@ -2355,4 +2361,18 @@\n-      } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n-        \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n-        \/\/ already been handled\n-        if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+      } else {\n+        add_property(tail);\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n+      \/\/ already been handled\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != NULL) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n@@ -2361,0 +2381,1 @@\n+        build_jvm_flags(tail);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":51,"deletions":30,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -408,0 +408,2 @@\n+    case JVMFlagOrigin::CRAC_RESTORE:\n+      st->print(\"crac restore\");\n@@ -531,3 +533,4 @@\n-const int DIAGNOSTIC   = JVMFlag::KIND_DIAGNOSTIC;\n-const int MANAGEABLE   = JVMFlag::KIND_MANAGEABLE;\n-const int EXPERIMENTAL = JVMFlag::KIND_EXPERIMENTAL;\n+const int DIAGNOSTIC       = JVMFlag::KIND_DIAGNOSTIC;\n+const int MANAGEABLE       = JVMFlag::KIND_MANAGEABLE;\n+const int EXPERIMENTAL     = JVMFlag::KIND_EXPERIMENTAL;\n+const int RESTORE_SETTABLE = JVMFlag::KIND_RESTORE_SETTABLE;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  CRAC_RESTORE     = 9,\n@@ -51,1 +52,1 @@\n-ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::JIMAGE_RESOURCE)\n+ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::CRAC_RESTORE)\n@@ -74,1 +75,1 @@\n-\n+    KIND_RESTORE_SETTABLE   = 1 << 16,\n@@ -253,0 +254,1 @@\n+  bool is_restore_settable() const { return (_flags & (KIND_RESTORE_SETTABLE | KIND_MANAGEABLE)) != 0; }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n-\/\/ only with product\/product_pd flags.\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, MANAGEABLE or RESTORE_SETTABLE. Currently\n+\/\/ extra_attrs can be used only with product\/product_pd flags.\n@@ -100,0 +100,3 @@\n+\/\/ RESTORE_SETTABLE are flags that can be set during restore from a snapshot.\n+\/\/    All MANAGEABLE flags are implicitly RESTORE_SETTABLE but\n+\/\/    RESTORE_SETTABLE are not MANAGEABLE.\n@@ -2091,1 +2094,2 @@\n-  product(ccstr, CRaCCheckpointTo, NULL, \"Path to checkpoint image\")        \\\n+  product(ccstr, CRaCCheckpointTo, NULL, RESTORE_SETTABLE,                  \\\n+        \"Path to checkpoint image directory\")                               \\\n@@ -2093,2 +2097,2 @@\n-  product(ccstr, CRaCRestoreFrom, NULL, \"Path to image for restore, \"       \\\n-      \"replaces the initializing VM on success\")                            \\\n+  product(ccstr, CRaCRestoreFrom, NULL, RESTORE_SETTABLE,                   \\\n+      \"Path to image for restore, replaces the initializing VM on success\") \\\n@@ -2096,2 +2100,5 @@\n-  product(ccstr, CREngine, \"criuengine\", \"Path or name of a program \"       \\\n-      \"implementing checkpoint\/restore\")                                    \\\n+  \/* It is usually not possible to use a different engine for checkpoint *\/ \\\n+  \/* and restore but when we use a non-default engine this must be set   *\/ \\\n+  \/* on restore, too. *\/                                                    \\\n+  product(ccstr, CREngine, \"criuengine\", RESTORE_SETTABLE,                  \\\n+      \"Path or name of a program implementing checkpoint\/restore\")          \\\n@@ -2099,3 +2106,3 @@\n-  product(bool, CRaCIgnoreRestoreIfUnavailable, false, \"Ignore \"            \\\n-      \"-XX:CRaCRestoreFrom and continue initialization if restore is \"      \\\n-      \"unavailable\")                                                        \\\n+  product(bool, CRaCIgnoreRestoreIfUnavailable, false, RESTORE_SETTABLE,    \\\n+      \"Ignore -XX:CRaCRestoreFrom and continue initialization if restore \"  \\\n+      \"is unavailable\")                                                     \\\n@@ -2103,4 +2110,5 @@\n-  product(ccstr, CRaCIgnoredFileDescriptors, NULL, \"Comma-separated list \"  \\\n-      \"of file descriptor numbers or paths. All file descriptors greater \"  \\\n-      \"than 2 (stdin, stdout and stderr are excluded automatically) not \"   \\\n-      \"in this list are closed when the VM is started.\")                    \\\n+  product(ccstr, CRaCIgnoredFileDescriptors, NULL, RESTORE_SETTABLE,        \\\n+      \"Comma-separated list of file descriptor numbers or paths. \"          \\\n+      \"All file descriptors greater than 2 (stdin, stdout and stderr are \"  \\\n+      \"excluded automatically) not in this list are closed when the VM \"    \\\n+      \"is started.\")                                                        \\\n@@ -2124,1 +2132,1 @@\n-  product(bool, CRTrace, true, \"Minimal C\/R tracing\")                       \\\n+  product(bool, CRTrace, true, RESTORE_SETTABLE, \"Minimal C\/R tracing\")     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2709,1 +2709,3 @@\n-    Arguments::parse_options_for_restore(args);\n+    if (!Arguments::parse_options_for_restore(args)) {\n+      return JNI_ERR;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2604,0 +2604,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-    \/\/ only writeable flags are allowed to be set\n-    if (f->is_writeable()) {\n+    \/\/ only writeable or restore_settable flags are allowed to be set\n+    if (f->is_writeable() || f->is_restore_settable() && origin == JVMFlagOrigin::CRAC_RESTORE) {\n","filename":"src\/hotspot\/share\/services\/writeableFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import com.sun.management.VMOption;\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.lang.management.ManagementFactory;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build VMOptionsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class VMOptionsTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.doCheckpoint();\n+        builder.vmOption(\"-XX:CRaCCheckpointTo=another\"); \/\/ manageable\n+        builder.vmOption(\"-XX:CRaCIgnoredFileDescriptors=42,43\"); \/\/ restore_settable\n+        builder.doRestore();\n+        \/\/ Setting non-manageable option\n+        builder.vmOption(\"-XX:NativeMemoryTracking=summary\");\n+        assertEquals(1, builder.startRestore().waitFor());\n+    }\n+\n+    @Override\n+    public void exec() throws RestoreException, CheckpointException {\n+        HotSpotDiagnosticMXBean bean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+        VMOption checkpointTo1 = bean.getVMOption(\"CRaCCheckpointTo\");\n+        assertEquals(\"cr\", checkpointTo1.getValue());\n+        assertEquals(VMOption.Origin.VM_CREATION, checkpointTo1.getOrigin());\n+        VMOption nmt1 = bean.getVMOption(\"NativeMemoryTracking\");\n+        assertEquals(\"off\", nmt1.getValue());\n+        assertEquals(VMOption.Origin.DEFAULT, nmt1.getOrigin());\n+\n+        Core.checkpointRestore();\n+\n+        VMOption checkpointTo2 = bean.getVMOption(\"CRaCCheckpointTo\");\n+        assertEquals(\"another\", checkpointTo2.getValue());\n+        assertEquals(VMOption.Origin.OTHER, checkpointTo2.getOrigin());\n+        VMOption ignoredFileDescriptors = bean.getVMOption(\"CRaCIgnoredFileDescriptors\");\n+        assertEquals(\"42,43\", ignoredFileDescriptors.getValue());\n+        assertEquals(VMOption.Origin.OTHER, ignoredFileDescriptors.getOrigin());\n+        VMOption nmt = bean.getVMOption(\"NativeMemoryTracking\");\n+        assertEquals(\"off\", nmt.getValue());\n+        assertEquals(VMOption.Origin.DEFAULT, nmt.getOrigin());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/VMOptionsTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+    final List<String> vmOptions = new ArrayList<>();\n@@ -43,0 +44,1 @@\n+    \/\/ make sure to update copy() when adding another field here\n@@ -62,0 +64,19 @@\n+    public CracBuilder copy() {\n+        CracBuilder other = new CracBuilder();\n+        other.verbose = verbose;\n+        other.debug = debug;\n+        other.classpathEntries.addAll(classpathEntries);\n+        other.env.putAll(env);\n+        other.vmOptions.addAll(vmOptions);\n+        other.javaOptions = new HashMap<>(javaOptions);\n+        other.imageDir = imageDir;\n+        other.engine = engine;\n+        other.printResources = printResources;\n+        other.main = main;\n+        other.args = args == null ? null : Arrays.copyOf(args, args.length);\n+        other.captureOutput = captureOutput;\n+        other.dockerImageName = dockerImageName;\n+        other.dockerOptions = dockerOptions == null ? null : Arrays.copyOf(dockerOptions, dockerOptions.length);\n+        return other;\n+    }\n+\n@@ -93,0 +114,5 @@\n+    public CracBuilder vmOption(String option) {\n+        vmOptions.add(option);\n+        return this;\n+    }\n+\n@@ -155,1 +181,1 @@\n-        List<String> cmd = prepareCommand(javaPrefix);\n+        List<String> cmd = prepareCommand(javaPrefix, false);\n@@ -249,1 +275,1 @@\n-        List<String> cmd = prepareCommand(prefixJava);\n+        List<String> cmd = prepareCommand(prefixJava, true);\n@@ -292,1 +318,1 @@\n-    private List<String> prepareCommand(List<String> javaPrefix) {\n+    private List<String> prepareCommand(List<String> javaPrefix, boolean isRestore) {\n@@ -303,2 +329,0 @@\n-        cmd.add(\"-cp\");\n-        cmd.add(getClassPath());\n@@ -308,3 +332,7 @@\n-        if (printResources) {\n-            cmd.add(\"-XX:+UnlockDiagnosticVMOptions\");\n-            cmd.add(\"-XX:+CRPrintResourcesOnCheckpoint\");\n+        if (!isRestore) {\n+            cmd.add(\"-cp\");\n+            cmd.add(getClassPath());\n+            if (printResources) {\n+                cmd.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+                cmd.add(\"-XX:+CRPrintResourcesOnCheckpoint\");\n+            }\n@@ -314,1 +342,4 @@\n-            cmd.add(\"-XX:-CRDoThrowCheckpointException\");\n+            if (!isRestore) {\n+                cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n+                cmd.add(\"-XX:-CRDoThrowCheckpointException\");\n+            }\n@@ -316,0 +347,1 @@\n+        cmd.addAll(vmOptions);\n@@ -338,1 +370,0 @@\n-\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-            throw new ClassNotFoundException(\"Test class \" + testClassName + \" not found, add jtreg tag @build \" + args[0], e);\n+            throw new ClassNotFoundException(\"Test class \" + testClassName + \" not found, add jtreg tag @build \" + testClassName, e);\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}