{"files":[{"patch":"@@ -31,0 +31,4 @@\n+import jdk.internal.crac.mirror.CheckpointException;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.JDKResource;\n@@ -54,24 +58,1 @@\n-        \/\/ initialize inotify\n-        int ifd = - 1;\n-        try {\n-            ifd = inotifyInit();\n-        } catch (UnixException x) {\n-            String msg = (x.errno() == EMFILE) ?\n-                \"User limit of inotify instances reached or too many open files\" :\n-                x.errorString();\n-            throw new IOException(msg);\n-        }\n-\n-        \/\/ configure inotify to be non-blocking\n-        \/\/ create socketpair used in the close mechanism\n-        int sp[] = new int[2];\n-        try {\n-            configureBlocking(ifd, false);\n-            socketpair(sp);\n-            configureBlocking(sp[0], false);\n-        } catch (UnixException x) {\n-            UnixNativeDispatcher.close(ifd, e -> null);\n-            throw new IOException(x.errorString());\n-        }\n-\n-        this.poller = new Poller(fs, this, ifd, sp);\n+        this.poller = new Poller(fs, this);\n@@ -105,0 +86,2 @@\n+        public final UnixPath dir;\n+        public int mask;\n@@ -106,1 +89,1 @@\n-        LinuxWatchKey(UnixPath dir, LinuxWatchService watcher, int ifd, int wd) {\n+        LinuxWatchKey(UnixPath dir, LinuxWatchService watcher, int ifd, int wd, int mask) {\n@@ -110,0 +93,2 @@\n+            this.dir = dir;\n+            this.mask = mask;\n@@ -127,0 +112,8 @@\n+        public UnixPath getDir() {\n+            return dir;\n+        }\n+\n+        public int getMask() {\n+            return mask;\n+        }\n+\n@@ -144,1 +137,1 @@\n-    private static class Poller extends AbstractPoller {\n+    private static class Poller extends AbstractPoller implements JDKResource {\n@@ -174,0 +167,8 @@\n+        private enum CheckpointRestoreState {\n+            NORMAL_OPERATION,\n+            CHECKPOINT_TRANSITION,\n+            CHECKPOINTED,\n+            CHECKPOINT_ERROR,\n+            RESTORE_TRANSITION,\n+        }\n+\n@@ -178,1 +179,1 @@\n-        private final int ifd;\n+        private int ifd;\n@@ -186,1 +187,5 @@\n-        Poller(UnixFileSystem fs, LinuxWatchService watcher, int ifd, int[] sp) {\n+        private volatile CheckpointRestoreState checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+\n+        Poller(UnixFileSystem fs, LinuxWatchService watcher) throws IOException {\n+            this.socketpair = new int[2];\n+            initFDs();\n@@ -189,2 +194,0 @@\n-            this.ifd = ifd;\n-            this.socketpair = sp;\n@@ -193,0 +196,85 @@\n+            jdk.internal.crac.Core.Priority.NORMAL.getContext().register(this);\n+        }\n+        private void initFDs() throws IOException {\n+            \/\/ initialize inotify\n+            try {\n+                this.ifd = inotifyInit();\n+            } catch (UnixException x) {\n+                String msg = (x.errno() == EMFILE) ?\n+                        \"User limit of inotify instances reached or too many open files\" :\n+                        x.errorString();\n+                throw new IOException(msg);\n+            }\n+\n+            \/\/ configure inotify to be non-blocking\n+            \/\/ create socketpair used in the close mechanism\n+            try {\n+                configureBlocking(ifd, false);\n+                socketpair(this.socketpair);\n+                configureBlocking(this.socketpair[0], false);\n+            } catch (UnixException x) {\n+                try {\n+                    UnixNativeDispatcher.close(ifd);\n+                } catch (UnixException cx) {\n+                }\n+                throw new IOException(x.errorString());\n+            }\n+        }\n+\n+        private boolean processCheckpointRestore() throws IOException {\n+            if (checkpointState != CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                return false;\n+            }\n+            synchronized (this) {\n+                CheckpointRestoreState thisState;\n+                try {\n+                    UnixNativeDispatcher.close(socketpair[0]);\n+                    UnixNativeDispatcher.close(socketpair[1]);\n+                    UnixNativeDispatcher.close(ifd);\n+                } catch (UnixException x) {\n+                    thisState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+                    throw new IOException(x.errorString());\n+                }\n+                thisState = CheckpointRestoreState.CHECKPOINTED;\n+\n+                checkpointState = thisState;\n+                this.notifyAll();\n+                while (checkpointState == thisState) {\n+                    try {\n+                        this.wait();\n+                    } catch (InterruptedException e) {\n+                    }\n+                }\n+                assert checkpointState == CheckpointRestoreState.RESTORE_TRANSITION;\n+                if (thisState == CheckpointRestoreState.CHECKPOINTED) {\n+                    initFDs();\n+                    for (Map.Entry<Integer,LinuxWatchKey> entry : wdToKey.entrySet()) {\n+                        Integer oldDescriptor = entry.getKey();\n+                        LinuxWatchKey oldKey = entry.getValue();\n+                        \/\/ register with inotify (replaces existing mask if already registered)\n+                        int wd;\n+                        UnixPath dir = oldKey.getDir();\n+                        if (!(Files.exists(dir) && Files.isDirectory(dir))){\n+                            System.getLogger(Poller.class.getName()).log(System.Logger.Level.WARNING, \"CRaC Restore WatchService: path \" +\n+                                dir.toString() + \" does not exist, skip re-register of WatchKey \");\n+                            wdToKey.remove(oldDescriptor);\n+                            continue;\n+                        }\n+                        try (NativeBuffer buffer =\n+                            NativeBuffers.asNativeBuffer(dir.getByteArrayForSysCalls())) {\n+                            wd = inotifyAddWatch(ifd, buffer.address(), oldKey.getMask());\n+                            LinuxWatchKey key = new LinuxWatchKey(dir, watcher, ifd, wd, oldKey.getMask());\n+                            wdToKey.remove(oldDescriptor);\n+                            wdToKey.put(wd, key);\n+                            } catch (UnixException x) {\n+                                if (x.errno() == ENOSPC) {\n+                                    throw new IOException(\"User limit of inotify watches reached\");\n+                                }\n+                                throw new IOException(\"Can't re-register LinuxWatchKey\");\n+                            }\n+                    }\n+                    checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+                    this.notifyAll();\n+                }\n+            }\n+            return true;\n@@ -265,1 +353,1 @@\n-                key = new LinuxWatchKey(dir, watcher, ifd, wd);\n+                key = new LinuxWatchKey(dir, watcher, ifd, wd, mask);\n@@ -307,1 +395,7 @@\n-                    nReady = poll(ifd, socketpair[0]);\n+                    try {\n+                        do {\n+                            nReady = poll(ifd, socketpair[0]);\n+                        } while (processCheckpointRestore());\n+                    } catch (IOException e) {\n+                        throw new Error(\"IOException in inotify processCheckpointRestore\", e);\n+                    }\n@@ -427,0 +521,45 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (!watcher.isOpen()) {\n+                return;\n+            }\n+\n+            synchronized (this) {\n+                checkpointState = CheckpointRestoreState.CHECKPOINT_TRANSITION;\n+                wakeup();\n+                while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                    try {\n+                        this.wait();\n+                    } catch (InterruptedException e) {\n+                        checkpointState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+                        throw e;\n+                    }\n+                }\n+                if (checkpointState == CheckpointRestoreState.CHECKPOINT_ERROR) {\n+                    throw new CheckpointException();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            if (!watcher.isOpen()) {\n+                return;\n+            }\n+            synchronized (this) {\n+                checkpointState = CheckpointRestoreState.RESTORE_TRANSITION;\n+                this.notifyAll();\n+                while (checkpointState == CheckpointRestoreState.RESTORE_TRANSITION) {\n+                    try {\n+                        this.wait();\n+                    } catch (InterruptedException e) {\n+                        checkpointState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+                        throw e;\n+                    }\n+                }\n+                if (checkpointState != CheckpointRestoreState.NORMAL_OPERATION) {\n+                    throw new CheckpointException();\n+                }\n+            }\n+        }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxWatchService.java","additions":171,"deletions":32,"binary":false,"changes":203,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2024, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ import jdk.crac.Core;\n+ import jdk.test.lib.Asserts;\n+ import jdk.test.lib.crac.CracBuilder;\n+ import jdk.test.lib.crac.CracTest;\n+ import jdk.test.lib.crac.CracTestArg;\n+\n+ import java.io.File;\n+ import java.io.IOException;\n+ import java.nio.file.*;\n+ import java.util.Objects;\n+ import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build FileWatcherAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class FileWatcherAfterRestoreTest implements CracTest {\n+\n+    @CracTestArg(0)\n+    boolean deleteFolder;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.doCheckpoint();\n+        if (deleteFolder) {\n+            Path checkPath = Paths.get(System.getProperty(\"user.dir\"), \"workdir\");\n+            for (File f : Objects.requireNonNull(checkPath.toFile().listFiles())) {\n+                f.delete();\n+            }\n+            Files.delete(checkPath);\n+        }\n+        builder.doRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        WatchService watchService = FileSystems.getDefault().newWatchService();\n+        Path directory;\n+        directory = Paths.get(System.getProperty(\"user.dir\"), \"workdir\");\n+        directory.toFile().mkdir();\n+        directory.register(watchService, StandardWatchEventKinds.ENTRY_CREATE);\n+        Asserts.assertTrue(isMatchFound(watchService, directory));\n+\n+        Core.checkpointRestore();\n+\n+        if (deleteFolder) {\n+            directory.toFile().mkdir();\n+            Asserts.assertFalse(isMatchFound(watchService, directory));\n+        } else {\n+            Asserts.assertTrue(isMatchFound(watchService, directory));\n+        }\n+        watchService.close();\n+    }\n+\n+    private boolean isMatchFound(WatchService watchService, Path directory) throws IOException, InterruptedException {\n+        WatchKey key;\n+        boolean matchFound;\n+        Files.createTempFile(directory, \"temp\", \".txt\");\n+        matchFound = false;\n+        while ((key = watchService.poll(1, TimeUnit.SECONDS)) != null) {\n+            for (WatchEvent<?> event : key.pollEvents()) {\n+                if (event.kind() == StandardWatchEventKinds.ENTRY_CREATE) {\n+                    Object context = event.context();\n+                    if (context instanceof Path filePath) {\n+                        String fileName = filePath.getFileName().toString();\n+                        if (fileName.matches(\"^temp\\\\d*\\\\.txt$\")) {\n+                            matchFound = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            key.reset();\n+            if (matchFound) {\n+                break;\n+            }\n+        }\n+        return matchFound;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FileWatcherAfterRestoreTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+\n+\/**\n+ * @test Checks the different state of WatchService keys at a checkpoint moment.\n+ * @library \/test\/lib\n+ * @build FileWatcherThreadTest\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class FileWatcherThreadTest implements CracTest {\n+\n+    @CracTestArg(0)\n+    boolean checkpointWithoutKey;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().verbose(true);\n+        builder.doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Path directory = Paths.get(System.getProperty(\"user.dir\"), \"workdir\");\n+        directory.toFile().mkdir();\n+\n+        CompletableFuture<Boolean> caughtFirst = new CompletableFuture();\n+        CompletableFuture<Boolean> caughtSecond = new CompletableFuture();\n+        CyclicBarrier barrier = new CyclicBarrier(2); \/\/ Create a CyclicBarrier to sync between two threads\n+\n+        \/\/ Start the WatchService in a separate thread\n+        Thread watchThread = new Thread(() -> {\n+            try {\n+                WatchService watchService = FileSystems.getDefault().newWatchService();\n+                directory.register(watchService, StandardWatchEventKinds.ENTRY_CREATE);\n+\n+                if (checkpointWithoutKey) {\n+                    barrier.await(); \/\/ Wait until the barrier is ready\n+                }\n+\n+                while (true) {\n+                    WatchKey key = watchService.take(); \/\/ Blocking call, waits for an event\n+                    if (key == null) continue;\n+\n+                    for (WatchEvent<?> event : key.pollEvents()) {\n+                        if (event.kind() == StandardWatchEventKinds.ENTRY_CREATE) {\n+                            if (caughtFirst.isDone()) {\n+                                caughtSecond.complete(true);\n+                            } else {\n+                                caughtFirst.complete(true);\n+                            }\n+                        }\n+                    }\n+                    key.reset();\n+                }\n+            } catch (Throwable e) {\n+                if (caughtFirst.isDone()) {\n+                    caughtSecond.completeExceptionally(e);\n+                } else {\n+                    caughtFirst.completeExceptionally(e);\n+                }\n+            }\n+        });\n+\n+        watchThread.setDaemon(true);\n+        watchThread.start();\n+\n+        if (checkpointWithoutKey) {\n+            barrier.await(); \/\/ Wait for the WatchService to be ready\n+            Core.checkpointRestore(); \/\/ Restore from checkpoint\n+            Files.createTempFile(directory, \"temp\", \".txt\");\n+            Asserts.assertFalse(caughtSecond.isDone());\n+        } else {\n+            Files.createTempFile(directory, \"temp\", \".txt\");\n+            Asserts.assertTrue(caughtFirst.get());\n+            Core.checkpointRestore();\n+            Files.createTempFile(directory, \"temp\", \".txt\");\n+            Asserts.assertTrue(caughtSecond.get());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FileWatcherThreadTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}