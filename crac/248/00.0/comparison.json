{"files":[{"patch":"@@ -234,1 +234,1 @@\n-      make-target: 'static-jdk-image'\n+      make-target: 'static-jdk-bundles'\n@@ -241,3 +241,1 @@\n-      # It currently doesn't produce any bundles, but probably will do in\n-      # the future.\n-      bundle-suffix: \"-static\"\n+      static-suffix: \"-static\"\n@@ -364,0 +362,13 @@\n+      debug-suffix: -debug\n+\n+#  test-linux-x64-static:\n+#    name: linux-x64-static\n+#    needs:\n+#      - build-linux-x64\n+#      - build-linux-x64-static\n+#    uses: .\/.github\/workflows\/test.yml\n+#    with:\n+#      platform: linux-x64\n+#      bootjdk-platform: linux-x64\n+#      runs-on: ubuntu-22.04\n+#      static-suffix: \"-static\"\n@@ -375,0 +386,1 @@\n+      debug-suffix: -debug\n@@ -385,0 +397,1 @@\n+      debug-suffix: -debug\n","filename":".github\/workflows\/main.yml","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,0 +43,6 @@\n+      debug-suffix:\n+        required: false\n+        type: string\n+      static-suffix:\n+        required: false\n+        type: string\n@@ -97,1 +103,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -101,1 +107,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -105,1 +111,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -109,1 +115,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -113,1 +119,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -117,1 +123,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -121,1 +127,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -125,1 +131,1 @@\n-            debug-suffix: -debug\n+            debug-suffix: ${{ inputs.debug-suffix }}\n@@ -151,0 +157,1 @@\n+          static-suffix: ${{ inputs.static-suffix }}\n@@ -171,0 +178,15 @@\n+          if [[ '${{ inputs.static-suffix }}' == '-static' ]]; then\n+            echo \"static-hotspot-problemlist-path=`pwd`\/test\/hotspot\/jtreg\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+            echo \"static-jdk-problemlist-path=`pwd`\/test\/jdk\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+            echo \"static-langtools-problemlist-path=`pwd`\/test\/langtools\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+            echo \"static-lib-test-problemlist-path=`pwd`\/test\/lib-test\/ProblemList-StaticJdk.txt\" >> $GITHUB_OUTPUT\n+          fi\n+\n+      - name: 'Set Extra Options'\n+        id: extra-options\n+        run: |\n+          if [[ '${{ inputs.static-suffix }}' == '-static' ]]; then\n+            echo \"test-jdk=JDK_UNDER_TEST=${{ steps.bundles.outputs.static-jdk-path }}\" >> $GITHUB_OUTPUT\n+            echo \"compile-jdk=JDK_FOR_COMPILE=${{ steps.bundles.outputs.jdk-path }}\" >> $GITHUB_OUTPUT\n+            echo \"extra-problem-lists=EXTRA_PROBLEM_LISTS=${{ steps.path.outputs.static-hotspot-problemlist-path }}%20${{ steps.path.outputs.static-jdk-problemlist-path }}%20${{ steps.path.outputs.static-langtools-problemlist-path }}%20${{ steps.path.outputs.static-lib-test-problemlist-path }}\" >> $GITHUB_OUTPUT\n+          fi\n@@ -188,1 +210,3 @@\n-          JTREG=\"JAVA_OPTIONS=$JAVA_OPTIONS;VERBOSE=fail,error,time;KEYWORDS=!headful\"\n+          ${{ steps.extra-options.outputs.test-jdk }}\n+          ${{ steps.extra-options.outputs.compile-jdk }}\n+          JTREG=\"JAVA_OPTIONS=$JAVA_OPTIONS;VERBOSE=fail,error,time;KEYWORDS=!headful;${{ steps.extra-options.outputs.extra-problem-lists }}\"\n@@ -224,1 +248,1 @@\n-          artifact_name=\"results-${{ inputs.platform }}-$(echo ${{ matrix.test-name }} | tr '\/ ' '__')\"\n+          artifact_name=\"results-${{ inputs.platform }}-$(echo ${{ matrix.test-name }}${{ inputs.static-suffix }} | tr '\/ ' '__')\"\n","filename":".github\/workflows\/test.yml","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -83,2 +83,0 @@\n-    -taglet build.tools.taglet.PreviewNote \\\n-    --preview-note-tag previewNote \\\n@@ -100,1 +98,1 @@\n-    -serialwarn -encoding ISO-8859-1 -docencoding UTF-8 -breakiterator \\\n+    -serialwarn -encoding utf-8 -docencoding utf-8 -breakiterator \\\n@@ -102,1 +100,1 @@\n-    --override-methods=summary --syntax-highlight\n+    --override-methods=summary\n@@ -107,1 +105,1 @@\n-    -serialwarn -encoding ISO-8859-1 -breakiterator -splitIndex --system none \\\n+    -serialwarn -encoding utf-8 -breakiterator -splitIndex --system none \\\n@@ -266,1 +264,1 @@\n-\t$$(ECHO) -n '$$($1_OVERVIEW_TEXT)' > $$@\n+\t$$(PRINTF) \"%s\" '$$($1_OVERVIEW_TEXT)' > $$@\n@@ -546,1 +544,3 @@\n-SPEC_FILTER := %\n+ifeq ($(SPEC_FILTER), )\n+  SPEC_FILTER := %\n+endif\n","filename":"make\/Docs.gmk","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -131,1 +131,2 @@\n-      systemDictionaryShared.cpp\n+      systemDictionaryShared.cpp \\\n+      trainingData.cpp\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,3 +197,0 @@\n-  \/\/ No _features_names[] available on this CPU.\n-  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025 SAP SE. All rights reserved.\n@@ -35,17 +35,0 @@\n-    fsqrt,\n-    fsqrts,\n-    isel,\n-    lxarxeh,\n-    cmpb,\n-    popcntb,\n-    popcntw,\n-    fcfids,\n-    vand,\n-    lqarx,\n-    vcipher,\n-    vpmsumb,\n-    mfdscr,\n-    vsx,\n-    ldbrx,\n-    stdbrx,\n-    vshasig,\n@@ -58,17 +41,0 @@\n-    fsqrt_m               = (1 << fsqrt  ),\n-    fsqrts_m              = (1 << fsqrts ),\n-    isel_m                = (1 << isel   ),\n-    lxarxeh_m             = (1 << lxarxeh),\n-    cmpb_m                = (1 << cmpb   ),\n-    popcntb_m             = (1 << popcntb),\n-    popcntw_m             = (1 << popcntw),\n-    fcfids_m              = (1 << fcfids ),\n-    vand_m                = (1 << vand   ),\n-    lqarx_m               = (1 << lqarx  ),\n-    vcipher_m             = (1 << vcipher),\n-    vpmsumb_m             = (1 << vpmsumb),\n-    mfdscr_m              = (1 << mfdscr ),\n-    vsx_m                 = (1 << vsx    ),\n-    ldbrx_m               = (1 << ldbrx  ),\n-    stdbrx_m              = (1 << stdbrx ),\n-    vshasig_m             = (1 << vshasig),\n@@ -108,17 +74,0 @@\n-  static bool has_fsqrt()   { return (_features & fsqrt_m) != 0; }\n-  static bool has_fsqrts()  { return (_features & fsqrts_m) != 0; }\n-  static bool has_isel()    { return (_features & isel_m) != 0; }\n-  static bool has_lxarxeh() { return (_features & lxarxeh_m) !=0; }\n-  static bool has_cmpb()    { return (_features & cmpb_m) != 0; }\n-  static bool has_popcntb() { return (_features & popcntb_m) != 0; }\n-  static bool has_popcntw() { return (_features & popcntw_m) != 0; }\n-  static bool has_fcfids()  { return (_features & fcfids_m) != 0; }\n-  static bool has_vand()    { return (_features & vand_m) != 0; }\n-  static bool has_lqarx()   { return (_features & lqarx_m) != 0; }\n-  static bool has_vcipher() { return (_features & vcipher_m) != 0; }\n-  static bool has_vpmsumb() { return (_features & vpmsumb_m) != 0; }\n-  static bool has_mfdscr()  { return (_features & mfdscr_m) != 0; }\n-  static bool has_vsx()     { return (_features & vsx_m) != 0; }\n-  static bool has_ldbrx()   { return (_features & ldbrx_m) != 0; }\n-  static bool has_stdbrx()  { return (_features & stdbrx_m) != 0; }\n-  static bool has_vshasig() { return (_features & vshasig_m) != 0; }\n@@ -128,2 +77,0 @@\n-  static bool has_mtfprd()  { return has_vpmsumb(); } \/\/ alias for P8\n-\n@@ -134,3 +81,0 @@\n-  \/\/ No _features_names[] available on this CPU.\n-  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":2,"deletions":58,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/profiles.adoc#rva20-profiles\n+  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/src\/profiles.adoc#rva20-profiles\n@@ -230,1 +230,1 @@\n-  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/profiles.adoc#rva22-profiles\n+  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/src\/profiles.adoc#rva22-profiles\n@@ -244,1 +244,1 @@\n-  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/rva23-profile.adoc#rva23u64-profile\n+  \/\/ https:\/\/github.com\/riscv\/riscv-profiles\/blob\/main\/src\/rva23-profile.adoc#rva23u64-profile\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -592,3 +592,0 @@\n-  \/\/ No _features_names[] available on this CPU.\n-  static void insert_features_names(char* buf, size_t buflen, unsigned long features[] = _features) {}\n-\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -60,0 +62,1 @@\n+#endif\n@@ -63,0 +66,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -64,0 +69,1 @@\n+#endif\n@@ -78,0 +84,5 @@\n+int VM_Version::VM_Features::_features_bitmap_size = sizeof(VM_Version::VM_Features::_features_bitmap) \/ BytesPerLong;\n+\n+VM_Version::VM_Features VM_Version::_features;\n+VM_Version::VM_Features VM_Version::_cpu_features;\n+\n@@ -100,1 +111,1 @@\n-  if ((_features & CPU_FLUSH) != 0) {\n+  if (_features.supports_feature(CPU_FLUSH)) {\n@@ -106,1 +117,1 @@\n-  vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: \" UINT64_FORMAT_X, CPU_FLUSH));\n+  vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: 0x%llx\", 1ULL << CPU_FLUSH));\n@@ -157,1 +168,1 @@\n-    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4;\n+    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4, std_cpuid24;\n@@ -356,0 +367,11 @@\n+    \/\/\n+    \/\/ cpuid(0x24) Converged Vector ISA Main Leaf (EAX = 24H, ECX = 0).\n+    \/\/\n+    __ bind(std_cpuid24);\n+    __ movl(rax, 0x24);\n+    __ movl(rcx, 0);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid24_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ movl(Address(rsi, 4), rbx);\n+\n@@ -442,2 +464,1 @@\n-    __ cmpl(rax, 0x200000);\n-    __ jcc(Assembler::notEqual, vector_save_restore);\n+    __ jcc(Assembler::equal, vector_save_restore);\n@@ -447,2 +468,1 @@\n-    __ cmpl(rax, 0x80000);\n-    __ jcc(Assembler::notEqual, vector_save_restore);\n+    __ jcc(Assembler::equal, vector_save_restore);\n@@ -501,0 +521,1 @@\n+      \/\/ OR check _cpuid_info.sefsl1_cpuid7_edx.bits.avx10\n@@ -503,3 +524,6 @@\n-      __ andl(rax, Address(rsi, 4)); \/\/ xcr0 bits sse | ymm\n-      __ cmpl(rax, 0x10000);\n-      __ jccb(Assembler::notEqual, legacy_setup); \/\/ jump if EVEX is not supported\n+      __ andl(rax, Address(rsi, 4));\n+      __ lea(rsi, Address(rbp, in_bytes(VM_Version::sefsl1_cpuid7_offset())));\n+      __ movl(rbx, 0x80000);\n+      __ andl(rbx, Address(rsi, 4));\n+      __ orl(rax, rbx);\n+      __ jccb(Assembler::equal, legacy_setup); \/\/ jump if EVEX is not supported\n@@ -586,2 +610,1 @@\n-      __ cmpl(rax, 0x10000);\n-      __ jcc(Assembler::notEqual, legacy_save_restore);\n+      __ jcc(Assembler::equal, legacy_save_restore);\n@@ -854,0 +877,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1263,0 +1288,1 @@\n+#endif\n@@ -1268,0 +1294,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1270,0 +1298,5 @@\n+FIXME:CPUFeatures2\n+  _features = 0;\n+FIXME:CPUFeatures3\n+#endif\n+\/\/FIXME:CPUFeatures4\n@@ -1285,0 +1318,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1287,0 +1322,6 @@\n+FIXME:CPUFeatures2\n+    _cpu_features = _features;   \/\/ Preserve features\n+FIXME:CPUFeatures3\n+#endif\n+    _cpu_features = _features; \/\/ Preserve features\n+\/\/FIXME:CPUFeatures4\n@@ -1300,0 +1341,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1301,0 +1344,1 @@\n+#endif\n@@ -1308,1 +1352,1 @@\n-      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, CPU_SSE2, (uint64_t)0));\n+      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: 0x%llx\", 1ULL << CPU_SSE2));\n@@ -1336,1 +1380,1 @@\n-  if (FLAG_IS_DEFAULT(EnableX86ECoreOpts) && is_intel() && cpu_family() == 6 &&\n+  if (FLAG_IS_DEFAULT(EnableX86ECoreOpts) && is_intel() && is_intel_server_family() &&\n@@ -1343,2 +1387,2 @@\n-    _features &= ~CPU_SSE4_1;\n-    _features &= ~CPU_SSE4_2;\n+    _features.clear_feature(CPU_SSE4_1);\n+    _features.clear_feature(CPU_SSE4_2);\n@@ -1348,3 +1392,3 @@\n-    _features &= ~CPU_SSE3;\n-    _features &= ~CPU_SSSE3;\n-    _features &= ~CPU_SSE4A;\n+    _features.clear_feature(CPU_SSE3);\n+    _features.clear_feature(CPU_SSSE3);\n+    _features.clear_feature(CPU_SSE4A);\n@@ -1354,1 +1398,1 @@\n-    _features &= ~CPU_SSE2;\n+    _features.clear_feature(CPU_SSE2);\n@@ -1357,1 +1401,1 @@\n-    _features &= ~CPU_SSE;\n+    _features.clear_feature(CPU_SSE);\n@@ -1423,15 +1467,19 @@\n-    _features &= ~CPU_AVX512F;\n-    _features &= ~CPU_AVX512DQ;\n-    _features &= ~CPU_AVX512CD;\n-    _features &= ~CPU_AVX512BW;\n-    _features &= ~CPU_AVX512VL;\n-    _features &= ~CPU_AVX512_VPOPCNTDQ;\n-    _features &= ~CPU_AVX512_VPCLMULQDQ;\n-    _features &= ~CPU_AVX512_VAES;\n-    _features &= ~CPU_AVX512_VNNI;\n-    _features &= ~CPU_AVX512_VBMI;\n-    _features &= ~CPU_AVX512_VBMI2;\n-    _features &= ~CPU_AVX512_BITALG;\n-    _features &= ~CPU_AVX512_IFMA;\n-    _features &= ~CPU_APX_F;\n-    _features &= ~CPU_AVX512_FP16;\n+    _features.clear_feature(CPU_AVX512F);\n+    _features.clear_feature(CPU_AVX512DQ);\n+    _features.clear_feature(CPU_AVX512CD);\n+    _features.clear_feature(CPU_AVX512BW);\n+    _features.clear_feature(CPU_AVX512ER);\n+    _features.clear_feature(CPU_AVX512PF);\n+    _features.clear_feature(CPU_AVX512VL);\n+    _features.clear_feature(CPU_AVX512_VPOPCNTDQ);\n+    _features.clear_feature(CPU_AVX512_VPCLMULQDQ);\n+    _features.clear_feature(CPU_AVX512_VAES);\n+    _features.clear_feature(CPU_AVX512_VNNI);\n+    _features.clear_feature(CPU_AVX512_VBMI);\n+    _features.clear_feature(CPU_AVX512_VBMI2);\n+    _features.clear_feature(CPU_AVX512_BITALG);\n+    _features.clear_feature(CPU_AVX512_IFMA);\n+    _features.clear_feature(CPU_APX_F);\n+    _features.clear_feature(CPU_AVX512_FP16);\n+    _features.clear_feature(CPU_AVX10_1);\n+    _features.clear_feature(CPU_AVX10_2);\n@@ -1450,1 +1498,1 @@\n-    _features &= ~CPU_APX_F;\n+    _features.clear_feature(CPU_APX_F);\n@@ -1454,2 +1502,2 @@\n-    _features &= ~CPU_AVX2;\n-    _features &= ~CPU_AVX_IFMA;\n+    _features.clear_feature(CPU_AVX2);\n+    _features.clear_feature(CPU_AVX_IFMA);\n@@ -1459,4 +1507,4 @@\n-    _features &= ~CPU_AVX;\n-    _features &= ~CPU_VZEROUPPER;\n-    _features &= ~CPU_F16C;\n-    _features &= ~CPU_SHA512;\n+    _features.clear_feature(CPU_AVX);\n+    _features.clear_feature(CPU_VZEROUPPER);\n+    _features.clear_feature(CPU_F16C);\n+    _features.clear_feature(CPU_SHA512);\n@@ -1467,1 +1515,1 @@\n-    _features &= ~CPU_HT;\n+    _features.clear_feature(CPU_HT);\n@@ -1472,17 +1520,19 @@\n-      _features &= ~CPU_VZEROUPPER;\n-      _features &= ~CPU_AVX512BW;\n-      _features &= ~CPU_AVX512VL;\n-      _features &= ~CPU_AVX512DQ;\n-      _features &= ~CPU_AVX512_VNNI;\n-      _features &= ~CPU_AVX512_VAES;\n-      _features &= ~CPU_AVX512_VPOPCNTDQ;\n-      _features &= ~CPU_AVX512_VPCLMULQDQ;\n-      _features &= ~CPU_AVX512_VBMI;\n-      _features &= ~CPU_AVX512_VBMI2;\n-      _features &= ~CPU_CLWB;\n-      _features &= ~CPU_FLUSHOPT;\n-      _features &= ~CPU_GFNI;\n-      _features &= ~CPU_AVX512_BITALG;\n-      _features &= ~CPU_AVX512_IFMA;\n-      _features &= ~CPU_AVX_IFMA;\n-      _features &= ~CPU_AVX512_FP16;\n+      _features.clear_feature(CPU_VZEROUPPER);\n+      _features.clear_feature(CPU_AVX512BW);\n+      _features.clear_feature(CPU_AVX512VL);\n+      _features.clear_feature(CPU_AVX512DQ);\n+      _features.clear_feature(CPU_AVX512_VNNI);\n+      _features.clear_feature(CPU_AVX512_VAES);\n+      _features.clear_feature(CPU_AVX512_VPOPCNTDQ);\n+      _features.clear_feature(CPU_AVX512_VPCLMULQDQ);\n+      _features.clear_feature(CPU_AVX512_VBMI);\n+      _features.clear_feature(CPU_AVX512_VBMI2);\n+      _features.clear_feature(CPU_CLWB);\n+      _features.clear_feature(CPU_FLUSHOPT);\n+      _features.clear_feature(CPU_GFNI);\n+      _features.clear_feature(CPU_AVX512_BITALG);\n+      _features.clear_feature(CPU_AVX512_IFMA);\n+      _features.clear_feature(CPU_AVX_IFMA);\n+      _features.clear_feature(CPU_AVX512_FP16);\n+      _features.clear_feature(CPU_AVX10_1);\n+      _features.clear_feature(CPU_AVX10_2);\n@@ -1498,1 +1548,0 @@\n-  assert(supports_cpuid(), \"Always present\");\n@@ -1522,2 +1571,2 @@\n-  char buf[1024];\n-  int cpu_info_size = jio_snprintf(\n+  char buf[2048];\n+  size_t cpu_info_size = jio_snprintf(\n@@ -1530,0 +1579,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1531,0 +1582,7 @@\n+FIXME:CPUFeatures2\n+  insert_features_names(buf + cpu_info_size, sizeof(buf) - cpu_info_size, _features_names);\n+FIXME:CPUFeatures3\n+#endif\n+\n+  insert_features_names(_features, buf + cpu_info_size, sizeof(buf) - cpu_info_size);\n+\/\/FIXME:CPUFeatures4\n@@ -1669,0 +1727,14 @@\n+  \/\/ Kyber Intrinsics\n+  \/\/ Currently we only have them for AVX512\n+#ifdef _LP64\n+  if (supports_evex() && supports_avx512bw()) {\n+      if (FLAG_IS_DEFAULT(UseKyberIntrinsics)) {\n+          UseKyberIntrinsics = true;\n+      }\n+  } else\n+#endif\n+  if (UseKyberIntrinsics) {\n+     warning(\"Intrinsics for ML-KEM are not available on this CPU.\");\n+     FLAG_SET_DEFAULT(UseKyberIntrinsics, false);\n+  }\n+\n@@ -2002,1 +2074,1 @@\n-    if (cpu_family() == 6 || cpu_family() == 15) {\n+    if (is_intel_server_family() || cpu_family() == 15) {\n@@ -2018,1 +2090,1 @@\n-    if (cpu_family() == 6 && supports_sse3()) { \/\/ New Intel cpus\n+    if (is_intel_server_family() && supports_sse3()) { \/\/ New Intel cpus\n@@ -2256,1 +2328,1 @@\n-  if (is_intel() && cpu_family() == 6 && supports_sse3()) {\n+  if (is_intel() && is_intel_server_family() && supports_sse3()) {\n@@ -2503,0 +2575,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2507,0 +2581,1 @@\n+#endif\n@@ -2516,0 +2591,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2518,0 +2595,1 @@\n+#endif\n@@ -2522,0 +2600,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2569,0 +2649,1 @@\n+#endif\n@@ -2605,0 +2686,1 @@\n+\n@@ -2620,0 +2702,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2622,0 +2706,1 @@\n+#endif\n@@ -2624,0 +2709,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2658,0 +2745,1 @@\n+#endif\n@@ -3421,2 +3509,2 @@\n-uint64_t VM_Version::CpuidInfo::feature_flags() const {\n-  uint64_t result = 0;\n+VM_Version::VM_Features VM_Version::CpuidInfo::feature_flags() const {\n+  VM_Features vm_features;\n@@ -3424,1 +3512,1 @@\n-    result |= CPU_CX8;\n+    vm_features.set_feature(CPU_CX8);\n@@ -3426,1 +3514,1 @@\n-    result |= CPU_CMOV;\n+    vm_features.set_feature(CPU_CMOV);\n@@ -3428,1 +3516,1 @@\n-    result |= CPU_FLUSH;\n+    vm_features.set_feature(CPU_FLUSH);\n@@ -3432,1 +3520,1 @@\n-  assert ((result & CPU_FLUSH) != 0, \"clflush should be available\");\n+  assert (vm_features.supports_feature(CPU_FLUSH), \"clflush should be available\");\n@@ -3435,1 +3523,1 @@\n-    result |= CPU_FXSR;\n+    vm_features.set_feature(CPU_FXSR);\n@@ -3438,1 +3526,1 @@\n-    result |= CPU_HT;\n+    vm_features.set_feature(CPU_HT);\n@@ -3441,1 +3529,1 @@\n-    result |= CPU_MMX;\n+    vm_features.set_feature(CPU_MMX);\n@@ -3443,1 +3531,1 @@\n-    result |= CPU_SSE;\n+    vm_features.set_feature(CPU_SSE);\n@@ -3445,1 +3533,1 @@\n-    result |= CPU_SSE2;\n+    vm_features.set_feature(CPU_SSE2);\n@@ -3447,1 +3535,1 @@\n-    result |= CPU_SSE3;\n+    vm_features.set_feature(CPU_SSE3);\n@@ -3449,1 +3537,1 @@\n-    result |= CPU_SSSE3;\n+    vm_features.set_feature(CPU_SSSE3);\n@@ -3451,1 +3539,1 @@\n-    result |= CPU_SSE4_1;\n+    vm_features.set_feature(CPU_SSE4_1);\n@@ -3453,1 +3541,1 @@\n-    result |= CPU_SSE4_2;\n+    vm_features.set_feature(CPU_SSE4_2);\n@@ -3455,1 +3543,1 @@\n-    result |= CPU_POPCNT;\n+    vm_features.set_feature(CPU_POPCNT);\n@@ -3458,1 +3546,1 @@\n-    result |= CPU_APX_F;\n+    vm_features.set_feature(CPU_APX_F);\n@@ -3464,2 +3552,2 @@\n-    result |= CPU_AVX;\n-    result |= CPU_VZEROUPPER;\n+    vm_features.set_feature(CPU_AVX);\n+    vm_features.set_feature(CPU_VZEROUPPER);\n@@ -3467,1 +3555,1 @@\n-      result |= CPU_SHA512;\n+      vm_features.set_feature(CPU_SHA512);\n@@ -3469,1 +3557,1 @@\n-      result |= CPU_F16C;\n+      vm_features.set_feature(CPU_F16C);\n@@ -3471,1 +3559,1 @@\n-      result |= CPU_AVX2;\n+      vm_features.set_feature(CPU_AVX2);\n@@ -3473,1 +3561,1 @@\n-        result |= CPU_AVX_IFMA;\n+        vm_features.set_feature(CPU_AVX_IFMA);\n@@ -3476,1 +3564,1 @@\n-        result |= CPU_GFNI;\n+        vm_features.set_feature(CPU_GFNI);\n@@ -3481,1 +3569,1 @@\n-      result |= CPU_AVX512F;\n+      vm_features.set_feature(CPU_AVX512F);\n@@ -3483,1 +3571,1 @@\n-        result |= CPU_AVX512CD;\n+        vm_features.set_feature(CPU_AVX512CD);\n@@ -3485,1 +3573,1 @@\n-        result |= CPU_AVX512DQ;\n+        vm_features.set_feature(CPU_AVX512DQ);\n@@ -3487,1 +3575,1 @@\n-        result |= CPU_AVX512_IFMA;\n+        vm_features.set_feature(CPU_AVX512_IFMA);\n@@ -3489,1 +3577,1 @@\n-        result |= CPU_AVX512PF;\n+        vm_features.set_feature(CPU_AVX512PF);\n@@ -3491,1 +3579,1 @@\n-        result |= CPU_AVX512ER;\n+        vm_features.set_feature(CPU_AVX512ER);\n@@ -3493,1 +3581,1 @@\n-        result |= CPU_AVX512BW;\n+        vm_features.set_feature(CPU_AVX512BW);\n@@ -3495,1 +3583,1 @@\n-        result |= CPU_AVX512VL;\n+        vm_features.set_feature(CPU_AVX512VL);\n@@ -3497,1 +3585,1 @@\n-        result |= CPU_AVX512_VPOPCNTDQ;\n+        vm_features.set_feature(CPU_AVX512_VPOPCNTDQ);\n@@ -3499,1 +3587,1 @@\n-        result |= CPU_AVX512_VPCLMULQDQ;\n+        vm_features.set_feature(CPU_AVX512_VPCLMULQDQ);\n@@ -3501,1 +3589,1 @@\n-        result |= CPU_AVX512_VAES;\n+        vm_features.set_feature(CPU_AVX512_VAES);\n@@ -3503,1 +3591,1 @@\n-        result |= CPU_AVX512_VNNI;\n+        vm_features.set_feature(CPU_AVX512_VNNI);\n@@ -3505,1 +3593,1 @@\n-        result |= CPU_AVX512_BITALG;\n+        vm_features.set_feature(CPU_AVX512_BITALG);\n@@ -3507,1 +3595,1 @@\n-        result |= CPU_AVX512_VBMI;\n+        vm_features.set_feature(CPU_AVX512_VBMI);\n@@ -3509,1 +3597,28 @@\n-        result |= CPU_AVX512_VBMI2;\n+        vm_features.set_feature(CPU_AVX512_VBMI2);\n+    }\n+    if (is_intel()) {\n+      if (sefsl1_cpuid7_edx.bits.avx10 != 0 &&\n+          std_cpuid24_ebx.bits.avx10_vlen_512 !=0 &&\n+          std_cpuid24_ebx.bits.avx10_converged_isa_version >= 1 &&\n+          xem_xcr0_eax.bits.opmask != 0 &&\n+          xem_xcr0_eax.bits.zmm512 != 0 &&\n+          xem_xcr0_eax.bits.zmm32 != 0) {\n+        vm_features.set_feature(CPU_AVX10_1);\n+        vm_features.set_feature(CPU_AVX512F);\n+        vm_features.set_feature(CPU_AVX512CD);\n+        vm_features.set_feature(CPU_AVX512DQ);\n+        vm_features.set_feature(CPU_AVX512PF);\n+        vm_features.set_feature(CPU_AVX512ER);\n+        vm_features.set_feature(CPU_AVX512BW);\n+        vm_features.set_feature(CPU_AVX512VL);\n+        vm_features.set_feature(CPU_AVX512_VPOPCNTDQ);\n+        vm_features.set_feature(CPU_AVX512_VPCLMULQDQ);\n+        vm_features.set_feature(CPU_AVX512_VAES);\n+        vm_features.set_feature(CPU_AVX512_VNNI);\n+        vm_features.set_feature(CPU_AVX512_BITALG);\n+        vm_features.set_feature(CPU_AVX512_VBMI);\n+        vm_features.set_feature(CPU_AVX512_VBMI2);\n+        if (std_cpuid24_ebx.bits.avx10_converged_isa_version >= 2) {\n+          vm_features.set_feature(CPU_AVX10_2);\n+        }\n+      }\n@@ -3512,0 +3627,1 @@\n+\n@@ -3513,1 +3629,1 @@\n-    result |= CPU_HV;\n+    vm_features.set_feature(CPU_HV);\n@@ -3515,1 +3631,1 @@\n-    result |= CPU_BMI1;\n+    vm_features.set_feature(CPU_BMI1);\n@@ -3517,1 +3633,1 @@\n-    result |= CPU_TSC;\n+    vm_features.set_feature(CPU_TSC);\n@@ -3519,1 +3635,1 @@\n-    result |= CPU_TSCINV_BIT;\n+    vm_features.set_feature(CPU_TSCINV_BIT);\n@@ -3521,1 +3637,1 @@\n-    result |= CPU_AES;\n+    vm_features.set_feature(CPU_AES);\n@@ -3523,1 +3639,1 @@\n-    result |= CPU_LZCNT;\n+    vm_features.set_feature(CPU_LZCNT);\n@@ -3525,1 +3641,1 @@\n-    result |= CPU_3DNOW_PREFETCH;\n+    vm_features.set_feature(CPU_3DNOW_PREFETCH);\n@@ -3527,1 +3643,1 @@\n-    result |= CPU_ERMS;\n+    vm_features.set_feature(CPU_ERMS);\n@@ -3529,1 +3645,1 @@\n-    result |= CPU_FSRM;\n+    vm_features.set_feature(CPU_FSRM);\n@@ -3531,1 +3647,1 @@\n-    result |= CPU_CLMUL;\n+    vm_features.set_feature(CPU_CLMUL);\n@@ -3533,1 +3649,1 @@\n-    result |= CPU_RTM;\n+    vm_features.set_feature(CPU_RTM);\n@@ -3535,1 +3651,1 @@\n-     result |= CPU_ADX;\n+     vm_features.set_feature(CPU_ADX);\n@@ -3537,1 +3653,1 @@\n-    result |= CPU_BMI2;\n+    vm_features.set_feature(CPU_BMI2);\n@@ -3539,1 +3655,1 @@\n-    result |= CPU_SHA;\n+    vm_features.set_feature(CPU_SHA);\n@@ -3541,1 +3657,1 @@\n-    result |= CPU_FMA;\n+    vm_features.set_feature(CPU_FMA);\n@@ -3543,1 +3659,1 @@\n-    result |= CPU_FLUSHOPT;\n+    vm_features.set_feature(CPU_FLUSHOPT);\n@@ -3545,1 +3661,1 @@\n-    result |= CPU_CLWB;\n+    vm_features.set_feature(CPU_CLWB);\n@@ -3547,1 +3663,1 @@\n-    result |= CPU_RDTSCP;\n+    vm_features.set_feature(CPU_RDTSCP);\n@@ -3549,1 +3665,1 @@\n-    result |= CPU_RDPID;\n+    vm_features.set_feature(CPU_RDPID);\n@@ -3555,1 +3671,1 @@\n-      result |= CPU_3DNOW_PREFETCH;\n+      vm_features.set_feature(CPU_3DNOW_PREFETCH);\n@@ -3557,1 +3673,1 @@\n-      result |= CPU_SSE4A;\n+      vm_features.set_feature(CPU_SSE4A);\n@@ -3563,1 +3679,1 @@\n-      result |= CPU_SERIALIZE;\n+      vm_features.set_feature(CPU_SERIALIZE);\n@@ -3565,1 +3681,1 @@\n-      result |= CPU_AVX512_FP16;\n+      vm_features.set_feature(CPU_AVX512_FP16);\n@@ -3572,2 +3688,2 @@\n-    assert((result & CPU_CLWB) == 0, \"Check if it is supported?\");\n-    result &= ~CPU_CLWB;\n+    assert(vm_features.supports_feature(CPU_CLWB), \"Check if it is supported?\");\n+    vm_features.clear_feature(CPU_CLWB);\n@@ -3578,1 +3694,1 @@\n-    result |= CPU_PKU;\n+    vm_features.set_feature(CPU_PKU);\n@@ -3581,1 +3697,1 @@\n-    result |= CPU_OSPKE;\n+    vm_features.set_feature(CPU_OSPKE);\n@@ -3586,1 +3702,1 @@\n-    result |= CPU_CET_SS;\n+    vm_features.set_feature(CPU_CET_SS);\n@@ -3589,1 +3705,1 @@\n-    result |= CPU_CET_IBT;\n+    vm_features.set_feature(CPU_CET_IBT);\n@@ -3596,1 +3712,1 @@\n-    result |= CPU_TSCINV;\n+    vm_features.set_feature(CPU_TSCINV);\n@@ -3598,2 +3714,1 @@\n-\n-  return result;\n+  return vm_features;\n@@ -3756,1 +3871,1 @@\n-    if (supports_sse3() && cpu_family() == 6) {\n+    if (supports_sse3() && is_intel_server_family()) {\n@@ -3764,1 +3879,1 @@\n-      if (cpu_family() == 6) {\n+      if (is_intel_server_family()) {\n@@ -3789,0 +3904,11 @@\n+\n+void VM_Version::insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen) {\n+  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n+    if (features.supports_feature((VM_Version::Feature_Flag)i)) {\n+      int res = jio_snprintf(buf, buflen, \", %s\", _features_names[i]);\n+      assert(res > 0, \"not enough temporary space allocated\");\n+      buf += res;\n+      buflen -= res;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":266,"deletions":140,"binary":false,"changes":406,"status":"modified"},{"patch":"@@ -302,1 +302,3 @@\n-      uint32_t       : 21,\n+      uint32_t       : 19,\n+              avx10  : 1,\n+                     : 1,\n@@ -308,0 +310,18 @@\n+  union StdCpuid24MainLeafEax {\n+    uint32_t value;\n+    struct {\n+      uint32_t  sub_leaves_cnt  : 31;\n+    } bits;\n+  };\n+\n+  union StdCpuid24MainLeafEbx {\n+    uint32_t value;\n+    struct {\n+      uint32_t  avx10_converged_isa_version  : 8,\n+                                             : 8,\n+                                             : 2,\n+                avx10_vlen_512               : 1,\n+                                             : 13;\n+    } bits;\n+  };\n+\n@@ -349,1 +369,1 @@\n-   * src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.amd64\/src\/jdk\/vm\/ci\/amd64\/AMD64.java\n+   * src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java\n@@ -351,1 +371,1 @@\n-  enum Feature_Flag : uint64_t {\n+  enum Feature_Flag {\n@@ -427,1 +447,3 @@\n-    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/\n+    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/ \\\n+    decl(AVX10_1,           \"avx10_1\",           63) \/* AVX10 512 bit vector ISA Version 1 support*\/ \\\n+    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n@@ -429,1 +451,1 @@\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1ULL << bit),\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (bit),\n@@ -432,0 +454,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -433,0 +457,5 @@\n+FIXME:CPUFeatures2\n+FIXME:CPUFeatures3\n+#endif\n+    MAX_CPU_FEATURES\n+\/\/FIXME:CPUFeatures4\n@@ -435,0 +464,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -460,0 +491,66 @@\n+FIXME:CPUFeatures2\n+FIXME:CPUFeatures3\n+#endif\n+  class VM_Features {\n+    friend class VMStructs;\n+    friend class JVMCIVMStructs;\n+\n+   private:\n+    uint64_t _features_bitmap[(MAX_CPU_FEATURES \/ BitsPerLong) + 1];\n+\n+    STATIC_ASSERT(sizeof(_features_bitmap) * BitsPerByte >= MAX_CPU_FEATURES);\n+\n+    \/\/ Number of 8-byte elements in _bitmap.\n+    constexpr static int features_bitmap_element_count() {\n+      return sizeof(_features_bitmap) \/ sizeof(uint64_t);\n+    }\n+\n+    constexpr static int features_bitmap_element_shift_count() {\n+      return LogBitsPerLong;\n+    }\n+\n+    constexpr static uint64_t features_bitmap_element_mask() {\n+      return (1ULL << features_bitmap_element_shift_count()) - 1;\n+    }\n+\n+    static int index(Feature_Flag feature) {\n+      int idx = feature >> features_bitmap_element_shift_count();\n+      assert(idx < features_bitmap_element_count(), \"Features array index out of bounds\");\n+      return idx;\n+    }\n+\n+    static uint64_t bit_mask(Feature_Flag feature) {\n+      return (1ULL << (feature & features_bitmap_element_mask()));\n+    }\n+\n+    static int _features_bitmap_size; \/\/ for JVMCI purposes\n+   public:\n+    VM_Features() {\n+      for (int i = 0; i < features_bitmap_element_count(); i++) {\n+        _features_bitmap[i] = 0;\n+      }\n+    }\n+\n+    void set_feature(Feature_Flag feature) {\n+      int idx = index(feature);\n+      _features_bitmap[idx] |= bit_mask(feature);\n+    }\n+\n+    void clear_feature(VM_Version::Feature_Flag feature) {\n+      int idx = index(feature);\n+      _features_bitmap[idx] &= ~bit_mask(feature);\n+    }\n+\n+    bool supports_feature(VM_Version::Feature_Flag feature) {\n+      int idx = index(feature);\n+      return (_features_bitmap[idx] & bit_mask(feature)) != 0;\n+    }\n+  };\n+\n+  \/\/ CPU feature flags vector, can be affected by VM settings.\n+  static VM_Features _features;\n+\n+  \/\/ Original CPU feature flags vector, not affected by VM settings.\n+  static VM_Features _cpu_features;\n+\n+\/\/FIXME:CPUFeatures4\n@@ -463,0 +560,5 @@\n+  static void clear_cpu_features() {\n+    _features = VM_Features();\n+    _cpu_features = VM_Features();\n+  }\n+\n@@ -526,0 +628,5 @@\n+    \/\/ cpuid function 24 converged vector ISA main leaf\n+    \/\/ eax = 24, ecx = 0\n+    StdCpuid24MainLeafEax std_cpuid24_eax;\n+    StdCpuid24MainLeafEbx std_cpuid24_ebx;\n+\n@@ -599,1 +706,1 @@\n-    uint64_t feature_flags() const;\n+    VM_Features feature_flags() const;\n@@ -601,0 +708,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -622,0 +731,2 @@\n+#else\n+    uint64_t glibc_flags() const { return 0; }\n@@ -623,0 +734,1 @@\n+#endif\n@@ -685,0 +797,1 @@\n+  static ByteSize std_cpuid24_offset() { return byte_offset_of(CpuidInfo, std_cpuid24_eax); }\n@@ -718,8 +831,15 @@\n-  static void clean_cpuFeatures()   { _features = 0; }\n-  static void set_avx_cpuFeatures() { _features |= (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }\n-  static void set_evex_cpuFeatures() { _features |= (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }\n-  static void set_apx_cpuFeatures() { _features |= CPU_APX_F; }\n-  static void set_bmi_cpuFeatures() { _features |= (CPU_BMI1 | CPU_BMI2 | CPU_LZCNT | CPU_POPCNT); }\n-\n-  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {\n-    Abstract_VM_Version::insert_features_names(buf, buflen, _features_names, features);\n+  static void clean_cpuFeatures()   {\n+    VM_Version::clear_cpu_features();\n+  }\n+  static void set_avx_cpuFeatures() {\n+    _features.set_feature(CPU_SSE);\n+    _features.set_feature(CPU_SSE2);\n+    _features.set_feature(CPU_AVX);\n+    _features.set_feature(CPU_VZEROUPPER);\n+  }\n+  static void set_evex_cpuFeatures() {\n+    _features.set_feature(CPU_AVX10_1);\n+    _features.set_feature(CPU_AVX512F);\n+    _features.set_feature(CPU_SSE);\n+    _features.set_feature(CPU_SSE2);\n+    _features.set_feature(CPU_VZEROUPPER);\n@@ -727,2 +847,6 @@\n-  static void insert_glibc_features_names(char* buf, size_t buflen, uint64_t glibc_features) {\n-    Abstract_VM_Version::insert_features_names(buf, buflen, _glibc_features_names, glibc_features);\n+  static void set_apx_cpuFeatures() { _features.set_feature(CPU_APX_F); }\n+  static void set_bmi_cpuFeatures() {\n+    _features.set_feature(CPU_BMI1);\n+    _features.set_feature(CPU_BMI2);\n+    _features.set_feature(CPU_LZCNT);\n+    _features.set_feature(CPU_POPCNT);\n@@ -738,0 +862,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -739,0 +865,3 @@\n+#else\n+  static bool ignore_cpu_features() { return true; }\n+#endif\n@@ -765,0 +894,1 @@\n+  static bool is_intel_server_family()    { return cpu_family() == 6 || cpu_family() == 19; }\n@@ -791,34 +921,33 @@\n-  static bool supports_cpuid()        { return _features  != 0; }\n-  static bool supports_cmov()         { return (_features & CPU_CMOV) != 0; }\n-  static bool supports_fxsr()         { return (_features & CPU_FXSR) != 0; }\n-  static bool supports_ht()           { return (_features & CPU_HT) != 0; }\n-  static bool supports_mmx()          { return (_features & CPU_MMX) != 0; }\n-  static bool supports_sse()          { return (_features & CPU_SSE) != 0; }\n-  static bool supports_sse2()         { return (_features & CPU_SSE2) != 0; }\n-  static bool supports_sse3()         { return (_features & CPU_SSE3) != 0; }\n-  static bool supports_ssse3()        { return (_features & CPU_SSSE3)!= 0; }\n-  static bool supports_sse4_1()       { return (_features & CPU_SSE4_1) != 0; }\n-  static bool supports_sse4_2()       { return (_features & CPU_SSE4_2) != 0; }\n-  static bool supports_popcnt()       { return (_features & CPU_POPCNT) != 0; }\n-  static bool supports_avx()          { return (_features & CPU_AVX) != 0; }\n-  static bool supports_avx2()         { return (_features & CPU_AVX2) != 0; }\n-  static bool supports_tsc()          { return (_features & CPU_TSC) != 0; }\n-  static bool supports_rdtscp()       { return (_features & CPU_RDTSCP) != 0; }\n-  static bool supports_rdpid()        { return (_features & CPU_RDPID) != 0; }\n-  static bool supports_aes()          { return (_features & CPU_AES) != 0; }\n-  static bool supports_erms()         { return (_features & CPU_ERMS) != 0; }\n-  static bool supports_fsrm()         { return (_features & CPU_FSRM) != 0; }\n-  static bool supports_clmul()        { return (_features & CPU_CLMUL) != 0; }\n-  static bool supports_rtm()          { return (_features & CPU_RTM) != 0; }\n-  static bool supports_bmi1()         { return (_features & CPU_BMI1) != 0; }\n-  static bool supports_bmi2()         { return (_features & CPU_BMI2) != 0; }\n-  static bool supports_adx()          { return (_features & CPU_ADX) != 0; }\n-  static bool supports_evex()         { return (_features & CPU_AVX512F) != 0; }\n-  static bool supports_avx512dq()     { return (_features & CPU_AVX512DQ) != 0; }\n-  static bool supports_avx512ifma()   { return (_features & CPU_AVX512_IFMA) != 0; }\n-  static bool supports_avxifma()      { return (_features & CPU_AVX_IFMA) != 0; }\n-  static bool supports_avx512pf()     { return (_features & CPU_AVX512PF) != 0; }\n-  static bool supports_avx512er()     { return (_features & CPU_AVX512ER) != 0; }\n-  static bool supports_avx512cd()     { return (_features & CPU_AVX512CD) != 0; }\n-  static bool supports_avx512bw()     { return (_features & CPU_AVX512BW) != 0; }\n-  static bool supports_avx512vl()     { return (_features & CPU_AVX512VL) != 0; }\n+  static bool supports_cmov()         { return _features.supports_feature(CPU_CMOV); }\n+  static bool supports_fxsr()         { return _features.supports_feature(CPU_FXSR); }\n+  static bool supports_ht()           { return _features.supports_feature(CPU_HT); }\n+  static bool supports_mmx()          { return _features.supports_feature(CPU_MMX); }\n+  static bool supports_sse()          { return _features.supports_feature(CPU_SSE); }\n+  static bool supports_sse2()         { return _features.supports_feature(CPU_SSE2); }\n+  static bool supports_sse3()         { return _features.supports_feature(CPU_SSE3); }\n+  static bool supports_ssse3()        { return _features.supports_feature(CPU_SSSE3); }\n+  static bool supports_sse4_1()       { return _features.supports_feature(CPU_SSE4_1); }\n+  static bool supports_sse4_2()       { return _features.supports_feature(CPU_SSE4_2); }\n+  static bool supports_popcnt()       { return _features.supports_feature(CPU_POPCNT); }\n+  static bool supports_avx()          { return _features.supports_feature(CPU_AVX); }\n+  static bool supports_avx2()         { return _features.supports_feature(CPU_AVX2); }\n+  static bool supports_tsc()          { return _features.supports_feature(CPU_TSC); }\n+  static bool supports_rdtscp()       { return _features.supports_feature(CPU_RDTSCP); }\n+  static bool supports_rdpid()        { return _features.supports_feature(CPU_RDPID); }\n+  static bool supports_aes()          { return _features.supports_feature(CPU_AES); }\n+  static bool supports_erms()         { return _features.supports_feature(CPU_ERMS); }\n+  static bool supports_fsrm()         { return _features.supports_feature(CPU_FSRM); }\n+  static bool supports_clmul()        { return _features.supports_feature(CPU_CLMUL); }\n+  static bool supports_rtm()          { return _features.supports_feature(CPU_RTM); }\n+  static bool supports_bmi1()         { return _features.supports_feature(CPU_BMI1); }\n+  static bool supports_bmi2()         { return _features.supports_feature(CPU_BMI2); }\n+  static bool supports_adx()          { return _features.supports_feature(CPU_ADX); }\n+  static bool supports_evex()         { return _features.supports_feature(CPU_AVX512F); }\n+  static bool supports_avx512dq()     { return _features.supports_feature(CPU_AVX512DQ); }\n+  static bool supports_avx512ifma()   { return _features.supports_feature(CPU_AVX512_IFMA); }\n+  static bool supports_avxifma()      { return _features.supports_feature(CPU_AVX_IFMA); }\n+  static bool supports_avx512pf()     { return _features.supports_feature(CPU_AVX512PF); }\n+  static bool supports_avx512er()     { return _features.supports_feature(CPU_AVX512ER); }\n+  static bool supports_avx512cd()     { return _features.supports_feature(CPU_AVX512CD); }\n+  static bool supports_avx512bw()     { return _features.supports_feature(CPU_AVX512BW); }\n+  static bool supports_avx512vl()     { return _features.supports_feature(CPU_AVX512VL); }\n@@ -833,1 +962,1 @@\n-  static bool supports_apx_f()        { return (_features & CPU_APX_F) != 0; }\n+  static bool supports_apx_f()        { return _features.supports_feature(CPU_APX_F); }\n@@ -835,20 +964,26 @@\n-  static bool supports_sha()          { return (_features & CPU_SHA) != 0; }\n-  static bool supports_fma()          { return (_features & CPU_FMA) != 0 && supports_avx(); }\n-  static bool supports_vzeroupper()   { return (_features & CPU_VZEROUPPER) != 0; }\n-  static bool supports_avx512_vpopcntdq()  { return (_features & CPU_AVX512_VPOPCNTDQ) != 0; }\n-  static bool supports_avx512_vpclmulqdq() { return (_features & CPU_AVX512_VPCLMULQDQ) != 0; }\n-  static bool supports_avx512_vaes()  { return (_features & CPU_AVX512_VAES) != 0; }\n-  static bool supports_gfni()         { return (_features & CPU_GFNI) != 0; }\n-  static bool supports_avx512_vnni()  { return (_features & CPU_AVX512_VNNI) != 0; }\n-  static bool supports_avx512_bitalg()  { return (_features & CPU_AVX512_BITALG) != 0; }\n-  static bool supports_avx512_vbmi()  { return (_features & CPU_AVX512_VBMI) != 0; }\n-  static bool supports_avx512_vbmi2() { return (_features & CPU_AVX512_VBMI2) != 0; }\n-  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }\n-  static bool supports_hv()           { return (_features & CPU_HV) != 0; }\n-  static bool supports_serialize()    { return (_features & CPU_SERIALIZE) != 0; }\n-  static bool supports_f16c()         { return (_features & CPU_F16C) != 0; }\n-  static bool supports_pku()          { return (_features & CPU_PKU) != 0; }\n-  static bool supports_ospke()        { return (_features & CPU_OSPKE) != 0; }\n-  static bool supports_cet_ss()       { return (_features & CPU_CET_SS) != 0; }\n-  static bool supports_cet_ibt()      { return (_features & CPU_CET_IBT) != 0; }\n-  static bool supports_sha512()       { return (_features & CPU_SHA512) != 0; }\n+  static bool supports_sha()          { return _features.supports_feature(CPU_SHA); }\n+  static bool supports_fma()          { return _features.supports_feature(CPU_FMA) && supports_avx(); }\n+  static bool supports_vzeroupper()   { return _features.supports_feature(CPU_VZEROUPPER); }\n+  static bool supports_avx512_vpopcntdq()  { return _features.supports_feature(CPU_AVX512_VPOPCNTDQ); }\n+  static bool supports_avx512_vpclmulqdq() { return _features.supports_feature(CPU_AVX512_VPCLMULQDQ); }\n+  static bool supports_avx512_vaes()  { return _features.supports_feature(CPU_AVX512_VAES); }\n+  static bool supports_gfni()         { return _features.supports_feature(CPU_GFNI); }\n+  static bool supports_avx512_vnni()  { return _features.supports_feature(CPU_AVX512_VNNI); }\n+  static bool supports_avx512_bitalg()  { return _features.supports_feature(CPU_AVX512_BITALG); }\n+  static bool supports_avx512_vbmi()  { return _features.supports_feature(CPU_AVX512_VBMI); }\n+  static bool supports_avx512_vbmi2() { return _features.supports_feature(CPU_AVX512_VBMI2); }\n+  static bool supports_avx512_fp16()  { return _features.supports_feature(CPU_AVX512_FP16); }\n+  static bool supports_hv()           { return _features.supports_feature(CPU_HV); }\n+  static bool supports_serialize()    { return _features.supports_feature(CPU_SERIALIZE); }\n+  static bool supports_f16c()         { return _features.supports_feature(CPU_F16C); }\n+  static bool supports_pku()          { return _features.supports_feature(CPU_PKU); }\n+  static bool supports_ospke()        { return _features.supports_feature(CPU_OSPKE); }\n+  static bool supports_cet_ss()       { return _features.supports_feature(CPU_CET_SS); }\n+  static bool supports_cet_ibt()      { return _features.supports_feature(CPU_CET_IBT); }\n+  static bool supports_sha512()       { return _features.supports_feature(CPU_SHA512); }\n+\n+  \/\/ IntelÂ® AVX10 introduces a versioned approach for enumeration that is monotonically increasing, inclusive,\n+  \/\/ and supporting all vector lengths. Feature set supported by an AVX10 vector ISA version is also supported\n+  \/\/ by all the versions above it.\n+  static bool supports_avx10_1()      { return _features.supports_feature(CPU_AVX10_1);}\n+  static bool supports_avx10_2()      { return _features.supports_feature(CPU_AVX10_2);}\n@@ -859,1 +994,1 @@\n-  static bool cpu_supports_evex()     { return (_cpu_features & CPU_AVX512F) != 0; }\n+  static bool cpu_supports_evex()     { return _cpu_features.supports_feature(CPU_AVX512F); }\n@@ -890,0 +1025,2 @@\n+  static void insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen);\n+\n@@ -897,3 +1034,3 @@\n-  static bool supports_3dnow_prefetch()    { return (_features & CPU_3DNOW_PREFETCH) != 0; }\n-  static bool supports_lzcnt()    { return (_features & CPU_LZCNT) != 0; }\n-  static bool supports_sse4a()    { return (_features & CPU_SSE4A) != 0; }\n+  static bool supports_3dnow_prefetch()    { return _features.supports_feature(CPU_3DNOW_PREFETCH); }\n+  static bool supports_lzcnt()    { return _features.supports_feature(CPU_LZCNT); }\n+  static bool supports_sse4a()    { return _features.supports_feature(CPU_SSE4A); }\n@@ -906,1 +1043,1 @@\n-    return (_features & CPU_TSCINV_BIT) != 0;\n+    return _features.supports_feature(CPU_TSCINV_BIT);\n@@ -909,1 +1046,1 @@\n-    return (_features & CPU_TSCINV) != 0;\n+    return _features.supports_feature(CPU_TSCINV);\n@@ -913,1 +1050,1 @@\n-  static bool has_fast_idiv()     { return is_intel() && cpu_family() == 6 &&\n+  static bool has_fast_idiv()     { return is_intel() && is_intel_server_family() &&\n@@ -970,2 +1107,2 @@\n-  static bool supports_clflushopt() { return ((_features & CPU_FLUSHOPT) != 0); }\n-  static bool supports_clwb() { return ((_features & CPU_CLWB) != 0); }\n+  static bool supports_clflushopt() { return (_features.supports_feature(CPU_FLUSHOPT)); }\n+  static bool supports_clwb() { return (_features.supports_feature(CPU_CLWB)); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":217,"deletions":80,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-  \/\/ No _features_names[] available on this CPU.\n-  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n-\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-#include \"runtime\/statSampler.hpp\"\n-#include \"runtime\/threadCritical.hpp\"\n@@ -142,6 +140,0 @@\n-#ifndef PV_7\n-  #define PV_7 0x200000          \/* Power PC 7 *\/\n-#endif\n-#ifndef PV_7_Compat\n-  #define PV_7_Compat 0x208000   \/* Power PC 7 *\/\n-#endif\n@@ -764,2 +756,3 @@\n-    int limit = 3;\n-    do {\n+    int trials_remaining = 4;\n+    useconds_t next_delay = 1000;\n+    while (true) {\n@@ -767,1 +760,13 @@\n-    } while (ret == EAGAIN && limit-- > 0);\n+\n+      if (ret != EAGAIN) {\n+        break;\n+      }\n+\n+      if (--trials_remaining <= 0) {\n+        break;\n+      }\n+\n+      log_debug(os, thread)(\"Failed to start native thread (%s), retrying after %dus.\", os::errno_name(ret), next_delay);\n+      ::usleep(next_delay);\n+      next_delay *= 2;\n+    }\n@@ -1241,27 +1246,0 @@\n-  case PV_7:\n-    strncpy(buf, \"Power PC 7\", buflen);\n-    break;\n-  case PV_6_1:\n-    strncpy(buf, \"Power PC 6 DD1.x\", buflen);\n-    break;\n-  case PV_6:\n-    strncpy(buf, \"Power PC 6\", buflen);\n-    break;\n-  case PV_5:\n-    strncpy(buf, \"Power PC 5\", buflen);\n-    break;\n-  case PV_5_2:\n-    strncpy(buf, \"Power PC 5_2\", buflen);\n-    break;\n-  case PV_5_3:\n-    strncpy(buf, \"Power PC 5_3\", buflen);\n-    break;\n-  case PV_5_Compat:\n-    strncpy(buf, \"PV_5_Compat\", buflen);\n-    break;\n-  case PV_6_Compat:\n-    strncpy(buf, \"PV_6_Compat\", buflen);\n-    break;\n-  case PV_7_Compat:\n-    strncpy(buf, \"PV_7_Compat\", buflen);\n-    break;\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":16,"deletions":38,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -56,2 +56,0 @@\n-#include \"runtime\/statSampler.hpp\"\n-#include \"runtime\/threadCritical.hpp\"\n@@ -146,1 +144,3 @@\n-\/\/ available here means free\n+\/\/ Available here means free. Note that this number is of no much use. As an estimate\n+\/\/ for future memory pressure it is far too conservative, since MacOS will use a lot\n+\/\/ of unused memory for caches, and return it willingly in case of needs.\n@@ -647,2 +647,3 @@\n-    int limit = 3;\n-    do {\n+    int trials_remaining = 4;\n+    useconds_t next_delay = 1000;\n+    while (true) {\n@@ -650,1 +651,13 @@\n-    } while (ret == EAGAIN && limit-- > 0);\n+\n+      if (ret != EAGAIN) {\n+        break;\n+      }\n+\n+      if (--trials_remaining <= 0) {\n+        break;\n+      }\n+\n+      log_debug(os, thread)(\"Failed to start native thread (%s), retrying after %dus.\", os::errno_name(ret), next_delay);\n+      ::usleep(next_delay);\n+      next_delay *= 2;\n+    }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-#include \"runtime\/statSampler.hpp\"\n-#include \"runtime\/threadCritical.hpp\"\n@@ -1070,2 +1068,3 @@\n-    int limit = 3;\n-    do {\n+    int trials_remaining = 4;\n+    useconds_t next_delay = 1000;\n+    while (true) {\n@@ -1073,1 +1072,13 @@\n-    } while (ret == EAGAIN && limit-- > 0);\n+\n+      if (ret != EAGAIN) {\n+        break;\n+      }\n+\n+      if (--trials_remaining <= 0) {\n+        break;\n+      }\n+\n+      log_debug(os, thread)(\"Failed to start native thread (%s), retrying after %dus.\", os::errno_name(ret), next_delay);\n+      ::usleep(next_delay);\n+      next_delay *= 2;\n+    }\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"interpreter\/interpreter.hpp\"\n@@ -1356,0 +1357,9 @@\n+#ifdef ASSERT\n+bool os::Posix::ucontext_is_interpreter(const ucontext_t* uc) {\n+  assert(uc != nullptr, \"invariant\");\n+  address pc = os::Posix::ucontext_get_pc(uc);\n+  assert(pc != nullptr, \"invariant\");\n+  return Interpreter::contains(pc);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+  DEBUG_ONLY(static bool ucontext_is_interpreter(const ucontext_t* ctx);)\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1508,0 +1508,8 @@\n+void* PosixSignals::get_signal_handler_for_signal(int sig) {\n+  struct sigaction oact;\n+  if (sigaction(sig, (struct sigaction*)nullptr, &oact) == -1) {\n+    return nullptr;\n+  }\n+  return get_signal_handler(&oact);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-#include \"runtime\/statSampler.hpp\"\n@@ -67,1 +66,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n@@ -762,2 +760,3 @@\n-  int limit = 3;\n-  do {\n+  int trials_remaining = 4;\n+  DWORD next_delay_ms = 1;\n+  while (true) {\n@@ -771,1 +770,17 @@\n-  } while (thread_handle == nullptr && errno == EAGAIN && limit-- > 0);\n+\n+    if (thread_handle != nullptr) {\n+      break;\n+    }\n+\n+    if (errno != EAGAIN) {\n+      break;\n+    }\n+\n+    if (--trials_remaining <= 0) {\n+      break;\n+    }\n+\n+    log_debug(os, thread)(\"Failed to start native thread (%s), retrying after %dms.\", os::errno_name(errno), next_delay_ms);\n+    Sleep(next_delay_ms);\n+    next_delay_ms *= 2;\n+  }\n@@ -4659,0 +4674,57 @@\n+\/\/ This method checks if a wide path is actually a symbolic link\n+static bool is_symbolic_link(const wchar_t* wide_path) {\n+  WIN32_FIND_DATAW fd;\n+  HANDLE f = ::FindFirstFileW(wide_path, &fd);\n+  if (f != INVALID_HANDLE_VALUE) {\n+    const bool result = fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT && fd.dwReserved0 == IO_REPARSE_TAG_SYMLINK;\n+    if (::FindClose(f) == 0) {\n+      errno = ::GetLastError();\n+      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%ld.\", errno);\n+    }\n+    return result;\n+  } else {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%ld.\", errno);\n+    return false;\n+  }\n+}\n+\n+\/\/ This method dereferences a symbolic link\n+static WCHAR* get_path_to_target(const wchar_t* wide_path) {\n+  HANDLE hFile = CreateFileW(wide_path, GENERIC_READ, FILE_SHARE_READ, nullptr,\n+                             OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);\n+  if (hFile == INVALID_HANDLE_VALUE) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  \/\/ Returned value includes the terminating null character.\n+  const size_t target_path_size = ::GetFinalPathNameByHandleW(hFile, nullptr, 0,\n+                                                              FILE_NAME_NORMALIZED);\n+  if (target_path_size == 0) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  WCHAR* path_to_target = NEW_C_HEAP_ARRAY(WCHAR, target_path_size, mtInternal);\n+\n+  \/\/ The returned size is the length excluding the terminating null character.\n+  const size_t res = ::GetFinalPathNameByHandleW(hFile, path_to_target, static_cast<DWORD>(target_path_size),\n+                                                 FILE_NAME_NORMALIZED);\n+  if (res != target_path_size - 1) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  if (::CloseHandle(hFile) == 0) {\n+    errno = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%ld.\", errno);\n+    return nullptr;\n+  }\n+\n+  return path_to_target;\n+}\n+\n@@ -4752,0 +4824,14 @@\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink) {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr) {\n+      \/\/ it is a symbolic link, but we failed to resolve it,\n+      \/\/ errno has been set in the call to get_path_to_target(),\n+      \/\/ no need to overwrite it\n+      os::free(wide_path);\n+      return -1;\n+    }\n+  }\n+\n@@ -4753,2 +4839,1 @@\n-  BOOL bret = ::GetFileAttributesExW(wide_path, GetFileExInfoStandard, &file_data);\n-  os::free(wide_path);\n+  BOOL bret = ::GetFileAttributesExW(is_symlink ? path_to_target : wide_path, GetFileExInfoStandard, &file_data);\n@@ -4756,0 +4841,1 @@\n+  \/\/ if getting attributes failed, GetLastError should be called immediately after that\n@@ -4758,0 +4844,3 @@\n+    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%ld.\", errno);\n+    os::free(wide_path);\n+    os::free(path_to_target);\n@@ -4761,0 +4850,3 @@\n+  os::free(wide_path);\n+  os::free(path_to_target);\n+\n@@ -4945,2 +5037,17 @@\n-  int fd = ::_wopen(wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n-  os::free(wide_path);\n+  const bool is_symlink = is_symbolic_link(wide_path);\n+  WCHAR* path_to_target = nullptr;\n+\n+  if (is_symlink) {\n+    path_to_target = get_path_to_target(wide_path);\n+    if (path_to_target == nullptr) {\n+      \/\/ it is a symbolic link, but we failed to resolve it,\n+      \/\/ errno has been set in the call to get_path_to_target(),\n+      \/\/ no need to overwrite it\n+      os::free(wide_path);\n+      return -1;\n+    }\n+  }\n+\n+  int fd = ::_wopen(is_symlink ? path_to_target : wide_path, oflag | O_BINARY | O_NOINHERIT, mode);\n+\n+  \/\/ if opening files failed, GetLastError should be called immediately after that\n@@ -4950,0 +5057,1 @@\n+    log_debug(os)(\"os::open() failed to _wopen: GetLastError->%ld.\", errno);\n@@ -4951,0 +5059,2 @@\n+  os::free(wide_path);\n+  os::free(path_to_target);\n@@ -5807,18 +5917,4 @@\n-\/\/ returns true if thread could be suspended,\n-\/\/ false otherwise\n-static bool do_suspend(HANDLE* h) {\n-  if (h != nullptr) {\n-    if (SuspendThread(*h) != ~0) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/ resume the thread\n-\/\/ calling resume on an active thread is a no-op\n-static void do_resume(HANDLE* h) {\n-  if (h != nullptr) {\n-    ResumeThread(*h);\n-  }\n-}\n+\/\/ WINDOWS CONTEXT Flags for THREAD_SAMPLING\n+#if defined(AMD64) || defined(_M_ARM64)\n+  #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)\n+#endif\n@@ -5826,7 +5922,4 @@\n-\/\/ retrieve a suspend\/resume context capable handle\n-\/\/ from the tid. Caller validates handle return value.\n-void get_thread_handle_for_extended_context(HANDLE* h,\n-                                            DWORD tid) {\n-  if (h != nullptr) {\n-    *h = OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);\n-  }\n+\/\/ Retrieve a suspend\/resume context capable handle for the tid.\n+\/\/ Caller validates handle return value.\n+static inline HANDLE get_thread_handle_for_extended_context(DWORD tid) {\n+  return OpenThread(THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);\n@@ -5838,8 +5931,2 @@\n-  CONTEXT    ctxt;\n-  HANDLE     h = nullptr;\n-\n-  \/\/ get context capable handle for thread\n-  get_thread_handle_for_extended_context(&h, _thread->osthread()->thread_id());\n-\n-  \/\/ sanity\n-  if (h == nullptr || h == INVALID_HANDLE_VALUE) {\n+  const HANDLE h = get_thread_handle_for_extended_context(_thread->osthread()->thread_id());\n+  if (h == nullptr) {\n@@ -5848,11 +5935,9 @@\n-\n-  \/\/ suspend the thread\n-  if (do_suspend(&h)) {\n-    ctxt.ContextFlags = (CONTEXT_FULL | CONTEXT_FLOATING_POINT);\n-    \/\/ get thread context\n-    GetThreadContext(h, &ctxt);\n-    SuspendedThreadTaskContext context(_thread, &ctxt);\n-    \/\/ pass context to Thread Sampling impl\n-    do_task(context);\n-    \/\/ resume thread\n-    do_resume(&h);\n+  CONTEXT ctxt;\n+  ctxt.ContextFlags = sampling_context_flags;\n+  if (SuspendThread(h) != OS_ERR) {\n+    if (GetThreadContext(h, &ctxt)) {\n+      const SuspendedThreadTaskContext context(_thread, &ctxt);\n+      \/\/ Pass context to Thread Sampling implementation.\n+      do_task(context);\n+    }\n+    ResumeThread(h);\n@@ -5860,2 +5945,0 @@\n-\n-  \/\/ close handle\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":138,"deletions":55,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n@@ -1211,1 +1210,0 @@\n-      ik->set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n@@ -1216,0 +1214,8 @@\n+  if (!SystemDictionaryShared::is_builtin_loader(ik->class_loader_data())) {\n+    \/\/ A class loaded by a user-defined classloader.\n+    assert(ik->shared_classpath_index() < 0, \"not assigned yet\");\n+    ik->set_shared_classpath_index(UNREGISTERED_INDEX);\n+    SystemDictionaryShared::set_shared_class_misc_info(ik, (ClassFileStream*)stream);\n+    return;\n+  }\n+\n@@ -1220,0 +1226,2 @@\n+  bool found_invalid = false;\n+\n@@ -1234,1 +1242,0 @@\n-    bool found_invalid = false;\n@@ -1261,2 +1268,0 @@\n-                ik->set_shared_classpath_index(-1);\n-                ik->set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n@@ -1278,1 +1283,1 @@\n-        return false; \/\/ quit iterating\n+        return false; \/\/ Break the AOTClassLocationConfig::dumptime_iterate() loop.\n@@ -1283,0 +1288,1 @@\n+  }\n@@ -1284,12 +1290,2 @@\n-    if (found_invalid) {\n-      return;\n-    }\n-\n-    \/\/ No path entry found for this class: most likely a shared class loaded by the\n-    \/\/ user defined classloader.\n-    if (classpath_index < 0 && !SystemDictionaryShared::is_builtin_loader(ik->class_loader_data())) {\n-      assert(ik->shared_classpath_index() < 0, \"not assigned yet\");\n-      ik->set_shared_classpath_index(UNREGISTERED_INDEX);\n-      SystemDictionaryShared::set_shared_class_misc_info(ik, (ClassFileStream*)stream);\n-      return;\n-    }\n+  if (found_invalid) {\n+    assert(classpath_index == -1, \"sanity\");\n@@ -1302,1 +1298,1 @@\n-  ClassLoaderExt::record_result(checked_cast<s2>(classpath_index), ik, redefined);\n+  ClassLoaderExt::record_result_for_builtin_loader(checked_cast<s2>(classpath_index), ik, redefined);\n@@ -1308,17 +1304,3 @@\n-  s2 classloader_type;\n-  if (HeapShared::is_lambda_form_klass(ik)) {\n-    classloader_type = ClassLoader::BOOT_LOADER;\n-  } else {\n-    oop loader = ik->class_loader();\n-\n-    if (loader == nullptr) {\n-      classloader_type = ClassLoader::BOOT_LOADER;\n-    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n-      classloader_type = ClassLoader::PLATFORM_LOADER;\n-    } else if (SystemDictionary::is_system_class_loader(loader)) {\n-      classloader_type = ClassLoader::APP_LOADER;\n-    } else {\n-      \/\/ This class won't be archived, so no need to update its\n-      \/\/ classloader_type\/classpath_index.\n-      return;\n-    }\n+  if (ik->defined_by_other_loaders()) {\n+    \/\/ We don't archive hidden classes for non-builtin loaders.\n+    return;\n@@ -1326,1 +1308,0 @@\n-  ik->set_shared_class_loader_type(classloader_type);\n@@ -1335,1 +1316,1 @@\n-    if (classloader_type == ClassLoader::APP_LOADER) {\n+    if (ik->defined_by_app_loader()) {\n@@ -1525,2 +1506,1 @@\n-  char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(orig)+1);\n-  strcpy(orig_copy, orig);\n+  char* orig_copy = ResourceArea::strdup(thread, orig);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":20,"deletions":40,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -749,0 +749,6 @@\n+  template(jdk_internal_vm_ThreadSnapshot,         \"jdk\/internal\/vm\/ThreadSnapshot\")                              \\\n+  template(jdk_internal_vm_ThreadLock,             \"jdk\/internal\/vm\/ThreadSnapshot$ThreadLock\")                   \\\n+  template(jdk_internal_vm_ThreadLock_signature,   \"Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                 \\\n+  template(jdk_internal_vm_ThreadLock_array,       \"[Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                \\\n+  template(java_lang_StackTraceElement_of_name,    \"of\")                                                          \\\n+  template(java_lang_StackTraceElement_of_signature, \"([Ljava\/lang\/StackTraceElement;)[Ljava\/lang\/StackTraceElement;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-      policy()->record_new_heap_size(num_regions());\n+      policy()->record_new_heap_size(num_committed_regions());\n@@ -551,1 +551,0 @@\n-  uint shrink_count = 0;\n@@ -563,0 +562,7 @@\n+  uint max_shrink_count = 0;\n+  if (capacity() > MinHeapSize) {\n+    size_t max_shrink_bytes = capacity() - MinHeapSize;\n+    max_shrink_count = (uint)(max_shrink_bytes \/ G1HeapRegion::GrainBytes);\n+  }\n+\n+  uint shrink_count = 0;\n@@ -569,2 +575,6 @@\n-    _hrm.shrink_at(r->hrm_index(), 1);\n-    shrink_count++;\n+    if (shrink_count < max_shrink_count) {\n+      _hrm.shrink_at(r->hrm_index(), 1);\n+      shrink_count++;\n+    } else {\n+      _hrm.insert_into_free_list(r);\n+    }\n@@ -576,2 +586,2 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (CDS archive regions). Total size: %zuB\",\n-                              G1HeapRegion::GrainWords * HeapWordSize * shrink_count);\n+    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (CDS archive regions). Total size: %zuB (%u Regions)\",\n+                              G1HeapRegion::GrainWords * HeapWordSize * shrink_count, shrink_count);\n@@ -780,1 +790,1 @@\n-void G1CollectedHeap::prepare_for_mutator_after_full_collection() {\n+void G1CollectedHeap::prepare_for_mutator_after_full_collection(size_t allocation_word_size) {\n@@ -785,1 +795,1 @@\n-  resize_heap_if_necessary();\n+  resize_heap_if_necessary(allocation_word_size);\n@@ -838,2 +848,3 @@\n-bool G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n-                                         bool do_maximal_compaction) {\n+void G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n+                                         bool do_maximal_compaction,\n+                                         size_t allocation_word_size) {\n@@ -851,4 +862,1 @@\n-  collector.complete_collection();\n-\n-  \/\/ Full collection was successfully completed.\n-  return true;\n+  collector.complete_collection(allocation_word_size);\n@@ -863,1 +871,2 @@\n-                     false \/* do_maximal_compaction *\/);\n+                     false \/* do_maximal_compaction *\/,\n+                     size_t(0) \/* allocation_word_size *\/);\n@@ -866,1 +875,1 @@\n-bool G1CollectedHeap::upgrade_to_full_collection() {\n+void G1CollectedHeap::upgrade_to_full_collection() {\n@@ -869,6 +878,3 @@\n-  bool success = do_full_collection(true  \/* clear_all_soft_refs *\/,\n-                                    false \/* do_maximal_compaction *\/);\n-  \/\/ do_full_collection only fails if blocked by GC locker and that can't\n-  \/\/ be the case here since we only call this when already completed one gc.\n-  assert(success, \"invariant\");\n-  return success;\n+  do_full_collection(true  \/* clear_all_soft_refs *\/,\n+                     false \/* do_maximal_compaction *\/,\n+                     size_t(0) \/* allocation_word_size *\/);\n@@ -877,1 +883,1 @@\n-void G1CollectedHeap::resize_heap_if_necessary() {\n+void G1CollectedHeap::resize_heap_if_necessary(size_t allocation_word_size) {\n@@ -881,1 +887,1 @@\n-  size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand);\n+  size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);\n@@ -915,3 +921,1 @@\n-                                                            bool expect_null_mutator_alloc_region,\n-                                                            bool* gc_succeeded) {\n-  *gc_succeeded = true;\n+                                                            bool expect_null_mutator_alloc_region) {\n@@ -945,2 +949,3 @@\n-    *gc_succeeded = do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/ ,\n-                                       maximal_compaction \/* do_maximal_compaction *\/);\n+    do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/,\n+                       maximal_compaction \/* do_maximal_compaction *\/,\n+                       word_size \/* allocation_word_size *\/);\n@@ -952,2 +957,1 @@\n-HeapWord* G1CollectedHeap::satisfy_failed_allocation(size_t word_size,\n-                                                     bool* succeeded) {\n+HeapWord* G1CollectedHeap::satisfy_failed_allocation(size_t word_size) {\n@@ -961,2 +965,1 @@\n-                                     false, \/* expect_null_mutator_alloc_region *\/\n-                                     succeeded);\n+                                     false \/* expect_null_mutator_alloc_region *\/);\n@@ -964,1 +967,1 @@\n-  if (result != nullptr || !*succeeded) {\n+  if (result != nullptr) {\n@@ -972,2 +975,1 @@\n-                                            true, \/* expect_null_mutator_alloc_region *\/\n-                                            succeeded);\n+                                            true \/* expect_null_mutator_alloc_region *\/);\n@@ -975,1 +977,1 @@\n-  if (result != nullptr || !*succeeded) {\n+  if (result != nullptr) {\n@@ -983,2 +985,1 @@\n-                                            true,  \/* expect_null_mutator_alloc_region *\/\n-                                            succeeded);\n+                                            true  \/* expect_null_mutator_alloc_region *\/);\n@@ -1031,1 +1032,1 @@\n-  if (is_maximal_no_gc()) {\n+  if (num_inactive_regions() == 0) {\n@@ -1049,1 +1050,1 @@\n-  policy()->record_new_heap_size(num_regions());\n+  policy()->record_new_heap_size(num_committed_regions());\n@@ -1058,1 +1059,1 @@\n-    assert(is_maximal_no_gc(), \"Should be no regions left, available: %u\", _hrm.available());\n+    assert(num_inactive_regions() == 0, \"Should be no regions left, available: %u\", num_inactive_regions());\n@@ -1063,1 +1064,1 @@\n-  policy()->record_new_heap_size(num_regions());\n+  policy()->record_new_heap_size(num_committed_regions());\n@@ -1079,1 +1080,1 @@\n-    policy()->record_new_heap_size(num_regions());\n+    policy()->record_new_heap_size(num_committed_regions());\n@@ -1391,1 +1392,1 @@\n-  guarantee((max_reserved_regions() - 1) <= max_region_idx, \"too many regions\");\n+  guarantee((max_num_regions() - 1) <= max_region_idx, \"too many regions\");\n@@ -1396,1 +1397,1 @@\n-  G1FromCardCache::initialize(max_reserved_regions());\n+  G1FromCardCache::initialize(max_num_regions());\n@@ -1399,1 +1400,1 @@\n-  _rem_set->initialize(max_reserved_regions());\n+  _rem_set->initialize(max_num_regions());\n@@ -1408,1 +1409,1 @@\n-  G1FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n+  G1FreeRegionList::set_unrealistically_long_length(max_num_regions() + 1);\n@@ -1476,1 +1477,1 @@\n-  _collection_set.initialize(max_reserved_regions());\n+  _collection_set.initialize(max_num_regions());\n@@ -1575,1 +1576,1 @@\n-  return _hrm.length() * G1HeapRegion::GrainBytes;\n+  return _hrm.num_committed_regions() * G1HeapRegion::GrainBytes;\n@@ -1878,24 +1879,0 @@\n-bool G1CollectedHeap::try_collect_fullgc(GCCause::Cause cause,\n-                                         const G1GCCounters& counters_before) {\n-  assert_heap_not_locked();\n-\n-  while(true) {\n-    VM_G1CollectFull op(counters_before.total_collections(),\n-                        counters_before.total_full_collections(),\n-                        cause);\n-    VMThread::execute(&op);\n-\n-    \/\/ Request is trivially finished.\n-    if (!GCCause::is_explicit_full_gc(cause) || op.gc_succeeded()) {\n-      return op.gc_succeeded();\n-    }\n-\n-    {\n-      MutexLocker ml(Heap_lock);\n-      if (counters_before.total_full_collections() != total_full_collections()) {\n-        return true;\n-      }\n-    }\n-  }\n-}\n-\n@@ -1920,1 +1897,5 @@\n-    return try_collect_fullgc(cause, counters_before);\n+    VM_G1CollectFull op(counters_before.total_collections(),\n+                        counters_before.total_full_collections(),\n+                        cause);\n+    VMThread::execute(&op);\n+    return op.gc_succeeded();\n@@ -2087,1 +2068,1 @@\n-  return max_regions() * G1HeapRegion::GrainBytes;\n+  return max_num_regions() * G1HeapRegion::GrainBytes;\n@@ -2151,1 +2132,1 @@\n-  StreamAutoIndentor indentor(st, 1);\n+  StreamIndentor si(st, 1);\n@@ -2235,1 +2216,1 @@\n-                       survivor_used_bytes, old_gen_used_bytes, num_regions());\n+                       survivor_used_bytes, old_gen_used_bytes, num_committed_regions());\n@@ -2319,2 +2300,2 @@\n-  bool ret_succeeded = op.prologue_succeeded() && op.gc_succeeded();\n-  assert(result == nullptr || ret_succeeded,\n+  *succeeded = op.gc_succeeded();\n+  assert(result == nullptr || *succeeded,\n@@ -2322,1 +2303,0 @@\n-  *succeeded = ret_succeeded;\n@@ -2449,1 +2429,1 @@\n-bool G1CollectedHeap::do_collection_pause_at_safepoint() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint() {\n@@ -2454,1 +2434,0 @@\n-  return true;\n@@ -2462,1 +2441,1 @@\n-  _g1h->print_heap_before_gc();\n+  _g1h->print_before_gc();\n@@ -2476,1 +2455,1 @@\n-  _g1h->print_heap_after_gc();\n+  _g1h->print_after_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":64,"deletions":85,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_reserved_regions() )\n+typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_num_regions() )\n@@ -284,3 +284,0 @@\n-  bool try_collect_fullgc(GCCause::Cause cause,\n-                          const G1GCCounters& counters_before);\n-\n@@ -484,0 +481,2 @@\n+  \/\/ - if allocation_word_size is set, then this allocation size will\n+  \/\/    be accounted for in case shrinking of the heap happens.\n@@ -486,2 +485,3 @@\n-  bool do_full_collection(bool clear_all_soft_refs,\n-                          bool do_maximal_compaction);\n+  void do_full_collection(bool clear_all_soft_refs,\n+                          bool do_maximal_compaction,\n+                          size_t allocation_word_size);\n@@ -493,1 +493,1 @@\n-  bool upgrade_to_full_collection();\n+  void upgrade_to_full_collection();\n@@ -498,2 +498,1 @@\n-  HeapWord* satisfy_failed_allocation(size_t word_size,\n-                                      bool* succeeded);\n+  HeapWord* satisfy_failed_allocation(size_t word_size);\n@@ -505,1 +504,1 @@\n-  void prepare_for_mutator_after_full_collection();\n+  void prepare_for_mutator_after_full_collection(size_t allocation_word_size);\n@@ -514,2 +513,1 @@\n-                                             bool expect_null_mutator_alloc_region,\n-                                             bool* gc_succeeded);\n+                                             bool expect_null_mutator_alloc_region);\n@@ -564,1 +562,1 @@\n-  void resize_heap_if_necessary();\n+  void resize_heap_if_necessary(size_t allocation_word_size);\n@@ -750,3 +748,1 @@\n-  \/\/ followed by a by-policy upgrade to a full collection.  Returns\n-  \/\/ false if unable to do the collection due to the GC locker being\n-  \/\/ active, true otherwise.\n+  \/\/ followed by a by-policy upgrade to a full collection.\n@@ -755,1 +751,1 @@\n-  bool do_collection_pause_at_safepoint();\n+  void do_collection_pause_at_safepoint();\n@@ -978,4 +974,0 @@\n-  bool is_maximal_no_gc() const override {\n-    return _hrm.available() == 0;\n-  }\n-\n@@ -985,1 +977,1 @@\n-    return is_maximal_no_gc() && num_free_regions() == 0;\n+    return num_inactive_regions() == 0 && num_free_regions() == 0;\n@@ -988,2 +980,2 @@\n-  \/\/ The current number of regions in the heap.\n-  uint num_regions() const { return _hrm.length(); }\n+  \/\/ The number of inactive regions.\n+  uint num_inactive_regions() const { return _hrm.num_inactive_regions(); }\n@@ -991,3 +983,2 @@\n-  \/\/ The max number of regions reserved for the heap. Except for static array\n-  \/\/ sizing purposes you probably want to use max_regions().\n-  uint max_reserved_regions() const { return _hrm.reserved_length(); }\n+  \/\/ The current number of regions in the heap.\n+  uint num_committed_regions() const { return _hrm.num_committed_regions(); }\n@@ -995,2 +986,2 @@\n-  \/\/ Max number of regions that can be committed.\n-  uint max_regions() const { return _hrm.max_length(); }\n+  \/\/ The max number of regions reserved for the heap.\n+  uint max_num_regions() const { return _hrm.max_num_regions(); }\n@@ -1001,0 +992,3 @@\n+  \/\/ The number of regions that are not completely free.\n+  uint num_used_regions() const { return _hrm.num_used_regions(); }\n+\n@@ -1002,1 +996,1 @@\n-  uint num_free_or_available_regions() const { return num_free_regions() + _hrm.available(); }\n+  uint num_available_regions() const { return _hrm.num_available_regions(); }\n@@ -1008,2 +1002,0 @@\n-  \/\/ The number of regions that are not completely free.\n-  uint num_used_regions() const { return num_regions() - num_free_regions(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":24,"deletions":32,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  _committed_map.initialize(reserved_length());\n+  _committed_map.initialize(max_num_regions());\n@@ -194,1 +194,1 @@\n-  guarantee(num_regions <= available(),\n+  guarantee(num_regions <= num_inactive_regions(),\n@@ -259,1 +259,1 @@\n-  assert(length() >= num_regions, \"pre-condition\");\n+  assert(num_committed_regions() >= num_regions, \"pre-condition\");\n@@ -422,1 +422,1 @@\n-  if (available() >= 1) {\n+  if (num_inactive_regions() >= 1) {\n@@ -426,1 +426,1 @@\n-      for (uint i = 0; i < reserved_length(); i++) {\n+      for (uint i = 0; i < max_num_regions(); i++) {\n@@ -438,1 +438,1 @@\n-      for (uint i = 0; i < reserved_length(); i++) {\n+      for (uint i = 0; i < max_num_regions(); i++) {\n@@ -515,1 +515,1 @@\n-  } while (candidate == G1_NO_HRM_INDEX && range.end() < reserved_length());\n+  } while (candidate == G1_NO_HRM_INDEX && range.end() < max_num_regions());\n@@ -522,1 +522,1 @@\n-  if (num_regions > (num_free_regions() + available())) {\n+  if (num_regions > num_available_regions()) {\n@@ -526,1 +526,1 @@\n-  return find_contiguous_in_range(0, reserved_length(), num_regions);\n+  return find_contiguous_in_range(0, max_num_regions(), num_regions);\n@@ -542,1 +542,1 @@\n-  uint len = reserved_length();\n+  uint len = max_num_regions();\n@@ -558,1 +558,1 @@\n-  uint len = reserved_length();\n+  uint len = max_num_regions();\n@@ -627,2 +627,2 @@\n-  assert(length() > 0, \"the region sequence should not be empty\");\n-  assert(length() <= _next_highest_used_hrm_index, \"invariant\");\n+  assert(num_committed_regions() > 0, \"the region sequence should not be empty\");\n+  assert(num_committed_regions() <= _next_highest_used_hrm_index, \"invariant\");\n@@ -630,1 +630,1 @@\n-  assert(num_regions_to_remove < length(), \"We should never remove all regions\");\n+  assert(num_regions_to_remove < num_committed_regions(), \"We should never remove all regions\");\n@@ -703,9 +703,9 @@\n-  guarantee(length() <= _next_highest_used_hrm_index,\n-            \"invariant: _length: %u _next_highest_used_hrm_index: %u\",\n-            length(), _next_highest_used_hrm_index);\n-  guarantee(_next_highest_used_hrm_index <= reserved_length(),\n-            \"invariant: _next_highest_used_hrm_index: %u _max_length: %u\",\n-            _next_highest_used_hrm_index, reserved_length());\n-  guarantee(length() <= max_length(),\n-            \"invariant: committed regions: %u max_regions: %u\",\n-            length(), max_length());\n+  guarantee(num_committed_regions() <= _next_highest_used_hrm_index,\n+            \"invariant: committed regions: %u _next_highest_used_hrm_index: %u\",\n+            num_committed_regions(), _next_highest_used_hrm_index);\n+  guarantee(_next_highest_used_hrm_index <= max_num_regions(),\n+            \"invariant: _next_highest_used_hrm_index: %u max_num_regions: %u\",\n+            _next_highest_used_hrm_index, max_num_regions());\n+  guarantee(num_committed_regions() <= max_num_regions(),\n+            \"invariant: committed regions: %u max_num_regions: %u\",\n+            num_committed_regions(), max_num_regions());\n@@ -738,1 +738,1 @@\n-  for (uint i = _next_highest_used_hrm_index; i < reserved_length(); i++) {\n+  for (uint i = _next_highest_used_hrm_index; i < max_num_regions(); i++) {\n@@ -742,1 +742,1 @@\n-  guarantee(num_committed == length(), \"Found %u committed regions, but should be %u\", num_committed, length());\n+  guarantee(num_committed == num_committed_regions(), \"Found %u committed regions, but should be %u\", num_committed, num_committed_regions());\n@@ -791,1 +791,1 @@\n-      _worker_chunk_size((_hrm->reserved_length() + num_workers - 1) \/ num_workers),\n+      _worker_chunk_size((_hrm->max_num_regions() + num_workers - 1) \/ num_workers),\n@@ -816,1 +816,1 @@\n-    uint end = MIN2(start + _worker_chunk_size, _hrm->reserved_length());\n+    uint end = MIN2(start + _worker_chunk_size, _hrm->max_num_regions());\n@@ -842,1 +842,1 @@\n-  uint const num_workers = clamp(max_length(), 1u, workers->active_workers());\n+  uint const num_workers = clamp(max_num_regions(), 1u, workers->active_workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,2 +69,1 @@\n-\/\/ * max_length() returns the maximum number of regions the heap may commit.\n-\/\/ * reserved_length() returns the maximum number of regions the heap has reserved.\n+\/\/ * max_num_regions() returns the maximum number of regions the heap has reserved.\n@@ -225,0 +224,2 @@\n+  uint num_used_regions() const { return num_committed_regions() - num_free_regions(); }\n+\n@@ -233,2 +234,2 @@\n-  \/\/ Return the number of regions available (uncommitted) regions.\n-  uint available() const { return _max_available_regions - length(); }\n+  \/\/ Return the number of regions uncommitted or ready to be uncommitted.\n+  uint num_inactive_regions() const { return _max_available_regions - num_committed_regions(); }\n@@ -237,1 +238,1 @@\n-  uint length() const { return _committed_map.num_active(); }\n+  uint num_committed_regions() const { return _committed_map.num_active(); }\n@@ -240,1 +241,1 @@\n-  uint reserved_length() const { return (uint)_regions.length(); }\n+  uint max_num_regions() const { return (uint)_regions.length(); }\n@@ -242,2 +243,1 @@\n-  \/\/ Return maximum number of regions that heap can expand to.\n-  uint max_length() const { return reserved_length(); }\n+  uint num_available_regions() const { return num_free_regions() + num_inactive_regions(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -668,1 +668,1 @@\n-  heap->print_heap_before_gc();\n+  heap->print_before_gc();\n@@ -1185,1 +1185,1 @@\n-  heap->print_heap_after_gc();\n+  heap->print_after_gc();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -840,1 +840,1 @@\n-  StreamAutoIndentor indentor(st, 1);\n+  StreamIndentor si(st, 1);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,4 +70,1 @@\n-class GCMessage : public FormatBuffer<1024> {\n- public:\n-  bool is_before;\n-};\n+class GCLogMessage : public FormatBuffer<512> {};\n@@ -76,2 +73,1 @@\n-void EventLogBase<GCMessage>::print(outputStream* st, GCMessage& m) {\n-  st->print_cr(\"GC heap %s\", m.is_before ? \"before\" : \"after\");\n+void EventLogBase<GCLogMessage>::print(outputStream* st, GCLogMessage& m) {\n@@ -81,3 +77,3 @@\n-class GCHeapLog : public EventLogBase<GCMessage> {\n- private:\n-  void log_heap(CollectedHeap* heap, bool before);\n+class GCLog : public EventLogBase<GCLogMessage> {\n+ protected:\n+  virtual void log_usage(const CollectedHeap* heap, outputStream* st) const = 0;\n@@ -86,1 +82,1 @@\n-  GCHeapLog() : EventLogBase<GCMessage>(\"GC Heap History\", \"gc\") {}\n+  GCLog(const char* name, const char* handle) : EventLogBase<GCLogMessage>(name, handle) {}\n@@ -88,6 +84,1 @@\n-  void log_heap_before(CollectedHeap* heap) {\n-    log_heap(heap, true);\n-  }\n-  void log_heap_after(CollectedHeap* heap) {\n-    log_heap(heap, false);\n-  }\n+  void log_gc(const CollectedHeap* heap, GCWhen::Type when);\n@@ -96,1 +87,1 @@\n-void GCHeapLog::log_heap(CollectedHeap* heap, bool before) {\n+void GCLog::log_gc(const CollectedHeap* heap, GCWhen::Type when) {\n@@ -104,1 +95,1 @@\n-  _records[index].thread = nullptr; \/\/ Its the GC thread so it's not that interesting.\n+  _records[index].thread = nullptr; \/\/ It's the GC thread so it's not that interesting.\n@@ -106,1 +97,0 @@\n-  _records[index].data.is_before = before;\n@@ -109,5 +99,1 @@\n-  st.print_cr(\"{Heap %s GC invocations=%u (full %u):\",\n-                 before ? \"before\" : \"after\",\n-                 heap->total_collections(),\n-                 heap->total_full_collections());\n-\n+  st.print(\"{\");\n@@ -115,3 +101,3 @@\n-    StreamAutoIndentor indentor(&st, 1);\n-    heap->print_heap_on(&st);\n-    MetaspaceUtils::print_on(&st);\n+    heap->print_invocation_on(&st, _handle, when);\n+    StreamIndentor si(&st, 1);\n+    log_usage(heap, &st);\n@@ -119,1 +105,0 @@\n-\n@@ -123,0 +108,20 @@\n+class GCHeapLog : public GCLog {\n+ private:\n+  void log_usage(const CollectedHeap* heap, outputStream* st) const override {\n+    heap->print_heap_on(st);\n+  }\n+\n+ public:\n+  GCHeapLog() : GCLog(\"GC Heap Usage History\", \"heap\") {}\n+};\n+\n+class GCMetaspaceLog : public GCLog {\n+ private:\n+  void log_usage(const CollectedHeap* heap, outputStream* st) const override {\n+    MetaspaceUtils::print_on(st);\n+  }\n+\n+ public:\n+  GCMetaspaceLog() : GCLog(\"Metaspace Usage History\", \"metaspace\") {}\n+};\n+\n@@ -166,5 +171,3 @@\n-void CollectedHeap::print_heap_before_gc() {\n-  LogTarget(Debug, gc, heap) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print_cr(\"Heap before GC invocations=%u (full %u):\", total_collections(), total_full_collections());\n+void CollectedHeap::print_invocation_on(outputStream* st, const char* type, GCWhen::Type when) const {\n+  st->print_cr(\"%s %s invocations=%u (full %u):\", type, GCWhen::to_string(when), total_collections(), total_full_collections());\n+}\n@@ -172,1 +175,7 @@\n-    StreamAutoIndentor indentor(&ls, 1);\n+void CollectedHeap::print_relative_to_gc(GCWhen::Type when) const {\n+  \/\/ Print heap information\n+  LogTarget(Debug, gc, heap) lt_heap;\n+  if (lt_heap.is_enabled()) {\n+    LogStream ls(lt_heap);\n+    print_invocation_on(&ls, \"Heap\", when);\n+    StreamIndentor si(&ls, 1);\n@@ -174,1 +183,0 @@\n-    MetaspaceUtils::print_on(&ls);\n@@ -177,2 +185,2 @@\n-  if (_gc_heap_log != nullptr) {\n-    _gc_heap_log->log_heap_before(this);\n+  if (_heap_log != nullptr) {\n+    _heap_log->log_gc(this, when);\n@@ -180,9 +188,6 @@\n-}\n-\n-void CollectedHeap::print_heap_after_gc() {\n-  LogTarget(Debug, gc, heap) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print_cr(\"Heap after GC invocations=%u (full %u):\", total_collections(), total_full_collections());\n-    StreamAutoIndentor indentor(&ls, 1);\n-    print_heap_on(&ls);\n+  \/\/ Print metaspace information\n+  LogTarget(Debug, gc, metaspace) lt_metaspace;\n+  if (lt_metaspace.is_enabled()) {\n+    LogStream ls(lt_metaspace);\n+    print_invocation_on(&ls, \"Metaspace\", when);\n+    StreamIndentor indentor(&ls, 1);\n@@ -193,2 +198,2 @@\n-  if (_gc_heap_log != nullptr) {\n-    _gc_heap_log->log_heap_after(this);\n+  if (_metaspace_log != nullptr) {\n+    _metaspace_log->log_gc(this, when);\n@@ -198,0 +203,8 @@\n+void CollectedHeap::print_before_gc() const {\n+  print_relative_to_gc(GCWhen::BeforeGC);\n+}\n+\n+void CollectedHeap::print_after_gc() const {\n+  print_relative_to_gc(GCWhen::AfterGC);\n+}\n+\n@@ -305,1 +318,2 @@\n-    _gc_heap_log = new GCHeapLog();\n+    _metaspace_log = new GCMetaspaceLog();\n+    _heap_log = new GCHeapLog();\n@@ -307,1 +321,2 @@\n-    _gc_heap_log = nullptr;\n+    _metaspace_log = nullptr;\n+    _heap_log = nullptr;\n@@ -371,1 +386,1 @@\n-    if (op.prologue_succeeded()) {\n+    if (op.gc_succeeded()) {\n@@ -521,2 +536,2 @@\n-      if (retire_tlabs) {\n-        thread->tlab().retire(&stats);\n+      if (retire_tlabs || ZeroTLAB) {\n+        thread->retire_tlab(&stats);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":68,"deletions":53,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+class GCMemoryManager;\n+class GCMetaspaceLog;\n@@ -53,1 +55,0 @@\n-class GCMemoryManager;\n@@ -97,1 +98,2 @@\n-  GCHeapLog* _gc_heap_log;\n+  GCHeapLog*      _heap_log;\n+  GCMetaspaceLog* _metaspace_log;\n@@ -262,5 +264,0 @@\n-  \/\/ Return \"true\" if the part of the heap that allocates Java\n-  \/\/ objects has reached the maximal committed limit that it can\n-  \/\/ reach, without a garbage collection.\n-  virtual bool is_maximal_no_gc() const = 0;\n-\n@@ -428,0 +425,2 @@\n+  void print_relative_to_gc(GCWhen::Type when) const;\n+\n@@ -443,0 +442,2 @@\n+  void print_invocation_on(outputStream* st, const char* type, GCWhen::Type when) const;\n+\n@@ -462,2 +463,2 @@\n-  void print_heap_before_gc();\n-  void print_heap_after_gc();\n+  void print_before_gc() const;\n+  void print_after_gc() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -840,0 +840,3 @@\n+  \/\/ Reset TLAB usage\n+  ZHeap::heap()->reset_tlab_used();\n+\n@@ -948,0 +951,8 @@\n+ZRemembered* ZGenerationYoung::remembered() {\n+  return &_remembered;\n+}\n+\n+void ZGenerationYoung::remap_current_remset(ZRemsetTableIterator* iter) {\n+  _remembered.remap_current(iter);\n+}\n+\n@@ -1439,1 +1450,1 @@\n-  ZGenerationPagesParallelIterator _old_pages_parallel_iterator;\n+  ZRemsetTableIterator             _remset_table_iterator;\n@@ -1453,1 +1464,1 @@\n-      _old_pages_parallel_iterator(page_table, ZGenerationId::old, page_allocator),\n+      _remset_table_iterator(ZGeneration::young()->remembered(), false \/* previous *\/),\n@@ -1476,5 +1487,2 @@\n-      _old_pages_parallel_iterator.do_pages([&](ZPage* page) {\n-        \/\/ Visit all object fields that potentially pointing into young generation\n-        page->oops_do_current_remembered(ZBarrier::load_barrier_on_oop_field);\n-        return true;\n-      });\n+      \/\/ Visit all object fields that potentially pointing into young generation\n+      ZGeneration::young()->remap_current_remset(&_remset_table_iterator);\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -187,0 +188,11 @@\n+  void set_satisfied_from_cache_vmem_fast_medium(ZVirtualMemory vmem) {\n+    precond(_satisfied_from_cache_vmem.is_null());\n+    precond(_partial_vmems.is_empty());\n+    precond(ZPageSizeMediumEnabled);\n+    precond(vmem.size() >= ZPageSizeMediumMin);\n+    precond(vmem.size() <= ZPageSizeMediumMax);\n+    precond(is_power_of_2(vmem.size()));\n+\n+    _satisfied_from_cache_vmem = vmem;\n+  }\n+\n@@ -397,1 +409,1 @@\n-  const size_t               _size;\n+  const size_t               _requested_size;\n@@ -413,1 +425,1 @@\n-      _size(size),\n+      _requested_size(size),\n@@ -437,1 +449,10 @@\n-    return _size;\n+    if (_flags.fast_medium()) {\n+      \/\/ A fast medium allocation may have allocated less than the _size field\n+      const ZVirtualMemory vmem = _single_partition_allocation.allocation()->satisfied_from_cache_vmem();\n+      if (!vmem.is_null()) {\n+        \/\/ The allocation has been satisfied, return the satisfied size.\n+        return vmem.size();\n+      }\n+    }\n+\n+    return _requested_size;\n@@ -537,1 +558,1 @@\n-                 _size,\n+                 size(),\n@@ -612,3 +633,0 @@\n-    _last_commit(0.0),\n-    _last_uncommit(0.0),\n-    _to_uncommit(0),\n@@ -632,3 +650,1 @@\n-    _last_commit = os::elapsedTime();\n-    _last_uncommit = 0;\n-    _cache.reset_min();\n+    _uncommitter.cancel_uncommit_cycle();\n@@ -743,57 +759,2 @@\n-size_t ZPartition::uncommit(uint64_t* timeout, uintx delay) {\n-  ZArray<ZVirtualMemory> flushed_vmems;\n-  size_t flushed = 0;\n-\n-  {\n-    \/\/ We need to join the suspendible thread set while manipulating capacity\n-    \/\/ and used, to make sure GC safepoints will have a consistent view.\n-    SuspendibleThreadSetJoiner sts_joiner;\n-    ZLocker<ZLock> locker(&_page_allocator->_lock);\n-\n-    const double now = os::elapsedTime();\n-    const double time_since_last_commit = std::floor(now - _last_commit);\n-    const double time_since_last_uncommit = std::floor(now - _last_uncommit);\n-\n-    if (time_since_last_commit < double(delay)) {\n-      \/\/ We have committed within the delay, stop uncommitting.\n-      *timeout = uint64_t(double(delay) - time_since_last_commit);\n-      return 0;\n-    }\n-\n-    \/\/ We flush out and uncommit chunks at a time (~0.8% of the max capacity,\n-    \/\/ but at least one granule and at most 256M), in case demand for memory\n-    \/\/ increases while we are uncommitting.\n-    const size_t limit_upper_bound = MAX2(ZGranuleSize, align_down(256 * M \/ ZNUMA::count(), ZGranuleSize));\n-    const size_t limit = MIN2(align_up(_current_max_capacity >> 7, ZGranuleSize), limit_upper_bound);\n-\n-    if (limit == 0) {\n-      \/\/ This may occur if the current max capacity for this partition is 0\n-\n-      \/\/ Set timeout to delay\n-      *timeout = delay;\n-      return 0;\n-    }\n-\n-    if (time_since_last_uncommit < double(delay)) {\n-      \/\/ We are in the uncommit phase\n-      const size_t num_uncommits_left = _to_uncommit \/ limit;\n-      const double time_left = double(delay) - time_since_last_uncommit;\n-      if (time_left < *timeout * num_uncommits_left) {\n-        \/\/ Running out of time, speed up.\n-        uint64_t new_timeout = uint64_t(std::floor(time_left \/ double(num_uncommits_left + 1)));\n-        *timeout = new_timeout;\n-      }\n-    } else {\n-      \/\/ We are about to start uncommitting\n-      _to_uncommit = _cache.reset_min();\n-      _last_uncommit = now;\n-\n-      const size_t split = _to_uncommit \/ limit + 1;\n-      uint64_t new_timeout = delay \/ split;\n-      *timeout = new_timeout;\n-    }\n-\n-    \/\/ Never uncommit below min capacity.\n-    const size_t retain = MAX2(_used, _min_capacity);\n-    const size_t release = _capacity - retain;\n-    const size_t flush = MIN3(release, limit, _to_uncommit);\n+bool ZPartition::claim_capacity_fast_medium(ZMemoryAllocation* allocation) {\n+  precond(ZPageSizeMediumEnabled);\n@@ -801,4 +762,4 @@\n-    if (flush == 0) {\n-      \/\/ Nothing to flush\n-      return 0;\n-    }\n+  \/\/ Try to allocate a medium page sized contiguous vmem\n+  const size_t min_size = ZPageSizeMediumMin;\n+  const size_t max_size = ZStressFastMediumPageAllocation ? min_size : ZPageSizeMediumMax;\n+  ZVirtualMemory vmem = _cache.remove_contiguous_power_of_2(min_size, max_size);\n@@ -806,10 +767,3 @@\n-    \/\/ Flush memory from the mapped cache to uncommit\n-    flushed = _cache.remove_from_min(flush, &flushed_vmems);\n-    if (flushed == 0) {\n-      \/\/ Nothing flushed\n-      return 0;\n-    }\n-\n-    \/\/ Record flushed memory as claimed and how much we've flushed for this partition\n-    Atomic::add(&_claimed, flushed);\n-    _to_uncommit -= flushed;\n+  if (vmem.is_null()) {\n+    \/\/ Failed to find a contiguous vmem\n+    return false;\n@@ -818,7 +772,2 @@\n-  \/\/ Unmap and uncommit flushed memory\n-  for (const ZVirtualMemory vmem : flushed_vmems) {\n-    unmap_virtual(vmem);\n-    uncommit_physical(vmem);\n-    free_physical(vmem);\n-    free_virtual(vmem);\n-  }\n+  \/\/ Found a satisfying vmem in the cache\n+  allocation->set_satisfied_from_cache_vmem_fast_medium(vmem);\n@@ -826,3 +775,2 @@\n-  {\n-    SuspendibleThreadSetJoiner sts_joiner;\n-    ZLocker<ZLock> locker(&_page_allocator->_lock);\n+  \/\/ Associate the allocation with this partition.\n+  allocation->set_partition(this);\n@@ -830,4 +778,2 @@\n-    \/\/ Adjust claimed and capacity to reflect the uncommit\n-    Atomic::sub(&_claimed, flushed);\n-    decrease_capacity(flushed, false \/* set_max_capacity *\/);\n-  }\n+  \/\/ Updated used statistics\n+  increase_used(vmem.size());\n@@ -835,1 +781,2 @@\n-  return flushed;\n+  \/\/ Success\n+  return true;\n@@ -1163,1 +1110,1 @@\n-  StreamAutoIndentor indentor(st, 1);\n+  StreamIndentor si(st, 1);\n@@ -1174,1 +1121,1 @@\n-  StreamAutoIndentor indentor(st, 1);\n+  StreamIndentor si(st, 1);\n@@ -1281,2 +1228,6 @@\n-  if (ZPageSizeMedium > 0) {\n-    log_info_p(gc, init)(\"Medium Page Size: %zuM\", ZPageSizeMedium \/ M);\n+  if (ZPageSizeMediumEnabled) {\n+    if (ZPageSizeMediumMin == ZPageSizeMediumMax) {\n+      log_info_p(gc, init)(\"Page Size Medium: %zuM\", ZPageSizeMediumMax \/ M);\n+    } else {\n+      log_info_p(gc, init)(\"Page Size Medium: Range [%zuM, %zuM]\", ZPageSizeMediumMin \/ M, ZPageSizeMediumMax \/ M);\n+    }\n@@ -1462,2 +1413,2 @@\n-    ZStatInc(ZCounterMutatorAllocationRate, size);\n-    ZStatMutatorAllocRate::sample_allocation(size);\n+    ZStatInc(ZCounterMutatorAllocationRate, page->size());\n+    ZStatMutatorAllocRate::sample_allocation(page->size());\n@@ -1591,0 +1542,6 @@\n+  \/\/ Fast medium allocation\n+  if (allocation->flags().fast_medium()) {\n+    return claim_capacity_fast_medium(allocation);\n+  }\n+\n+  \/\/ Round robin single-partition claiming\n@@ -1595,2 +1552,0 @@\n-  \/\/ Round robin single-partition claiming\n-\n@@ -1622,0 +1577,17 @@\n+bool ZPageAllocator::claim_capacity_fast_medium(ZPageAllocation* allocation) {\n+  const uint32_t start_node = allocation->initiating_numa_id();\n+  const uint32_t numa_nodes = ZNUMA::count();\n+\n+  for (uint32_t i = 0; i < numa_nodes; ++i) {\n+    const uint32_t numa_id = (start_node + i) % numa_nodes;\n+    ZPartition& partition = _partitions.get(numa_id);\n+    ZSinglePartitionAllocation* single_partition_allocation = allocation->single_partition_allocation();\n+\n+    if (partition.claim_capacity_fast_medium(single_partition_allocation->allocation())) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n@@ -2079,0 +2051,2 @@\n+  assert(allocation->size() == vmem.size(), \"Must be %zu == %zu\", allocation->size(), vmem.size());\n+\n@@ -2418,1 +2392,1 @@\n-  StreamAutoIndentor indentor(st, 1);\n+  StreamIndentor si(st, 1);\n@@ -2451,1 +2425,1 @@\n-  StreamAutoIndentor indentor(st, 1);\n+  StreamIndentor si(st, 1);\n@@ -2472,2 +2446,0 @@\n-  uint64_t timeout;\n-  size_t flushed, uncommitted = 0;\n@@ -2476,11 +2448,2 @@\n-    partition->_cache.reset_min();\n-    do {\n-      flushed = partition->uncommit(&timeout, 0);\n-      uncommitted += flushed;\n-    } while (flushed > 0);\n-  }\n-  if (uncommitted > 0) {\n-    EventZUncommit event;\n-    log_info(gc, heap)(\"Uncommitted (cleanup): %zuM(%.0f%%)\",\n-      uncommitted \/ M, percent_of(uncommitted, ZHeap::heap()->max_capacity()));\n-    event.commit(uncommitted);\n+    partition->_cache.reset_min_size_watermark();\n+    partition->_uncommitter.force_uncommit();\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":82,"deletions":119,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  friend class ZUncommitter;\n@@ -71,3 +72,0 @@\n-  double                _last_commit;\n-  double                _last_uncommit;\n-  size_t                _to_uncommit;\n@@ -104,2 +102,1 @@\n-\n-  size_t uncommit(uint64_t* timeout, uintx delay);\n+  bool claim_capacity_fast_medium(ZMemoryAllocation* allocation);\n@@ -177,0 +174,1 @@\n+  bool claim_capacity_fast_medium(ZPageAllocation* allocation);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/z\/zGlobals.hpp\"\n@@ -27,0 +28,2 @@\n+#include \"gc\/z\/zMappedCache.hpp\"\n+#include \"gc\/z\/zNUMA.inline.hpp\"\n@@ -31,0 +34,6 @@\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+#include <cmath>\n@@ -38,1 +47,9 @@\n-    _stop(false) {\n+    _stop(false),\n+    _cancel_time(0.0),\n+    _next_cycle_timeout(0),\n+    _next_uncommit_timeout(0),\n+    _cycle_start(0.0),\n+    _to_uncommit(0),\n+    _uncommitted(0),\n+    _force_uncommit(false),\n+    _force_uncommit_lock() {\n@@ -49,3 +66,21 @@\n-  if (!_stop && timeout > 0) {\n-    log_debug(gc, heap)(\"Uncommitter (%u) Timeout: \" UINT64_FORMAT \"s\", _id, timeout);\n-    _lock.wait(timeout * MILLIUNITS);\n+  if (!_stop && timeout > 0 && !_force_uncommit) {\n+    if (!uncommit_cycle_is_finished()) {\n+      log_trace(gc, heap)(\"Uncommitter (%u) Timeout: \" UINT64_FORMAT \"ms left to uncommit: \"\n+                          EXACTFMT, _id, timeout, EXACTFMTARGS(_to_uncommit));\n+    } else {\n+      log_debug(gc, heap)(\"Uncommitter (%u) Timeout: \" UINT64_FORMAT \"ms\", _id, timeout);\n+    }\n+\n+    double now = os::elapsedTime();\n+    const double wait_until = now + double(timeout) \/ MILLIUNITS;\n+    do {\n+      const uint64_t remaining_timeout_ms = to_millis(wait_until - now);\n+      if (remaining_timeout_ms == 0) {\n+        \/\/ Less than a millisecond left to wait, just return early\n+        break;\n+      }\n+\n+      \/\/ Wait\n+      _lock.wait(remaining_timeout_ms);\n+      now = os::elapsedTime();\n+    } while (!_stop && now < wait_until && !_force_uncommit);\n@@ -62,0 +97,13 @@\n+void ZUncommitter::update_statistics(size_t uncommitted, Ticks start, Tickspan* accumulated_time) const {\n+  \/\/ Update counter\n+  ZStatInc(ZCounterUncommit, uncommitted);\n+\n+  Ticks end = Ticks::now();\n+\n+  \/\/ Send event\n+  EventZUncommit::commit(start, end, uncommitted);\n+\n+  \/\/ Track accumulated time\n+  *accumulated_time += end - start;\n+}\n+\n@@ -63,1 +111,8 @@\n-  uint64_t timeout = 0;\n+  \/\/ Initialize first cycle timeout\n+  _next_cycle_timeout = to_millis(ZUncommitDelay);\n+\n+  while (wait(_next_cycle_timeout)) {\n+    \/\/ Counters for event and statistics\n+    Ticks start = Ticks::now();\n+    size_t uncommitted_since_last_timeout = 0;\n+    Tickspan accumulated_time;\n@@ -65,3 +120,4 @@\n-  while (wait(timeout)) {\n-    EventZUncommit event;\n-    size_t total_uncommitted = 0;\n+    if (!activate_uncommit_cycle()) {\n+      \/\/ We failed activating a new cycle, continue until next cycle\n+      continue;\n+    }\n@@ -71,2 +127,8 @@\n-      const size_t uncommitted = _partition->uncommit(&timeout, ZUncommitDelay);\n-      if (uncommitted == 0) {\n+      const size_t uncommitted = uncommit();\n+\n+      \/\/ Update uncommitted counter\n+      uncommitted_since_last_timeout += uncommitted;\n+\n+      \/\/ 'uncommitted == 0' is a proxy for uncommit_cycle_is_canceled() without\n+      \/\/ having to take the page allocator lock\n+      if (uncommitted == 0 || uncommit_cycle_is_finished()) {\n@@ -77,1 +139,11 @@\n-      total_uncommitted += uncommitted;\n+      if (_next_uncommit_timeout != 0) {\n+        \/\/ Update statistics\n+        update_statistics(uncommitted_since_last_timeout, start, &accumulated_time);\n+\n+        \/\/ Wait until next uncommit\n+        wait(_next_uncommit_timeout);\n+\n+        \/\/ Reset event and statistics counters\n+        start = Ticks::now();\n+        uncommitted_since_last_timeout = 0;\n+      }\n@@ -80,5 +152,10 @@\n-    if (total_uncommitted > 0) {\n-      \/\/ Update statistics\n-      ZStatInc(ZCounterUncommit, total_uncommitted);\n-      log_info(gc, heap)(\"Uncommitter (%u) Uncommitted: %zuM(%.0f%%)\",\n-                         _id, total_uncommitted \/ M, percent_of(total_uncommitted, ZHeap::heap()->max_capacity()));\n+    if (_uncommitted > 0) {\n+      if (uncommitted_since_last_timeout > 0) {\n+        \/\/ Update statistics\n+        update_statistics(uncommitted_since_last_timeout, start, &accumulated_time);\n+      }\n+\n+      log_info(gc, heap)(\"Uncommitter (%u) Uncommitted: %zuM(%.0f%%) in %.3fms\",\n+                         _id, _uncommitted \/ M, percent_of(_uncommitted, ZHeap::heap()->max_capacity()),\n+                         accumulated_time.seconds() * MILLIUNITS);\n+    }\n@@ -86,2 +163,3 @@\n-      \/\/ Send event\n-      event.commit(total_uncommitted);\n+    if (!should_continue()) {\n+      \/\/ We are terminating\n+      return;\n@@ -89,0 +167,2 @@\n+\n+    deactivate_uncommit_cycle();\n@@ -97,0 +177,279 @@\n+\n+void ZUncommitter::reset_uncommit_cycle() {\n+  _to_uncommit = 0;\n+  _uncommitted = 0;\n+  _cycle_start = 0.0;\n+  _cancel_time = 0.0;\n+\n+  postcond(uncommit_cycle_is_finished());\n+  postcond(!uncommit_cycle_is_canceled());\n+  postcond(!uncommit_cycle_is_active());\n+}\n+\n+void ZUncommitter::deactivate_uncommit_cycle() {\n+  ZLocker<ZLock> locker(&_partition->_page_allocator->_lock);\n+\n+  precond(uncommit_cycle_is_active());\n+  precond(uncommit_cycle_is_finished() || uncommit_cycle_is_canceled());\n+\n+  \/\/ Update the next timeout\n+  if (uncommit_cycle_is_canceled()) {\n+    update_next_cycle_timeout_on_cancel();\n+  } else {\n+    update_next_cycle_timeout_on_finish();\n+  }\n+\n+  if (uncommit_cycle_is_finished()) {\n+    finish_force_uncommit();\n+  }\n+\n+  \/\/ Reset the cycle\n+  reset_uncommit_cycle();\n+}\n+\n+bool ZUncommitter::activate_uncommit_cycle() {\n+  ZLocker<ZLock> locker(&_partition->_page_allocator->_lock);\n+\n+  precond(uncommit_cycle_is_finished());\n+  precond(!uncommit_cycle_is_active());\n+\n+  if (uncommit_cycle_is_canceled()) {\n+    \/\/ We were canceled before we managed to activate, update the timeout\n+    update_next_cycle_timeout_on_cancel();\n+\n+    \/\/ Reset the cycle\n+    reset_uncommit_cycle();\n+\n+    return false;\n+  }\n+\n+  ZMappedCache* const cache = &_partition->_cache;\n+\n+  \/\/ Claim and reset the cache cycle tracking and register the cycle start time.\n+  _cycle_start = os::elapsedTime();\n+\n+  \/\/ Read watermark from cache\n+  const size_t uncommit_watermark = cache->min_size_watermark();\n+\n+  \/\/ Keep 10% as a headroom\n+  const size_t to_uncommit = align_up(size_t(double(uncommit_watermark) * 0.9), ZGranuleSize);\n+\n+  \/\/ Never uncommit below min capacity\n+  const size_t uncommit_limit = _partition->_capacity - _partition->_min_capacity;\n+\n+  _to_uncommit = MIN2(uncommit_limit, to_uncommit);\n+  _uncommitted = 0;\n+\n+  \/\/ Reset watermark for next uncommit cycle\n+  cache->reset_min_size_watermark();\n+\n+  postcond(is_aligned(_to_uncommit, ZGranuleSize));\n+\n+  return true;\n+}\n+\n+uint64_t ZUncommitter::to_millis(double seconds) const {\n+  return uint64_t(std::floor(seconds * double(MILLIUNITS)));\n+}\n+\n+void ZUncommitter::update_next_cycle_timeout(double from_time) {\n+  const double now = os::elapsedTime();\n+\n+  if (now < from_time + double(ZUncommitDelay)) {\n+    _next_cycle_timeout = to_millis(ZUncommitDelay) - to_millis(now - from_time);\n+  } else {\n+    \/\/ ZUncommitDelay has already expired\n+    _next_cycle_timeout = 0;\n+  }\n+}\n+\n+void ZUncommitter::update_next_cycle_timeout_on_cancel() {\n+  precond(uncommit_cycle_is_canceled());\n+\n+  update_next_cycle_timeout(_cancel_time);\n+\n+  \/\/ Skip logging if there is no delay\n+  if (ZUncommitDelay > 0) {\n+    log_debug(gc, heap)(\"Uncommitter (%u) Cancel Next Cycle Timeout: \" UINT64_FORMAT \"ms\",\n+                        _id, _next_cycle_timeout);\n+  }\n+}\n+\n+void ZUncommitter::update_next_cycle_timeout_on_finish() {\n+  precond(uncommit_cycle_is_active());\n+  precond(uncommit_cycle_is_finished());\n+\n+  update_next_cycle_timeout(_cycle_start);\n+\n+  \/\/ Skip logging if there is no delay\n+  if (ZUncommitDelay > 0) {\n+    log_debug(gc, heap)(\"Uncommitter (%u) Finish Next Cycle Timeout: \" UINT64_FORMAT \"ms\",\n+                        _id, _next_cycle_timeout);\n+  }\n+}\n+\n+void ZUncommitter::cancel_uncommit_cycle() {\n+  \/\/ Reset the cache cycle tracking and register the cancel time.\n+  _partition->_cache.reset_min_size_watermark();\n+  _cancel_time = os::elapsedTime();\n+}\n+\n+void ZUncommitter::register_uncommit(size_t size) {\n+  precond(uncommit_cycle_is_active());\n+  precond(size > 0);\n+  precond(size <= _to_uncommit);\n+  precond(is_aligned(size, ZGranuleSize));\n+\n+  _to_uncommit -= size;\n+  _uncommitted += size;\n+\n+  if (uncommit_cycle_is_canceled()) {\n+    \/\/ Uncommit cycle got canceled while uncommitting.\n+    return;\n+  }\n+\n+  if (uncommit_cycle_is_finished()) {\n+    \/\/ Everything has been uncommitted.\n+    return;\n+  }\n+\n+  const double now = os::elapsedTime();\n+  const double time_since_start = now - _cycle_start;\n+\n+  if (time_since_start == 0.0) {\n+    \/\/ Handle degenerate case where no time has elapsed.\n+    _next_uncommit_timeout = 0;\n+    return;\n+  }\n+\n+  const double uncommit_rate = double(_uncommitted) \/ time_since_start;\n+  const double time_to_complete = double(_to_uncommit) \/ uncommit_rate;\n+  const double time_left = double(ZUncommitDelay) - time_since_start;\n+\n+  if (time_left < time_to_complete) {\n+    \/\/ Too slow, work as fast as we can.\n+    _next_uncommit_timeout = 0;\n+    return;\n+  }\n+\n+  const size_t uncommits_remaining_estimate = _to_uncommit \/ size + 1;\n+  const uint64_t millis_left_rounded_down = to_millis(time_left);\n+\n+  if (uncommits_remaining_estimate < millis_left_rounded_down) {\n+    \/\/ We have at least one millisecond per uncommit, spread them out.\n+    _next_uncommit_timeout = millis_left_rounded_down \/ uncommits_remaining_estimate;\n+    return;\n+  }\n+\n+  \/\/ Randomly distribute the extra time, one millisecond at a time.\n+  const double extra_time = time_left - time_to_complete;\n+  const double random = double(uint32_t(os::random())) \/ double(std::numeric_limits<uint32_t>::max());\n+\n+  _next_uncommit_timeout = random < (extra_time \/ time_left) ? 1 : 0;\n+}\n+\n+bool ZUncommitter::uncommit_cycle_is_finished() const {\n+  return _to_uncommit == 0;\n+}\n+\n+bool ZUncommitter::uncommit_cycle_is_active() const {\n+  return _cycle_start != 0.0;\n+}\n+\n+bool ZUncommitter::uncommit_cycle_is_canceled() const {\n+  return _cancel_time != 0.0;\n+}\n+\n+size_t ZUncommitter::uncommit() {\n+  precond(uncommit_cycle_is_active());\n+\n+  ZArray<ZVirtualMemory> flushed_vmems;\n+  size_t flushed = 0;\n+\n+  {\n+    \/\/ We need to join the suspendible thread set while manipulating capacity\n+    \/\/ and used, to make sure GC safepoints will have a consistent view.\n+    SuspendibleThreadSetJoiner sts_joiner;\n+    ZLocker<ZLock> locker(&_partition->_page_allocator->_lock);\n+\n+    if (uncommit_cycle_is_canceled()) {\n+      \/\/ We have committed within the delay, stop uncommitting.\n+      return 0;\n+    }\n+\n+    \/\/ We flush out and uncommit chunks at a time (~0.8% of the max capacity,\n+    \/\/ but at least one granule and at most 256M), in case demand for memory\n+    \/\/ increases while we are uncommitting.\n+    const size_t current_max_capacity = _partition->_current_max_capacity;\n+    const size_t limit_upper_bound = MAX2(ZGranuleSize, align_down(256 * M \/ ZNUMA::count(), ZGranuleSize));\n+    const size_t limit = MIN2(align_up(current_max_capacity >> 7, ZGranuleSize), limit_upper_bound);\n+\n+    ZMappedCache& cache = _partition->_cache;\n+\n+    \/\/ Never uncommit more than the current uncommit watermark,\n+    \/\/ (adjusted by what has already been uncommitted).\n+    const size_t allowed_to_uncommit = MAX2(cache.min_size_watermark(), _uncommitted) - _uncommitted;\n+    const size_t to_uncommit = MIN2(_to_uncommit, allowed_to_uncommit);\n+\n+    \/\/ Never uncommit below min capacity.\n+    const size_t retain = MAX2(_partition->_used, _partition->_min_capacity);\n+    const size_t release = _partition->_capacity - retain;\n+    const size_t flush = MIN3(release, limit, to_uncommit);\n+\n+    \/\/ Flush memory from the mapped cache for uncommit\n+    flushed = cache.remove_for_uncommit(flush, &flushed_vmems);\n+    if (flushed == 0) {\n+      \/\/ Nothing flushed\n+      cancel_uncommit_cycle();\n+      return 0;\n+    }\n+\n+    \/\/ Record flushed memory as claimed and how much we've flushed for this partition\n+    Atomic::add(&_partition->_claimed, flushed);\n+  }\n+\n+  \/\/ Unmap and uncommit flushed memory\n+  for (const ZVirtualMemory vmem : flushed_vmems) {\n+    _partition->unmap_virtual(vmem);\n+    _partition->uncommit_physical(vmem);\n+    _partition->free_physical(vmem);\n+    _partition->free_virtual(vmem);\n+  }\n+\n+  {\n+    SuspendibleThreadSetJoiner sts_joiner;\n+    ZLocker<ZLock> locker(&_partition->_page_allocator->_lock);\n+\n+    \/\/ Adjust claimed and capacity to reflect the uncommit\n+    Atomic::sub(&_partition->_claimed, flushed);\n+    _partition->decrease_capacity(flushed, false \/* set_max_capacity *\/);\n+    register_uncommit(flushed);\n+  }\n+\n+  return flushed;\n+}\n+\n+void ZUncommitter::force_uncommit() {\n+  {\n+    ZLocker<ZConditionLock> locker(&_lock);\n+    _force_uncommit = true;\n+    _lock.notify_all();\n+  }\n+\n+  wait_for_finish_force_uncommit();\n+}\n+\n+void ZUncommitter::wait_for_finish_force_uncommit() {\n+  ZLocker<ZConditionLock> locker(&_force_uncommit_lock);\n+  while (_force_uncommit) {\n+    _force_uncommit_lock.wait();\n+  }\n+}\n+\n+void ZUncommitter::finish_force_uncommit() {\n+  if (_force_uncommit) {\n+    ZLocker<ZConditionLock> locker(&_force_uncommit_lock);\n+    _force_uncommit = false;\n+    _force_uncommit_lock.notify_all();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zUncommitter.cpp","additions":377,"deletions":18,"binary":false,"changes":395,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -38,0 +39,8 @@\n+  double                 _cancel_time;\n+  uint64_t               _next_cycle_timeout;\n+  uint64_t               _next_uncommit_timeout;\n+  double                 _cycle_start;\n+  size_t                 _to_uncommit;\n+  size_t                 _uncommitted;\n+  bool                   _force_uncommit;\n+  mutable ZConditionLock _force_uncommit_lock;\n@@ -42,0 +51,22 @@\n+  uint64_t to_millis(double seconds) const;\n+\n+  void update_next_cycle_timeout(double from_time);\n+  void update_next_cycle_timeout_on_cancel();\n+  void update_next_cycle_timeout_on_finish();\n+\n+  void reset_uncommit_cycle();\n+  void deactivate_uncommit_cycle();\n+  bool activate_uncommit_cycle();\n+  void register_uncommit(size_t size);\n+\n+  bool uncommit_cycle_is_finished() const;\n+  bool uncommit_cycle_is_active() const;\n+  bool uncommit_cycle_is_canceled() const;\n+\n+  size_t uncommit();\n+\n+  void update_statistics(size_t uncommitted, Ticks start, Tickspan* accumulated_time) const;\n+\n+  void wait_for_finish_force_uncommit();\n+  void finish_force_uncommit();\n+\n@@ -48,0 +79,4 @@\n+\n+  void cancel_uncommit_cycle();\n+\n+  void force_uncommit();\n","filename":"src\/hotspot\/share\/gc\/z\/zUncommitter.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -304,0 +304,3 @@\n+JNIEXPORT jobject JNICALL\n+JVM_CreateThreadSnapshot(JNIEnv* env, jobject thread);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"jfr\/support\/jfrKlassExtension.hpp\"\n@@ -40,0 +42,4 @@\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -41,0 +47,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -78,0 +85,16 @@\n+void Jfr::on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS) {\n+  if (IS_EVENT_OR_HOST_KLASS(ik)) {\n+    JfrEventClassTransformer::on_klass_creation(ik, parser, THREAD);\n+    return;\n+  }\n+  if (JfrMethodTracer::in_use()) {\n+    JfrMethodTracer::on_klass_creation(ik, parser, THREAD);\n+  }\n+}\n+\n+void Jfr::on_klass_redefinition(const InstanceKlass* ik, Thread* thread) {\n+  assert(JfrMethodTracer::in_use(), \"invariant\");\n+  JfrMethodTracer::on_klass_redefinition(ik, thread);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"jni.h\"\n@@ -37,0 +36,1 @@\n+class ClassFileParser;\n@@ -38,0 +38,1 @@\n+class InstanceKlass;\n@@ -39,0 +40,1 @@\n+struct JavaVMOption;\n@@ -61,0 +63,2 @@\n+  static void on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS);\n+  static void on_klass_redefinition(const InstanceKlass* ik, Thread* thread);\n@@ -77,0 +81,2 @@\n+  static bool has_sample_request(JavaThread* jt);\n+  static void check_and_process_sample_request(JavaThread* jt);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n@@ -52,0 +53,1 @@\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n@@ -171,0 +173,5 @@\n+JVM_ENTRY_NO_ENV(void, jfr_set_cpu_throttle(JNIEnv* env, jclass jvm, jdouble rate, jboolean auto_adapt))\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, rate > 0);\n+  JfrCPUTimeThreadSampling::set_rate(rate, auto_adapt == JNI_TRUE);\n+JVM_END\n+\n@@ -280,1 +287,1 @@\n-    JfrThreadSampling::set_java_sample_period(periodMillis);\n+    JfrThreadSampler::set_java_sample_period(periodMillis);\n@@ -282,1 +289,1 @@\n-    JfrThreadSampling::set_native_sample_period(periodMillis);\n+    JfrThreadSampler::set_native_sample_period(periodMillis);\n@@ -444,0 +451,8 @@\n+\n+JVM_ENTRY_NO_ENV(jlongArray, jfr_set_method_trace_filters(JNIEnv* env, jclass jvm, jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modifications))\n+  return JfrMethodTracer::set_filters(env, classes, methods, annotations, modifications, thread);\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(jlongArray, jfr_drain_stale_method_tracer_ids(JNIEnv* env, jclass jvm))\n+  return JfrMethodTracer::drain_stale_class_ids(thread);\n+JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,0 +132,2 @@\n+void JNICALL jfr_set_cpu_throttle(JNIEnv* env, jclass jvm, jdouble rate, jboolean auto_adapt);\n+\n@@ -174,0 +176,4 @@\n+jlongArray JNICALL jfr_set_method_trace_filters(JNIEnv* env, jclass jvm, jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modifications);\n+\n+jlongArray JNICALL jfr_drain_stale_method_tracer_ids(JNIEnv* env, jclass);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+      (char*)\"setCPUThrottle\", (char*)\"(DZ)V\", (void*)jfr_set_cpu_throttle,\n@@ -105,1 +106,3 @@\n-      (char*)\"isProduct\", (char*)\"()Z\", (void*)jfr_is_product\n+      (char*)\"isProduct\", (char*)\"()Z\", (void*)jfr_is_product,\n+      (char*)\"setMethodTraceFilters\", (char*)\"([Ljava\/lang\/String;[Ljava\/lang\/String;[Ljava\/lang\/String;[I)[J\", (void*)jfr_set_method_trace_filters,\n+      (char*)\"drainStaleMethodTracerIds\", (char*)\"()[J\", (void*)jfr_drain_stale_method_tracer_ids\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classFileStream.hpp\"\n@@ -26,0 +27,1 @@\n+#include \"classfile\/moduleEntry.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n@@ -31,0 +34,1 @@\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n@@ -39,0 +43,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -40,0 +45,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -52,0 +58,4 @@\n+static Symbol* on_method_trace_sym = nullptr;\n+static Symbol* on_method_trace_sig_sym = nullptr;\n+static Symbol* publish_method_timers_for_klass_sym = nullptr;\n+static Symbol* publish_method_timers_for_klass_sig_sym = nullptr;\n@@ -67,0 +77,5 @@\n+    on_method_trace_sym = SymbolTable::new_permanent_symbol(\"onMethodTrace\");\n+    on_method_trace_sig_sym = SymbolTable::new_permanent_symbol(\"(Ljava\/lang\/Module;Ljava\/lang\/ClassLoader;Ljava\/lang\/String;[B[J[Ljava\/lang\/String;[Ljava\/lang\/String;[I)[B\");\n+    publish_method_timers_for_klass_sym = SymbolTable::new_permanent_symbol(\"publishMethodTimersForClass\");\n+    publish_method_timers_for_klass_sig_sym = SymbolTable::new_permanent_symbol(\"(J)V\");\n+    initialized = publish_method_timers_for_klass_sig_sym != nullptr;\n@@ -240,0 +255,100 @@\n+\n+\/\/ Caller needs ResourceMark\n+ClassFileStream* JfrUpcalls::on_method_trace(InstanceKlass* ik, const ClassFileStream* stream, GrowableArray<JfrTracedMethod>* methods, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  assert(stream != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n+  assert(methods->is_nonempty(), \"invariant\");\n+  initialize(THREAD);\n+  Klass* klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, CHECK_NULL);\n+  assert(klass != nullptr, \"invariant\");\n+\n+  HandleMark hm(THREAD);\n+\n+  ModuleEntry* module_entry = ik->module();\n+  oop module = nullptr;\n+  if (module_entry != nullptr) {\n+    module = module_entry->module();\n+  }\n+  instanceHandle module_handle(THREAD, (instanceOop)module);\n+\n+  \/\/ ClassLoader\n+  oop class_loader = ik->class_loader();\n+  instanceHandle class_loader_handle(THREAD, (instanceOop)class_loader);\n+\n+  \/\/ String class name\n+  Handle class_name_h = java_lang_String::create_from_symbol(ik->name(), CHECK_NULL);\n+\n+  \/\/ new byte[]\n+  int size = stream->length();\n+  typeArrayOop bytecode_array = oopFactory::new_byteArray(size, CHECK_NULL);\n+  typeArrayHandle h_bytecode_array(THREAD, bytecode_array);\n+\n+  \/\/ Copy ClassFileStream bytes to byte[]\n+  const jbyte* src = reinterpret_cast<const jbyte*>(stream->buffer());\n+  ArrayAccess<>::arraycopy_from_native(src, bytecode_array, typeArrayOopDesc::element_offset<jbyte>(0), size);\n+\n+  int method_count = methods->length();\n+\n+  \/\/ new long[method_count]\n+  typeArrayOop id_array = oopFactory::new_longArray(method_count, CHECK_NULL);\n+  typeArrayHandle h_id_array(THREAD, id_array);\n+\n+  \/\/ new String[method_count]\n+  objArrayOop name_array = oopFactory::new_objArray(vmClasses::String_klass(), method_count, CHECK_NULL);\n+  objArrayHandle h_name_array(THREAD, name_array);\n+\n+  \/\/ new String[method_count]\n+  objArrayOop signature_array = oopFactory::new_objArray(vmClasses::String_klass(), method_count, CHECK_NULL);\n+  objArrayHandle h_signature_array(THREAD, signature_array);\n+\n+   \/\/ new int[method_count]\n+  typeArrayOop modification_array = oopFactory::new_intArray(method_count, CHECK_NULL);\n+  typeArrayHandle h_modification_array(THREAD, modification_array);\n+\n+  \/\/ Fill in arrays\n+  for (int i = 0; i < method_count; i++) {\n+    JfrTracedMethod method = methods->at(i);\n+    h_id_array->long_at_put(i, method.id());\n+    Handle name = java_lang_String::create_from_symbol(method.name(), CHECK_NULL);\n+    h_name_array->obj_at_put(i, name());\n+    Handle signature = java_lang_String::create_from_symbol(method.signature(), CHECK_NULL);\n+    h_signature_array->obj_at_put(i, signature());\n+    h_modification_array->int_at_put(i, method.modification());\n+  }\n+\n+  \/\/ Call JVMUpcalls::onMethodTrace\n+  JavaCallArguments args;\n+  JavaValue result(T_ARRAY);\n+  args.push_oop(module_handle);\n+  args.push_oop(class_loader_handle);\n+  args.push_oop(class_name_h);\n+  args.push_oop(h_bytecode_array);\n+  args.push_oop(h_id_array);\n+  args.push_oop(h_name_array);\n+  args.push_oop(h_signature_array);\n+  args.push_oop(h_modification_array);\n+  JavaCalls::call_static(&result, klass, on_method_trace_sym, on_method_trace_sig_sym, &args, CHECK_NULL);\n+\n+  oop return_object = result.get_oop();\n+  if (return_object != nullptr) {\n+    assert(return_object->is_typeArray(), \"invariant\");\n+    assert(TypeArrayKlass::cast(return_object->klass())->element_type() == T_BYTE, \"invariant\");\n+    typeArrayOop byte_array = typeArrayOop(return_object);\n+    int length = byte_array->length();\n+    u1* buffer = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, u1, length);\n+    ArrayAccess<>::arraycopy_to_native<>(byte_array, typeArrayOopDesc::element_offset<jbyte>(0), buffer, length);\n+    return new ClassFileStream(buffer, length, stream->source(), stream->from_boot_loader_modules_image());\n+  }\n+  return nullptr;\n+}\n+\n+void JfrUpcalls::publish_method_timers_for_klass(traceid klass_id, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  Klass* const klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, CHECK);\n+  assert(klass != nullptr, \"invariant\");\n+  JavaCallArguments args;\n+  JavaValue result(T_VOID);\n+  args.push_long(static_cast<jlong>(klass_id));\n+  JavaCalls::call_static(&result, klass, publish_method_timers_for_klass_sym, publish_method_timers_for_klass_sig_sym, &args, CHECK);\n+}\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n@@ -32,0 +33,3 @@\n+class ClassFileStream;\n+class InstanceKlass;\n+class JfrTracedMethod;\n@@ -33,0 +37,1 @@\n+template <typename E> class GrowableArray;\n@@ -58,0 +63,7 @@\n+  \/\/ Caller needs ResourceMark\n+  static ClassFileStream* on_method_trace(InstanceKlass* ik, const ClassFileStream* stream,\n+                                          GrowableArray<JfrTracedMethod>* methods,\n+                                          TRAPS);\n+\n+  static void publish_method_timers_for_klass(traceid klass_id, TRAPS);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n@@ -304,1 +305,4 @@\n-  if (!create_thread_sampling()) {\n+  if (!create_thread_sampler()) {\n+    return false;\n+  }\n+  if (!create_cpu_time_thread_sampling()) {\n@@ -320,1 +324,2 @@\n-static JfrThreadSampling* _thread_sampling = nullptr;\n+static JfrThreadSampler* _thread_sampler = nullptr;\n+static JfrCPUTimeThreadSampling* _cpu_time_thread_sampling = nullptr;\n@@ -387,4 +392,10 @@\n-bool JfrRecorder::create_thread_sampling() {\n-  assert(_thread_sampling == nullptr, \"invariant\");\n-  _thread_sampling = JfrThreadSampling::create();\n-  return _thread_sampling != nullptr;\n+bool JfrRecorder::create_thread_sampler() {\n+  assert(_thread_sampler == nullptr, \"invariant\");\n+  _thread_sampler = JfrThreadSampler::create();\n+  return _thread_sampler != nullptr;\n+}\n+\n+bool JfrRecorder::create_cpu_time_thread_sampling() {\n+  assert(_cpu_time_thread_sampling == nullptr, \"invariant\");\n+  _cpu_time_thread_sampling = JfrCPUTimeThreadSampling::create();\n+  return _cpu_time_thread_sampling != nullptr;\n@@ -427,3 +438,7 @@\n-  if (_thread_sampling != nullptr) {\n-    JfrThreadSampling::destroy();\n-    _thread_sampling = nullptr;\n+  if (_thread_sampler != nullptr) {\n+    JfrThreadSampler::destroy();\n+    _thread_sampler = nullptr;\n+  }\n+  if (_cpu_time_thread_sampling != nullptr) {\n+    JfrCPUTimeThreadSampling::destroy();\n+    _cpu_time_thread_sampling = nullptr;\n@@ -435,1 +450,1 @@\n-  return JfrRecorderThread::start(_checkpoint_manager, _post_box, JavaThread::current());\n+  return JfrRecorderThreadEntry::start(_checkpoint_manager, _post_box, JavaThread::current());\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,2 @@\n-  static bool create_thread_sampling();\n+  static bool create_thread_sampler();\n+  static bool create_cpu_time_thread_sampling();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,1 @@\n+  LOG_TAG(methodtrace) \\\n@@ -209,0 +210,1 @@\n+  LOG_TAG(training) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2771,1 +2771,1 @@\n-    if (log_is_enabled(Info, cds)) {\n+    if (log_is_enabled(Info, aot)) {\n@@ -2774,1 +2774,1 @@\n-      log_info(cds)(\"JVM_StartThread() ignored: %s\", t->klass()->external_name());\n+      log_info(aot)(\"JVM_StartThread() ignored: %s\", t->klass()->external_name());\n@@ -2965,0 +2965,9 @@\n+JVM_ENTRY(jobject, JVM_CreateThreadSnapshot(JNIEnv* env, jobject jthread))\n+#if INCLUDE_JVMTI\n+  oop snapshot = ThreadSnapshotFactory::get_thread_snapshot(jthread, THREAD);\n+  return JNIHandles::make_local(THREAD, snapshot);\n+#else\n+  return nullptr;\n+#endif\n+JVM_END\n+\n@@ -3467,1 +3476,1 @@\n-    log_debug(cds)(\"JVM_GetRandomSeedForDumping() = \" JLONG_FORMAT, seed);\n+    log_debug(aot)(\"JVM_GetRandomSeedForDumping() = \" JLONG_FORMAT, seed);\n@@ -3530,1 +3539,1 @@\n-      log_debug(cds)(\"NeedsClassInitBarrierForCDS: %s\", k->external_name());\n+      log_debug(aot)(\"NeedsClassInitBarrierForCDS: %s\", k->external_name());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -91,0 +92,3 @@\n+#if INCLUDE_JVMCI\n+bool   Arguments::_jvmci_module_added           = false;\n+#endif\n@@ -139,0 +143,5 @@\n+struct VMInitArgsGroup {\n+  const JavaVMInitArgs* _args;\n+  JVMFlagOrigin _origin;\n+};\n+\n@@ -338,2 +347,1 @@\n-    if (matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||\n-        matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||\n+    if (matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||\n@@ -350,0 +358,1 @@\n+          matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||\n@@ -539,0 +548,1 @@\n+  { \"PerfDataSamplingInterval\",     JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n@@ -542,0 +552,3 @@\n+#if defined(AARCH64)\n+  { \"NearCpool\",                    JDK_Version::undefined(), JDK_Version::jdk(25), JDK_Version::undefined() },\n+#endif\n@@ -1401,1 +1414,1 @@\n-    log_error(cds)(\"%s is incompatible with other specified options.\",\n+    aot_log_error(aot)(\"%s is incompatible with other specified options.\",\n@@ -1410,1 +1423,1 @@\n-      log_warning(cds)(\"Unable to use AOT cache: %s\", message);\n+      log_warning(aot)(\"Unable to use AOT cache: %s\", message);\n@@ -1412,1 +1425,1 @@\n-      log_info(cds)(\"Unable to use shared archive: %s\", message);\n+      aot_log_info(aot)(\"Unable to use shared archive: %s\", message);\n@@ -1601,1 +1614,1 @@\n-          log_info(cds)(\"UseCompressedOops and UseCompressedClassPointers have been disabled due to\"\n+          aot_log_info(aot)(\"UseCompressedOops and UseCompressedClassPointers have been disabled due to\"\n@@ -1837,3 +1850,3 @@\n-    PropertyList_unique_add(&_system_properties, \"jdk.internal.vm.ci.enabled\", \"true\",\n-        AddProperty, UnwriteableProperty, InternalProperty);\n-    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+    \/\/ Add the JVMCI module if not using libjvmci or EnableJVMCI\n+    \/\/ was explicitly set on the command line or in the jimage.\n+    if ((!UseJVMCINativeLibrary || FLAG_IS_CMDLINE(EnableJVMCI) || FLAG_IS_JIMAGE_RESOURCE(EnableJVMCI)) && ClassLoader::is_module_observable(\"jdk.internal.vm.ci\") && !_jvmci_module_added) {\n@@ -1984,6 +1997,1 @@\n-\/\/ Parse JavaVMInitArgs structure\n-\n-jint Arguments::parse_vm_init_args(const JavaVMInitArgs *vm_options_args,\n-                                   const JavaVMInitArgs *java_tool_options_args,\n-                                   const JavaVMInitArgs *java_options_args,\n-                                   const JavaVMInitArgs *cmd_line_args) {\n+jint Arguments::parse_vm_init_args(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args) {\n@@ -2002,24 +2010,6 @@\n-  \/\/ Parse args structure generated from java.base vm options resource\n-  jint result = parse_each_vm_init_arg(vm_options_args, JVMFlagOrigin::JIMAGE_RESOURCE);\n-  if (result != JNI_OK) {\n-    return result;\n-  }\n-\n-  \/\/ Parse args structure generated from JAVA_TOOL_OPTIONS environment\n-  \/\/ variable (if present).\n-  result = parse_each_vm_init_arg(java_tool_options_args, JVMFlagOrigin::ENVIRON_VAR);\n-  if (result != JNI_OK) {\n-    return result;\n-  }\n-\n-  \/\/ Parse args structure generated from the command line flags.\n-  result = parse_each_vm_init_arg(cmd_line_args, JVMFlagOrigin::COMMAND_LINE);\n-  if (result != JNI_OK) {\n-    return result;\n-  }\n-\n-  \/\/ Parse args structure generated from the _JAVA_OPTIONS environment\n-  \/\/ variable (if present) (mimics classic VM)\n-  result = parse_each_vm_init_arg(java_options_args, JVMFlagOrigin::ENVIRON_VAR);\n-  if (result != JNI_OK) {\n-    return result;\n+  jint result;\n+  for (int i = 0; i < all_args->length(); i++) {\n+    result = parse_each_vm_init_arg(all_args->at(i)._args, all_args->at(i)._origin);\n+    if (result != JNI_OK) {\n+      return result;\n+    }\n@@ -2370,0 +2360,13 @@\n+#if INCLUDE_JVMCI\n+      if (!_jvmci_module_added) {\n+        const char *jvmci_module = strstr(tail, \"jdk.internal.vm.ci\");\n+        if (jvmci_module != nullptr) {\n+          char before = *(jvmci_module - 1);\n+          char after  = *(jvmci_module + strlen(\"jdk.internal.vm.ci\"));\n+          if ((before == '=' || before == ',') && (after == '\\0' || after == ',')) {\n+            FLAG_SET_DEFAULT(EnableJVMCI, true);\n+            _jvmci_module_added = true;\n+          }\n+        }\n+      }\n+#endif\n@@ -3206,0 +3209,44 @@\n+static JavaVMOption* get_last_aotmode_arg(const JavaVMInitArgs* args) {\n+  for (int index = args->nOptions - 1; index >= 0; index--) {\n+    JavaVMOption* option = args->options + index;\n+    if (strstr(option->optionString, \"-XX:AOTMode=\") == option->optionString) {\n+      return option;\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n+jint Arguments::parse_jdk_aot_vm_options_environment_variable(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args,\n+                                                            ScopedVMInitArgs* jdk_aot_vm_options_args) {\n+  \/\/ Don't bother scanning all the args if this env variable is not set\n+  if (::getenv(\"JDK_AOT_VM_OPTIONS\") == nullptr) {\n+    return JNI_OK;\n+  }\n+\n+  \/\/ Scan backwards and find the last occurrence of -XX:AOTMode=xxx, which will decide the value\n+  \/\/ of AOTMode.\n+  JavaVMOption* option = nullptr;\n+  for (int i = all_args->length() - 1; i >= 0; i--) {\n+    if ((option = get_last_aotmode_arg(all_args->at(i)._args)) != nullptr) {\n+      break;\n+    }\n+  }\n+\n+  if (option != nullptr) {\n+    \/\/ We have found the last -XX:AOTMode=xxx. At this point <option> has NOT been parsed yet,\n+    \/\/ so its value is not reflected inside the global variable AOTMode.\n+    if (strcmp(option->optionString, \"-XX:AOTMode=create\") != 0) {\n+      return JNI_OK; \/\/ Do not parse JDK_AOT_VM_OPTIONS\n+    }\n+  } else {\n+    \/\/ -XX:AOTMode is not specified in any of 4 options_args, let's check AOTMode,\n+    \/\/ which would have been set inside process_settings_file();\n+    if (AOTMode == nullptr || strcmp(AOTMode, \"create\") != 0) {\n+      return JNI_OK; \/\/ Do not parse JDK_AOT_VM_OPTIONS\n+    }\n+  }\n+\n+  return parse_options_environment_variable(\"JDK_AOT_VM_OPTIONS\", jdk_aot_vm_options_args);\n+}\n+\n@@ -3584,0 +3631,1 @@\n+  ScopedVMInitArgs initial_jdk_aot_vm_options_args(\"env_var='JDK_AOT_VM_OPTIONS'\");\n@@ -3590,0 +3638,1 @@\n+  JavaVMInitArgs* cur_jdk_aot_vm_options_args;\n@@ -3596,0 +3645,1 @@\n+  ScopedVMInitArgs mod_jdk_aot_vm_options_args(\"env_var='_JDK_AOT_VM_OPTIONS'\");\n@@ -3597,0 +3647,1 @@\n+  GrowableArrayCHeap<VMInitArgsGroup, mtArguments> all_args;\n@@ -3604,0 +3655,2 @@\n+  \/\/ Yet another environment variable: _JAVA_OPTIONS. This mimics the classic VM.\n+  \/\/ This is an undocumented feature.\n@@ -3650,7 +3703,1 @@\n-  if (IgnoreUnrecognizedVMOptions) {\n-    cur_cmd_args->ignoreUnrecognized = true;\n-    cur_java_tool_options_args->ignoreUnrecognized = true;\n-    cur_java_options_args->ignoreUnrecognized = true;\n-  }\n-\n-  \/\/ Parse specified settings file\n+  \/\/ Parse specified settings file (s) -- the effects are applied immediately into the JVM global flags.\n@@ -3659,1 +3706,1 @@\n-                               cur_cmd_args->ignoreUnrecognized)) {\n+                               IgnoreUnrecognizedVMOptions)) {\n@@ -3666,1 +3713,1 @@\n-                               cur_cmd_args->ignoreUnrecognized)) {\n+                               IgnoreUnrecognizedVMOptions)) {\n@@ -3677,0 +3724,43 @@\n+  \/\/ The settings in the args are applied in this order to the the JVM global flags.\n+  \/\/ For historical reasons, the order is DIFFERENT than the scanning order of\n+  \/\/ the above expand_vm_options_as_needed() calls.\n+  all_args.append({cur_vm_options_args, JVMFlagOrigin::JIMAGE_RESOURCE});\n+  all_args.append({cur_java_tool_options_args, JVMFlagOrigin::ENVIRON_VAR});\n+  all_args.append({cur_cmd_args, JVMFlagOrigin::COMMAND_LINE});\n+  all_args.append({cur_java_options_args, JVMFlagOrigin::ENVIRON_VAR});\n+\n+  \/\/ JDK_AOT_VM_OPTIONS are parsed only if -XX:AOTMode=create has been detected from all\n+  \/\/ the options that have been gathered above.\n+  code = parse_jdk_aot_vm_options_environment_variable(&all_args, &initial_jdk_aot_vm_options_args);\n+  if (code != JNI_OK) {\n+    return code;\n+  }\n+  code = expand_vm_options_as_needed(initial_jdk_aot_vm_options_args.get(),\n+                                     &mod_jdk_aot_vm_options_args,\n+                                     &cur_jdk_aot_vm_options_args);\n+  if (code != JNI_OK) {\n+    return code;\n+  }\n+\n+  for (int index = 0; index < cur_jdk_aot_vm_options_args->nOptions; index++) {\n+    JavaVMOption* option = cur_jdk_aot_vm_options_args->options + index;\n+    const char* optionString = option->optionString;\n+    if (strstr(optionString, \"-XX:AOTMode=\") == optionString &&\n+        strcmp(optionString, \"-XX:AOTMode=create\") != 0) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"Option %s cannot be specified in JDK_AOT_VM_OPTIONS\\n\", optionString);\n+      return JNI_ERR;\n+    }\n+  }\n+\n+  all_args.append({cur_jdk_aot_vm_options_args, JVMFlagOrigin::ENVIRON_VAR});\n+\n+  if (IgnoreUnrecognizedVMOptions) {\n+    \/\/ Note: unrecognized options in cur_vm_options_arg cannot be ignored. They are part of\n+    \/\/ the JDK so it shouldn't have bad options.\n+    cur_cmd_args->ignoreUnrecognized = true;\n+    cur_java_tool_options_args->ignoreUnrecognized = true;\n+    cur_java_options_args->ignoreUnrecognized = true;\n+    cur_jdk_aot_vm_options_args->ignoreUnrecognized = true;\n+  }\n+\n@@ -3678,0 +3768,1 @@\n+    \/\/ For historical reasons, options specified in cur_vm_options_arg and -XX:Flags are not printed.\n@@ -3681,0 +3772,1 @@\n+    print_options(cur_jdk_aot_vm_options_args);\n@@ -3683,5 +3775,2 @@\n-  \/\/ Parse JavaVMInitArgs structure passed in, as well as JAVA_TOOL_OPTIONS and _JAVA_OPTIONS\n-  jint result = parse_vm_init_args(cur_vm_options_args,\n-                                   cur_java_tool_options_args,\n-                                   cur_java_options_args,\n-                                   cur_cmd_args);\n+  \/\/ Apply the settings in these args to the JVM global flags.\n+  jint result = parse_vm_init_args(&all_args);\n@@ -3746,1 +3835,1 @@\n-      log_is_enabled(Info, cds)) {\n+      log_is_enabled(Info, cds) || log_is_enabled(Info, aot)) {\n@@ -3750,0 +3839,1 @@\n+    LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(aot));\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":144,"deletions":54,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -151,0 +151,3 @@\n+struct VMInitArgsGroup;\n+template <typename E, MemTag MT> class GrowableArrayCHeap;\n+\n@@ -201,0 +204,4 @@\n+#if INCLUDE_JVMCI\n+  \/\/ was jdk.internal.vm.ci module specified in the --add-modules option?\n+  static bool _jvmci_module_added;\n+#endif\n@@ -314,0 +321,2 @@\n+  static jint parse_jdk_aot_vm_options_environment_variable(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args,\n+                                                            ScopedVMInitArgs* jdk_aot_vm_options_args);\n@@ -331,4 +340,1 @@\n-  static jint parse_vm_init_args(const JavaVMInitArgs *vm_options_args,\n-                                 const JavaVMInitArgs *java_tool_options_args,\n-                                 const JavaVMInitArgs *java_options_args,\n-                                 const JavaVMInitArgs *cmd_line_args);\n+  static jint parse_vm_init_args(GrowableArrayCHeap<VMInitArgsGroup, mtArguments>* all_args);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  product(bool, UseCompactObjectHeaders, false, EXPERIMENTAL,               \\\n+  product(bool, UseCompactObjectHeaders, false,                             \\\n@@ -335,0 +335,1 @@\n+                                                                            \\\n@@ -658,0 +659,4 @@\n+  product(bool, DeoptimizeOnAllocationException, false, DIAGNOSTIC,         \\\n+          \"Deoptimize on exception during allocation instead of using the \" \\\n+          \"compiled exception handlers\")                                    \\\n+                                                                            \\\n@@ -1731,5 +1736,0 @@\n-  product(int, PerfDataSamplingInterval, 50,                                \\\n-          \"Data sampling interval (in milliseconds)\")                       \\\n-          range(PeriodicTask::min_interval, max_jint)                       \\\n-          constraint(PerfDataSamplingIntervalFunc, AfterErgo)               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -219,1 +219,0 @@\n-    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n@@ -230,2 +229,0 @@\n-  inline void set_trace_flag();\n-  inline void clear_trace_flag();\n@@ -234,1 +231,0 @@\n-  bool is_trace_suspend()      { return (_suspend_flags & _trace_flag) != 0; }\n@@ -754,1 +750,1 @@\n-    return (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n+    return (_suspend_flags & _obj_deopt) != 0;\n@@ -1170,0 +1166,1 @@\n+  \/\/ This field is checked by the interpreter which expects it to be an integer.\n@@ -1176,4 +1173,1 @@\n-  int get_interp_only_mode()                { return _interp_only_mode; }\n-  int set_interp_only_mode(int val)         { return _interp_only_mode = val; }\n-  void increment_interp_only_mode()         { ++_interp_only_mode; }\n-  void decrement_interp_only_mode()         { --_interp_only_mode; }\n+  void set_interp_only_mode(bool val)       { _interp_only_mode = val ? 1 : 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -631,0 +631,1 @@\n+  static intptr_t*  fetch_bcp_from_context(const void* ucVoid);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -92,1 +93,0 @@\n-#include \"runtime\/statSampler.hpp\"\n@@ -480,0 +480,3 @@\n+  \/\/ Initialize memory pools\n+  Arena::initialize_chunk_pool();\n+\n@@ -845,0 +848,5 @@\n+  \/\/ Initiate replay training processing once preloading is over.\n+  CompileBroker::init_training_replay();\n+\n+  AOTLinkedClassBulkLoader::replay_training_at_init_for_preloaded_classes(CHECK_JNI_ERR);\n+\n@@ -868,1 +876,1 @@\n-    JVMCI::initialize_compiler(CHECK_JNI_ERR);\n+    JVMCI::initialize_compiler_in_create_vm(CHECK_JNI_ERR);\n@@ -875,7 +883,16 @@\n-  Management::initialize(THREAD);\n-\n-  if (HAS_PENDING_EXCEPTION) {\n-    \/\/ management agent fails to start possibly due to\n-    \/\/ configuration problem and is responsible for printing\n-    \/\/ stack trace if appropriate. Simply exit VM.\n-    vm_exit(1);\n+  bool start_agent = true;\n+#if INCLUDE_CDS\n+  start_agent = !CDSConfig::is_dumping_final_static_archive();\n+  if (!start_agent) {\n+    log_info(aot)(\"Not starting management agent during creation of AOT cache.\");\n+  }\n+#endif \/\/ INCLUDE_CDS\n+  if (start_agent) {\n+    Management::initialize(THREAD);\n+\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ management agent fails to start possibly due to\n+      \/\/ configuration problem and is responsible for printing\n+      \/\/ stack trace if appropriate. Simply exit VM.\n+      vm_exit(1);\n+    }\n@@ -885,1 +902,1 @@\n-  StatSampler::engage();\n+  if (UsePerfData)         PerfDataManager::create_misc_perfdata();\n@@ -939,1 +956,1 @@\n-\/\/      > stop StatSampler, watcher thread,\n+\/\/      > stop watcher thread,\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -119,0 +119,2 @@\n+  template(JFRInitializeCPUTimeSampler)       \\\n+  template(JFRTerminateCPUTimeSampler)        \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,0 +1,1 @@\n+\n@@ -1026,0 +1027,1 @@\n+        declare_type(TrainingReplayThread, JavaThread)                    \\\n@@ -1167,0 +1169,1 @@\n+  declare_toplevel_type(VM_Version)                                       \\\n@@ -1719,1 +1722,0 @@\n-  NOT_ZERO(X86_ONLY(declare_constant(frame::entry_frame_call_wrapper_offset)))      \\\n@@ -2150,0 +2152,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -178,2 +178,2 @@\n-\/\/ Default is false (if jdk.attach.vm.streaming property is not set).\n-bool AttachListener::_default_streaming_output = false;\n+\/\/ Default is true (if jdk.attach.vm.streaming property is not set).\n+bool AttachListener::_default_streaming_output = true;\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+#if INCLUDE_JVMTI\n@@ -135,0 +136,1 @@\n+#endif \/\/ INCLUDE_JVMTI\n@@ -422,1 +424,0 @@\n-  MetaspaceUtils::print_on(output());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -164,0 +164,6 @@\n+bool outputStream::set_autoindent(bool value) {\n+  const bool old = _autoindent;\n+  _autoindent = value;\n+  return old;\n+}\n+\n@@ -228,4 +234,0 @@\n-void outputStream::cr_indent() {\n-  cr(); indent();\n-}\n-\n@@ -280,6 +282,0 @@\n-bool outputStream::set_autoindent(bool value) {\n-  const bool old = _autoindent;\n-  _autoindent = value;\n-  return old;\n-}\n-\n@@ -303,1 +299,1 @@\n- * indent is applied to each line.  Ends with a CR.\n+ * Ends with a CR.\n@@ -310,1 +306,1 @@\n-        indent().print(\"%07\" PRIxPTR \":\", i);\n+        print(\"%07\" PRIxPTR \":\", i);\n@@ -312,1 +308,1 @@\n-        indent().print(PTR_FORMAT \":\", p2i((unsigned char*)data + i));\n+        print(PTR_FORMAT \":\", p2i((unsigned char*)data + i));\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+  friend class StreamIndentor;\n+\n@@ -90,0 +92,3 @@\n+   \/\/ Automatic indentation. Returns old autoindent state.\n+   bool set_autoindent(bool value);\n+\n@@ -107,8 +112,0 @@\n-   \/\/ Automatic indentation:\n-   \/\/ If autoindent mode is on, the following APIs will automatically indent\n-   \/\/ line starts depending on the current indentation level:\n-   \/\/ print(), print_cr(), print_raw(), print_raw_cr()\n-   \/\/ Other APIs are unaffected\n-   \/\/ Returns old autoindent state.\n-   bool set_autoindent(bool value);\n-\n@@ -138,1 +135,0 @@\n-   void cr_indent();\n@@ -178,11 +174,9 @@\n-class streamIndentor : public StackObj {\n-protected:\n-  outputStream* const _str;\n-  const int _amount;\n-  NONCOPYABLE(streamIndentor);\n-public:\n-  streamIndentor(outputStream* str, int amt = 2) : _str(str), _amount(amt) {\n-    _str->inc(_amount);\n-  }\n-  ~streamIndentor() { _str->dec(_amount); }\n-};\n+\/\/ outputStream indentation. When used, indentation is automatically applied\n+\/\/ when printing on the stream using the following APIs:\n+\/\/ print(), print_cr(), print_raw(), print_raw_cr()\n+class StreamIndentor {\n+ private:\n+  outputStream* const _stream;\n+  const int           _indentation;\n+  const bool          _old_autoindent;\n+  NONCOPYABLE(StreamIndentor);\n@@ -190,6 +184,12 @@\n-class StreamAutoIndentor : public streamIndentor {\n-  const bool _old;\n-  NONCOPYABLE(StreamAutoIndentor);\n-  StreamAutoIndentor(outputStream* os, int indentation = 0) :\n-    streamIndentor(os, indentation), _old(os->set_autoindent(true)) {}\n-  ~StreamAutoIndentor() { _str->set_autoindent(_old); }\n+  StreamIndentor(outputStream* os, int indentation) :\n+    _stream(os),\n+    _indentation(indentation),\n+    _old_autoindent(_stream->set_autoindent(true)) {\n+\n+    _stream->inc(_indentation);\n+  }\n+\n+  ~StreamIndentor() {\n+    _stream->dec(_indentation);\n+    _stream->set_autoindent(_old_autoindent);\n+  }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,2 +215,1 @@\n-        boolean endOfFile = false;\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -219,1 +218,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -222,1 +220,1 @@\n-                endOfFile = true;\n+                bytesRead = -1;\n@@ -227,4 +225,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -246,1 +241,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -248,1 +243,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -251,8 +245,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -297,1 +297,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -301,4 +300,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -339,1 +335,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -341,1 +337,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -345,4 +340,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,2 +405,1 @@\n-        boolean endOfFile = false;\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -408,1 +407,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -411,1 +409,1 @@\n-                endOfFile = true;\n+                bytesRead = -1;\n@@ -416,4 +414,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -442,1 +437,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -444,1 +439,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -447,8 +441,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -620,1 +607,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -622,1 +609,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -626,4 +612,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -662,1 +645,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -664,1 +647,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -668,4 +650,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":10,"deletions":31,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -127,4 +127,13 @@\n-     * within an {@link java.io.InputStreamReader InputStreamReader} or other object\n-     * that handles character encoding. After this is done, subsequent reading should\n-     * use only the wrapper object; operating directly on {@code System.in} results\n-     * in unspecified behavior.\n+     * within the object that handles character encoding. After this is done,\n+     * subsequent reading should use only the wrapper object; continuing to\n+     * operate directly on {@code System.in} results in unspecified behavior.\n+     * <p>\n+     * Here are two common examples. Using an {@link java.io.InputStreamReader\n+     * InputStreamReader}:\n+     * {@snippet lang=java :\n+     *     new InputStreamReader(System.in, System.getProperty(\"stdin.encoding\"));\n+     * }\n+     * Or using a {@link java.util.Scanner Scanner}:\n+     * {@snippet lang=java :\n+     *     new Scanner(System.in, System.getProperty(\"stdin.encoding\"));\n+     * }\n@@ -2144,1 +2153,1 @@\n-            public int countPositives(byte[] bytes, int offset, int length) {\n+            public int uncheckedCountPositives(byte[] bytes, int offset, int length) {\n@@ -2150,1 +2159,1 @@\n-            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+            public String uncheckedNewStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n@@ -2153,1 +2162,1 @@\n-            public char getUTF16Char(byte[] bytes, int index) {\n+            public char uncheckedGetUTF16Char(byte[] bytes, int index) {\n@@ -2156,1 +2165,1 @@\n-            public void putCharUTF16(byte[] bytes, int index, int ch) {\n+            public void uncheckedPutCharUTF16(byte[] bytes, int index, int ch) {\n@@ -2159,1 +2168,1 @@\n-            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n+            public byte[] uncheckedGetBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n@@ -2171,1 +2180,1 @@\n-            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+            public void uncheckedInflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n@@ -2175,1 +2184,1 @@\n-            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+            public int uncheckedDecodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n@@ -2179,1 +2188,1 @@\n-            public int encodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n@@ -2215,1 +2224,1 @@\n-            public Object stringConcat1(String[] constants) {\n+            public Object uncheckedStringConcat1(String[] constants) {\n@@ -2280,4 +2289,0 @@\n-            public boolean isCarrierThreadLocalPresent(CarrierThreadLocal<?> local) {\n-                return ((ThreadLocal<?>)local).isCarrierThreadLocalPresent();\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-    public Cleanable register(Object obj, Runnable action) {\n+    public Cleanable register(@jdk.internal.RequiresIdentity Object obj, Runnable action) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-public abstract sealed class Reference<T>\n+public abstract sealed class Reference<@jdk.internal.RequiresIdentity T>\n@@ -313,1 +313,0 @@\n-    \/\/ Called from JVM when loading an AOT cache\n@@ -318,0 +317,1 @@\n+    \/\/ Also called from JVM when loading an AOT cache\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.Continuation;\n@@ -50,1 +49,1 @@\n-public class ReferenceQueue<T> {\n+public class ReferenceQueue<@jdk.internal.RequiresIdentity T> {\n@@ -148,13 +147,0 @@\n-    private boolean tryDisablePreempt() {\n-        if (Thread.currentThread().isVirtual() && ContinuationSupport.isSupported()) {\n-            Continuation.pin();\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    private void enablePreempt() {\n-        Continuation.unpin();\n-    }\n-\n@@ -176,1 +162,1 @@\n-        boolean disabled = tryDisablePreempt();\n+        ContinuationSupport.pinIfSupported();\n@@ -182,1 +168,1 @@\n-            if (disabled) enablePreempt();\n+            ContinuationSupport.unpinIfSupported();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+import jdk.internal.util.Exceptions;\n@@ -75,0 +76,2 @@\n+import static jdk.internal.util.Exceptions.filterNonSocketInfo;\n+import static jdk.internal.util.Exceptions.formatMsg;\n@@ -398,0 +401,1 @@\n+        Exceptions.setup(); \/\/ needed for native exceptions\n@@ -932,1 +936,1 @@\n-                throw new UnknownHostException(host);\n+                throw new UnknownHostException(formatMsg(\"%s\", filterNonSocketInfo(host)));\n@@ -1125,1 +1129,3 @@\n-                        throw ex == null ? new UnknownHostException(host) : ex;\n+                        throw ex == null\n+                            ? new UnknownHostException(formatMsg(\"%s\", filterNonSocketInfo(host)))\n+                            : ex;\n@@ -1233,3 +1239,5 @@\n-                throw new UnknownHostException(\"Unable to resolve address \"\n-                        + Arrays.toString(addr) + \" as hosts file \" + hostsFile\n-                        + \" not found \");\n+                throw new UnknownHostException(\n+                    formatMsg(\"Unable to resolve address %s as hosts file %s not found\",\n+                              filterNonSocketInfo(Arrays.toString(addr)),\n+                              filterNonSocketInfo(hostsFile)\n+                                   .replaceWith(\"from ${jdk.net.hosts.file} system property\")));\n@@ -1239,4 +1247,5 @@\n-                throw new UnknownHostException(\"Requested address \"\n-                        + Arrays.toString(addr)\n-                        + \" resolves to an invalid entry in hosts file \"\n-                        + hostsFile);\n+                throw new UnknownHostException(\n+                    formatMsg(\"Requested address %s resolves to an invalid entry in hosts file %s\",\n+                              filterNonSocketInfo(Arrays.toString(addr)),\n+                              filterNonSocketInfo(hostsFile)\n+                                   .replaceWith(\"from ${jdk.net.hosts.file} system property\")));\n@@ -1303,2 +1312,5 @@\n-                throw new UnknownHostException(\"Unable to resolve host \" + host\n-                        + \" as hosts file \" + hostsFile + \" not found \");\n+                throw new UnknownHostException(\n+                    formatMsg(\"Unable to resolve host %s as hosts file %s not found\",\n+                              filterNonSocketInfo(host), filterNonSocketInfo(hostsFile)\n+                                   .replaceWith(\"from ${jdk.net.hosts.file} system property\")));\n+\n@@ -1335,2 +1347,4 @@\n-                throw new UnknownHostException(\"Unable to resolve host \" + hostName\n-                        + \" in hosts file \" + hostsFile);\n+                throw new UnknownHostException(\n+                    formatMsg(\"Unable to resolve host %s in hosts file %s\",\n+                              filterNonSocketInfo(hostName), filterNonSocketInfo(hostsFile)\n+                                   .replaceWith(\"from ${jdk.net.hosts.file} system property\")));\n@@ -1573,1 +1587,1 @@\n-                    var uhe = new UnknownHostException(host);\n+                    var uhe = new UnknownHostException(formatMsg(\"%s\", filterNonSocketInfo(host)));\n@@ -1600,1 +1614,2 @@\n-        return new UnknownHostException(hostString + \": invalid IPv6 address literal\");\n+        return new UnknownHostException(formatMsg(\"%sinvalid IPv6 address literal\",\n+                                                  filterNonSocketInfo(hostString).suffixWith(\": \")));\n@@ -1738,1 +1753,2 @@\n-            throw ex == null ? new UnknownHostException(host) : ex;\n+            throw ex == null ? new UnknownHostException(formatMsg(\"%s\", filterNonSocketInfo(host)))\n+                             : ex;\n@@ -1810,3 +1826,3 @@\n-                UnknownHostException uhe2 =\n-                        new UnknownHostException(local + \": \" +\n-                                uhe.getMessage());\n+                    UnknownHostException uhe2 =\n+                        new UnknownHostException(formatMsg(filterNonSocketInfo(local)\n+                                                               .suffixWith(\": \") + uhe.getMessage()));\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":36,"deletions":20,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -683,1 +683,1 @@\n-     * @see #isBound\n+     * @see #isBound()\n@@ -969,4 +969,1 @@\n-            long duration = SocketReadEvent.timestamp() - start;\n-            if (SocketReadEvent.shouldCommit(duration)) {\n-                SocketReadEvent.emit(start, duration, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n-            }\n+            SocketReadEvent.offer(start, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n@@ -1085,4 +1082,1 @@\n-            long duration = SocketWriteEvent.timestamp() - start;\n-            if (SocketWriteEvent.shouldCommit(duration)) {\n-                SocketWriteEvent.emit(start, duration, len, parent.getRemoteSocketAddress());\n-            }\n+            SocketWriteEvent.offer(start, len, parent.getRemoteSocketAddress());\n@@ -1616,1 +1610,1 @@\n-     * @see #isClosed\n+     * @see #isClosed()\n@@ -1646,1 +1640,1 @@\n-     * @see #isInputShutdown\n+     * @see #isInputShutdown()\n@@ -1676,1 +1670,1 @@\n-     * @see #isOutputShutdown\n+     * @see #isOutputShutdown()\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,2 @@\n+    \/\/ Used when decoding entry names and comments\n+    private final ZipCoder zipCoder;\n@@ -203,1 +205,2 @@\n-        this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);\n+        this.zipCoder = ZipCoder.get(charset);\n+        this.res = new CleanableResource(this, zipCoder, file, mode);\n@@ -270,1 +273,1 @@\n-                return res.zsrc.zc.toString(res.zsrc.comment);\n+                return zipCoder.toString(res.zsrc.comment);\n@@ -293,1 +296,1 @@\n-            EntryPos pos = res.zsrc.getEntryPos(name, true);\n+            EntryPos pos = res.zsrc.getEntryPos(name, true, zipCoder);\n@@ -333,1 +336,1 @@\n-                EntryPos entryPos = zsrc.getEntryPos(entry.name, false);\n+                EntryPos entryPos = zsrc.getEntryPos(entry.name, false, zipCoder);\n@@ -353,3 +356,3 @@\n-                    long size = CENSIZ(zsrc.cen, pos);\n-                    if (size > 65536) {\n-                        size = 8192;\n+                    long inputBufSize = CENSIZ(zsrc.cen, pos);\n+                    if (inputBufSize > 65536 || inputBufSize <= 0) {\n+                        inputBufSize = 8192;\n@@ -357,1 +360,1 @@\n-                    InputStream is = new ZipFileInflaterInputStream(in, res, (int) size);\n+                    InputStream is = new ZipFileInflaterInputStream(in, res, (int) inputBufSize);\n@@ -368,0 +371,29 @@\n+    \/**\n+     * Determines and returns a {@link ZipCoder} to use for decoding\n+     * name and comment fields of the ZIP entry identified by the {@code pos}\n+     * in the ZIP file's {@code cen}.\n+     * <p>\n+     * A ZIP entry's name and comment fields may be encoded using UTF-8, in\n+     * which case this method returns a UTF-8 capable {@code ZipCoder}. If the\n+     * entry doesn't require UTF-8, then this method returns the {@code fallback}\n+     * {@code ZipCoder}.\n+     *\n+     * @param cen the CEN\n+     * @param pos the ZIP entry's position in CEN\n+     * @param fallback the fallback ZipCoder to return if the entry doesn't require UTF-8\n+     *\/\n+    private static ZipCoder zipCoderFor(final byte[] cen, final int pos, final ZipCoder fallback) {\n+        if (fallback.isUTF8()) {\n+            \/\/ the fallback ZipCoder is capable of handling UTF-8,\n+            \/\/ so no need to parse the entry flags to determine if\n+            \/\/ the entry has UTF-8 flag.\n+            return fallback;\n+        }\n+        if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n+            \/\/ entry requires a UTF-8 ZipCoder\n+            return ZipCoder.UTF8;\n+        }\n+        \/\/ entry doesn't require a UTF-8 ZipCoder\n+        return fallback;\n+    }\n+\n@@ -389,2 +421,2 @@\n-                                   CleanableResource res, int size) {\n-            this(zfin, res, res.getInflater(), size);\n+                                   CleanableResource res, int inputBufSize) {\n+            this(zfin, res, res.getInflater(), inputBufSize);\n@@ -395,2 +427,2 @@\n-                                           Inflater inf, int size) {\n-            super(zfin, inf, size);\n+                                           Inflater inf, int inputBufSize) {\n+            super(zfin, inf, inputBufSize);\n@@ -566,1 +598,1 @@\n-        ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+        ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -637,1 +669,1 @@\n-            ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+            ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -669,1 +701,2 @@\n-        CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {\n+        CleanableResource(ZipFile zf, ZipCoder zipCoder, File file, int mode) throws IOException {\n+            assert zipCoder != null : \"null ZipCoder\";\n@@ -673,1 +706,1 @@\n-            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zc);\n+            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zipCoder);\n@@ -1129,0 +1162,1 @@\n+    \/\/ Implementation note: This class is thread safe.\n@@ -1141,1 +1175,0 @@\n-        private final @Stable ZipCoder zc;   \/\/ ZIP coder used to decode\/encode\n@@ -1177,2 +1210,3 @@\n-        \/\/ then returns the length of the entry name.\n-        private int checkAndAddEntry(int pos, int index)\n+        \/\/ then returns the length of the entry name. Uses the given zipCoder for processing the\n+        \/\/ entry name and the entry comment (if any).\n+        private int checkAndAddEntry(final int pos, final int index, final ZipCoder zipCoder)\n@@ -1216,2 +1250,1 @@\n-                ZipCoder zcp = zipCoderForPos(pos);\n-                int hash = zcp.checkedHash(cen, entryPos, nlen);\n+                int hash = zipCoder.checkedHash(cen, entryPos, nlen);\n@@ -1222,3 +1255,3 @@\n-                entries[index++] = hash;\n-                entries[index++] = next;\n-                entries[index  ] = pos;\n+                entries[index] = hash;\n+                entries[index + 1] = next;\n+                entries[index + 2] = pos;\n@@ -1230,1 +1263,1 @@\n-                    zcp.toString(cen, start, clen);\n+                    zipCoder.toString(cen, start, clen);\n@@ -1409,5 +1442,8 @@\n-         * A class representing a key to a ZIP file. A key is based\n-         * on the file key if available, or the path value if the\n-         * file key is not available. The key is also based on the\n-         * file's last modified time to allow for cases where a ZIP\n-         * file is re-opened after it has been modified.\n+         * A class representing a key to the Source of a ZipFile.\n+         * The Key is composed of:\n+         * - The BasicFileAttributes.fileKey() if available, or the Path of the ZIP file\n+         * if the fileKey() is not available.\n+         * - The ZIP file's last modified time (to allow for cases\n+         * where a ZIP file is re-opened after it has been modified).\n+         * - The Charset that was provided when constructing the ZipFile instance.\n+         * The unique combination of these components identifies a Source of a ZipFile.\n@@ -1416,5 +1452,13 @@\n-            final BasicFileAttributes attrs;\n-            File file;\n-            final boolean utf8;\n-\n-            public Key(File file, BasicFileAttributes attrs, ZipCoder zc) {\n+            private final BasicFileAttributes attrs;\n+            private final File file;\n+            \/\/ the Charset that was provided when constructing the ZipFile instance\n+            private final Charset charset;\n+\n+            \/**\n+             * Constructs a {@code Key} to a {@code Source} of a {@code ZipFile}\n+             *\n+             * @param file    the ZIP file\n+             * @param attrs   the attributes of the ZIP file\n+             * @param charset the Charset that was provided when constructing the ZipFile instance\n+             *\/\n+            public Key(File file, BasicFileAttributes attrs, Charset charset) {\n@@ -1423,1 +1467,1 @@\n-                this.utf8 = zc.isUTF8();\n+                this.charset = charset;\n@@ -1426,0 +1470,1 @@\n+            @Override\n@@ -1427,1 +1472,1 @@\n-                long t = utf8 ? 0 : Long.MAX_VALUE;\n+                long t = charset.hashCode();\n@@ -1434,0 +1479,1 @@\n+            @Override\n@@ -1436,1 +1482,1 @@\n-                    if (key.utf8 != utf8) {\n+                    if (!charset.equals(key.charset)) {\n@@ -1460,1 +1506,1 @@\n-        static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {\n+        static Source get(File file, boolean toDelete, ZipCoder zipCoder) throws IOException {\n@@ -1465,1 +1511,1 @@\n-                                BasicFileAttributes.class), zc);\n+                                BasicFileAttributes.class), zipCoder.charset());\n@@ -1477,1 +1523,1 @@\n-            src = new Source(key, toDelete, zc);\n+            src = new Source(key, toDelete, zipCoder);\n@@ -1499,2 +1545,1 @@\n-        private Source(Key key, boolean toDelete, ZipCoder zc) throws IOException {\n-            this.zc = zc;\n+        private Source(Key key, boolean toDelete, ZipCoder zipCoder) throws IOException {\n@@ -1514,1 +1559,1 @@\n-                initCEN(-1);\n+                initCEN(-1, zipCoder);\n@@ -1669,1 +1714,1 @@\n-        private void initCEN(int knownTotal) throws IOException {\n+        private void initCEN(final int knownTotal, final ZipCoder zipCoder) throws IOException {\n@@ -1731,1 +1776,1 @@\n-                    initCEN(countCENHeaders(cen));\n+                    initCEN(countCENHeaders(cen), zipCoder);\n@@ -1736,0 +1781,2 @@\n+                \/\/ the ZipCoder for any non-UTF8 entries\n+                final ZipCoder entryZipCoder = zipCoderFor(cen, pos, zipCoder);\n@@ -1737,1 +1784,1 @@\n-                int nlen = checkAndAddEntry(pos, idx);\n+                int nlen = checkAndAddEntry(pos, idx, entryZipCoder);\n@@ -1761,1 +1808,1 @@\n-                                int hashCode = zipCoderForPos(pos).checkedHash(cen,\n+                                int hashCode = entryZipCoder.checkedHash(cen,\n@@ -1806,1 +1853,1 @@\n-         *  to the specified entry name, or {@code null} if not found.\n+         * to the specified entry name, or {@code null} if not found.\n@@ -1808,1 +1855,2 @@\n-        private EntryPos getEntryPos(String name, boolean addSlash) {\n+        private EntryPos getEntryPos(final String name, final boolean addSlash,\n+                                     final ZipCoder zipCoder) {\n@@ -1827,2 +1875,1 @@\n-                    ZipCoder zc = zipCoderForPos(pos);\n-\n+                    final ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -1854,10 +1901,0 @@\n-        private ZipCoder zipCoderForPos(int pos) {\n-            if (zc.isUTF8()) {\n-                return zc;\n-            }\n-            if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n-                return ZipCoder.UTF8;\n-            }\n-            return zc;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":100,"deletions":63,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-        jdk.crypto.cryptoki, \/\/ participates in preview features\n@@ -278,0 +277,3 @@\n+        java.naming,\n+        java.rmi,\n+        java.net.http,\n@@ -281,0 +283,1 @@\n+        jdk.httpserver,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import static jdk.internal.util.Exceptions.filterJarName;\n+import static jdk.internal.util.Exceptions.formatMsg;\n@@ -118,1 +120,1 @@\n-            throw new FileNotFoundException(url.toString());\n+            throw new FileNotFoundException(formatMsg(\"%s\", filterJarName(url.toString())));\n@@ -210,1 +212,1 @@\n-            throw new FileNotFoundException(url.toString());\n+            throw new FileNotFoundException(formatMsg(\"%s\", filterJarName(url.toString())));\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -307,1 +307,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -310,8 +309,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -367,1 +359,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -369,1 +361,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -372,8 +363,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -426,1 +410,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -428,1 +412,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -431,5 +414,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -482,1 +461,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -484,1 +463,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -487,5 +465,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n@@ -1240,1 +1214,1 @@\n-        long start = 0;\n+        long start = FileReadEvent.timestamp();\n@@ -1242,1 +1216,0 @@\n-            start = FileReadEvent.timestamp();\n@@ -1245,8 +1218,1 @@\n-            long duration = FileReadEvent.timestamp() - start;\n-            if (FileReadEvent.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n+            FileReadEvent.offer(start, path, bytesRead);\n@@ -1312,1 +1278,1 @@\n-        long start = 0;\n+        long start = FileWriteEvent.timestamp();\n@@ -1314,1 +1280,0 @@\n-            start = FileWriteEvent.timestamp();\n@@ -1317,5 +1282,1 @@\n-            long duration = FileWriteEvent.timestamp() - start;\n-            if (FileWriteEvent.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n+            FileWriteEvent.offer(start, path, bytesWritten);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":13,"deletions":52,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-import sun.net.util.SocketExceptions;\n+import jdk.internal.util.Exceptions;\n@@ -66,0 +66,2 @@\n+import static jdk.internal.util.Exceptions.filterNonSocketInfo;\n+import static jdk.internal.util.Exceptions.formatMsg;\n@@ -298,1 +300,1 @@\n-    private int implRead(byte[] b, int off, int len) throws IOException {\n+    private int implRead(byte[] b, int off, int len, long remainingNanos) throws IOException {\n@@ -306,3 +308,2 @@\n-            int timeout = this.timeout;\n-            configureNonBlockingIfNeeded(fd, timeout > 0);\n-            if (timeout > 0) {\n+            configureNonBlockingIfNeeded(fd, remainingNanos > 0);\n+            if (remainingNanos > 0) {\n@@ -310,1 +311,1 @@\n-                n = timedRead(fd, b, off, len, MILLISECONDS.toNanos(timeout));\n+                n = timedRead(fd, b, off, len, remainingNanos);\n@@ -345,1 +346,11 @@\n-            readLock.lock();\n+            long remainingNanos = 0;\n+            int timeout = this.timeout;\n+            if (timeout > 0) {\n+                remainingNanos = tryLock(readLock, timeout, MILLISECONDS);\n+                if (remainingNanos <= 0) {\n+                    assert !readLock.isHeldByCurrentThread();\n+                    throw new SocketTimeoutException(\"Read timed out\");\n+                }\n+            } else {\n+                readLock.lock();\n+            }\n@@ -352,1 +363,1 @@\n-                int n = implRead(b, off, size);\n+                int n = implRead(b, off, size, remainingNanos);\n@@ -593,1 +604,2 @@\n-            throw new UnknownHostException(isa.getHostName());\n+            throw new UnknownHostException(\n+                formatMsg(filterNonSocketInfo(isa.getHostName())));\n@@ -643,1 +655,1 @@\n-                throw SocketExceptions.of(ioe, isa);\n+                throw Exceptions.ioException(ioe, isa);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-import sun.net.util.SocketExceptions;\n+import jdk.internal.util.Exceptions;\n@@ -980,1 +980,1 @@\n-            throw SocketExceptions.of(ioe, sa);\n+            throw Exceptions.ioException(ioe, sa);\n@@ -1070,1 +1070,1 @@\n-            throw SocketExceptions.of(ioe, remoteAddress);\n+            throw Exceptions.ioException(ioe, remoteAddress);\n@@ -1318,1 +1318,1 @@\n-            throw SocketExceptions.of(ioe, sa);\n+            throw Exceptions.ioException(ioe, sa);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2734,1 +2734,6 @@\n-:   Enables parallel reference processing. By default, this option is disabled.\n+:   Enables parallel reference processing. By default, collectors employing multiple\n+    threads perform parallel reference processing if the number of parallel threads\n+    to use is larger than one.\n+    The option is available only when the throughput or G1 garbage collector is used\n+    (`-XX:+UseParallelGC` or `-XX:+UseG1GC`). Other collectors employing multiple\n+    threads always perform reference processing in parallel.\n@@ -4028,2 +4033,2 @@\n-To diagnose problems with the above options, you can add `-Xlog:cds` to the application's VM\n-arguments. For example, if `--add-modules jdk.jconcole` was specified during archive creation\n+To diagnose problems with the AOT options, you can add `-Xlog:aot` to the application's VM\n+arguments. For example, if `--add-modules jdk.jconsole` was specified during archive creation\n@@ -4078,1 +4083,1 @@\n-`-XX:AOTCache:=`*cachefile*\n+`-XX:AOTCache=`*cachefile*\n@@ -4080,2 +4085,1 @@\n-    If `-XX:AOTCache` is specified but `-XX:AOTMode` is not specified,\n-    then `AOTMode` will be given the value of `auto`.\n+    This option cannot be used together with `-XX:AOTCacheOutput`.\n@@ -4083,1 +4087,12 @@\n-`-XX:AOTConfiguration:=`*configfile*\n+    This option is compatible with `AOTMode` settings of `on`, `create`, or `auto` (the default).\n+    The *cachefile* is read in AOT modes `on` and `auto`, and is ignored by mode `off`.\n+    The *cachefile* is written by AOT mode `create`.  In that case, this option is\n+    equivalent to `-XX:AOTCacheOutput=`*cachefile*.\n+\n+`-XX:AOTCacheOutput=`*cachefile*\n+:   Specifies the location of the AOT cache to write. The standard extension for *cachefile* is `.aot`.\n+    This option cannot be used together with `-XX:AOTCache`.\n+\n+    This option is compatible with `AOTMode` settings of `record`, `create`, or `auto` (the default).\n+\n+`-XX:AOTConfiguration=`*configfile*\n@@ -4085,1 +4100,0 @@\n-    This option can be used only with `-XX:AOTMode=record` and `-XX:AOTMode=create`.\n@@ -4088,2 +4102,3 @@\n-`-XX:+AOTMode:=`*mode*\n-:   *mode* must be one of the following: `off`, `record`, `create`, `auto`, or `on`.\n+    This option is compatible with `AOTMode` settings of `record`, `create`, or `auto` (the default).\n+    The *configfile* is read by AOT mode `create`, and written by the other applicable modes.\n+    If the AOT mode is `auto`, then `AOTCacheOutput` must also be present.\n@@ -4091,1 +4106,3 @@\n--   `off`: no AOT cache is used.\n+`-XX:AOTMode=`*mode*\n+:   Specifies the AOT Mode for this run.\n+    *mode* must be one of the following: `auto`, `off`, `record`, `create`, or `on`.\n@@ -4093,3 +4110,6 @@\n--   `record`: Execute the application in the Training phase.\n-    `-XX:AOTConfiguration=`*configfile* must be specified. The JVM gathers\n-     statistical data and stores them into *configfile*.\n+-   `auto`: This AOT mode is the default, and takes effect if no `-XX:AOTMode` option\n+    is present.  It automatically sets the AOT mode to `record`, `on`, or `off`, as follows:\n+     - If `-XX:AOTCacheOutput=`*cachefile* is specified, the AOT mode is changed to `record`\n+       (a training run, with a subsequent `create` operation).\n+     - Otherwise, if an AOT cache can be loaded, the AOT mode is changed to `on` (a production run).\n+     - Otherwise, the AOT mode is changed to `off` (a production run with no AOT cache).\n@@ -4097,3 +4117,23 @@\n--   `create`: Perform the Assembly phase. `-XX:AOTConfiguration=`*configfile*\n-     and `-XX:AOTCache=`*cachefile*  must be specified. The JVM reads the statistical\n-     data from *configfile* and writes the optimization artifacts into *cachefile*.\n+-   `off`: No AOT cache is used.\n+    Other AOT command line options are ignored.\n+\n+-   `record`: Execute the application in the training phase.\n+     At least one of `-XX:AOTConfiguration=`*configfile* and\/or\n+     `-XX:AOTCacheOutput=`*cachefile* must be specified.\n+     If `-XX:AOTConfiguration=`*configfile* is specified, the JVM gathers\n+     statistical data and stores them into *configfile*.\n+     If `-XX:AOTConfiguration=`*configfile* is not specified, the JVM uses\n+     a temporary file name, which may be the string `AOTCacheOutput+\".config\"`,\n+     or else a fresh implementation-dependent temporary file name.\n+     If `-XX:AOTCacheOutput=`*cachefile* is specified, a second JVM process is launched\n+     to perform the Assembly phase to write the optimization artifacts into *cachefile*.\n+\n+     Extra JVM options can be passed to the second JVM process using the environment\n+     variable `JDK_AOT_VM_OPTIONS`, with the same format as the environment variable\n+     `JAVA_TOOL_OPTIONS`, which is\n+     [defined by JVMTI](https:\/\/docs.oracle.com\/en\/java\/javase\/24\/docs\/specs\/jvmti.html#tooloptions).\n+\n+-   `create`: Perform the Assembly phase. `-XX:AOTConfiguration=`*configfile* must be\n+     specified.\n+     The JVM reads history and statistics\n+     from *configfile* and writes the optimization artifacts into *cachefile*.\n@@ -4102,1 +4142,1 @@\n--   `auto` or `on`: These modes should be used in the Production phase.\n+-   `on`: Execute the application in the Production phase.\n@@ -4119,1 +4159,1 @@\n-       list of scenarios that may be incompatible with the AOT cache for JDK 24.\n+       list of scenarios that may be incompatible with the AOT cache.\n@@ -4126,1 +4166,1 @@\n-     - If `AOTMode` is `auto`, the JVM will continue execution without using the\n+     - If `AOTMode` was originally `auto`, the JVM will continue execution without using the\n@@ -4136,1 +4176,1 @@\n-       `-XX:AOTMode=auto -Xlog:cds` to see if the AOT cache can be used or not.\n+       `-XX:AOTMode=auto -Xlog:aot` to see if the AOT cache can be used or not.\n@@ -4153,0 +4193,10 @@\n+The first occurrence of the special sequence `%p` in `*configfile* and `*cachefile* is replaced\n+with the process ID of the JVM process launched in the command-line, and likewise the\n+first occurrence of `%t` is replace by the JVM's startup timestamp.\n+(After replacement there must be no further occurrences of `%p` or `%t`, to prevent\n+problems with sub-processes.)  For example:\n+\n+>   `java -XX:AOTConfiguration=foo%p.aotconfig -XX:AOTCacheOutput=foo%p.aot -cp foo.jar Foo`\n+\n+will create two files: `foopid123.aotconfig` and `foopid123.aot`, where `123` is the\n+process ID of the JVM that has executed the application `Foo`.\n","filename":"src\/java.base\/share\/man\/java.md","additions":71,"deletions":21,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -104,2 +104,14 @@\n-                case LINUX:\n-                    return lm;      \/\/ All options are valid for Linux\n+                case LINUX: {\n+                    \/\/ All options are valid for Linux, but VFORK is deprecated and results\n+                    \/\/ in a warning\n+                    if (lm == LaunchMechanism.VFORK) {\n+                        System.err.println(\"VFORK MODE DEPRECATED\");\n+                        System.err.println(\"\"\"\n+                                          The VFORK launch mechanism has been deprecated for being dangerous.\n+                                          It will be removed in a future java version. Either remove the\n+                                          jdk.lang.Process.launchMechanism property (preferred) or use FORK mode\n+                                          instead (-Djdk.lang.Process.launchMechanism=FORK).\n+                                          \"\"\");\n+                    }\n+                    return lm;\n+                }\n@@ -112,2 +124,0 @@\n-                case WINDOWS:\n-                    \/\/ fall through to throw to Error\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -698,1 +698,3 @@\n-        write ( AWT_WRITEPIPE, &wakeUp_char, 1 );\n+        if (write(AWT_WRITEPIPE, &wakeUp_char, 1) < 0) {\n+            DTRACE_PRINTLN(\"wakeUp(): write to AWT pipe failed\");\n+        }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/xawt\/XToolkit.c","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-        \/\/ For now the default is false.\n-        ALLOW_STREAMING_OUTPUT = \"\".equals(s2) || Boolean.parseBoolean(s2);\n+        ALLOW_STREAMING_OUTPUT = !(\"false\".equals(s2));\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotVirtualMachine.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -273,0 +273,10 @@\n+    \/**\n+     * Set the maximum event emission rate for the CPU time sampler\n+     *\n+     * Setting rate to 0 turns off the CPU time sampler.\n+     *\n+     * @param rate the new rate in events per second\n+     * @param autoAdapt true if the rate should be adapted automatically\n+     *\/\n+    public static native void setCPUThrottle(double rate, boolean autoAdapt);\n+\n@@ -690,0 +700,64 @@\n+\n+    \/**\n+     * Sets method tracing filters.\n+     *\n+     * A filter can be a class, a method, or an annotation.\n+     *\n+     * For example, the following three filters:\n+     * <ul>\n+     * <li>Method timing on all methods in class com.foo.Bar<\/li>\n+     * <li>Method tracing on the method com.foo.Bar::baz<\/li>\n+     * <li>Method timing and tracing on all methods or classes with the annotation @com.foo.Foo<\/li>\n+     * <\/ul>\n+     * can be set using the following code:\n+     * <pre>\n+     * String[] classes = new String[3];\n+     * classes[0] = \"com\/foo\/Bar\";\n+     * classes[1] = \"com\/foo\/Bar\";\n+     * classes[2] = null;\n+     *\n+     * String[] methods = new String[3];\n+     * methods[0] = null;\n+     * methods[1] = \"baz\";\n+     * methods[2] = null;\n+     *\n+     * String[] annotations = new String[3];\n+     * annotations[0] = null;\n+     * annotations[1] = null;\n+     * annotations[2] = \"com\/foo\/Foo\";\n+     *\n+     * int[] modifications = new int[3];\n+     * modifications[0] = 1; \/\/ filter should apply to timing\n+     * modifications[1] = 2; \/\/ filter should apply to tracing\n+     * modifications[2] = 1 | 2; \/\/ filter should apply to both timing and tracing\n+     *\n+     * JVM.setMethodTraceFilters(classes, methods, annotations, modifications);\n+     * <\/pre>\n+     * The filter will be applied to currently and future loaded classes.\n+     * <p>\n+     * If a method is overloaded, the filter matches against all methods. It's not possible\n+     * to match specific method parameters or annotation values.\n+     * <p>\n+     * Only one type of a filter - class, method, or annotation - can be used per array index.\n+     * <p>\n+     * If the filter is matched, JVMUpcalls::onMethodTrace will be invoked with\n+     * the bytecode. If a filter is replaced, and method no longer requires instrumentation,\n+     * the method will also be called with modification = 0;\n+     *\n+     * @param classes, not {@code null}, array of class names\n+     * @param methods, not {@code null}, array of method names\n+     * @param annotations, not {@code null}, array of annotation names\n+     * @param modifications, not {@code null}, array of modification flags\n+     * @return the published IDs, or null if no classes has been published.\n+     *\/\n+    public static native long[] setMethodTraceFilters(\n+            String[] classes,\n+            String[] methods,\n+            String[] annotations,\n+            int[] modification);\n+    \/**\n+     * Returns IDs for method-traced classes that have been unloaded.\n+     *\n+     * @return the unloaded IDs, or null if no unloading has occurred.\n+     *\/\n+    public static native long[] drainStaleMethodTracerIds();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":75,"deletions":1,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.jfr.internal.tracing.PlatformTracer;\n+\n@@ -170,0 +172,31 @@\n+\n+    \/**\n+     * Called by the JVM to update method tracing instrumentation.\n+     * <p>\n+     * @param module the module the class belongs to\n+     * @param classLoader the class loader the class is being loaded for\n+     * @param className the internal class name, i.e. java\/lang\/String.\n+     * @param bytecode the bytecode to modify\n+     * @param methodIds the method IDs\n+     * @param names constant pool indices of method names\n+     * @param signatures constant pool indices of method signatures\n+     * @param modifications integer mask describing the modification\n+     *\n+     * @return the instrumented bytecode, or null if the class can't or shouldn't be modified.\n+     *\/\n+    public static byte[] onMethodTrace(Module module, ClassLoader classLoader, String className,\n+                                       byte[] bytecode, long[] methodIds, String[] names, String[] signatures,\n+                                       int[] modifications) {\n+        return PlatformTracer.onMethodTrace(module, classLoader, className,\n+                                            bytecode, methodIds, names, signatures,\n+                                            modifications);\n+    }\n+\n+    \/**\n+     * Called by the JVM to publish a class ID that can safely be used by the Method Timing event.\n+     * <p>\n+     * @param classId the methods to be published\n+     *\/\n+    public static void publishMethodTimersForClass(long classId) {\n+        PlatformTracer.publishClass(classId);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-\n+    private static volatile boolean inShutdown;\n@@ -77,1 +77,0 @@\n-    private boolean inShutdown;\n@@ -250,2 +249,2 @@\n-    synchronized void setInShutDown() {\n-        this.inShutdown = true;\n+    static void setInShutDown() {\n+        inShutdown = true;\n@@ -254,2 +253,2 @@\n-    synchronized boolean isInShutDown() {\n-        return this.inShutdown;\n+    static boolean isInShutDown() {\n+        return inShutdown;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-                boolean reportOnExit = recorder.isInShutDown() && !reports.isEmpty();\n+                boolean reportOnExit = PlatformRecorder.isInShutDown() && !reports.isEmpty();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -857,1 +858,1 @@\n-            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem, peek);\n+            int n = receive0(fd, resultContainer, NIO_ACCESS.getBufferAddress(bb) + pos, rem, peek);\n@@ -1040,1 +1041,1 @@\n-            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+            int written = send0(fd, NIO_ACCESS.getBufferAddress(bb) + pos, rem, addr,\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -600,1 +601,1 @@\n-            int n = receive0(fd, resultContainer, ((DirectBuffer)bb).address() + pos, rem);\n+            int n = receive0(fd, resultContainer, NIO_ACCESS.getBufferAddress(bb) + pos, rem);\n@@ -909,1 +910,1 @@\n-            int written = send0(fd, ((DirectBuffer)bb).address() + pos, rem, addr,\n+            int written = send0(fd, NIO_ACCESS.getBufferAddress(bb) + pos, rem, addr,\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-compiler\/runtime\/Test8168712.java 8211769,8211771 generic-ppc64,generic-ppc64le,linux-s390x\n+compiler\/runtime\/Test8168712.java#with-dtrace 8211769,8211771 generic-ppc64,generic-ppc64le,linux-s390x\n+compiler\/runtime\/Test8168712.java#without-dtrace 8211769,8211771 generic-ppc64,generic-ppc64le,linux-s390x\n@@ -81,2 +82,1 @@\n-compiler\/c2\/irTests\/TestFloat16ScalarOperations.java 8355708 linux-aarch64\n-compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java 8355708 linux-aarch64\n+compiler\/startup\/StartupOutput.java 8358129 windows-all\n@@ -94,1 +94,0 @@\n-gc\/TestAllocHumongousFragment.java#iu-aggressive 8298781 generic-all\n@@ -97,6 +96,0 @@\n-gc\/TestAlwaysPreTouchBehavior.java#ParallelCollector 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#SerialCollector 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#Shenandoah 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#G1 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#Z 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#Epsilon 8334513 generic-all\n@@ -168,0 +161,3 @@\n+vmTestbase\/gc\/gctests\/FinalizeTest04\/FinalizeTest04.java 8284234 generic-all\n+vmTestbase\/gc\/gctests\/PhantomReference\/phantom001\/phantom001.java 8284234 generic-all\n+\n@@ -173,1 +169,1 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/TestDescription.java 8202971 generic-all\n+vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/TestDescription.java 8358094 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+java\/awt\/Frame\/MaximizedToMaximized\/MaximizedToMaximized.java 8340374 macosx-all\n@@ -125,1 +126,0 @@\n-java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java 8341370 macosx-all\n@@ -130,0 +130,1 @@\n+java\/awt\/dnd\/FileListBetweenJVMsTest\/FileListBetweenJVMsTest.java 8353673 macosx-all\n@@ -131,1 +132,1 @@\n-java\/awt\/dnd\/MissingDragExitEventTest\/MissingDragExitEventTest.java 8288839 windows-x64\n+java\/awt\/dnd\/MissingDragExitEventTest\/MissingDragExitEventTest.java 8288839 windows-x64,macosx-all\n@@ -490,1 +491,0 @@\n-java\/awt\/Graphics2D\/CopyAreaOOB.java 8343106 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}