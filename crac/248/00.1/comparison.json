{"files":[{"patch":"@@ -313,1 +313,1 @@\n-      msvc-toolset-version: '14.43'\n+      msvc-toolset-version: '14.44'\n@@ -325,1 +325,1 @@\n-      msvc-toolset-version: '14.43'\n+      msvc-toolset-version: '14.44'\n@@ -364,11 +364,11 @@\n-  test-linux-x64-static:\n-    name: linux-x64-static\n-    needs:\n-      - build-linux-x64\n-      - build-linux-x64-static\n-    uses: .\/.github\/workflows\/test.yml\n-    with:\n-      platform: linux-x64\n-      bootjdk-platform: linux-x64\n-      runs-on: ubuntu-22.04\n-      static-suffix: \"-static\"\n+#  test-linux-x64-static:\n+#    name: linux-x64-static\n+#    needs:\n+#      - build-linux-x64\n+#      - build-linux-x64-static\n+#    uses: .\/.github\/workflows\/test.yml\n+#    with:\n+#      platform: linux-x64\n+#      bootjdk-platform: linux-x64\n+#      runs-on: ubuntu-22.04\n+#      static-suffix: \"-static\"\n","filename":".github\/workflows\/main.yml","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+          - 'jdk\/crac'\n+          - 'jdk\/since checks'\n@@ -81,0 +83,6 @@\n+          - test-name: 'jdk\/crac'\n+            test-suite: 'test\/jdk\/jdk\/crac\/'\n+\n+          - test-name: 'jdk\/since checks'\n+            test-suite: 'test\/jdk\/:jdk_since_checks'\n+\n@@ -186,0 +194,6 @@\n+      - name: 'Setup CRIU'\n+        uses: .\/.github\/actions\/setup-criu\n+        with:\n+          jdk-path: ${{ steps.bundles.outputs.jdk-path }}\n+        if: runner.os == 'Linux' && matrix.test-name == 'jdk\/crac'\n+\n@@ -198,1 +212,1 @@\n-          JTREG='JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash;VERBOSE=fail,error,time;KEYWORDS=!headful;${{ steps.extra-options.outputs.extra-problem-lists }}'\n+          JTREG=\"JAVA_OPTIONS=$JAVA_OPTIONS;VERBOSE=fail,error,time;KEYWORDS=!headful;${{ steps.extra-options.outputs.extra-problem-lists }}\"\n@@ -202,0 +216,3 @@\n+          JAVA_OPTIONS: >-\n+            -XX:-CreateCoredumpOnCrash\n+            ${{ matrix.test-name == 'jdk\/crac' && '-Djdk.test.docker.retain.image=true -Djdk.test.crac.reuse.image=true' || '' }}\n","filename":".github\/workflows\/test.yml","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    -tag crac:cmopt:'CRaC:' \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -161,0 +161,4 @@\n+ifneq ($(call check-jvm-feature, cpu_feature_active), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_CPU_FEATURE_ACTIVE=0\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,0 +67,4 @@\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -310,0 +310,4 @@\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -417,0 +417,4 @@\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -43,0 +44,7 @@\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# if defined(__clang__) && defined(__STRICT_ANSI__)\n+\/\/ clang <stdbool.h> is missing this definition compared to gcc\n+#  define _Bool bool\n+# endif\n+# include <sys\/platform\/x86.h>\n+#endif\n@@ -49,0 +57,6 @@\n+#if 0\n+FIXME:CPUFeatures1\n+uint64_t VM_Version::_glibc_features;\n+uint64_t VM_Version::_features_saved;\n+uint64_t VM_Version::_glibc_features_saved;\n+#endif\n@@ -51,1 +65,5 @@\n-const char* VM_Version::_features_names[] = { CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::      _features_names[] = {   CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+#if 0\n+FIXME:CPUFeatures1\n+const char* VM_Version::_glibc_features_names[] = { GLIBC_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+#endif\n@@ -90,2 +108,11 @@\n-  assert ((!Universe::is_fully_initialized() || _features.supports_feature(CPU_FLUSH)), \"clflush should be available\");\n-  return true;\n+  if (!Universe::is_fully_initialized()) {\n+    return true;\n+  }\n+  if (_features.supports_feature(CPU_FLUSH)) {\n+    return true;\n+  }\n+  if (FLAG_IS_DEFAULT(CPUFeatures)) {\n+    vm_exit_during_initialization(\"clflush should be available\");\n+  }\n+  vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: 0x%llx\", 1ULL << CPU_FLUSH));\n+  return false;\n@@ -850,1 +877,260 @@\n-void VM_Version::get_processor_features() {\n+#if 0\n+FIXME:CPUFeatures1\n+uint64_t VM_Version::CPUFeatures_parse(const char *str, uint64_t &glibc_features) {\n+  glibc_features = _glibc_features;\n+#ifndef LINUX\n+  _ignore_glibc_not_using = true;\n+  return _features;\n+#endif\n+  if (str == nullptr || strcmp(str, \"native\") == 0) {\n+    return _features;\n+  }\n+  if (strcmp(str, \"ignore\") == 0) {\n+    _ignore_glibc_not_using = true;\n+    return _features;\n+  }\n+  glibc_features = 0;\n+  if (strcmp(str, \"generic\") == 0) {\n+    \/\/ 32-bit x86 cannot rely on anything.\n+    return 0\n+#ifdef AMD64\n+      \/\/ The following options are all in \/proc\/cpuinfo of one of the first 64-bit CPUs - Atom D2700 (and Opteron 1352): https:\/\/superuser.com\/q\/1572306\/1015048\n+      | CPU_SSE \/\/ enabled in 'gcc -Q --help=target', used by OpenJDK\n+      | CPU_SSE2 \/\/ enabled in 'gcc -Q --help=target', required by OpenJDK\n+      | CPU_FXSR \/\/ enabled in 'gcc -Q --help=target', not used by OpenJDK\n+      | CPU_MMX \/\/ enabled in 'gcc -Q --help=target', used only by 32-bit x86 OpenJDK\n+      | CPU_TSC \/\/ not used by gcc, used by OpenJDK\n+      | CPU_CX8 \/\/ gcc detects it to set cpu \"pentium\" (=32-bit only), used by OpenJDK\n+      | CPU_CMOV \/\/ gcc detects it to set cpu \"pentiumpro\" (=32-bit only), used by OpenJDK\n+      | CPU_FLUSH \/\/ =\"clflush\" in cpuinfo, not used by gcc, required by OpenJDK\n+      \/\/ GLIBC_MOVBE is disabled in 'gcc -Q --help=target' and for example i7-720QM does not support it\n+      \/\/ GLIBC_LAHFSAHF is disabled in 'gcc -Q --help=target' and \"Early Intel Pentium 4 CPUs with Intel 64 support ... lacked the LAHF and SAHF instructions\"\n+#endif\n+    ;\n+  }\n+  char *endptr;\n+  errno = 0;\n+  uint64_t retval;\n+  unsigned long long ull = strtoull(str, &endptr, 0);\n+  retval = ull;\n+  if (!errno && *endptr == ',' && retval == ull) {\n+    ull = strtoull(endptr + 1, &endptr, 0);\n+    glibc_features = ull;\n+    if (!errno && !*endptr && glibc_features == ull) {\n+      return retval;\n+    }\n+  }\n+  vm_exit_during_initialization(err_msg(\"VM option 'CPUFeatures=%s' must be of the form: 0xnum,0xnum\", str));\n+  return -1;\n+}\n+\n+bool VM_Version::_ignore_glibc_not_using = false;\n+#ifdef LINUX\n+const char VM_Version::glibc_prefix[] = \":glibc.cpu.hwcaps=\";\n+const size_t VM_Version::glibc_prefix_len = strlen(glibc_prefix);\n+\n+bool VM_Version::glibc_env_set(char *disable_str) {\n+#define TUNABLES_NAME \"GLIBC_TUNABLES\"\n+#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n+  char *env_val = disable_str;\n+  const char *env = getenv(TUNABLES_NAME);\n+  if (env && (strcmp(env, env_val) == 0 || (!INCLUDE_CPU_FEATURE_ACTIVE && getenv(REEXEC_NAME)))) {\n+    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Environment variable already set, glibc CPU_FEATURE_ACTIVE is unavailable - re-exec suppressed: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      return true;\n+    }\n+  }\n+  {\n+    ResourceMark rm;\n+    size_t env_buf_size = strlen(disable_str) + (!env ? 0 : strlen(env) + 100);\n+    char *env_buf = NEW_RESOURCE_ARRAY(char, env_buf_size);\n+    if (env) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n+      if (!hwcaps) {\n+        strcpy(env_buf, env);\n+        strcat(env_buf, disable_str);\n+      } else {\n+        const char *colon = strchr(hwcaps, ':');\n+        if (!colon) {\n+          strcpy(env_buf, env);\n+          strcat(env_buf, disable_str + glibc_prefix_len);\n+        } else {\n+          int err = jio_snprintf(env_buf, env_buf_size, \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n+          assert(err >= 0 && (unsigned) err < env_buf_size, \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+        }\n+      }\n+      env_val = env_buf;\n+    }\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+    }\n+    if (setenv(TUNABLES_NAME, env_val, 1)) {\n+      vm_exit_during_initialization(err_msg(\"setenv \" TUNABLES_NAME \" error: %m\"));\n+    }\n+  }\n+\n+  if (getenv(REEXEC_NAME)) {\n+    vm_exit_during_initialization(err_msg(\"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str));\n+  }\n+  if (setenv(REEXEC_NAME, \"1\", 1)) {\n+    vm_exit_during_initialization(err_msg(\"setenv \" REEXEC_NAME \" error: %m\"));\n+  }\n+#undef REEXEC_NAME\n+  return false;\n+}\n+\n+void VM_Version::glibc_reexec() {\n+  char *buf = nullptr;\n+  size_t buf_allocated = 0;\n+  size_t buf_used = 0;\n+#define CMDLINE \"\/proc\/self\/cmdline\"\n+  int fd = open(CMDLINE, O_RDONLY);\n+  if (fd == -1)\n+    vm_exit_during_initialization(err_msg(\"Cannot open \" CMDLINE \": %m\"));\n+  ssize_t got;\n+  do {\n+    if (buf_used == buf_allocated) {\n+      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n+      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n+      if (buf == nullptr)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu bytes\", buf_allocated));\n+    }\n+    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n+    if (got == -1)\n+      vm_exit_during_initialization(err_msg(\"Cannot read \" CMDLINE \": %m\"));\n+    buf_used += got;\n+  } while (got);\n+  if (close(fd))\n+    vm_exit_during_initialization(err_msg(\"Cannot close \" CMDLINE \": %m\"));\n+  char **argv = nullptr;\n+  size_t argv_allocated = 0;\n+  size_t argv_used = 0;\n+  char *s = buf;\n+  while (s <= buf + buf_used) {\n+    if (argv_used == argv_allocated) {\n+      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n+      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n+      if (argv == nullptr)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu pointers\", argv_allocated));\n+    }\n+    if (s == buf + buf_used) {\n+      break;\n+    }\n+    argv[argv_used++] = s;\n+    s += strnlen(s, buf + buf_used - s);\n+    if (s == buf + buf_used)\n+      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n+    ++s;\n+  }\n+  argv[argv_used] = nullptr;\n+#undef CMDLINE\n+\n+#define EXEC \"\/proc\/self\/exe\"\n+  execv(EXEC, argv);\n+  vm_exit_during_initialization(err_msg(\"Cannot re-execute \" EXEC \": %m\"));\n+#undef EXEC\n+}\n+\n+\/\/ Returns whether we should have got set a GLIBC_TUNABLES environment variables but did not get any.\n+bool VM_Version::glibc_not_using() {\n+  if (_ignore_glibc_not_using)\n+    return true;\n+\n+  uint64_t       features_expected =   MAX_CPU - 1;\n+  uint64_t glibc_features_expected = MAX_GLIBC - 1;\n+  if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+          features_expected =       _features;\n+    glibc_features_expected = _glibc_features;\n+  }\n+  uint64_t shouldnotuse_CPU   =       features_expected & ~      _features;\n+  uint64_t shouldnotuse_GLIBC = glibc_features_expected & ~_glibc_features;\n+\n+#ifndef ASSERT\n+  if (!shouldnotuse_CPU && !shouldnotuse_GLIBC)\n+    return true;\n+#endif\n+\n+  \/\/ glibc: sysdeps\/x86\/get-isa-level.h:\n+  \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMOV)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, CX8)\n+  \/\/ glibc:     && CPU_FEATURE_CPU_P (cpu_features, FPU)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FXSR)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MMX)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE2))\n+  \/\/ glibc:     isa_level = GNU_PROPERTY_X86_ISA_1_BASELINE;\n+  if ((_features & CPU_CMOV) &&\n+      (_features & CPU_CX8) &&\n+      \/\/ FPU is always present on i686+: (_features & CPU_FPU) &&\n+      (_features & CPU_SSE2)) {\n+    \/\/ These cannot be disabled by GLIBC_TUNABLES.\n+    if (shouldnotuse_CPU & (CPU_FXSR | CPU_MMX | CPU_SSE)) {\n+      assert(!(shouldnotuse_CPU & CPU_SSE2), \"CPU_SSE2 in both _features and shouldnotuse_CPU cannot happen\");\n+      \/\/ FIXME: The choice should be based on glibc impact, not the feature age.\n+      \/\/ CX8 is i586+, CMOV is i686+ 1995+, SSE2 is 2000+\n+      shouldnotuse_CPU |= CPU_SSE2;\n+    }\n+    if ((_features & CPU_FXSR) &&\n+        (_features & CPU_MMX) &&\n+        (_features & CPU_SSE)) {\n+      \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMPXCHG16B)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LAHF64_SAHF64)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, POPCNT)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_1)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_2))\n+      \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V2;\n+      if ((_features & CPU_POPCNT) &&\n+          (_features & CPU_SSSE3) &&\n+          (_features & CPU_SSE4_1) &&\n+          (_features & CPU_SSE4_2)) {\n+        if ((shouldnotuse_CPU & CPU_SSE3) ||\n+            (shouldnotuse_GLIBC & (GLIBC_CMPXCHG16 | GLIBC_LAHFSAHF))) {\n+          assert(!(shouldnotuse_CPU & CPU_SSE4_2), \"CPU_SSE4_2 in both _features and shouldnotuse_CPU cannot happen\");\n+          \/\/ POPCNT is 2007+, SSSE3 is 2006+, SSE4_1 is 2007+, SSE4_2 is 2008+.\n+          shouldnotuse_CPU |= CPU_SSE4_2;\n+        }\n+        if ((_features & CPU_SSE3) &&\n+            (_glibc_features & GLIBC_CMPXCHG16) &&\n+            (_glibc_features & GLIBC_LAHFSAHF)) {\n+          \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI1)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, F16C)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FMA)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LZCNT)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MOVBE))\n+          \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V3;\n+          if ((_features & CPU_AVX) &&\n+              (_features & CPU_AVX2) &&\n+              (_features & CPU_BMI1) &&\n+              (_features & CPU_BMI2) &&\n+              (_features & CPU_FMA) &&\n+              (_features & CPU_LZCNT) &&\n+              (_glibc_features & GLIBC_MOVBE)) {\n+            if (shouldnotuse_GLIBC & GLIBC_F16C) {\n+              assert(!(shouldnotuse_GLIBC & GLIBC_MOVBE), \"GLIBC_MOVBE in both _glibc_features and shouldnotuse_GLIBC cannot happen\");\n+              \/\/ FMA is 2012+, AVX2+BMI1+BMI2+LZCNT are 2013+, MOVBE is 2015+\n+              shouldnotuse_GLIBC |= GLIBC_MOVBE;\n+            }\n+            if (_glibc_features & GLIBC_F16C) {\n+              \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX512F)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512BW)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512CD)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512DQ)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512VL))\n+              \/\/ glibc:   isa_level |= GNU_PROPERTY_X86_ISA_1_V4;\n+              \/\/ All these flags are supported by disable() below.\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n@@ -852,0 +1138,153 @@\n+#define PASTE_TOKENS3(x, y, z) PASTE_TOKENS(x, PASTE_TOKENS(y, z))\n+  enum kind { KIND_CPU = 0, KIND_GLIBC, KIND_COUNT };\n+\n+  static const size_t tunables_size_max = 17;\n+  \/\/ 64 is # of bits in uint64_t VM_Version::_glibc_features.\n+  char disable_str[KIND_COUNT * 64 * (1\/*','*\/ + 1\/*'-'*\/ + tunables_size_max) + 1\/*'\\0'*\/];\n+  strcpy(disable_str, glibc_prefix);\n+  char *disable_end = disable_str + glibc_prefix_len;\n+  auto disable = [&](enum kind kind, uint64_t value, const char *tunables) {\n+    size_t remains = disable_str + sizeof(disable_str) - disable_end;\n+    guarantee(2 + strlen(tunables) < remains, \"internal error: disable_str overflow\");\n+    *disable_end++ = ',';\n+    *disable_end++ = '-';\n+    disable_end = stpcpy(disable_end, tunables);\n+  };\n+\n+#ifdef ASSERT\n+  uint64_t handled[KIND_COUNT] = { 0 };\n+#endif\n+  auto shouldnotuse_handled = [&](enum kind kind, uint64_t value, const char *kindstr, const char *tunables) {\n+    assert(strlen(tunables) <= tunables_size_max, \"Too long string %s\", tunables);\n+    assert((handled[kind] & value) == 0, \"already used %s_%s\", kindstr, tunables);\n+    DEBUG_ONLY(handled[kind] |= value);\n+  };\n+#define EXCESSIVE_HANDLED(kind, tunables) shouldnotuse_handled(PASTE_TOKENS(KIND_, kind), PASTE_TOKENS3(kind, _, tunables), STR(kind), STR(tunables))\n+\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# define FEATURE_ACTIVE(tunables) CPU_FEATURE_ACTIVE(tunables)\n+#else\n+# define FEATURE_ACTIVE(tunables) true\n+#endif\n+\n+  const uint64_t shouldnotuseval[KIND_COUNT] = { shouldnotuse_CPU, shouldnotuse_GLIBC };\n+  auto shouldnotuse = [&](enum kind kind, uint64_t value, const char *kindstr, const char *tunables, bool feature_active) {\n+    shouldnotuse_handled(kind, value, kindstr, tunables);\n+    if ((shouldnotuseval[kind] & value) != 0 && feature_active) {\n+      disable(kind, value, tunables);\n+    }\n+  };\n+#define EXCESSIVE(kind, tunables) \\\n+    shouldnotuse(PASTE_TOKENS(KIND_, kind), PASTE_TOKENS3(kind, _, tunables), STR(kind), STR(tunables), FEATURE_ACTIVE(tunables))\n+\n+  EXCESSIVE(CPU  , AVX     );\n+  EXCESSIVE(CPU  , CX8     );\n+  EXCESSIVE(CPU  , FMA     );\n+  EXCESSIVE(CPU  , RTM     );\n+  EXCESSIVE(CPU  , AVX2    );\n+  EXCESSIVE(CPU  , BMI1    );\n+  EXCESSIVE(CPU  , BMI2    );\n+  EXCESSIVE(CPU  , CMOV    );\n+  EXCESSIVE(CPU  , ERMS    );\n+  EXCESSIVE(CPU  , SSE2    );\n+  EXCESSIVE(CPU  , LZCNT   );\n+  EXCESSIVE(CPU  , SSSE3   );\n+  EXCESSIVE(CPU  , POPCNT  );\n+  EXCESSIVE(CPU  , SSE4_1  );\n+  EXCESSIVE(CPU  , SSE4_2  );\n+  EXCESSIVE(CPU  , AVX512F );\n+  EXCESSIVE(CPU  , AVX512CD);\n+  EXCESSIVE(CPU  , AVX512BW);\n+  EXCESSIVE(CPU  , AVX512DQ);\n+  EXCESSIVE(CPU  , AVX512ER);\n+  EXCESSIVE(CPU  , AVX512PF);\n+  EXCESSIVE(CPU  , AVX512VL);\n+  EXCESSIVE(GLIBC, IBT     );\n+  EXCESSIVE(GLIBC, FMA4    );\n+  EXCESSIVE(GLIBC, MOVBE   );\n+  EXCESSIVE(GLIBC, SHSTK   );\n+  EXCESSIVE(GLIBC, XSAVE   );\n+  EXCESSIVE(GLIBC, OSXSAVE );\n+  EXCESSIVE(GLIBC, HTT     );\n+#undef EXCESSIVE\n+#undef EXCESSIVE3\n+\n+#ifdef ASSERT\n+  \/\/ These cannot be disabled by GLIBC_TUNABLES interface.\n+#define GLIBC_UNSUPPORTED(kind, hotspot) EXCESSIVE_HANDLED(kind, hotspot)\n+  GLIBC_UNSUPPORTED(CPU  , 3DNOW_PREFETCH   );\n+  GLIBC_UNSUPPORTED(CPU  , SSE4A            );\n+  GLIBC_UNSUPPORTED(CPU  , TSC              );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV_BIT       );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV           );\n+  GLIBC_UNSUPPORTED(CPU  , AES              );\n+  GLIBC_UNSUPPORTED(CPU  , CLMUL            );\n+  GLIBC_UNSUPPORTED(CPU  , ADX              );\n+  GLIBC_UNSUPPORTED(CPU  , SHA              );\n+  GLIBC_UNSUPPORTED(CPU  , VZEROUPPER       );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPOPCNTDQ );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPCLMULQDQ);\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VAES      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VNNI      );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSH            );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSHOPT         );\n+  GLIBC_UNSUPPORTED(CPU  , CLWB             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI2     );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI      );\n+  GLIBC_UNSUPPORTED(CPU  , HV               );\n+  GLIBC_UNSUPPORTED(CPU  , SSE3             );\n+  GLIBC_UNSUPPORTED(CPU  , SERIALIZE        );\n+  GLIBC_UNSUPPORTED(CPU  , RDTSCP           );\n+  GLIBC_UNSUPPORTED(CPU  , RDPID            );\n+  GLIBC_UNSUPPORTED(CPU  , FSRM             );\n+  GLIBC_UNSUPPORTED(CPU  , GFNI             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_BITALG    );\n+  GLIBC_UNSUPPORTED(CPU  , F16C             );\n+  GLIBC_UNSUPPORTED(CPU  , PKU              );\n+  GLIBC_UNSUPPORTED(CPU  , OSPKE            );\n+  GLIBC_UNSUPPORTED(CPU  , CET_IBT          );\n+  GLIBC_UNSUPPORTED(CPU  , CET_SS           );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_IFMA      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX_IFMA         );\n+  GLIBC_UNSUPPORTED(CPU  , APX_F            );\n+  GLIBC_UNSUPPORTED(CPU  , SHA512           );\n+  \/\/ These are handled as an exception above.\n+  GLIBC_UNSUPPORTED(CPU  , FXSR             );\n+  GLIBC_UNSUPPORTED(CPU  , MMX              );\n+  GLIBC_UNSUPPORTED(CPU  , SSE              );\n+  GLIBC_UNSUPPORTED(CPU  , HT               );\n+  GLIBC_UNSUPPORTED(GLIBC, CMPXCHG16        );\n+  GLIBC_UNSUPPORTED(GLIBC, LAHFSAHF         );\n+  GLIBC_UNSUPPORTED(GLIBC, F16C             );\n+#undef GLIBC_UNSUPPORTED\n+\n+  auto check_kind = [&](enum kind kind, const char *kindstr, uint64_t mask) {\n+    if (handled[kind] != mask) {\n+      vm_exit_during_initialization(err_msg(\"internal error: Unsupported disabling of some %s_* 0x%\" PRIx64 \" != full 0x%\" PRIx64, kindstr, handled[kind], mask));\n+    }\n+  };\n+#define CHECK_KIND(kind) check_kind(PASTE_TOKENS(KIND_, kind), STR(kind), PASTE_TOKENS(MAX_, kind) - 1)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+#endif \/\/ ASSERT\n+\n+  *disable_end = 0;\n+  if (disable_end == disable_str + glibc_prefix_len)\n+    return true;\n+  if (glibc_env_set(disable_str))\n+    return true;\n+  return false;\n+}\n+#endif \/\/LINUX\n+\n+void VM_Version::print_using_features_cr() {\n+  if (_ignore_glibc_not_using) {\n+    tty->print_cr(\"CPU features are being kept intact as requested by -XX:CPUFeatures=ignore\");\n+  } else {\n+    tty->print_cr(\"CPU features being used are: -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, _features, _glibc_features);\n+  }\n+}\n+#endif\n+\n+void VM_Version::get_processor_features_hardware() {\n@@ -855,0 +1294,9 @@\n+#if 0\n+FIXME:CPUFeatures1\n+  _features = 0;\n+  _glibc_features = 0;\n+FIXME:CPUFeatures2\n+  _features = 0;\n+FIXME:CPUFeatures3\n+#endif\n+\/\/FIXME:CPUFeatures4\n@@ -870,0 +1318,8 @@\n+#if 0\n+FIXME:CPUFeatures1\n+    _cpu_features = _features;   \/\/ Preserve features\n+    LINUX_ONLY(_glibc_features = _cpuid_info.glibc_flags();)\n+FIXME:CPUFeatures2\n+    _cpu_features = _features;   \/\/ Preserve features\n+FIXME:CPUFeatures3\n+#endif\n@@ -871,0 +1327,1 @@\n+\/\/FIXME:CPUFeatures4\n@@ -883,0 +1340,9 @@\n+  if (ShowCPUFeatures) {\n+#if 0\n+FIXME:CPUFeatures1\n+    tty->print_cr(\"This machine's CPU features are: -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, _features, _glibc_features);\n+#endif\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hotspot() {\n@@ -885,0 +1351,2 @@\n+    if (!FLAG_IS_DEFAULT(CPUFeatures))\n+      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: 0x%llx\", 1ULL << CPU_SSE2));\n@@ -1109,0 +1577,1 @@\n+\n@@ -1110,0 +1579,7 @@\n+#if 0\n+FIXME:CPUFeatures1\n+  insert_features_names(buf + cpu_info_size, sizeof(buf) - cpu_info_size);\n+FIXME:CPUFeatures2\n+  insert_features_names(buf + cpu_info_size, sizeof(buf) - cpu_info_size, _features_names);\n+FIXME:CPUFeatures3\n+#endif\n@@ -1112,0 +1588,1 @@\n+\/\/FIXME:CPUFeatures4\n@@ -2094,0 +2571,82 @@\n+\/\/ Print the feature names as \" = feat1, ..., featN\\n\";\n+void VM_Version::missing_features(uint64_t features_missing, uint64_t glibc_features_missing) {\n+  tty->print(\"; missing features of this CPU are \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X \" =\", features_missing, glibc_features_missing);\n+  char buf[512] = \"\";\n+#if 0\n+FIXME:CPUFeatures1\n+  \/\/ insert_features_names() does crash for undefined too high-numbered features.\n+  insert_features_names(buf, sizeof(buf)          ,       features_missing & (  MAX_CPU - 1));\n+  char *s = buf + strlen(buf);\n+  insert_features_names(s  , buf + sizeof(buf) - s, glibc_features_missing & (MAX_GLIBC - 1));\n+#endif\n+  tty->print_cr(\n+    \"%s\\n\"\n+    \"If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures .\",\n+    \/* + 1 to skip the first ','. *\/\n+    buf + 1);\n+}\n+\n+static_assert(sizeof(VM_Version::CPUFeaturesBinary) == 2 * 8, \"unexpected sizeof\");\n+bool VM_Version::cpu_features_binary(VM_Version::CPUFeaturesBinary *data) {\n+#if 0\n+FIXME:CPUFeatures1\n+  data->cpu = _features;\n+  data->glibc = _glibc_features;\n+#endif\n+  return true;\n+}\n+\n+bool VM_Version::cpu_features_binary_check(const CPUFeaturesBinary *data) {\n+#if 0\n+FIXME:CPUFeatures1\n+  assert(CPUFeatures == nullptr, \"This should only be called on restore and CPUFeatures is not restore-settable\");\n+\n+  if (!data) {\n+    return false;\n+  }\n+\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"This snapshot's stored CPU features are: -XX:CPUFeatures=0x%\" PRIx64 \",0x%\" PRIx64, data->cpu, data->glibc);\n+  }\n+\n+  uint64_t   CPUFeatures_x64 = data->cpu;\n+  uint64_t GLIBCFeatures_x64 = data->glibc;\n+\n+  uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+  uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  if (features_missing || glibc_features_missing) {\n+    tty->print(\n+      \"You have to specify -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X\n+      \" together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X,\n+      CPUFeatures_x64 & _features, GLIBCFeatures_x64 & _glibc_features,\n+      CPUFeatures_x64, GLIBCFeatures_x64);\n+    missing_features(features_missing, glibc_features_missing);\n+    if (!IgnoreCPUFeatures) {\n+      return false;\n+    }\n+  }\n+\n+        _features_saved =       _features;\n+  _glibc_features_saved = _glibc_features;\n+\n+        _features =   CPUFeatures_x64;\n+  _glibc_features = GLIBCFeatures_x64;\n+\n+  if (ShowCPUFeatures && !CRaCRestoreFrom) {\n+    print_using_features_cr();\n+  }\n+\n+#ifdef LINUX\n+  \/\/ glibc_not_using() has done setenv(TUNABLES_NAME) and it expects us to re-exec ourselves.\n+  \/\/ But we were only checking the cpufeatures file before restoring the process so we ignore the result.\n+  glibc_not_using();\n+#endif\n+\n+#endif\n+  return true;\n+}\n+\n@@ -2142,1 +2701,48 @@\n-  get_processor_features();\n+\n+#if 0\n+FIXME:CPUFeatures1\n+  assert(      _features == 0,       \"_features should be zero at startup\");\n+  assert(_glibc_features == 0, \"_glibc_features should be zero at startup\");\n+#endif\n+  get_processor_features_hardware();\n+\n+#if 0\n+FIXME:CPUFeatures1\n+  assert(!CPUFeatures == FLAG_IS_DEFAULT(CPUFeatures), \"CPUFeatures parsing\");\n+\n+  uint64_t GLIBCFeatures_x64;\n+  uint64_t   CPUFeatures_x64 = CPUFeatures_parse(CPUFeatures, GLIBCFeatures_x64);\n+\n+  uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+  uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  if (features_missing || glibc_features_missing) {\n+    tty->print(\n+      \"Specified -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X\n+      \"; this machine's CPU features are \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X,\n+      CPUFeatures_x64, GLIBCFeatures_x64,\n+      _features, _glibc_features);\n+    missing_features(features_missing, glibc_features_missing);\n+    vm_exit_during_initialization();\n+  }\n+\n+        _features_saved =       _features;\n+  _glibc_features_saved = _glibc_features;\n+\n+        _features =   CPUFeatures_x64;\n+  _glibc_features = GLIBCFeatures_x64;\n+\n+  if (ShowCPUFeatures && !CRaCRestoreFrom) {\n+    print_using_features_cr();\n+  }\n+\n+#ifdef LINUX\n+  if (!glibc_not_using())\n+    glibc_reexec();\n+#endif\n+#endif\n+\n+  get_processor_features_hotspot();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":611,"deletions":5,"binary":false,"changes":616,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -86,1 +87,2 @@\n-                        : 2,\n+                        : 1,\n+               movbe    : 1,\n@@ -90,1 +92,1 @@\n-                        : 1,\n+               xsave    : 1,\n@@ -157,1 +159,3 @@\n-                            : 23;\n+                            : 7,\n+               fma4         : 1,\n+                            : 15;\n@@ -450,0 +454,6 @@\n+#if 0\n+FIXME:CPUFeatures1\n+    MAX_CPU = CPU_SHA512 << 1\n+FIXME:CPUFeatures2\n+FIXME:CPUFeatures3\n+#endif\n@@ -451,0 +461,1 @@\n+\/\/FIXME:CPUFeatures4\n@@ -453,0 +464,30 @@\n+#if 0\n+FIXME:CPUFeatures1\n+  \/* Tracking of a CPU feature for glibc *\/ \\\n+  enum Glibc_Feature_Flag : uint64_t {\n+#define GLIBC_FEATURE_FLAGS(decl) \\\n+    decl(FMA4,              \"fma4\",               0) \\\n+    decl(MOVBE,             \"movbe\",              1) \\\n+    decl(OSXSAVE,           \"osxsave\",            2) \\\n+    decl(IBT,               \"ibt\",                3) \\\n+    decl(SHSTK,             \"shstk\",              4) \/* Also known as cet_ss *\/ \\\n+    decl(XSAVE,             \"xsave\",              5) \\\n+    decl(CMPXCHG16,         \"cmpxchg16\",          6) \/* Also known in cpuinfo as cx16 and in glibc as cmpxchg16b *\/ \\\n+    decl(LAHFSAHF,          \"lahfsahf\",           7) \/* Also known in cpuinfo as lahf_lm and in glibc as lahf64_sahf64 *\/ \\\n+    decl(F16C,              \"f16c\",               8) \\\n+    decl(HTT,               \"htt\",                9) \/* hotspot calls it 'ht' but it is affected by threads_per_core() *\/\n+\n+#define DECLARE_GLIBC_FEATURE_FLAG(id, name, bit) GLIBC_##id = (1ULL << bit),\n+    GLIBC_FEATURE_FLAGS(DECLARE_GLIBC_FEATURE_FLAG)\n+#undef DECLARE_GLIBC_FEATURE_FLAG\n+    MAX_GLIBC = GLIBC_HTT << 1\n+  };\n+\n+  \/\/ glibc feature flags.\n+  static uint64_t _glibc_features;\n+\n+  static uint64_t _features_saved, _glibc_features_saved;\n+\n+FIXME:CPUFeatures2\n+FIXME:CPUFeatures3\n+#endif\n@@ -515,0 +556,1 @@\n+\/\/FIXME:CPUFeatures4\n@@ -516,0 +558,1 @@\n+  static const char* _glibc_features_names[];\n@@ -665,0 +708,28 @@\n+#if 0\n+FIXME:CPUFeatures1\n+#ifdef LINUX\n+    uint64_t glibc_flags() const {\n+      uint64_t result = 0;\n+      if (std_cpuid1_ecx.bits.movbe != 0)\n+        result |= GLIBC_MOVBE;\n+      if (std_cpuid1_ecx.bits.osxsave != 0)\n+        result |= GLIBC_OSXSAVE;\n+      if (std_cpuid1_ecx.bits.xsave != 0)\n+        result |= GLIBC_XSAVE;\n+      if (std_cpuid1_ecx.bits.cmpxchg16 != 0)\n+        result |= GLIBC_CMPXCHG16;\n+      if (std_cpuid1_ecx.bits.f16c != 0)\n+        result |= GLIBC_F16C;\n+      if (ext_cpuid1_ecx.bits.fma4 != 0)\n+        result |= GLIBC_FMA4;\n+      if (ext_cpuid1_ecx.bits.LahfSahf != 0)\n+        result |= GLIBC_LAHFSAHF;\n+      if (std_cpuid1_edx.bits.ht != 0)\n+        result |= GLIBC_HTT;\n+      return result;\n+    }\n+#else\n+    uint64_t glibc_flags() const { return 0; }\n+#endif \/\/LINUX\n+#endif\n+\n@@ -701,0 +772,17 @@\n+  static void get_processor_features_hardware();\n+  static void get_processor_features_hotspot();\n+\n+  static uint64_t CPUFeatures_parse(const char *str, uint64_t &glibc_features);\n+#ifdef LINUX\n+  static bool glibc_not_using();\n+  static bool glibc_env_set(char *disable_str);\n+  \/*[[noreturn]]*\/ static void glibc_reexec();\n+  \/\/ C++17: Make glibc_prefix and glibc_prefix_len constexpr.\n+  static const char glibc_prefix[];\n+  static const size_t glibc_prefix_len;\n+#endif \/\/LINUX\n+  \/\/ C++17: Make _ignore_glibc_not_using inline.\n+  static bool _ignore_glibc_not_using;\n+  static void print_using_features_cr();\n+  \/*[[noreturn]]*\/ static void missing_features(uint64_t features_missing, uint64_t glibc_features_missing);\n+\n@@ -769,0 +857,12 @@\n+  struct CPUFeaturesBinary {\n+    uint64_t cpu, glibc;\n+  };\n+  static bool cpu_features_binary(CPUFeaturesBinary *data);\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data);\n+#if 0\n+FIXME:CPUFeatures1\n+  static bool ignore_cpu_features() { return _ignore_glibc_not_using; }\n+#else\n+  static bool ignore_cpu_features() { return true; }\n+#endif\n+  static void restore_check(const char* str, const char* msg_prefix);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":103,"deletions":3,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+  struct CPUFeaturesBinary {};\n+  static bool cpu_features_binary(CPUFeaturesBinary *data) { return false; }\n+  static bool cpu_features_binary_check(const CPUFeaturesBinary *data) { return data == nullptr; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -927,0 +927,3 @@\n+void os::reset_cached_process_id() {\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -876,0 +876,3 @@\n+void os::reset_cached_process_id() {\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2017, 2022, Azul Systems, Inc. All rights reserved.\n@@ -26,0 +27,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -66,0 +68,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -85,0 +88,1 @@\n+# include <arpa\/inet.h>\n@@ -89,1 +93,0 @@\n-# include <sys\/stat.h>\n@@ -92,0 +95,1 @@\n+# include <sys\/sysmacros.h>\n@@ -109,1 +113,0 @@\n-# include <fcntl.h>\n@@ -118,0 +121,1 @@\n+# include <libgen.h>\n@@ -211,0 +215,2 @@\n+static int cached_pid = 0;\n+\n@@ -510,0 +516,5 @@\n+void os::Linux::initialize_processor_count() {\n+  set_processor_count((int) sysconf(_SC_NPROCESSORS_CONF));\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n@@ -511,1 +522,1 @@\n-  set_processor_count((int)sysconf(_SC_NPROCESSORS_CONF));\n+  initialize_processor_count();\n@@ -524,1 +535,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n@@ -1526,0 +1536,1 @@\n+\n@@ -1527,1 +1538,8 @@\n-  return ::getpid();\n+  \/\/ GLIBC < 2.25 caches pid in ::getpid(); we need to be able to reset this\n+  \/\/ on CRaC restore, therefore we will use our own caching.\n+  return cached_pid ? cached_pid : syscall(SYS_getpid);\n+}\n+\n+void os::reset_cached_process_id() {\n+  cached_pid = 0;\n+  cached_pid = current_process_id();\n@@ -4390,0 +4408,1 @@\n+  cached_pid = current_process_id();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -102,0 +103,1 @@\n+static jlong restore_time_count = 0;\n@@ -877,0 +879,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -899,0 +905,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1319,0 +1333,4 @@\n+  initialize_time_counters();\n+}\n+\n+void os::Posix::initialize_time_counters(void) {\n@@ -1320,0 +1338,5 @@\n+  restore_time_count = initial_time_count;\n+}\n+\n+void os::Posix::reset_time_counters(void) {\n+  restore_time_count = javaTimeNanos();\n@@ -1486,1 +1509,1 @@\n-  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec);\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + crac::monotonic_time_offset();\n@@ -1512,0 +1535,4 @@\n+jlong os::elapsed_counter_since_restore() {\n+  return os::javaTimeNanos() - restore_time_count;\n+}\n+\n@@ -2036,0 +2063,4 @@\n+int os::execv(const char *path, const char *argv[]) {\n+  return ::execv(path, (char * const *)argv);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  static void initialize_time_counters(void);\n+  static void reset_time_counters(void);\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n@@ -1181,1 +1181,1 @@\n-      const pid_t me = getpid();\n+      const pid_t me = os::current_process_id();\n@@ -1558,0 +1558,15 @@\n+\n+  sigemptyset(&blocked_sigs);\n+\/\/ RESTORE_SIGNAL is used only on Linux, other platform don't send this\n+#ifdef LINUX\n+  \/\/ The signal is used with default crexec library, other CRaCEngines might use\n+  \/\/ signals in a different way and having this signal blocked could interfere.\n+  const char *signal_engines[] = { \"criu\", \"criuengine\", \"sim\", \"simengine\", \"pause\", \"pauseengine\", nullptr };\n+  for (int i = 0; signal_engines[i] != nullptr; ++i) {\n+    if (strcmp(CRaCEngine, signal_engines[i]) == 0) {\n+      sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+      break;\n+    }\n+  }\n+#endif\n+\n@@ -1568,0 +1583,5 @@\n+static sigset_t* blocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &blocked_sigs;\n+}\n+\n@@ -1585,0 +1605,1 @@\n+  pthread_sigmask(SIG_BLOCK, blocked_signals(), nullptr);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -838,0 +839,1 @@\n+static jlong restore_performance_count;\n@@ -845,1 +847,0 @@\n-\n@@ -850,0 +851,5 @@\n+jlong os::elapsed_counter_since_restore() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceCounter(&count);\n+  return count.QuadPart - restore_performance_count;\n+}\n@@ -1129,0 +1135,1 @@\n+  restore_performance_count = initial_performance_count;\n@@ -1131,0 +1138,9 @@\n+void os::win32::reset_performance_counters() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceFrequency(&count);\n+  \/\/ Until we perform a real C\/R on Windows this is safe, performance frequency\n+  \/\/ should be the same. With real C\/R the counters will be probably incomparable.\n+  assert(performance_frequency == count.QuadPart, \"Performance frequency changed\");\n+  QueryPerformanceCounter(&count);\n+  restore_performance_count = count.QuadPart;\n+}\n@@ -1570,0 +1586,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -3900,0 +3943,3 @@\n+void os::reset_cached_process_id() {\n+}\n+\n@@ -4744,0 +4790,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == nullptr) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == nullptr) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5785,0 +5856,4 @@\n+int os::execv(const char *path, const char *argv[]) {\n+  return _execv(path, argv);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":76,"deletions":1,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -761,0 +761,12 @@\n+GrowableArray<int> ClassLoader::get_classpath_entry_fds() {\n+  GrowableArray<int> fds;\n+  assert(Thread::current()->is_VM_thread(), \"should be called from VM op\");\n+  \/\/ we don't use mutexes here because it is called from VM op\n+  for (ClassPathEntry *entry = first_append_entry(); entry != nullptr; entry = entry->next()) {\n+    if (entry->is_jar_file()) {\n+      fds.append(((ClassPathZipEntry *) entry)->get_fd());\n+    }\n+  }\n+  return fds;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -741,0 +741,4 @@\n+  template(jdk_internal_crac_mirror_Core,          \"jdk\/internal\/crac\/mirror\/Core\")                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+  template(checkpointRestoreInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -795,1 +796,5 @@\n-  uncommit_regions_if_necessary();\n+  if (should_cleanup_unused()) {\n+    cleanup_unused_regions(); \/\/ Includes uncommitting\n+  } else {\n+    uncommit_regions_if_necessary();\n+  }\n@@ -893,0 +898,20 @@\n+\/\/ The implementation of this should likely be OS-dependent. The current one is verified to have\n+\/\/ the desired effect on Linux, should probably also be on BSD. On others this may mostly be a\n+\/\/ useless work.\n+void G1CollectedHeap::cleanup_unused_regions() {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  log_debug(gc, heap)(\"Cleanup unused regions\");\n+  const size_t orig_capacity = capacity();\n+\n+  \/\/ Uncommit all free regions\n+  precond(orig_capacity >= G1HeapRegion::GrainBytes);\n+  shrink(orig_capacity - G1HeapRegion::GrainBytes \/* leave one region to pass G1HeapRegionManager's asserts *\/);\n+  uncommit_regions(UINT_MAX);\n+  assert(capacity() <= orig_capacity, \"unexpectedly gained capacity: %zu -> %zu\", orig_capacity, capacity());\n+\n+  \/\/ Commit them back\n+  expand(orig_capacity - capacity());\n+  assert(capacity() >= orig_capacity, \"unexpectedly lost capacity: %zu -> %zu\", orig_capacity, capacity());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"gc\/g1\/g1UncommitRegionTask.hpp\"\n@@ -569,0 +570,4 @@\n+  \/\/ Clear all free regions.\n+  \/\/ The aim is to have free regions committed but not be actually physically reserved on OS-level.\n+  void cleanup_unused_regions();\n+\n@@ -1318,0 +1323,4 @@\n+\n+  void after_restore(void) override {\n+    _hrm.after_restore();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -69,1 +69,3 @@\n-  _regions(), _heap_mapper(nullptr),\n+  _regions(),\n+  _max_available_regions(0),\n+  _heap_mapper(nullptr),\n@@ -88,0 +90,2 @@\n+  _max_available_regions = (uint) (CRaCMaxHeapSizeBeforeCheckpoint == 0 ? _regions.length() :\n+    CRaCMaxHeapSizeBeforeCheckpoint \/ G1HeapRegion::GrainBytes);\n@@ -92,0 +96,4 @@\n+void G1HeapRegionManager::after_restore() {\n+  _max_available_regions = (uint) _regions.length();\n+}\n+\n@@ -133,1 +141,3 @@\n-  expand_exact(candidate, num_regions, G1CollectedHeap::heap()->workers());\n+  if (!expand_exact(candidate, num_regions, G1CollectedHeap::heap()->workers())) {\n+    return nullptr;\n+  }\n@@ -164,0 +174,4 @@\n+  assert(_committed_map.num_active() + _committed_map.num_inactive() + num_regions <= _max_available_regions,\n+    \"Expanding over the limit: %d active, %d inactive, %d requested, limit %d\",\n+    _committed_map.num_active(), _committed_map.num_inactive(), num_regions, _max_available_regions);\n+\n@@ -342,2 +356,5 @@\n-    uint to_expand = MIN2(num_regions - expanded, regions.length());\n-    expand(regions.start(), to_expand, pretouch_workers);\n+    uint to_expand = MIN3(num_regions - expanded, regions.length(),\n+      _max_available_regions - _committed_map.num_active() - _committed_map.num_inactive());\n+    if (to_expand > 0) {\n+      expand(regions.start(), to_expand, pretouch_workers);\n+    }\n@@ -367,1 +384,1 @@\n-void G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n+bool G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -386,0 +403,6 @@\n+      \/\/ Fail if we're over the limits (were not able to just reactivate)\n+      if (_committed_map.num_active() + _committed_map.num_inactive() + (i - start) + 1 > _max_available_regions) {\n+        log_debug(gc)(\"Cannot expand to regions %u - %u: active %u, inactive %u, max %u\", start, end,\n+         _committed_map.num_active(),  _committed_map.num_inactive(), _max_available_regions);\n+        return false;\n+      }\n@@ -393,0 +416,1 @@\n+  return true;\n@@ -399,4 +423,12 @@\n-    for (uint i = 0; i < max_num_regions(); i++) {\n-      if (is_available(i)) {\n-        \/\/ Already in use continue\n-        continue;\n+    if (_committed_map.num_active() + _committed_map.num_inactive() >= _max_available_regions) {\n+      \/\/ We have to use existing inactive region, cannot allocate new one\n+      \/\/ while we have inactive.\n+      for (uint i = 0; i < max_num_regions(); i++) {\n+        if (!_committed_map.inactive(i)) {\n+          continue;\n+        }\n+        expand_candidate = i;\n+        if (is_on_preferred_index(expand_candidate, preferred_index)) {\n+          \/\/ We have found a candidate on the preferred node, break.\n+          break;\n+        }\n@@ -404,5 +436,13 @@\n-      \/\/ Always save the candidate so we can expand later on.\n-      expand_candidate = i;\n-      if (is_on_preferred_index(expand_candidate, preferred_index)) {\n-        \/\/ We have found a candidate on the preferred node, break.\n-        break;\n+    }\n+    if (expand_candidate == UINT_MAX) {\n+      for (uint i = 0; i < max_num_regions(); i++) {\n+        if (is_available(i)) {\n+          \/\/ Already in use continue\n+          continue;\n+        }\n+        \/\/ Always save the candidate so we can expand later on.\n+        expand_candidate = i;\n+        if (is_on_preferred_index(expand_candidate, preferred_index)) {\n+          \/\/ We have found a candidate on the preferred node, break.\n+          break;\n+        }\n@@ -415,0 +455,1 @@\n+    log_debug(gc)(\"No regions left\");\n@@ -417,0 +458,1 @@\n+  log_debug(gc)(\"Candidate is %u\", expand_candidate);\n@@ -418,2 +460,1 @@\n-  expand_exact(expand_candidate, 1, nullptr);\n-  return 1;\n+  return expand_exact(expand_candidate, 1, nullptr) ? 1 : 0;\n@@ -541,1 +582,3 @@\n-      expand_exact(curr_index, 1, pretouch_workers);\n+      if (!expand_exact(curr_index, 1, pretouch_workers)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+  uint _max_available_regions;\n@@ -147,1 +148,1 @@\n-  void expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers);\n+  bool expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers);\n@@ -234,1 +235,1 @@\n-  uint num_inactive_regions() const { return max_num_regions() - num_committed_regions(); }\n+  uint num_inactive_regions() const { return _max_available_regions - num_committed_regions(); }\n@@ -290,0 +291,2 @@\n+\n+  void after_restore(void);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -991,0 +992,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1141,0 +1149,7 @@\n+    if (heap->should_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -406,0 +407,6 @@\n+  if (Universe::heap()->should_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), (char*)eden()->end() - (char*)eden()->top());\n+    os::cleanup_memory((char*)from()->top(), (char*)from()->end() - (char*)from()->top());\n+    os::cleanup_memory((char*)to()->top(), (char*)to()->end() - (char*)to()->top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -281,0 +281,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,0 +122,2 @@\n+  bool _cleanup_unused;\n+\n@@ -375,0 +377,3 @@\n+  void set_cleanup_unused(bool value) { _cleanup_unused = value; }\n+  bool should_cleanup_unused() const { return _cleanup_unused; }\n+\n@@ -514,0 +519,2 @@\n+\n+  virtual void after_restore(void) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1054,0 +1054,4 @@\n+\n+  if (Universe::heap()->should_cleanup_unused()) {\n+    _page_allocator->uncommit_unused_memory();\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2444,0 +2444,8 @@\n+\n+void ZPageAllocator::uncommit_unused_memory() {\n+  ZPartitionIterator iter = partition_iterator();\n+  for (ZPartition* partition; iter.next(&partition);) {\n+    partition->_cache.reset_min_size_watermark();\n+    partition->_uncommitter.force_uncommit();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -284,0 +284,2 @@\n+  void uncommit_unused_memory();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,3 @@\n-    _uncommitted(0) {\n+    _uncommitted(0),\n+    _force_uncommit(false),\n+    _force_uncommit_lock() {\n@@ -64,1 +66,1 @@\n-  if (!_stop && timeout > 0) {\n+  if (!_stop && timeout > 0 && !_force_uncommit) {\n@@ -83,1 +85,0 @@\n-\n@@ -85,1 +86,1 @@\n-    } while (!_stop && now < wait_until);\n+    } while (!_stop && now < wait_until && !_force_uncommit);\n@@ -201,0 +202,4 @@\n+  if (uncommit_cycle_is_finished()) {\n+    finish_force_uncommit();\n+  }\n+\n@@ -426,0 +431,25 @@\n+\n+void ZUncommitter::force_uncommit() {\n+  {\n+    ZLocker<ZConditionLock> locker(&_lock);\n+    _force_uncommit = true;\n+    _lock.notify_all();\n+  }\n+\n+  wait_for_finish_force_uncommit();\n+}\n+\n+void ZUncommitter::wait_for_finish_force_uncommit() {\n+  ZLocker<ZConditionLock> locker(&_force_uncommit_lock);\n+  while (_force_uncommit) {\n+    _force_uncommit_lock.wait();\n+  }\n+}\n+\n+void ZUncommitter::finish_force_uncommit() {\n+  if (_force_uncommit) {\n+    ZLocker<ZConditionLock> locker(&_force_uncommit_lock);\n+    _force_uncommit = false;\n+    _force_uncommit_lock.notify_all();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zUncommitter.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  bool                   _force_uncommit;\n+  mutable ZConditionLock _force_uncommit_lock;\n@@ -68,0 +70,3 @@\n+  void wait_for_finish_force_uncommit();\n+  void finish_force_uncommit();\n+\n@@ -76,0 +81,2 @@\n+\n+  void force_uncommit();\n","filename":"src\/hotspot\/share\/gc\/z\/zUncommitter.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1174,0 +1174,15 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/jni\/jfrUpcalls.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"jfr\/periodic\/jfrOSInterface.hpp\"\n@@ -38,0 +40,2 @@\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -174,0 +178,26 @@\n+\n+void Jfr::before_checkpoint() {\n+  JfrOSInterface::before_checkpoint();\n+}\n+\n+void Jfr::after_restore() {\n+  const char *jfr_flag = \"StartFlightRecording\";\n+  JVMFlag *flag = JVMFlag::find_flag(jfr_flag);\n+  if (flag->get_origin() == JVMFlagOrigin::CRAC_RESTORE) {\n+    \/\/ -XX:StartFlightRecording passed on restore\n+    assert(JfrOptionSet::start_flight_recording_options() == nullptr, \"should have been released\");\n+    size_t buf_len = 4 + strlen(jfr_flag) + 1 + strlen(flag->get_ccstr()) + 1;\n+    ResourceMark rm;\n+    char *buf = NEW_RESOURCE_ARRAY(char, buf_len);\n+    snprintf(buf, buf_len, \"-XX:%s=%s\", jfr_flag, flag->get_ccstr());\n+    JavaVMOption option;\n+    option.optionString = buf;\n+    option.extraInfo = nullptr;\n+    const JavaVMOption *option_ptr = &option;\n+    JfrOptionSet::parse_start_flight_recording_option(&option_ptr, buf + 4 + strlen(jfr_flag));\n+    \/\/ We cannot invoke this directly now as DCmdStart command would be blocked\n+    \/\/ trying to register new file descriptors. Instead we just record a request and\n+    \/\/ the recording will be started at the right moment from JDKResource.\n+    JfrUpcalls::request_start_after_restore();\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+  static void before_checkpoint();\n+  static void after_restore();\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -440,0 +440,4 @@\n+JVM_ENTRY_NO_ENV(void, jfr_start_after_restore(JNIEnv* env, jclass jvm))\n+  return JfrRecorder::start_after_restore();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -172,0 +172,2 @@\n+void JNICALL jfr_start_after_restore(JNIEnv* env, jclass jvm);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+      (char*)\"startFlightRecorderAfterRestore\", (char*)\"()V\", (void*)jfr_start_after_restore,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+static Symbol* request_start_after_restore_sym = nullptr;\n+static Symbol* request_start_after_restore_sig_sym = nullptr;\n@@ -72,0 +74,3 @@\n+    request_start_after_restore_sym = SymbolTable::new_permanent_symbol(\"requestStartAfterRestore\");\n+    request_start_after_restore_sig_sym = SymbolTable::new_permanent_symbol(\"()V\");\n+    initialized = unhide_internal_types_sig_sym != nullptr;\n@@ -225,0 +230,26 @@\n+void JfrUpcalls::request_start_after_restore() {\n+  JavaThread * const THREAD = JavaThread::current();\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  if (!initialize(THREAD)) {\n+    log_error(jfr, system)(\"JfrUpcall could not be initialized.\");\n+    return;\n+  }\n+  JavaValue result(T_VOID);\n+  const Klass* klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    ResourceMark rm(THREAD);\n+    log_error(jfr, system)(\"JfrUpcall cannot resolve class %s, flight recording won't be started\",\n+      jvm_upcalls_class_sym->as_C_string());\n+    return;\n+  }\n+  assert(klass != nullptr, \"invariant\");\n+  JfrJavaArguments args(&result, klass, request_start_after_restore_sym, request_start_after_restore_sig_sym);\n+  JfrJavaSupport::call_static(&args, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    ResourceMark rm(THREAD);\n+    log_error(jfr, system)(\"JfrUpcall failed for %s\", request_start_after_restore_sym->as_C_string());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  static void request_start_after_restore();\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -480,0 +480,7 @@\n+\n+void JfrRecorder::start_after_restore() {\n+  JavaThread* const THREAD = JavaThread::current();\n+  validate_recording_options(THREAD);\n+  launch_command_line_recordings(THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"pending exception\");\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+\n+  static void start_after_restore();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  LOG_TAG(crac) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3703,0 +3704,5 @@\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2024, Azul Systems, Inc. All rights reserved.\n@@ -53,0 +54,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -78,0 +80,1 @@\n+#include <type_traits>\n@@ -93,0 +96,1 @@\n+char*  Arguments::_java_command_crac            = nullptr;\n@@ -567,0 +571,10 @@\n+  { \"CREngine\",                     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowedOpenFilePrefixes\",    JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowToSkipCheckpoint\",      JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRHeapDumpOnCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPrintResourcesOnCheckpoint\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTraceStartupTime\",           JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRDoThrowCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPauseOnCheckpointError\",     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTrace\",                      JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::undefined() },\n+\n@@ -578,0 +592,8 @@\n+  { \"CREngine\",                        \"CRaCEngine\" },\n+  { \"CRAllowedOpenFilePrefixes\",       \"CRaCAllowedOpenFilePrefixes\" },\n+  { \"CRAllowToSkipCheckpoint\",         \"CRaCAllowToSkipCheckpoint \"},\n+  { \"CRHeapDumpOnCheckpointException\", \"CRaCHeapDumpOnCheckpointException\" },\n+  { \"CRPrintResourcesOnCheckpoint\",    \"CRaCPrintResourcesOnCheckpoint\" },\n+  { \"CRTraceStartupTime\",              \"CRaCTraceStartupTime\" },\n+  { \"CRDoThrowCheckpointException\",    \"CRaCDoThrowCheckpointException\" },\n+  { \"CRPauseOnCheckpointError\",        \"CRaCPauseOnCheckpointError\" },\n@@ -1105,0 +1127,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == nullptr) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1114,4 +1149,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1119,6 +1151,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == nullptr) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1255,1 +1283,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != nullptr, \"key should not be null\");\n+  assert(value != nullptr, \"value should not be null\");\n@@ -1257,2 +1287,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1262,1 +1290,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1270,1 +1299,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1272,1 +1301,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1274,0 +1303,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = nullptr;\n+  const char* value = nullptr;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2135,0 +2171,83 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (!match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      continue;\n+    }\n+    \/\/ ccstr is never set to an empty string by the parser so we should not\n+    \/\/ treat an empty string value as the option being set. If it ever becomes\n+    \/\/ ccstrlist or the parser changes, the value check will need to be removed.\n+    static_assert(std::is_same<ccstr, decltype(CRaCRestoreFrom)>(), \"expected ccstr\");\n+    const char* eq = strchr(tail, '=');\n+    if (eq != nullptr && eq[1] != '\\0') {\n+      return true; \/\/ the value is not an empty string\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = nullptr;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = nullptr;\n+      const char* value = nullptr;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.crac_command\") == 0) {\n+        char *old_java_command = _java_command_crac;\n+        _java_command_crac = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != nullptr) {\n+          os::free(old_java_command);\n+        }\n+      } else {\n+        add_property(tail);\n+      }\n+\n+      if (key != tail) { \/\/ key was copied\n+        FreeHeap(const_cast<char *>(key));\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != nullptr) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n+          return false;\n+        }\n+        build_jvm_flags(tail);\n+      }\n+    }\n+  }\n+\n+  postcond(CRaCRestoreFrom != nullptr);\n+\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -2147,0 +2266,1 @@\n+        !match_option(option, \"-Dsun.java.crac_command\", &tail) &&\n@@ -2968,0 +3088,8 @@\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return JNI_ERR;\n+  }\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n@@ -4069,0 +4197,7 @@\n+\n+void Arguments::reset_for_crac_restore() {\n+  if (!FLAG_IS_DEFAULT(LogVMOutput)){\n+    FLAG_SET_DEFAULT(LogVMOutput, false);\n+    FLAG_SET_DEFAULT(LogFile, nullptr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":151,"deletions":16,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -201,0 +201,1 @@\n+  static char* _java_command_crac;\n@@ -292,0 +293,4 @@\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n+\n@@ -408,0 +413,1 @@\n+  static const char* java_command_crac()        { return _java_command_crac; }\n@@ -462,0 +468,2 @@\n+  \/\/ Reset LogVMoutput to default values\n+  static void reset_for_crac_restore();\n@@ -527,0 +535,4 @@\n+  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n-\/\/ only with product\/product_pd flags.\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, MANAGEABLE or RESTORE_SETTABLE. Currently\n+\/\/ extra_attrs can be used only with product\/product_pd flags.\n@@ -100,0 +100,3 @@\n+\/\/ RESTORE_SETTABLE are flags that can be set during restore from a snapshot.\n+\/\/    All MANAGEABLE flags are implicitly RESTORE_SETTABLE but\n+\/\/    RESTORE_SETTABLE are not MANAGEABLE.\n@@ -177,1 +180,2 @@\n-  product(bool, UnlockDiagnosticVMOptions, trueInDebug, DIAGNOSTIC,         \\\n+  product(bool, UnlockDiagnosticVMOptions, trueInDebug,                     \\\n+          DIAGNOSTIC | RESTORE_SETTABLE,                                    \\\n@@ -180,1 +184,2 @@\n-  product(bool, UnlockExperimentalVMOptions, false, EXPERIMENTAL,           \\\n+  product(bool, UnlockExperimentalVMOptions, false,                         \\\n+          EXPERIMENTAL | RESTORE_SETTABLE,                                  \\\n@@ -1028,1 +1033,1 @@\n-  product(bool, LogVMOutput, false, DIAGNOSTIC,                             \\\n+  product(bool, LogVMOutput, false, DIAGNOSTIC | RESTORE_SETTABLE,          \\\n@@ -1031,1 +1036,1 @@\n-  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                              \\\n+  product(ccstr, LogFile, nullptr, DIAGNOSTIC | RESTORE_SETTABLE,           \\\n@@ -1942,1 +1947,1 @@\n-  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                    \\\n+  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr, RESTORE_SETTABLE,  \\\n@@ -1956,0 +1961,65 @@\n+  product(ccstr, CRaCCheckpointTo, nullptr, RESTORE_SETTABLE,               \\\n+        \"Path to checkpoint image directory\")                               \\\n+                                                                            \\\n+  product(ccstr, CRaCRestoreFrom, nullptr, RESTORE_SETTABLE,                \\\n+      \"Path to image for restore, replaces the initializing VM on success\") \\\n+                                                                            \\\n+  product(uint, CRaCMinPid, 128,                                            \\\n+      \"Mininal PID value for checkpoint'ed process\")                        \\\n+      range(1, UINT_MAX)                                                    \\\n+                                                                            \\\n+  product(bool, CRaCResetStartTime, true, DIAGNOSTIC | RESTORE_SETTABLE,    \\\n+      \"Reset JVM's start time and uptime on restore\")                       \\\n+                                                                            \\\n+  product_pd(ccstr, CRaCEngine, RESTORE_SETTABLE,                           \\\n+      \"Path or name of a program or a shared library implementing \"         \\\n+      \"checkpoint and restore. On restore this option applies only to \"     \\\n+      \"the restoring VM, i.e. the restored VM keeps the value it had \"      \\\n+      \"before the checkpoint.\")                                             \\\n+                                                                            \\\n+  product(ccstrlist, CRaCEngineOptions, nullptr, RESTORE_SETTABLE,          \\\n+      \"Options passed to CRaCEngine, in the form of 'key1=value,key2'. \"    \\\n+      \"The list of supported options is engine-dependent, use \"             \\\n+      \"'-XX:CRaCEngineOptions=help' to make the VM print the information \"  \\\n+      \"about the engine, including its supported options, and exit. On \"    \\\n+      \"restore this option applies only to the restoring VM, i.e. the \"     \\\n+      \"restored VM keeps the value it had before the checkpoint.\")          \\\n+                                                                            \\\n+  product(bool, CRaCIgnoreRestoreIfUnavailable, false, RESTORE_SETTABLE,    \\\n+      \"Ignore -XX:CRaCRestoreFrom and continue initialization if restore \"  \\\n+      \"is unavailable\")                                                     \\\n+                                                                            \\\n+  product(ccstr, CRaCIgnoredFileDescriptors, nullptr, RESTORE_SETTABLE,     \\\n+      \"Comma-separated list of file descriptor numbers or paths. \"          \\\n+      \"All file descriptors greater than 2 (stdin, stdout and stderr are \"  \\\n+      \"excluded automatically) not in this list are closed when the VM \"    \\\n+      \"is started.\")                                                        \\\n+                                                                            \\\n+  product_pd(ccstrlist, CRaCAllowedOpenFilePrefixes, \"List of path \"        \\\n+      \"prefixes for files that can be open during checkpoint; CRaC won't \"  \\\n+      \"error upon detecting these and will leave the handling up to C\/R \"   \\\n+      \"engine. This option applies only to files opened by native code; \"   \\\n+      \"for files opened by Java code use -Djdk.crac.resource-policies=...\") \\\n+                                                                            \\\n+  product(bool, CRaCAllowToSkipCheckpoint, false, DIAGNOSTIC,               \\\n+      \"Allow implementation to not call Checkpoint if helper not found\")    \\\n+                                                                            \\\n+  product(bool, CRaCHeapDumpOnCheckpointException, false, DIAGNOSTIC,       \\\n+      \"Dump heap on CheckpointException thrown because of CRaC \"            \\\n+      \"precondition failed\")                                                \\\n+                                                                            \\\n+  product(bool, CRaCPrintResourcesOnCheckpoint, false, DIAGNOSTIC,          \\\n+      \"Print resources to decide CheckpointException\")                      \\\n+                                                                            \\\n+  product(bool, CRaCTraceStartupTime, false, DIAGNOSTIC,                    \\\n+      \"Trace startup time\")                                                 \\\n+                                                                            \\\n+  product(bool, CRaCDoThrowCheckpointException, true, EXPERIMENTAL,         \\\n+      \"Throw CheckpointException if uncheckpointable resource handle found\")\\\n+                                                                            \\\n+  product(bool, CRaCPauseOnCheckpointError, false, DIAGNOSTIC,              \\\n+      \"Pauses the checkpoint when a problem is found on VM level.\")         \\\n+                                                                            \\\n+  product(size_t, CRaCMaxHeapSizeBeforeCheckpoint, 0, \"Maximum size \"       \\\n+      \"of heap before checkpoint. By default equals to -Xmx.\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":77,"deletions":7,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1245,0 +1245,1 @@\n+  void wakeup_sleep() { _SleepEvent->unpark(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,0 +295,2 @@\n+  \/\/ Before restore returns the same value as elapsed_counter()\n+  static jlong elapsed_counter_since_restore();\n@@ -486,0 +488,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n@@ -607,0 +611,1 @@\n+  static void reset_cached_process_id();\n@@ -646,0 +651,2 @@\n+  static int execv(const char *path, const char *argv[]);\n+\n@@ -710,0 +717,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -713,0 +723,2 @@\n+  static bool           is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -428,0 +429,9 @@\n+static jint check_for_restore(JavaVMInitArgs* args) {\n+  if (Arguments::is_restore_option_set(args)) {\n+    if (!Arguments::parse_options_for_restore(args)) {\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -444,0 +454,8 @@\n+#ifdef __APPLE__\n+  \/\/ BSD clock would be initialized in os::init() but we need to do that earlier\n+  \/\/ as crac::prepare_restore() calls os::javaTimeNanos().\n+  os::Bsd::clock_init();\n+#endif\n+  crac::crac_restore_data restore_data;\n+  crac::prepare_restore(restore_data);\n+\n@@ -477,0 +495,2 @@\n+  if (check_for_restore(args) != JNI_OK) return JNI_ERR;\n+\n@@ -511,0 +531,2 @@\n+  crac::vm_create_start();\n+\n@@ -599,0 +621,11 @@\n+  \/\/ Output stream module should be already initialized for error reporting during restore.\n+  \/\/ JDK version should also be intialized. There is lot of initializations needed to read\n+  \/\/ the current machine's CPUFeatures.\n+  if (CRaCRestoreFrom) {\n+    crac::restore(restore_data);\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      log_error(crac)(\"Failed to restore %s\", CRaCRestoreFrom);\n+      return JNI_ERR;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+  template(VM_Crac)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1789,0 +1789,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+#if INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+#include \"posixAttachOperation.hpp\"\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n@@ -644,0 +647,7 @@\n+#if INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+      PosixAttachOperation* posix_op = static_cast<PosixAttachOperation*>(op);\n+      if (!posix_op->is_effectively_completed()) {\n+        st.complete();\n+        posix_op->set_effectively_completed(true);\n+      }\n+#else\n@@ -645,0 +655,1 @@\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+#if INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n@@ -157,0 +161,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -1054,0 +1060,26 @@\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_crac_mirror_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::checkpointRestoreInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != nullptr) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      outputStream* stream = output();\n+#if INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+      assert(PosixAttachListener::get_current_op(), \"should exist\");\n+      if (PosixAttachListener::get_current_op()->is_effectively_completed()) {\n+        stream = tty;\n+      }\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+      stream->print_cr(\"An exception during a checkpoint operation:\");\n+      stream->print(\"%s\", out);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -799,1 +799,1 @@\n-void defaultStream::finish_log() {\n+void defaultStream::finish_log(bool is_checkpoint) {\n@@ -803,0 +803,3 @@\n+  if (is_checkpoint) {\n+    CompileLog::finish_log_on_checkpoint(xs->out());\n+  } else {\n@@ -804,1 +807,2 @@\n-  CompileLog::finish_log(xs->out());  \/\/ write compile logging, if any, now\n+    CompileLog::finish_log(xs->out());  \/\/ write compile logging, if any, now\n+  }\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -303,0 +303,1 @@\n+  int get_fd() { return fileno(_file); }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFileResource;\n@@ -567,0 +574,65 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (fd == FileDescriptor.in) {\n+                Core.getClaimedFDs().claimFd(fd, FileInputStream.this, NO_EXCEPTION, fd);\n+            } else {\n+                \/\/ When the stream is opened with file descriptor we don't have any extra\n+                \/\/ information we could use for policy (this is most often a pipe, but could\n+                \/\/ be a socket as well). Such cases need to be handled on a higher level.\n+                super.beforeCheckpoint(context);\n+            }\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            try {\n+                offset = position();\n+            } catch (IOException e) {\n+                \/\/ We might get IOException from native code when lseeking a named pipe.\n+                offset = 0;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path);\n+                if (offset > 0) {\n+                    skip(offset);\n+                }\n+                FileInputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -29,0 +29,8 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -31,0 +39,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -98,0 +107,10 @@\n+    \/**\n+     * When the file is opened in non-append mode we need to check position\n+     * through the {@link #channel} when handling the file descriptor policy;\n+     * this needs to be independent of the regular resource as we need to\n+     * ensure initialization of the channel before FD priority class.\n+     * This field being <code>null<\/code> means that the file is opened in\n+     * append-only mode and does not need to track the position.\n+     *\/\n+    private final EnsureChannelResource channelResource;\n+\n@@ -209,0 +228,5 @@\n+        if (append) {\n+            channelResource = null;\n+        } else {\n+            channelResource = new EnsureChannelResource();\n+        }\n@@ -236,0 +260,2 @@\n+        \/\/ We don't have path information and won't reopen the file\n+        this.channelResource = null;\n@@ -245,1 +271,1 @@\n-    private native void open0(String name, boolean append)\n+    private native void open0(String name, boolean append, boolean truncate)\n@@ -255,1 +281,1 @@\n-        open0(name, append);\n+        open0(name, append, !append);\n@@ -465,0 +491,77 @@\n+\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            if (channelResource != null) {\n+                FileChannel channel = getChannel();\n+                channelResource.position = channel.isOpen() ? channel.position() : -1;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            assert path != null; \/\/ won't be reopened if it was not closed, and won't be closed without path\n+            synchronized (closeLock) {\n+                \/\/ We have been writing to a file, but it disappeared during checkpoint\n+                if (!Files.exists(Path.of(path))) {\n+                    throw new IOException(\"File \" + path + \" is not present during restore\");\n+                }\n+                if (channelResource == null) {\n+                    open(path, true);\n+                } else {\n+                    open0(path, false, false);\n+                    \/\/noinspection resource\n+                    getChannel().position(channelResource.position);\n+                }\n+                FileOutputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n+    private class EnsureChannelResource implements JDKResource {\n+        public long position;\n+\n+        EnsureChannelResource() {\n+            \/\/ This must be before PRE_FILE_DESCRIPTORS as getChannel()\n+            \/\/ could clinit FileDispatcherImpl\n+            Core.Priority.NORMAL.getContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            \/\/ the channel is not used but we ensure its existence\n+            getChannel();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":105,"deletions":2,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -32,0 +33,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -83,0 +85,1 @@\n+    private final int imode;\n@@ -102,0 +105,31 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ We cannot synchronize this without making every other method call synchronized\n+            offset = getFilePointer();\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path, imode);\n+                seek(offset);\n+                RandomAccessFile.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n@@ -257,0 +291,1 @@\n+        this.imode = imode;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -379,0 +379,5 @@\n+     * @crac When the process is restored on another machine or if the machine\n+     * rebooted the value is updated based on wall-clock time difference,\n+     * resulting in a loss of accuracy when comparing timestamps obtained\n+     * before and after checkpoint.\n+     *\n@@ -639,0 +644,6 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload system properties in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -673,0 +684,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -732,0 +744,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -753,0 +768,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -853,0 +871,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -860,0 +884,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -889,0 +914,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload the environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -894,0 +925,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.crac.Core;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -338,0 +342,10 @@\n+\n+            @Override\n+            public <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException {\n+                return queue.poll(timeout);\n+            }\n+\n+            @Override\n+            public void wakeupReferenceQueue(ReferenceQueue<?> queue) {\n+                queue.wakeup();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -172,0 +172,17 @@\n+    Reference<? extends T> poll(long timeout) throws InterruptedException {\n+        synchronized (lock) {\n+            Reference<? extends T> r = poll0();\n+            if (r != null) return r;\n+            \/\/ any wake (including spurious) ends the wait\n+            \/\/noinspection ResultOfMethodCallIgnored\n+            lock.wait(timeout);\n+            return poll0();\n+        }\n+    }\n+\n+    void wakeup() {\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -60,0 +62,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -235,0 +239,6 @@\n+ * @crac This class holds a cache of resolved hostname-address pairs;\n+ * this cache is wiped out before checkpoint. Therefore, lookups after restore\n+ * will cause name address resolution.\n+ * This ensures that the addresses are up-to-date in the environment where\n+ * the process is restored.\n+ *\n@@ -353,0 +363,3 @@\n+    \/* Resource registration uses weak references; we need to keep it locally. *\/\n+    private static final JDKResource checkpointListener;\n+\n@@ -390,0 +403,14 @@\n+        \/\/ DNS cache is cleared before the checkpoint; application restored at a later point\n+        \/\/ or in a different environment should query DNS again.\n+        checkpointListener = new JDKResource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                cache.clear();\n+                expirySet.clear();\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            }\n+        };\n+        Core.Priority.NORMAL.getContext().register(checkpointListener);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.SharedSecrets;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -50,0 +51,1 @@\n+import jdk.internal.crac.Core;\n@@ -796,0 +798,8 @@\n+\n+        public void beforeCheckpoint() {\n+            if (zsrc != null) {\n+                synchronized (zsrc) {\n+                    zsrc.beforeCheckpoint();\n+                }\n+            }\n+        }\n@@ -1095,0 +1105,4 @@\n+    private synchronized void beforeCheckpoint() {\n+        res.beforeCheckpoint();\n+    }\n+\n@@ -1138,2 +1152,5 @@\n-\n-             }\n+                @Override\n+                public void beforeCheckpoint(ZipFile zip) {\n+                    zip.beforeCheckpoint();\n+                }\n+            }\n@@ -2029,0 +2046,13 @@\n+\n+        public void beforeCheckpoint() {\n+            synchronized (zfile) {\n+                FileDescriptor fd = null;\n+                try {\n+                    fd = zfile.getFD();\n+                } catch (IOException e) {\n+                }\n+                if (fd != null) {\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+                }\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-\n@@ -178,0 +177,5 @@\n+    exports jdk.internal.crac to\n+        java.rmi,\n+        jdk.jfr,\n+        jdk.management.agent,\n+        jdk.sctp;\n@@ -413,0 +417,8 @@\n+    exports jdk.internal.crac.mirror to\n+        java.rmi,\n+        jdk.crac,\n+        jdk.jfr,\n+        jdk.management.agent;\n+\n+    exports jdk.internal.crac.mirror.impl to\n+        jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.WeakHashMap;\n@@ -41,0 +42,4 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+\n@@ -47,1 +52,1 @@\n-class JarFileFactory implements URLJarFile.URLJarFileCloseController {\n+class JarFileFactory implements URLJarFile.URLJarFileCloseController, jdk.internal.crac.JDKResource {\n@@ -57,1 +62,3 @@\n-    private JarFileFactory() { }\n+    private JarFileFactory() {\n+        Core.Priority.NORMAL.getContext().register(this);\n+    }\n@@ -233,0 +240,25 @@\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        \/\/ Need to clear cached entries that are held by the factory only (e.g.\n+        \/\/ after JarURLInputStream.close with useCaches == true).  Creating a\n+        \/\/ temporary weak cache and triggering GC to get know JARs really in\n+        \/\/ use.\n+        synchronized (instance) {\n+            WeakHashMap<JarFile, URL> weakMap = new WeakHashMap<>(urlCache);\n+            fileCache.clear();\n+            urlCache.clear();\n+\n+            System.gc();\n+\n+            weakMap.forEach((JarFile jarFile, URL url) -> {\n+                String key = urlKey(url);\n+                urlCache.put(jarFile, url);\n+                fileCache.put(key, jarFile);\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -53,0 +56,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -83,0 +87,34 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (!isOpen() || path == null) {\n+                return;\n+            } else if (parent != null) {\n+                \/\/ This FileChannel is managed by a higher level object that\n+                \/\/ will handle the provided file descriptor on its own.\n+                return;\n+            }\n+            super.beforeCheckpoint(context);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ implementation is possible but non-trivial\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -128,0 +129,8 @@\n+    \/\/ last backlog used for listen() invocation\n+    private int backlog;\n+\n+    static {\n+        \/\/ trigger eager initialization\n+        new FileDispatcherImpl();\n+    }\n+\n@@ -457,0 +466,27 @@\n+    public boolean isListening() {\n+        return server;\n+    }\n+\n+    public void reopenAfterRestore() throws IOException {\n+        if (!server) {\n+            throw new UnsupportedOperationException(\"Reopen not implemented for non-server sockets\");\n+        }\n+        synchronized (stateLock) {\n+            FileDescriptor fd;\n+            fd = Net.serverSocket();\n+            Runnable closer = closerFor(fd);\n+            IOUtil.setfdVal(NioSocketImpl.this.fd, IOUtil.fdVal(fd));\n+            NioSocketImpl.this.cleaner = CleanerFactory.cleaner().register(NioSocketImpl.this, closer);\n+            state = ST_UNCONNECTED;\n+\n+            if (localport != 0) {\n+                int port = localport;\n+                localport = 0;\n+                bind(address, port);\n+            }\n+            if (backlog > 0) {\n+                Net.listen(fd, backlog);\n+            }\n+        }\n+    }\n+\n@@ -656,1 +692,2 @@\n-            Net.listen(fd, backlog < 1 ? 50 : backlog);\n+            this.backlog = backlog < 1 ? 50 : backlog;\n+            Net.listen(fd, this.backlog);\n@@ -1198,1 +1235,1 @@\n-    private static Runnable closerFor(FileDescriptor fd) {\n+    private static Runnable closerFor0(FileDescriptor fd) {\n@@ -1208,0 +1245,14 @@\n+    private static Runnable closerFor(FileDescriptor fd) {\n+\n+        \/\/ FIXME ensure FileDispatcherImpl's Resource is registered before the closer is used,\n+        \/\/ otherwise the closer during beforeCheckpoint may be the first one to access\n+        \/\/ FileDescriptor, and then Dispatcher Resource will be blocked for registration.\n+        try {\n+            MethodHandles.lookup().ensureInitialized(FileDispatcherImpl.class);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        return closerFor0(fd);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":53,"deletions":2,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -86,0 +87,1 @@\n+    private final Resource resource = new Resource();\n@@ -1603,0 +1605,31 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(SocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1076,0 +1076,15 @@\n+`-XX:CRaCCheckpointTo=`*directory*\n+:   The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+    a running Java program into an image directory. Restoring from the image should\n+    solve some of the problematic start-up and warm-up times.\n+\n+    This option defines a path to the snapshot which is currently a directory. The\n+    directory will be created if it does not exist, but no parent directories are\n+    created.\n+\n+`-XX:CRaCRestoreFrom=`*directory*\n+:   Restores a snapshot created by `-XX:CRaCCheckpointTo=`*directory*.\n+\n+`-XX:CRaCMinPid=`*value*\n+:   A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+\n@@ -1830,0 +1845,6 @@\n+`-XX:CPUFeatures=`*0xnumber,0xnumber*\n+:   CPU feature set, use `-XX:CPUFeatures=`*0xnumber,0xnumber* with\n+    `-XX:CRaCCheckpointTo` when you get an error during `-XX:CRaCRestoreFrom`\n+    on a different machine. `-XX:CPUFeatures=native` is the default.\n+    `-XX:CPUFeatures=generic` is compatible with any CPU.\n+\n@@ -1834,0 +1855,5 @@\n+`-XX:+IgnoreCPUFeatures`\n+:   Skip any verifications of `-XX:CPUFeatures`. It may lead to a crash\n+    if `-XX:CRaCRestoreFrom` is used on a CPU with less features than the CPU\n+    where `-XX:CRaCCheckpointTo` was made.\n+\n@@ -1997,0 +2023,4 @@\n+`-XX:+ShowCPUFeatures`\n+:   Show features of this CPU to be possibly used for the\n+    `-XX:CPUFeatures=`*0xnumber* option.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.crac.JDKFdResource;\n@@ -621,0 +622,2 @@\n+        private final JDKFdResource resource;\n+\n@@ -622,1 +625,6 @@\n-            super(new PipeOutputStream(newFileDescriptor(fd)));\n+            this(newFileDescriptor(fd));\n+        }\n+\n+        private ProcessPipeOutputStream(FileDescriptor fd) {\n+            super(new PipeOutputStream(fd));\n+            resource = new PipeResource(this, fd);\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+#ifdef LINUX\n+#include <sys\/syscall.h>\n+#endif\n@@ -867,0 +870,3 @@\n+#ifdef LINUX\n+    return syscall(SYS_getpid);\n+#else\n@@ -868,0 +874,1 @@\n+#endif \/\/ !LINUX\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/xawt\/XToolkit.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-    private static final long CURRENT_PID = pid();\n-\n@@ -84,1 +82,1 @@\n-        selfAttach = pid == 0 || pid == CURRENT_PID;\n+        selfAttach = pid == 0 || pid == pid();\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotVirtualMachine.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -689,0 +689,5 @@\n+    \/**\n+     * Starts recording based on -XX:StartFlightRecorder passed on restore.\n+     *\/\n+    public static native void startFlightRecorderAfterRestore();\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+import jdk.internal.crac.Core;\n@@ -164,0 +166,7 @@\n+    \/**\n+     * Called by the JVM when it is restored with a new -XX:StartFlightRecorder\n+     *\/\n+    static void requestStartAfterRestore() {\n+        Core.setStartFlightRecorder(JVM::startFlightRecorderAfterRestore);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import static jdk.jfr.internal.LogLevel.ERROR;\n@@ -34,0 +35,1 @@\n+import java.io.File;\n@@ -35,0 +37,1 @@\n+import java.nio.file.Files;\n@@ -47,0 +50,1 @@\n+import java.util.stream.Collectors;\n@@ -48,0 +52,4 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -69,0 +77,88 @@\n+    private JDKResource resource = new JDKResource() {\n+        private List<PlatformRecording> futureRecordings;\n+        private static int MAX_BACKUPS = Integer.getInteger(\"jdk.jfr.max_backups\", 20);\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            synchronized (PlatformRecorder.this) {\n+                ArrayList<PlatformRecording> copy = new ArrayList<>(recordings);\n+                futureRecordings = copy.stream().map(r -> {\n+                    \/\/ PlatformRecording has to have a matching Recording - otherwise we could not control those\n+                    \/\/ through jcmd\n+                    Recording rec = new Recording(r.getSettings());\n+                    PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(rec);\n+                    if (r.getName().equals(String.valueOf(r.getId()))) {\n+                        \/\/ default name == id, use the new id as name as well\n+                        rec.setName(String.valueOf(rec.getId()));\n+                    } else {\n+                        \/\/ custom name, keep it\n+                        rec.setName(r.getName());\n+                    }\n+                    rec.setToDisk(r.isToDisk());\n+                    rec.setSettings(r.getSettings());\n+                    pr.setDumpDirectory(r.getDumpDirectory());\n+                    try {\n+                        pr.setDestination(r.getDestination());\n+                    } catch (IOException e) {\n+                        \/\/ never thrown\n+                        Logger.log(JFR, ERROR, \"Cannot copy destination: \" + e.getMessage());\n+                    }\n+                    rec.setMaxAge(r.getMaxAge());\n+                    rec.setMaxSize(r.getMaxSize());\n+                    pr.setInternalDuration(r.getDuration());\n+                    rec.setDumpOnExit(r.getDumpOnExit());\n+                    pr.setFlushInterval(r.getFlushInterval());\n+                    return pr;\n+                }).collect(Collectors.toList());\n+                recordings.removeAll(futureRecordings);\n+                copy.forEach(r -> r.stop(\"Checkpoint\"));\n+                assert recordings.isEmpty();\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            synchronized (PlatformRecorder.this) {\n+                futureRecordings.forEach(r -> {\n+                    recordings.add(r);\n+                    WriteablePath destination = r.getDestination();\n+                    \/\/ The backup recording has to be moved before creating WriteablePath\n+                    \/\/ (and touching the recording output file)\n+                    try {\n+                        File destFile = destination.getReal().toFile();\n+                        if (destFile.exists()) {\n+                            Path backup = null;\n+                            for (int i = 0; backup == null && i < MAX_BACKUPS; ++i) {\n+                                String name = destFile.getName();\n+                                \/\/ Mission Control has issues opening recording files\n+                                \/\/ that don't end with .jfr\n+                                if (name.endsWith(\".jfr\")) {\n+                                    name = name.substring(0, name.length() - 4) + \".\" + i + \".jfr\";\n+                                } else {\n+                                    name = name + \".\" + i;\n+                                }\n+                                backup = destination.getReal().getParent().resolve(name);\n+                                if (backup.toFile().exists()) {\n+                                    backup = null;\n+                                }\n+                            }\n+                            if (backup != null) {\n+                                Files.move(destFile.toPath(), backup);\n+                                Logger.log(JFR, INFO, \"Backed up \" + destFile + \" to \" + backup);\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        Logger.log(JFR, ERROR, \"Cannot backup previous recording: \" + e);\n+                    }\n+                    try {\n+                        \/\/ We need to invoke WriteablePath after restore to create the dump file.\n+                        \/\/ Since we're creating another WriteablePath we can use the original specification\n+                        r.setDestination(new WriteablePath(destination.getPath()));\n+                    } catch (IOException e) {\n+                        Logger.log(JFR, ERROR, \"Cannot reset recording destination: \" + e);\n+                    }\n+                    r.start();\n+                });\n+            }\n+        }\n+    };\n@@ -83,0 +179,2 @@\n+\n+        Core.Priority.JFR.getContext().register(resource);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -834,0 +834,4 @@\n+    Path getDumpDirectory() {\n+        return dumpDirectory;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,0 +86,25 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(remoteAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import java.util.stream.Collectors;\n+\n@@ -83,0 +85,34 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            synchronized (stateLock) {\n+                if (!isOpen() || !isBound()) {\n+                    return Collections.emptySet();\n+                }\n+                return associationMap.keySet().stream().flatMap(a -> {\n+                    try {\n+                        return SctpMultiChannelImpl.this.getRemoteAddresses(a).stream();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }).collect(Collectors.toSet());\n+            }\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -111,0 +111,3 @@\n+runtime\/ErrorHandling\/CreateCoredumpOnCrash.java 8267433 macosx-x64\n+# JDK-8310862 was closed but we're still seeing errors with the updated test\n+runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8310862 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -531,0 +531,6 @@\n+# jdk_crac\n+\n+jdk\/crac\/LinkedCleanableRefTest.java                            8353064 generic-all\n+\n+############################################################################\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}