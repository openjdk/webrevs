{"files":[{"patch":"@@ -1342,0 +1342,1 @@\n+        *env = &single_env;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libdt_socket\/socketTransport.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <stdbool.h>\n@@ -105,0 +106,2 @@\n+static void subscribe_crac_events(jvmtiEnv*);\n+\n@@ -331,0 +334,2 @@\n+    subscribe_crac_events(gdata->jvmti);\n+\n@@ -1348,0 +1353,48 @@\n+\n+static void JNICALL\n+cbBeforeCheckpoint(jvmtiEnv* jvmti_env, ...)\n+{\n+    gdata->checkpointInProgress = JNI_TRUE;\n+    transport_before_checkpoint();\n+    gdata->checkpointInProgress = JNI_FALSE;\n+}\n+\n+static void JNICALL\n+cbAfterRestore(jvmtiEnv* jvmti_env, ...)\n+{\n+    gdata->restoreInProgress = JNI_TRUE;\n+    debugInit_reset(getEnv());\n+    gdata->restoreInProgress = JNI_FALSE;\n+}\n+\n+static void\n+subscribe_crac_events(jvmtiEnv* jvmti)\n+{\n+    jint extensionEventCount = 0;\n+    jvmtiExtensionEventInfo* extensionEvents = NULL;\n+    jvmtiError err = (*jvmti)->GetExtensionEvents(jvmti, &extensionEventCount, &extensionEvents);\n+    if (JVMTI_ERROR_NONE != err) {\n+        TTY_MESSAGE((\"Failed enumerating JVMTI extension events: %s(%d)\", jvmtiErrorText(err), (int)err));\n+        return;\n+    }\n+\n+    bool beforeCheckpointFound = false;\n+    bool afterRestoreFound = false;\n+    for (jint i = 0; i < extensionEventCount && (!beforeCheckpointFound || !afterRestoreFound); ++i) {\n+        if (0 == strcmp(\"jdk.crac.events.BeforeCheckpoint\", extensionEvents[i].id)) {\n+            (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents[i].extension_event_index, &cbBeforeCheckpoint);\n+            beforeCheckpointFound = true;\n+        }\n+        else if (0 == strcmp(\"jdk.crac.events.AfterRestore\", extensionEvents[i].id)) {\n+            (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents[i].extension_event_index, &cbAfterRestore);\n+            afterRestoreFound = true;\n+        }\n+    }\n+    if (beforeCheckpointFound != afterRestoreFound) {\n+        ERROR_MESSAGE((\"Failed subscribing CRaC events: beforeCheckpoint %d, afterRestore %d\", beforeCheckpointFound, afterRestoreFound));\n+        forceExit(1);\n+    }\n+    if (!beforeCheckpointFound) {\n+        TTY_MESSAGE((\"CRaC JVMTI extension events not found\"));\n+    }\n+}\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -197,1 +197,3 @@\n-    if ( ! gdata->vmDead ) {\n+    if (gdata->checkpointInProgress) {\n+        \/\/ Do nothing - avoid restarting a transport\n+    } else if ( ! gdata->vmDead ) {\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugLoop.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+static const char* const jdwpListenerThreadName = \"JDWP Transport Listener: \";\n+static jdwpTransportEnv *listeningTransport = NULL;\n+\n@@ -240,0 +243,4 @@\n+        if (gdata->restoreInProgress && JNI_EEXIST == rc) {\n+            rc = JNI_OK;\n+        }\n+\n@@ -368,1 +375,4 @@\n-    if (rc != JDWPTRANSPORT_ERROR_NONE) {\n+    if (gdata->checkpointInProgress) {\n+        TTY_MESSAGE((\"Exiting accept thread because of checkpoint\"));\n+        (*t)->StopListening(t);\n+    } else if (rc != JDWPTRANSPORT_ERROR_NONE) {\n@@ -377,0 +387,1 @@\n+        listeningTransport = NULL;\n@@ -587,1 +598,1 @@\n-        (void)strcpy(threadName, \"JDWP Transport Listener: \");\n+        (void)strcpy(threadName, jdwpListenerThreadName);\n@@ -591,0 +602,1 @@\n+        listeningTransport = info->transport;\n@@ -645,1 +657,1 @@\n-         (void)strcpy(threadName, \"JDWP Transport Listener: \");\n+         (void)strcpy(threadName, jdwpListenerThreadName);\n@@ -728,0 +740,47 @@\n+\n+static void\n+joinListeningThread()\n+{\n+    JNIEnv* env = getEnv();\n+    jvmtiEnv* jvmti = gdata->jvmti;\n+    jint threadCount;\n+    jthread* threads;\n+    jthread thread = NULL;\n+    jvmtiError err = (*jvmti)->GetAllThreads(jvmti, &threadCount, &threads);\n+    if (err == JVMTI_ERROR_NONE) {\n+        for (int i = 0; !thread && i < threadCount; ++i) {\n+            jvmtiThreadInfo info;\n+            err = (*jvmti)->GetThreadInfo(jvmti, threads[i], &info);\n+            if (err != JVMTI_ERROR_NONE) {\n+                continue;\n+            }\n+            if (0 == strncmp(info.name, jdwpListenerThreadName, strlen(jdwpListenerThreadName))) {\n+                thread = (jthread)(*env)->NewGlobalRef(env, threads[i]);\n+            }\n+            (*jvmti)->Deallocate(jvmti, (unsigned char*)info.name);\n+        }\n+        (*jvmti)->Deallocate(jvmti, (unsigned char*)threads);\n+    }\n+    if (thread) {\n+        JNIEnv* env = getEnv();\n+        jclass cls = (*env)->GetObjectClass(env, thread);\n+        jmethodID methodId = (*env)->GetMethodID(env, cls, \"join\", \"()V\");\n+        if (methodId) {\n+            (*env)->CallVoidMethod(env, thread, methodId);\n+        }\n+        (*env)->DeleteGlobalRef(env, thread);\n+    }\n+}\n+\n+void\n+transport_before_checkpoint(void)\n+{\n+    jdwpTransportEnv *listenTrans = listeningTransport;\n+    if (listenTrans != NULL) {\n+        (*listenTrans)->StopListening(listenTrans);\n+    }\n+    transport_reset();\n+    joinListeningThread();\n+    transport = NULL;\n+    listeningTransport = NULL;\n+}\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/transport.c","additions":62,"deletions":3,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+void transport_before_checkpoint(void);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/transport.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -146,0 +146,3 @@\n+    jboolean checkpointInProgress;\n+    jboolean restoreInProgress;\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -156,0 +156,18 @@\n+#if defined(LINUX)\n+    \/\/ In case of multi-threading socket processing, a 'close' call may hang as long as other thread\n+    \/\/ still use a socket with 'select' or whatever. This is exactly the case I met on WSL Ubuntu 22.04.\n+    \/\/ This is why 'shutdown' call is needed here (as well for AIX and Windows) - it stops all the\n+    \/\/ communications via socket, so all system calls using this socket will exit with an error.\n+    \/\/\n+    \/\/ On the other hand, a socket may be set with SO_LINGER property controlling a socket behaviour on close.\n+    \/\/ This affects both 'close' and 'shutdown' calls, so, if SO_LINGER set, it doesn't make sense to call\n+    \/\/ 'shutdown'. So, here we make 'shutdown' call only of SO_LINGER isn't set.\n+    struct linger l;\n+    socklen_t len = sizeof(l);\n+\n+    if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&l, &len) == 0) {\n+        if (l.l_onoff == 0) {\n+            shutdown(fd, SHUT_RDWR);\n+        }\n+    }\n+#endif\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libdt_socket\/socket_md.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import com.sun.jdi.Bootstrap;\n+import com.sun.jdi.connect.AttachingConnector;\n+import com.sun.jdi.connect.Connector;\n+import com.sun.jdi.connect.IllegalConnectorArgumentsException;\n+import com.sun.jdi.VirtualMachine;\n+import com.sun.jdi.VMDisconnectedException;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test ContextOrderTest\n+ * @library \/test\/lib\n+ * @build JdwpTransportTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true true\n+ *\/\n+\n+public class JdwpTransportTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean suspendOnJdwpStart;\n+\n+    @CracTestArg(1)\n+    boolean keepDebuggingBeforeCheckpoint;\n+\n+    private static String ATTACH_CONNECTOR = \"com.sun.jdi.SocketAttach\";\n+    private static String ADDRESS = \"127.0.0.1\";\n+    private static String PORT = \"5555\";\n+    private static String DEBUGEE = \"Listening for transport dt_socket at address: 5555\";\n+    private static String STARTED = \"APP: Started\";\n+    private static String CHECKPOINT = \"CR: Checkpoint\";\n+\n+    private VirtualMachine attachDebugger() throws Exception {\n+        AttachingConnector ac = Bootstrap.virtualMachineManager().attachingConnectors()\n+                .stream().filter(c -> c.name().equals(ATTACH_CONNECTOR)).findFirst()\n+                .orElseThrow(() -> new RuntimeException(\"Unable to locate \" + ATTACH_CONNECTOR));\n+\n+        Map<String, Connector.Argument> args = ac.defaultArguments();\n+\n+        Connector.Argument argHost = args.get(\"hostname\");\n+        argHost.setValue(ADDRESS);\n+        Connector.Argument argPort = args.get(\"port\");\n+        argPort.setValue(PORT);\n+        System.out.println(\"TEST: Debugger is attaching to: \" + ADDRESS + \":\" + PORT + \" ...\");\n+\n+        VirtualMachine vm = ac.attach(args);\n+        System.out.println(\"TEST: Attached!\");\n+        System.out.println(\"TEST: Get all threads\");\n+        vm.allThreads().stream().forEach(System.out::println);\n+        return vm;\n+    }\n+\n+    private void waitForString(BufferedReader reader, String str) throws IOException {\n+        for (String line = reader.readLine(); true; line = reader.readLine()) {\n+            System.out.println(line);\n+            if (line.contains(str))\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        final String suspendArg = \",suspend=\" + (suspendOnJdwpStart ? \"y\" : \"n\");\n+        CracBuilder builder = new CracBuilder()\n+            .vmOption(\"-agentlib:jdwp=transport=dt_socket,server=y,address=0.0.0.0:\" + PORT + suspendArg);\n+        builder.engine(CracEngine.SIMULATE);\n+\n+        CracProcess process = builder.captureOutput(true).startCheckpoint();\n+        var errReader = new BufferedReader(new InputStreamReader(process.errOutput()));\n+        try {\n+            var reader = new BufferedReader(new InputStreamReader(process.output()));\n+            if (!suspendOnJdwpStart) {\n+                waitForString(reader, STARTED);\n+            } else {\n+                waitForString(reader, DEBUGEE);\n+                VirtualMachine vm = attachDebugger();\n+                if (keepDebuggingBeforeCheckpoint) {\n+                    vm.resume();\n+                    System.out.println(\"TEST: Debugger resume.\");\n+                    try {\n+                        waitForString(reader, CHECKPOINT);\n+                        vm.dispose();\n+                        fail(\"VMDisconnectedException isn't thrown. The debugger should be disconnected by a debuggee.\");\n+                    } catch (VMDisconnectedException e) {\n+                    }\n+                } else {\n+                    vm.dispose();\n+                    vm = null;\n+                    System.out.println(\"TEST: Debugger done.\");\n+\n+                    waitForString(reader, STARTED);\n+                }\n+            }\n+\n+            \/\/ After checkpoint\/restore\n+            waitForString(reader, DEBUGEE);\n+            VirtualMachine vm = attachDebugger();\n+            vm.dispose();\n+            System.out.println(\"TEST: Debugger done.\");\n+            System.out.flush();\n+            process.input().write(0); \/\/ Resume app\n+            process.input().flush();\n+\n+            process.waitForSuccess();\n+        } finally {\n+                for (String line = errReader.readLine(); null != line; line = errReader.readLine()) {\n+                    System.err.println(line);\n+                }\n+                process.destroyForcibly();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(STARTED);\n+        Core.checkpointRestore();\n+        System.out.println(\"APP: Restored\");\n+        System.in.read(); \/\/ Wait for debugger is attached and done\n+        System.out.println(\"APP: Finished\");\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/jdwp\/JdwpTransportTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -162,0 +162,4 @@\n+    public InputStream errOutput() {\n+        return process.getErrorStream();\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}