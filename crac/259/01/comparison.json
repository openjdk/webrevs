{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.test.lib.Utils;\n@@ -106,1 +107,6 @@\n-        proc.waitForSuccess();\n+        try {\n+            proc.waitForSuccess();\n+        } catch (InterruptedException ex) {\n+            out.reportDiagnosticSummary();\n+            throw ex;\n+        }\n@@ -115,1 +121,1 @@\n-        timedDoWhile(\"compilation\", () -> {\n+        waitForCondition(\"compilation (enqueue)\", () -> {\n@@ -120,6 +126,1 @@\n-            try {\n-                Thread.sleep(500); \/\/ Time to compile\n-            } catch (InterruptedException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-            return whiteBox.isMethodCompiled(testMethodRef);\n+            return whiteBox.isMethodCompiled(testMethodRef) || whiteBox.isMethodQueuedForCompilation(testMethodRef);\n@@ -127,0 +128,2 @@\n+        waitForCondition(\"compilation (dequeue)\", () -> !whiteBox.isMethodQueuedForCompilation(testMethodRef));\n+        assertTrue(whiteBox.isMethodCompiled(testMethodRef), \"Should be compiled\");\n@@ -131,2 +134,2 @@\n-                assertTrue(whiteBox.isMethodCompiled(testMethodRef), \"Should still be compiled\");\n-                timedDoWhile(\"deoptimization\", () -> {\n+                assertTrue(whiteBox.isMethodCompiled(testMethodRef), \"Should remain compiled\");\n+                waitForCondition(\"deoptimization\", () -> {\n@@ -143,1 +146,2 @@\n-                assertFalse(whiteBox.isMethodCompiled(testMethodRef), \"Should still be deoptimized\");\n+                assertFalse(whiteBox.isMethodQueuedForCompilation(testMethodRef), \"Should remain deoptimized\");\n+                assertFalse(whiteBox.isMethodCompiled(testMethodRef), \"Should remain deoptimized\");\n@@ -150,8 +154,1 @@\n-        timedDoWhile(\"recompilation\", () -> {\n-            try {\n-                Thread.sleep(1000); \/\/ Time to recompile\n-            } catch (InterruptedException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-            return whiteBox.isMethodCompiled(testMethodRef);\n-        });\n+        waitForCondition(\"recompilation\", () -> whiteBox.isMethodCompiled(testMethodRef));\n@@ -160,14 +157,14 @@\n-    private static void timedDoWhile(String name, BooleanSupplier action) {\n-        final var startTime = System.nanoTime();\n-        boolean completed;\n-        do {\n-            if (STAGE_TIME_LIMIT_SEC > 0) {\n-                assertLessThan(\n-                    (System.nanoTime() - startTime) \/ 1_000_000_000, STAGE_TIME_LIMIT_SEC,\n-                    \"Task takes too long: \" + name\n-                );\n-            }\n-            System.out.println(\"Running: \" + name);\n-            completed = action.getAsBoolean();\n-        } while (!completed);\n-        System.out.println(\"Completed: \" + name);\n+    private static void waitForCondition(String name, BooleanSupplier condition) {\n+        \/\/ Utils.waitForCondition() invokes its supplier argument one more time\n+        \/\/ after it returns true. For our conditions that is unacceptable.\n+        final var result = new Object() { boolean value = false; };\n+        Utils.waitForCondition(() -> {\n+                if (!result.value) {\n+                    System.out.println(\"Running: \" + name);\n+                    result.value = condition.getAsBoolean();\n+                }\n+                return result.value;\n+            },\n+            STAGE_TIME_LIMIT_SEC > 0 ? STAGE_TIME_LIMIT_SEC * 1000 : -1\n+        );\n+        assertTrue(result.value, \"Task takes too long: \" + name);\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/NaturalDecompilationTest.java","additions":30,"deletions":33,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.lang.reflect.Method;\n+\n@@ -28,0 +30,1 @@\n+import jdk.test.lib.Utils;\n@@ -37,0 +40,1 @@\n+ * @modules java.base\/java.lang:open\n@@ -69,1 +73,1 @@\n-        final var builder = new CracBuilder().engine(CracEngine.SIMULATE)\n+        new CracBuilder().engine(CracEngine.SIMULATE)\n@@ -71,0 +75,1 @@\n+            .vmOption(\"--add-opens=java.base\/jdk.internal.crac.mirror=ALL-UNNAMED\")\n@@ -122,1 +127,0 @@\n-\n@@ -126,3 +130,0 @@\n-\n-            \/\/ Wait for the delay to expire and give the concurrent compilations some time to finish\n-            Thread.sleep(delayMs + 500);\n@@ -132,0 +133,3 @@\n+            if (delayMs > 0) {\n+                waitUntilRecompiledIfRecorded(whiteBox, testMethodRef);\n+            }\n@@ -137,0 +141,3 @@\n+            if (delayMs > 0) {\n+                waitUntilRecompiledAllRecorded(whiteBox);\n+            }\n@@ -140,0 +147,44 @@\n+\n+    private static void waitForRecompilerThreadToFinish() throws InterruptedException  {\n+        \/\/ Can be done without reflection via ThreadGroup.enumerate(...) but would require more code\n+        final Thread recompilerThread;\n+        try {\n+            final var coreClass = Class.forName(\"jdk.internal.crac.mirror.Core\");\n+            final var recompilerThreadField = coreClass.getDeclaredField(\"recompilerThread\");\n+            recompilerThreadField.setAccessible(true);\n+            recompilerThread = (Thread) recompilerThreadField.get(null);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new IllegalStateException(\"Cannot read jdk.internal.crac.mirror.Core.recompilerThread\", ex);\n+        }\n+\n+        if (recompilerThread != null) {\n+            System.out.println(\"Waiting for recompiler thread\");\n+            recompilerThread.join();\n+        } else {\n+            System.out.println(\"Recompiler thread not set\");\n+        }\n+    }\n+\n+    \/**\n+     * Wait for the specified method to get recompiled if has been recorded.\n+     *\/\n+    private static void waitUntilRecompiledIfRecorded(WhiteBox whiteBox, Method m) throws InterruptedException {\n+        \/\/ Wait until recorded methods are put into the compilation queue\n+        waitForRecompilerThreadToFinish();\n+        \/\/ Wait until the method is out of the queue (if it was added there at all)\n+        System.out.println(\"Waiting for the method to get dequeued\");\n+        Utils.waitForCondition(() -> !whiteBox.isMethodQueuedForCompilation(m));\n+    }\n+\n+    \/**\n+     * Wait for all recorded methods to get recompiled.\n+     *\/\n+    private static void waitUntilRecompiledAllRecorded(WhiteBox whiteBox) throws InterruptedException {\n+        \/\/ Wait until recorded methods are put into the compilation queue\n+        waitForRecompilerThreadToFinish();\n+        \/\/ Wait until the compilation queue is empty. We may wait longer than\n+        \/\/ necessary because new methods may get queued along the way, but\n+        \/\/ eventually it should get empty.\n+        System.out.println(\"Waiting for all methods to get dequeued\");\n+        Utils.waitForCondition(() -> whiteBox.getCompileQueuesSize() == 0);\n+    }\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/RecompilationFlagsTest.java","additions":56,"deletions":5,"binary":false,"changes":61,"status":"modified"}]}