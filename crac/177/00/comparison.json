{"files":[{"patch":"@@ -76,1 +76,1 @@\n-    private final ByteBuffer memoryMap;\n+    private ByteBuffer memoryMap;\n@@ -80,4 +80,4 @@\n-    private final IntBuffer redirect;\n-    private final IntBuffer offsets;\n-    private final ByteBuffer locations;\n-    private final ByteBuffer strings;\n+    private IntBuffer redirect;\n+    private IntBuffer offsets;\n+    private ByteBuffer locations;\n+    private ByteBuffer strings;\n@@ -110,1 +110,1 @@\n-            registerIfCRaCPresent();\n+            registerIfCracPresent();\n@@ -115,1 +115,1 @@\n-            map = channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size());\n+            map = createMemoryMap(channel.size());\n@@ -141,1 +141,1 @@\n-            map = channel.map(FileChannel.MapMode.READ_ONLY, 0, indexSize);\n+            map = createMemoryMap(indexSize);\n@@ -150,0 +150,8 @@\n+\n+        initMappedBuffers();\n+\n+        stringsReader = new ImageStringsReader(this);\n+        decompressor = new Decompressor();\n+    }\n+\n+    protected void initMappedBuffers() {\n@@ -154,0 +162,1 @@\n+    }\n@@ -155,2 +164,2 @@\n-        stringsReader = new ImageStringsReader(this);\n-        decompressor = new Decompressor();\n+    protected ByteBuffer createMemoryMap(long size) throws IOException {\n+        return channel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n@@ -161,1 +170,8 @@\n-    private void registerIfCRaCPresent() {\n+    private void registerIfCracPresent() {\n+        Class<?> priorityClass = null;\n+        try {\n+            priorityClass = Class.forName(\"jdk.internal.crac.Core$Priority\");\n+        } catch (ClassNotFoundException e) {\n+            \/\/ there is no CRaC; suppress an exception\n+            return;\n+        }\n@@ -163,3 +179,0 @@\n-            Class<?> priorityClass = Class.forName(\"jdk.internal.crac.Core$Priority\");\n-            Class<?> jdkResourceClass = Class.forName(\"jdk.internal.crac.JDKResource\");\n-            Class<?> resourceClass = Class.forName(\"jdk.internal.crac.mirror.Resource\");\n@@ -179,21 +192,57 @@\n-            try {\n-                Method getContext = priorityClass.getMethod(\"getContext\");\n-                Object ctx = getContext.invoke(normalPriority);\n-                Method register = ctx.getClass().getMethod(\"register\", resourceClass);\n-                cracResource = Proxy.newProxyInstance(null, new Class<?>[] { jdkResourceClass }, new InvocationHandler() {\n-                    @Override\n-                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n-                        if (\"beforeCheckpoint\".equals(method.getName())) {\n-                            channel.close();\n-                        } else if (\"afterRestore\".equals(method.getName())) {\n-                            if (channel != null) {\n-                                channel = openFileChannel();\n-                            }\n-                        } else if (\"toString\".equals(method.getName())) {\n-                            return BasicImageReader.this.toString();\n-                        } else if (\"hashCode\".equals(method.getName())) {\n-                            return 0;\n-                        } else if (\"equals\".equals(method.getName())) {\n-                            return args[0] == cracResource;\n-                        } else {\n-                            throw new UnsupportedOperationException(method.toString());\n+            Class<?> resourceClass = Class.forName(\"jdk.internal.crac.mirror.Resource\");\n+            Method getContextMethod = priorityClass.getMethod(\"getContext\");\n+            Object ctx = getContextMethod.invoke(normalPriority);\n+            Class<?> ctxClass = ctx.getClass();\n+\n+            registerCracResource(resourceClass, ctxClass, ctx);\n+        } catch (IllegalAccessException e) {\n+            \/\/ try to register via public API\n+            registerIfPublicCracPresent();\n+        } catch (NoSuchMethodException | InvocationTargetException | ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private void registerIfPublicCracPresent() {\n+        Class<?> cracCoreClass = null;\n+        try {\n+            cracCoreClass = Class.forName(\"jdk.crac.Core\");\n+        } catch (ClassNotFoundException e) {\n+            \/\/ there is no public CRaC; suppress an exception\n+            return;\n+        }\n+        try {\n+            Class<?> resourceClass = Class.forName(\"jdk.crac.Resource\");\n+            Method getGlobalContextMethod = cracCoreClass.getMethod(\"getGlobalContext\");\n+            Object ctx = getGlobalContextMethod.invoke(null);\n+            Class<?> ctxClass = Class.forName(\"jdk.crac.Context\");\n+\n+            registerCracResource(resourceClass, ctxClass, ctx);\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        } catch (NoSuchMethodException | InvocationTargetException | ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private void registerCracResource(Class<?> resourceClass, Class<?> ctxClass, Object ctx)\n+            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        Method registerMethod = ctxClass.getMethod(\"register\", resourceClass);\n+        cracResource = Proxy.newProxyInstance(\n+            resourceClass.getClassLoader(),\n+            new Class<?>[] { resourceClass },\n+            new InvocationHandler() {\n+                @Override\n+                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                    if (\"beforeCheckpoint\".equals(method.getName())) {\n+                        channel.close();\n+                        redirect = null;\n+                        offsets = null;\n+                        locations = null;\n+                        strings = null;\n+                        memoryMap = null;\n+                    } else if (\"afterRestore\".equals(method.getName())) {\n+                        if (channel != null) {\n+                            channel = openFileChannel();\n+                            memoryMap = createMemoryMap(MAP_ALL ? channel.size() : indexSize).asReadOnlyBuffer();\n+                            initMappedBuffers();\n@@ -201,1 +250,8 @@\n-                        return null;\n+                    } else if (\"toString\".equals(method.getName())) {\n+                        return BasicImageReader.this.toString();\n+                    } else if (\"hashCode\".equals(method.getName())) {\n+                        return 0;\n+                    } else if (\"equals\".equals(method.getName())) {\n+                        return args[0] == cracResource;\n+                    } else {\n+                        throw new UnsupportedOperationException(method.toString());\n@@ -203,4 +259,2 @@\n-                });\n-                register.invoke(ctx, cracResource);\n-            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {\n-                throw new IllegalStateException(e);\n+                    return null;\n+                }\n@@ -208,3 +262,2 @@\n-        } catch (ClassNotFoundException e) {\n-            \/\/ ignored if class not present\n-        }\n+        );\n+        registerMethod.invoke(ctx, cracResource);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":96,"deletions":43,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2024, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.crac.Core;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import jdk.internal.jimage.BasicImageReader;\n+import jdk.internal.jimage.ImageLocation;\n+\n+\/**\n+ * @test\n+ * @summary Tests checkpoint\/restore for BasicImageReader with an open descriptor.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.jimage\n+ * @build BasicImageReaderTest\n+ * @run driver jdk.test.lib.crac.CracTest true true\n+ * @run driver jdk.test.lib.crac.CracTest true false\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ *\/\n+public class BasicImageReaderTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean useJvmMap;\n+\n+    @CracTestArg(1)\n+    boolean imageMapAll;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder().engine(CracEngine.SIMULATE).captureOutput(true)\n+            .vmOption(\"--add-opens=java.base\/jdk.internal.jimage=ALL-UNNAMED\")\n+            .startCheckpoint();\n+        cp.outputAnalyzer()\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.setProperty(\"jdk.image.use.jvm.map\", String.valueOf(useJvmMap));\n+        System.setProperty(\"jdk.image.map.all\", String.valueOf(imageMapAll));\n+\n+        Path imageFile = Paths.get(System.getProperty(\"java.home\"), \"lib\", \"modules\");\n+        BasicImageReader reader = BasicImageReader.open(imageFile);\n+\n+        readClass(reader, \"java.base\", \"java\/lang\/String.class\");\n+        readClass(reader, \"java.logging\", \"java\/util\/logging\/Logger.class\");\n+\n+        Core.checkpointRestore();\n+        System.out.println(\"RESTORED\");\n+\n+        readClass(reader, \"java.base\", \"java\/lang\/String.class\");\n+        readClass(reader, \"java.logging\", \"java\/util\/logging\/Logger.class\");\n+    }\n+\n+    private void readClass(BasicImageReader reader, String moduleName, String className) throws Exception {\n+        final int classMagic = 0xCAFEBABE;\n+\n+        System.out.printf(\"reading: module: %s, path: %s%n\", moduleName, className);\n+        ImageLocation location = reader.findLocation(moduleName, className);\n+        assertTrue(location != null);\n+\n+        long size = location.getUncompressedSize();\n+        assertTrue(size > 0);\n+\n+        ByteBuffer buffer = reader.getResourceBuffer(location);\n+        assertTrue(buffer != null);\n+\n+        final int magic = buffer.getInt();\n+        assertTrue(magic == classMagic);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/BasicImageReaderTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+import jdk.crac.Core;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+\/**\n+ * @test\n+ * @summary Tests creating JRT FS and checkpoint'ing with an open file descriptor.\n+ * @library \/test\/lib\n+ * @build JrtFsTest\n+ * @run driver jdk.test.lib.crac.CracTest true true\n+ * @run driver jdk.test.lib.crac.CracTest true false\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ *\/\n+public class JrtFsTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean useJvmMap;\n+\n+    @CracTestArg(1)\n+    boolean imageMapAll;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder().engine(CracEngine.SIMULATE).captureOutput(true)\n+            .startCheckpoint();\n+        cp.outputAnalyzer()\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.setProperty(\"jdk.image.use.jvm.map\", String.valueOf(useJvmMap));\n+        System.setProperty(\"jdk.image.map.all\", String.valueOf(imageMapAll));\n+        Map<String, String> env = new HashMap<>();\n+        env.put(\"java.home\", System.getProperty(\"java.home\"));\n+        FileSystem fs = FileSystems.newFileSystem(URI.create(\"jrt:\/\"), env);\n+\n+        byte[] classBytes1;\n+        {\n+            Path objectClassPath = fs.getPath(\"\/modules\/java.base\", \"java\/lang\/Object.class\");\n+            classBytes1 = Files.readAllBytes(objectClassPath);\n+            System.out.println(\"Read \" + classBytes1.length + \" bytes from Object.class\");\n+        }\n+\n+        Core.checkpointRestore();\n+        System.out.println(\"RESTORED\");\n+\n+        byte[] classBytes2;\n+        {\n+            Path objectClassPath = fs.getPath(\"\/modules\/java.base\", \"java\/lang\/Object.class\");\n+            classBytes2 = Files.readAllBytes(objectClassPath);\n+            System.out.println(\"Read \" + classBytes2.length + \" bytes from Object.class\");\n+        }\n+        assertTrue(Arrays.equals(classBytes1, classBytes2));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/JrtFsTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}