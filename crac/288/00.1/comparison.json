{"files":[{"patch":"@@ -59,3 +59,3 @@\n-          - s390x\n-          - ppc64le\n-          - riscv64\n+          # - s390x\n+          # - ppc64le\n+          # - riscv64\n@@ -76,18 +76,18 @@\n-          - target-cpu: s390x\n-            gnu-arch: s390x\n-            debian-arch: s390x\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: trixie\n-            tolerate-sysroot-errors: false\n-          - target-cpu: ppc64le\n-            gnu-arch: powerpc64le\n-            debian-arch: ppc64el\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: trixie\n-            tolerate-sysroot-errors: false\n-          - target-cpu: riscv64\n-            gnu-arch: riscv64\n-            debian-arch: riscv64\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: trixie\n-            tolerate-sysroot-errors: false\n+#          - target-cpu: s390x\n+#            gnu-arch: s390x\n+#            debian-arch: s390x\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: trixie\n+#            tolerate-sysroot-errors: false\n+#          - target-cpu: ppc64le\n+#            gnu-arch: powerpc64le\n+#            debian-arch: ppc64el\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: trixie\n+#            tolerate-sysroot-errors: false\n+#          - target-cpu: riscv64\n+#            gnu-arch: riscv64\n+#            debian-arch: riscv64\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: trixie\n+#            tolerate-sysroot-errors: false\n","filename":".github\/workflows\/build-cross-compile.yml","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+          - 'jdk\/crac'\n+          - 'jdk\/since checks'\n@@ -85,0 +87,6 @@\n+          - test-name: 'jdk\/crac'\n+            test-suite: 'test\/jdk\/jdk\/crac\/'\n+\n+          - test-name: 'jdk\/since checks'\n+            test-suite: 'test\/jdk\/:jdk_since_checks'\n+\n@@ -186,1 +194,1 @@\n-            echo \"test-jdk=JDK_UNDER_TEST=${{ steps.bundles.outputs.static-jdk-path }}\" >> $GITHUB_OUTPUT\n+            echo \"test-jdk=${{ steps.bundles.outputs.static-jdk-path }}\" >> $GITHUB_OUTPUT\n@@ -189,0 +197,2 @@\n+          else\n+            echo \"test-jdk=${{ steps.bundles.outputs.jdk-path }}\" >> $GITHUB_OUTPUT\n@@ -191,0 +201,6 @@\n+      - name: 'Setup CRIU'\n+        uses: .\/.github\/actions\/setup-criu\n+        with:\n+          jdk-path: ${{ steps.extra-options.outputs.test-jdk }}\n+        if: runner.os == 'Linux' && matrix.test-name == 'jdk\/crac'\n+\n@@ -201,1 +217,1 @@\n-          ${{ steps.extra-options.outputs.test-jdk }}\n+          JDK_UNDER_TEST=${{ steps.extra-options.outputs.test-jdk }}\n@@ -203,1 +219,1 @@\n-          JTREG='JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash;VERBOSE=fail,error,time;KEYWORDS=!headful;${{ steps.extra-options.outputs.extra-problem-lists }}'\n+          JTREG=\"JAVA_OPTIONS=$JAVA_OPTIONS;VERBOSE=fail,error,time;KEYWORDS=!headful;${{ steps.extra-options.outputs.extra-problem-lists }}\"\n@@ -207,0 +223,3 @@\n+          JAVA_OPTIONS: >-\n+            -XX:-CreateCoredumpOnCrash\n+            ${{ matrix.test-name == 'jdk\/crac' && '-Djdk.test.docker.retain.image=true -Djdk.test.crac.reuse.image=true' || '' }}\n","filename":".github\/workflows\/test.yml","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=crac\n@@ -7,2 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists,copyright\n-warning=issuestitle,binary\n+error=whitespace\n@@ -10,3 +9,3 @@\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=.*\n+[checks \"reviewers\"]\n+committers=1\n+ignore=duke\n@@ -17,25 +16,0 @@\n-\n-[checks \"whitespace\"]\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.S|.*\\.md|.*\\.properties|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n-ignore-tabs=.*\\.gmk|Makefile\n-\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n-[checks \"committer\"]\n-role=committer\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n-\n-[checks \"copyright\"]\n-files=^(?!LICENSE|license\\.txt|.*\\.bin|.*\\.gif|.*\\.jpg|.*\\.png|.*\\.icon|.*\\.tiff|.*\\.dat|.*\\.patch|.*\\.wav|.*\\.class|.*-header|.*\\.jar).*\n-oracle_locator=.*Copyright \\(c\\)(.*)Oracle and\/or its affiliates\\. All rights reserved\\.\n-oracle_validator=.*Copyright \\(c\\) (\\d{4})(?:, (\\d{4}))?, Oracle and\/or its affiliates\\. All rights reserved\\.\n","filename":".jcheck\/conf","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,1 +1,24 @@\n-# Welcome to the JDK!\n+# CRaC JDK\n+\n+## Build\n+\n+CRaC JDK have extended build procedure.\n+\n+1. Build JDK as usual\n+```\n+bash configure\n+make images\n+mv build\/linux-x86_64-server-release\/images\/jdk\/ .\n+```\n+2. Download a build of [modified CRIU](https:\/\/github.com\/CRaC\/criu\/releases\/tag\/release-1.4)\n+3. Extract and copy `criu` binary over a same named file in the JDK\n+```\n+cp criu-dist\/sbin\/criu jdk\/lib\/criu\n+```\n+Grant permissions to allow regular user to run it\n+```\n+sudo chown root:root jdk\/lib\/criu\n+sudo chmod u+s jdk\/lib\/criu\n+```\n+\n+# JDK\n","filename":"README.md","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    -tag crac:cmopt:'CRaC:' \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -686,0 +686,3 @@\n+  # setup arch name (the same as 'os.arch' system property)\n+  $1_DEFINES_CPU_JVM=\"${$1_DEFINES_CPU_JVM} -DARCHPROPNAME='\\\"$OPENJDK_TARGET_CPU_OSARCH\\\"'\"\n+\n","filename":"make\/autoconf\/flags-cflags.m4","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    cpu_feature_active \\\n@@ -367,0 +368,22 @@\n+################################################################################\n+# Check if glibc CPU_FEATURE_ACTIVE is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(cpu_feature_active, [\n+    AC_MSG_CHECKING([if glibc CPU_FEATURE_ACTIVE is supported])\n+    AC_COMPILE_IFELSE(\n+      [AC_LANG_PROGRAM([[#include <sys\/platform\/x86.h>]],\n+        [[int x = CPU_FEATURE_ACTIVE(SSE2);]])\n+      ],\n+      [\n+        AC_MSG_RESULT([yes])\n+      ],\n+      [\n+        AC_MSG_RESULT([no])\n+        AVAILABLE=false\n+      ]\n+    )\n+  ])\n+])\n+\n@@ -382,0 +405,1 @@\n+  JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE\n","filename":"make\/autoconf\/jvm-features.m4","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  LIB_SETUP_CRIU_CRAC\n@@ -360,0 +361,21 @@\n+\n+################################################################################\n+# Setup CRaC CRIU\n+################################################################################\n+AC_DEFUN_ONCE([LIB_SETUP_CRIU_CRAC],\n+[\n+  AC_ARG_WITH(criu-crac, [AS_HELP_STRING([--with-criu-crac],\n+      [use specified criu binary for CRaC implementation])])\n+\n+  AC_MSG_CHECKING([for criu-crac])\n+\n+  USE_CRIU_CRAC=\n+  if test -f \"${with_criu_crac}\"; then\n+    USE_CRIU_CRAC=\"${with_criu_crac}\"\n+    AC_MSG_RESULT([exists])\n+  else\n+    AC_MSG_RESULT([none])\n+  fi\n+\n+  AC_SUBST(USE_CRIU_CRAC)\n+])\n","filename":"make\/autoconf\/lib-bundled.m4","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -842,0 +842,2 @@\n+USE_CRIU_CRAC:=@USE_CRIU_CRAC@\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+    jdk.crac \\\n","filename":"make\/conf\/docs-modules.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+LINUX_X64_CRIU_FILENAME=criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_URL=https:\/\/github.com\/CRaC\/criu\/releases\/download\/release-1.3\/criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_SHA256=82a014bf342c957305b98a71867c0994ebf6e7379f01f083121884793768d966\n+\n","filename":"make\/conf\/github-actions.conf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    jdk.crac \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -161,0 +161,4 @@\n+ifneq ($(call check-jvm-feature, cpu_feature_active), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_CPU_FEATURE_ACTIVE=0\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,0 +107,57 @@\n+\n+ifeq ($(OPENJDK_TARGET_OS), linux)\n+  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n+      NAME := pauseengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/linux\/native\/pauseengine, \\\n+      INCLUDE_FILES := pauseengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_PAUSEENGINE)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_CRIUENGINE, \\\n+      NAME := criuengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/linux\/native\/criuengine, \\\n+      INCLUDE_FILES := criuengine.c, \\\n+      OPTIMIZATION := HIGH, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_CRIUENGINE)\n+\n+endif\n+\n+ifeq ($(call isTargetOs, macosx linux windows), true)\n+  ifeq ($(OPENJDK_TARGET_OS), windows)\n+    CRAC_ENGINE_DIR = modules_cmds\n+  else\n+    CRAC_ENGINE_DIR = modules_libs\n+  endif\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_SIMENGINE, \\\n+      NAME := simengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/simengine, \\\n+      INCLUDE_FILES := simengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_SIMENGINE)\n+\n+  ifneq ($(USE_CRIU_CRAC),)\n+\n+    CRIU_CRAC_BIN := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE)\/criu\n+    TARGETS += $(CRIU_CRAC_BIN)\n+\n+$(CRIU_CRAC_BIN) : $(USE_CRIU_CRAC)\n+\t$(call MakeTargetDir)\n+\t$(CP) $(USE_CRIU_CRAC) $(CRIU_CRAC_BIN)\n+\n+  endif\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -208,0 +208,14 @@\n+# Build checkpoint\/restore exec library\n+################################################################################\n+\n+# CFLAGS_windows from make\/autoconf\/flags-cflags.m4#FLAGS_SETUP_CFLAGS_HELPER\n+$(eval $(call SetupJdkLibrary, BUILD_LIBCREXEC, \\\n+    NAME := crexec, \\\n+    LINK_TYPE := C++, \\\n+    EXTRA_HEADER_DIRS := libjvm, \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB) -DCRLIB_IS_IMPL, \\\n+    CXXFLAGS_windows := -D_WINDOWS -DWIN32, \\\n+    CXXFLAGS_macosx := -DMACOSX, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB), \\\n+))\n+TARGETS += $(BUILD_LIBCREXEC)\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -644,0 +644,2 @@\n+  check_cpufeatures_vmoptions();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+  struct VM_Features: public Zero_Features {};\n+  static bool cpu_features_binary(VM_Features *data) { return false; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -353,0 +353,2 @@\n+  check_cpufeatures_vmoptions();\n+\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -347,0 +347,2 @@\n+\n+  check_cpufeatures_vmoptions();\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+  struct VM_Features: public Zero_Features {};\n+  static bool cpu_features_binary(VM_Features *data) { return false; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+\n+  check_cpufeatures_vmoptions();\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -503,0 +503,3 @@\n+  struct VM_Features: public Zero_Features {};\n+  static bool cpu_features_binary(VM_Features *data) { return false; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -334,0 +334,2 @@\n+\n+  check_cpufeatures_vmoptions();\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -419,0 +419,3 @@\n+  struct VM_Features: public Zero_Features {};\n+  static bool cpu_features_binary(VM_Features *data) { return false; }\n+  static bool ignore_cpu_features() { return true; }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -44,0 +45,7 @@\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# if defined(__clang__) && defined(__STRICT_ANSI__)\n+\/\/ clang <stdbool.h> is missing this definition compared to gcc\n+#  define _Bool bool\n+# endif\n+# include <sys\/platform\/x86.h>\n+#endif\n@@ -50,0 +58,1 @@\n+VM_Version::VM_Features VM_Version::_features_saved;\n@@ -93,2 +102,34 @@\n-  assert ((!Universe::is_fully_initialized() || _features.supports_feature(CPU_FLUSH)), \"clflush should be available\");\n-  return true;\n+  if (!Universe::is_fully_initialized()) {\n+    return true;\n+  }\n+  if (_features.supports_feature(CPU_FLUSH)) {\n+    return true;\n+  }\n+  if (FLAG_IS_DEFAULT(CPUFeatures)) {\n+    vm_exit_during_initialization(\"clflush should be available\");\n+  }\n+  stringStream ss;\n+  ss.print_raw(\"-XX:CPUFeatures option requires FLUSH flag to be set: \");\n+  {\n+    VM_Features flush;\n+    flush.set_feature(CPU_FLUSH);\n+    flush.print_numbers(ss);\n+  }\n+  vm_exit_during_initialization(ss.base());\n+  return false;\n+}\n+\n+void VM_Version::VM_Features::print_numbers(outputStream &os, bool hexonly) const {\n+  apply_to_all_features([&](uint64_t u, int idx) {\n+    os.print(hexonly ? UINT64_FORMAT_0 : UINT64_FORMAT_X, u);\n+    if (!hexonly && idx + 1 < features_bitmap_element_count()) {\n+      os.print_raw(\",\");\n+    }\n+  });\n+}\n+\n+const char *VM_Version::VM_Features::print_numbers() const {\n+  char *buf = NEW_RESOURCE_ARRAY(char, MAX_CPU_FEATURES);\n+  stringStream ss(buf, MAX_CPU_FEATURES);\n+  print_numbers(ss);\n+  return buf;\n@@ -144,1 +185,1 @@\n-    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4, std_cpuid24, std_cpuid29;\n+    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4, std_cpuid24, std_cpuid29, check_cpuidb;\n@@ -217,0 +258,13 @@\n+    __ cmpl(rax, 0xc);                  \/\/ Is cpuid(0xD) supported?\n+    __ jccb(Assembler::belowEqual, check_cpuidb);\n+    __ push(rax);\n+\n+    __ movl(rax, 0xd);\n+    __ movl(rcx, 1);     \/\/ Packages level\n+    __ cpuid();\n+\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::xfs_cpuidD1_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+\n+    __ pop(rax);\n+    __ bind(check_cpuidb);\n@@ -861,1 +915,67 @@\n-void VM_Version::get_processor_features() {\n+VM_Version::VM_Features VM_Version::CPUFeatures_parse(const char *str) {\n+#ifndef LINUX\n+  _ignore_glibc_not_using = true;\n+#endif \/\/ !LINUX\n+  if (str == nullptr || strcmp(str, \"native\") == 0) {\n+    return _features;\n+  }\n+  if (strcmp(str, \"ignore\") == 0) {\n+    _ignore_glibc_not_using = true;\n+    return _features;\n+  }\n+  if (strcmp(str, \"generic\") == 0) {\n+#ifndef LINUX\n+    return _features;\n+#else\n+    \/\/ 32-bit x86 cannot rely on anything.\n+    VM_Version::VM_Features retval;\n+#ifdef AMD64\n+      \/\/ The following options are all in \/proc\/cpuinfo of one of the first 64-bit CPUs - Atom D2700 (and Opteron 1352): https:\/\/superuser.com\/q\/1572306\/1015048\n+    retval.set_feature(CPU_SSE); \/\/ enabled in 'gcc -Q --help=target', used by OpenJDK\n+    retval.set_feature(CPU_SSE2); \/\/ enabled in 'gcc -Q --help=target', required by OpenJDK\n+    retval.set_feature(CPU_FXSR); \/\/ enabled in 'gcc -Q --help=target', not used by OpenJDK\n+    retval.set_feature(CPU_MMX); \/\/ enabled in 'gcc -Q --help=target', used only by 32-bit x86 OpenJDK\n+    retval.set_feature(CPU_TSC); \/\/ not used by gcc, used by OpenJDK\n+    retval.set_feature(CPU_CX8); \/\/ gcc detects it to set cpu \"pentium\" (=32-bit only), used by OpenJDK\n+    retval.set_feature(CPU_CMOV); \/\/ gcc detects it to set cpu \"pentiumpro\" (=32-bit only), used by OpenJDK\n+    retval.set_feature(CPU_FLUSH); \/\/ =\"clflush\" in cpuinfo, not used by gcc, required by OpenJDK\n+    \/\/ CPU_MOVBE is disabled in 'gcc -Q --help=target' and for example i7-720QM does not support it\n+    \/\/ CPU_LAHFSAHF is disabled in 'gcc -Q --help=target' and \"Early Intel Pentium 4 CPUs with Intel 64 support ... lacked the LAHF and SAHF instructions\"\n+#endif \/\/ AMD64\n+    return retval;\n+#endif \/\/ LINUX\n+  }\n+#ifndef LINUX\n+  vm_exit_during_initialization(\"This OS does not support any arch-specific -XX:CPUFeatures options\");\n+  return {};\n+#else \/\/ LINUX\n+  int count = VM_Version::VM_Features::features_bitmap_element_count();\n+  VM_Version::VM_Features retval;\n+  const char *str_orig = str;\n+  for (int idx = 0;; ++idx) {\n+    static_assert(sizeof(uint64_t) == sizeof(unsigned long long), \"unexpected arch\");\n+    char *endptr;\n+    errno = 0;\n+    uint64_t u64 = strtoull(str, &endptr, 0);\n+    if (errno != 0) {\n+      break;\n+    }\n+    bool last = idx + 1 == count;\n+    if (*endptr != (last ? 0 : ',')) {\n+      break;\n+    }\n+    retval.set_feature_idx(idx, u64);\n+    if (last) {\n+      return retval;\n+    }\n+    str = endptr + 1;\n+  }\n+  char buf[MAX_CPU_FEATURES];\n+  char *s = buf;\n+  for (int idx = 0; idx < count; ++idx) {\n+    s = stpcpy(s, \",0xNUM\");\n+  }\n+  vm_exit_during_initialization(err_msg(\"VM option 'CPUFeatures=%s' must be of the form: %s\", str_orig, buf + 1));\n+  return {};\n+#endif \/\/ LINUX\n+}\n@@ -863,0 +983,367 @@\n+bool VM_Version::_ignore_glibc_not_using = false;\n+#ifdef LINUX\n+const char VM_Version::glibc_prefix[] = \":glibc.cpu.hwcaps=\";\n+const size_t VM_Version::glibc_prefix_len = strlen(glibc_prefix);\n+\n+bool VM_Version::glibc_env_set(char *disable_str) {\n+#define TUNABLES_NAME \"GLIBC_TUNABLES\"\n+#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n+  char *env_val = disable_str;\n+  const char *env = getenv(TUNABLES_NAME);\n+  bool from_reexec = getenv(REEXEC_NAME) != nullptr;\n+  if (env && (strcmp(env, env_val) == 0 || (!INCLUDE_CPU_FEATURE_ACTIVE && from_reexec))) {\n+    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Environment variable already set, glibc CPU_FEATURE_ACTIVE is unavailable - re-exec suppressed: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      return true;\n+    }\n+  }\n+  {\n+    ResourceMark rm;\n+    size_t env_buf_size = strlen(disable_str) + (!env ? 0 : strlen(env) + 100);\n+    char *env_buf = NEW_RESOURCE_ARRAY(char, env_buf_size);\n+    if (env) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n+      if (!hwcaps) {\n+        strcpy(env_buf, env);\n+        strcat(env_buf, disable_str);\n+      } else {\n+        const char *colon = strchr(hwcaps, ':');\n+        if (!colon) {\n+          strcpy(env_buf, env);\n+          strcat(env_buf, disable_str + glibc_prefix_len);\n+        } else {\n+          int err = jio_snprintf(env_buf, env_buf_size, \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n+          assert(err >= 0 && (unsigned) err < env_buf_size, \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+        }\n+      }\n+      env_val = env_buf;\n+    }\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+    }\n+    if (setenv(TUNABLES_NAME, env_val, 1)) {\n+      vm_exit_during_initialization(err_msg(\"setenv \" TUNABLES_NAME \" error: %m\"));\n+    }\n+  }\n+\n+  if (from_reexec) {\n+    vm_exit_during_initialization(err_msg(\"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str));\n+  }\n+  if (setenv(REEXEC_NAME, \"1\", 1)) {\n+    vm_exit_during_initialization(err_msg(\"setenv \" REEXEC_NAME \" error: %m\"));\n+  }\n+  return false;\n+}\n+\n+void VM_Version::glibc_reexec() {\n+  char *buf = nullptr;\n+  size_t buf_allocated = 0;\n+  size_t buf_used = 0;\n+#define CMDLINE \"\/proc\/self\/cmdline\"\n+  int fd = open(CMDLINE, O_RDONLY);\n+  if (fd == -1)\n+    vm_exit_during_initialization(err_msg(\"Cannot open \" CMDLINE \": %m\"));\n+  ssize_t got;\n+  do {\n+    if (buf_used == buf_allocated) {\n+      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n+      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n+      if (buf == nullptr)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu bytes\", buf_allocated));\n+    }\n+    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n+    if (got == -1)\n+      vm_exit_during_initialization(err_msg(\"Cannot read \" CMDLINE \": %m\"));\n+    buf_used += got;\n+  } while (got);\n+  if (close(fd))\n+    vm_exit_during_initialization(err_msg(\"Cannot close \" CMDLINE \": %m\"));\n+  char **argv = nullptr;\n+  size_t argv_allocated = 0;\n+  size_t argv_used = 0;\n+  char *s = buf;\n+  while (s <= buf + buf_used) {\n+    if (argv_used == argv_allocated) {\n+      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n+      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n+      if (argv == nullptr)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu pointers\", argv_allocated));\n+    }\n+    if (s == buf + buf_used) {\n+      break;\n+    }\n+    argv[argv_used++] = s;\n+    s += strnlen(s, buf + buf_used - s);\n+    if (s == buf + buf_used)\n+      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n+    ++s;\n+  }\n+  argv[argv_used] = nullptr;\n+#undef CMDLINE\n+\n+#define EXEC \"\/proc\/self\/exe\"\n+  execv(EXEC, argv);\n+  vm_exit_during_initialization(err_msg(\"Cannot re-execute \" EXEC \": %m\"));\n+#undef EXEC\n+}\n+\n+\/\/ Returns whether we should have got set a GLIBC_TUNABLES environment variables but did not get any.\n+bool VM_Version::glibc_not_using() {\n+  if (_ignore_glibc_not_using)\n+    return true;\n+\n+  VM_Version::VM_Features features_expected;\n+  features_expected.set_all_features();\n+  if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+    features_expected = _features;\n+  }\n+  VM_Version::VM_Features shouldnotuse = features_expected & ~_features;\n+\n+#ifndef ASSERT\n+  if (shouldnotuse.empty())\n+    return true;\n+#endif\n+\n+  \/\/ glibc: sysdeps\/x86\/get-isa-level.h:\n+  \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMOV)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, CX8)\n+  \/\/ glibc:     && CPU_FEATURE_CPU_P (cpu_features, FPU)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FXSR)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MMX)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE2))\n+  \/\/ glibc:     isa_level = GNU_PROPERTY_X86_ISA_1_BASELINE;\n+  if (_features.supports_feature(CPU_CMOV) &&\n+      _features.supports_feature(CPU_CX8) &&\n+      \/\/ FPU is always present on i686+: _features.supports_feature(CPU_FPU) &&\n+      _features.supports_feature(CPU_SSE2)) {\n+    \/\/ These cannot be disabled by CPU_TUNABLES.\n+    if (shouldnotuse.supports_feature(CPU_FXSR) || shouldnotuse.supports_feature(CPU_MMX) ||\n+        shouldnotuse.supports_feature(CPU_SSE)) {\n+      assert(!shouldnotuse.supports_feature(CPU_SSE2), \"CPU_SSE2 in both _features and shouldnotuse cannot happen\");\n+      \/\/ FIXME: The choice should be based on glibc impact, not the feature age.\n+      \/\/ CX8 is i586+, CMOV is i686+ 1995+, SSE2 is 2000+\n+      shouldnotuse.set_feature(CPU_SSE2);\n+    }\n+    if (_features.supports_feature(CPU_FXSR) &&\n+        _features.supports_feature(CPU_MMX) &&\n+        _features.supports_feature(CPU_SSE)) {\n+      \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMPXCHG16B)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LAHF64_SAHF64)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, POPCNT)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_1)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_2))\n+      \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V2;\n+      if (_features.supports_feature(CPU_POPCNT) &&\n+          _features.supports_feature(CPU_SSSE3) &&\n+          _features.supports_feature(CPU_SSE4_1) &&\n+          _features.supports_feature(CPU_SSE4_2)) {\n+        if (shouldnotuse.supports_feature(CPU_SSE3) ||\n+            (shouldnotuse.supports_feature(CPU_CMPXCHG16) || shouldnotuse.supports_feature(CPU_LAHFSAHF))) {\n+          assert(!shouldnotuse.supports_feature(CPU_SSE4_2), \"CPU_SSE4_2 in both _features and shouldnotuse cannot happen\");\n+          \/\/ POPCNT is 2007+, SSSE3 is 2006+, SSE4_1 is 2007+, SSE4_2 is 2008+.\n+          shouldnotuse.set_feature(CPU_SSE4_2);\n+        }\n+        if (_features.supports_feature(CPU_SSE3) &&\n+            _features.supports_feature(CPU_CMPXCHG16) &&\n+            _features.supports_feature(CPU_LAHFSAHF)) {\n+          \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI1)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, F16C)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FMA)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LZCNT)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MOVBE))\n+          \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V3;\n+          if (_features.supports_feature(CPU_AVX) &&\n+              _features.supports_feature(CPU_AVX2) &&\n+              _features.supports_feature(CPU_BMI1) &&\n+              _features.supports_feature(CPU_BMI2) &&\n+              _features.supports_feature(CPU_FMA) &&\n+              _features.supports_feature(CPU_LZCNT) &&\n+              _features.supports_feature(CPU_MOVBE)) {\n+            if (shouldnotuse.supports_feature(CPU_F16C)) {\n+              assert(!shouldnotuse.supports_feature(CPU_MOVBE), \"CPU_MOVBE in both _features and shouldnotuse cannot happen\");\n+              \/\/ FMA is 2012+, AVX2+BMI1+BMI2+LZCNT are 2013+, MOVBE is 2015+\n+              shouldnotuse.set_feature(CPU_MOVBE);\n+            }\n+            if (_features.supports_feature(CPU_F16C)) {\n+              \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX512F)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512BW)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512CD)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512DQ)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512VL))\n+              \/\/ glibc:   isa_level |= GNU_PROPERTY_X86_ISA_1_V4;\n+              \/\/ All these flags are supported by disable() below.\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  static const size_t tunables_size_max = sizeof(\"AVX_Fast_Unaligned_Load\") - 1;\n+  char disable_str[MAX_CPU_FEATURES * (1\/*','*\/ + 1\/*'-'*\/ + tunables_size_max) + 1\/*'\\0'*\/];\n+  strcpy(disable_str, glibc_prefix);\n+  char *disable_end = disable_str + glibc_prefix_len;\n+  auto disable = [&](const char *tunables) {\n+    size_t remains = disable_str + sizeof(disable_str) - disable_end;\n+    guarantee(2 + strlen(tunables) < remains, \"internal error: disable_str overflow\");\n+    *disable_end++ = ',';\n+    *disable_end++ = '-';\n+    disable_end = stpcpy(disable_end, tunables);\n+  };\n+\n+#ifdef ASSERT\n+  VM_Version::VM_Features handled;\n+#endif\n+  auto shouldnotuse_handled = [&](VM_Version::Feature_Flag feature, const char *tunables) {\n+    assert(strlen(tunables) <= tunables_size_max, \"Too long string %s\", tunables);\n+    assert(!handled.supports_feature(feature), \"already used %s\", tunables);\n+    DEBUG_ONLY(handled.set_feature(feature));\n+  };\n+#define EXCESSIVE_HANDLED(tunables) shouldnotuse_handled(PASTE_TOKENS(CPU_, tunables), STR(tunables))\n+\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# define FEATURE_ACTIVE(tunables) CPU_FEATURE_ACTIVE(tunables)\n+#else\n+# define FEATURE_ACTIVE(tunables) true\n+#endif\n+\n+  auto shouldnotuse_set = [&](VM_Version::Feature_Flag feature, const char *tunables, bool feature_active) {\n+    shouldnotuse_handled(feature, tunables);\n+    if (shouldnotuse.supports_feature(feature) && feature_active) {\n+      disable(tunables);\n+    }\n+  };\n+#define EXCESSIVE2(tunables, feature_active) shouldnotuse_set(PASTE_TOKENS(CPU_, tunables), STR(tunables), feature_active)\n+#define EXCESSIVE(tunables) EXCESSIVE2(tunables, FEATURE_ACTIVE(tunables))\n+  EXCESSIVE(AVX     );\n+  EXCESSIVE(CX8     );\n+  EXCESSIVE(FMA     );\n+  EXCESSIVE(RTM     );\n+  EXCESSIVE(AVX2    );\n+  EXCESSIVE(BMI1    );\n+  EXCESSIVE(BMI2    );\n+  EXCESSIVE(CMOV    );\n+  EXCESSIVE(ERMS    );\n+  EXCESSIVE(SSE2    );\n+  EXCESSIVE(LZCNT   );\n+  EXCESSIVE(SSSE3   );\n+  EXCESSIVE(POPCNT  );\n+  EXCESSIVE(SSE4_1  );\n+  EXCESSIVE(SSE4_2  );\n+  EXCESSIVE(AVX512F );\n+  EXCESSIVE(AVX512CD);\n+  EXCESSIVE(AVX512BW);\n+  EXCESSIVE(AVX512DQ);\n+  EXCESSIVE(AVX512ER);\n+  EXCESSIVE(AVX512PF);\n+  EXCESSIVE(AVX512VL);\n+  EXCESSIVE(IBT     );\n+  EXCESSIVE(FMA4    );\n+  EXCESSIVE(MOVBE   );\n+  EXCESSIVE(SHSTK   );\n+  EXCESSIVE(XSAVE   );\n+  EXCESSIVE(OSXSAVE );\n+  EXCESSIVE(HTT     );\n+  EXCESSIVE(XSAVEC  );\n+  \/\/ There is no CPU_FEATURE_ACTIVE() available for this symbol.\n+  \/\/ The detection is a copy from glibc sysdeps\/x86\/cpu-features.c .\n+  \/\/ There is no check for 'xem_xcr0_eax.bits.sse != 0 && xem_xcr0_eax.bits.ymm != 0' but FEATURE_ACTIVE(AVX) depends on it so it can be assumed.\n+  EXCESSIVE2(AVX_Fast_Unaligned_Load, FEATURE_ACTIVE(OSXSAVE) && FEATURE_ACTIVE(AVX) && FEATURE_ACTIVE(AVX2));\n+#undef EXCESSIVE\n+\n+#ifdef ASSERT\n+  \/\/ These cannot be disabled by GLIBC_TUNABLES interface.\n+#define GLIBC_UNSUPPORTED(hotspot) EXCESSIVE_HANDLED(hotspot)\n+  GLIBC_UNSUPPORTED(3DNOW_PREFETCH   );\n+  GLIBC_UNSUPPORTED(SSE4A            );\n+  GLIBC_UNSUPPORTED(TSC              );\n+  GLIBC_UNSUPPORTED(TSCINV_BIT       );\n+  GLIBC_UNSUPPORTED(TSCINV           );\n+  GLIBC_UNSUPPORTED(AES              );\n+  GLIBC_UNSUPPORTED(CLMUL            );\n+  GLIBC_UNSUPPORTED(ADX              );\n+  GLIBC_UNSUPPORTED(SHA              );\n+  GLIBC_UNSUPPORTED(VZEROUPPER       );\n+  GLIBC_UNSUPPORTED(AVX512_VPOPCNTDQ );\n+  GLIBC_UNSUPPORTED(AVX512_VPCLMULQDQ);\n+  GLIBC_UNSUPPORTED(AVX512_VAES      );\n+  GLIBC_UNSUPPORTED(AVX512_VNNI      );\n+  GLIBC_UNSUPPORTED(FLUSH            );\n+  GLIBC_UNSUPPORTED(FLUSHOPT         );\n+  GLIBC_UNSUPPORTED(CLWB             );\n+  GLIBC_UNSUPPORTED(AVX512_VBMI2     );\n+  GLIBC_UNSUPPORTED(AVX512_VBMI      );\n+  GLIBC_UNSUPPORTED(HV               );\n+  GLIBC_UNSUPPORTED(SSE3             );\n+  GLIBC_UNSUPPORTED(SERIALIZE        );\n+  GLIBC_UNSUPPORTED(RDTSCP           );\n+  GLIBC_UNSUPPORTED(RDPID            );\n+  GLIBC_UNSUPPORTED(FSRM             );\n+  GLIBC_UNSUPPORTED(GFNI             );\n+  GLIBC_UNSUPPORTED(AVX512_BITALG    );\n+  GLIBC_UNSUPPORTED(F16C             );\n+  GLIBC_UNSUPPORTED(PKU              );\n+  GLIBC_UNSUPPORTED(OSPKE            );\n+  GLIBC_UNSUPPORTED(CET_IBT          );\n+  GLIBC_UNSUPPORTED(CET_SS           );\n+  GLIBC_UNSUPPORTED(AVX512_IFMA      );\n+  GLIBC_UNSUPPORTED(AVX_IFMA         );\n+  GLIBC_UNSUPPORTED(APX_F            );\n+  GLIBC_UNSUPPORTED(SHA512           );\n+  GLIBC_UNSUPPORTED(AVX512_FP16      );\n+  GLIBC_UNSUPPORTED(AVX10_1          );\n+  GLIBC_UNSUPPORTED(AVX10_2          );\n+  GLIBC_UNSUPPORTED(HT               );\n+  GLIBC_UNSUPPORTED(HYBRID           );\n+  \/\/ These are handled as an exception above.\n+  GLIBC_UNSUPPORTED(FXSR             );\n+  GLIBC_UNSUPPORTED(MMX              );\n+  GLIBC_UNSUPPORTED(SSE              );\n+  GLIBC_UNSUPPORTED(CMPXCHG16        );\n+  GLIBC_UNSUPPORTED(LAHFSAHF         );\n+#undef GLIBC_UNSUPPORTED\n+\n+  VM_Version::VM_Features all_features;\n+  all_features.set_all_features();\n+  if (handled != all_features) {\n+    stringStream ss;\n+    ss.print_raw(\"internal error: Unsupported disabling of some CPU_* \");\n+    handled.print_numbers(ss);\n+    ss.print_raw(\" != full \");\n+    all_features.print_numbers(ss);\n+    vm_exit_during_initialization(ss.base());\n+  }\n+#endif \/\/ ASSERT\n+\n+  *disable_end = 0;\n+  if (disable_end == disable_str + glibc_prefix_len)\n+    return true;\n+  if (glibc_env_set(disable_str))\n+    return true;\n+  return false;\n+}\n+#undef REEXEC_NAME\n+#endif \/\/ LINUX\n+\n+void VM_Version::print_using_features_cr() {\n+  if (_ignore_glibc_not_using) {\n+    tty->print_raw_cr(\"CPU features are being kept intact as requested by -XX:CPUFeatures=ignore\");\n+  } else {\n+    tty->print_raw(\"CPU features being used are: -XX:CPUFeatures=\");\n+    _features.print_numbers(*tty);\n+    tty->cr();\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hardware() {\n@@ -866,0 +1353,1 @@\n+  _features = VM_Version::VM_Features();\n@@ -894,0 +1382,8 @@\n+  if (ShowCPUFeatures) {\n+    tty->print_raw(\"This machine's CPU features are: -XX:CPUFeatures=\");\n+    _features.print_numbers(*tty);\n+    tty->cr();\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hotspot() {\n@@ -896,0 +1392,10 @@\n+    if (!FLAG_IS_DEFAULT(CPUFeatures)) {\n+      stringStream ss;\n+      ss.print_raw(\"-XX:CPUFeatures option requires SSE2 flag to be set: \");\n+      {\n+        VM_Features sse2;\n+        sse2.set_feature(CPU_SSE2);\n+        sse2.print_numbers(ss);\n+      }\n+      vm_exit_during_initialization(ss.base());\n+    }\n@@ -2081,0 +2587,7 @@\n+bool VM_Version::cpu_features_binary(VM_Version::VM_Features *data) {\n+  *data = _features;\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  data->clear_feature(CPU_HT);\n+  return true;\n+}\n+\n@@ -2135,1 +2648,40 @@\n-  get_processor_features();\n+\n+  assert(_features.empty(), \"_features should be zero at startup\");\n+  get_processor_features_hardware();\n+\n+  assert(!CPUFeatures == FLAG_IS_DEFAULT(CPUFeatures), \"CPUFeatures parsing\");\n+\n+  VM_Features CPUFeatures_parsed = CPUFeatures_parse(CPUFeatures);\n+  VM_Features features_missing = CPUFeatures_parsed & ~_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing.clear_feature(CPU_HT);\n+\n+  if (!features_missing.empty()) {\n+    stringStream ss;\n+    ss.print_raw(\"Specified -XX:CPUFeatures=\");\n+    CPUFeatures_parsed.print_numbers(ss);\n+    ss.print_raw(\"; this machine's CPU features are \");\n+    _features.print_numbers(ss);\n+    ss.print_raw(\"; missing features of this CPU are \");\n+    features_missing.print_numbers(ss);\n+    ss.print_raw(\" = \");\n+    insert_features_names(features_missing, ss);\n+    ss.cr();\n+    ss.print_raw_cr(\"If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:CheckCPUFeatures=ignore .\");\n+    vm_exit_during_initialization(ss.base());\n+  }\n+\n+  _features_saved = _features;\n+  _features = CPUFeatures_parsed;\n+\n+  if (ShowCPUFeatures && !CRaCRestoreFrom) {\n+    print_using_features_cr();\n+  }\n+\n+#ifdef LINUX\n+  if (!glibc_not_using())\n+    glibc_reexec();\n+#endif\n+\n+  get_processor_features_hotspot();\n@@ -3085,0 +3637,36 @@\n+  \/\/ glibc-only features.\n+  if (std_cpuid1_ecx.bits.movbe != 0) {\n+    vm_features.set_feature(CPU_MOVBE);\n+  }\n+  if (std_cpuid1_ecx.bits.osxsave != 0) {\n+    vm_features.set_feature(CPU_OSXSAVE);\n+  }\n+  if (std_cpuid1_ecx.bits.xsave != 0) {\n+    vm_features.set_feature(CPU_XSAVE);\n+  }\n+  if (std_cpuid1_ecx.bits.cmpxchg16 != 0) {\n+    vm_features.set_feature(CPU_CMPXCHG16);\n+  }\n+  if (ext_cpuid1_ecx.bits.fma4 != 0) {\n+    vm_features.set_feature(CPU_FMA4);\n+  }\n+  if (ext_cpuid1_ecx.bits.LahfSahf != 0) {\n+    vm_features.set_feature(CPU_LAHFSAHF);\n+  }\n+  if (std_cpuid1_edx.bits.ht != 0) {\n+    vm_features.set_feature(CPU_HTT);\n+  }\n+  if (xfs_cpuidD1_eax.bits.xsavec != 0) {\n+    vm_features.set_feature(CPU_XSAVEC);\n+  }\n+  \/\/ The detection is a copy from glibc sysdeps\/x86\/cpu-features.c .\n+  if (vm_features.supports_feature(CPU_OSXSAVE)) {\n+    if (vm_features.supports_feature(CPU_AVX)) {\n+      assert(xem_xcr0_eax.bits.sse != 0, \"required by CPU_AVX\");\n+      assert(xem_xcr0_eax.bits.ymm != 0, \"required by CPU_AVX\");\n+      if (vm_features.supports_feature(CPU_AVX2)) {\n+        vm_features.set_feature(CPU_AVX_Fast_Unaligned_Load);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":593,"deletions":5,"binary":false,"changes":598,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -38,0 +39,2 @@\n+  friend class CracEngine;\n+  friend class crac;\n@@ -88,1 +91,2 @@\n-                        : 2,\n+                        : 1,\n+               movbe    : 1,\n@@ -92,1 +96,1 @@\n-                        : 1,\n+               xsave    : 1,\n@@ -149,0 +153,12 @@\n+  union XfsCpuidDEax {\n+    uint32_t value;\n+    struct {\n+      uint32_t xsaveopt     : 1,\n+               xsavec       : 1,\n+               xgetbv_ecx1  : 1,\n+               xss          : 1,\n+               xfd          : 1,\n+                            : 27;\n+    } bits;\n+  };\n+\n@@ -159,1 +175,3 @@\n-                            : 23;\n+                            : 7,\n+               fma4         : 1,\n+                            : 15;\n@@ -457,1 +475,12 @@\n-    decl(HYBRID,            \"hybrid\",            65) \/* Hybrid architecture *\/\n+    decl(HYBRID,            \"hybrid\",            65) \/* Hybrid architecture *\/ \\\n+    decl(FMA4,              \"fma4\",              66) \\\n+    decl(MOVBE,             \"movbe\",             67) \\\n+    decl(OSXSAVE,           \"osxsave\",           68) \\\n+    decl(IBT,               \"ibt\",               69) \\\n+    decl(SHSTK,             \"shstk\",             70) \/* Also known as cet_ss *\/ \\\n+    decl(XSAVE,             \"xsave\",             71) \\\n+    decl(CMPXCHG16,         \"cmpxchg16\",         72) \/* Also known in cpuinfo as cx16 and in glibc as cmpxchg16b *\/ \\\n+    decl(LAHFSAHF,          \"lahfsahf\",          73) \/* Also known in cpuinfo as lahf_lm and in glibc as lahf64_sahf64 *\/ \\\n+    decl(HTT,               \"htt\",               74) \/* hotspot calls it 'ht' but that is affected by threads_per_core() *\/ \\\n+    decl(XSAVEC,            \"xsavec\",            75) \\\n+    decl(AVX_Fast_Unaligned_Load, \"avx_fast_unaligned_load\", 76)\n@@ -470,1 +499,1 @@\n-    uint64_t _features_bitmap[(MAX_CPU_FEATURES \/ BitsPerLong) + 1];\n+    uint64_t _features_bitmap[(MAX_CPU_FEATURES + BitsPerLong - 1) \/ BitsPerLong];\n@@ -474,5 +503,0 @@\n-    \/\/ Number of 8-byte elements in _bitmap.\n-    constexpr static int features_bitmap_element_count() {\n-      return sizeof(_features_bitmap) \/ sizeof(uint64_t);\n-    }\n-\n@@ -498,0 +522,30 @@\n+\n+    static uint64_t index_mask(int idx) {\n+      assert(idx < features_bitmap_element_count(), \"Features array index out of bounds\");\n+      if (idx + 1 < features_bitmap_element_count()) {\n+        return -1LL;\n+      }\n+      \/\/ It is equivalent to 'bit_mask(MAX_CPU_FEATURES) - 1'.\n+      return ((bit_mask((Feature_Flag) ((int) MAX_CPU_FEATURES - 1)) - 1) << 1) | 1;\n+    }\n+\n+    \/\/ We do not use std::forward<> as we just call 'func'.\n+    template <typename T, typename F>\n+    static void apply_to_all_features(T&& t, F&& func) {\n+      for (int idx = 0; idx < t.features_bitmap_element_count(); ++idx) {\n+        func(t._features_bitmap[idx], idx);\n+      }\n+    }\n+\n+    \/\/ We do not use std::forward<> as we just call 'func'.\n+    template <typename F>\n+    void apply_to_all_features(F&& func) {\n+      apply_to_all_features(*this, func);\n+    }\n+\n+    \/\/ We do not use std::forward<> as we just call 'func'.\n+    template <typename F>\n+    void apply_to_all_features(F&& func) const {\n+      apply_to_all_features(*this, func);\n+    }\n+\n@@ -500,3 +554,8 @@\n-      for (int i = 0; i < features_bitmap_element_count(); i++) {\n-        _features_bitmap[i] = 0;\n-      }\n+      apply_to_all_features([](uint64_t &u, int idx) {\n+        u = 0;\n+      });\n+    }\n+\n+    \/\/ Number of 8-byte elements in _bitmap.\n+    constexpr static int features_bitmap_element_count() {\n+      return sizeof(_features_bitmap) \/ sizeof(uint64_t);\n@@ -519,0 +578,50 @@\n+\n+    void set_all_features() {\n+      apply_to_all_features([](uint64_t &u, int idx) {\n+        u = index_mask(idx);\n+      });\n+    }\n+\n+    void set_feature_idx(int idx, uint64_t val) {\n+      assert(idx < features_bitmap_element_count(), \"Features array index out of bounds\");\n+      _features_bitmap[idx] = val;\n+    }\n+\n+    VM_Features operator ~() const {\n+      VM_Features retval = *this;\n+      apply_to_all_features(retval, [](uint64_t &u, int idx) {\n+        u ^= index_mask(idx);\n+      });\n+      return retval;\n+    }\n+\n+    VM_Features operator &(const VM_Features &other) const {\n+      VM_Features retval = *this;\n+      apply_to_all_features(retval, [&other](uint64_t &u, int idx) {\n+        u &= other._features_bitmap[idx];\n+      });\n+      return retval;\n+    }\n+\n+    bool operator ==(const VM_Features &other) const {\n+      bool retval = true;\n+      apply_to_all_features([&other, &retval](uint64_t u, int idx) {\n+        if (u != other._features_bitmap[idx]) {\n+          retval = false;\n+        }\n+      });\n+      return retval;\n+    }\n+\n+    bool operator !=(const VM_Features &other) const {\n+      return !(*this == other);\n+    }\n+\n+    bool empty() const {\n+      VM_Features empty_features;\n+      return *this == empty_features;\n+    }\n+\n+    void print_numbers(outputStream &os, bool hexonly = false) const;\n+\n+    const char *print_numbers() const;\n@@ -522,1 +631,1 @@\n-  static VM_Features _features;\n+  static VM_Features _features, _features_saved;\n@@ -625,0 +734,4 @@\n+    \/\/ cpuid function 0xD (xsave features and state components)\n+    \/\/ ecx = 1\n+    XfsCpuidDEax xfs_cpuidD1_eax;\n+\n@@ -717,0 +830,16 @@\n+  static void get_processor_features_hardware();\n+  static void get_processor_features_hotspot();\n+\n+  static VM_Features CPUFeatures_parse(const char *str);\n+#ifdef LINUX\n+  static bool glibc_not_using();\n+  static bool glibc_env_set(char *disable_str);\n+  \/*[[noreturn]]*\/ static void glibc_reexec();\n+  \/\/ C++17: Make glibc_prefix and glibc_prefix_len constexpr.\n+  static const char glibc_prefix[];\n+  static const size_t glibc_prefix_len;\n+#endif \/\/LINUX\n+  \/\/ C++17: Make _ignore_glibc_not_using inline.\n+  static bool _ignore_glibc_not_using;\n+  static void print_using_features_cr();\n+\n@@ -738,0 +867,1 @@\n+  static ByteSize xfs_cpuidD1_offset() { return byte_offset_of(CpuidInfo, xfs_cpuidD1_eax); }\n@@ -788,0 +918,7 @@\n+  static bool cpu_features_binary(VM_Features *data);\n+  static bool ignore_cpu_features() {\n+    \/\/ This gets triggered by -XX:CPUFeatures=ignore, not writing the features & arch\n+    \/\/ on checkpoint into the image at all, and skipping the check on restore.\n+    return _ignore_glibc_not_using;\n+  }\n+  static void restore_check(const char* str, const char* msg_prefix);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":151,"deletions":14,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+\n+  check_cpufeatures_vmoptions();\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -919,0 +919,3 @@\n+void os::reset_cached_process_id() {\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -960,0 +960,3 @@\n+void os::reset_cached_process_id() {\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,513 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"classfile\/classLoader.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"perfMemory_linux.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+#include <netinet\/in.h>\n+#include <string.h>\n+\n+class FdsInfo {\n+public:\n+\n+  enum state_t {\n+    INVALID = -3,\n+    CLOSED = -2,\n+    ROOT = -1,\n+    DUP_OF_0 = 0,\n+    \/\/ ...\n+  };\n+\n+private:\n+  struct fdinfo {\n+    int fd;\n+    struct stat stat;\n+    state_t state;\n+  };\n+\n+  \/\/ params are indices into _fdinfos\n+  bool same_fd(int i1, int i2);\n+\n+  bool _inited;\n+  GrowableArray<fdinfo> _fdinfos;\n+\n+public:\n+  void initialize();\n+\n+  int len() { return _fdinfos.length(); }\n+\n+  state_t get_state(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).state;\n+  }\n+\n+  state_t find_state(int fd, state_t orstate) {\n+    for (int i = 0; i < _fdinfos.length(); ++i) {\n+      fdinfo *info = _fdinfos.adr_at(i);\n+      if (info->fd == fd) {\n+        return info->state;\n+      }\n+    }\n+    return orstate;\n+  }\n+\n+  int get_fd(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).fd;\n+  }\n+\n+  struct stat* get_stat(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return &_fdinfos.at(i).stat;\n+  }\n+\n+  FdsInfo(bool do_init = true) :\n+    _inited(false),\n+    _fdinfos(16, mtInternal)\n+  {\n+    if (do_init) {\n+      initialize();\n+    }\n+  }\n+};\n+\n+static FdsInfo _vm_inited_fds(false);\n+\n+static int readfdlink(int fd, char *link, size_t len) {\n+  char fdpath[64];\n+  os::snprintf_checked(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+  int ret = readlink(fdpath, link, len);\n+  if (ret == -1) {\n+    return ret;\n+  }\n+  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n+  return ret;\n+}\n+\n+static bool same_stat(struct stat* st1, struct stat* st2) {\n+  return st1->st_dev == st2->st_dev &&\n+         st1->st_ino == st2->st_ino;\n+}\n+\n+bool FdsInfo::same_fd(int i1, int i2) {\n+  assert(i1 < _fdinfos.length(), \"\");\n+  assert(i2 < _fdinfos.length(), \"\");\n+  fdinfo *fi1 = _fdinfos.adr_at(i1);\n+  fdinfo *fi2 = _fdinfos.adr_at(i2);\n+  if (!same_stat(&fi1->stat, &fi2->stat)) {\n+    return false;\n+  }\n+\n+  int flags1 = fcntl(fi1->fd, F_GETFL);\n+  int flags2 = fcntl(fi2->fd, F_GETFL);\n+  if (flags1 != flags2) {\n+    return false;\n+  }\n+\n+  const int test_flag = O_NONBLOCK;\n+  const int new_flags1 = flags1 ^ test_flag;\n+  fcntl(fi1->fd, F_SETFL, new_flags1);\n+  if (fcntl(fi1->fd, F_GETFL) != new_flags1) {\n+    \/\/ flag write ignored or handled differently,\n+    \/\/ don't know what to do\n+    return false;\n+  }\n+\n+  const int new_flags2 = fcntl(fi2->fd, F_GETFL);\n+  const bool are_same = new_flags1 == new_flags2;\n+\n+  fcntl(fi2->fd, flags1);\n+\n+  return are_same;\n+}\n+\n+void FdsInfo::initialize() {\n+  assert(!_inited, \"should be called only once\");\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  int dfd = dirfd(dir);\n+  while ((dp = readdir(dir))) {\n+    if (dp->d_name[0] == '.') {\n+      \/\/ skip \".\" and \"..\"\n+      continue;\n+    }\n+    fdinfo info;\n+    info.fd = atoi(dp->d_name);\n+    if (info.fd == dfd) {\n+      continue;\n+    }\n+    int r = fstat(info.fd, &info.stat);\n+    if (r == -1) {\n+      info.state = CLOSED;\n+      continue;\n+    }\n+    info.state = ROOT; \/\/ can be changed to DUP_OF_0 + N below\n+    _fdinfos.append(info);\n+  }\n+  closedir(dir);\n+  _inited = true;\n+\n+  for (int i = 0; i < _fdinfos.length(); ++i) {\n+    fdinfo *info = _fdinfos.adr_at(i);\n+    for (int j = 0; j < i; ++j) {\n+      if (get_state(j) == ROOT && same_fd(i, j)) {\n+        info->state = (state_t)(DUP_OF_0 + j);\n+        break;\n+      }\n+    }\n+  }\n+}\n+\n+static const char* stat2strtype(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK: return \"socket\";\n+  case S_IFLNK:  return \"symlink\";\n+  case S_IFREG:  return \"regular\";\n+  case S_IFBLK:  return \"block\";\n+  case S_IFDIR:  return \"directory\";\n+  case S_IFCHR:  return \"character\";\n+  case S_IFIFO:  return \"fifo\";\n+  default:       break;\n+  }\n+  return \"unknown\";\n+}\n+\n+static int stat2stfail(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK:\n+    return JVM_CR_FAIL_SOCK;\n+  case S_IFLNK:\n+  case S_IFREG:\n+  case S_IFBLK:\n+  case S_IFDIR:\n+  case S_IFCHR:\n+    return JVM_CR_FAIL_FILE;\n+  case S_IFIFO:\n+    return JVM_CR_FAIL_PIPE;\n+  default:\n+    break;\n+  }\n+  return JVM_CR_FAIL;\n+}\n+\n+\/\/ If checkpoint is called throught the API, jcmd operation and jcmd output doesn't exist.\n+bool VM_Crac::is_socket_from_jcmd(int sock) {\n+#if INCLUDE_SERVICES\n+  if (_attach_op == nullptr)\n+    return false;\n+  int sock_fd = _attach_op->socket();\n+  return sock == sock_fd;\n+#else\n+  return false;\n+#endif\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+#if INCLUDE_SERVICES\n+  if (_attach_op == nullptr)\n+    return;\n+  bufferedStream* buf = static_cast<bufferedStream*>(_ostream);\n+  _attach_op->effectively_complete_raw(JNI_OK, buf);\n+  \/\/ redirect any further output to console\n+  _ostream = tty;\n+#endif\n+}\n+\n+bool VM_Crac::check_fds() {\n+\n+  AttachListener::abort();\n+\n+  FdsInfo fds;\n+\n+  bool ok = true;\n+\n+  ResourceMark rm;\n+  GrowableArray<int> boot_classpath_fds = ClassLoader::get_classpath_entry_fds();\n+  GrowableArray<int> patch_module_fds = ClassLoader::get_patch_module_entry_fds();\n+\n+  for (int i = 0; i < fds.len(); ++i) {\n+    if (fds.get_state(i) == FdsInfo::CLOSED) {\n+      continue;\n+    }\n+    int fd = fds.get_fd(i);\n+\n+    char detailsbuf[PATH_MAX];\n+    struct stat* st = fds.get_stat(i);\n+    const char* type = stat2strtype(st->st_mode);\n+    int linkret = readfdlink(fd, detailsbuf, sizeof(detailsbuf));\n+    const char* details = 0 < linkret ? detailsbuf : \"\";\n+    {\n+      sockaddr_in sa;\n+      socklen_t slen = sizeof(sa);\n+      if (S_ISSOCK(st->st_mode) && 0 == getsockname(fd, (sockaddr*)&sa, &slen)) {\n+        const size_t len = strlen(detailsbuf);\n+        os::snprintf_checked(detailsbuf + len, sizeof(detailsbuf) - len, \",port=%d\", (int)ntohs(sa.sin_port));\n+      }\n+    }\n+    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\" \", fd, type, details);\n+\n+    if (is_claimed_fd(fd)) {\n+      print_resources(\"OK: claimed by java code\\n\");\n+      continue;\n+    }\n+\n+    if (_vm_inited_fds.find_state(fd, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n+      print_resources(\"OK: inherited from process env\\n\");\n+      continue;\n+    }\n+\n+    if (S_ISSOCK(st->st_mode)) {\n+      if (is_socket_from_jcmd(fd)){\n+        print_resources(\"OK: jcmd socket\\n\");\n+        continue;\n+      }\n+    }\n+\n+    if (boot_classpath_fds.contains(fd)) {\n+      print_resources(\"OK: claimed by classloader\\n\");\n+      continue;\n+    }\n+\n+    if (patch_module_fds.contains(fd)) {\n+      print_resources(\"OK: claimed by patch-module\\n\");\n+      continue;\n+    }\n+\n+    if (!strncmp(details, \"\/memfd:\", 7)) {\n+      print_resources(\"OK: memfd\\n\");\n+      continue;\n+    }\n+\n+    if (CRaCAllowedOpenFilePrefixes != nullptr) {\n+      const char *prefix = CRaCAllowedOpenFilePrefixes;\n+      \/\/ JDK appends to ccstrlist using newline, on command line that would be comma\n+      size_t prefix_length = strcspn(prefix, \",\\n\");\n+      bool matched = false;\n+      while (prefix_length > 0) {\n+        if (!strncmp(details, prefix, prefix_length)) {\n+          matched = true;\n+          break;\n+        }\n+        if (prefix[prefix_length] == '\\0') {\n+          break;\n+        }\n+        prefix += prefix_length + 1;\n+        prefix_length = strcspn(prefix, \",\\n\");\n+      }\n+      if (matched) {\n+        print_resources(\"OK: allowed in -XX:CRaCAllowedOpenFilePrefixes\\n\");\n+        continue;\n+      }\n+    }\n+\n+    print_resources(\"BAD: opened by application\\n\");\n+    ok = false;\n+\n+    const int maxinfo = 64;\n+    size_t buflen = strlen(details) + maxinfo;\n+    char* msg = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n+    int len = os::snprintf(msg, buflen, \"FD fd=%d type=%s path=%s\", fd, type, detailsbuf);\n+    msg[len < 0 ? 0 : ((size_t) len >= buflen ? buflen - 1 : len)] = '\\0';\n+    _failures->append(CracFailDep(stat2stfail(st->st_mode & S_IFMT), msg));\n+  }\n+\n+  return ok;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return PerfMemoryLinux::checkpoint();\n+}\n+\n+void VM_Crac::memory_restore() {\n+  PerfMemoryLinux::restore();\n+}\n+\n+static char modules_path[JVM_MAXPATHLEN] = { '\\0' };\n+\n+static bool is_fd_ignored(int fd, const char *path) {\n+  const char *list = CRaCIgnoredFileDescriptors;\n+  while (list && *list) {\n+    const char *end = strchr(list, ',');\n+    if (!end) {\n+      end = list + strlen(list);\n+    }\n+    char *invalid;\n+    int ignored_fd = strtol(list, &invalid, 10);\n+    if (invalid == end) { \/\/ entry was integer -> file descriptor\n+      if (fd == ignored_fd) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    } else { \/\/ interpret entry as path\n+      int path_len = path ? strlen(path) : -1;\n+      if (path_len != -1 && path_len == end - list && !strncmp(path, list, end - list)) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    }\n+    if (*end) {\n+      list = end + 1;\n+    } else {\n+      break;\n+    }\n+  }\n+\n+  if (os::same_files(modules_path, path)) {\n+    \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+    \/\/ We can ignore this for purposes of CRaC.\n+    return true;\n+  }\n+\n+  if (LogConfiguration::is_fd_used(fd)) {\n+    return true;\n+  }\n+\n+  if (defaultStream::instance->is_fd_used(fd)) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+static void close_extra_descriptors() {\n+  \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+  \/\/ We can ignore this for purposes of CRaC.\n+  if (modules_path[0] == '\\0') {\n+    const char* fileSep = os::file_separator();\n+    jio_snprintf(modules_path, JVM_MAXPATHLEN, \"%s%slib%s\" MODULES_IMAGE_NAME, Arguments::get_java_home(), fileSep, fileSep);\n+  }\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  while ((dp = readdir(dir))) {\n+    int fd = atoi(dp->d_name);\n+    if (fd > 2 && fd != dirfd(dir)) {\n+      int r = readfdlink(fd, path, sizeof(path));\n+      if (!is_fd_ignored(fd, r != -1 ? path : nullptr)) {\n+        log_warning(os)(\"CRaC closing file descriptor %d: %s\", fd, path);\n+        close(fd);\n+      }\n+    }\n+  }\n+  closedir(dir);\n+}\n+\n+void crac::vm_create_start() {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  close_extra_descriptors();\n+  _vm_inited_fds.initialize();\n+}\n+\n+static bool read_all(int fd, const char *filename, char *dest, size_t n) {\n+  size_t rd = 0;\n+  do {\n+    ssize_t r = ::read(fd, dest + rd, n - rd);\n+    if (r == 0) {\n+      log_error(crac)(\"Unexpected end of file %s (read %zu\/%zu bytes)\", filename, rd, n);\n+      return false;\n+    } else if (r < 0) {\n+      if (errno == EINTR) {\n+        continue;\n+      }\n+      log_error(crac)(\"I\/O error reading %s: %s\", filename, os::strerror(errno));\n+      return false;\n+    }\n+    rd += r;\n+  } while (rd < n);\n+  return true;\n+}\n+\n+\/\/ RAII object to close file descriptor\n+class FDGuard {\n+private:\n+  const char *_what;\n+  int _fd;\n+public:\n+  FDGuard(const char *what, int fd): _what(what), _fd(fd) {}\n+  ~FDGuard() {\n+    if (_fd >= 0 && ::close(_fd) != 0) {\n+      log_error(crac)(\"Cannot close %s: %s\", _what, os::strerror(errno));\n+    }\n+  }\n+};\n+\n+bool crac::read_bootid(char *dest) {\n+  const char *boot_id_file = \"\/proc\/sys\/kernel\/random\/boot_id\";\n+  int fd = ::open(boot_id_file, O_RDONLY);\n+  FDGuard guard(\"system boot ID file\", fd);\n+  if (fd < 0 || !read_all(fd, boot_id_file, dest, UUID_LENGTH)) {\n+    log_error(crac)(\"Cannot read system boot ID\");\n+    return false;\n+  }\n+  char c;\n+  ssize_t r = ::read(fd, &c, 1);\n+  if (r == 0) {\n+    \/\/ Some systems don't end boot-id with a newline\n+    return true;\n+  } else if (r < 0) {\n+    log_error(crac)(\"Failure reading system boot ID: %s\", os::strerror(errno));\n+    return false;\n+  } else if (c != '\\n') {\n+    log_error(crac)(\"System boot ID does not end with a newline\");\n+    return false;\n+  }\n+  r = ::read(fd, &c, 1);\n+  if (r == 0) {\n+    return true;\n+  } else if (r < 0) {\n+    log_error(crac)(\"Error reading system boot ID: %s\", os::strerror(errno));\n+  } else { \/\/ r > 0\n+    log_error(crac)(\"Unexpected data in system boot ID\");\n+  }\n+  return false;\n+}\n+\n+bool crac::random_bytes(u1 *dest, size_t length) {\n+  const char *urandom_file = \"\/dev\/urandom\";\n+  int fd = ::open(urandom_file, O_RDONLY);\n+  FDGuard guard(\"\/dev\/urandom\", fd);\n+  if (fd < 0 || !read_all(fd, urandom_file, reinterpret_cast<char *>(dest), length)) {\n+    log_error(crac)(\"Cannot get random bytes\");\n+    return false;\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/linux\/crac_linux.cpp","additions":513,"deletions":0,"binary":false,"changes":513,"status":"added"},{"patch":"@@ -64,0 +64,3 @@\n+  product(bool, CRaCCPUCountInit, false, \"Reinitialize the recorded \"   \\\n+          \"number of CPUs on restore\")                                  \\\n+                                                                        \\\n@@ -107,0 +110,5 @@\n+define_pd_global(ccstr, CRaCEngine, \"criuengine\");\n+\/\/ On some systems using SSSD files in this directory are left open\n+\/\/ after calling getpwuid_r, getpwname_r, getgrgid_r, getgrname_r\n+\/\/ or other functions in this family.\n+define_pd_global(ccstrlist, CRaCAllowedOpenFilePrefixes, \"\/var\/lib\/sss\/mc\/\");\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2017, 2022, Azul Systems, Inc. All rights reserved.\n@@ -26,0 +27,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -67,0 +69,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -205,0 +208,2 @@\n+static int cached_pid = 0;\n+\n@@ -508,0 +513,5 @@\n+void os::Linux::initialize_processor_count() {\n+  set_processor_count((int) sysconf(_SC_NPROCESSORS_CONF));\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n@@ -509,1 +519,1 @@\n-  set_processor_count((int)sysconf(_SC_NPROCESSORS_CONF));\n+  initialize_processor_count();\n@@ -522,1 +532,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n@@ -1475,0 +1484,1 @@\n+\n@@ -1476,1 +1486,8 @@\n-  return ::getpid();\n+  \/\/ GLIBC < 2.25 caches pid in ::getpid(); we need to be able to reset this\n+  \/\/ on CRaC restore, therefore we will use our own caching.\n+  return cached_pid ? cached_pid : syscall(SYS_getpid);\n+}\n+\n+void os::reset_cached_process_id() {\n+  cached_pid = 0;\n+  cached_pid = current_process_id();\n@@ -4376,0 +4393,1 @@\n+  cached_pid = current_process_id();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -57,0 +58,1 @@\n+  static void initialize_processor_count();\n@@ -308,0 +310,7 @@\n+  static void initialize_cpu_count() {\n+    initialize_processor_count();\n+    if (cpu_to_node() != nullptr) {\n+      rebuild_cpu_to_node_map();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"attachListener_posix.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"posixAttachOperation.hpp\"\n@@ -44,4 +47,0 @@\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(sockaddr_un::sun_path)\n-#endif\n-\n@@ -64,96 +63,0 @@\n-\/\/ forward reference\n-class PosixAttachOperation;\n-\n-class PosixAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n- public:\n-  static void set_path(char* path) {\n-    if (path == nullptr) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  static PosixAttachOperation* dequeue();\n-};\n-\n-class SocketChannel : public AttachOperation::RequestReader, public AttachOperation::ReplyWriter {\n-private:\n-  int _socket;\n-public:\n-  SocketChannel(int socket) : _socket(socket) {}\n-  ~SocketChannel() {\n-    close();\n-  }\n-\n-  bool opened() const {\n-    return _socket != -1;\n-  }\n-\n-  void close() {\n-    if (opened()) {\n-      ::shutdown(_socket, SHUT_RDWR);\n-      ::close(_socket);\n-      _socket = -1;\n-    }\n-  }\n-\n-  \/\/ RequestReader\n-  int read(void* buffer, int size) override {\n-    ssize_t n;\n-    RESTARTABLE(::read(_socket, buffer, (size_t)size), n);\n-    return checked_cast<int>(n);\n-  }\n-\n-  \/\/ ReplyWriter\n-  int write(const void* buffer, int size) override {\n-    ssize_t n;\n-    RESTARTABLE(::write(_socket, buffer, size), n);\n-    return checked_cast<int>(n);\n-  }\n-\n-  void flush() override {\n-  }\n-};\n-\n-class PosixAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  SocketChannel _socket_channel;\n-\n- public:\n-  PosixAttachOperation(int socket) : AttachOperation(), _socket_channel(socket) {}\n-\n-  void complete(jint res, bufferedStream* st) override;\n-\n-  ReplyWriter* get_reply_writer() override {\n-    return &_socket_channel;\n-  }\n-\n-  bool read_request() {\n-    return _socket_channel.read_request(this, &_socket_channel);\n-  }\n-};\n-\n@@ -165,0 +68,1 @@\n+PosixAttachOperation* PosixAttachListener::_current_op = nullptr;\n@@ -310,0 +214,1 @@\n+      _current_op = op;\n@@ -315,0 +220,11 @@\n+\/\/ An operation completion is splitted into two parts.\n+\/\/ For proper handling the jcmd connection at CRaC checkpoint action.\n+\/\/ An effectively_complete_raw is called in checkpoint processing, before criu engine calls, for properly closing the socket.\n+\/\/ The complete() gets called after restore for proper deletion the leftover object.\n+\n+void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n+  \/\/ reset the current op as late as possible, this happens on attach listener thread.\n+  PosixAttachListener::reset_current_op();\n+  delete this;\n+}\n+\n@@ -323,2 +239,23 @@\n-void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n-  delete this;\n+void PosixAttachOperation::effectively_complete_raw(jint result, bufferedStream* st) {\n+\n+  if (_effectively_completed) {\n+    assert(st->size() == 0, \"no lost output\");\n+    return;\n+  }\n+\n+  \/\/ write operation result\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    ThreadBlockInVM tbivm(JavaThread::cast(thread));\n+    write_operation_result(result, st);\n+  } else {\n+    write_operation_result(result, st);\n+  }\n+  _effectively_completed = true;\n+}\n+\n+void PosixAttachOperation::write_operation_result(jint result, bufferedStream* st) {\n+  _socket_channel.write_reply(result, st);\n+\n+  _socket_channel.close();\n+  st->reset();\n@@ -327,0 +264,16 @@\n+static void assert_listener_thread() {\n+#ifdef ASSERT\n+  ResourceMark rm; \/\/ For retrieving the thread names\n+  assert(strcmp(\"Attach Listener\", Thread::current()->name()) == 0, \"should gets called from Attach Listener thread\");\n+#endif\n+}\n+\n+PosixAttachOperation* PosixAttachListener::get_current_op() {\n+  assert_listener_thread();\n+  return PosixAttachListener::_current_op;\n+}\n+\n+void PosixAttachListener::reset_current_op() {\n+  assert_listener_thread();\n+  PosixAttachListener::_current_op = nullptr;\n+}\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":55,"deletions":102,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_ATTACHLISTENER_POSIX_HPP\n+#define OS_POSIX_ATTACHLISTENER_POSIX_HPP\n+\n+#include \"utilities\/macros.hpp\"\n+\n+#if INCLUDE_SERVICES\n+#ifndef AIX\n+\n+#include \"posixAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+\n+#include <sys\/un.h>\n+\n+#ifndef UNIX_PATH_MAX\n+#define UNIX_PATH_MAX   sizeof(sockaddr_un::sun_path)\n+#endif\n+\n+class PosixAttachListener: AllStatic {\n+ private:\n+  \/\/ the path to which we bind the UNIX domain socket\n+  static char _path[UNIX_PATH_MAX];\n+  static bool _has_path;\n+\n+  \/\/ the file descriptor for the listening socket\n+  static volatile int _listener;\n+\n+  static bool _atexit_registered;\n+\n+  \/\/ this is for proper reporting JDK.Chekpoint processing to jcmd peer\n+  static PosixAttachOperation* _current_op;\n+\n+ public:\n+  static void set_path(char* path) {\n+    if (path == nullptr) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n+  \/\/ initialize the listener, returns 0 if okay\n+  static int init();\n+\n+  static char* path()                   { return _path; }\n+  static bool has_path()                { return _has_path; }\n+  static int listener()                 { return _listener; }\n+\n+  static PosixAttachOperation* dequeue();\n+  static PosixAttachOperation* get_current_op();\n+  static void reset_current_op();\n+\n+};\n+\n+#endif \/\/ !AIX\n+\n+#endif \/\/ INCLUDE_SERVICES\n+\n+#endif \/\/ OS_POSIX_ATTACHLISTENER_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.hpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -87,0 +87,5 @@\n+#if defined(LINUX)\n+\/\/ The signal is blocked by default; this should not break SunMiscSignalTest\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,0 +68,3 @@\n+#if !defined(__APPLE__) && !defined(AIX)\n+#include \"runtime\/crac.hpp\"\n+#endif\n@@ -104,0 +107,1 @@\n+static jlong restore_time_count = 0;\n@@ -903,0 +907,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -925,0 +933,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1439,0 +1455,4 @@\n+  initialize_time_counters();\n+}\n+\n+void os::Posix::initialize_time_counters(void) {\n@@ -1440,0 +1460,5 @@\n+  restore_time_count = initial_time_count;\n+}\n+\n+void os::Posix::reset_time_counters(void) {\n+  restore_time_count = javaTimeNanos();\n@@ -1606,1 +1631,1 @@\n-  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec);\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + crac::monotonic_time_offset();\n@@ -1632,0 +1657,4 @@\n+jlong os::elapsed_counter_since_restore() {\n+  return os::javaTimeNanos() - restore_time_count;\n+}\n+\n@@ -2165,0 +2194,4 @@\n+int os::execv(const char *path, const char *argv[]) {\n+  return ::execv(path, (char * const *)argv);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  static void initialize_time_counters(void);\n+  static void reset_time_counters(void);\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -34,0 +35,1 @@\n+\/\/#include \"os_linux.inline.hpp\"\n@@ -47,0 +49,4 @@\n+#ifdef LINUX\n+#include \"perfMemory_linux.hpp\"\n+#endif \/\/LINUX\n+\n@@ -1328,0 +1334,83 @@\n+\n+#ifdef LINUX\n+bool PerfMemoryLinux::checkpoint() {\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  void *anon = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (anon == MAP_FAILED) {\n+    tty->print_cr(\"Cannot allocate new memory for perfdata: %s\", os::strerror(errno));\n+    return false;\n+  }\n+  \/\/ Note: we might be losing updates that happen between this copy and mremap\n+  \/\/ TODO: consider acquiring PeriodicTask_lock around this\n+  memcpy(anon, PerfMemory::start(), PerfMemory::used());\n+  if (mremap(anon, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap perfdata memory as anonymous: %s\", os::strerror(errno));\n+    if (munmap(anon, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap unused private perfdata memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  remove_file(backing_store_file_name);\n+  \/\/ We cannot keep the filename because some C\/R engines might not preserve PID numbers\n+  \/\/ Also, username might change.\n+  FREE_C_HEAP_ARRAY(char, backing_store_file_name);\n+  backing_store_file_name = nullptr;\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::restore() {\n+  assert(backing_store_file_name == nullptr, \"Should be nil'ed on checkpoint\");\n+  \/\/ With -XX:-UsePerfData the capacity is zero\n+  if (PerfDisableSharedMem || PerfMemory::capacity() == 0) {\n+    return true;\n+  }\n+  int vmid = os::current_process_id();\n+  char* user_name = get_user_name(geteuid());\n+  if (!user_name) {\n+    return false;\n+  }\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  if (!make_user_tmp_dir(dirname)) {\n+    return false;\n+  }\n+  backing_store_file_name = get_sharedmem_filename(dirname, vmid, -1);\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"Cannot open shared perfdata file: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  if (::ftruncate(fd, PerfMemory::capacity())) {\n+    tty->print_cr(\"Cannot restore (ftruncate) perfdata file size: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  void* shared = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == shared) {\n+    tty->print_cr(\"cannot mmap shared perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+  ::close(fd);\n+\n+  \/\/ Here is another place where we might lose the update\n+  memcpy(shared, PerfMemory::start(), PerfMemory::used());\n+  if (::mremap(shared, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap shared perfdata: %s\", os::strerror(errno));\n+    if (munmap(shared, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap the shared memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  return true;\n+}\n+#endif \/\/LINUX\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n@@ -1217,1 +1217,1 @@\n-      const pid_t me = getpid();\n+      const pid_t me = os::current_process_id();\n@@ -1594,0 +1594,15 @@\n+\n+  sigemptyset(&blocked_sigs);\n+\/\/ RESTORE_SIGNAL is used only on Linux, other platform don't send this\n+#ifdef LINUX\n+  \/\/ The signal is used with default crexec library, other CRaCEngines might use\n+  \/\/ signals in a different way and having this signal blocked could interfere.\n+  const char *signal_engines[] = { \"criu\", \"criuengine\", \"sim\", \"simengine\", \"pause\", \"pauseengine\", nullptr };\n+  for (int i = 0; signal_engines[i] != nullptr; ++i) {\n+    if (strcmp(CRaCEngine, signal_engines[i]) == 0) {\n+      sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+      break;\n+    }\n+  }\n+#endif\n+\n@@ -1604,0 +1619,5 @@\n+static sigset_t* blocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &blocked_sigs;\n+}\n+\n@@ -1621,0 +1641,1 @@\n+  pthread_sigmask(SIG_BLOCK, blocked_signals(), nullptr);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvm.h\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+void crac::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  return true;\n+}\n+\n+void crac::reset_time_counters() {\n+  os::win32::reset_performance_counters();\n+}\n+\n+bool crac::random_bytes(u1 *dest, size_t length) {\n+  \/\/ Dummy implementation\n+  unsigned int seed = static_cast<unsigned int>(os::javaTimeNanos());\n+  for (size_t i = 0; i < length; i += sizeof(int)) {\n+    int value = os::next_random(seed);\n+    seed = value;\n+    size_t to_copy = length - i;\n+    if (to_copy > sizeof(value)) {\n+      to_copy = sizeof(value);\n+    }\n+    ::memcpy(dest + i, &value, to_copy);\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/windows\/crac_windows.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -825,0 +825,1 @@\n+static jlong restore_performance_count;\n@@ -832,1 +833,0 @@\n-\n@@ -837,0 +837,5 @@\n+jlong os::elapsed_counter_since_restore() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceCounter(&count);\n+  return count.QuadPart - restore_performance_count;\n+}\n@@ -1126,0 +1131,1 @@\n+  restore_performance_count = initial_performance_count;\n@@ -1128,0 +1134,9 @@\n+void os::win32::reset_performance_counters() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceFrequency(&count);\n+  \/\/ Until we perform a real C\/R on Windows this is safe, performance frequency\n+  \/\/ should be the same. With real C\/R the counters will be probably incomparable.\n+  assert(performance_frequency == count.QuadPart, \"Performance frequency changed\");\n+  QueryPerformanceCounter(&count);\n+  restore_performance_count = count.QuadPart;\n+}\n@@ -1584,0 +1599,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -3928,0 +3970,3 @@\n+void os::reset_cached_process_id() {\n+}\n+\n@@ -4770,0 +4815,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == nullptr) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == nullptr) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5815,0 +5885,4 @@\n+int os::execv(const char *path, const char *argv[]) {\n+  return _execv(path, argv);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":75,"deletions":1,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+  static void   initialize_performance_counter();\n+  static void   reset_performance_counters();\n@@ -114,1 +116,0 @@\n-  static void initialize_performance_counter();\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -810,1 +810,1 @@\n-    if (nm->make_not_entrant(nmethod::InvalidationReason::C1_DEOPTIMIZE)) {\n+    if (nm->make_not_entrant(nmethod::InvalidationReason::C1_DEOPTIMIZE, true \/* OK to recompile *\/)) {\n@@ -1102,1 +1102,1 @@\n-      nm->make_not_entrant(nmethod::InvalidationReason::C1_CODEPATCH);\n+      nm->make_not_entrant(nmethod::InvalidationReason::C1_CODEPATCH, true \/* OK to recompile *\/);\n@@ -1350,1 +1350,1 @@\n-      nm->make_not_entrant(nmethod::InvalidationReason::C1_DEOPTIMIZE_FOR_PATCHING);\n+      nm->make_not_entrant(nmethod::InvalidationReason::C1_DEOPTIMIZE_FOR_PATCHING, true \/* OK to recompile *\/);\n@@ -1478,1 +1478,1 @@\n-  nm->make_not_entrant(nmethod::InvalidationReason::C1_PREDICATE_FAILED_TRAP);\n+  nm->make_not_entrant(nmethod::InvalidationReason::C1_PREDICATE_FAILED_TRAP, true \/* OK to recompile *\/);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -805,1 +805,1 @@\n-      nm->make_not_entrant(nmethod::InvalidationReason::CI_REPLAY);\n+      nm->make_not_entrant(nmethod::InvalidationReason::CI_REPLAY, false \/* recompiling by ourselves *\/);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,0 +760,28 @@\n+GrowableArray<int> ClassLoader::get_classpath_entry_fds() {\n+  GrowableArray<int> fds;\n+  assert(Thread::current()->is_VM_thread(), \"should be called from VM op\");\n+  \/\/ we don't use mutexes here because it is called from VM op\n+  for (ClassPathEntry *entry = first_append_entry(); entry != nullptr; entry = entry->next()) {\n+    if (entry->is_jar_file()) {\n+      fds.append(((ClassPathZipEntry *) entry)->get_fd());\n+    }\n+  }\n+  return fds;\n+}\n+\n+GrowableArray<int> ClassLoader::get_patch_module_entry_fds() {\n+  GrowableArray<int> fds;\n+  if (_patch_mod_entries == nullptr) {\n+    return fds;\n+  }\n+  for (int i = 0; i < _patch_mod_entries->length(); i++) {\n+    ModuleClassPathList* module_cpl = _patch_mod_entries->at(i);\n+    for (ClassPathEntry* entry = module_cpl->module_first_entry(); entry != nullptr; entry = entry->next()) {\n+      if (entry->is_jar_file()) {\n+        fds.append(((ClassPathZipEntry*)entry)->get_fd());\n+      }\n+    }\n+  }\n+  return fds;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+  int get_fd() const { return ZipLibrary::get_fd(_zip); }\n@@ -376,0 +377,6 @@\n+  \/\/ returns list of file descriptors used for both boot and app classpath entries\n+  static GrowableArray<int> get_classpath_entry_fds();\n+\n+  \/\/ returns list of file descriptors used for patch module entries\n+  static GrowableArray<int> get_patch_module_entry_fds();\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -746,0 +746,4 @@\n+  template(jdk_internal_crac_mirror_Core,          \"jdk\/internal\/crac\/mirror\/Core\")                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+  template(checkpointRestoreInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1359,1 +1359,1 @@\n-      nm->make_not_entrant(nmethod::InvalidationReason::MARKED_FOR_DEOPTIMIZATION);\n+      nm->make_not_entrant(nmethod::InvalidationReason::MARKED_FOR_DEOPTIMIZATION, true \/* OK to recompile *\/);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -1594,1 +1595,1 @@\n-      make_not_entrant(InvalidationReason::RELOCATED);\n+      make_not_entrant(InvalidationReason::RELOCATED, false \/* copy is now in use *\/);\n@@ -2290,1 +2291,1 @@\n-bool nmethod::make_not_entrant(InvalidationReason invalidation_reason) {\n+bool nmethod::make_not_entrant(InvalidationReason invalidation_reason, bool can_schedule_recompilation) {\n@@ -2370,0 +2371,4 @@\n+  if (can_schedule_recompilation) {\n+    CRaCRecompiler::record_decompilation(*this);\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -726,2 +726,7 @@\n-  bool  make_not_entrant(InvalidationReason invalidation_reason);\n-  bool  make_not_used() { return make_not_entrant(InvalidationReason::NOT_USED); }\n+  \/\/\n+  \/\/ can_schedule_recompilation should be true if the decompilation\n+  \/\/ is triggered by an application state change and it makes sense\n+  \/\/ to request recompilation of the method as soon as the state\n+  \/\/ becomes stable again.\n+  bool  make_not_entrant(InvalidationReason invalidation_reason, bool can_schedule_recompilation);\n+  bool  make_not_used() { return make_not_entrant(InvalidationReason::NOT_USED, false \/* likely already recompiling *\/); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -939,1 +939,1 @@\n-        osr_nm->make_not_entrant(nmethod::InvalidationReason::OSR_INVALIDATION_FOR_COMPILING_WITH_C1);\n+        osr_nm->make_not_entrant(nmethod::InvalidationReason::OSR_INVALIDATION_FOR_COMPILING_WITH_C1, false \/* recompiling by ourselves *\/);\n@@ -1543,1 +1543,1 @@\n-            nm->make_not_entrant(nmethod::InvalidationReason::OSR_INVALIDATION_BACK_BRANCH);\n+            nm->make_not_entrant(nmethod::InvalidationReason::OSR_INVALIDATION_BACK_BRANCH, false \/* recompiling by ourselves *\/);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -1268,0 +1269,9 @@\n+    \/\/ Ensure the method has not gotten compiled on a better level since CRaC\n+    \/\/ recorded its decompilation. We do it this late to ensure there is no race\n+    \/\/ between the recompilation requesting thread and other threads requesting\n+    \/\/ compilation through the usual routes.\n+    if (compile_reason == CompileTask::Reason_CRaC &&\n+        !CRaCRecompiler::is_recompilation_relevant(method, osr_bci, comp_level)) {\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -198,0 +199,20 @@\n+void CompileLog::before_checkpoint() {\n+  \/\/ Remove only output stream, don't destroy the CompileLog itself.\n+  delete _out;\n+  _out = nullptr;\n+  unlink(_file); \/\/ like in CompileLog dtor\n+  \/\/ _file_end: do not touch, mark_file_end calculates it based on the actual file size.\n+}\n+\n+void CompileLog::after_restore() {\n+  FILE* fp = os::fopen(_file, \"wt\");\n+  _out = new(mtCompiler) fileStream(fp, true);\n+}\n+\n+void CompileLog::swap_streams_on_restore() {\n+  assert_at_safepoint();\n+  for (CompileLog* log = _list_head; log != nullptr; log = log->_next) {\n+    log->after_restore();\n+  }\n+}\n+\n@@ -311,0 +332,38 @@\n+void CompileLog::finish_log_on_checkpoint(outputStream* file) {\n+  assert_at_safepoint(); \/\/ Ensures no concurrent modifications of log list\n+  char buf[4 * K];\n+  int buflen = sizeof(buf);\n+  file->print_raw(\"<compilation_log closed at a checkpoint >\");\n+  for (CompileLog* log = _list_head; log != nullptr; log = log->_next) {\n+    log->flush();\n+    const char* partial_file = log->file();\n+    int partial_fd = open(partial_file, O_RDONLY);\n+    if (partial_fd != -1) {\n+      \/\/ print\/print_cr may need to allocate large stack buffer to format\n+      \/\/ strings, here we use snprintf() and print_raw() instead.\n+      file->print_raw(\"<compilation_log thread='\");\n+      jio_snprintf(buf, buflen, \"%zu\", log->thread_id());\n+      file->print_raw(buf);\n+      file->print_raw_cr(\"'>\");\n+\n+      size_t nr; \/\/ number read into buf from partial log\n+      \/\/ In case of unsuccessful completion, read returns -1.\n+      ssize_t bytes_read;\n+      \/\/ Copy data up to the end of the last <event> element:\n+      julong to_read = log->_file_end;\n+      while (to_read > 0) {\n+        if (to_read < (julong)buflen)\n+              nr = (size_t)to_read;\n+        else  nr = buflen;\n+        bytes_read = ::read(partial_fd, buf, (int)nr);\n+        if (bytes_read <= 0) break;\n+        nr = bytes_read;\n+        to_read -= (julong)nr;\n+        file->write(buf, nr);\n+      }\n+      ::close(partial_fd);\n+    }\n+    log->before_checkpoint();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compileLog.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -85,0 +85,4 @@\n+  \/\/CRaC purposes\n+  void after_restore();\n+  void before_checkpoint();\n+\n@@ -98,0 +102,2 @@\n+  static void finish_log_on_checkpoint(outputStream* out);\n+  static void swap_streams_on_restore();\n","filename":"src\/hotspot\/share\/compiler\/compileLog.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+      Reason_CRaC,             \/\/ CRaC-initiated recompilation\n@@ -79,1 +80,2 @@\n-      \"bootstrap\"\n+      \"bootstrap\",\n+      \"crac\"\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2026, Azul Systems, Inc. All rights reserved.\n@@ -850,0 +851,3 @@\n+  if (should_cleanup_unused()) {\n+    cleanup_unused_regions();\n+  }\n@@ -947,0 +951,19 @@\n+\/\/ The implementation of this should likely be OS-dependent. The current one is verified to have\n+\/\/ the desired effect on Linux, should probably also be on BSD. On others this may mostly be a\n+\/\/ useless work.\n+void G1CollectedHeap::cleanup_unused_regions() {\n+  assert_at_safepoint_on_vm_thread();\n+\n+  log_debug(gc, heap)(\"Cleanup unused regions\");\n+  const size_t orig_capacity = capacity();\n+\n+  \/\/ Uncommit all free regions\n+  precond(orig_capacity >= G1HeapRegion::GrainBytes);\n+  shrink(orig_capacity - G1HeapRegion::GrainBytes \/* leave one region to pass G1HeapRegionManager's asserts *\/);\n+  uncommit_regions(UINT_MAX);\n+  assert(capacity() <= orig_capacity, \"unexpectedly gained capacity: %zu -> %zu\", orig_capacity, capacity());\n+\n+  \/\/ Commit them back\n+  expand(orig_capacity - capacity(), _workers);\n+  assert(capacity() >= orig_capacity, \"unexpectedly lost capacity: %zu -> %zu\", orig_capacity, capacity());\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"gc\/g1\/g1UncommitRegionTask.hpp\"\n@@ -608,0 +609,4 @@\n+  \/\/ Clear all free regions.\n+  \/\/ The aim is to have free regions committed but not be actually physically reserved on OS-level.\n+  void cleanup_unused_regions();\n+\n@@ -1361,0 +1366,4 @@\n+\n+  void after_restore(void) override {\n+    _hrm.after_restore();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,1 +70,3 @@\n-  _regions(), _heap_mapper(nullptr),\n+  _regions(),\n+  _max_available_regions(0),\n+  _heap_mapper(nullptr),\n@@ -91,0 +93,2 @@\n+  _max_available_regions = (uint) (FLAG_IS_DEFAULT(CRaCMaxHeapSizeBeforeCheckpoint) ? _regions.length() :\n+    CRaCMaxHeapSizeBeforeCheckpoint \/ G1HeapRegion::GrainBytes);\n@@ -95,0 +99,4 @@\n+void G1HeapRegionManager::after_restore() {\n+  _max_available_regions = (uint) _regions.length();\n+}\n+\n@@ -136,1 +144,3 @@\n-  expand_exact(candidate, num_regions, G1CollectedHeap::heap()->workers());\n+  if (!expand_exact(candidate, num_regions, G1CollectedHeap::heap()->workers())) {\n+    return nullptr;\n+  }\n@@ -167,0 +177,4 @@\n+  assert(_committed_map.num_active() + _committed_map.num_inactive() + num_regions <= _max_available_regions,\n+    \"Expanding over the limit: %d active, %d inactive, %d requested, limit %d\",\n+    _committed_map.num_active(), _committed_map.num_inactive(), num_regions, _max_available_regions);\n+\n@@ -351,2 +365,5 @@\n-    uint to_expand = MIN2(num_regions - expanded, regions.length());\n-    expand(regions.start(), to_expand, pretouch_workers);\n+    uint to_expand = MIN3(num_regions - expanded, regions.length(),\n+      _max_available_regions - _committed_map.num_active() - _committed_map.num_inactive());\n+    if (to_expand > 0) {\n+      expand(regions.start(), to_expand, pretouch_workers);\n+    }\n@@ -376,1 +393,1 @@\n-void G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n+bool G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -395,0 +412,6 @@\n+      \/\/ Fail if we're over the limits (were not able to just reactivate)\n+      if (_committed_map.num_active() + _committed_map.num_inactive() + (i - start) + 1 > _max_available_regions) {\n+        log_debug(gc)(\"Cannot expand to regions %u - %u: active %u, inactive %u, max %u\", start, end,\n+         _committed_map.num_active(),  _committed_map.num_inactive(), _max_available_regions);\n+        return false;\n+      }\n@@ -402,0 +425,1 @@\n+  return true;\n@@ -408,4 +432,12 @@\n-    for (uint i = 0; i < max_num_regions(); i++) {\n-      if (is_available(i)) {\n-        \/\/ Already in use continue\n-        continue;\n+    if (_committed_map.num_active() + _committed_map.num_inactive() >= _max_available_regions) {\n+      \/\/ We have to use existing inactive region, cannot allocate new one\n+      \/\/ while we have inactive.\n+      for (uint i = 0; i < max_num_regions(); i++) {\n+        if (!_committed_map.inactive(i)) {\n+          continue;\n+        }\n+        expand_candidate = i;\n+        if (is_on_preferred_index(expand_candidate, preferred_index)) {\n+          \/\/ We have found a candidate on the preferred node, break.\n+          break;\n+        }\n@@ -413,5 +445,13 @@\n-      \/\/ Always save the candidate so we can expand later on.\n-      expand_candidate = i;\n-      if (is_on_preferred_index(expand_candidate, preferred_index)) {\n-        \/\/ We have found a candidate on the preferred node, break.\n-        break;\n+    }\n+    if (expand_candidate == UINT_MAX) {\n+      for (uint i = 0; i < max_num_regions(); i++) {\n+        if (is_available(i)) {\n+          \/\/ Already in use continue\n+          continue;\n+        }\n+        \/\/ Always save the candidate so we can expand later on.\n+        expand_candidate = i;\n+        if (is_on_preferred_index(expand_candidate, preferred_index)) {\n+          \/\/ We have found a candidate on the preferred node, break.\n+          break;\n+        }\n@@ -424,0 +464,1 @@\n+    log_debug(gc)(\"No regions left\");\n@@ -426,0 +467,1 @@\n+  log_debug(gc)(\"Candidate is %u\", expand_candidate);\n@@ -427,2 +469,1 @@\n-  expand_exact(expand_candidate, 1, nullptr);\n-  return 1;\n+  return expand_exact(expand_candidate, 1, nullptr) ? 1 : 0;\n@@ -546,1 +587,3 @@\n-      expand_exact(curr_index, 1, pretouch_workers);\n+      if (!expand_exact(curr_index, 1, pretouch_workers)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+  uint _max_available_regions;\n@@ -148,1 +149,1 @@\n-  void expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers);\n+  bool expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers);\n@@ -236,1 +237,1 @@\n-  uint num_inactive_regions() const { return max_num_regions() - num_committed_regions(); }\n+  uint num_inactive_regions() const { return _max_available_regions - num_committed_regions(); }\n@@ -290,0 +291,2 @@\n+\n+  void after_restore(void);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -931,0 +931,7 @@\n+\n+  if (should_cleanup_unused()) {\n+    os::cleanup_memory((char*)_young_gen->eden_space()->top(), _young_gen->eden_space()->free_in_bytes());\n+    os::cleanup_memory((char*)_young_gen->from_space()->top(), _young_gen->from_space()->free_in_bytes());\n+    os::cleanup_memory((char*)_young_gen->to_space()->top(), _young_gen->to_space()->free_in_bytes());\n+    os::cleanup_memory((char*)_old_gen->object_space()->top(), _old_gen->object_space()->free_in_bytes());\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -467,0 +468,6 @@\n+  if (Universe::heap()->should_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), eden()->free());\n+    os::cleanup_memory((char*)from()->top(), from()->free());\n+    os::cleanup_memory((char*)to()->top(), to()->free());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -281,0 +281,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+  bool _cleanup_unused;\n+\n@@ -380,0 +382,3 @@\n+  void set_cleanup_unused(bool value) { _cleanup_unused = value; }\n+  bool should_cleanup_unused() const { return _cleanup_unused; }\n+\n@@ -513,0 +518,2 @@\n+\n+  virtual void after_restore(void) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+  assert(FLAG_IS_DEFAULT(CRaCMaxHeapSizeBeforeCheckpoint) || CRaCMaxHeapSizeBeforeCheckpoint >= InitialHeapSize, \"Incompatible initial and maximum heap size before checkpoint\");\n+  assert(FLAG_IS_DEFAULT(CRaCMaxHeapSizeBeforeCheckpoint) || CRaCMaxHeapSizeBeforeCheckpoint <= MaxHeapSize, \"Incompatible initial and maximum heap size before checkpoint\");\n@@ -149,0 +151,20 @@\n+  if (FLAG_IS_CMDLINE(CRaCMaxHeapSizeBeforeCheckpoint)) {\n+    if (!UseG1GC) {\n+      vm_exit_during_initialization(\"CRaCMaxHeapSizeBeforeCheckpoint can be used only with G1 garbage collector.\");\n+    }\n+    if (CRaCMaxHeapSizeBeforeCheckpoint < InitialHeapSize) {\n+      if (FLAG_IS_CMDLINE(InitialHeapSize)) {\n+        vm_exit_during_initialization(\"Incompatible initial heap and maximum before checkpoint sizes specified\");\n+      } else {\n+        FLAG_SET_ERGO(InitialHeapSize, CRaCMaxHeapSizeBeforeCheckpoint);\n+      }\n+    }\n+    if (CRaCMaxHeapSizeBeforeCheckpoint > MaxHeapSize) {\n+      if (FLAG_IS_CMDLINE(MaxHeapSize)) {\n+        vm_exit_during_initialization(\"Incompatible heap sizes - maximum before checkpoint and absolute maximum - specified\");\n+      } else {\n+        FLAG_SET_ERGO(MaxHeapSize, CRaCMaxHeapSizeBeforeCheckpoint);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1072,0 +1072,4 @@\n+\n+  if (Universe::heap()->should_cleanup_unused()) {\n+    _page_allocator->uncommit_unused_memory();\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2454,0 +2454,8 @@\n+\n+void ZPageAllocator::uncommit_unused_memory() {\n+  ZPartitionIterator iter = partition_iterator();\n+  for (ZPartition* partition; iter.next(&partition);) {\n+    partition->_cache.reset_min_size_watermark();\n+    partition->_uncommitter.force_uncommit();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -285,0 +285,2 @@\n+  void uncommit_unused_memory();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,2 @@\n-    _uncommitted(0) {\n+    _uncommitted(0),\n+    _force_uncommit(false) {\n@@ -64,1 +65,1 @@\n-  if (!_stop && timeout > 0) {\n+  if (!_stop && timeout > 0 && !_force_uncommit) {\n@@ -85,1 +86,1 @@\n-    } while (!_stop && now < wait_until);\n+    } while (!_stop && now < wait_until && !_force_uncommit);\n@@ -201,0 +202,4 @@\n+  if (uncommit_cycle_is_finished()) {\n+    finish_force_uncommit();\n+  }\n+\n@@ -426,0 +431,20 @@\n+\n+void ZUncommitter::force_uncommit() {\n+  if (ZUncommit) {\n+    ZLocker<ZConditionLock> locker(&_lock);\n+    _force_uncommit = true;\n+    _lock.notify_all();\n+\n+    while (_force_uncommit && !_stop) {\n+      _lock.wait();\n+    }\n+  }\n+}\n+\n+void ZUncommitter::finish_force_uncommit() {\n+  ZLocker<ZConditionLock> locker(&_lock);\n+  if (_force_uncommit) {\n+    _force_uncommit = false;\n+    _lock.notify_all();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zUncommitter.cpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  JMM_JVM_RESTORE_START_TIME_MS      = 13,   \/* Time when the JVM started restore operation *\/\n+  JMM_JVM_UPTIME_SINCE_RESTORE_MS    = 14,   \/* The JVM uptime since restore *\/\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1168,0 +1168,27 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n+\n+JNIEXPORT void JNICALL\n+JVM_StartRecordingDecompilations(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL\n+JVM_FinishRecordingDecompilationsAndRecompile(JNIEnv *env);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_IsCRaCScoreSupported(JNIEnv *env);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_RecordCRaCScore(JNIEnv *env, jobjectArray metrics, jdoubleArray values);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jfr\/jni\/jfrUpcalls.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"jfr\/periodic\/jfrOSInterface.hpp\"\n@@ -42,0 +44,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -44,0 +47,1 @@\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -46,0 +50,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -178,0 +183,26 @@\n+void Jfr::before_checkpoint() {\n+  JfrOSInterface::before_checkpoint();\n+}\n+\n+void Jfr::after_restore() {\n+  const char *jfr_flag = \"StartFlightRecording\";\n+  JVMFlag *flag = JVMFlag::find_flag(jfr_flag);\n+  if (flag->get_origin() == JVMFlagOrigin::CRAC_RESTORE) {\n+    \/\/ -XX:StartFlightRecording passed on restore\n+    assert(JfrOptionSet::start_flight_recording_options() == nullptr, \"should have been released\");\n+    size_t buf_len = 4 + strlen(jfr_flag) + 1 + strlen(flag->get_ccstr()) + 1;\n+    ResourceMark rm;\n+    char *buf = NEW_RESOURCE_ARRAY(char, buf_len);\n+    os::snprintf_checked(buf, buf_len, \"-XX:%s=%s\", jfr_flag, flag->get_ccstr());\n+    JavaVMOption option;\n+    option.optionString = buf;\n+    option.extraInfo = nullptr;\n+    const JavaVMOption *option_ptr = &option;\n+    JfrOptionSet::parse_start_flight_recording_option(&option_ptr, buf + 4 + strlen(jfr_flag));\n+    \/\/ We cannot invoke this directly now as DCmdStart command would be blocked\n+    \/\/ trying to register new file descriptors. Instead we just record a request and\n+    \/\/ the recording will be started at the right moment from JDKResource.\n+    JfrUpcalls::request_start_after_restore();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+  static void before_checkpoint();\n+  static void after_restore();\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,0 +450,4 @@\n+JVM_ENTRY_NO_ENV(void, jfr_start_after_restore(JNIEnv* env, jclass jvm))\n+  return JfrRecorder::start_after_restore();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -174,0 +174,2 @@\n+void JNICALL jfr_start_after_restore(JNIEnv* env, jclass jvm);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+      (char*)\"startFlightRecorderAfterRestore\", (char*)\"()V\", (void*)jfr_start_after_restore,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+static Symbol* request_start_after_restore_sym = nullptr;\n+static Symbol* request_start_after_restore_sig_sym = nullptr;\n@@ -72,0 +74,2 @@\n+    request_start_after_restore_sym = SymbolTable::new_permanent_symbol(\"requestStartAfterRestore\");\n+    request_start_after_restore_sig_sym = SymbolTable::new_permanent_symbol(\"()V\");\n@@ -225,0 +229,26 @@\n+void JfrUpcalls::request_start_after_restore() {\n+  JavaThread * const THREAD = JavaThread::current();\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  if (!initialize(THREAD)) {\n+    log_error(jfr, system)(\"JfrUpcall could not be initialized.\");\n+    return;\n+  }\n+  JavaValue result(T_VOID);\n+  const Klass* klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    ResourceMark rm(THREAD);\n+    log_error(jfr, system)(\"JfrUpcall cannot resolve class %s, flight recording won't be started\",\n+      jvm_upcalls_class_sym->as_C_string());\n+    return;\n+  }\n+  assert(klass != nullptr, \"invariant\");\n+  JfrJavaArguments args(&result, klass, request_start_after_restore_sym, request_start_after_restore_sig_sym);\n+  JfrJavaSupport::call_static(&args, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    ResourceMark rm(THREAD);\n+    log_error(jfr, system)(\"JfrUpcall failed for %s\", request_start_after_restore_sym->as_C_string());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -86,0 +86,8 @@\n+\n+  void before_checkpoint() {\n+    \/\/ SystemProcessInterface::SystemProcesses::ProcessIterator has an open FD\n+    \/\/ to \/proc directory - we need to close this before checkpoint.\n+    \/\/ _system_process_interfaces will be re-created on demand\n+    delete _system_process_interface;\n+    _system_process_interface = nullptr;\n+  }\n@@ -309,0 +317,6 @@\n+\n+void JfrOSInterface::before_checkpoint() {\n+  if (_instance != nullptr && _instance->_impl != nullptr) {\n+    return _instance->_impl->before_checkpoint();\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrOSInterface.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    case JVMFlagOrigin::CRAC_RESTORE: return \"CRaC restore\";\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -498,0 +498,7 @@\n+\n+void JfrRecorder::start_after_restore() {\n+  JavaThread* const THREAD = JavaThread::current();\n+  validate_recording_options(THREAD);\n+  launch_command_line_recordings(THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"pending exception\");\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+\n+  static void start_after_restore();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1394,1 +1394,1 @@\n-    code->make_not_entrant(nmethod::InvalidationReason::JVMCI_REPROFILE);\n+    code->make_not_entrant(nmethod::InvalidationReason::JVMCI_REPROFILE, false \/* trust the compiler, ideally should be a parameter *\/);\n@@ -1839,1 +1839,2 @@\n-    fst.current()->cb()->as_nmethod()->make_not_entrant(nmethod::InvalidationReason::JVMCI_MATERIALIZE_VIRTUAL_OBJECT);\n+    fst.current()->cb()->as_nmethod()->make_not_entrant(nmethod::InvalidationReason::JVMCI_MATERIALIZE_VIRTUAL_OBJECT,\n+                                                        false \/* likely not caused by app state change *\/);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1776,1 +1776,1 @@\n-    nm->make_not_entrant(invalidation_reason);\n+    nm->make_not_entrant(invalidation_reason, false \/* trust the compiler, ideally should be a parameter *\/);\n@@ -1785,1 +1785,1 @@\n-    nm->make_not_entrant(invalidation_reason);\n+    nm->make_not_entrant(invalidation_reason, false \/* trust the compiler, ideally should be a parameter *\/);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2191,1 +2191,1 @@\n-              old->make_not_entrant(nmethod::InvalidationReason::JVMCI_REPLACED_WITH_NEW_CODE);\n+              old->make_not_entrant(nmethod::InvalidationReason::JVMCI_REPLACED_WITH_NEW_CODE, false \/* already being replaced *\/);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+  _block_async(),\n@@ -295,0 +296,3 @@\n+    _block_async.lock();\n+    _block_async.unlock();\n+\n@@ -357,0 +361,9 @@\n+\n+void AsyncLogWriter::stop() {\n+  _block_async.lock();\n+  flush();\n+}\n+\n+void AsyncLogWriter::resume() {\n+  _block_async.unlock();\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -170,0 +170,2 @@\n+  \/\/ for asynchronous thread run()\n+  PlatformMonitor _block_async;\n@@ -211,0 +213,2 @@\n+  void stop();\n+  void resume();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,0 +155,5 @@\n+\n+  \/\/ Is this file descriptor in use?\n+  static bool is_fd_used(int fd);\n+  static void close();\n+  static void reopen();\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,3 +57,3 @@\n-  virtual bool set_option(const char* key, const char* value, outputStream* errstream);\n-  virtual int write(const LogDecorations& decorations, const char* msg);\n-  virtual int write(LogMessageBuffer::Iterator msg_iterator);\n+  virtual bool set_option(const char* key, const char* value, outputStream* errstream) override;\n+  virtual int write(const LogDecorations& decorations, const char* msg) override;\n+  virtual int write(LogMessageBuffer::Iterator msg_iterator) override;\n@@ -62,1 +62,2 @@\n-  virtual void describe(outputStream* out);\n+  virtual void describe(outputStream* out) override;\n+  virtual int fd_get() const override { return fileno(_stream); }\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  LOG_TAG(crac) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3557,1 +3557,1 @@\n-      inv->make_not_entrant(nmethod::InvalidationReason::OSR_INVALIDATION_OF_LOWER_LEVEL);\n+      inv->make_not_entrant(nmethod::InvalidationReason::OSR_INVALIDATION_OF_LOWER_LEVEL, false \/* already being replaced *\/);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1044,1 +1044,1 @@\n-    nm->make_not_entrant(nmethod::InvalidationReason::SET_NATIVE_FUNCTION);\n+    nm->make_not_entrant(nmethod::InvalidationReason::SET_NATIVE_FUNCTION, false \/* replaced by native function *\/);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -3667,0 +3669,21 @@\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_StartRecordingDecompilations(JNIEnv *env))\n+  CRaCRecompiler::start_recording_decompilations();\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_FinishRecordingDecompilationsAndRecompile(JNIEnv *env))\n+  CRaCRecompiler::finish_recording_decompilations_and_recompile();\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsCRaCScoreSupported(JNIEnv *env))\n+  return crac::is_image_score_supported();\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_RecordCRaCScore(JNIEnv *env, jobjectArray metrics, jdoubleArray values))\n+  return crac::record_image_score(metrics, values);\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -847,0 +847,8 @@\n+    case EXT_EVENT_CRAC_BEFORE_CHECKPOINT :\n+      ext_callbacks->CracBeforeCheckpoint = callback;\n+      env->env_event_enable()->set_user_enabled(event_type, enabling);\n+      break;\n+    case EXT_EVENT_CRAC_AFTER_RESTORE :\n+      ext_callbacks->CracAfterRestore = callback;\n+      env->env_event_enable()->set_user_enabled(event_type, enabling);\n+      break;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+  EXT_EVENT_CRAC_AFTER_RESTORE = JVMTI_MIN_EVENT_TYPE_VAL-5,\n+  EXT_EVENT_CRAC_BEFORE_CHECKPOINT = JVMTI_MIN_EVENT_TYPE_VAL-4,\n@@ -50,1 +52,1 @@\n-  EXT_MIN_EVENT_TYPE_VAL = EXT_EVENT_VIRTUAL_THREAD_UNMOUNT,\n+  EXT_MIN_EVENT_TYPE_VAL = EXT_EVENT_CRAC_AFTER_RESTORE,\n@@ -58,0 +60,2 @@\n+  jvmtiExtensionEvent CracBeforeCheckpoint;\n+  jvmtiExtensionEvent CracAfterRestore;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3266,0 +3266,36 @@\n+\n+void JvmtiExport::post_crac_before_checkpoint() {\n+  JavaThread *thread = JavaThread::current();\n+  HandleMark hm(thread);\n+  EVT_TRIG_TRACE(EXT_EVENT_CRAC_BEFORE_CHECKPOINT, (\"Trg CRaC Before Checkpoint event triggered\"));\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n+    if (env->is_enabled((jvmtiEvent)EXT_EVENT_CRAC_BEFORE_CHECKPOINT)) {\n+      EVT_TRACE(EXT_EVENT_CRAC_BEFORE_CHECKPOINT, (\"[?] Evt Before Checkpoint sent\"));\n+      JvmtiEventMark jem(thread);\n+      JvmtiJavaThreadEventTransition jet(thread);\n+      jvmtiExtensionEvent callback = env->ext_callbacks()->CracBeforeCheckpoint;\n+      if (callback != nullptr) {\n+        (*callback)(env->jvmti_external());\n+      }\n+    }\n+  }\n+}\n+\n+void JvmtiExport::post_crac_after_restore() {\n+  JavaThread *thread = JavaThread::current();\n+  HandleMark hm(thread);\n+  EVT_TRIG_TRACE(EXT_EVENT_CRAC_AFTER_RESTORE, (\"Trg CRaC After Restore event triggered\"));\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n+    if (env->is_enabled((jvmtiEvent)EXT_EVENT_CRAC_AFTER_RESTORE)) {\n+      EVT_TRACE(EXT_EVENT_CRAC_AFTER_RESTORE, (\"[?] Evt After Restore sent\"));\n+      JvmtiEventMark jem(thread);\n+      JvmtiJavaThreadEventTransition jet(thread);\n+      jvmtiExtensionEvent callback = env->ext_callbacks()->CracAfterRestore;\n+      if (callback != nullptr) {\n+        (*callback)(env->jvmti_external());\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -367,0 +367,3 @@\n+  static void post_crac_before_checkpoint() NOT_JVMTI_RETURN;\n+  static void post_crac_after_restore() NOT_JVMTI_RETURN;\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -242,0 +242,6 @@\n+  static jvmtiParamInfo crac_before_checkpoint_params[] = {\n+    { (char*)\"JNI Environment\", JVMTI_KIND_IN_PTR, JVMTI_TYPE_JNIENV, JNI_FALSE }\n+  };\n+  static jvmtiParamInfo crac_after_restore_params[] = {\n+    { (char*)\"JNI Environment\", JVMTI_KIND_IN_PTR, JVMTI_TYPE_JNIENV, JNI_FALSE }\n+  };\n@@ -264,0 +270,14 @@\n+  static jvmtiExtensionEventInfo crac_before_checkpoint_ext_event = {\n+    EXT_EVENT_CRAC_BEFORE_CHECKPOINT,\n+    (char*)\"jdk.crac.events.BeforeCheckpoint\",\n+    (char*)\"CRAC_BEFORE_CHECKPOINT event\",\n+    sizeof(crac_before_checkpoint_params)\/sizeof(crac_before_checkpoint_params[0]),\n+    crac_before_checkpoint_params\n+  };\n+  static jvmtiExtensionEventInfo crac_after_restore_ext_event = {\n+    EXT_EVENT_CRAC_AFTER_RESTORE,\n+    (char*)\"jdk.crac.events.AfterRestore\",\n+    (char*)\"CRAC_AFTER_RESTORE event\",\n+    sizeof(crac_after_restore_params)\/sizeof(crac_after_restore_params[0]),\n+    crac_after_restore_params\n+  };\n@@ -268,0 +288,2 @@\n+  _ext_events->append(&crac_before_checkpoint_ext_event);\n+  _ext_events->append(&crac_after_restore_ext_event);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -799,1 +799,1 @@\n-                nm->make_not_entrant(nmethod::InvalidationReason::WHITEBOX_DEOPTIMIZATION);\n+                nm->make_not_entrant(nmethod::InvalidationReason::WHITEBOX_DEOPTIMIZATION, false \/* don't interfere with testing *\/);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -406,0 +407,11 @@\n+\n+void Abstract_VM_Version::check_cpufeatures_vmoptions() {\n+  if (!FLAG_IS_DEFAULT(CPUFeatures)) {\n+    if (strcmp(CPUFeatures, \"native\") && strcmp(CPUFeatures, \"generic\") && strcmp(CPUFeatures, \"ignore\")) {\n+      vm_exit_during_initialization(\"This architecture does not support any arch-specific -XX:CPUFeatures options\");\n+    }\n+  }\n+  if (!FLAG_IS_DEFAULT(ShowCPUFeatures)) {\n+    tty->print_cr(\"Do not use -XX:ShowCPUFeatures: this architecture does not support any arch-specific strings.\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,0 +54,5 @@\n+  struct Zero_Features {\n+    void print_numbers(outputStream &os, bool hexonly = false) const {}\n+    const char *print_numbers() const { return \"\"; }\n+  };\n+\n@@ -222,0 +227,3 @@\n+  \/\/ Default check for non-x86_64 architectures on VM options sanity\n+  static void check_cpufeatures_vmoptions();\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2024, Azul Systems, Inc. All rights reserved.\n@@ -55,0 +56,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -87,0 +89,2 @@\n+char** Arguments::_jvm_restore_flags_array      = nullptr;\n+int    Arguments::_num_jvm_restore_flags        = 0;\n@@ -92,0 +96,1 @@\n+char*  Arguments::_java_command_crac            = nullptr;\n@@ -572,0 +577,2 @@\n+  { \"IgnoreCPUFeatures\",            JDK_Version::jdk(26), JDK_Version::jdk(27), JDK_Version::jdk(28) },\n+\n@@ -1027,0 +1034,4 @@\n+void Arguments::build_jvm_restore_flags(const char* arg) {\n+  add_string(&_jvm_restore_flags_array, &_num_jvm_restore_flags, arg);\n+}\n+\n@@ -1117,0 +1128,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == nullptr) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1126,4 +1150,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1131,6 +1152,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == nullptr) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1273,1 +1290,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != nullptr, \"key should not be null\");\n+  assert(value != nullptr, \"value should not be null\");\n@@ -1275,2 +1294,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1280,1 +1297,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1288,1 +1306,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1290,1 +1308,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1292,0 +1310,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = nullptr;\n+  const char* value = nullptr;\n+\n+  get_key_value(prop, &key, &value);\n@@ -1317,0 +1342,6 @@\n+    } else if (strcmp(key, \"sun.java.crac_command\") == 0) {\n+      char *old_java_command_crac = _java_command_crac;\n+      _java_command_crac = os::strdup_check_oom(value, mtArguments);\n+      if (old_java_command_crac != nullptr) {\n+        os::free(old_java_command_crac);\n+      }\n@@ -1857,0 +1888,6 @@\n+  if (CheckCPUFeatures != nullptr && !strcmp(CheckCPUFeatures, \"skip\") && !UnlockExperimentalVMOptions) {\n+    jio_fprintf(defaultStream::error_stream(),\n+                \"-XX:CheckCPUFeatures=skip is allowed only with -XX:+UnlockExperimentalVMOptions\\n\");\n+    return false;\n+  }\n+\n@@ -2138,0 +2175,1 @@\n+        !match_option(option, \"-Dsun.java.crac_command\", &tail) &&\n@@ -2924,0 +2962,107 @@\n+\/\/ Some restore-settable flags should not be updated in the restored JVM.\n+static bool should_record_for_restore(const JVMFlag& flag) {\n+  precond(flag.is_restore_settable());\n+  if (strncmp(flag.name(), \"CRaCEngine\", ARRAY_SIZE(\"CRaCEngine\") - 1) == 0) {\n+    assert(strcmp(flag.name(), \"CRaCEngine\") == 0 || strcmp(flag.name(), \"CRaCEngineOptions\") == 0,\n+           \"unexpected CRaCEngine* flag: %s\", flag.name());\n+    return false;\n+  }\n+  if (strcmp(flag.name(), \"IgnoreUnrecognizedVMOptions\") == 0) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ arg is a JVM argument without the leading \"-XX:\", e.g. \"+BoolOpt\" or \"StrOpt=str\"\n+bool Arguments::process_flag_for_restore(const char *arg) {\n+  \/\/ -XX:Flags and -XX:VMOptionsFile do not have corresponding JVMFlags\n+  if ((strncmp(arg, \"Flags=\", ARRAY_SIZE(\"Flags=\") - 1) == 0) ||\n+      (strncmp(arg, \"VMOptionsFile=\", ARRAY_SIZE(\"VMOptionsFile=\") - 1) == 0)) {\n+    return true;\n+  }\n+\n+  const char* name;\n+  size_t name_len;\n+  bool has_plus_minus;\n+  parse_argname(arg, &name, &name_len, &has_plus_minus);\n+\n+  const JVMFlag* flag = nullptr;\n+  bool is_name_real; \/\/ false if the given name is an alias for a real flag name\n+  if (name_len <= BUFLEN) {\n+    char buf[BUFLEN + 1];\n+    const char* stripped_name;\n+    if (name[name_len] == '\\0') {\n+      stripped_name = name;\n+    } else {\n+      strncpy(buf, name, name_len);\n+      buf[name_len] = '\\0';\n+      stripped_name = buf;\n+    }\n+\n+    const char* real_name = real_flag_name(stripped_name);\n+    is_name_real = stripped_name == real_name;\n+    assert(is_name_real == (strcmp(stripped_name, real_name) == 0), \"real_flag_name(s) == s if s is real\");\n+\n+    flag = JVMFlag::find_declared_flag(real_name);\n+  }\n+  if (flag == nullptr) {\n+    return true; \/\/ The argument should have been ignored by IgnoreUnrecognizedVMOptions\n+  }\n+  assert(has_plus_minus == flag->is_bool(), \"sanity check\");\n+\n+  if (!flag->is_restore_settable() && !CRaCIgnoreRestoreIfUnavailable) {\n+    \/\/ Same message format as used in JVMFlag::get_locked_message() for\n+    \/\/ diagnostic\/experimental\/develop options\n+    jio_fprintf(defaultStream::error_stream(),\n+                \"Error: VM option '%.*s' is not restore-settable and is not available on restore.\\n\",\n+                name_len, name);\n+    return false;\n+  }\n+\n+  if (flag->is_restore_settable() && should_record_for_restore(*flag)) {\n+    \/\/ Restored JVM will search for the flag using the name we record here so we\n+    \/\/ must ensure the real one is recorded\n+    if (is_name_real) {\n+      build_jvm_restore_flags(arg);\n+    } else {\n+      const size_t real_arg_len = strlen(arg) + (strlen(flag->name()) - name_len);\n+      char* const real_arg = AllocateHeap(real_arg_len + 1, MemTag::mtArguments);\n+      const int ret = has_plus_minus ?\n+        jio_snprintf(real_arg, real_arg_len + 1, \"%c%s\", arg[0], flag->name()) :\n+        jio_snprintf(real_arg, real_arg_len + 1, \"%s%s\", flag->name(), arg + name_len);\n+      guarantee(ret >= 0 && checked_cast<size_t>(ret) == real_arg_len, \"snprintf failed: %i\", ret);\n+      build_jvm_restore_flags(real_arg);\n+      FreeHeap(real_arg);\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+bool Arguments::process_flags_for_restore() {\n+  precond(CRaCRestoreFrom != nullptr);\n+\n+  char** const vm_flags = Arguments::jvm_flags_array();\n+  for (int i = 0; i < Arguments::num_jvm_flags(); i++) {\n+    if (!process_flag_for_restore(vm_flags[i])) {\n+      return false;\n+    }\n+  }\n+\n+  char** const vm_args = Arguments::jvm_args_array();\n+  for (int i = 0; i < Arguments::num_jvm_args(); i++) {\n+    const JavaVMOption opt{vm_args[i]};\n+    const char *tail;\n+    \/\/ FIXME: other kinds of arguments can also lead to VM flags being set so\n+    \/\/  ideally we would want to process those too. But there seems to be no way\n+    \/\/  to do this except highly intrusive (add processing into each special\n+    \/\/  branch of arguments parsing) or performance-costly (iterate through all\n+    \/\/  JVMFlags) ones.\n+    if (match_option(&opt, \"-XX:\", &tail) && !process_flag_for_restore(tail)) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n@@ -3003,0 +3148,11 @@\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return JNI_ERR;\n+  }\n+  if (CRaCRestoreFrom && !process_flags_for_restore()) {\n+    return JNI_EINVAL;\n+  }\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n@@ -3934,0 +4090,1 @@\n+\n@@ -4101,0 +4258,19 @@\n+\n+void Arguments::reset_for_crac_restore() {\n+  if (!FLAG_IS_DEFAULT(LogVMOutput)){\n+    FLAG_SET_DEFAULT(LogVMOutput, false);\n+    FLAG_SET_DEFAULT(LogFile, nullptr);\n+  }\n+}\n+\n+void Arguments::free_restore_only_data() {\n+  os::free(_java_command_crac);\n+  _java_command_crac = nullptr;\n+\n+  for (int i = 0; i < _num_jvm_restore_flags; i++) {\n+    os::free(_jvm_restore_flags_array[i]);\n+  }\n+  FREE_C_HEAP_ARRAY(char*, _jvm_restore_flags_array);\n+  _num_jvm_restore_flags = 0;\n+  _jvm_restore_flags_array = nullptr;\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":192,"deletions":16,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -198,0 +198,3 @@\n+  \/\/ an array containing all restore-settable jvm flags specified in any way on restore\n+  static char** _jvm_restore_flags_array;\n+  static int    _num_jvm_restore_flags;\n@@ -200,0 +203,2 @@\n+  \/\/ same as _java_command but with spaces inside args escaped\n+  static char* _java_command_crac;\n@@ -291,0 +296,4 @@\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n+\n@@ -351,0 +360,1 @@\n+  static void build_jvm_restore_flags(const char* arg);\n@@ -403,0 +413,1 @@\n+  static char** jvm_restore_flags_array()  { return _jvm_restore_flags_array; }\n@@ -405,0 +416,1 @@\n+  static int num_jvm_restore_flags()       { return _num_jvm_restore_flags; }\n@@ -407,0 +419,1 @@\n+  static const char* java_command_crac()   { return _java_command_crac; }\n@@ -457,0 +470,2 @@\n+  \/\/ Reset LogVMoutput to default values\n+  static void reset_for_crac_restore();\n@@ -522,0 +537,5 @@\n+  static bool process_flag_for_restore(const char *arg);\n+  static bool process_flags_for_restore();\n+\n+  static void free_restore_only_data();\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,1007 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"classfile\/classLoader.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"jfr\/jfr.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"oops\/oopCast.inline.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/crac_engine.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/classLoadingService.hpp\"\n+#include \"services\/heapDumper.hpp\"\n+#include \"services\/writeableFlags.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/decoder.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+static jlong _restore_start_time;\n+static jlong _restore_start_nanos;\n+\n+CracEngine *crac::_engine = nullptr;\n+unsigned int crac::_generation = 1;\n+char crac::_checkpoint_bootid[UUID_LENGTH];\n+jlong crac::_checkpoint_wallclock_seconds;\n+jlong crac::_checkpoint_wallclock_nanos;\n+jlong crac::_checkpoint_monotonic_nanos;\n+jlong crac::_javaTimeNanos_offset;\n+\n+jlong crac::restore_start_time() {\n+  if (!_restore_start_time) {\n+    return -1;\n+  }\n+  return _restore_start_time;\n+}\n+\n+jlong crac::uptime_since_restore() {\n+  if (!_restore_start_nanos) {\n+    return -1;\n+  }\n+  return os::javaTimeNanos() - _restore_start_nanos;\n+}\n+\n+void VM_Crac::print_resources(const char* msg, ...) {\n+  if (CRaCPrintResourcesOnCheckpoint) {\n+    va_list ap;\n+    va_start(ap, msg);\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    _ostream->vprint(msg, ap);\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+    va_end(ap);\n+  }\n+}\n+\n+#if defined(__APPLE__) || defined(_WINDOWS)\n+static char * strchrnul(char * str, char c) {\n+  for (; *str && c != *str; ++str) {}\n+  return str;\n+}\n+#endif \/\/__APPLE__ || _WINDOWS\n+\n+static int append_time(char *buf, size_t buflen, bool iso8601, bool zero_pad, int width, jlong timeMillis) {\n+  if (iso8601) {\n+    if (width >= 0 || zero_pad) {\n+      log_warning(crac)(\"Cannot use zero-padding or set width for ISO-8601 time in CRaCCheckpointTo=%s\", CRaCCheckpointTo);\n+    }\n+    \/\/ os::iso8601_time formats with dashes and colons, we want the basic version\n+    time_t time = timeMillis \/ 1000;\n+    struct tm tms;\n+    if (os::gmtime_pd(&time, &tms) == nullptr) {\n+      log_warning(crac)(\"Cannot format time \" JLONG_FORMAT, timeMillis);\n+      return -1;\n+    }\n+    return (int) strftime(buf, buflen, \"%Y%m%dT%H%M%SZ\", &tms);\n+  } else {\n+    \/\/ width -1 works too (means 1 char left aligned => we always print at least 1 char)\n+    return os::snprintf(buf, buflen, zero_pad ? \"%0*\" PRId64 : \"%*\" PRId64, width, static_cast<int64_t>(timeMillis \/ 1000));\n+  }\n+}\n+\n+static int append_size(char *buf, size_t buflen, bool zero_pad, int width, size_t size) {\n+  if (zero_pad) {\n+    return os::snprintf(buf, buflen, \"%0*zu\", width, size);\n+  } else if (width >= 0) {\n+    return os::snprintf(buf, buflen, \"%*zu\", width, size);\n+  } else {\n+    static constexpr const char *suffixes[] = { \"k\", \"M\", \"G\" };\n+    const char *suffix = \"\";\n+    for (size_t i = 0; i < ARRAY_SIZE(suffixes) && size != 0 && (size & 1023) == 0; ++i) {\n+      suffix = suffixes[i];\n+      size = size >> 10;\n+    }\n+    return os::snprintf(buf, buflen, \"%zu%s\", size, suffix);\n+  }\n+}\n+\n+#define check_no_width_padding() do { \\\n+    if (width >= 0) { \\\n+      log_warning(crac)(\"Cannot set width for %%%c in CRaCCheckpointTo=%s\", c, CRaCCheckpointTo); \\\n+    } \\\n+    if (zero_pad) { \\\n+      log_warning(crac)(\"Cannot use zero-padding for %%%c in CRaCCheckpointTo=%s\", c, CRaCCheckpointTo); \\\n+    } \\\n+  } while (false)\n+\n+#define check_retval(statement) do { \\\n+    int ret = statement; \\\n+    if ((size_t) ret > buflen) { \\\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s (too long)\", CRaCCheckpointTo); \\\n+      return false; \\\n+    } else if (ret < 0) { \\\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s\", CRaCCheckpointTo); \\\n+      return false; \\\n+    } \\\n+    buf += ret; \\\n+    buflen -= ret; \\\n+  } while (false)\n+\n+static inline jlong boot_time() {\n+  \/\/ RuntimeMxBean.getStartTime() returns Management::vm_init_done_time() but this is not initialized\n+  \/\/ when CRaC checks the boot time early in the initialization phase\n+  return os::javaTimeMillis() - (1000 * os::elapsed_counter() \/ os::elapsed_frequency());\n+}\n+\n+\/\/ TODO: use stringStream or similar instead of a raw buffer\n+bool crac::interpolate_checkpoint_location(char *buf, size_t buflen, bool *fixed) {\n+  *fixed = true;\n+  for (size_t si = 0; ; si++) {\n+    if (buflen == 0) {\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s (too long)\", CRaCCheckpointTo);\n+      return false;\n+    }\n+    char c = CRaCCheckpointTo[si];\n+    if (c != '%') {\n+      *(buf++) = c;\n+      --buflen;\n+      if (!c) {\n+        break;\n+      } else {\n+        continue;\n+      }\n+    }\n+\n+    si++;\n+    c = CRaCCheckpointTo[si];\n+    bool zero_pad = false;\n+    if (c == '0') {\n+      zero_pad = true;\n+      si++;\n+    }\n+    size_t width_start = si;\n+    while (CRaCCheckpointTo[si] >= '0' && CRaCCheckpointTo[si] <= '9') {\n+      ++si;\n+    }\n+    if (zero_pad && width_start == si) {\n+      log_error(crac)(\"CRaCCheckpointTo=%s contains a pattern with zero padding but no length\", CRaCCheckpointTo);\n+      return false;\n+    }\n+    const int width = si > width_start ? atoi(&CRaCCheckpointTo[width_start]) : -1;\n+    c = CRaCCheckpointTo[si];\n+    switch (c) {\n+    case '%':\n+      check_no_width_padding();\n+      *(buf++) = '%';\n+      --buflen;\n+      break;\n+    case 'a': \/\/ CPU architecture; matches system property \"os.arch\"\n+        check_no_width_padding();\n+#ifndef ARCHPROPNAME\n+# error \"ARCHPROPNAME must be defined by build scripts\"\n+#endif\n+      check_retval(os::snprintf(buf, buflen, \"%s\", ARCHPROPNAME));\n+      break;\n+    case 'f': { \/\/ CPU features\n+        check_no_width_padding();\n+        VM_Version::VM_Features data;\n+        if (VM_Version::cpu_features_binary(&data)) {\n+          \/\/ The copying is inefficient but the proper fix is to use stringStream on the caller-site\n+          stringStream ss;\n+          data.print_numbers(ss, true);\n+          check_retval(static_cast<int>(ss.size()));\n+          memcpy(buf - ss.size(), ss.base(), ss.size());\n+        } \/\/ otherwise just empty string\n+      }\n+      break;\n+    case 'u': { \/\/ Random UUID (v4)\n+        u4 uuid[4];\n+        if (!random_bytes(reinterpret_cast<u1 *>(uuid), sizeof(uuid))) {\n+          log_error(crac)(\"Cannot generate random UUID\");\n+          return false;\n+        }\n+        check_no_width_padding();\n+        *fixed = false; \/\/ FIXME?\n+        u4 time_mid_high = uuid[0];\n+        u4 seq_and_node_low = uuid[1];\n+        check_retval(os::snprintf(buf, buflen, \"%08x-%04x-4%03x-%04x-%04x%08x\",\n+          uuid[2], time_mid_high >> 16, time_mid_high & 0xFFF,\n+          0x8000 | (seq_and_node_low & 0x3FFF), seq_and_node_low >> 16, uuid[3]));\n+      }\n+      break;\n+    case 't': \/\/ checkpoint (current) time\n+    case 'T':\n+      *fixed = false;\n+      check_retval(append_time(buf, buflen, c == 't', zero_pad, width, os::javaTimeMillis()));\n+      break;\n+    case 'b': \/\/ boot time\n+    case 'B':\n+      check_retval(append_time(buf, buflen, c == 'b', zero_pad, width, boot_time()));\n+      break;\n+    case 'r': \/\/ last restore time\n+    case 'R':\n+      check_retval(append_time(buf, buflen, c == 'r', zero_pad, width, _generation != 1 ? crac::restore_start_time() : boot_time()));\n+      break;\n+    case 'p': \/\/ PID\n+      check_retval(os::snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::current_process_id()));\n+      break;\n+    case 'c': \/\/ Number of CPUs\n+      check_retval(os::snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::active_processor_count()));\n+      break;\n+    case 'm': \/\/ Max heap size\n+      *fixed = false; \/\/ Heap size is not yet resolved when this is called from prepare_checkpoint()\n+      check_retval(append_size(buf, buflen, zero_pad, width, Universe::heap() != nullptr ? Universe::heap()->max_capacity() : 0));\n+      break;\n+    case 'g': \/\/ CRaC generation\n+      check_retval(os::snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, _generation));\n+      break;\n+    default: \/* incl. terminating '\\0' *\/\n+      log_error(crac)(\"CRaCCheckpointTo=%s contains an invalid pattern\", CRaCCheckpointTo);\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+#undef check_no_width_padding\n+#undef check_retval\n+\n+static bool ensure_checkpoint_dir(const char *path, bool rm) {\n+  struct stat st;\n+  if (0 == os::stat(path, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      log_error(crac)(\"CRaCCheckpointTo=%s is not a directory\", path);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == os::mkdir(path)) {\n+      log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", path, os::strerror(errno));\n+      return false;\n+    }\n+    if (rm && -1 == os::rmdir(path)) {\n+      log_warning(crac)(\"Cannot cleanup after CRaCCheckpointTo check: %s\", os::strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+  return true;\n+}\n+\n+#ifndef PATH_MAX\n+# define PATH_MAX 1024\n+#endif\n+\n+int crac::checkpoint_restore(int *shmid) {\n+  guarantee(_engine != nullptr, \"CRaC engine is not initialized\");\n+\n+  crac::record_time_before_checkpoint();\n+\n+  \/\/ CRaCCheckpointTo can be changed on restore, and if this contains a pattern\n+  \/\/ it might not have been configured => we need to update the conf.\n+  \/\/ Note that CRaCEngine and CRaCEngineOptions are not updated (as documented)\n+  \/\/ so we don't need to re-init the whole engine handle.\n+  char image_location[PATH_MAX];\n+  bool ignored;\n+  if (!interpolate_checkpoint_location(image_location, sizeof(image_location), &ignored) ||\n+      !ensure_checkpoint_dir(image_location, false) ||\n+      !_engine->configure_image_location(image_location)) {\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  \/\/ Setup CPU arch & features only during the first checkpoint; the feature set\n+  \/\/ cannot change after initial boot (and we don't support switching the engine).\n+  if (_generation == 1 && !VM_Version::ignore_cpu_features()) {\n+    VM_Version::VM_Features data;\n+    if (VM_Version::cpu_features_binary(&data)) {\n+      switch (_engine->prepare_image_constraints_api()) {\n+        case CracEngine::ApiStatus::OK:\n+          if (!_engine->store_cpuinfo(&data)) {\n+            return JVM_CHECKPOINT_ERROR;\n+          }\n+          break;\n+        case CracEngine::ApiStatus::ERR:\n+          return JVM_CHECKPOINT_ERROR;\n+        case CracEngine::ApiStatus::UNSUPPORTED:\n+          log_warning(crac)(\"Cannot store CPUFeatures for checkpoint \"\n+            \"with the selected CRaC engine\");\n+          break;\n+      }\n+    }\n+  }\n+\n+  const int ret = _engine->checkpoint();\n+  if (ret != 0) {\n+    log_error(crac)(\"CRaC engine failed to checkpoint to %s: error %i\", image_location, ret);\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  switch (_engine->prepare_restore_data_api()) {\n+    case CracEngine::ApiStatus::OK: {\n+      constexpr size_t required_size = sizeof(*shmid);\n+      const size_t available_size = _engine->get_restore_data(shmid, sizeof(*shmid));\n+      if (available_size == 0) { \/\/ Possible if we were not killed by the engine and thus there is no restoring JVM\n+        *shmid = 0; \/\/ Not an error, just no restore data\n+        break;\n+      }\n+      if (available_size == required_size) {\n+        break;\n+      }\n+      if (available_size > required_size) {\n+        log_debug(crac)(\"CRaC engine has more restore data than expected\");\n+        break;\n+      }\n+      log_error(crac)(\"CRaC engine provided not enough restore data: need %zu bytes, got %zu\",\n+                      required_size, available_size);\n+      \/\/ fallthrough\n+    }\n+    case CracEngine::ApiStatus::ERR:         *shmid = -1; break; \/\/ Indicates error to the caller\n+    case CracEngine::ApiStatus::UNSUPPORTED: *shmid = 0;  break; \/\/ Not an error, just no restore data\n+  }\n+\n+#ifdef LINUX\n+  if (CRaCCPUCountInit) {\n+    os::Linux::initialize_cpu_count();\n+  }\n+#endif \/\/LINUX\n+\n+  crac::update_javaTimeNanos_offset();\n+\n+  if (CRaCTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n+  }\n+\n+  return JVM_CHECKPOINT_OK;\n+}\n+\n+bool VM_Crac::read_shm(int shmid) {\n+  precond(shmid > 0);\n+  CracSHM shm(shmid);\n+  int shmfd = shm.open(O_RDONLY);\n+  shm.unlink();\n+  if (shmfd < 0) {\n+    log_error(crac)(\"Cannot read restore parameters\");\n+    return false;\n+  }\n+  bool ret = _restore_parameters.read_from(shmfd);\n+  close(shmfd);\n+  return ret;\n+}\n+\n+bool VM_Crac::is_claimed_fd(int fd) {\n+  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n+  for (int j = 0; j < claimed_fds->length(); ++j) {\n+    jint cfd = claimed_fds->int_at(j);\n+    if (fd == cfd) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+class WakeupClosure: public ThreadClosure {\n+  void do_thread(Thread* thread) {\n+    JavaThread *jt = JavaThread::cast(thread);\n+    jt->wakeup_sleep();\n+    jt->parker()->unpark();\n+    jt->_ParkEvent->unpark();\n+  }\n+};\n+\n+\/\/ It requires Threads_lock to be held so it is being run as a part of VM_Operation.\n+static void wakeup_threads_in_timedwait_vm() {\n+  WakeupClosure wc;\n+  Threads::java_threads_do(&wc);\n+}\n+\n+\/\/ Run it after VM_Operation as it holds Threads_lock which would cause:\n+\/\/ Attempting to acquire lock PeriodicTask_lock\/safepoint out of order with lock Threads_lock\/safepoint-1 -- possible deadlock\n+static void wakeup_threads_in_timedwait() {\n+  MonitorLocker ml(PeriodicTask_lock, Mutex::_safepoint_check_flag);\n+  WatcherThread::watcher_thread()->unpark();\n+}\n+\n+class DefaultStreamHandler {\n+public:\n+  DefaultStreamHandler() {\n+    defaultStream::instance->before_checkpoint();\n+  }\n+\n+  ~DefaultStreamHandler() {\n+    defaultStream::instance->after_restore();\n+  }\n+};\n+\n+void VM_Crac::doit() {\n+  \/\/ dry-run fails checkpoint\n+  bool ok = true;\n+  DefaultStreamHandler defStreamHandler;\n+\n+  Decoder::before_checkpoint();\n+  if (!check_fds()) {\n+    ok = false;\n+  }\n+\n+  if ((!ok || _dry_run) && CRaCHeapDumpOnCheckpointException) {\n+    HeapDumper::dump_heap();\n+  }\n+\n+  if (!ok && CRaCPauseOnCheckpointError) {\n+    os::message_box(\"Checkpoint failed\", \"Errors were found during checkpoint.\");\n+  }\n+\n+  if (!ok || _dry_run) {\n+    _ok = ok;\n+    return;\n+  }\n+\n+  if (!memory_checkpoint()) {\n+    return;\n+  }\n+\n+  int shmid = -1;\n+  if (CRaCSkipCheckpoint) {\n+    log_info(crac)(\"Skip Checkpoint\");\n+    shmid = 0;\n+  } else {\n+    log_info(crac)(\"Checkpoint ...\");\n+    report_ok_to_jcmd_if_any();\n+    int ret = crac::checkpoint_restore(&shmid);\n+    if (ret == JVM_CHECKPOINT_ERROR) {\n+      memory_restore();\n+      return;\n+    }\n+  }\n+\n+  crac::_generation++;\n+  Arguments::reset_for_crac_restore();\n+  os::reset_cached_process_id();\n+\n+  if (shmid == 0) { \/\/ E.g. engine does not support restore data\n+    log_debug(crac)(\"Restore parameters (JVM flags, env vars, system properties, arguments...) not provided\");\n+    _restore_start_time = os::javaTimeMillis();\n+    _restore_start_nanos = os::javaTimeNanos();\n+  } else {\n+    if (shmid < 0 || !VM_Crac::read_shm(shmid)) {\n+      vm_direct_exit(1, \"Restore cannot continue, VM will exit.\"); \/\/ More info in logs\n+      ShouldNotReachHere();\n+    }\n+    _restore_start_nanos += crac::monotonic_time_offset();\n+  }\n+\n+  if (CRaCResetStartTime) {\n+    crac::reset_time_counters();\n+  }\n+\n+  memory_restore();\n+\n+  wakeup_threads_in_timedwait_vm();\n+\n+  _ok = true;\n+}\n+\n+void crac::print_engine_info_and_exit() {\n+  CracEngine engine;\n+  if (!engine.is_initialized()) {\n+    return;\n+  }\n+\n+  const CracEngine::ApiStatus status = engine.prepare_description_api();\n+  if (status == CracEngine::ApiStatus::ERR) {\n+    return;\n+  }\n+  if (status == CracEngine::ApiStatus::UNSUPPORTED) {\n+    tty->print_cr(\"Selected CRaC engine does not provide information about itself\");\n+    vm_exit(0);\n+    ShouldNotReachHere();\n+  }\n+  postcond(status == CracEngine::ApiStatus::OK);\n+\n+  const char *description = engine.description();\n+  if (description == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to provide its textual description\");\n+    return;\n+  }\n+  tty->print_raw_cr(description);\n+\n+  const char *conf_doc = engine.configuration_doc();\n+  if (conf_doc == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to provide documentation of its configuration options\");\n+    return;\n+  }\n+  tty->cr();\n+  tty->print_raw_cr(\"Configuration options:\");\n+  tty->print_raw(conf_doc); \/\/ Doc string ends with CR by convention\n+\n+  const GrowableArrayCHeap<const char *, MemTag::mtInternal> *controlled_opts = engine.vm_controlled_options();\n+  tty->cr();\n+  tty->print_raw(\"Configuration options controlled by the JVM: \");\n+  for (int i = 0; i < controlled_opts->length(); i++) {\n+    const char *opt = controlled_opts->at(i);\n+    tty->print_raw(opt);\n+    if (i < controlled_opts->length() - 1) {\n+      tty->print_raw(\", \");\n+    }\n+  }\n+  tty->cr();\n+  delete controlled_opts;\n+\n+  vm_exit(0);\n+  ShouldNotReachHere();\n+}\n+\n+template<class T> class FutureRef {\n+private:\n+  T *_t;\n+public:\n+  FutureRef(T *t): _t(t) {}\n+  ~FutureRef() {\n+    delete _t;\n+  }\n+  T *operator->() {\n+    return _t;\n+  }\n+  T *extract() {\n+    T *tmp = _t;\n+    _t = nullptr;\n+    return tmp;\n+  }\n+};\n+\n+bool crac::prepare_checkpoint() {\n+  precond(CRaCCheckpointTo != nullptr);\n+\n+  \/\/ Initialize CRaC engine now to verify all the related VM options\n+  assert(_engine == nullptr, \"CRaC engine should be initialized only once\");\n+  FutureRef<CracEngine> engine(new CracEngine());\n+  if (!engine->is_initialized()) {\n+    return false;\n+  }\n+\n+  char image_location[PATH_MAX];\n+  bool fixed_path;\n+  if (!interpolate_checkpoint_location(image_location, PATH_MAX, &fixed_path)) {\n+    return false;\n+  }\n+  if (fixed_path && (!ensure_checkpoint_dir(image_location, true) || !engine->configure_image_location(image_location))) {\n+    return false;\n+  }\n+\n+  _engine = engine.extract();\n+  return true;\n+}\n+\n+static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n+  objArrayHandle bundle(THREAD, bundleObj);\n+  jvalue jval;\n+  jval.i = ret;\n+  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n+  bundle->obj_at_put(0, retObj);\n+  bundle->obj_at_put(1, new_args());\n+  bundle->obj_at_put(2, new_props());\n+  bundle->obj_at_put(3, err_codes());\n+  bundle->obj_at_put(4, err_msgs());\n+  return bundle;\n+}\n+\n+\/** Checkpoint main entry.\n+ *\/\n+Handle crac::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n+  log_debug(crac)(\"Checkpoint %i requested (dry run=%s)\", os::current_process_id(), BOOL_TO_STR(dry_run));\n+\n+  if (CRaCCheckpointTo == nullptr) {\n+    log_error(crac)(\"CRaCCheckpointTo is not specified\");\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+#if INCLUDE_JVMTI\n+  JvmtiExport::post_crac_before_checkpoint();\n+#endif\n+\n+  Universe::heap()->set_cleanup_unused(true);\n+  Universe::heap()->collect(GCCause::_full_gc_alot);\n+  Universe::heap()->set_cleanup_unused(false);\n+\n+  if (os::can_trim_native_heap()) {\n+    os::size_change_t sc;\n+    if (os::trim_native_heap(&sc)) {\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n+        log_debug(crac)(\"Trim native heap before checkpoint: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \")\",\n+                        PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta));\n+      }\n+    }\n+  }\n+\n+  JFR_ONLY(Jfr::before_checkpoint();)\n+\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer) {\n+    aio_writer->stop();\n+  }\n+  LogConfiguration::close();\n+\n+  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    VMThread::execute(&cr);\n+  }\n+\n+  Universe::heap()->after_restore();\n+\n+  LogConfiguration::reopen();\n+  if (aio_writer) {\n+    aio_writer->resume();\n+  }\n+\n+  JFR_ONLY(Jfr::after_restore();)\n+\n+#if INCLUDE_JVMTI\n+  JvmtiExport::post_crac_after_restore();\n+#endif\n+\n+  if (cr.ok()) {\n+    \/\/ Using handle rather than oop; dangling oop would fail with -XX:+CheckUnhandledOops\n+    Handle new_args;\n+    if (cr.new_args()) {\n+      oop args_oop = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n+      new_args = Handle(THREAD, args_oop);\n+    }\n+\n+    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n+    objArrayHandle props(THREAD, propsObj);\n+\n+    for (int i = 0; i < new_properties->length(); i++) {\n+      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n+      props->obj_at_put(i, propObj);\n+    }\n+\n+    wakeup_threads_in_timedwait();\n+\n+    return ret_cr(JVM_CHECKPOINT_OK, new_args, props, Handle(), Handle(), THREAD);\n+  }\n+\n+  GrowableArray<CracFailDep>* failures = cr.failures();\n+\n+  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n+  typeArrayHandle codes(THREAD, codesObj);\n+  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n+  objArrayHandle msgs(THREAD, msgsObj);\n+\n+  for (int i = 0; i < failures->length(); ++i) {\n+    codes->int_at_put(i, failures->at(i)._type);\n+    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n+    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n+    msgs->obj_at_put(i, msgObj);\n+  }\n+\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n+}\n+\n+bool crac::is_image_constraints_supported() {\n+  return _engine != nullptr && _engine->prepare_image_constraints_api() == CracEngine::ApiStatus::OK;\n+}\n+\n+bool crac::record_image_label(const char *label, const char *value) {\n+  if (_engine == nullptr || _engine->prepare_image_constraints_api() != CracEngine::ApiStatus::OK) {\n+    return false;\n+  }\n+  return _engine->set_label(label, value);\n+}\n+\n+bool crac::is_image_score_supported() {\n+  \/\/ The engine is not initialized when CRaCCheckpointTo is not set\n+  return _engine != nullptr && _engine->prepare_image_score_api() == CracEngine::ApiStatus::OK;\n+}\n+\n+bool crac::record_image_score(jobjectArray metrics, jdoubleArray values) {\n+  if (_engine == nullptr || _engine->prepare_image_score_api() != CracEngine::ApiStatus::OK) {\n+    return false;\n+  }\n+  ResourceMark rm;\n+  objArrayOop metrics_oops = oop_cast<objArrayOop>(JNIHandles::resolve_non_null(metrics));\n+  typeArrayOop values_oops = oop_cast<typeArrayOop>(JNIHandles::resolve_non_null(values));\n+  assert(metrics_oops->length() == values_oops->length(), \"should be equal\");\n+  for (int i = 0; i < metrics_oops->length(); ++i) {\n+    oop metric_oop = metrics_oops->obj_at(i);\n+    assert(metric_oop != nullptr, \"not null\");\n+    const char* metric = java_lang_String::as_utf8_string(metric_oop);\n+    double value = values_oops->double_at(i);\n+    if (!_engine->set_score(metric, value)) {\n+      return false;\n+    }\n+  }\n+\n+  bool result = true;\n+  result = result && _engine->set_score(\"java.lang.Runtime.availableProcessors\", os::active_processor_count());\n+  result = result && _engine->set_score(\"java.lang.Runtime.totalMemory\", Universe::heap()->capacity());\n+  result = result && _engine->set_score(\"java.lang.Runtime.maxMemory\", Universe::heap()->max_capacity());\n+\n+  double uptime = TimeHelper::counter_to_millis(os::elapsed_counter());\n+  result = result && _engine->set_score(\"vm.boot_time\", os::javaTimeMillis() - uptime);\n+  result = result && _engine->set_score(\"vm.uptime\", uptime);\n+  result = result && _engine->set_score(\"vm.uptime_since_restore\", TimeHelper::counter_to_millis(os::elapsed_counter_since_restore()));\n+\n+#if INCLUDE_MANAGEMENT\n+  jlong shared_loaded_classes = ClassLoadingService::loaded_shared_class_count();\n+  jlong shared_unloaded_classes = ClassLoadingService::unloaded_shared_class_count();\n+  \/\/ The keys match what jcmd <pid> PerfCounter.print would use\n+  result = result && _engine->set_score(\"java.cls.loadedClasses\", ClassLoadingService::loaded_class_count() - shared_loaded_classes);\n+  result = result && _engine->set_score(\"java.cls.sharedLoadedClasses\", shared_loaded_classes);\n+  result = result && _engine->set_score(\"java.cls.unloadedClasses\", ClassLoadingService::unloaded_class_count() - shared_unloaded_classes);\n+  result = result && _engine->set_score(\"java.cls.sharedUnloadedClasses\", shared_unloaded_classes);\n+#endif \/\/ INCLUDE_MANAGEMENT\n+  if (ClassLoader::perf_app_classload_count() != nullptr) {\n+    result = result && _engine->set_score(\"sun.cls.appClassLoadCount\", ClassLoader::perf_app_classload_count()->get_value());\n+  }\n+\n+  result = result && _engine->set_score(\"sun.ci.totalCompiles\", CompileBroker::get_total_compile_count());\n+  result = result && _engine->set_score(\"sun.ci.totalBailouts\", CompileBroker::get_total_bailout_count());\n+  result = result && _engine->set_score(\"sun.ci.totalInvalidates\", CompileBroker::get_total_invalidated_count());\n+  \/\/ CompileBroker::get_total_native_compile_count() is never incremented?\n+  result = result && _engine->set_score(\"sun.ci.osrCompiles\", CompileBroker::get_total_osr_compile_count());\n+  result = result && _engine->set_score(\"sun.ci.standardCompiles\", CompileBroker::get_total_standard_compile_count());\n+  result = result && _engine->set_score(\"sun.ci.osrBytes\", CompileBroker::get_sum_osr_bytes_compiled());\n+  result = result && _engine->set_score(\"sun.ci.standardBytes\", CompileBroker::get_sum_standard_bytes_compiled());\n+  result = result && _engine->set_score(\"sun.ci.nmethodSize\", CompileBroker::get_sum_nmethod_size());\n+  result = result && _engine->set_score(\"sun.ci.nmethodCodeSize\", CompileBroker::get_sum_nmethod_code_size());\n+  result = result && _engine->set_score(\"java.ci.totalTime\", CompileBroker::get_total_compilation_time());\n+  return result;\n+}\n+\n+bool crac::record_image_score(const char *metric, double value) {\n+  if (_engine == nullptr || _engine->prepare_image_score_api() != CracEngine::ApiStatus::OK) {\n+    return false;\n+  }\n+  return _engine->set_score(metric, value);\n+}\n+\n+void crac::prepare_restore(crac_restore_data& restore_data) {\n+  restore_data.restore_time = os::javaTimeMillis();\n+  restore_data.restore_nanos = os::javaTimeNanos();\n+}\n+\n+void crac::restore(crac_restore_data& restore_data) {\n+  precond(CRaCRestoreFrom != nullptr);\n+\n+  struct stat statbuf;\n+  if (os::stat(CRaCRestoreFrom, &statbuf) != 0) {\n+    log_error(crac)(\"Cannot open CRaCRestoreFrom=%s: %s\", CRaCRestoreFrom, os::strerror(errno));\n+    return;\n+  }\n+  if ((statbuf.st_mode & S_IFMT) != S_IFDIR) {\n+    log_error(crac)(\"CRaCRestoreFrom=%s is not a directory\", CRaCRestoreFrom);\n+    return;\n+  }\n+\n+  \/\/ Note that this is a local, i.e. the handle will be destroyed if we fail to restore\n+  CracEngine engine;\n+  if (!engine.is_initialized() || !engine.configure_image_location(CRaCRestoreFrom)) {\n+    return;\n+  }\n+\n+  bool ignore = VM_Version::ignore_cpu_features();\n+  bool exact = false;\n+  if (CheckCPUFeatures == nullptr || !strcmp(CheckCPUFeatures, \"compatible\")) {\n+    \/\/ default, compatible\n+  } else if (!strcmp(CheckCPUFeatures, \"skip\")) {\n+    ignore = true;\n+  } else if (!strcmp(CheckCPUFeatures, \"exact\")) {\n+    exact = true;\n+  } else {\n+    log_error(crac)(\"Invalid value for -XX:CheckCPUFeatures=%s; available are 'compatible', 'exact' or 'skip'\", CheckCPUFeatures);\n+    return;\n+  }\n+  if (!ignore) {\n+    switch (engine.prepare_image_constraints_api()) {\n+      case CracEngine::ApiStatus::OK: {\n+        VM_Version::VM_Features data;\n+        if (VM_Version::cpu_features_binary(&data)) {\n+          engine.require_cpuinfo(&data, exact);\n+        }\n+        } break;\n+      case CracEngine::ApiStatus::ERR:\n+        return;\n+      case CracEngine::ApiStatus::UNSUPPORTED:\n+        log_warning(crac)(\"Cannot verify CPUFeatures for restore \"\n+          \"with the selected CRaC engine\");\n+        break;\n+    }\n+  }\n+\n+  switch (engine.prepare_restore_data_api()) {\n+    case CracEngine::ApiStatus::OK: {\n+      const int shmid = os::current_process_id();\n+      CracSHM shm(shmid);\n+      const int shmfd = shm.open(O_RDWR | O_CREAT | O_TRUNC);\n+      if (shmfd < 0) {\n+        log_error(crac)(\"Failed to open a space shared with restored process\");\n+        return;\n+      }\n+      const bool write_success = CracRestoreParameters::write_to(\n+        shmfd,\n+        Arguments::jvm_restore_flags_array(), Arguments::num_jvm_restore_flags(),\n+        Arguments::system_properties(),\n+        !CRaCIgnoreRestoreIfUnavailable && Arguments::java_command_crac() != nullptr ?\n+          Arguments::java_command_crac() : \"\",\n+        restore_data.restore_time,\n+        restore_data.restore_nanos\n+      );\n+      close(shmfd);\n+      if (!write_success) {\n+        log_error(crac)(\"Failed to write to a space shared with restored process\");\n+        return;\n+      }\n+      if (!engine.set_restore_data(&shmid, sizeof(shmid))) {\n+        log_error(crac)(\"CRaC engine failed to record restore data\");\n+        return;\n+      }\n+      break;\n+    }\n+    case CracEngine::ApiStatus::ERR: break;\n+    case CracEngine::ApiStatus::UNSUPPORTED:\n+      log_warning(crac)(\"Cannot pass restore parameters (JVM flags, env vars, system properties, arguments...) \"\n+        \"with the selected CRaC engine\");\n+      break;\n+  }\n+\n+  const int ret = engine.restore();\n+  if (ret != 0) {\n+    log_error(crac)(\"CRaC engine failed to restore from %s: error %d\", CRaCRestoreFrom, ret);\n+    VM_Version::VM_Features data;\n+    VM_Version::cpu_features_binary(&data); \/\/ ignore return value\n+    engine.check_cpuinfo(&data);\n+  }\n+}\n+\n+bool CracRestoreParameters::read_from(int fd) {\n+  struct stat st;\n+  if (fstat(fd, &st)) {\n+    perror(\"fstat (ignoring restore parameters)\");\n+    return false;\n+  }\n+\n+  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+  if (read(fd, contents, st.st_size) < 0) {\n+    perror(\"read (ignoring restore parameters)\");\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return false;\n+  }\n+\n+  _raw_content = contents;\n+\n+  \/\/ parse the contents to read new system properties and arguments\n+  header* hdr = (header*)_raw_content;\n+  char* cursor = _raw_content + sizeof(header);\n+\n+  ::_restore_start_time = hdr->_restore_time;\n+  ::_restore_start_nanos = hdr->_restore_nanos;\n+\n+  for (int i = 0; i < hdr->_nflags; i++) {\n+    FormatBuffer<80> err_msg(\"%s\", \"\");\n+    JVMFlag::Error result;\n+    const char *name = cursor;\n+    if (*cursor == '+' || *cursor == '-') {\n+      name = cursor + 1;\n+      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n+        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+      cursor += strlen(cursor) + 1;\n+    } else {\n+      char* eq = strchrnul(cursor, '=');\n+      if (*eq == '\\0') {\n+        result = JVMFlag::Error::MISSING_VALUE;\n+        cursor = eq + 1;\n+      } else {\n+        *eq = '\\0';\n+        char* value = eq + 1;\n+        \/\/ A single ccstrlist flag can be specified multiple times meaning those\n+        \/\/ should be concatenated. But with the current code the last occurence\n+        \/\/ will just overwrite the previous ones.\n+        assert(!JVMFlag::find_flag(cursor)->ccstr_accumulates(),\n+               \"setting ccstrlist flags on restore is not supported: %s\", cursor);\n+        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+        cursor = value + strlen(value) + 1;\n+      }\n+    }\n+    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %d\",\n+        name, result);\n+  }\n+\n+  for (int i = 0; i < hdr->_nprops; i++) {\n+    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+    int idx = _properties->append(cursor);\n+    size_t prop_len = strlen(cursor) + 1;\n+    cursor = cursor + prop_len;\n+  }\n+\n+  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n+  memcpy(env_mem, cursor, hdr->_env_memory_size);\n+\n+  const char* env_end = env_mem + hdr->_env_memory_size;\n+  while (env_mem < env_end) {\n+    const size_t s = strlen(env_mem) + 1;\n+    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n+    putenv(env_mem);\n+    env_mem += s;\n+  }\n+  cursor += hdr->_env_memory_size;\n+\n+  _args = cursor;\n+  return true;\n+}\n+\n+void crac::record_time_before_checkpoint() {\n+  os::javaTimeSystemUTC(_checkpoint_wallclock_seconds, _checkpoint_wallclock_nanos);\n+  _checkpoint_monotonic_nanos = os::javaTimeNanos();\n+  memset(_checkpoint_bootid, 0, UUID_LENGTH);\n+  read_bootid(_checkpoint_bootid);\n+}\n+\n+void crac::update_javaTimeNanos_offset() {\n+  char buf[UUID_LENGTH];\n+  \/\/ We will change the nanotime offset only if this is not the same boot\n+  \/\/ to prevent reducing the accuracy of System.nanoTime() unnecessarily.\n+  \/\/ It is possible that in a real-world case the boot_id does not change\n+  \/\/ (containers keep the boot_id) - but the monotonic time changes. We will\n+  \/\/ only guarantee that the nanotime does not go backwards in that case but\n+  \/\/ won't offset the time based on wall-clock time as this change in monotonic\n+  \/\/ time is likely intentional.\n+  if (!read_bootid(buf) || memcmp(buf, _checkpoint_bootid, UUID_LENGTH) != 0) {\n+    jlong current_wallclock_seconds;\n+    jlong current_wallclock_nanos;\n+    os::javaTimeSystemUTC(current_wallclock_seconds, current_wallclock_nanos);\n+\n+    jlong diff_wallclock =\n+      (current_wallclock_seconds - _checkpoint_wallclock_seconds) * NANOSECS_PER_SEC +\n+      current_wallclock_nanos - _checkpoint_wallclock_nanos;\n+    \/\/ If the wall clock has gone backwards we won't add it to the offset\n+    if (diff_wallclock < 0) {\n+      diff_wallclock = 0;\n+    }\n+\n+    \/\/ javaTimeNanos() call on the second line below uses the *_offset, so we will zero\n+    \/\/ it to make the call return true monotonic time rather than the adjusted value.\n+    _javaTimeNanos_offset = 0;\n+    _javaTimeNanos_offset = _checkpoint_monotonic_nanos - os::javaTimeNanos() + diff_wallclock;\n+  } else {\n+    \/\/ ensure monotonicity even if this looks like the same boot\n+    jlong diff = os::javaTimeNanos() - _checkpoint_monotonic_nanos;\n+    if (diff < 0) {\n+      _javaTimeNanos_offset -= diff;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":1007,"deletions":0,"binary":false,"changes":1007,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"code\/nmethod.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/metadata.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/cracRecompiler.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ Records information about a decompiled method.\n+\/\/\n+\/\/ Safepoints may occur between the moments when it is recorded and used which\n+\/\/ can lead to the Method* getting freed. To fight this we use the same\n+\/\/ mechanisms as CompileTask does:\n+\/\/ 1. Method holder class may get unloaded. A jweak to class holder is used to\n+\/\/    checked for this, the method will not be re-compiled if this happens.\n+\/\/ 2. Method may get thrown away by RedefineClasses. We forbid this for all\n+\/\/    recorded methods by marking them \"on-stack\" for RedefineClasses.\n+class CompilationInfo : public CHeapObj<MemTag::mtInternal> {\n+public:\n+  CompilationInfo(Method *method, int bci, int comp_level) :\n+      _klass_holder(JNIHandles::make_weak_global(Handle(Thread::current(), method->method_holder()->klass_holder()))),\n+      _method(method), _bci(bci), _comp_level(comp_level) {}\n+  ~CompilationInfo() {\n+    if (_klass_holder != nullptr) {\n+      if (JNIHandles::is_weak_global_handle(_klass_holder)) {\n+        JNIHandles::destroy_weak_global(_klass_holder);\n+      } else {\n+        JNIHandles::destroy_global(_klass_holder);\n+      }\n+    }\n+  }\n+  NONCOPYABLE(CompilationInfo);\n+\n+  Method *method() const { return _method; }\n+  int bci() const { return _bci; };\n+  int comp_level() const { return _comp_level; };\n+\n+  bool is_method_loaded() const {\n+    return _klass_holder == nullptr || \/\/ bootstrap loader is never unloaded\n+           JNIHandles::is_global_handle(_klass_holder) || \/\/ Strong handle keeps it loaded\n+           !JNIHandles::is_weak_global_cleared(_klass_holder); \/\/ Weak handle but still loaded\n+  }\n+  bool keep_method_loaded() {\n+    const NoSafepointVerifier nsv; \/\/ Ensure not unloaded concurrently\n+    if (!is_method_loaded()) {\n+      return false; \/\/ Already unloaded\n+    }\n+    JNIHandles::destroy_weak_global(_klass_holder);\n+    _klass_holder = JNIHandles::make_global(Handle(Thread::current(), method()->method_holder()->klass_holder()));\n+    postcond(is_method_loaded());\n+    return true;\n+  }\n+\n+private:\n+  jweak _klass_holder;\n+  Method * const _method;\n+  const int _bci;\n+  const int _comp_level;\n+};\n+\n+static void request_recompilation(CompilationInfo *info) {\n+  if (!info->keep_method_loaded()) {\n+    log_trace(crac, compilation)(\n+      \"Skipping recompilation: <unloaded method>, bci=%i, comp_level=%i  method got unloaded\",\n+      info->bci(), info->comp_level());\n+    return;\n+  }\n+  assert(Method::is_valid_method(info->method()), \"sanity check\");\n+\n+  if (log_is_enabled(Trace, crac)) {\n+    ResourceMark rm;\n+    log_trace(crac, compilation)(\n+      \"Requesting recompilation: %s, bci=%i, comp_level=%i\",\n+      info->method()->external_name(), info->bci(), info->comp_level());\n+  }\n+\n+  auto * const THREAD = JavaThread::current();\n+  \/\/ Note: this does not guarantee the method will get compiled; e.g. there may\n+  \/\/ already be compilation tasks for this method (even if on another level or\n+  \/\/ OSR-BCI) or it may have gotten not-compilable since it was recorded.\n+  CompileBroker::compile_method(methodHandle(THREAD, info->method()), info->bci(), info->comp_level(),\n+                                0, CompileTask::Reason_CRaC, THREAD);\n+  guarantee(!HAS_PENDING_EXCEPTION, \"the method should have been successfully compiled before\");\n+}\n+\n+\/\/ States:\n+\/\/  > IDLE > RECORDING > COMPILING \n+\/\/  \n+\/\/ - IDLE  doing nothing.\n+\/\/  - is_recording == false\n+\/\/  - decompilations == null\n+\/\/ - RECORDING  recording decompilations.\n+\/\/  - is_recording == true\n+\/\/  - decompilations != null  used for concurrent writing\n+\/\/ - COMPILING  recompiling the recorded decompilations.\n+\/\/  - is_recording == false\n+\/\/  - decompilations != null  used for non-concurrent reading and writing\n+static Atomic<bool> is_recording;\n+static Mutex *decompilations_lock;\n+static GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *decompilations;\n+\n+void CRaCRecompiler::start_recording_decompilations() {\n+  if (decompilations_lock == nullptr) {\n+    \/\/ Rank must be lower than that of MDOExtraData_lock\n+    decompilations_lock = new Mutex(Mutex::nosafepoint - 2, \"CRaCRecompiler_lock\");\n+  }\n+\n+  assert(!is_recording.load_relaxed() && decompilations == nullptr, \"unexpected state: is_recording = %s, decompilations = %p\",\n+         BOOL_TO_STR(is_recording.load_relaxed()), decompilations);\n+  decompilations = new GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal>();\n+  is_recording.release_store_fence(true);\n+  log_debug(crac, compilation)(\"CRaCRecompiler state: IDLE -> RECORDING\");\n+}\n+\n+void CRaCRecompiler::finish_recording_decompilations_and_recompile() {\n+  assert(Thread::current()->is_Java_thread(), \"need a Java thread to request compilations\");\n+\n+  {\n+    \/\/ The lock ensures we do not change the state while someone is recording\n+    const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n+    assert(is_recording.load_relaxed() && decompilations != nullptr, \"unexpected state: is_recording = %s, decompilations = %p\",\n+           BOOL_TO_STR(is_recording.load_relaxed()), decompilations);\n+    is_recording.release_store_fence(false);\n+    log_debug(crac, compilation)(\"CRaCRecompiler state: RECORDING -> COMPILING (recorded: %i)\", decompilations->length());\n+  }\n+\n+  \/\/ No lock because while the state is COMPILING only metadata_do() can access\n+  \/\/ decompilations besides us and it does that only on safepoints. We also rely\n+  \/\/ on the caller to ensure that if another recording will be started later\n+  \/\/ that thread will see all of these updates.\n+  while (decompilations->is_nonempty()) {\n+    \/\/ TODO: there can only be one compilation queued\/in-progress for a method\n+    \/\/  at a time, if there is one already for this method our request for it\n+    \/\/  will just be ignored. We could optimize at least our own requests by\n+    \/\/  placing requests for the same method further away from each other.\n+    request_recompilation(decompilations->last()); \/\/ Order should not matter\n+    \/\/ Method must stay in the decompilations list until we're done processing\n+    \/\/ it to let metadata_do() defend it from being deleted, so only pop now\n+    delete decompilations->pop();\n+  }\n+  delete decompilations;\n+  decompilations = nullptr;\n+  log_debug(crac, compilation)(\"CRaCRecompiler state: COMPILING -> IDLE\");\n+}\n+\n+void CRaCRecompiler::record_decompilation(const nmethod &nmethod) {\n+  if (!is_recording.load_acquire()) {\n+    return; \/\/ Fast pass to not acquire a lock when no C\/R occurs (i.e. most of the time)\n+  }\n+\n+  const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n+  if (is_recording.load_relaxed()) { \/\/ Re-check under the lock to be safe from concurrent changes\n+    assert(decompilations != nullptr, \"unexpected state: is_recording = %s, decompilations = %p\",\n+           BOOL_TO_STR(is_recording.load_relaxed()), decompilations);\n+    decompilations->append(new CompilationInfo(nmethod.method(),\n+                                               nmethod.is_osr_method() ? nmethod.osr_entry_bci() : InvocationEntryBci,\n+                                               nmethod.comp_level()));\n+  }\n+}\n+\n+bool CRaCRecompiler::is_recompilation_relevant(const methodHandle &method, int bci, int comp_level) {\n+  const nmethod *current_nmethod = bci == InvocationEntryBci ?\n+      method->code() :\n+      method->lookup_osr_nmethod_for(bci, CompLevel::CompLevel_any, false);\n+  const CompLevel current_comp_level = current_nmethod != nullptr ?\n+    checked_cast<CompLevel>(current_nmethod->comp_level()) :\n+    CompLevel::CompLevel_none;\n+  switch (current_comp_level) {\n+    case CompLevel::CompLevel_none:\n+      assert(comp_level > CompLevel::CompLevel_none, \"must be compiled\");\n+      return true; \/\/ JIT is better than interpreter\n+    case CompLevel::CompLevel_simple:\n+    case CompLevel::CompLevel_full_optimization:\n+      return false; \/\/ Already on a final level\n+    case CompLevel::CompLevel_limited_profile:\n+    case CompLevel::CompLevel_full_profile:\n+      return comp_level == CompLevel::CompLevel_full_optimization; \/\/ C2 is better than C1\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+  }\n+}\n+\n+void CRaCRecompiler::metadata_do(void f(Metadata *)) {\n+  assert_at_safepoint();\n+  \/\/ Since we are at a safepoint no synchronization is needed\n+  if (decompilations != nullptr) {\n+    for (const auto *decompilation : *decompilations) {\n+      if (decompilation->is_method_loaded()) {\n+        f(decompilation->method());\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/cracRecompiler.cpp","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,472 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"runtime\/crac_engine.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/hashTable.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/stringUtils.hpp\"\n+\n+#include <cstddef>\n+#include <cstring>\n+\n+\/\/ CRaC engine configuration options JVM sets directly instead of relaying from the user\n+#define VM_CONTROLLED_ENGINE_OPTS(OPT) \\\n+  OPT(image_location) \\\n+  OPT(exec_location) \\\n+\n+#define ARRAY_ELEM(opt) #opt,\n+static constexpr const char * const vm_controlled_engine_opts[] = {\n+  VM_CONTROLLED_ENGINE_OPTS(ARRAY_ELEM)\n+};\n+#undef ARRAY_ELEM\n+\n+#define DEFINE_OPT_VAR(opt) static constexpr const char engine_opt_##opt[] = #opt;\n+VM_CONTROLLED_ENGINE_OPTS(DEFINE_OPT_VAR)\n+#undef DEFINE_OPT_VAR\n+\n+static bool find_engine(const char *dll_dir, char *path, size_t path_size, bool *is_library) {\n+  \/\/ Try to interpret as a file path\n+  if (os::is_path_absolute(CRaCEngine)) {\n+    const size_t path_len = strlen(CRaCEngine);\n+    if (path_len + 1 > path_size) {\n+      log_error(crac)(\"CRaCEngine file path is too long: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    if (!os::file_exists(CRaCEngine)) {\n+      log_error(crac)(\"CRaCEngine file does not exist: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    strcpy(path, CRaCEngine);\n+\n+    const char *last_slash = strrchr(CRaCEngine, *os::file_separator());\n+    const char *basename;\n+    if (last_slash == nullptr) {\n+      basename = CRaCEngine;\n+    } else {\n+      basename = last_slash + strlen(os::file_separator());\n+    }\n+    *is_library = strncmp(basename, JNI_LIB_PREFIX, strlen(JNI_LIB_PREFIX)) == 0 &&\n+      strcmp(path + path_len - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0;\n+    log_debug(crac)(\"CRaCEngine path %s is %s library\", CRaCEngine, *is_library ? \"a\" : \"not a\");\n+\n+    return true;\n+  }\n+\n+  \/\/ Try to interpret as a library name\n+  if (os::dll_locate_lib(path, path_size, dll_dir, CRaCEngine)) {\n+    *is_library = true;\n+    log_debug(crac)(\"Found CRaCEngine %s as a library in %s\", CRaCEngine, path);\n+    return true;\n+  }\n+\n+  *is_library = false;\n+  log_debug(crac)(\"CRaCEngine %s is not a library in %s\", CRaCEngine, dll_dir);\n+\n+  constexpr const char suffix[] = WINDOWS_ONLY(\".exe\") NOT_WINDOWS(\"\");\n+#ifndef S_ISREG\n+# define S_ISREG(__mode) (((__mode) & S_IFMT) == S_IFREG)\n+#endif \/\/ S_ISREG\n+  struct stat st;\n+\n+  \/\/ Try to interpret as an executable name with \"engine\" suffix omitted\n+  size_t path_len = strlen(dll_dir) + strlen(os::file_separator()) + strlen(CRaCEngine) + strlen(\"engine\") + strlen(suffix);\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%sengine%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n+    }\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine an executable name with 'engine' omitted: path is too long\");\n+  }\n+\n+  \/\/ Try to interpret as an executable name\n+  precond(path_len > strlen(\"engine\"));\n+  path_len -= strlen(\"engine\");\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%s%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n+    }\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine as an executable name: path is too long\");\n+  }\n+\n+  return false;\n+}\n+\n+static bool configure_image_location(const crlib_api_t &api, crlib_conf_t *conf, const char *image_location) {\n+  precond(image_location != nullptr && image_location[0] != '\\0');\n+  if (!api.configure(conf, engine_opt_image_location, image_location)) {\n+    log_error(crac)(\"CRaC engine failed to configure: '%s' = '%s'\", engine_opt_image_location, image_location);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ These functions are used in a template instantiation and need to have external linkage. Otherwise\n+\/\/ Windows-debug build fails with linkage errors for the instantiation's symbols.\n+class CStringUtils : public AllStatic {\n+public:\n+  static unsigned int hash(const char * const &s) {\n+    unsigned int h = 0;\n+    for (const char *p = s; *p != '\\0'; p++) {\n+      h = 31 * h + *p;\n+    }\n+    return h;\n+  }\n+\n+  static bool equals(const char * const &s0, const char * const &s1) {\n+    return strcmp(s0, s1) == 0;\n+  }\n+};\n+\n+\/\/ Have to use C-heap because resource area may yet be unavailable when this is used\n+using CStringSet = HashTable<const char *, bool, 256, AnyObj::C_HEAP, MemTag::mtInternal,\n+                             CStringUtils::hash, CStringUtils::equals>;\n+\n+static crlib_conf_t *create_conf(const crlib_api_t &api, const char *exec_location) {\n+  crlib_conf_t * const conf = api.create_conf();\n+  if (conf == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to create its configuration\");\n+    return nullptr;\n+  }\n+\n+  if (CRaCEngineOptions != nullptr && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    return conf;\n+  }\n+\n+  if (exec_location != nullptr) { \/\/ Only passed when using crexec\n+    guarantee(api.can_configure(conf, engine_opt_exec_location),\n+              \"crexec does not support expected option: %s\", engine_opt_exec_location);\n+    if (!api.configure(conf, engine_opt_exec_location, exec_location)) {\n+      log_error(crac)(\"crexec failed to configure: '%s' = '%s'\", engine_opt_exec_location, exec_location);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+  }\n+\n+  if (CRaCEngineOptions == nullptr || CRaCEngineOptions[0] == '\\0' \/* possible for ccstrlist *\/) {\n+    return conf;\n+  }\n+\n+  CStringSet vm_controlled_keys;\n+#define PUT_CONTROLLED_KEY(opt) vm_controlled_keys.put_when_absent(engine_opt_##opt, false);\n+  VM_CONTROLLED_ENGINE_OPTS(PUT_CONTROLLED_KEY)\n+#undef PUT_CONTROLLED_KEY\n+\n+  char *engine_options = os::strdup_check_oom(CRaCEngineOptions, mtInternal);\n+  char *const engine_options_start = engine_options;\n+  CStringSet keys;\n+  do {\n+    char *key_value = strsep(&engine_options, \",\\n\"); \/\/ '\\n' appears when ccstrlist is appended to\n+    const char *key = strsep(&key_value, \"=\");\n+    const char *value = key_value != nullptr ? key_value : \"\";\n+    assert(key != nullptr, \"Should have terminated before\");\n+    if (vm_controlled_keys.contains(key)) {\n+      log_warning(crac)(\"VM-controlled CRaC engine option provided, skipping: %s\", key);\n+      continue;\n+    }\n+    {\n+      bool is_new_key;\n+      keys.put_if_absent(key, &is_new_key);\n+      if (!is_new_key) {\n+        log_warning(crac)(\"CRaC engine option '%s' specified multiple times\", key);\n+      }\n+    }\n+    if (!api.configure(conf, key, value)) {\n+      log_error(crac)(\"CRaC engine failed to configure: '%s' = '%s'\", key, value);\n+      os::free(engine_options_start);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+    log_debug(crac)(\"CRaC engine option: '%s' = '%s'\", key, value);\n+  } while (engine_options != nullptr);\n+  os::free(engine_options_start);\n+\n+  return conf;\n+}\n+\n+CracEngine::CracEngine() {\n+  if (CRaCEngine == nullptr) {\n+    log_error(crac)(\"CRaCEngine must not be empty\");\n+    return;\n+  }\n+\n+  \/\/ Arguments::get_dll_dir() might not have been initialized yet\n+  char dll_dir[JVM_MAXPATHLEN];\n+  os::jvm_path(dll_dir, sizeof(dll_dir));\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n+  \/\/ for static JDK, the path or \"...\/bin\/java\", or \"...\\bin\\java.exe\"\n+  char *after_elem = nullptr;\n+  for (int i = 0; i < 2; ++i) {\n+    after_elem = strrchr(dll_dir, *os::file_separator());\n+    *after_elem = '\\0';\n+  }\n+  if (is_vm_statically_linked()) {\n+    strcat(dll_dir, os::file_separator());\n+#ifdef _WINDOWS\n+    strcat(dll_dir, \"bin\");\n+#else\n+    strcat(dll_dir, \"lib\");\n+#endif\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  bool is_library;\n+  if (!find_engine(dll_dir, path, sizeof(path), &is_library)) {\n+    log_error(crac)(\"Cannot find CRaC engine %s\", CRaCEngine);\n+    return;\n+  }\n+  postcond(path[0] != '\\0');\n+\n+  bool is_static_crexec = false; \/\/ true when using statically linked crexec\n+\n+  char exec_path[JVM_MAXPATHLEN] = \"\\0\";\n+  if (!is_library) {\n+    strcpy(exec_path, path); \/\/ Save to later pass it to crexec\n+    if (is_vm_statically_linked()) {\n+      is_static_crexec = true;\n+      os::jvm_path(path, sizeof(path)); \/\/ points to bin\/java for static JDK\n+    } else if (!os::dll_locate_lib(path, sizeof(path), dll_dir, \"crexec\")) {\n+      log_error(crac)(\"Cannot find crexec library to use CRaCEngine executable\");\n+      return;\n+    }\n+  }\n+\n+  char error_buf[1024];\n+  void * const lib = is_static_crexec ? os::get_default_process_handle() : os::dll_load(path, error_buf, sizeof(error_buf));\n+  if (lib == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library from %s: %s\", path, error_buf);\n+    return;\n+  }\n+\n+  using api_func_t = decltype(&CRLIB_API);\n+  const auto api_func = reinterpret_cast<api_func_t>(os::dll_lookup(lib, CRLIB_API_FUNC));\n+  if (api_func == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library entrypoint '\" CRLIB_API_FUNC \"' from %s\", path);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  crlib_api_t * const api = api_func(CRLIB_API_VERSION, sizeof(crlib_api_t));\n+  if (api == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to initialize its API (version %i). \"\n+                    \"Maybe this version is not supported?\", CRLIB_API_VERSION);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+  if (api->create_conf == nullptr || api->destroy_conf == nullptr ||\n+      api->checkpoint == nullptr || api->restore == nullptr ||\n+      api->can_configure == nullptr || api->configure == nullptr ||\n+      api->get_extension == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid API\");\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  const char *exec_location = exec_path[0] != '\\0' ? exec_path : nullptr;\n+  crlib_conf_t * const conf = create_conf(*api, exec_location);\n+  if (conf == nullptr) {\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  _lib = lib;\n+  _api = api;\n+  _conf = conf;\n+}\n+\n+CracEngine::~CracEngine() {\n+  if (is_initialized()) {\n+    _api->destroy_conf(_conf);\n+    os::dll_unload(_lib);\n+  }\n+}\n+\n+bool CracEngine::is_initialized() const {\n+  assert((_lib == nullptr && _api == nullptr && _conf == nullptr) ||\n+          (_lib != nullptr && _api != nullptr && _conf != nullptr), \"invariant\");\n+  return _lib != nullptr;\n+}\n+\n+int CracEngine::checkpoint() const {\n+  precond(is_initialized());\n+  return _api->checkpoint(_conf);\n+}\n+\n+int CracEngine::restore() const {\n+  precond(is_initialized());\n+  return _api->restore(_conf);\n+}\n+\n+bool CracEngine::configure_image_location(const char *image_location) const {\n+  precond(is_initialized());\n+  return ::configure_image_location(*_api, _conf, image_location);\n+}\n+\n+GrowableArrayCHeap<const char *, MemTag::mtInternal> *CracEngine::vm_controlled_options() const {\n+  auto * const opts = new GrowableArrayCHeap<const char *, MemTag::mtInternal>();\n+  \/\/ Only list those options which the current engine actually supports\n+  for (const char *opt : vm_controlled_engine_opts) {\n+    if (_api->can_configure(_conf, opt)) {\n+      opts->append(opt);\n+    }\n+  }\n+  return opts;\n+}\n+\n+#define prepare_extension_api(_ext_api, ext_name) \\\n+  precond(is_initialized()); \\\n+  if (_ext_api != nullptr) { \\\n+    return ApiStatus::OK; \\\n+  } \\\n+  auto const ext_api = CRLIB_EXTENSION(_api, std::remove_reference<decltype(*_ext_api)>::type, ext_name); \\\n+  if (ext_api == nullptr) { \\\n+    log_debug(crac)(\"CRaC engine does not support extension \" ext_name); \\\n+    return ApiStatus::UNSUPPORTED; \\\n+  } \\\n+  constexpr const char *_ext_name = ext_name;\n+\n+#define require_method(_func) \\\n+  if (ext_api->_func == nullptr) { \\\n+    log_error(crac)(\"CRaC engine provided invalid API for extension %s: %s is not set\", _ext_name, #_func); \\\n+    return ApiStatus::ERR; \\\n+  }\n+\n+#define complete_extension_api(_ext_api) \\\n+  _ext_api = ext_api; \\\n+  return ApiStatus::OK;\n+\n+CracEngine::ApiStatus CracEngine::prepare_restore_data_api() {\n+  prepare_extension_api(_restore_data_api, CRLIB_EXTENSION_RESTORE_DATA_NAME)\n+  require_method(set_restore_data)\n+  require_method(get_restore_data)\n+  complete_extension_api(_restore_data_api)\n+}\n+\n+bool CracEngine::set_restore_data(const void *data, size_t size) const {\n+  precond(_restore_data_api != nullptr);\n+  return _restore_data_api->set_restore_data(_conf, data, size);\n+}\n+\n+size_t CracEngine::get_restore_data(void *buf, size_t size) const {\n+  precond(_restore_data_api != nullptr);\n+  return _restore_data_api->get_restore_data(_conf, buf, size);\n+}\n+\n+CracEngine::ApiStatus CracEngine::prepare_description_api() {\n+  prepare_extension_api(_description_api, CRLIB_EXTENSION_DESCRIPTION_NAME)\n+  require_method(identity)\n+  require_method(description)\n+  require_method(configuration_doc)\n+  require_method(configurable_keys)\n+  require_method(supported_extensions)\n+  complete_extension_api(_description_api)\n+}\n+\n+const char *CracEngine::description() const {\n+  precond(_description_api != nullptr);\n+  return _description_api->description(_conf);\n+}\n+\n+const char *CracEngine::configuration_doc() const {\n+  precond(_description_api != nullptr);\n+  return _description_api->configuration_doc(_conf);\n+}\n+\n+static constexpr char cpuarch_name[] = \"cpu.arch\";\n+static constexpr char cpufeatures_name[] = \"cpu.features\";\n+\n+CracEngine::ApiStatus CracEngine::prepare_image_constraints_api() {\n+  prepare_extension_api(_image_constraints_api, CRLIB_EXTENSION_IMAGE_CONSTRAINTS_NAME)\n+  require_method(set_label)\n+  require_method(set_bitmap)\n+  require_method(require_label)\n+  require_method(require_bitmap)\n+  require_method(is_failed)\n+  complete_extension_api(_image_constraints_api)\n+}\n+\n+\/\/ Return success.\n+bool CracEngine::store_cpuinfo(const VM_Version::VM_Features *datap) const {\n+  log_debug(crac)(\"store cpu.arch & cpu.features to %s...\", CRaCRestoreFrom);\n+  if (!_image_constraints_api->set_label(_conf, cpuarch_name, ARCHPROPNAME)) {\n+    log_error(crac)(\"CRaC engine failed to record label %s\", cpuarch_name);\n+    return false;\n+  }\n+  if (!_image_constraints_api->set_bitmap(_conf, cpufeatures_name, reinterpret_cast<const unsigned char *>(datap), sizeof(*datap))) {\n+    log_error(crac)(\"CRaC engine failed to record bitmap %s\", cpufeatures_name);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+void CracEngine::require_cpuinfo(const VM_Version::VM_Features *datap, bool exact) const {\n+  log_debug(crac)(\"cpufeatures_load user data %s from %s...\", cpufeatures_name, CRaCRestoreFrom);\n+  _image_constraints_api->require_label(_conf, cpuarch_name, ARCHPROPNAME);\n+  _image_constraints_api->require_bitmap(_conf, cpufeatures_name,\n+    reinterpret_cast<const unsigned char *>(datap), sizeof(*datap), exact ? EQUALS : SUBSET);\n+}\n+\n+void CracEngine::check_cpuinfo(const VM_Version::VM_Features *datap) const {\n+  if (_image_constraints_api == nullptr) {\n+    \/\/ When CPU features are ignored\n+    return;\n+  }\n+  if (_image_constraints_api->is_failed(_conf, cpuarch_name)) {\n+    log_error(crac)(\"Restore failed due to wrong or missing CPU architecture (current architecture is \" ARCHPROPNAME \")\");\n+  }\n+  if (_image_constraints_api->is_failed(_conf, cpufeatures_name)) {\n+    ResourceMark rm;\n+    log_error(crac)(\"Restore failed due to incompatible or missing CPU features, try using -XX:CPUFeatures=%s on checkpoint.\", datap->print_numbers());\n+  }\n+}\n+\n+bool CracEngine::set_label(const char* label, const char* value) {\n+  return _image_constraints_api->set_label(_conf, label, value);\n+}\n+\n+CracEngine::ApiStatus CracEngine::prepare_image_score_api() {\n+  prepare_extension_api(_image_score_api, CRLIB_EXTENSION_IMAGE_SCORE_NAME)\n+  require_method(set_score)\n+  complete_extension_api(_image_score_api)\n+}\n+\n+bool CracEngine::set_score(const char* metric, double value) {\n+  return _image_score_api->set_score(_conf, metric, value);\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":472,"deletions":0,"binary":false,"changes":472,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+#define SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+\n+#include \"jvm.h\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#ifdef LINUX\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+#endif\n+\n+struct CracFailDep {\n+  int _type;\n+  char* _msg;\n+  CracFailDep(int type, char* msg) :\n+    _type(type),\n+    _msg(msg)\n+  { }\n+  CracFailDep() :\n+    _type(JVM_CR_FAIL),\n+    _msg(nullptr)\n+  { }\n+};\n+\n+class CracRestoreParameters : public CHeapObj<mtInternal> {\n+  char* _raw_content;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  struct header {\n+    jlong _restore_time;\n+    jlong _restore_nanos;\n+    int _nflags;\n+    int _nprops;\n+    int _env_memory_size;\n+  };\n+\n+  static bool write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  static int system_props_length(const SystemProperty* props) {\n+    int len = 0;\n+    while (props != nullptr) {\n+      ++len;\n+      props = props->next();\n+    }\n+    return len;\n+  }\n+\n+  static int env_vars_size(const char* const * env) {\n+    int len = 0;\n+    for (; *env; ++env) {\n+      len += (int)strlen(*env) + 1;\n+    }\n+    return len;\n+  }\n+\n+ public:\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  CracRestoreParameters() :\n+    _raw_content(nullptr),\n+    _properties(new (mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(nullptr)\n+  {}\n+\n+  ~CracRestoreParameters() {\n+    if (_raw_content) {\n+      FREE_C_HEAP_ARRAY(char, _raw_content);\n+    }\n+    delete _properties;\n+  }\n+\n+  static bool write_to(int fd,\n+      const char* const* flags, int num_flags,\n+      const SystemProperty* props,\n+      const char *args,\n+      jlong restore_time,\n+      jlong restore_nanos) {\n+    header hdr = {\n+      restore_time,\n+      restore_nanos,\n+      num_flags,\n+      system_props_length(props),\n+      env_vars_size(os::get_environ())\n+    };\n+\n+    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < num_flags; ++i) {\n+      if (!write_check_error(fd, flags[i], (int)strlen(flags[i]) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    const SystemProperty* p = props;\n+    while (p != nullptr) {\n+      char prop[4096];\n+      int len = os::snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n+      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n+      if (!write_check_error(fd, prop, len+1)) {\n+        return false;\n+      }\n+      p = p->next();\n+    }\n+\n+    \/\/ Write env vars\n+    for (char** env = os::get_environ(); *env; ++env) {\n+      if (!write_check_error(fd, *env, (int)strlen(*env) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    return write_check_error(fd, args, (int)strlen(args)+1); \/\/ +1 for null char\n+  }\n+\n+  bool read_from(int fd);\n+\n+};\n+\n+class VM_Crac: public VM_Operation {\n+  jarray _fd_arr;\n+  const bool _dry_run;\n+  bool _ok;\n+  GrowableArray<CracFailDep>* _failures;\n+  CracRestoreParameters _restore_parameters;\n+  outputStream* _ostream;\n+#if defined(LINUX) && INCLUDE_SERVICES\n+  PosixAttachOperation* _attach_op;\n+#endif \/\/ LINUX && INCLUDE_SERVICES\n+\n+public:\n+  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n+    _fd_arr(fd_arr),\n+    _dry_run(dry_run),\n+    _ok(false),\n+    _failures(new (mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n+    _restore_parameters(),\n+    _ostream(jcmd_stream ? jcmd_stream : tty)\n+#if defined(LINUX) && INCLUDE_SERVICES\n+    , _attach_op(jcmd_stream ? PosixAttachListener::get_current_op() : nullptr)\n+#endif \/\/ LINUX && INCLUDE_SERVICES\n+  { }\n+\n+  ~VM_Crac() {\n+    delete _failures;\n+  }\n+\n+  GrowableArray<CracFailDep>* failures() { return _failures; }\n+  bool ok() { return _ok; }\n+  const char* new_args() { return _restore_parameters.args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n+  virtual bool allow_nested_vm_operations() const  { return true; }\n+  VMOp_Type type() const { return VMOp_VM_Crac; }\n+  void doit();\n+  bool read_shm(int shmid);\n+\n+private:\n+  bool is_claimed_fd(int fd);\n+  bool is_socket_from_jcmd(int sock_fd);\n+  void report_ok_to_jcmd_if_any();\n+  void print_resources(const char* msg, ...);\n+  bool check_fds();\n+  bool memory_checkpoint();\n+  void memory_restore();\n+};\n+\n+class CracSHM {\n+  char _path[128];\n+public:\n+  CracSHM(int id) {\n+    int shmpathlen = os::snprintf(_path, sizeof(_path), \"%s\/crac_%d\", os::get_temp_directory(), id);\n+    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n+      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    }\n+  }\n+\n+  int open(int flags) {\n+    int fd = os::open(_path, flags, 0600);\n+    if (-1 == fd) {\n+      log_error(crac)(\"Cannot %s shared object %s: %s\", flags & O_CREAT ? \"create\" : \"open\", _path, os::strerror(errno));\n+    }\n+    return fd;\n+  }\n+\n+  void unlink() {\n+    if (::remove(_path)) {\n+      log_error(crac)(\"Cannot remove shared object %s: %s\", _path, os::strerror(errno));\n+    }\n+  }\n+};\n+\n+#endif \/\/SHARE_RUNTIME_CRAC_STRUCTS_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac_structs.hpp","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -1818,1 +1818,1 @@\n-    nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER);\n+    nm->make_not_entrant(nmethod::InvalidationReason::MISSING_EXCEPTION_HANDLER, true \/* OK to recompile *\/);\n@@ -2464,1 +2464,1 @@\n-      if (!nm->make_not_entrant(nmethod::InvalidationReason::UNCOMMON_TRAP)) {\n+      if (!nm->make_not_entrant(nmethod::InvalidationReason::UNCOMMON_TRAP, true \/* OK to recompile *\/)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -337,0 +337,1 @@\n+    { KIND_RESTORE_SETTABLE, \"restore\" },\n@@ -401,0 +402,2 @@\n+    case JVMFlagOrigin::CRAC_RESTORE:\n+      st->print(\"crac restore\");\n@@ -508,3 +511,4 @@\n-const int DIAGNOSTIC   = JVMFlag::KIND_DIAGNOSTIC;\n-const int MANAGEABLE   = JVMFlag::KIND_MANAGEABLE;\n-const int EXPERIMENTAL = JVMFlag::KIND_EXPERIMENTAL;\n+const int DIAGNOSTIC       = JVMFlag::KIND_DIAGNOSTIC;\n+const int MANAGEABLE       = JVMFlag::KIND_MANAGEABLE;\n+const int EXPERIMENTAL     = JVMFlag::KIND_EXPERIMENTAL;\n+const int RESTORE_SETTABLE = JVMFlag::KIND_RESTORE_SETTABLE;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  CRAC_RESTORE     = 9,\n@@ -51,1 +52,1 @@\n-ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::JIMAGE_RESOURCE)\n+ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::CRAC_RESTORE)\n@@ -73,0 +74,1 @@\n+    KIND_RESTORE_SETTABLE   = 1 << 15,\n@@ -250,0 +252,1 @@\n+  bool is_restore_settable() const { return (_flags & (KIND_RESTORE_SETTABLE | KIND_MANAGEABLE)) != 0; }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n-\/\/ only with product\/product_pd flags.\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, MANAGEABLE or RESTORE_SETTABLE. Currently\n+\/\/ extra_attrs can be used only with product\/product_pd flags.\n@@ -100,0 +100,3 @@\n+\/\/ RESTORE_SETTABLE are flags that can be set during restore from a snapshot.\n+\/\/    All MANAGEABLE flags are implicitly RESTORE_SETTABLE but\n+\/\/    RESTORE_SETTABLE are not MANAGEABLE.\n@@ -172,1 +175,2 @@\n-  product(bool, UnlockDiagnosticVMOptions, trueInDebug, DIAGNOSTIC,         \\\n+  product(bool, UnlockDiagnosticVMOptions, trueInDebug,                     \\\n+          DIAGNOSTIC | RESTORE_SETTABLE,                                    \\\n@@ -175,1 +179,2 @@\n-  product(bool, UnlockExperimentalVMOptions, false, EXPERIMENTAL,           \\\n+  product(bool, UnlockExperimentalVMOptions, false,                         \\\n+          EXPERIMENTAL | RESTORE_SETTABLE,                                  \\\n@@ -1000,1 +1005,1 @@\n-  product(bool, IgnoreUnrecognizedVMOptions, false,                         \\\n+  product(bool, IgnoreUnrecognizedVMOptions, false, RESTORE_SETTABLE,       \\\n@@ -1025,1 +1030,1 @@\n-  product(bool, LogVMOutput, false, DIAGNOSTIC,                             \\\n+  product(bool, LogVMOutput, false, DIAGNOSTIC | RESTORE_SETTABLE,          \\\n@@ -1028,1 +1033,1 @@\n-  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                              \\\n+  product(ccstr, LogFile, nullptr, DIAGNOSTIC | RESTORE_SETTABLE,           \\\n@@ -1945,1 +1950,1 @@\n-  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                    \\\n+  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr, RESTORE_SETTABLE,  \\\n@@ -1959,0 +1964,90 @@\n+  product(ccstr, CRaCCheckpointTo, nullptr, RESTORE_SETTABLE,               \\\n+          \"Path where the checkpoint image should be placed. Currently an \" \\\n+          \"image is a directory, the directory will be created if it does \" \\\n+          \"not exist (parent directories are not created) or overwritten \"  \\\n+          \"otherwise. The path can contain placeholders (e.g. %p for PID);\" \\\n+          \" check documentation for pattern format.\")                       \\\n+                                                                            \\\n+  product(ccstr, CRaCRestoreFrom, nullptr, RESTORE_SETTABLE,                \\\n+          \"Path to the image to restore from.\")                             \\\n+                                                                            \\\n+  product(uint, CRaCMinPid, 128,                                            \\\n+          \"Mininal PID value for checkpointed process (POSIX only)\")        \\\n+          range(1, UINT_MAX)                                                \\\n+                                                                            \\\n+  product(bool, CRaCResetStartTime, true, DIAGNOSTIC | RESTORE_SETTABLE,    \\\n+          \"Reset JVM's start time and uptime on restore\")                   \\\n+                                                                            \\\n+  product_pd(ccstr, CRaCEngine, RESTORE_SETTABLE,                           \\\n+          \"Path or name of a program or a shared library implementing \"     \\\n+          \"checkpoint and restore. On restore this option applies only to \" \\\n+          \"the restoring VM, i.e. the restored VM keeps the value it had \"  \\\n+          \"before the checkpoint.\")                                         \\\n+                                                                            \\\n+  product(ccstrlist, CRaCEngineOptions, nullptr, RESTORE_SETTABLE,          \\\n+          \"Options passed to CRaCEngine, in the form of 'key1=value,key2'. \"\\\n+          \"The list of supported options is engine-dependent, use \"         \\\n+          \"'-XX:CRaCEngineOptions=help' to make the VM print information \"  \\\n+          \"about the engine, including its supported options, and exit. On \"\\\n+          \"restore this option applies only to the restoring VM, i.e. the \" \\\n+          \"restored VM keeps the value it had before the checkpoint.\")      \\\n+                                                                            \\\n+  product(bool, CRaCIgnoreRestoreIfUnavailable, false, RESTORE_SETTABLE,    \\\n+          \"If the image selected via CRaCRestoreFrom is identified as \"     \\\n+          \"being unusable, continue initializing the JVM instead of \"       \\\n+          \"failing. Enabling this option does not guarantee that the \"      \\\n+          \"initialization will continue after any failed restoration \"      \\\n+          \"attempt; it only covers an early image\/environment \"             \\\n+          \"verification.\")                                                  \\\n+                                                                            \\\n+  product(ccstr, CRaCIgnoredFileDescriptors, nullptr, RESTORE_SETTABLE,     \\\n+          \"Comma-separated list of file descriptor numbers or paths. All \"  \\\n+          \"file descriptors greater than 2 (stdin, stdout and stderr are \"  \\\n+          \"excluded automatically) not in this list are closed when the VM \"\\\n+          \"is started. (Linux only)\")                                       \\\n+                                                                            \\\n+  product_pd(ccstrlist, CRaCAllowedOpenFilePrefixes, \"List of path \"        \\\n+          \"prefixes for files that can be open during checkpoint. CRaC \"    \\\n+          \"will not error upon detecting these and will leave the handling \"\\\n+          \"up to the engine. This option applies only to files opened by \"  \\\n+          \"native code and is Linux only; for files opened by Java code \"   \\\n+          \"use -Djdk.crac.resource-policies=...\")                           \\\n+                                                                            \\\n+  product(bool, CRaCSkipCheckpoint, false, DIAGNOSTIC,                      \\\n+          \"On checkpoint, skip calling CRaC engine and restore immediately\")\\\n+                                                                            \\\n+  product(bool, CRaCHeapDumpOnCheckpointException, false, DIAGNOSTIC,       \\\n+          \"Dump heap on CheckpointException thrown because of a low-level \" \\\n+          \"CRaC precondition failing\")                                      \\\n+                                                                            \\\n+  product(bool, CRaCPrintResourcesOnCheckpoint, false, DIAGNOSTIC,          \\\n+          \"Print low-level resources checked by VM before checkpoint\")      \\\n+                                                                            \\\n+  product(bool, CRaCTraceStartupTime, false, DIAGNOSTIC,                    \\\n+          \"Print the time at which the VM-level restore starts\")            \\\n+                                                                            \\\n+  product(bool, CRaCPauseOnCheckpointError, false, DIAGNOSTIC,              \\\n+          \"Pauses the checkpoint when a problem is found on VM level.\")     \\\n+                                                                            \\\n+  product(size_t, CRaCMaxHeapSizeBeforeCheckpoint, 0, \"Maximum size \"       \\\n+          \"of heap before checkpoint. By default equals to -Xmx.\")          \\\n+                                                                            \\\n+  product(ccstr, CPUFeatures, nullptr, \"CPU feature set, \"                  \\\n+          \"Limit set of CPU features to make the CRaC image compatible \"    \\\n+          \"for running on a machine with different CPU:\"                    \\\n+          \"native: use all available features (default), \"                  \\\n+          \"generic: compatible with most CPUs, \"                            \\\n+          \"ignore: do not store CPU features at all, \"                      \\\n+          \"<arch-specific>: use -XX:+ShowCPUFeatures to find a suitable \"   \\\n+          \"architecture-specific string, e.g. 0xnumber,0xnumber on x86_64.\")\\\n+                                                                            \\\n+  product(bool, ShowCPUFeatures, false, \"Show features of this CPU \"        \\\n+          \"to be possibly used for the -XX:CPUFeatures=0xnumber option\")    \\\n+                                                                            \\\n+  product(ccstr, CheckCPUFeatures, nullptr, RESTORE_SETTABLE,               \\\n+          \"Set requirements for CPU features check: \"                       \\\n+          \"compatible: image must be runnable on this CPU (default), \"      \\\n+          \"exact: image must use the very same features as this CPU, \"      \\\n+          \"skip: don't check features at all (requires \"                    \\\n+          \"-XX:+UnlockExperimentalVMOptions).\")                             \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":103,"deletions":8,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1327,1 +1327,1 @@\n-      nm->make_not_entrant(nmethod::InvalidationReason::ZOMBIE);\n+      nm->make_not_entrant(nmethod::InvalidationReason::ZOMBIE, false \/* don't interfere with testing\/debugging *\/);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1272,0 +1272,1 @@\n+  void wakeup_sleep() { _SleepEvent->unpark(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2313,0 +2313,9 @@\n+void os::cleanup_memory(char* addr, size_t bytes) {\n+  char* start = (char*)align_up(addr, os::vm_page_size());\n+  char* end = (char*)align_down(addr + bytes, os::vm_page_size());\n+  if (start < end) {\n+    os::uncommit_memory(start, end - start);\n+    os::commit_memory(start, end - start, false);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -294,0 +294,2 @@\n+  \/\/ Before restore returns the same value as elapsed_counter()\n+  static jlong elapsed_counter_since_restore();\n@@ -491,0 +493,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n@@ -611,0 +615,1 @@\n+  static void reset_cached_process_id();\n@@ -650,0 +655,2 @@\n+  static int execv(const char *path, const char *argv[]);\n+\n@@ -714,0 +721,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -717,0 +727,2 @@\n+  static bool           is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -453,0 +454,8 @@\n+#ifdef __APPLE__\n+  \/\/ BSD clock would be initialized in os::init() but we need to do that earlier\n+  \/\/ as crac::prepare_restore() calls os::javaTimeNanos().\n+  os::Bsd::clock_init();\n+#endif\n+  crac::crac_restore_data restore_data;\n+  crac::prepare_restore(restore_data);\n+\n@@ -523,0 +532,2 @@\n+  crac::vm_create_start();\n+\n@@ -614,0 +625,12 @@\n+  \/\/ Output stream module should be already initialized for error reporting during restore.\n+  \/\/ JDK version should also be intialized. There is lot of initializations needed to read\n+  \/\/ the current machine's CPUFeatures.\n+  if (CRaCRestoreFrom) {\n+    crac::restore(restore_data);\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      log_error(crac)(\"Failed to restore from %s\", CRaCRestoreFrom);\n+      return JNI_ERR;\n+    }\n+  }\n+  Arguments::free_restore_only_data(); \/\/ Not needed anymore\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+  template(VM_Crac)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1795,0 +1795,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,0 +24,4 @@\n+#include <clocale>\n+#ifdef _ALLBSD_SOURCE\n+#include <xlocale.h>\n+#endif \/\/ _ALLBSD_SOURCE\n@@ -53,0 +57,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -72,0 +77,5 @@\n+#include \"utilities\/stringUtils.hpp\"\n+#if INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n@@ -156,0 +166,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export));\n+\n@@ -1073,0 +1085,177 @@\n+CheckpointDCmd::CheckpointDCmd(outputStream* output, bool heap) :\n+  DCmdWithParser(output, heap),\n+  _metrics(\"metrics\", \"Extra image metrics to record (key1=value2,key2=value2,... or @\/path\/to\/file)\", \"STRING\", false),\n+  _labels(\"labels\", \"Extra labels to record (label1=value1,label2=value2,... or @\/path\/to\/file)\", \"STRING\", false) {\n+  _dcmdparser.add_dcmd_option(&_metrics);\n+  _dcmdparser.add_dcmd_option(&_labels);\n+}\n+\n+struct LocaleGuard {\n+#ifndef _WINDOWS\n+  locale_t _new, _old;\n+  LocaleGuard(): _new(newlocale(LC_ALL_MASK, \"C\", 0)), _old(uselocale(_new)) {}\n+#else\n+  LocaleGuard() {}\n+#endif \/\/ _WINDOWS\n+  ~LocaleGuard() {\n+#ifndef _WINDOWS\n+    uselocale(_old);\n+    freelocale(_new);\n+#endif \/\/ _WINDOWS\n+  }\n+};\n+\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  const char *metrics = _metrics.value();\n+  if (metrics != nullptr) {\n+    if (crac::is_image_score_supported()) {\n+      \/\/ This guard ensures that we are parsing the floating point values\n+      \/\/ with '.' as the decimal point (some other locales use ',')\n+      LocaleGuard lg;\n+      if (metrics[0] == '@') {\n+        if (!parse_pairs_from_file(\"metric\", metrics + 1, CheckpointDCmd::accept_metric)) {\n+          return;\n+        }\n+      } else {\n+        if (!parse_pairs(\"metric\", metrics, CheckpointDCmd::accept_metric)) {\n+          return;\n+        }\n+      }\n+    } else {\n+      output()->print_cr(\"Warning: metrics are not supported by current C\/R engine\");\n+    }\n+  }\n+  const char *labels = _labels.value();\n+  if (labels != nullptr) {\n+    if (crac::is_image_constraints_supported()) {\n+      if (labels[0] == '@') {\n+        if (!parse_pairs_from_file(\"label\", labels + 1, CheckpointDCmd::accept_label)) {\n+          return;\n+        }\n+      } else {\n+        if (!parse_pairs(\"label\", labels, CheckpointDCmd::accept_label)) {\n+          return;\n+        }\n+      }\n+    } else {\n+      output()->print_cr(\"Warning: labels are not supported by current C\/R engine\");\n+    }\n+  }\n+\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_crac_mirror_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::checkpointRestoreInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != nullptr) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      outputStream* stream = output();\n+#if INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+      assert(PosixAttachListener::get_current_op(), \"should exist\");\n+      if (PosixAttachListener::get_current_op()->is_effectively_completed()) {\n+        stream = tty;\n+      }\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+      stream->print_cr(\"An exception during a checkpoint operation:\");\n+      stream->print(\"%s\", out);\n+    }\n+  }\n+}\n+\n+bool CheckpointDCmd::accept_metric(CheckpointDCmd* self, const char* key, char* str) {\n+  char *endptr;\n+  double value = strtod(str, &endptr);\n+  while (isspace(*endptr)) ++endptr;\n+  if (*endptr) {\n+    self->output()->print_cr(\"Cannot convert '%s' into double value for metric '%s'\", str, key);\n+    return false;\n+  }\n+  if (!crac::record_image_score(key, value)) {\n+    self->output()->print_cr(\"Cannot record metric %s=%f\", key, value);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool CheckpointDCmd::accept_label(CheckpointDCmd* self, const char* key, char* str) {\n+  while (isspace(*str)) ++str;\n+  char *end = str + strlen(str) - 1;\n+  while (end >= str && isspace(*end)) {\n+    *end = '\\0';\n+    --end;\n+  }\n+  if (!crac::record_image_label(key, str)) {\n+    self->output()->print_cr(\"Cannot record label %s=%s\", key, str);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool CheckpointDCmd::parse_pairs(const char* what, const char* str, accept_func accept) {\n+  ResourceMark rm;\n+  size_t len = strlen(str);\n+  char *copy = strcpy(NEW_RESOURCE_ARRAY(char, len + 1), str);\n+  char *key_value;\n+  while ((key_value = strsep(&copy, \",\")) != nullptr) {\n+    char *key = strsep(&key_value, \"=\");\n+    if (*key == '\\0') {\n+      output()->print_cr(\"Empty %s name\", what);\n+      return false;\n+    }\n+    if (key_value == nullptr) {\n+      output()->print_cr(\"Missing value for %s '%s'\", what, key);\n+      return false;\n+    }\n+    if (!accept(this, key, key_value)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool CheckpointDCmd::parse_pairs_from_file(const char* what, const char* path, accept_func accept) {\n+  FILE *file = os::fopen(path, \"r\");\n+  if (file == nullptr) {\n+    output()->print_cr(\"Cannot open %s: %s\", path, os::strerror(errno));\n+    return false;\n+  }\n+  struct FileCloser: StackObj {\n+    FILE *_file;\n+    FileCloser(FILE *f): _file(f) {}\n+    ~FileCloser() { fclose(_file); }\n+  } closer(file);\n+  char linebuf[1024];\n+  for (int linenum = 1; fgets(linebuf, sizeof(linebuf), file); ++linenum) {\n+    char *line = linebuf;\n+    size_t line_length = strlen(line);\n+    if (line_length >= sizeof(linebuf) - 1 && line[line_length - 1] != '\\n') {\n+      output()->print_cr(\"Line %d starting with '%s' is too long\", linenum, line);\n+      return false;\n+    } else if (line[line_length - 1] == '\\n') {\n+      \/\/ don't print newline in error message\n+      line[line_length - 1] = '\\0';\n+    }\n+    char *key = strsep(&line, \"=\");\n+    if (line == nullptr) {\n+      output()->print_cr(\"Invalid line %d in %s (no '=' separator)\", linenum, path);\n+      return false;\n+    }\n+    \/\/ truncate whitespace in key\n+    while (isspace(*key)) ++key;\n+    for (char *end = line - 2; end >= key && isspace(*end); --end) *end = '\\0';\n+    if (*key == '\\0') {\n+      output()->print_cr(\"Empty %s name\", what);\n+      return false;\n+    }\n+    if (!accept(this, key, line)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":189,"deletions":0,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -872,0 +872,25 @@\n+class CheckpointDCmd : public DCmdWithParser {\n+  DCmdArgument<char*> _metrics;\n+  DCmdArgument<char*> _labels;\n+\n+public:\n+  CheckpointDCmd(outputStream* output, bool heap);\n+  static const char* name() { return \"JDK.checkpoint\"; }\n+  static const char* description() {\n+    return \"Initiates a CRaC checkpoint.\";\n+  }\n+  static const char* impact() {\n+    return \"High: JVM terminates\";\n+  }\n+  static int num_arguments() { return 2; }\n+  virtual void execute(DCmdSource source, TRAPS);\n+\n+private:\n+  typedef bool (*accept_func)(CheckpointDCmd*, const char*, char*);\n+\n+  bool parse_pairs(const char* what, const char* pairs, accept_func accept);\n+  bool parse_pairs_from_file(const char* what, const char* path, accept_func accept);\n+  static bool accept_metric(CheckpointDCmd* self, const char* key, char* str);\n+  static bool accept_label(CheckpointDCmd* self, const char* key, char* str);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -932,1 +933,1 @@\n-    return Management::ticks_to_ms(os::elapsed_counter());\n+    return Management::ticks_to_ms(os::elapsed_counter_since_restore());\n@@ -999,0 +1000,12 @@\n+  case JMM_JVM_RESTORE_START_TIME_MS:\n+    return crac::restore_start_time();\n+\n+  case JMM_JVM_UPTIME_SINCE_RESTORE_MS:\n+    {\n+      jlong ticks = crac::uptime_since_restore();\n+      if (ticks == -1) {\n+        return -1;\n+      }\n+      return Management::ticks_to_ms(ticks);\n+    }\n+\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compileLog.hpp\"\n@@ -46,1 +47,1 @@\n-  void finish_log();\n+  void finish_log(bool is_checkpoint = false);\n@@ -86,0 +87,20 @@\n+  bool is_fd_used(int fd) {\n+    return has_log_file() ? fd == _log_file->get_fd() : false;\n+  }\n+  void before_checkpoint() {\n+    if (has_log_file()){\n+      if (xtty != nullptr) {\n+        ttyLocker ttyl;\n+        xtty->begin_elem(\"crac_checkpoint_vm\");\n+        xtty->stamp();\n+        xtty->end_elem();\n+        xtty = nullptr;\n+      }\n+      finish_log(true);\n+    }\n+  }\n+  void after_restore() {\n+    init();\n+    CompileLog::swap_streams_on_restore();\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/defaultStream.hpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -254,0 +254,4 @@\n+#ifndef INCLUDE_CPU_FEATURE_ACTIVE\n+#define INCLUDE_CPU_FEATURE_ACTIVE 1\n+#endif \/\/ INCLUDE_CPU_FEATURE_ACTIVE\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -799,1 +799,1 @@\n-void defaultStream::finish_log() {\n+void defaultStream::finish_log(bool is_checkpoint) {\n@@ -803,0 +803,3 @@\n+  if (is_checkpoint) {\n+    CompileLog::finish_log_on_checkpoint(xs->out());\n+  } else {\n@@ -804,1 +807,2 @@\n-  CompileLog::finish_log(xs->out());  \/\/ write compile logging, if any, now\n+    CompileLog::finish_log(xs->out());  \/\/ write compile logging, if any, now\n+  }\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+  int get_fd() { return fileno(_file); }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,17 @@\n+#ifdef _WINDOWS\n+char *strsep(char **strp, const char *delim) {\n+  char *str = *strp;\n+  if (str == nullptr) {\n+    return nullptr;\n+  }\n+  size_t len = strcspn(str, delim);\n+  if (str[len] == '\\0') {\n+    *strp = nullptr;\n+    return str;\n+  }\n+  str[len] = '\\0';\n+  *strp += len + 1;\n+  return str;\n+}\n+#endif \/\/ _WINDOWS\n+\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,1 +33,4 @@\n-#endif\n+\n+\/\/ Windows does not have standard C library's strsep\n+char *strsep(char **strp, const char *delim);\n+#endif \/\/ _WINDOWS\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+typedef int(*ZIP_GetFD_t)(jzfile *zip);\n@@ -51,0 +52,1 @@\n+static ZIP_GetFD_t ZIP_GetFD = nullptr;\n@@ -91,0 +93,1 @@\n+  ZIP_GetFD = CAST_TO_FN_PTR(ZIP_GetFD_t, dll_lookup(\"ZIP_GetFD\", path, false));\n@@ -217,0 +220,4 @@\n+\n+int ZipLibrary::get_fd(jzfile *zip) {\n+  return ZIP_GetFD ? ZIP_GetFD(zip) : -1;\n+}\n","filename":"src\/hotspot\/share\/utilities\/zipLibrary.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -32,0 +33,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -83,0 +85,1 @@\n+    private final int imode;\n@@ -102,0 +105,31 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ We cannot synchronize this without making every other method call synchronized\n+            offset = getFilePointer();\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path, imode);\n+                seek(offset);\n+                RandomAccessFile.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n@@ -257,0 +291,1 @@\n+        this.imode = imode;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.mirror.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -40,0 +46,1 @@\n+import java.util.function.Supplier;\n@@ -1065,0 +1072,1 @@\n+        private final JDKFdResource resource;\n@@ -1068,0 +1076,1 @@\n+            resource = new PipeResource(this, fd);\n@@ -1162,0 +1171,31 @@\n+    static class PipeResource extends JDKFdResource {\n+        private final Closeable owner;\n+        private final FileDescriptor fd;\n+\n+        PipeResource(Closeable owner, FileDescriptor fd) {\n+            this.owner = owner;\n+            this.fd = fd;\n+        }\n+\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            OpenResourcePolicies.Policy policy = OpenResourcePolicies.find(false, OpenResourcePolicies.PIPE, null);\n+            String action = policy != null ? policy.action.toLowerCase() : \"error\";\n+            Supplier<Exception> exceptionSupplier = switch (action) {\n+                case \"error\":\n+                    yield  () -> new CheckpointOpenResourceException(owner.toString(), getStackTraceHolder());\n+                case \"close\":\n+                    owner.close();\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    warnOpenResource(policy, owner.toString());\n+                    yield NO_EXCEPTION;\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + owner, null);\n+            };\n+            \/\/ FileInputStream does not claim when path is null\n+            Core.getClaimedFDs().claimFd(fd, this, exceptionSupplier, fd);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -34,0 +34,8 @@\n+import java.util.*;\n+\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -701,0 +709,2 @@\n+            \/\/ This creates a file descriptor but does not need own resource,\n+            \/\/ see PipelineResource.\n@@ -1224,11 +1234,18 @@\n-        try {\n-            Redirect prevOutput = null;\n-            for (int index = 0; index < builders.size(); index++) {\n-                ProcessBuilder builder = builders.get(index);\n-                Redirect[] redirects = builder.redirects();\n-                if (index > 0) {\n-                    \/\/ check the current Builder to see if it can take input from the previous\n-                    if (builder.redirectInput() != Redirect.PIPE) {\n-                        throw new IllegalArgumentException(\"builder redirectInput()\" +\n-                                \" must be PIPE except for the first builder: \"\n-                                + builder.redirectInput());\n+        \/\/ This resource helps us block the checkpoint until all subprocesses\n+        \/\/ are created; after that we won't need the FileDescriptors and can safely\n+        \/\/ close these.\n+        PipelineResource pipelineResource = new PipelineResource();\n+        synchronized (pipelineResource) {\n+            try (pipelineResource) {\n+                Redirect prevOutput = null;\n+                for (int index = 0; index < builders.size(); index++) {\n+                    ProcessBuilder builder = builders.get(index);\n+                    Redirect[] redirects = builder.redirects();\n+                    if (index > 0) {\n+                        \/\/ check the current Builder to see if it can take input from the previous\n+                        if (builder.redirectInput() != Redirect.PIPE) {\n+                            throw new IllegalArgumentException(\"builder redirectInput()\" +\n+                                    \" must be PIPE except for the first builder: \"\n+                                    + builder.redirectInput());\n+                        }\n+                        redirects[0] = prevOutput;\n@@ -1236,8 +1253,10 @@\n-                    redirects[0] = prevOutput;\n-                }\n-                if (index < numBuilders - 1) {\n-                    \/\/ check all but the last stage has output = PIPE\n-                    if (builder.redirectOutput() != Redirect.PIPE) {\n-                        throw new IllegalArgumentException(\"builder redirectOutput()\" +\n-                                \" must be PIPE except for the last builder: \"\n-                                + builder.redirectOutput());\n+                    if (index < numBuilders - 1) {\n+                        \/\/ check all but the last stage has output = PIPE\n+                        if (builder.redirectOutput() != Redirect.PIPE) {\n+                            throw new IllegalArgumentException(\"builder redirectOutput()\" +\n+                                    \" must be PIPE except for the last builder: \"\n+                                    + builder.redirectOutput());\n+                        }\n+                        RedirectPipeImpl redirectPipe = new RedirectPipeImpl();\n+                        redirects[1] = redirectPipe;  \/\/ placeholder for new output\n+                        pipelineResource.addRedirect(redirectPipe);\n@@ -1245,6 +1264,6 @@\n-                    redirects[1] = new RedirectPipeImpl();  \/\/ placeholder for new output\n-                }\n-                processes.add(builder.start(redirects));\n-                if (prevOutput instanceof RedirectPipeImpl redir) {\n-                    \/\/ Wrap the fd so it can be closed\n-                    new Process.PipeInputStream(redir.getFd()).close();\n+                    processes.add(builder.start(redirects));\n+                    if (prevOutput instanceof RedirectPipeImpl redir) {\n+                        \/\/ Wrap the fd so it can be closed\n+                        new Process.PipeInputStream(redir.getFd()).close();\n+                    }\n+                    prevOutput = redirects[1];\n@@ -1252,1 +1271,12 @@\n-                prevOutput = redirects[1];\n+            } catch (Exception ex) {\n+                \/\/ Cleanup processes already started\n+                processes.forEach(Process::destroyForcibly);\n+                processes.forEach(p -> {\n+                    try {\n+                        p.waitFor();        \/\/ Wait for it to exit\n+                    } catch (InterruptedException ie) {\n+                        \/\/ If interrupted; continue with next Process\n+                        Thread.currentThread().interrupt();\n+                    }\n+                });\n+                throw ex;\n@@ -1254,12 +1284,0 @@\n-        } catch (Exception ex) {\n-            \/\/ Cleanup processes already started\n-            processes.forEach(Process::destroyForcibly);\n-            processes.forEach(p -> {\n-                try {\n-                    p.waitFor();        \/\/ Wait for it to exit\n-                } catch (InterruptedException ie) {\n-                    \/\/ If interrupted; continue with next Process\n-                    Thread.currentThread().interrupt();\n-                }\n-            });\n-            throw ex;\n@@ -1269,0 +1287,32 @@\n+\n+    private static class PipelineResource implements JDKResource, AutoCloseable {\n+        private static final JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+        private final List<RedirectPipeImpl> redirects = new ArrayList<>();\n+\n+        public PipelineResource() {\n+            Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+        }\n+\n+        @Override\n+        public synchronized void beforeCheckpoint(Context<? extends Resource> context) {\n+            \/\/ Noop, but this method is synchronized\n+            assert redirects.isEmpty();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+\n+        public void addRedirect(RedirectPipeImpl redirect) {\n+            this.redirects.add(redirect);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            \/\/ The file descriptors won't be used by this process\n+            for (RedirectPipeImpl r : redirects) {\n+                fdAccess.close(r.getFd());\n+            }\n+            redirects.clear();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":88,"deletions":38,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -380,0 +380,5 @@\n+     * @crac When the process is restored on another machine or if the machine\n+     * rebooted the value is updated based on wall-clock time difference,\n+     * resulting in a loss of accuracy when comparing timestamps obtained\n+     * before and after checkpoint.\n+     *\n@@ -640,0 +645,6 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload system properties in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -674,0 +685,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -733,0 +745,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -754,0 +769,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -854,0 +872,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -861,0 +885,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -890,0 +915,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload the environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -895,0 +926,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.crac.Core;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -316,0 +320,10 @@\n+\n+            @Override\n+            public <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException {\n+                return queue.poll(timeout);\n+            }\n+\n+            @Override\n+            public void wakeupReferenceQueue(ReferenceQueue<?> queue) {\n+                queue.wakeup();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.crac.JDKSocketResource;\n+import sun.nio.ch.Net;\n+\n@@ -58,0 +61,28 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() {\n+            disconnect();\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.SharedSecrets;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -36,0 +37,1 @@\n+import sun.nio.ch.Net;\n@@ -75,0 +77,44 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return new InetSocketAddress(address, port);\n+        }\n+\n+        \/\/ We cannot override this in subclass because SocketImpl is public and resource factory method\n+        \/\/ would expose JDKSocketResource outside JDK.\n+        \/\/ We cannot expose any public overridable methods either in order to pass JCK.\n+        @Override\n+        protected boolean isListening() {\n+            return (SocketImpl.this instanceof NioSocketImpl) && ((NioSocketImpl) SocketImpl.this).isListening();\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected void markForReopen() {\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore() throws IOException {\n+            if (SocketImpl.this instanceof NioSocketImpl) {\n+                ((NioSocketImpl) SocketImpl.this).reopenAfterRestore();\n+            } else {\n+                throw new UnsupportedOperationException(\"Reopen not implemented\");\n+            }\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -218,0 +218,4 @@\n+     *\n+     * @crac Instances created by this constructor are automatically reseeded\n+     * after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n@@ -261,0 +265,4 @@\n+     * @crac Instances created by this constructor are <strong>not<\/strong>\n+     * reseeded after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n+     *\n@@ -363,0 +371,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -411,0 +421,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -456,0 +468,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -504,0 +518,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -562,0 +578,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -615,0 +633,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -152,0 +152,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n@@ -191,0 +196,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledExecutorService.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -50,0 +51,1 @@\n+import jdk.internal.crac.Core;\n@@ -797,0 +799,8 @@\n+\n+        public void beforeCheckpoint() {\n+            if (zsrc != null) {\n+                synchronized (zsrc) {\n+                    zsrc.beforeCheckpoint();\n+                }\n+            }\n+        }\n@@ -1107,0 +1117,4 @@\n+    private synchronized void beforeCheckpoint() {\n+        res.beforeCheckpoint();\n+    }\n+\n@@ -1150,2 +1164,5 @@\n-\n-             }\n+                @Override\n+                public void beforeCheckpoint(ZipFile zip) {\n+                    zip.beforeCheckpoint();\n+                }\n+            }\n@@ -2041,0 +2058,13 @@\n+\n+        public void beforeCheckpoint() {\n+            synchronized (zfile) {\n+                FileDescriptor fd = null;\n+                try {\n+                    fd = zfile.getFD();\n+                } catch (IOException e) {\n+                }\n+                if (fd != null) {\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+                }\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+    @Stable private static JavaNioChannelsSpiAccess javaNioChannelsSpiAccess;\n@@ -287,0 +288,13 @@\n+    public static void setJavaNioChannelsSpiAccess(JavaNioChannelsSpiAccess a) {\n+        javaNioChannelsSpiAccess = a;\n+    }\n+\n+    public static JavaNioChannelsSpiAccess getJavaNioChannelsSpiAccess() {\n+        var access = javaNioChannelsSpiAccess;\n+        if (access == null) {\n+            ensureClassInitialized(java.nio.channels.spi.AbstractInterruptibleChannel.class);\n+            access = javaNioChannelsSpiAccess;\n+        }\n+        return access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+package jdk.internal.crac;\n+\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.mirror.impl.CheckpointOpenFileException;\n+import jdk.internal.crac.mirror.impl.CheckpointOpenResourceException;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.function.Supplier;\n+\n+public abstract class JDKFileResource extends JDKFdResource {\n+    \/\/ Non-final to reduce the amount of static initialization. Currently\n+    \/\/ initialization of this class always becomes a part of VM initialization.\n+    \/\/\n+    \/\/ Besides the performance benefit when no C\/R will be performed, we want to\n+    \/\/ keep the static initialization order of the CRaC project closer to the\n+    \/\/ mainline JDK to reduce incompatibilities (the order defines the final\n+    \/\/ result).\n+    @Stable\n+    private static volatile Path[] CLASSPATH_ENTRIES;\n+\n+    private static Path[] getClasspathEntries() {\n+        if (CLASSPATH_ENTRIES == null) {\n+            synchronized (JDKFileResource.class) {\n+                if (CLASSPATH_ENTRIES == null) {\n+                    CLASSPATH_ENTRIES = createClasspathEntries();\n+                }\n+            }\n+        }\n+        return CLASSPATH_ENTRIES;\n+    }\n+\n+    private static Path[] createClasspathEntries() {\n+        final var items = System.getProperty(\"java.class.path\").split(File.pathSeparator);\n+        final var entries = new Path[items.length];\n+        for (int i = 0; i < items.length; i++) {\n+            try {\n+                \/\/ On Windows, path with forward slashes starting with '\/' is an accepted classpath\n+                \/\/ element, even though it might seem as invalid and parsing in Path.of(...) would fail.\n+                entries[i] = new File(items[i]).toPath();\n+            } catch (Exception e) {\n+                \/\/ Ignore any exception parsing the path: URLClassPath.toFileURL() ignores IOExceptions\n+                \/\/ as well, here we might get InvalidPathException\n+            }\n+        }\n+        return entries;\n+    }\n+\n+    boolean closed;\n+    boolean error;\n+\n+    public static OpenResourcePolicies.Policy findPolicy(boolean isRestore, String pathStr) {\n+        Path path = Path.of(pathStr);\n+        return OpenResourcePolicies.find(isRestore,\n+                OpenResourcePolicies.FILE, props -> {\n+                    String policyPath = props.get(\"path\");\n+                    if (policyPath == null) {\n+                        return true; \/\/ missing path matches all files\n+                    } else {\n+                        return FileSystems.getDefault().getPathMatcher(\"glob:\" + policyPath).matches(path);\n+                    }\n+                });\n+    }\n+\n+    protected abstract FileDescriptor getFD();\n+    protected abstract String getPath();\n+    protected abstract void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException;\n+    protected abstract void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException;\n+\n+    protected boolean matchClasspath(String path) {\n+        Path p = Path.of(path);\n+        for (Path entry : getClasspathEntries()) {\n+            try {\n+                if (entry != null && Files.isSameFile(p, entry)) {\n+                    return true;\n+                }\n+            } catch (IOException e) {\n+                \/\/ ignored\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        String path = getPath();\n+        if (path == null) {\n+            \/\/ let FileDescriptor claim everything\n+            return;\n+        }\n+\n+        OpenResourcePolicies.Policy policy = findPolicy(false, path);\n+        String action = \"error\";\n+        if (policy != null) {\n+            action = policy.action.toLowerCase();\n+        } else if (matchClasspath(path)) {\n+            \/\/ Files on the classpath are considered persistent, exception is not thrown\n+            action = \"ignore\";\n+        }\n+        Supplier<Exception> exceptionSupplier = switch (action) {\n+            case \"error\":\n+                error = true;\n+                yield () -> new CheckpointOpenFileException(path, getStackTraceHolder());\n+            case \"close\", \"reopen\":\n+                \/\/ Here we assume that the stream is idle; any concurrent access\n+                \/\/ will end with exceptions as the file-descriptors is invalidated\n+                try {\n+                    closeBeforeCheckpoint(policy);\n+                } catch (IOException e) {\n+                    throw new CheckpointOpenResourceException(\"Cannot close \" + path, e);\n+                }\n+                closed = true;\n+            case \"ignore\":\n+                warnOpenResource(policy, \"File \" + path);\n+                yield NO_EXCEPTION;\n+            default:\n+                throw new IllegalStateException(\"Unknown policy action for path \" + path + \": \" + policy.action);\n+        };\n+        FileDescriptor fd = getFD();\n+        Core.getClaimedFDs().claimFd(fd, this, exceptionSupplier, fd);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (!closed || error) {\n+            return;\n+        }\n+        OpenResourcePolicies.Policy policy = findPolicy(true, getPath());\n+        if (policy != null && \"reopen\".equalsIgnoreCase(policy.action)) {\n+            reopenAfterRestore(policy);\n+            closed = false;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFileResource.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.InvocationHandler;\n@@ -32,0 +33,1 @@\n+import java.lang.reflect.Proxy;\n@@ -74,2 +76,2 @@\n-    private final ByteBuffer memoryMap;\n-    private final FileChannel channel;\n+    private ByteBuffer memoryMap;\n+    private FileChannel channel;\n@@ -78,4 +80,4 @@\n-    private final IntBuffer redirect;\n-    private final IntBuffer offsets;\n-    private final ByteBuffer locations;\n-    private final ByteBuffer strings;\n+    private IntBuffer redirect;\n+    private IntBuffer offsets;\n+    private ByteBuffer locations;\n+    private ByteBuffer strings;\n@@ -84,0 +86,1 @@\n+    private Object cracResource;\n@@ -85,1 +88,1 @@\n-    @SuppressWarnings({ \"removal\", \"this-escape\", \"suppression\" })\n+    @SuppressWarnings({ \"this-escape\", \"suppression\" })\n@@ -106,24 +109,2 @@\n-            channel = FileChannel.open(imagePath, StandardOpenOption.READ);\n-            \/\/ No lambdas during bootstrap\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run() {\n-                    if (BasicImageReader.class.getClassLoader() == null) {\n-                        try {\n-                            Class<?> fileChannelImpl =\n-                                Class.forName(\"sun.nio.ch.FileChannelImpl\");\n-                            Method setUninterruptible =\n-                                    fileChannelImpl.getMethod(\"setUninterruptible\");\n-                            setUninterruptible.invoke(channel);\n-                        } catch (ClassNotFoundException |\n-                                 NoSuchMethodException |\n-                                 IllegalAccessException |\n-                                 InvocationTargetException ex) {\n-                            \/\/ fall thru - will only happen on JDK-8 systems where this code\n-                            \/\/ is only used by tools using jrt-fs (non-critical.)\n-                        }\n-                    }\n-\n-                    return null;\n-                }\n-            });\n+            channel = openFileChannel();\n+            registerIfCracPresent();\n@@ -134,1 +115,1 @@\n-            map = channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size());\n+            map = createMemoryMap(channel.size());\n@@ -160,1 +141,1 @@\n-            map = channel.map(FileChannel.MapMode.READ_ONLY, 0, indexSize);\n+            map = createMemoryMap(indexSize);\n@@ -169,0 +150,8 @@\n+\n+        initMappedBuffers();\n+\n+        stringsReader = new ImageStringsReader(this);\n+        decompressor = new Decompressor();\n+    }\n+\n+    protected void initMappedBuffers() {\n@@ -173,0 +162,1 @@\n+    }\n@@ -174,2 +164,129 @@\n-        stringsReader = new ImageStringsReader(this);\n-        decompressor = new Decompressor();\n+    protected ByteBuffer createMemoryMap(long size) throws IOException {\n+        return channel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n+    }\n+\n+    \/\/ Since this class must be compatible with JDK 8 and any non-CRaC JDK due to being part of jrtfs.jar\n+    \/\/ we must register this to CRaC via reflection.\n+    private void registerIfCracPresent() {\n+        Class<?> priorityClass = null;\n+        try {\n+            priorityClass = Class.forName(\"jdk.internal.crac.Core$Priority\");\n+        } catch (ClassNotFoundException e) {\n+            \/\/ there is no CRaC; suppress an exception\n+            return;\n+        }\n+        try {\n+            Object[] priorities = priorityClass.getEnumConstants();\n+            if (priorities == null) {\n+                return;\n+            }\n+            Object normalPriority = null;\n+            for (int i = 0; i < priorities.length; ++i) {\n+                if (\"NORMAL\".equals(priorities[i].toString())) {\n+                    normalPriority = priorities[i];\n+                }\n+            }\n+            if (normalPriority == null) {\n+                throw new IllegalStateException();\n+            }\n+            Class<?> resourceClass = Class.forName(\"jdk.internal.crac.mirror.Resource\");\n+            Method getContextMethod = priorityClass.getMethod(\"getContext\");\n+            Object ctx = getContextMethod.invoke(normalPriority);\n+            Class<?> ctxClass = ctx.getClass();\n+\n+            registerCracResource(resourceClass, ctxClass, ctx);\n+        } catch (IllegalAccessException e) {\n+            \/\/ try to register via public API\n+            registerIfPublicCracPresent();\n+        } catch (NoSuchMethodException | InvocationTargetException | ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private void registerIfPublicCracPresent() {\n+        Class<?> cracCoreClass = null;\n+        try {\n+            cracCoreClass = Class.forName(\"jdk.crac.Core\");\n+        } catch (ClassNotFoundException e) {\n+            \/\/ there is no public CRaC; suppress an exception\n+            return;\n+        }\n+        try {\n+            Class<?> resourceClass = Class.forName(\"jdk.crac.Resource\");\n+            Method getGlobalContextMethod = cracCoreClass.getMethod(\"getGlobalContext\");\n+            Object ctx = getGlobalContextMethod.invoke(null);\n+            Class<?> ctxClass = Class.forName(\"jdk.crac.Context\");\n+\n+            registerCracResource(resourceClass, ctxClass, ctx);\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        } catch (NoSuchMethodException | InvocationTargetException | ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private void registerCracResource(Class<?> resourceClass, Class<?> ctxClass, Object ctx)\n+            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        Method registerMethod = ctxClass.getMethod(\"register\", resourceClass);\n+        cracResource = Proxy.newProxyInstance(\n+            resourceClass.getClassLoader(),\n+            new Class<?>[] { resourceClass },\n+            new InvocationHandler() {\n+                @Override\n+                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                    if (\"beforeCheckpoint\".equals(method.getName())) {\n+                        channel.close();\n+                        redirect = null;\n+                        offsets = null;\n+                        locations = null;\n+                        strings = null;\n+                        memoryMap = null;\n+                    } else if (\"afterRestore\".equals(method.getName())) {\n+                        if (channel != null) {\n+                            channel = openFileChannel();\n+                            memoryMap = createMemoryMap(MAP_ALL ? channel.size() : indexSize).asReadOnlyBuffer();\n+                            initMappedBuffers();\n+                        }\n+                    } else if (\"toString\".equals(method.getName())) {\n+                        return BasicImageReader.this.toString();\n+                    } else if (\"hashCode\".equals(method.getName())) {\n+                        return 0;\n+                    } else if (\"equals\".equals(method.getName())) {\n+                        return args[0] == cracResource;\n+                    } else {\n+                        throw new UnsupportedOperationException(method.toString());\n+                    }\n+                    return null;\n+                }\n+            }\n+        );\n+        registerMethod.invoke(ctx, cracResource);\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private FileChannel openFileChannel() throws IOException {\n+        FileChannel channel = FileChannel.open(imagePath, StandardOpenOption.READ);\n+        \/\/ No lambdas during bootstrap\n+        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n+            @Override\n+            public Void run() {\n+                if (BasicImageReader.class.getClassLoader() == null) {\n+                    try {\n+                        Class<?> fileChannelImpl =\n+                            Class.forName(\"sun.nio.ch.FileChannelImpl\");\n+                        Method setUninterruptible =\n+                                fileChannelImpl.getMethod(\"setUninterruptible\");\n+                        setUninterruptible.invoke(channel);\n+                    } catch (ClassNotFoundException |\n+                             NoSuchMethodException |\n+                             IllegalAccessException |\n+                             InvocationTargetException ex) {\n+                        \/\/ fall thru - will only happen on JDK-8 systems where this code\n+                        \/\/ is only used by tools using jrt-fs (non-critical.)\n+                    }\n+                }\n+\n+                return null;\n+            }\n+        });\n+        return channel;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":152,"deletions":35,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import java.util.zip.ZipFile;\n@@ -58,0 +59,1 @@\n+import jdk.internal.util.jar.PersistentJarFile;\n@@ -451,1 +453,1 @@\n-            this.jf = new JarFile(path.toString());\n+            this.jf = new PersistentJarFile(new File(path.toString()), true, ZipFile.OPEN_READ, JarFile.runtimeVersion());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModulePatcher.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-\n@@ -171,0 +170,5 @@\n+    exports jdk.internal.crac to\n+        java.rmi,\n+        jdk.jfr,\n+        jdk.management.agent,\n+        jdk.sctp;\n@@ -408,0 +412,8 @@\n+    exports jdk.internal.crac.mirror to\n+        java.rmi,\n+        jdk.crac,\n+        jdk.jfr,\n+        jdk.management.agent;\n+\n+    exports jdk.internal.crac.mirror.impl to\n+        jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.JDKFileResource;\n+\n@@ -53,0 +58,29 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fdObj;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            \/\/ TODO: we don't have information about the path without introspecting FD\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (isOpen()) {\n+                super.beforeCheckpoint(context);\n+            }\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousFileChannelImpl.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -52,0 +53,1 @@\n+    private final JDKSocketResource resource;\n@@ -69,0 +71,3 @@\n+    \/\/ last backlog used for bind(...)\n+    private int backlog;\n+\n@@ -72,0 +77,44 @@\n+        this.resource = new JDKSocketResource(this) {\n+            @Override\n+            protected FileDescriptor getFD() {\n+                return fd;\n+            }\n+\n+            @Override\n+            protected SocketAddress localAddress() {\n+                return localAddress;\n+            }\n+\n+            @Override\n+            protected SocketAddress remoteAddress() {\n+                return null;\n+            }\n+\n+            @Override\n+            protected boolean isListening() {\n+                return true;\n+            }\n+\n+            @Override\n+            protected void closeBeforeCheckpoint() throws IOException {\n+                close();\n+            }\n+\n+            @Override\n+            protected void markForReopen() {\n+            }\n+\n+            @Override\n+            protected void reopenAfterRestore() throws IOException {\n+                FileDescriptor newfd = Net.serverSocket();\n+                IOUtil.setfdVal(fd, IOUtil.fdVal(newfd));\n+                reopen();\n+                synchronized (stateLock) {\n+                    SocketAddress local = localAddress;\n+                    if (local != null) {\n+                        localAddress = null;\n+                        bind(local, backlog);\n+                    }\n+                }\n+            }\n+        };\n@@ -114,0 +163,13 @@\n+    private void reopen() throws IOException {\n+        implReopen();\n+        closeLock.writeLock().lock();\n+        try {\n+            assert(closed);\n+            closed = false;\n+        } finally {\n+            closeLock.writeLock().unlock();\n+        }\n+    }\n+\n+    protected abstract void implReopen() throws IOException;\n+\n@@ -158,1 +220,2 @@\n-                Net.listen(fd, backlog < 1 ? 50 : backlog);\n+                this.backlog = backlog < 1 ? 50 : backlog;\n+                Net.listen(fd, this.backlog);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKSocketResource;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -55,0 +59,1 @@\n+    private static final FileDispatcherImpl nd = new FileDispatcherImpl();\n@@ -56,1 +61,3 @@\n-    protected final FileDescriptor fd;\n+    protected FileDescriptor fd;\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new Resource();\n@@ -617,0 +624,72 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(AsynchronousSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.internal.crac.mirror.Resource> context) throws Exception {\n+            try {\n+                begin();\n+                synchronized (stateLock) {\n+                    \/\/ On Windows, the socket channel with its FD is created in the accept()\n+                    \/\/ (returning incomplete future) so the user code does not have the chance to close it.\n+                    if (state == ST_UNCONNECTED) {\n+                        nd.close(fd);\n+                        Core.getClaimedFDs().claimFd(fd, AsynchronousSocketChannelImpl.this, NO_EXCEPTION, fd);\n+                    } else {\n+                        \/\/ Unlock so that we could close by FD policy\n+                        end();\n+                        try {\n+                            super.beforeCheckpoint(context);\n+                        } finally {\n+                            \/\/ lock again - afterRestore should start locked\n+                            begin();\n+                        }\n+                    }\n+                }\n+            } catch (ClosedChannelException e) {\n+                \/\/ ignored\n+            }\n+            \/\/ Not calling end() here - we've left the fd inconsistent\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends jdk.internal.crac.mirror.Resource> context) throws Exception {\n+            try {\n+                synchronized (stateLock) {\n+                    if (state == ST_UNCONNECTED) {\n+                        fd = Net.socket();\n+                    }\n+                }\n+            } finally {\n+                end();\n+            }\n+            super.afterRestore(context);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":80,"deletions":1,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -53,0 +56,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -83,0 +87,34 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (!isOpen() || path == null) {\n+                return;\n+            } else if (parent != null) {\n+                \/\/ This FileChannel is managed by a higher level object that\n+                \/\/ will handle the provided file descriptor on its own.\n+                return;\n+            }\n+            super.beforeCheckpoint(context);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ implementation is possible but non-trivial\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -123,0 +124,8 @@\n+    \/\/ last backlog used for listen() invocation\n+    private int backlog;\n+\n+    static {\n+        \/\/ trigger eager initialization\n+        new FileDispatcherImpl();\n+    }\n+\n@@ -463,0 +472,27 @@\n+    public boolean isListening() {\n+        return server;\n+    }\n+\n+    public void reopenAfterRestore() throws IOException {\n+        if (!server) {\n+            throw new UnsupportedOperationException(\"Reopen not implemented for non-server sockets\");\n+        }\n+        synchronized (stateLock) {\n+            FileDescriptor fd;\n+            fd = Net.serverSocket();\n+            Runnable closer = closerFor(fd);\n+            IOUtil.setfdVal(NioSocketImpl.this.fd, IOUtil.fdVal(fd));\n+            NioSocketImpl.this.cleaner = CleanerFactory.cleaner().register(NioSocketImpl.this, closer);\n+            state = ST_UNCONNECTED;\n+\n+            if (localport != 0) {\n+                int port = localport;\n+                localport = 0;\n+                bind(address, port);\n+            }\n+            if (backlog > 0) {\n+                Net.listen(fd, backlog);\n+            }\n+        }\n+    }\n+\n@@ -656,1 +692,2 @@\n-            Net.listen(fd, backlog < 1 ? 50 : backlog);\n+            this.backlog = backlog < 1 ? 50 : backlog;\n+            Net.listen(fd, this.backlog);\n@@ -1198,1 +1235,1 @@\n-    private static Runnable closerFor(FileDescriptor fd) {\n+    private static Runnable closerFor0(FileDescriptor fd) {\n@@ -1208,0 +1245,14 @@\n+    private static Runnable closerFor(FileDescriptor fd) {\n+\n+        \/\/ FIXME ensure FileDispatcherImpl's Resource is registered before the closer is used,\n+        \/\/ otherwise the closer during beforeCheckpoint may be the first one to access\n+        \/\/ FileDescriptor, and then Dispatcher Resource will be blocked for registration.\n+        try {\n+            MethodHandles.lookup().ensureInitialized(FileDispatcherImpl.class);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        return closerFor0(fd);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":53,"deletions":2,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+import java.nio.channels.spi.AbstractSelectableChannel;\n+import java.nio.channels.spi.AbstractSelectionKey;\n@@ -49,0 +51,1 @@\n+import java.util.ArrayList;\n@@ -51,0 +54,1 @@\n+import java.util.List;\n@@ -54,0 +58,2 @@\n+import java.util.function.Consumer;\n+\n@@ -58,0 +64,4 @@\n+import jdk.internal.access.JavaNioChannelsSpiAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.JDKSocketResource;\n+import jdk.internal.crac.JDKSocketResourceBase;\n@@ -70,0 +80,1 @@\n+    private static final JavaNioChannelsSpiAccess SPI_ACCESS = SharedSecrets.getJavaNioChannelsSpiAccess();\n@@ -76,1 +87,3 @@\n-    private final int fdVal;\n+    private int fdVal;\n+    private final Resource resource = new Resource();\n+    private int backlog;\n@@ -298,0 +311,2 @@\n+            \/\/ Persisting the backlog since there's no way to query that before close\n+            this.backlog = backlog < 1 ? 50 : backlog;\n@@ -403,1 +418,0 @@\n-\n@@ -729,0 +743,90 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        private List<SelectionKey> reopenQueue;\n+\n+        public Resource() {\n+            super(ServerSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isListening() {\n+            return true;\n+        }\n+\n+        @Override\n+        protected void markForReopen() {\n+            \/\/ No need to synchronization: reopen will be invoked from single thread\n+            reopenQueue = new ArrayList<>();\n+            SPI_ACCESS.forEachKey(ServerSocketChannelImpl.this, reopenQueue::add);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore() throws IOException {\n+            FileDescriptor newFd;\n+            if (family == UNIX) {\n+                newFd = UnixDomainSockets.socket();\n+            } else {\n+                newFd = Net.serverSocket(family);\n+            }\n+            \/\/ We could avoid making fdVal non-final and dup2(...) to the original\n+            \/\/ value but that could accidentally conflict with another FD created\n+            \/\/ during restore.\n+            fdVal = IOUtil.fdVal(newFd);\n+            IOUtil.setfdVal(fd, fdVal);\n+            synchronized (stateLock) {\n+                state = ST_INUSE;\n+                if (isUnixSocket()) {\n+                    localAddress = unixBind(localAddress, backlog);\n+                } else {\n+                    localAddress = netBind(localAddress, backlog);\n+                }\n+            }\n+            SPI_ACCESS.setChannelReopened(ServerSocketChannelImpl.this);\n+\n+            for (SelectionKey key : reopenQueue) {\n+                assert(key.channel() == ServerSocketChannelImpl.this);\n+                \/\/ If a key registered on the channel that is about to be reopened\n+                \/\/ by FD policies is cancelled during JDK resource C\/R handling\n+                \/\/ this would be automatically uncancelled.\n+                if (key instanceof AbstractSelectionKey ask) {\n+                    SPI_ACCESS.revalidateSelectionKey(ask);\n+                }\n+                if (key.channel() instanceof AbstractSelectableChannel asc) {\n+                    SPI_ACCESS.reregisterSelectionKey(asc, key);\n+                }\n+                if (key.selector() instanceof SelectorImpl selector) {\n+                    assert key instanceof SelectionKeyImpl;\n+                    SelectionKeyImpl ski = (SelectionKeyImpl) key;\n+                    selector.registerExisting(ski);\n+                    if (selector.isOpen()) {\n+                        \/\/ Let the implementation process updates queue\n+                        selector.wakeup();\n+                    } else {\n+                        selector.removeKey(ski);\n+                        key.cancel();\n+                    }\n+                }\n+            }\n+            reopenQueue = null;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":106,"deletions":2,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -85,0 +86,1 @@\n+    private final Resource resource = new Resource();\n@@ -1611,0 +1613,31 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(SocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1110,0 +1110,54 @@\n+[`-XX:CRaCCheckpointTo=`]{#-XX_CRaCCheckpointTo}*directory*\n+:   The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+    a running Java program into an image. Restoring from the image should have\n+    lower start-up and warm-up times compared to a full re-launch.\n+\n+    This option defines a path to the image which is currently a directory. The\n+    directory will be created if it does not exist, but no parent directories are\n+    created.\n+\n+    It is possible to use a pattern with automatically inferred values, using\n+    these placeholders:\n+    -   `%%`: single % character\n+    -   `%a`: architecture; the same value as system property 'os.arch'\n+    -   `%f`: CPU features hex string. Empty string if the architecture does not\n+              use optional CPU features.\n+    -   `%u`: UUID (version 4 = random)\n+    -   `%g`: checkpoint generation (starting with 1, 0 is reserved for unknown)\n+    -   `%t`: checkpoint date & time in ISO-8601 in UTC, basic format (without\n+              separators) with second precision, e.g. `20250909T141711Z`\n+    -   `%T`: checkpoint epoch time (second precision)\n+    -   `%b` and `%B`: process boot time (generation 1), same format as `%t` or `%T`\n+    -   `%r` and `%R`: last restore time, same format as `%t` or `%T`. In case\n+                       of generation 1 this is is the same as process boot time.\n+    -   `%p`: PID of checkpointed process\n+    -   `%c`: number of CPU cores\n+    -   `%m`: max heap size (`-Xmx`) in a user-friendly format - using G or M suffix\n+\n+    Numeric placeholders (`%T`, `%B`, `%R`, `%p`, `%c`, `%m` and `%g`) support\n+    an optional prefix with minimum width, padded with spaces or zeroes if the prefix\n+    starts with zero, e.g. `%3g` -> `  1`, `%03g` -> `001`.\n+\n+[`-XX:CRaCRestoreFrom=`]{#-XX_CRaCRestoreFrom}*directory*\n+:   Restores from the specified checkpoint image.\n+\n+    You can optionally pass the name of the new main class and its arguments when\n+    using this option. In such a case, the new main method will be invoked with\n+    the specified arguments by the thread that initiated the checkpoint, after all\n+    CRaC resources have been successfully processed.\n+\n+[`-XX:+CRaCIgnoreRestoreIfUnavailable`]{#-XX__CRaCIgnoreRestoreIfUnavailable}\n+:   If the checkpoint image specified for restoration is identified as being\n+    unusable, continue with the normal startup instead of failing.\n+\n+    When restoring with this option, you should specify the command-line arguments\n+    for the normal startup process. If the restoration succeeds, they are ignored;\n+    otherwise, they are used for starting up.\n+\n+    If an initial image verification passes, but restoration still fails, the JVM\n+    will not attempt to start normally.\n+\n+[`-XX:CRaCMinPid=`]{#-XX_CRaCMinPid}*value*\n+:   A desired minimal PID value for checkpointed process. Applied by the launcher,\n+    only on POSIX-like platforms.\n+\n@@ -1854,0 +1908,19 @@\n+[`-XX:CPUFeatures=`]{#-XX_CPUFeatures}*features*\n+:   Limit the set of CPU features to make the CRaC image compatible for running\n+    on a machine with a different CPU:\n+\n+    `native`\n+    :   Use all available CPU features (default).\n+\n+    `generic`\n+    :   This option is compatible with most CPUs and faster than disabling\n+        all optional features.\n+\n+    `ignore`\n+    :   Do not store CPU features at all.\n+\n+    *arch-specific*\n+    :   Architecture specific string, e.g. *0xnumber,0xnumber* on x86_64.\n+        Use `-XX:+ShowCPUFeatures` to find a suitable architecture-specific\n+        string.\n+\n@@ -1858,0 +1931,13 @@\n+[`-XX:CheckCPUFeatures=`]{#-XX_CheckCPUFeatures}*check*\n+:   Set requirements for CPU features check:\n+\n+    `compatible`\n+    :   The image must be runnable on this CPU (default).\n+\n+    `exact`\n+    :   The image must use the very same features as this CPU.\n+\n+    `skip`\n+    :   Don't check features at all. This option is allowed only when\n+        `-XX:+UnlockExperimentalVMOptions` is used.\n+\n@@ -2021,0 +2107,4 @@\n+[`-XX:+ShowCPUFeatures`]{#-XX__ShowCPUFeatures}\n+:   Show features of this CPU to be possibly used for the\n+    `-XX:CPUFeatures=`*0xnumber* option.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include <errno.h>\n+\n@@ -102,0 +104,149 @@\n+\n+#ifndef _WIN32\n+#include <stdbool.h>\n+#include <sys\/wait.h>\n+\n+static bool is_checkpoint = false;\n+static bool is_restore = false;\n+static const int crac_min_pid_default = 128;\n+static int crac_min_pid = 0;\n+static bool is_min_pid_set = false;\n+\n+static inline const char *find_option(const char *arg, const char *vmoption) {\n+    const int len = strlen(vmoption);\n+    if (0 == strncmp(arg, vmoption, len)) {\n+        return arg + len;\n+    }\n+    return NULL;\n+}\n+\n+static void parse_crac(const char *arg) {\n+    if (!is_checkpoint && find_option(arg, \"-XX:CRaCCheckpointTo\")) {\n+        is_checkpoint = true;\n+    } else if (!is_restore && find_option(arg, \"-XX:CRaCRestoreFrom\")) {\n+        is_restore = true;\n+    } else if (!is_min_pid_set) {\n+        const char *value = find_option(arg, \"-XX:CRaCMinPid=\");\n+        if (value != NULL) {\n+            crac_min_pid = atoi(value);\n+            is_min_pid_set = true;\n+        }\n+    }\n+}\n+\n+static pid_t g_child_pid = -1;\n+\n+static int wait_for_children() {\n+    int status = -1;\n+    pid_t pid;\n+    do {\n+        int st = 0;\n+        pid = wait(&st);\n+        if (pid == g_child_pid) {\n+            status = st;\n+        }\n+    } while (-1 != pid || ECHILD != errno);\n+\n+    if (WIFEXITED(status)) {\n+        return WEXITSTATUS(status);\n+    }\n+\n+    if (WIFSIGNALED(status)) {\n+        \/\/ Try to terminate the current process with the same signal\n+        \/\/ as the child process was terminated\n+        const int sig = WTERMSIG(status);\n+        signal(sig, SIG_DFL);\n+        raise(sig);\n+        \/\/ Signal was ignored, return 128+n as bash does\n+        \/\/ see https:\/\/linux.die.net\/man\/1\/bash\n+        return 128+sig;\n+    }\n+\n+    return 1;\n+}\n+\n+static void sighandler(int sig, siginfo_t *info, void *param) {\n+    if (0 < g_child_pid) {\n+        kill(g_child_pid, sig);\n+    }\n+}\n+\n+static void setup_sighandler() {\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    const int MaxSignalValue = 31;\n+    for (int sig = 1; sig <= MaxSignalValue; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(\"sigprocmask\");\n+    }\n+}\n+\n+static int set_last_pid(int pid) {\n+#ifdef LINUX\n+    char buf[11]; \/\/ enough for int32\n+    const int len = snprintf(buf, sizeof(buf), \"%d\", pid);\n+    if (0 > len || sizeof(buf) < (size_t)len) {\n+        return EINVAL;\n+    }\n+    const char *last_pid_filename = \"\/proc\/sys\/kernel\/ns_last_pid\";\n+    const int last_pid_file = open(last_pid_filename, O_WRONLY|O_TRUNC, 0666);\n+    if (0 > last_pid_file) {\n+        return errno;\n+    }\n+    int res = 0;\n+    if (len > write(last_pid_file, buf, len)) {\n+        res = errno;\n+    }\n+    close(last_pid_file);\n+    return res;\n+#else\n+    return EPERM;\n+#endif\n+}\n+\n+static void spin_last_pid(int pid) {\n+    const int MaxSpinCount = pid < 1000 ? 1000 : pid;\n+    int cnt = MaxSpinCount;\n+    int child = 0;\n+    int prev = 0;\n+    do {\n+        child = fork();\n+        if (0 > child) {\n+            perror(\"spin_last_pid clone\");\n+            exit(1);\n+        }\n+        if (0 == child) {\n+            exit(0);\n+        }\n+        if (child < prev) {\n+            fprintf(stderr, \"%s: Invalid argument (%d)\\n\", __FUNCTION__, pid);\n+            exit(1);\n+        }\n+        if (0 >= cnt) {\n+            fprintf(stderr, \"%s: Can't reach pid %d, out of try count. Current pid=%d\\n\", __FUNCTION__, pid, child);\n+            exit(1);\n+        }\n+        prev = child;\n+        int status;\n+        if (0 > waitpid(child, &status, 0)) {\n+            perror(\"spin_last_pid waitpid\");\n+            exit(1);\n+        }\n+        --cnt;\n+    } while (child < pid);\n+}\n+#endif \/\/ _WIN32\n+\n@@ -206,0 +357,3 @@\n+        for (size_t j = 0; j < args->size; j++) {\n+            parse_crac(args->elements[j]);\n+        }\n@@ -211,1 +365,69 @@\n-#endif \/* WIN32 *\/\n+\n+    const int is_init = 1 == getpid();\n+    if (is_init && !is_min_pid_set) {\n+        crac_min_pid = crac_min_pid_default;\n+    }\n+    const int needs_pid_adjust = getpid() < crac_min_pid;\n+    if (is_checkpoint && (is_init || needs_pid_adjust)) {\n+        \/\/ Move PID value for new processes to a desired value\n+        \/\/ to avoid PID conflicts on restore.\n+        if (needs_pid_adjust) {\n+            const int res = set_last_pid(crac_min_pid);\n+            if (EPERM == res || EACCES == res || EROFS == res) {\n+                spin_last_pid(crac_min_pid);\n+            } else if (0 != res) {\n+                fprintf(stderr, \"set_last_pid: %s\\n\", strerror(res));\n+                exit(1);\n+            }\n+        }\n+\n+        \/\/ Avoid unexpected process completion when checkpointing under docker container run\n+        \/\/ by creating the main process waiting for children before exit.\n+        g_child_pid = fork();\n+        if (0 == g_child_pid && needs_pid_adjust && getpid() < crac_min_pid) {\n+            if (is_min_pid_set) {\n+                fprintf(stderr, \"Error: Can't adjust PID to min PID %d, current PID %d\\n\", crac_min_pid, (int)getpid());\n+                exit(1);\n+            } else {\n+                fprintf(stderr,\n+                        \"Warning: Can't adjust PID to min PID %d, current PID %d.\\n\"\n+                        \"This message can be suppressed by '-XX:CRaCMinPid=1' option\\n\",\n+                        crac_min_pid, (int)getpid());\n+            }\n+        }\n+        if (0 < g_child_pid) {\n+            \/\/ The main process should forward signals to the child.\n+            setup_sighandler();\n+            const int status = wait_for_children();\n+            exit(status);\n+        }\n+    }\n+#ifdef LINUX\n+    \/\/ \/proc filesystem is only on LINUX\/*NIX - rseq is not relevant elsewhere anyway\n+    if (is_checkpoint || is_restore) {\n+        const char *GLIBC_TUNABLES = \"GLIBC_TUNABLES\";\n+        const char *tunables = getenv(GLIBC_TUNABLES);\n+        \/\/ do not try overwrite an existing tunable setting\n+        if (!tunables || !strstr(tunables, \"glibc.pthread.rseq\")) {\n+            char tunables_buf[4096];\n+            const char *new_tunables = \"glibc.pthread.rseq=0\";\n+            if (tunables) {\n+                int sz = snprintf(tunables_buf, sizeof(tunables_buf), \"%s:%s\", tunables, new_tunables);\n+                if (sz < 0 || (int)sizeof(tunables_buf) <= sz) {\n+                    fprintf(stderr, \"Cannot update GLIBC_TUNABLES: does not fit\\n\");\n+                    return 1;\n+                }\n+                new_tunables = tunables_buf;\n+            }\n+\n+            if (setenv(GLIBC_TUNABLES, new_tunables, 1) < 0) {\n+                perror(\"setenv GLIBC_TUNABLES\");\n+                return 1;\n+            }\n+            execv(\"\/proc\/self\/exe\", argv);\n+            perror(\"re-exec\");\n+            return 1;\n+        }\n+    }\n+#endif \/* LINUX *\/\n+#endif \/* not WIN32 *\/\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":223,"deletions":1,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -1697,0 +1697,10 @@\n+\n+JNIEXPORT int\n+ZIP_GetFD(jzfile *zip) {\n+#ifdef WIN32\n+    \/\/ File descriptors not applicable on Windows\n+    return -1;\n+#else\n+    return (int) zip->zfd;\n+#endif \/\/ !WIN32\n+}\n","filename":"src\/java.base\/share\/native\/libzip\/zip_util.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.crac.JDKFdResource;\n@@ -621,0 +622,2 @@\n+        private final JDKFdResource resource;\n+\n@@ -622,1 +625,6 @@\n-            super(new PipeOutputStream(newFileDescriptor(fd)));\n+            this(newFileDescriptor(fd));\n+        }\n+\n+        private ProcessPipeOutputStream(FileDescriptor fd) {\n+            super(new PipeOutputStream(fd));\n+            resource = new PipeResource(this, fd);\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,7 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -34,0 +41,20 @@\n+    static class ResourceProxy implements JDKResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            UnixDispatcher.beforeCheckpoint();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context)\n+                throws IOException {\n+            UnixDispatcher.afterRestore();\n+        }\n+    }\n+\n+    static Object closeLock = new Object();\n+    static boolean forceNonDeferedClose;\n+    static int closeCnt;\n+\n+    static ResourceProxy resourceProxy = new ResourceProxy();\n+\n+\n@@ -36,1 +63,55 @@\n-        close0(fd);\n+        closeAndMark(fd);\n+    }\n+\n+    void preClose(FileDescriptor fd) throws IOException {\n+        boolean doPreclose = true;\n+        synchronized (closeLock) {\n+            if (forceNonDeferedClose) {\n+                doPreclose = false;\n+            }\n+            if (doPreclose) {\n+                ++closeCnt;\n+            }\n+        }\n+\n+        if (!doPreclose) {\n+            return;\n+        }\n+\n+        try {\n+            preClose0(fd);\n+        } finally {\n+            synchronized (closeLock) {\n+                closeCnt--;\n+                if (forceNonDeferedClose && closeCnt == 0) {\n+                    closeLock.notifyAll();\n+                }\n+            }\n+        }\n+    }\n+\n+    static void beforeCheckpoint() throws InterruptedException {\n+        synchronized (closeLock) {\n+            forceNonDeferedClose = true;\n+            while (closeCnt != 0) {\n+                closeLock.wait();\n+            }\n+            beforeCheckpoint0();\n+        }\n+    }\n+\n+    static void afterRestore() throws IOException {\n+        synchronized (closeLock) {\n+            afterRestore0();\n+            forceNonDeferedClose = false;\n+        }\n+    }\n+\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+        SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    static void closeAndMark(FileDescriptor fd) throws IOException {\n+        \/\/ Originally this used fdAccess.markClosed() and close0() but leaving\n+        \/\/ the FD value set breaks JDKSocketResource (we don't want the extra\n+        \/\/ test if the FD resource has been marked).\n+        fdAccess.close(fd);\n@@ -63,0 +144,4 @@\n+    static native void beforeCheckpoint0();\n+\n+    static native void afterRestore0() throws IOException;\n+\n@@ -66,0 +151,4 @@\n+        \/\/ We cannot register using normal priority because other JDK resources\n+        \/\/ might read configuration files with this or later priority.\n+        \/\/ It's difficult to trigger static initialization outside the package.\n+        Core.Priority.PRE_FILE_DESCRIPTORS.getContext().register(resourceProxy);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDispatcher.java","additions":90,"deletions":1,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -675,0 +675,10 @@\n+    {\n+      \/\/ TODO: this should depend on CRaCEngine!\n+      const int restore_signal = SIGRTMIN + 2;\n+      \/\/ block restore_signal in launcher thread to allow JVM handle it\n+      sigset_t block_sig;\n+      sigemptyset(&block_sig);\n+      sigaddset(&block_sig, restore_signal);\n+      pthread_sigmask(SIG_BLOCK, &block_sig, NULL);\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+#ifdef LINUX\n+#include <sys\/syscall.h>\n+#endif\n@@ -388,0 +391,3 @@\n+#ifdef LINUX\n+    pid = (jchar)syscall(SYS_getpid);\n+#else\n@@ -389,0 +395,1 @@\n+#endif \/\/ !LINUX\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet4AddressImpl.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#ifdef LINUX\n+#include <sys\/syscall.h>\n+#endif\n@@ -596,0 +599,3 @@\n+#ifdef LINUX\n+    pid = (jchar)syscall(SYS_getpid);\n+#else\n@@ -597,0 +603,1 @@\n+#endif \/\/ !LINUX\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet6AddressImpl.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -112,0 +112,4 @@\n+\n+    \/\/ CRaC support\n+    public long getRestoreTime();\n+    public long getUptimeSinceRestore();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagement.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,0 +279,12 @@\n+\n+    \/\/ CRaC support\n+    private native long getRestoreTime0();\n+    private native long getUptimeSinceRestore0();\n+\n+    public long getRestoreTime() {\n+        return getRestoreTime0();\n+    }\n+\n+    public long getUptimeSinceRestore() {\n+        return getUptimeSinceRestore0();\n+    }\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagementImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -335,0 +335,16 @@\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_VMManagementImpl_getRestoreTime0\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return jmm_interface->GetLongAttribute(env, NULL,\n+                                           JMM_JVM_RESTORE_START_TIME_MS);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_VMManagementImpl_getUptimeSinceRestore0\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return jmm_interface->GetLongAttribute(env, NULL,\n+                                           JMM_JVM_UPTIME_SINCE_RESTORE_MS);\n+}\n","filename":"src\/java.management\/share\/native\/libmanagement\/VMManagementImpl.c","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -291,1 +291,12 @@\n-        HYBRID\n+        HYBRID,\n+        FMA4,\n+        MOVBE,\n+        OSXSAVE,\n+        IBT,\n+        SHSTK,\n+        XSAVE,\n+        CMPXCHG16,\n+        LAHFSAHF,\n+        HTT,\n+        XSAVEC,\n+        AVX_Fast_Unaligned_Load\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <stdbool.h>\n@@ -105,0 +106,2 @@\n+static void subscribe_crac_events(jvmtiEnv*);\n+\n@@ -331,0 +334,2 @@\n+    subscribe_crac_events(gdata->jvmti);\n+\n@@ -1339,0 +1344,48 @@\n+\n+static void JNICALL\n+cbBeforeCheckpoint(jvmtiEnv* jvmti_env, ...)\n+{\n+    gdata->checkpointInProgress = JNI_TRUE;\n+    transport_before_checkpoint();\n+    gdata->checkpointInProgress = JNI_FALSE;\n+}\n+\n+static void JNICALL\n+cbAfterRestore(jvmtiEnv* jvmti_env, ...)\n+{\n+    gdata->restoreInProgress = JNI_TRUE;\n+    debugInit_reset(getEnv());\n+    gdata->restoreInProgress = JNI_FALSE;\n+}\n+\n+static void\n+subscribe_crac_events(jvmtiEnv* jvmti)\n+{\n+    jint extensionEventCount = 0;\n+    jvmtiExtensionEventInfo* extensionEvents = NULL;\n+    jvmtiError err = (*jvmti)->GetExtensionEvents(jvmti, &extensionEventCount, &extensionEvents);\n+    if (JVMTI_ERROR_NONE != err) {\n+        TTY_MESSAGE((\"Failed enumerating JVMTI extension events: %s(%d)\", jvmtiErrorText(err), (int)err));\n+        return;\n+    }\n+\n+    bool beforeCheckpointFound = false;\n+    bool afterRestoreFound = false;\n+    for (jint i = 0; i < extensionEventCount && (!beforeCheckpointFound || !afterRestoreFound); ++i) {\n+        if (0 == strcmp(\"jdk.crac.events.BeforeCheckpoint\", extensionEvents[i].id)) {\n+            (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents[i].extension_event_index, &cbBeforeCheckpoint);\n+            beforeCheckpointFound = true;\n+        }\n+        else if (0 == strcmp(\"jdk.crac.events.AfterRestore\", extensionEvents[i].id)) {\n+            (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents[i].extension_event_index, &cbAfterRestore);\n+            afterRestoreFound = true;\n+        }\n+    }\n+    if (beforeCheckpointFound != afterRestoreFound) {\n+        ERROR_MESSAGE((\"Failed subscribing CRaC events: beforeCheckpoint %d, afterRestore %d\", beforeCheckpointFound, afterRestoreFound));\n+        forceExit(1);\n+    }\n+    if (!beforeCheckpointFound) {\n+        TTY_MESSAGE((\"CRaC JVMTI extension events not found\"));\n+    }\n+}\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -148,0 +148,3 @@\n+    jboolean checkpointInProgress;\n+    jboolean restoreInProgress;\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#ifdef LINUX\n+#include <sys\/syscall.h>\n+#endif\n@@ -94,0 +97,5 @@\n+#ifdef LINUX\n+        pid_t pid = syscall(SYS_getpid);\n+#else\n+        pid_t pid = getpid();\n+#endif \/\/ !LINUX\n@@ -96,1 +104,1 @@\n-                       FD_DIR, getpid()));\n+                       FD_DIR, pid));\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libjdwp\/exec_md.c","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -701,0 +701,5 @@\n+    \/**\n+     * Starts recording based on -XX:StartFlightRecorder passed on restore.\n+     *\/\n+    public static native void startFlightRecorderAfterRestore();\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import static jdk.jfr.internal.LogLevel.ERROR;\n@@ -34,0 +35,1 @@\n+import java.io.File;\n@@ -35,0 +37,1 @@\n+import java.nio.file.Files;\n@@ -47,0 +50,1 @@\n+import java.util.stream.Collectors;\n@@ -48,0 +52,4 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -70,0 +78,88 @@\n+    private JDKResource resource = new JDKResource() {\n+        private List<PlatformRecording> futureRecordings;\n+        private static int MAX_BACKUPS = Integer.getInteger(\"jdk.jfr.max_backups\", 20);\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            synchronized (PlatformRecorder.this) {\n+                ArrayList<PlatformRecording> copy = new ArrayList<>(recordings);\n+                futureRecordings = copy.stream().map(r -> {\n+                    \/\/ PlatformRecording has to have a matching Recording - otherwise we could not control those\n+                    \/\/ through jcmd\n+                    Recording rec = new Recording(r.getSettings());\n+                    PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(rec);\n+                    if (r.getName().equals(String.valueOf(r.getId()))) {\n+                        \/\/ default name == id, use the new id as name as well\n+                        rec.setName(String.valueOf(rec.getId()));\n+                    } else {\n+                        \/\/ custom name, keep it\n+                        rec.setName(r.getName());\n+                    }\n+                    rec.setToDisk(r.isToDisk());\n+                    rec.setSettings(r.getSettings());\n+                    pr.setDumpDirectory(r.getDumpDirectory());\n+                    try {\n+                        pr.setDestination(r.getDestination());\n+                    } catch (IOException e) {\n+                        \/\/ never thrown\n+                        Logger.log(JFR, ERROR, \"Cannot copy destination: \" + e.getMessage());\n+                    }\n+                    rec.setMaxAge(r.getMaxAge());\n+                    rec.setMaxSize(r.getMaxSize());\n+                    pr.setInternalDuration(r.getDuration());\n+                    rec.setDumpOnExit(r.getDumpOnExit());\n+                    pr.setFlushInterval(r.getFlushInterval());\n+                    return pr;\n+                }).collect(Collectors.toList());\n+                recordings.removeAll(futureRecordings);\n+                copy.forEach(r -> r.stop(\"Checkpoint\"));\n+                assert recordings.isEmpty();\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            synchronized (PlatformRecorder.this) {\n+                futureRecordings.forEach(r -> {\n+                    recordings.add(r);\n+                    WriteablePath destination = r.getDestination();\n+                    \/\/ The backup recording has to be moved before creating WriteablePath\n+                    \/\/ (and touching the recording output file)\n+                    try {\n+                        File destFile = destination.getReal().toFile();\n+                        if (destFile.exists()) {\n+                            Path backup = null;\n+                            for (int i = 0; backup == null && i < MAX_BACKUPS; ++i) {\n+                                String name = destFile.getName();\n+                                \/\/ Mission Control has issues opening recording files\n+                                \/\/ that don't end with .jfr\n+                                if (name.endsWith(\".jfr\")) {\n+                                    name = name.substring(0, name.length() - 4) + \".\" + i + \".jfr\";\n+                                } else {\n+                                    name = name + \".\" + i;\n+                                }\n+                                backup = destination.getReal().getParent().resolve(name);\n+                                if (backup.toFile().exists()) {\n+                                    backup = null;\n+                                }\n+                            }\n+                            if (backup != null) {\n+                                Files.move(destFile.toPath(), backup);\n+                                Logger.log(JFR, INFO, \"Backed up \" + destFile + \" to \" + backup);\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        Logger.log(JFR, ERROR, \"Cannot backup previous recording: \" + e);\n+                    }\n+                    try {\n+                        \/\/ We need to invoke WriteablePath after restore to create the dump file.\n+                        \/\/ Since we're creating another WriteablePath we can use the original specification\n+                        r.setDestination(new WriteablePath(destination.getPath()));\n+                    } catch (IOException e) {\n+                        Logger.log(JFR, ERROR, \"Cannot reset recording destination: \" + e);\n+                    }\n+                    r.start();\n+                });\n+            }\n+        }\n+    };\n@@ -83,0 +179,2 @@\n+\n+        Core.Priority.JFR.getContext().register(resource);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -842,0 +842,4 @@\n+    Path getDumpDirectory() {\n+        return dumpDirectory;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -288,0 +288,3 @@\n+        \/\/ After restoring with CRaC the new process can appear 'younger'\n+        \/\/ than last value in counters - we will return -1 (unavailable).\n+        if (!failed && pticks->usedKernel >= tmp.usedKernel && pticks->total >= tmp.total && pticks->used >= tmp.used) {\n@@ -289,3 +292,0 @@\n-        if (!failed) {\n-\n-            assert(pticks->usedKernel >= tmp.usedKernel);\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.crac.management.CRaCMXBean;\n@@ -44,0 +45,2 @@\n+\n+import jdk.crac.management.internal.CRaCImpl;\n@@ -56,0 +59,5 @@\n+    \/\/ CRaC\n+    private static CRaCMXBean cracMXBean = null;\n+    public static final String CRAC_MXBEAN_NAME =\n+        \"jdk.management:type=CRaC\";\n+\n@@ -334,0 +342,30 @@\n+        \/**\n+         * CRaC MXBean\n+         *\/\n+        initMBeanList.add(new PlatformComponent<CRaCMXBean>() {\n+            private final Set<String> cracMXBeanInterfaceNames =\n+                Collections.singleton(\"jdk.crac.management.CRaCMXBean\");\n+\n+            @Override\n+            public Set<Class<? extends CRaCMXBean>> mbeanInterfaces() {\n+                return Collections.singleton(CRaCMXBean.class);\n+            }\n+\n+            @Override\n+            public Set<String> mbeanInterfaceNames() {\n+                return cracMXBeanInterfaceNames;\n+            }\n+\n+            @Override\n+            public String getObjectNamePattern() {\n+                return CRAC_MXBEAN_NAME;\n+            }\n+\n+            @Override\n+            public Map<String, CRaCMXBean> nameToMBeanMap() {\n+                return Collections.<String, CRaCMXBean>singletonMap(\n+                    CRAC_MXBEAN_NAME,\n+                    getCRaCMXBean());\n+            }\n+        });\n+\n@@ -351,0 +389,7 @@\n+\n+    private static synchronized CRaCMXBean getCRaCMXBean() {\n+        if (cracMXBean == null) {\n+            cracMXBean = new CRaCImpl(ManagementFactoryHelper.getVMManagement());\n+        }\n+        return cracMXBean;\n+    }\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -109,0 +109,2 @@\n+# JDK-8310862 was closed but we're still seeing errors with the updated test\n+runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8310862 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -499,0 +499,6 @@\n+\n+# jdk_crac\n+\n+jdk\/crac\/LinkedCleanableRefTest.java                            8353064 generic-all\n+\n+############################################################################\n","filename":"test\/jdk\/ProblemList.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracContainerBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.util.HashMap;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test ContainerOOMETest\n+ * @requires (os.family == \"linux\")\n+ * @requires container.support\n+ * @comment Static JDK eagerly loads X11 which is missing from the Docker image\n+ * @requires !jdk.static\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build ContainerOOMETest\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest\n+ *\/\n+public class ContainerOOMETest implements CracTest {\n+    private static final String AFTER_OOME = \"AFTER OOME\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        DockerTestUtils.checkCanUseResourceLimits();\n+        final String imageName = Common.imageName(\"oome-test\");\n+        CracContainerBuilder builder = new CracContainerBuilder()\n+                .captureOutput(true)\n+                .inDockerImage(imageName)\n+                .dockerOptions(\"-m\", \"256M\")\n+                .runContainerDirectly(true)\n+                \/\/ Without specific request for G1 we would get Serial on 256M\n+                .vmOption(\"-XX:+UseG1GC\")\n+                .vmOption(\"-Xmx4G\")\n+                .vmOption(\"-XX:CRaCMaxHeapSizeBeforeCheckpoint=128M\");\n+        try {\n+            builder.startCheckpoint().outputAnalyzer()\n+                    .shouldHaveExitValue(137) \/\/ checkpoint\n+                    .stderrShouldContain(AFTER_OOME);\n+            builder.clearDockerOptions().clearVmOptions().captureOutput(false);\n+            builder.doRestore();\n+        } finally {\n+            builder.ensureContainerKilled();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try {\n+            lotOfAllocations();\n+            fail(\"Should have OOMEd\");\n+        } catch (OutOfMemoryError error) {\n+            \/\/ ignore the error\n+        }\n+        System.err.println(AFTER_OOME);\n+        Core.checkpointRestore();\n+        lotOfAllocations();\n+    }\n+\n+    private static void lotOfAllocations() {\n+        HashMap<String, String> map = new HashMap<>();\n+        for (int i = 0; i < 10000000; ++i) {\n+            String str = String.valueOf(i);\n+            map.put(str, str);\n+            if (i % 1000000 == 0) {\n+                System.err.println(i + \": \" + Runtime.getRuntime().totalMemory());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContainerOOMETest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.crac.CracContainerBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertLessThan;\n+\n+\/*\n+ * @test ContainerPidAdjustmentTest\n+ * @summary The test checks that process PID is adjusted with the specified value, when checkpointing in a container. Default min PID value is 128.\n+ * @requires (os.family == \"linux\")\n+ * @requires container.support\n+ * @comment Static JDK eagerly loads X11 which is missing from the Docker image\n+ * @requires !jdk.static\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build ContainerPidAdjustmentTest\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  true   false  INF     true   128\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  true   true   1       false  1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  true   true   100     true   100\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  false  INF     false  1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   1       false  1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   1       true   1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   200     true   200\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   1000    false  1000\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   2000    true   2000   1000\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   0       true   -1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   -10     true   -1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   blabla  true   -1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   5000000 true   -1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   5000000 true   -1     MAX-100\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   MAX-1   true   -1\n+ *\/\n+public class ContainerPidAdjustmentTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean runDirectly;\n+\n+    @CracTestArg(1)\n+    boolean needSetMinPid;\n+\n+    @CracTestArg(2)\n+    String lastPid;\n+\n+    @CracTestArg(3)\n+    boolean usePrivilegedContainer;\n+\n+    @CracTestArg(4)\n+    long expectedLastPid;\n+\n+    @CracTestArg(value = 5, optional = true)\n+    String lastPidSetup;\n+\n+    final private String CURRENT_PID_MESSAGE = \"Current PID = \";\n+    final private String MAX_PID_PREFIX = \"MAX\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        final String imageName = Common.imageName(\"pid-adjustment\");\n+        CracContainerBuilder builder = new CracContainerBuilder()\n+            .inDockerImage(imageName)\n+            .runContainerDirectly(runDirectly)\n+            .containerUsePrivileged(usePrivilegedContainer);\n+        try {\n+            if (needSetMinPid) {\n+                builder.vmOption(\"-XX:CRaCMinPid=\" + createLastPidValue(lastPid));\n+            }\n+            if (0 > expectedLastPid) {\n+                builder.captureOutput(true);\n+            }\n+            if (null != lastPidSetup) {\n+                \/\/ Set up the initial last pid,\n+                \/\/ create a non-privileged user,\n+                \/\/ and force spinning the last pid running checkpoint under the user.\n+                String setupLastPidCmd = \"export LAST_PID=\" + createLastPidValue(lastPidSetup)\n+                        + \" && echo ${LAST_PID} >\/proc\/sys\/kernel\/ns_last_pid\";\n+                if (Platform.isMusl()) {\n+                    builder.containerSetup(\"sh\", \"-x\", \"-c\",\n+                            \"adduser -D the_user && cat \/proc\/sys\/kernel\/pid_max && \" + setupLastPidCmd);\n+                } else {\n+                    builder.containerSetup(\"bash\", \"-x\", \"-c\",\n+                            \"useradd the_user && cat \/proc\/sys\/kernel\/pid_max && \" + setupLastPidCmd);\n+                }\n+                builder.dockerCheckpointOptions(\"-u\", \"the_user\");\n+            }\n+\n+            if (0 < expectedLastPid) {\n+                builder.startCheckpoint().waitForSuccess();\n+            } else {\n+                final int expectedExitValue = (int)java.lang.Math.abs(expectedLastPid);\n+                CracProcess process = builder.startCheckpoint();\n+                final int exitValue = process.waitFor();\n+                assertEquals(expectedExitValue, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+                OutputAnalyzer oa = process.outputAnalyzer();\n+                oa.shouldNotContain(CURRENT_PID_MESSAGE);\n+                if (null != lastPidSetup) {\n+                    oa.shouldContain(\"spin_last_pid: Invalid argument (\" + lastPid + \")\");\n+                }\n+            }\n+        } finally {\n+            builder.ensureContainerKilled();\n+        }\n+    }\n+\n+    private String createLastPidValue(String expr) {\n+        if (expr.startsWith(MAX_PID_PREFIX)){\n+            expr = expr.substring(MAX_PID_PREFIX.length());\n+            expr = \"$(($(cat \/proc\/sys\/kernel\/pid_max)\" + expr + \"))\";\n+        }\n+        return expr;\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(CURRENT_PID_MESSAGE + ProcessHandle.current().pid());\n+        assertLessThan((long)0, expectedLastPid, \"Shouldn't happen\");\n+        assertLessThan(expectedLastPid, ProcessHandle.current().pid());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContainerPidAdjustmentTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.util.FileUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build JcmdArgsTest\n+ * @run driver\/timeout=10 jdk.test.lib.crac.CracTest false\n+ * @run driver\/timeout=10 jdk.test.lib.crac.CracTest true\n+ *\/\n+public class JcmdArgsTest implements CracTest {\n+    private static final String READY = \"TEST:READY\";\n+    private static final String CHECKPOINTED = \"TEST:CHECKPOINTED\";\n+\n+    @CracTestArg\n+    boolean useFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        \/\/ Ensure the image does not exist\n+        Path imageDir = new CracBuilder().imageDir();\n+        if (imageDir.toFile().isDirectory()) {\n+            FileUtils.deleteFileTreeWithRetry(imageDir);\n+        }\n+\n+        CracProcess process = new CracBuilder().engine(CracEngine.SIMULATE).captureOutput(true).startCheckpoint();\n+        var queue = new LinkedBlockingQueue<String>();\n+        process.watch(line -> {\n+            System.out.println(line);\n+            if (line.startsWith(\"TEST:\")) {\n+                queue.add(line);\n+            }\n+        }, System.err::println);\n+        assertEquals(READY, queue.take());\n+        String[] args;\n+        if (useFile) {\n+            Path metricsPath = createTemp(\"metrics\", \"dummy\\t=45\\n   foo.bar = 123.0 \\n\");\n+            Path labelsPath = createTemp(\"labels\", \" xxx= yyy\\naaa=bbb\");\n+            args = new String[] { \"metrics=@\" + metricsPath, \"labels=@\" + labelsPath };\n+        } else {\n+            args = new String[] { \"metrics=foo.bar=123\", \"labels=xxx=yyy\" };\n+        }\n+        new CracBuilder().checkpointViaJcmd(process.pid(), args);\n+        assertEquals(CHECKPOINTED, queue.take());\n+        process.input().write('\\n');\n+        process.input().flush();\n+        process.waitForSuccess();\n+\n+        assertTrue(Files.readAllLines(imageDir.resolve(\"score\")).stream()\n+                .anyMatch(\"foo.bar=123.000000\"::equals));\n+        assertTrue(Files.readAllLines(imageDir.resolve(\"tags\")).stream()\n+                .anyMatch(\"label:xxx=yyy\"::equals));\n+    }\n+\n+    private static Path createTemp(String name, String text) throws IOException {\n+        Path path = Files.createTempFile(name, \".txt\");\n+        path.toFile().deleteOnExit();\n+        Files.writeString(path, text);\n+        return path;\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.getGlobalContext().register(new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) {\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                System.out.println(CHECKPOINTED);\n+            }\n+        });\n+        System.out.println(READY);\n+        System.in.read();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/JcmdArgsTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import com.sun.management.VMOption;\n+\n+import jdk.crac.*;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Files;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build VMOptionsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class VMOptionsTest implements CracTest {\n+    private static final String RESTORE_MSG = \"RESTORED\";\n+\n+    private record VMOptionSpec(\n+        String name,\n+        String strValue,\n+        Boolean boolValue,\n+        \/**\n+         * Whether the option can be changed in the restored JVM. This is not\n+         * the same as being RESTORE_SETTABLE: for this to be true the option\n+         * must be RESTORE_SETTABLE but some RESTORE_SETTABLE options are not\n+         * applied in the restored JVM (e.g. engine options).\n+         *\/\n+        boolean canChangeOnRestore\n+    ) {\n+        public VMOptionSpec {\n+            assertNotNull(name, \"Option must have a name\");\n+            assertTrue(strValue != null ^ boolValue != null, \"Option must have one type of value\");\n+        }\n+\n+        public static VMOptionSpec ofStr(String name, String value, boolean canChangeOnRestore) {\n+            assertNotNull(value, \"String option must have a value\");\n+            return new VMOptionSpec(name, value, null, canChangeOnRestore);\n+        }\n+\n+        public static VMOptionSpec ofBool(String name, boolean value, boolean canChangeOnRestore) {\n+            return new VMOptionSpec(name, null, value, canChangeOnRestore);\n+        }\n+\n+        public boolean isStr() {\n+            return strValue != null;\n+        }\n+\n+        public boolean isBool() {\n+            return boolValue != null;\n+        }\n+\n+        public String asArgument() {\n+            return isStr() ? name + \"=\" + strValue : (boolValue ? \"+\" : \"-\") + name;\n+        }\n+\n+        public String valueAsString() {\n+            return isStr() ? strValue : boolValue.toString();\n+        }\n+    };\n+\n+    private static final List<VMOptionSpec> OPTIONS_CHECKPOINT = List.of(\n+        VMOptionSpec.ofStr(\"CRaCEngine\", \"criu\", false),\n+        VMOptionSpec.ofStr(\"CRaCEngineOptions\", \"args=-v1\", false),\n+        VMOptionSpec.ofStr(\"CRaCCheckpointTo\", new CracBuilder().imageDir().toString(), true),\n+        VMOptionSpec.ofStr(\"NativeMemoryTracking\", \"off\", false)\n+    );\n+    private static final List<VMOptionSpec> OPTIONS_RESTORE = List.of(\n+        VMOptionSpec.ofStr(\"CRaCEngine\", \"criuengine\", false),\n+        VMOptionSpec.ofStr(\"CRaCEngineOptions\", \"args=-v2\", false),\n+        VMOptionSpec.ofStr(\"CRaCCheckpointTo\", \"another\", true),\n+        VMOptionSpec.ofStr(\"CRaCIgnoredFileDescriptors\", \"42,43\", true),\n+        VMOptionSpec.ofBool(\"UnlockExperimentalVMOptions\", true, true)\n+    );\n+\n+    @Override\n+    public void test() throws Exception {\n+        final var builder = new CracBuilder().engine(CracEngine.CRIU).captureOutput(true);\n+        setVmOptions(builder, OPTIONS_CHECKPOINT);\n+        builder.doCheckpoint();\n+\n+        \/\/ Only restore-settable options => should succeed\n+        builder.clearVmOptions();\n+        setVmOptions(builder, OPTIONS_RESTORE);\n+        checkRestoreOutput(builder.doRestore());\n+\n+        \/\/ Adding a non-restore-settable option => should fail\n+        builder.vmOption(\"-XX:NativeMemoryTracking=summary\");\n+        builder.startRestore().outputAnalyzer().shouldHaveExitValue(1).stderrShouldContain(\n+            \"VM option 'NativeMemoryTracking' is not restore-settable and is not available on restore\"\n+        );\n+\n+        \/\/ Non-restore-settable option from before + allowing restore to fail => should succeed\n+        builder.vmOption(\"-XX:+CRaCIgnoreRestoreIfUnavailable\");\n+        checkRestoreOutput(builder.doRestore());\n+\n+        \/\/ Only restore-settable options coming from a settings file => should succeed\n+        builder.clearVmOptions();\n+        builder.vmOption(\"-XX:Flags=\" + createSettingsFile(OPTIONS_RESTORE));\n+        checkRestoreOutput(builder.doRestore());\n+\n+        \/\/ Only restore-settable options coming from a VM options file => should succeed\n+        builder.clearVmOptions();\n+        builder.vmOption(\"-XX:VMOptionsFile=\" + createVMOptionsFile(OPTIONS_RESTORE));\n+        checkRestoreOutput(builder.doRestore());\n+\n+        \/\/ Unrecognized option => should fail\n+        builder.clearVmOptions();\n+        setVmOptions(builder, OPTIONS_RESTORE);\n+        builder.vmOption(\"-XX:SomeNonExistentOption=abc\");\n+        builder.startRestore().outputAnalyzer().shouldHaveExitValue(1).stderrShouldContain(\n+            \"Unrecognized VM option 'SomeNonExistentOption=abc'\"\n+        );\n+\n+        \/\/ Unrecognized option from before + IgnoreUnrecognizedVMOptions => should succeed\n+        builder.vmOption(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        checkRestoreOutput(builder.doRestore());\n+    }\n+\n+    @Override\n+    public void exec() throws RestoreException, CheckpointException {\n+        HotSpotDiagnosticMXBean bean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+\n+        for (final var optSpec : OPTIONS_CHECKPOINT) {\n+            final var opt = bean.getVMOption(optSpec.name());\n+            assertEquals(optSpec.valueAsString(), opt.getValue(), optSpec.name() + \": value not set before checkpoint\");\n+            assertEquals(VMOption.Origin.VM_CREATION, opt.getOrigin(), optSpec.name() + \": unexpected origin before checkpoint\");\n+        }\n+        for (final var optSpec : OPTIONS_RESTORE) {\n+            final var opt = bean.getVMOption(optSpec.name());\n+            final var expectedOrigin = OPTIONS_CHECKPOINT.stream().anyMatch(o -> o.name().equals(optSpec.name())) ?\n+                VMOption.Origin.VM_CREATION : VMOption.Origin.DEFAULT;\n+            assertEquals(expectedOrigin, opt.getOrigin(), optSpec.name() + \": unexpected origin before checkpoint\");\n+        }\n+\n+        Core.checkpointRestore();\n+        System.out.println(RESTORE_MSG);\n+\n+        for (final var optSpec : OPTIONS_CHECKPOINT) {\n+            if (!optSpec.canChangeOnRestore() || OPTIONS_RESTORE.stream().noneMatch(o -> o.name().equals(optSpec.name()))) {\n+                final var opt = bean.getVMOption(optSpec.name());\n+                assertEquals(optSpec.valueAsString(), opt.getValue(), optSpec.name() + \": value changed after restore\");\n+                assertEquals(VMOption.Origin.VM_CREATION, opt.getOrigin(), optSpec.name() + \": origin changed after restore\");\n+            }\n+        }\n+        {\n+            final var ignoreUnrecognized = bean.getVMOption(\"IgnoreUnrecognizedVMOptions\");\n+            assertEquals(VMOption.Origin.DEFAULT, ignoreUnrecognized.getOrigin(), \"IgnoreUnrecognizedVMOptions: origin changed after restore\");\n+        }\n+        for (final var optSpec : OPTIONS_RESTORE) {\n+            final var opt = bean.getVMOption(optSpec.name());\n+            if (!optSpec.canChangeOnRestore()) {\n+                final var expectedOrigin = OPTIONS_CHECKPOINT.stream().anyMatch(o -> o.name().equals(optSpec.name())) ?\n+                    VMOption.Origin.VM_CREATION : VMOption.Origin.DEFAULT;\n+                assertEquals(expectedOrigin, opt.getOrigin(), optSpec.name() + \": origin changed after restore\");\n+            } else {\n+                assertEquals(optSpec.valueAsString(), opt.getValue(), optSpec.name() + \": value not changed after restore\");\n+                assertEquals(VMOption.Origin.OTHER, opt.getOrigin(), optSpec.name() + \": unexpected origin after restore\");\n+            }\n+        }\n+    }\n+\n+    private static void checkRestoreOutput(CracProcess restored) throws Exception {\n+        restored.outputAnalyzer()\n+            .shouldNotContain(\"[warning]\")\n+            .shouldNotContain(\"[error]\")\n+            .stdoutShouldContain(RESTORE_MSG);\n+    }\n+\n+    private static void setVmOptions(CracBuilder builder, List<VMOptionSpec> options) {\n+        for (final var opt : options) {\n+            builder.vmOption(\"-XX:\" + opt.asArgument());\n+        }\n+    }\n+\n+    private static String createSettingsFile(List<VMOptionSpec> options) throws Exception {\n+        final var path = Utils.createTempFile(\"settings\", \".txt\");\n+        Files.write(\n+            path,\n+            options.stream().map(opt -> opt.asArgument()).collect(Collectors.toList())\n+        );\n+        return path.toString();\n+    }\n+\n+    private static String createVMOptionsFile(List<VMOptionSpec> options) throws Exception {\n+        final var path = Utils.createTempFile(\"vmoptions\", \".txt\");\n+        Files.write(\n+            path,\n+            options.stream().map(opt -> \"-XX:\" + opt.asArgument()).collect(Collectors.toList())\n+        );\n+        return path.toString();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/VMOptionsTest.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.management.CRaCMXBean;\n+import jdk.test.lib.Container;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.crac.CracContainerBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.RuntimeMXBean;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test NanoTimeTest\n+ * @requires (os.family == \"linux\")\n+ * @requires container.support\n+ * @comment Static JDK eagerly loads X11 which is missing from the Docker image\n+ * @requires !jdk.static\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build NanoTimeTest\n+ * @run driver jdk.test.lib.crac.CracTest      0 true\n+ * @run driver jdk.test.lib.crac.CracTest  86400 true\n+ * @run driver jdk.test.lib.crac.CracTest -86400 true\n+ * @run driver jdk.test.lib.crac.CracTest  86400 false\n+ * @run driver jdk.test.lib.crac.CracTest -86400 false\n+ *\/\n+public class NanoTimeTest implements CracTest {\n+    @CracTestArg(0)\n+    long monotonicOffset;\n+\n+    @CracTestArg(1)\n+    boolean changeBootId;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracContainerBuilder builder = new CracContainerBuilder();\n+        Path bootIdFile = Files.createTempFile(\"NanoTimeTest-\", \"-boot_id\");\n+\n+        String imageName = Common.imageName(\"system-nanotime\");\n+\n+        try {\n+            \/\/ TODO: use more official image\n+            String baseImage = Platform.isMusl() ? \"ghcr.io\/crac\/test-base-musl\" : \"ghcr.io\/crac\/test-base\";\n+            builder.withBaseImage(baseImage, \"latest\")\n+                    .dockerOptions(\"-v\", bootIdFile + \":\/fake_boot_id\")\n+                    .inDockerImage(imageName);\n+\n+            Files.writeString(bootIdFile, \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\n\");\n+            \/\/ We need to preload the library before checkpoint\n+            builder.doCheckpoint(Container.ENGINE_COMMAND, \"exec\",\n+                    \"-e\", \"LD_PRELOAD=\/opt\/path-mapping-quiet.so\",\n+                    \"-e\", \"PATH_MAPPING=\/proc\/sys\/kernel\/random\/boot_id:\/fake_boot_id\",\n+                    CracContainerBuilder.CONTAINER_NAME,\n+                    \/\/ In case we are trying to use negative monotonic offset we could\n+                    \/\/ run into situation where we'd set it to negative value (prohibited).\n+                    \/\/ Therefore, we'll rather offset it to the future before checkpoint\n+                    \/\/ and set to 0 for restore.\n+                    \"unshare\", \"--fork\", \"--time\", \"--monotonic\", String.valueOf(Math.max(-monotonicOffset, 0)),\n+                    CracContainerBuilder.DOCKER_JAVA);\n+\n+            if (changeBootId) {\n+                Files.writeString(bootIdFile, \"yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\\n\");\n+            }\n+\n+            builder.doRestore(Container.ENGINE_COMMAND, \"exec\", CracContainerBuilder.CONTAINER_NAME,\n+                    \"unshare\", \"--fork\", \"--time\", \"--boottime\", \"86400\", \"--monotonic\", String.valueOf(Math.max(monotonicOffset, 0)),\n+                    CracContainerBuilder.DOCKER_JAVA);\n+        } finally {\n+            builder.ensureContainerKilled();\n+            assertTrue(bootIdFile.toFile().delete());\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(\"Expected offset: \" + monotonicOffset);\n+        \/\/ We use uptime to assert that changing the clock worked\n+        long boottimeBefore = readSystemUptime();\n+\n+        long before = System.nanoTime();\n+        Core.checkpointRestore();\n+        long after = System.nanoTime();\n+        System.out.println(\"Before: \" + before);\n+        System.out.println(\"After: \" + after);\n+        assertLTE(before, after, \"After < Before\");\n+        if (changeBootId || monotonicOffset <= 0) {\n+            \/\/ Even though we have shifted the monotic offset by a day the difference\n+            \/\/ is adjusted by difference between wall clock time before and after;\n+            \/\/ the difference in monotonic time is considered \"random\"\n+            assertLT(after, before + TimeUnit.HOURS.toNanos(1), \"After too late\");\n+        } else {\n+            assertGT(after, before + TimeUnit.HOURS.toNanos(1), \"After too early\");\n+            assertLT(after, before + TimeUnit.HOURS.toNanos(25), \"After too late\");\n+        }\n+        long boottimeAfter = readSystemUptime();\n+        assertGTE(boottimeAfter, boottimeBefore + 86_400_000, \"Boottime was not changed\");\n+        RuntimeMXBean runtimeMX = ManagementFactory.getRuntimeMXBean();\n+        assertGTE(runtimeMX.getUptime(), 0L, \"VM Uptime is negative!\");\n+        CRaCMXBean cracBean = CRaCMXBean.getCRaCMXBean();\n+        assertLT(cracBean.getUptimeSinceRestore(), 60_000L);\n+        assertGTE(cracBean.getUptimeSinceRestore(), 0L);\n+    }\n+\n+    private long readSystemUptime() throws IOException {\n+        String uptimeStr = Files.readString(Path.of(\"\/proc\/uptime\"));\n+        String[] parts = uptimeStr.split(\" \");\n+        return (long)(Double.parseDouble(parts[0]) * 1000);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/System\/NanoTimeTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.crac.CracContainerBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test TimedWaitingTest checks whether timed waiting does not block when monotonic time runs backwards\n+ * @requires (os.family == \"linux\")\n+ * @requires container.support\n+ * @comment Static JDK eagerly loads X11 which is missing from the Docker image\n+ * @requires !jdk.static\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build TimedWaitingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class TimedWaitingTest implements CracTest {\n+    public static final String WAITING = \"WAITING\";\n+    public static final int WAIT_TIME_MILLIS = 1000;\n+\n+    @Override\n+    public void test() throws Exception {\n+        String imageName = Common.imageName(\"timed-waiting\");\n+\n+        CracContainerBuilder builder = new CracContainerBuilder();\n+        Path bootIdFile = Files.createTempFile(\"TimedWaitingTest-\", \"-boot_id\");\n+        try {\n+            String baseImage = Platform.isMusl() ? \"ghcr.io\/crac\/test-base-musl\" : \"ghcr.io\/crac\/test-base\";\n+            builder.withBaseImage(baseImage, \"latest\")\n+                    .dockerOptions(\"-v\", bootIdFile + \":\/fake_boot_id\")\n+                    .inDockerImage(imageName);\n+            builder.captureOutput(true);\n+\n+            Files.writeString(bootIdFile, \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\n\");\n+            \/\/ We need to preload the library before checkpoint\n+            CracProcess checkpointed = builder.startCheckpoint(Container.ENGINE_COMMAND, \"exec\",\n+                    \"-e\", \"LD_PRELOAD=\/opt\/path-mapping-quiet.so\",\n+                    \"-e\", \"PATH_MAPPING=\/proc\/sys\/kernel\/random\/boot_id:\/fake_boot_id\",\n+                    CracContainerBuilder.CONTAINER_NAME,\n+                    \"unshare\", \"--fork\", \"--time\", \"--monotonic\", \"86400\", \"--boottime\", \"86400\",\n+                    CracContainerBuilder.DOCKER_JAVA);\n+            CountDownLatch latch = new CountDownLatch(1);\n+            checkpointed.watch(out -> {\n+                System.out.println(out);\n+                if (WAITING.equals(out)) {\n+                    latch.countDown();\n+                }\n+            }, System.err::println);\n+            latch.await();\n+            builder.checkpointViaJcmd();\n+            checkpointed.waitForCheckpointed();\n+\n+            Files.writeString(bootIdFile, \"yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\\n\");\n+\n+            CracProcess restore = builder.startRestore();\n+            CompletableFuture<Void> future = new CompletableFuture<>();\n+            new Thread(() -> {\n+                try {\n+                    restore.waitForSuccess();\n+                    System.err.print(restore.outputAnalyzer().getStderr());\n+                    future.complete(null);\n+                } catch (Throwable t) {\n+                    future.completeExceptionally(t);\n+                }\n+            }).start();\n+            future.get(10, TimeUnit.SECONDS);\n+        } finally {\n+            builder.ensureContainerKilled();\n+            assertTrue(bootIdFile.toFile().delete());\n+        }\n+    }\n+\n+    private interface Task {\n+        void run() throws InterruptedException;\n+    }\n+\n+    private static void timedWait(Task task, List<Throwable> exceptions, boolean canReturnEarly) {\n+        try {\n+            long before = System.currentTimeMillis();\n+            task.run();\n+            long after = System.currentTimeMillis();\n+            if (after - before < WAIT_TIME_MILLIS) {\n+                if (canReturnEarly) {\n+                    \/\/ Non-critical\n+                    System.err.println(Thread.currentThread().getName() + \" took: \" + (after - before) + \" ms\");\n+                } else {\n+                    exceptions.add(new IllegalStateException(\n+                            Thread.currentThread().getName() + \" was too short: \" + (after - before) + \" ms\"));\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            exceptions.add(unexpectedInterrupt(e));\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        List<Throwable> exceptions = Collections.synchronizedList(new ArrayList<>());\n+        List<Thread> threads = new ArrayList<>();\n+        CountDownLatch latch = new CountDownLatch(6);\n+\n+        startThread(\"Thread.sleep\", threads, latch, () -> {\n+            timedWait(() -> Thread.sleep(WAIT_TIME_MILLIS), exceptions, false);\n+        });\n+\n+        startThread(\"Thread.join\", threads, latch, () -> {\n+            Thread daemon = new Thread(() -> {\n+                try {\n+                    Thread.sleep(86_400_000);\n+                } catch (InterruptedException e) {\n+                    exceptions.add(unexpectedInterrupt(e));\n+                }\n+            }, \"inifinite daemon\");\n+            daemon.setDaemon(true);\n+            daemon.start();\n+            timedWait(() -> daemon.join(WAIT_TIME_MILLIS), exceptions, false);\n+        });\n+\n+        startThread(\"Object.wait\", threads, latch, () -> {\n+            synchronized (this) {\n+                timedWait(() -> this.wait(WAIT_TIME_MILLIS), exceptions, true);\n+            }\n+        });\n+\n+        ReentrantLock lock = new ReentrantLock();\n+        lock.lock();\n+        startThread(\"ReentrantLock.tryLock\", threads, latch, () -> {\n+            timedWait(() -> {\n+                if (lock.tryLock(WAIT_TIME_MILLIS, TimeUnit.MILLISECONDS)) {\n+                    exceptions.add(new AssertionError(\"Should not be able to lock\"));\n+                }\n+            }, exceptions, false);\n+        });\n+\n+        startThread(\"Condition.await\", threads, latch, () -> {\n+            ReentrantLock lock2 = new ReentrantLock();\n+            Condition condition = lock2.newCondition();\n+            lock2.lock();\n+            \/\/noinspection ResultOfMethodCallIgnored\n+            timedWait(() -> condition.await(WAIT_TIME_MILLIS, TimeUnit.MILLISECONDS), exceptions, true);\n+        });\n+\n+        startThread(\"LockSupport.parkUntil\", threads, latch, () -> {\n+            timedWait(() -> LockSupport.parkUntil(System.currentTimeMillis() + WAIT_TIME_MILLIS),\n+                    exceptions, true);\n+        });\n+\n+        assertEquals(latch.getCount(), (long) threads.size());\n+        do {\n+            Thread.yield();\n+            threads.stream().forEach(t -> {\n+                System.out.printf(\"%s: %s%n\", t.getName(), t.getState());\n+            });\n+        } while (!threads.stream().map(Thread::getState).allMatch(Thread.State.TIMED_WAITING::equals));\n+        System.out.println(WAITING);\n+        \/\/ Make sure none of the threads completed yet\n+        assertEquals(latch.getCount(), (long) threads.size());\n+        try {\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            fail(\"Should not get interrupted\", e);\n+        }\n+        assertEquals(Collections.emptyList(), exceptions);\n+    }\n+\n+    private static void startThread(String name, List<Thread> threads, CountDownLatch latch, Runnable runnable) {\n+        Thread thread = new Thread(() -> {\n+            try {\n+                runnable.run();\n+            } finally {\n+                latch.countDown();\n+            }\n+        }, name);\n+        threads.add(thread);\n+        thread.start();\n+    }\n+\n+    private static AssertionError unexpectedInterrupt(InterruptedException e) {\n+        return new AssertionError(Thread.currentThread().getName() + \" interrupted\", e);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/System\/TimedWaitingTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.crac.CracContainerBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.*;\n+\n+\/*\n+ * @test\n+ * @summary Test if InetAddress cache is flushed after checkpoint\/restore\n+ * @requires (os.family == \"linux\")\n+ * @requires container.support\n+ * @comment Static JDK eagerly loads X11 which is missing from the Docker image\n+ * @requires !jdk.static\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build ResolveTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ResolveTest implements CracTest {\n+    public static final String TEST_HOSTNAME = \"some.test.hostname.example.com\";\n+\n+    @CracTestArg(value = 0, optional = true)\n+    String ip;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String checkFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        String imageName = Common.imageName(\"inet-address\");\n+\n+        CracContainerBuilder builder = new CracContainerBuilder()\n+                .inDockerImage(imageName).dockerOptions(\"--add-host\", TEST_HOSTNAME + \":192.168.12.34\")\n+                .captureOutput(true)\n+                .args(CracTest.args(TEST_HOSTNAME, \"\/second-run\"));\n+\n+        try {\n+            CompletableFuture<?> firstOutputFuture = new CompletableFuture<Void>();\n+            builder.vmOption(\"-XX:CRaCMinPid=100\");\n+            CracProcess checkpointed = builder.startCheckpoint().watch(line -> {\n+                System.out.println(\"OUTPUT: \" + line);\n+                if (line.equals(\"192.168.12.34\")) {\n+                    firstOutputFuture.complete(null);\n+                }\n+            }, error -> {\n+                System.err.println(\"ERROR: \" + error);\n+                firstOutputFuture.cancel(false);\n+            });\n+            firstOutputFuture.get(10, TimeUnit.SECONDS);\n+            builder.checkpointViaJcmd();\n+            checkpointed.waitForCheckpointed();\n+\n+            builder.clearVmOptions();\n+            builder.recreateContainer(imageName,\n+                    \"--add-host\", TEST_HOSTNAME + \":192.168.56.78\",\n+                    \"--volume\", Utils.TEST_CLASSES + \":\/second-run\"); \/\/ any file\/dir suffices\n+\n+\n+            builder.startRestore().outputAnalyzer()\n+                    .shouldHaveExitValue(0)\n+                    .shouldContain(\"192.168.56.78\");\n+        } finally {\n+            builder.ensureContainerKilled();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (ip == null || checkFile == null) {\n+            System.err.println(\"Args: <ip address> <check file path>\");\n+            return;\n+        }\n+        printAddress(ip);\n+        while (!Files.exists(Path.of(checkFile))) {\n+            try {\n+                \/\/noinspection BusyWait\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                System.err.println(\"Interrupted!\");\n+                return;\n+            }\n+        }\n+        printAddress(ip);\n+    }\n+\n+    private static void printAddress(String hostname) {\n+        try {\n+            InetAddress address = InetAddress.getByName(hostname);\n+            \/\/ we will assume IPv4 address\n+            byte[] bytes = address.getAddress();\n+            System.out.print(bytes[0] & 0xFF);\n+            for (int i = 1; i < bytes.length; ++i) {\n+                System.out.print('.');\n+                System.out.print(bytes[i] & 0xFF);\n+            }\n+            System.out.println();\n+        } catch (UnknownHostException e) {\n+            System.out.println();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -48,0 +48,3 @@\n+        \"pauseengine\", \/\/ crac, don't test\n+        \"simengine\", \/\/ crac, don't test\n+\n","filename":"test\/jdk\/tools\/launcher\/HelpFlagsTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+        \"pauseengine\", \/\/ crac, don't test\n+        \"simengine\", \/\/ crac, don't test\n+\n@@ -70,0 +73,3 @@\n+        \"pauseengine\", \/\/ crac, don't test\n+        \"simengine\", \/\/ crac, don't test\n+\n","filename":"test\/jdk\/tools\/launcher\/VersionCheck.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,1 +70,4 @@\n-                    \"sha512\",       \"hybrid\"\n+                    \"sha512\",       \"hybrid\",           \"fma4\",              \"movbe\",\n+                    \"osxsave\",      \"ibt\",              \"shstk\",             \"xsave\",\n+                    \"cmpxchg16\",    \"lahfsahf\",         \"htt\",               \"xsavec\",\n+                    \"avx_fast_unaligned_load\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerRunOptions.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2026, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.crac;\n+\n+public class CracBuilder extends CracBuilderBase<CracBuilder> {\n+    public CracBuilder() {\n+    }\n+\n+    protected CracBuilder(CracBuilder other) {\n+        super(other);\n+    }\n+\n+    @Override\n+    protected CracBuilder self() {\n+        return this;\n+    }\n+\n+    @Override\n+    public CracBuilder copy() {\n+        return new CracBuilder(this);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,326 @@\n+\/*\n+ * Copyright (c) 2026, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.crac;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+public abstract class CracBuilderBase<T extends CracBuilderBase<T>> {\n+    private static final String DEFAULT_IMAGE_DIR = \"cr\";\n+    public static final String JAVA = Utils.TEST_JDK + \"\/bin\/java\";\n+\n+    \/\/ This dummy field is here as workaround for (possibly) a JTReg bug;\n+    \/\/ some tests don't build CracTestArg into their Test.d\/ directory\n+    \/\/ (not all classes from \/test\/lib are built!) and the tests would fail.\n+    \/\/ This does not always happen when the test is run individually but breaks\n+    \/\/ when the whole suite is executed.\n+    private static final Class<CracTestArg> dummyWorkaround = CracTestArg.class;\n+\n+    boolean verbose = true;\n+    boolean debug = false;\n+    final List<String> classpathEntries;\n+    final Map<String, String> env;\n+    final List<String> vmOptions;\n+    final Map<String, String> javaOptions;\n+    String imageDir = DEFAULT_IMAGE_DIR;\n+    CracEngine engine;\n+    String[] engineOptions;\n+    boolean printResources;\n+    boolean forwardClasspathOnRestore;\n+    Class<?> main;\n+    String[] args;\n+    boolean captureOutput;\n+    \/\/ make sure to update copy constructor when adding new fields\n+\n+    protected abstract T self();\n+\n+    public abstract T copy();\n+\n+    public CracBuilderBase() {\n+        classpathEntries = new ArrayList<>();\n+        env = new HashMap<>();\n+        vmOptions = new ArrayList<>();\n+        javaOptions = new HashMap<>();\n+    }\n+\n+    protected CracBuilderBase(T other) {\n+        verbose = other.verbose;\n+        debug = other.debug;\n+        classpathEntries = new ArrayList<>(other.classpathEntries);\n+        env = new HashMap<>(other.env);\n+        vmOptions = new ArrayList<>(other.vmOptions);\n+        javaOptions = new HashMap<>(other.javaOptions);\n+        imageDir = other.imageDir;\n+        engine = other.engine;\n+        engineOptions = other.engineOptions == null ? null : Arrays.copyOf(other.engineOptions, other.engineOptions.length);\n+        printResources = other.printResources;\n+        forwardClasspathOnRestore = other.forwardClasspathOnRestore;\n+        main = other.main;\n+        args = other.args == null ? null : Arrays.copyOf(other.args, other.args.length);\n+        captureOutput = other.captureOutput;\n+    }\n+\n+    public T verbose(boolean verbose) {\n+        this.verbose = verbose;\n+        return self();\n+    }\n+\n+    public T debug(boolean debug) {\n+        this.debug = debug;\n+        return self();\n+    }\n+\n+    public T classpathEntry(String cp) {\n+        classpathEntries.add(cp);\n+        return self();\n+    }\n+\n+    public T engine(CracEngine engine) {\n+        assertTrue(this.engine == null || this.engine.equals(engine));\n+        this.engine = engine;\n+        return self();\n+    }\n+\n+    public T engineOptions(String... options) {\n+        this.engineOptions = options;\n+        return self();\n+    }\n+\n+    public Path imageDir() {\n+        return Path.of(imageDir);\n+    }\n+\n+    public T imageDir(String imageDir) {\n+        assertEquals(DEFAULT_IMAGE_DIR, this.imageDir); \/\/ set once\n+        this.imageDir = imageDir;\n+        return self();\n+    }\n+\n+    public T vmOption(String option) {\n+        vmOptions.add(option);\n+        return self();\n+    }\n+\n+    public T clearVmOptions() {\n+        vmOptions.clear();\n+        return self();\n+    }\n+\n+    public T printResources(boolean print) {\n+        this.printResources = print;\n+        return self();\n+    }\n+\n+    public T forwardClasspathOnRestore(boolean forward) {\n+        this.forwardClasspathOnRestore = forward;\n+        return self();\n+    }\n+\n+    public T env(String name, String value) {\n+        env.put(name, value);\n+        return self();\n+    }\n+\n+    public T javaOption(String name, String value) {\n+        javaOptions.put(name, value);\n+        return self();\n+    }\n+\n+    public T main(Class<?> mainClass) {\n+        assertNull(this.main); \/\/ set once\n+        this.main = mainClass;\n+        return self();\n+    }\n+\n+    public Class<?> main() {\n+        return main != null ? main : CracTest.class;\n+    }\n+\n+    public T args(String... args) {\n+        assertNull(this.args); \/\/ set once\n+        this.args = args;\n+        return self();\n+    }\n+\n+    public String[] args() {\n+        return args != null ? args : CracTest.args();\n+    }\n+\n+    public T captureOutput(boolean captureOutput) {\n+        this.captureOutput = captureOutput;\n+        return self();\n+    }\n+\n+    public void doCheckpoint(String... javaPrefix) throws Exception {\n+        startCheckpoint(javaPrefix).waitForCheckpointed();\n+    }\n+\n+    public CracProcess startCheckpoint(String... javaPrefix) throws Exception {\n+        List<String> list = javaPrefix.length == 0 ? null : Arrays.asList(javaPrefix);\n+        return startCheckpoint(list);\n+    }\n+\n+    public CracProcess startCheckpoint(List<String> javaPrefix) throws Exception {\n+        List<String> cmd = prepareCommand(javaPrefix, false);\n+        if (imageDir != null) {\n+            cmd.add(\"-XX:CRaCCheckpointTo=\" + imageDir);\n+        }\n+        cmd.add(main().getName());\n+        cmd.addAll(Arrays.asList(args()));\n+        log(\"Starting process to be checkpointed:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    void log(String fmt, Object... args) {\n+        if (verbose) {\n+            if (args.length == 0) {\n+                System.err.println(fmt);\n+            } else {\n+                System.err.printf(fmt, args);\n+            }\n+        }\n+    }\n+\n+    public CracProcess doRestore(String... javaPrefix) throws Exception {\n+        return startRestore(javaPrefix).waitForSuccess();\n+    }\n+\n+    public CracProcess startRestore(String... javaPrefix) throws Exception {\n+        List<String> list = javaPrefix.length == 0 ? null : Arrays.asList(javaPrefix);\n+        return startRestore(list);\n+    }\n+\n+    public CracProcess startRestore(List<String> javaPrefix) throws Exception {\n+        return startRestoreWithArgs(javaPrefix, null);\n+    }\n+\n+    public CracProcess startRestoreWithArgs(List<String> javaPrefix, List<String> args) throws Exception {\n+        List<String> cmd = prepareCommand(javaPrefix, true);\n+        if (imageDir != null) {\n+            cmd.add(\"-XX:CRaCRestoreFrom=\" + imageDir);\n+        }\n+        if (null != args) {\n+            cmd.addAll(args);\n+        }\n+        log(\"Starting restored process:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    public CracProcess startPlain() throws IOException {\n+        List<String> cmd = new ArrayList<>(getPlainCommandPrefix());\n+        cmd.add(JAVA);\n+        cmd.add(\"-ea\");\n+        cmd.add(\"-cp\");\n+        cmd.add(getClassPath());\n+        if (debug) {\n+            cmd.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=0.0.0.0:5005\");\n+        }\n+        cmd.addAll(vmOptions);\n+        for (var entry : javaOptions.entrySet()) {\n+            cmd.add(\"-D\" + entry.getKey() + \"=\" + entry.getValue());\n+        }\n+        cmd.add(main().getName());\n+        cmd.addAll(Arrays.asList(args()));\n+        log(\"Starting process without CRaC:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    protected List<String> getPlainCommandPrefix() {\n+        return List.of();\n+    }\n+\n+    private String getClassPath() {\n+        String classPath = classpathEntries.isEmpty() ? \"\" : String.join(File.pathSeparator, classpathEntries) + File.pathSeparator;\n+        return classPath + getTestClassPath();\n+    }\n+\n+    protected String getTestClassPath() {\n+        return Utils.TEST_CLASS_PATH;\n+    }\n+\n+    public CracProcess doPlain() throws IOException, InterruptedException {\n+        return startPlain().waitForSuccess();\n+    }\n+\n+    private List<String> prepareCommand(List<String> javaPrefix, boolean isRestore) {\n+        List<String> cmd = new ArrayList<>(javaPrefix != null ? javaPrefix : getDefaultJavaPrefix());\n+        cmd.add(\"-ea\");\n+        if (engine != null) {\n+            cmd.add(\"-XX:CRaCEngine=\" + engine.engine);\n+        }\n+        if (engineOptions != null) {\n+            cmd.add(\"-XX:CRaCEngineOptions=\" + String.join(\",\", engineOptions));\n+        }\n+        if (!isRestore || forwardClasspathOnRestore) {\n+            cmd.add(\"-cp\");\n+            cmd.add(getClassPath());\n+        }\n+        if (!isRestore && printResources) {\n+            cmd.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+            cmd.add(\"-XX:+CRaCPrintResourcesOnCheckpoint\");\n+        }\n+        if (debug) {\n+            cmd.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=0.0.0.0:5005\");\n+        }\n+        cmd.addAll(vmOptions);\n+        for (var entry : javaOptions.entrySet()) {\n+            cmd.add(\"-D\" + entry.getKey() + \"=\" + entry.getValue());\n+        }\n+        return cmd;\n+    }\n+\n+    protected List<String> getDefaultJavaPrefix() {\n+        return List.of(JAVA);\n+    }\n+\n+    public void doCheckpointAndRestore() throws Exception {\n+        doCheckpoint();\n+        doRestore();\n+    }\n+\n+    public void checkpointViaJcmd(long pid, String... args) throws Exception {\n+        runJcmd(Long.toString(pid), Stream.concat(Stream.of(\"JDK.checkpoint\"), Stream.of(args)).toArray(String[]::new))\n+                .shouldHaveExitValue(0).outputTo(System.out).errorTo(System.err);\n+    }\n+\n+    public OutputAnalyzer runJcmd(String id, String... command) throws Exception {\n+        final List<String> cmd = new ArrayList<>();\n+        cmd.add(Utils.TEST_JDK + \"\/bin\/jcmd\");\n+        cmd.add(id);\n+        cmd.addAll(Arrays.asList(command));\n+        log(\"Executing JCMD command for PID \" + id + \": \" + String.join(\" \", List.of(command)));\n+        return new OutputAnalyzer(new ProcessBuilder(cmd).start());\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilderBase.java","additions":326,"deletions":0,"binary":false,"changes":326,"status":"added"},{"patch":"@@ -0,0 +1,362 @@\n+\/*\n+ * Copyright (c) 2026, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.crac;\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.containers.docker.DockerfileConfig;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.FileUtils;\n+\n+import java.io.File;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * Tests using this must be tagged with:\n+ * <ul>\n+ * <li> {@code @modules java.base\/jdk.internal.platform}, see\n+ * <a href=\"https:\/\/github.com\/openjdk\/jdk\/pull\/28557#issuecomment-3597274354\">this discussion<\/a>; <\/li>\n+ * <li> {@code @requires !jdk.static} unless the test uses an image that has X11 installed,\n+ * the default image currently does not have it making static JDK that loads X11 eagerly\n+ * fail to start. <\/li>\n+ * <\/ul>\n+ *\/\n+public class CracContainerBuilder extends CracBuilderBase<CracContainerBuilder> {\n+    \/\/ Make it unique so that tests running in parallel do not conflict with:\n+    \/\/ docker: Error response from daemon: Conflict. The container name \"\/crac-test\" is already in use by container \"<hash>\". You have to remove (or rename) that container to be able to reuse that name.\n+    public static final String CONTAINER_NAME = \"crac-test\" + ProcessHandle.current().pid();\n+    public static final String DOCKER_JAVA = \"\/jdk\/bin\/java\";\n+    \/\/ Set this property to true to re-use an existing image.\n+    \/\/ By default an image will be built from scratch.\n+    \/\/ Reusing an image may be useful for running test cases with the same image,\n+    \/\/ without rebuilding it.\n+    public static final boolean REUSE_IMAGE_IF_EXIST = Boolean.getBoolean(\"jdk.test.crac.reuse.image\");\n+\n+    private static final List<String> CRIU_CANDIDATES = List.of(Utils.TEST_JDK + \"\/lib\/criu\", \"\/usr\/sbin\/criu\", \"\/sbin\/criu\");\n+    private static final String CRIU_PATH;\n+    static {\n+        String path = System.getenv(\"CRAC_CRIU_PATH\");\n+        if (path == null) {\n+            for (String candidate : CRIU_CANDIDATES) {\n+                if (new File(candidate).exists()) {\n+                    path = candidate;\n+                    break;\n+                }\n+            }\n+        }\n+        CRIU_PATH = path;\n+    }\n+\n+    String dockerImageBaseName;\n+    String dockerImageBaseVersion;\n+    String dockerImageName;\n+    private List<String> dockerOptions; \/\/ Immutable\n+    private List<String> dockerCheckpointOptions; \/\/ Immutable\n+    private List<String> containerSetupCommand; \/\/ Immutable\n+    boolean containerUsePrivileged = true;\n+    boolean runContainerDirectly = false;\n+    \/\/ make sure to update copy constructor when adding new fields\n+\n+    boolean containerStarted;\n+\n+    public CracContainerBuilder() {\n+        super();\n+        dockerOptions = List.of();\n+        dockerCheckpointOptions = List.of();\n+        containerSetupCommand = List.of();\n+    }\n+\n+    protected CracContainerBuilder(CracContainerBuilder other) {\n+        super(other);\n+        dockerImageBaseName = other.dockerImageBaseName;\n+        dockerImageBaseVersion = other.dockerImageBaseVersion;\n+        dockerImageName = other.dockerImageName;\n+        dockerOptions = other.dockerOptions; \/\/ No deep copy because immutable\n+        dockerCheckpointOptions = other.dockerCheckpointOptions; \/\/ No deep copy because immutable\n+        containerSetupCommand = other.containerSetupCommand; \/\/ No deep copy because immutable\n+        containerUsePrivileged = other.containerUsePrivileged;\n+        runContainerDirectly = other.runContainerDirectly;\n+        \/\/ containerStarted is left out intentionally\n+    }\n+\n+    @Override\n+    protected CracContainerBuilder self() {\n+        return this;\n+    }\n+\n+    @Override\n+    public CracContainerBuilder copy() {\n+        return new CracContainerBuilder(this);\n+    }\n+\n+    public CracContainerBuilder withBaseImage(String name, String tag) {\n+        assertNull(dockerImageBaseName);\n+        assertNull(dockerImageBaseVersion);\n+        dockerImageBaseName = name;\n+        dockerImageBaseVersion = tag;\n+        return this;\n+    }\n+\n+    public CracContainerBuilder inDockerImage(String imageName) {\n+        assertNull(dockerImageName);\n+        dockerImageName = imageName;\n+        return this;\n+    }\n+\n+    public CracContainerBuilder dockerOptions(String... options) {\n+        dockerOptions = List.of(options);\n+        return this;\n+    }\n+\n+    public CracContainerBuilder clearDockerOptions() {\n+        dockerOptions = List.of();\n+        return this;\n+    }\n+\n+    public CracContainerBuilder dockerCheckpointOptions(String... options) {\n+        dockerCheckpointOptions = List.of(options);\n+        return this;\n+    }\n+\n+    public CracContainerBuilder containerSetup(String... cmd) {\n+        containerSetupCommand = List.of(cmd);\n+        return this;\n+    }\n+\n+    public CracContainerBuilder containerUsePrivileged(boolean usePrivileged) {\n+        containerUsePrivileged = usePrivileged;\n+        return this;\n+    }\n+\n+    public CracContainerBuilder runContainerDirectly(boolean runDirectly) {\n+        runContainerDirectly = runDirectly;\n+        return this;\n+    }\n+\n+    public void ensureContainerStarted() throws Exception {\n+        assertNotNull(dockerImageName, \"Docker image name must be specified\");\n+        if (engine == CracEngine.CRIU && CRIU_PATH == null) {\n+            fail(\"CRAC_CRIU_PATH is not set and cannot find criu executable in any of: \" + CRIU_CANDIDATES);\n+        }\n+        if (!containerStarted) {\n+            prepareContainer();\n+            List<String> cmd = prepareContainerCommand(dockerImageName, dockerOptions);\n+            log(\"Starting docker container:\\n\" + String.join(\" \", cmd));\n+            try (final var p = new ProcessBuilder().inheritIO().command(cmd).start()) {\n+                assertEquals(0, p.waitFor());\n+            }\n+            setupContainer();\n+            containerStarted = true;\n+        }\n+    }\n+    private void prepareContainer() throws Exception {\n+        DockerTestUtils.checkCanTestDocker();\n+\n+        if (runContainerDirectly && !containerSetupCommand.isEmpty()) {\n+            fail(\"runContainerDirectly and containerSetupCommand cannot be used together.\");\n+        }\n+        ensureContainerKilled();\n+\n+        \/\/ FIXME cooperate better with DockerTestUtils\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(Path.of(\".\", dockerImageName.replace(\":\", \"-\")));\n+        } catch (NoSuchFileException ignore) {\n+        }\n+\n+        buildDockerImage();\n+    }\n+\n+    private void buildDockerImage() throws Exception {\n+        String previousBaseImageName = null;\n+        String previousBaseImageVersion = null;\n+        try {\n+            previousBaseImageName = System.getProperty(DockerfileConfig.BASE_IMAGE_NAME);\n+            previousBaseImageVersion = System.getProperty(DockerfileConfig.BASE_IMAGE_VERSION);\n+            if (dockerImageBaseName != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_NAME, dockerImageBaseName);\n+            }\n+            if (dockerImageBaseVersion != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_VERSION, dockerImageBaseVersion);\n+            }\n+            if (REUSE_IMAGE_IF_EXIST) {\n+                if (0 == DockerTestUtils.execute(Container.ENGINE_COMMAND, \"inspect\", \"--type=image\", dockerImageName).getExitValue()) {\n+                    return;\n+                }\n+            }\n+            DockerTestUtils.buildJdkContainerImage(dockerImageName);\n+        } finally {\n+            if (previousBaseImageName != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_NAME, previousBaseImageName);\n+            } else {\n+                System.clearProperty(DockerfileConfig.BASE_IMAGE_NAME);\n+            }\n+            if (previousBaseImageVersion != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_VERSION, previousBaseImageVersion);\n+            } else {\n+                System.clearProperty(DockerfileConfig.BASE_IMAGE_VERSION);\n+            }\n+        }\n+    }\n+\n+    private List<String> prepareContainerCommand(String imageName, List<String> options) {\n+        List<String> cmd = prepareContainerCommandBase(imageName, options);\n+        cmd.addAll(Arrays.asList(\"sleep\", \"3600\"));\n+        return cmd;\n+    }\n+\n+    private List<String> prepareContainerCommandBase(String imageName, List<String> options) {\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(Container.ENGINE_COMMAND);\n+        cmd.addAll(Arrays.asList(\"run\", \"--rm\"));\n+        if (!runContainerDirectly) {\n+            cmd.add(\"-d\");\n+            cmd.add(\"--init\"); \/\/ otherwise the checkpointed process would not be reaped (by sleep with PID 1)\n+        }\n+        if (containerUsePrivileged) {\n+            cmd.add(\"--privileged\"); \/\/ required to give CRIU sufficient permissions\n+        }\n+        int entryCounter = 0;\n+        for (var entry : Utils.TEST_CLASS_PATH.split(File.pathSeparator)) {\n+            cmd.addAll(Arrays.asList(\"--volume\", entry + \":\/cp\/\" + (entryCounter++)));\n+        }\n+        new File(System.getProperty(\"user.dir\") + \"\/cr\").mkdirs(); \/\/ create \"cr\" dir under the current user, to be able to delete it later.\n+        cmd.addAll(Arrays.asList(\"--volume\", System.getProperty(\"user.dir\") + \"\/cr:\/cr\"));\n+        if (engine == CracEngine.CRIU) {\n+            cmd.addAll(Arrays.asList(\"--volume\", CRIU_PATH + \":\/criu\"));\n+            cmd.addAll(Arrays.asList(\"--env\", \"CRAC_CRIU_PATH=\/criu\"));\n+        }\n+        cmd.addAll(Arrays.asList(\"--name\", CONTAINER_NAME));\n+        if (debug) {\n+            cmd.addAll(Arrays.asList(\"--publish\", \"5005:5005\"));\n+        }\n+        cmd.addAll(options);\n+        cmd.add(imageName);\n+        return cmd;\n+    }\n+\n+    private void setupContainer() throws Exception {\n+        if (!containerSetupCommand.isEmpty()) {\n+            List<String> cmd = new ArrayList<>();\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+            cmd.addAll(containerSetupCommand);\n+            log(\"Container set up:\\n\" + String.join(\" \", cmd));\n+            DockerTestUtils.execute(cmd).shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    public void ensureContainerKilled() throws Exception {\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"kill\", CONTAINER_NAME).getExitValue();\n+        if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+            DockerTestUtils.removeDockerImage(dockerImageName);\n+        }\n+    }\n+\n+    public void recreateContainer(String imageName, String... options) throws Exception {\n+        assertTrue(containerStarted);\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"kill\", CONTAINER_NAME).getExitValue();\n+\n+        \/\/ Docker needs some time to remove a container after kill\n+        OutputAnalyzer oa;\n+        do {\n+            oa = DockerTestUtils.execute(Container.ENGINE_COMMAND, \"ps\");\n+            oa.getExitValue();\n+        } while (oa.getStdout().contains(CONTAINER_NAME));\n+\n+        List<String> cmd = prepareContainerCommand(imageName, List.of(options));\n+        log(\"Recreating docker container:\\n\" + String.join(\" \", cmd));\n+        try (final var p = new ProcessBuilder().inheritIO().command(cmd).start()) {\n+            assertEquals(0, p.waitFor());\n+        }\n+    }\n+\n+    @Override\n+    public CracProcess startCheckpoint(List<String> javaPrefix) throws Exception {\n+        if (runContainerDirectly) {\n+            prepareContainer();\n+        } else {\n+            ensureContainerStarted();\n+        }\n+        return super.startCheckpoint(javaPrefix);\n+    }\n+\n+    @Override\n+    public CracProcess startRestoreWithArgs(List<String> javaPrefix, List<String> args) throws Exception {\n+        if (!runContainerDirectly) {\n+            ensureContainerStarted();\n+        }\n+        return super.startRestoreWithArgs(javaPrefix, args);\n+    }\n+\n+    @Override\n+    protected List<String> getPlainCommandPrefix() {\n+        return Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME);\n+    }\n+\n+    @Override\n+    protected String getTestClassPath() {\n+        StringBuilder builder = new StringBuilder();\n+        final int numEntries = Utils.TEST_CLASS_PATH.split(File.pathSeparator).length;\n+        for (int i = 0; i < numEntries; ++i) {\n+            builder.append(\"\/cp\/\").append(i).append(File.pathSeparator);\n+        }\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    protected List<String> getDefaultJavaPrefix() {\n+        List<String> cmd;\n+        if (runContainerDirectly) {\n+            cmd = prepareContainerCommandBase(dockerImageName, dockerOptions);\n+        } else {\n+            cmd = new ArrayList<>();\n+            cmd.add(Container.ENGINE_COMMAND);\n+            cmd.add(\"exec\");\n+            cmd.addAll(dockerCheckpointOptions);\n+            cmd.add(CONTAINER_NAME);\n+        }\n+        cmd.add(DOCKER_JAVA);\n+        return cmd;\n+    }\n+\n+    public void checkpointViaJcmd() throws Exception {\n+        runJcmd(main().getName(), \"JDK.checkpoint\").shouldHaveExitValue(0)\n+                .outputTo(System.out).errorTo(System.err);\n+    }\n+\n+    @Override\n+    public OutputAnalyzer runJcmd(String id, String... command) throws Exception {\n+        final List<String> cmd = new ArrayList<>();\n+        cmd.addAll(List.of(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME, \"\/jdk\/bin\/jcmd\"));\n+        cmd.add(id);\n+        cmd.addAll(Arrays.asList(command));\n+        return DockerTestUtils.execute(cmd);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracContainerBuilder.java","additions":362,"deletions":0,"binary":false,"changes":362,"status":"added"},{"patch":"@@ -0,0 +1,266 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.StreamPumper;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.nio.file.*;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+public class CracProcess {\n+    private final CracBuilderBase<?> builder;\n+    private final Process process;\n+\n+    public CracProcess(CracBuilderBase<?> builder, List<String> cmd) throws IOException {\n+        this.builder = builder;\n+        ProcessBuilder pb = new ProcessBuilder().inheritIO().redirectInput(ProcessBuilder.Redirect.PIPE);\n+        if (builder.captureOutput) {\n+            pb.redirectOutput(ProcessBuilder.Redirect.PIPE);\n+            pb.redirectError(ProcessBuilder.Redirect.PIPE);\n+        }\n+        pb.environment().putAll(builder.env);\n+        this.process = pb.command(cmd).start();\n+    }\n+\n+    public int waitFor() throws InterruptedException {\n+        return process.waitFor();\n+    }\n+\n+    public void waitForCheckpointed() throws InterruptedException {\n+        if (builder.engine == null || builder.engine == CracEngine.CRIU) {\n+            final var exitValue = process.waitFor();\n+            if (exitValue != 137 && builder.captureOutput) {\n+                printOutput();\n+            }\n+            assertEquals(137, exitValue, \"Checkpointed process was not killed as expected.\");\n+            builder.log(\"Process %d completed with exit value %d%n\", process.pid(), exitValue);\n+        } else {\n+            fail(\"With engine \" + builder.engine.engine + \" use the async version.\");\n+        }\n+    }\n+\n+    public void waitForPausePid() throws IOException, InterruptedException {\n+        assertEquals(CracEngine.PAUSE, builder.engine, \"Pause PID file created only with pauseengine\");\n+\n+        \/\/ (at least on Windows) we need to wait to avoid os::prepare_checkpoint() interference with mkdir\/rmdir calls\n+        Thread.sleep(500);\n+\n+        try (WatchService watcher = FileSystems.getDefault().newWatchService()) {\n+            Path imageDir = builder.imageDir().toAbsolutePath();\n+            waitForFileCreated(watcher, imageDir.getParent(), path -> \"cr\".equals(path.toFile().getName()));\n+            waitForFileCreated(watcher, imageDir, path -> \"pid\".equals(path.toFile().getName()));\n+        }\n+    }\n+\n+    private void waitForFileCreated(WatchService watcher, Path dir, Predicate<Path> predicate) throws IOException, InterruptedException {\n+        WatchKey key = dir.register(watcher, StandardWatchEventKinds.ENTRY_CREATE);\n+        assertTrue(key.isValid());\n+        try {\n+            try (Stream<Path> dirContents = Files.list(dir)) {\n+                if (dirContents.anyMatch(predicate)) {\n+                    \/\/ file already present\n+                    return;\n+                }\n+            }\n+            int timeoutCounter = 10;\n+            for (; ; ) {\n+                WatchKey key2 = watcher.poll(1, TimeUnit.SECONDS);\n+                if (null == key2) {\n+                    if (!process.isAlive() && 0 < --timeoutCounter) {\n+                        \/\/ At least on macOS, it seems like WatchService's event may be delayed up to 10 secs,\n+                        \/\/ so we need to keep waiting some time for the event, even the process is completed.\n+                        continue;\n+                    }\n+                    assertTrue(process.isAlive(), \"Process should exist\");\n+                    continue;\n+                }\n+                for (WatchEvent<?> event : key2.pollEvents()) {\n+                    if (event.kind() != StandardWatchEventKinds.ENTRY_CREATE) {\n+                        continue;\n+                    }\n+                    if (predicate.test((Path) event.context())) {\n+                        return;\n+                    }\n+                }\n+                key2.reset();\n+            }\n+        } finally {\n+            key.cancel();\n+        }\n+    }\n+\n+    public CracProcess waitForSuccess() throws InterruptedException {\n+        int exitValue = process.waitFor();\n+        if (exitValue != 0 && builder.captureOutput) {\n+            printOutput();\n+        }\n+        assertEquals(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+        builder.log(\"Process %d completed with exit value %d%n\", process.pid(), exitValue);\n+        return this;\n+    }\n+\n+    private void printOutput() {\n+        final OutputAnalyzer oa;\n+        try {\n+            oa = outputAnalyzer();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        \/\/ Similar to OutputAnalyzer.reportDiagnosticSummary() but a bit better formatted\n+        System.err.println(\"stdout: [\");\n+        System.err.print(oa.getStdout());\n+        System.err.println(\"]\\nstderr: [\");\n+        System.err.print(oa.getStderr());\n+        System.err.println(\"]\\nexitValue = \" + oa.getExitValue() + \"\\n\");\n+    }\n+\n+    public OutputAnalyzer outputAnalyzer() throws IOException {\n+        assertTrue(builder.captureOutput, \"Output must be captured with .captureOutput(true)\");\n+        return new OutputAnalyzer(process);\n+    }\n+\n+    public CracProcess watch(Consumer<String> outputConsumer, Consumer<String> errorConsumer) {\n+        assertTrue(builder.captureOutput, \"Output must be captured with .captureOutput(true)\");\n+        pump(process.getInputStream(), outputConsumer);\n+        pump(process.getErrorStream(), errorConsumer);\n+        return this;\n+    }\n+\n+    public void waitForStdout(String str) throws InterruptedException {\n+        waitForStdout(str, true);\n+    }\n+\n+    public void waitForStdout(String str, boolean failOnUnexpected) throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        AtomicReference<String> unexpected = new AtomicReference<>();\n+        watch(line -> {\n+            if (line.equals(str)) {\n+                latch.countDown();\n+            } else if (failOnUnexpected) {\n+                unexpected.set(line);\n+                latch.countDown();\n+            }\n+        }, System.err::println);\n+        assertTrue(latch.await(10, TimeUnit.SECONDS));\n+        String unexpectedLine = unexpected.get();\n+        if (unexpectedLine != null) {\n+            throw new IllegalArgumentException(unexpectedLine);\n+        }\n+    }\n+\n+    private static void pump(InputStream stream, Consumer<String> consumer) {\n+        new StreamPumper(stream).addPump(new StreamPumper.LinePump() {\n+            @Override\n+            protected void processLine(String line) {\n+                consumer.accept(line);\n+            }\n+        }).process();\n+    }\n+\n+    public long pid() {\n+        return process.pid();\n+    }\n+\n+    public OutputStream input() {\n+        return process.getOutputStream();\n+    }\n+\n+    public InputStream output() {\n+        return process.getInputStream();\n+    }\n+\n+    public InputStream errOutput() {\n+        return process.getErrorStream();\n+    }\n+\n+    public void sendNewline() throws IOException {\n+        OutputStream input = process.getOutputStream();\n+        input.write('\\n');\n+        input.flush();\n+    }\n+\n+    public void destroyForcibly() {\n+        process.destroyForcibly();\n+    }\n+\n+    public void printThreadDump() throws IOException {\n+        final long pid = this.pid();\n+        boolean isAlive = ProcessHandle.of(pid).map(ProcessHandle::isAlive).orElse(false);\n+        if (!isAlive) {\n+            System.err.println(\"Process \" + pid + \" is not alive.\");\n+        } else {\n+            System.err.println(\"Running: jcmd \" + pid + \" Thread.print\");\n+            Process jcmdProc = new ProcessBuilder(jdk.test.lib.Utils.TEST_JDK + \"\/bin\/jcmd\", String.valueOf(pid), \"Thread.print\")\n+                    .redirectErrorStream(true)\n+                    .start();\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(jcmdProc.getInputStream()))) {\n+                for (String line = reader.readLine(); null != line; line = reader.readLine()) {\n+                    System.err.println(\"JCMD: \" + line);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean checkGcoreAvailable() {\n+        ProcessBuilder builder = new ProcessBuilder(\"which\", \"gcore\");\n+        builder.redirectErrorStream(true);\n+        try {\n+            Process process = builder.start();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n+            String line = reader.readLine();\n+            int exitCode = process.waitFor();\n+            if (exitCode == 0 && line != null && !line.trim().isEmpty()) {\n+                System.out.println(\"gcore is available.\");\n+                return true;\n+            } else {\n+                System.out.println(\"gcore is NOT available.\");\n+                return false;\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            System.out.println(\"Could not run 'which gcore' or was interrupted\");\n+            return false;\n+        }\n+    }\n+\n+    public void dumpProcess() {\n+        \/\/ For gcore, it's required 'sudo sysctl -w kernel.yama.ptrace_scope=0'\n+        \/\/ For kill, it's required 'ulimit -c unlimited && echo core.%p | sudo tee \/proc\/sys\/kernel\/core_pattern'\n+        final long pid = this.pid();\n+        ProcessBuilder builder = checkGcoreAvailable() ? new ProcessBuilder(\"gcore\", String.valueOf(pid))\n+                : new ProcessBuilder(\"kill\", \"-ABRT\", String.valueOf(pid));\n+        builder.redirectErrorStream(true);\n+        try {\n+            Process process = builder.start();\n+            var reader = new AsyncStreamReader(process.getInputStream());\n+            int exitCode = process.waitFor();\n+            try {\n+                while (true) {\n+                    System.out.println(\"dumpProcess: \" + reader.readLine(100));\n+                }\n+            } catch (Exception e) {\n+                \/\/ do nothing\n+            }\n+            if (exitCode == 0) {\n+                System.out.println(\"Core dump seems to be created successfully for pid=\" + pid);\n+            } else {\n+                System.out.println(\"Something went wrong while dumping the app\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            System.out.println(\"Exception thrown while dumping the app\");\n+            e.printStackTrace();\n+        }\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":266,"deletions":0,"binary":false,"changes":266,"status":"added"}]}