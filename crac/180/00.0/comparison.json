{"files":[{"patch":"@@ -40,0 +40,3 @@\n+      xcode-toolset-version:\n+        required: false\n+        type: string\n@@ -154,1 +157,1 @@\n-          sudo xcode-select --switch \/Applications\/Xcode_14.3.1.app\/Contents\/Developer\n+          sudo xcode-select --switch \/Applications\/Xcode_${{ inputs.xcode-toolset-version }}.app\/Contents\/Developer\n","filename":".github\/workflows\/test.yml","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -370,2 +370,1 @@\n-BUILD_MANPAGES := @BUILD_MANPAGES@\n-\n+BUILD_CDS_ARCHIVE_COH := @BUILD_CDS_ARCHIVE_COH@\n@@ -710,0 +709,1 @@\n+JLINK_PRODUCE_LINKABLE_RUNTIME := @JLINK_PRODUCE_LINKABLE_RUNTIME@\n","filename":"make\/autoconf\/spec.gmk.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -535,1 +535,0 @@\n-#ifdef _LP64\n@@ -540,1 +539,0 @@\n-#endif \/\/ _LP64\n@@ -564,1 +562,0 @@\n-#ifdef _LP64\n@@ -569,1 +566,0 @@\n-#endif \/\/ _LP64\n@@ -629,1 +625,0 @@\n-#ifdef _LP64\n@@ -634,1 +629,0 @@\n-#endif \/\/ _LP64\n@@ -659,1 +653,0 @@\n-#ifdef _LP64\n@@ -664,1 +657,0 @@\n-#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -716,1 +716,1 @@\n-  static void set_bmi_cpuFeatures() { _features |= (CPU_BMI1 | CPU_BMI2 | CPU_LZCNT); }\n+  static void set_bmi_cpuFeatures() { _features |= (CPU_BMI1 | CPU_BMI2 | CPU_LZCNT | CPU_POPCNT); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,7 +40,0 @@\n-#define JNI_ONLOAD_SYMBOLS   {\"JNI_OnLoad\"}\n-#define JNI_ONUNLOAD_SYMBOLS {\"JNI_OnUnload\"}\n-#define JVM_ONLOAD_SYMBOLS      {\"JVM_OnLoad\"}\n-#define AGENT_ONLOAD_SYMBOLS    {\"Agent_OnLoad\"}\n-#define AGENT_ONUNLOAD_SYMBOLS  {\"Agent_OnUnload\"}\n-#define AGENT_ONATTACH_SYMBOLS  {\"Agent_OnAttach\"}\n-\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -700,8 +700,0 @@\n-void os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n-  \/\/ no prefix required\n-}\n-\n-void os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n-  \/\/ no suffix required\n-}\n-\n@@ -820,1 +812,1 @@\n-    \/\/ It is possible that we found a NULL symbol, hence no error.\n+    \/\/ It is possible that we found a null symbol, hence no error.\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1095,1 +1095,1 @@\n-    NmtVirtualMemoryLocker ml;\n+    ThreadCritical tc;\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-  #define __CPU__ i486\n+  #error \"Unknown CPU\"\n@@ -286,5 +286,0 @@\n-#ifndef _WIN64\n-\/\/ previous UnhandledExceptionFilter, if there is one\n-static LPTOP_LEVEL_EXCEPTION_FILTER prev_uef_handler = nullptr;\n-#endif\n-\n@@ -403,5 +398,0 @@\n-#ifndef _WIN64\n-  \/\/ set our UnhandledExceptionFilter and save any previous one\n-  prev_uef_handler = SetUnhandledExceptionFilter(Uncaught_Exception_Handler);\n-#endif\n-\n@@ -521,1 +511,1 @@\n-static unsigned __stdcall thread_native_entry(void* t) {\n+static unsigned thread_native_entry(void* t) {\n@@ -880,1 +870,0 @@\n-#ifdef _LP64\n@@ -883,5 +872,0 @@\n-#else\n-  \/\/ Limit to 1400m because of the 2gb address space wall\n-  *limit = MIN2((size_t)1400*M, (size_t)ms.ullAvailVirtual);\n-  return true;\n-#endif\n@@ -1580,1 +1564,1 @@\n-#ifdef _WIN64\n+\n@@ -1602,1 +1586,0 @@\n-#endif\n@@ -1780,1 +1763,0 @@\n-    {IMAGE_FILE_MACHINE_I386,      (char*)\"IA 32\"},\n@@ -1788,2 +1770,0 @@\n-#elif (defined _M_IX86)\n-  static const uint16_t running_arch = IMAGE_FILE_MACHINE_I386;\n@@ -1792,1 +1772,1 @@\n-         is defined :_M_AMD64 or _M_IX86 or _M_ARM64\n+         is defined :_M_AMD64 or _M_ARM64\n@@ -2132,7 +2112,0 @@\n-\n-    \/\/ on 32bit Total\/AvailVirtual are interesting (show us how close we get to 2-4 GB per process borders)\n-#if defined(_M_IX86)\n-    st->print(\", user-mode portion of virtual address-space \" INT64_FORMAT \"M \",\n-             (int64_t) ms.ullTotalVirtual >> 20);\n-    st->print(\"(\" INT64_FORMAT \"M free)\", (int64_t) ms.ullAvailVirtual >> 20);\n-#endif\n@@ -2259,13 +2232,0 @@\n-void os::print_jni_name_prefix_on(outputStream* st, int args_size) {\n-#ifndef _WIN64\n-  st->print(\"_\");\n-#endif\n-}\n-\n-\n-void os::print_jni_name_suffix_on(outputStream* st, int args_size) {\n-#ifndef _WIN64\n-  st->print(\"@%d\", args_size  * sizeof(int));\n-#endif\n-}\n-\n@@ -2496,2 +2456,0 @@\n-#elif defined(_M_IX86)\n-  #define PC_NAME Eip\n@@ -2621,10 +2579,1 @@\n-  PCONTEXT ctx = exceptionInfo->ContextRecord;\n-  address pc = (address)ctx->Eip;\n-  guarantee(pc[0] == 0xF7, \"not an idiv opcode(0xF7), the actual value = 0x%x\", pc[1]);\n-  guarantee((pc[1] & ~0x7) == 0xF8, \"cannot handle non-register operands, the actual value = 0x%x\", pc[1]);\n-  guarantee(ctx->Eax == min_jint, \"unexpected idiv exception, the actual value = %d while the expected is %d\", ctx->Eax, min_jint);\n-  \/\/ set correct result values and continue after idiv instruction\n-  ctx->Eip = (DWORD)pc + 2;        \/\/ idiv reg, reg  is 2 bytes\n-  ctx->Eax = (DWORD)min_jint;      \/\/ result\n-  ctx->Edx = (DWORD)0;             \/\/ remainder\n-  \/\/ Continue the execution\n+  #error unknown architecture\n@@ -2635,1 +2584,1 @@\n-#if defined(_M_AMD64) || defined(_M_IX86)\n+#if defined(_M_AMD64)\n@@ -2650,10 +2599,0 @@\n-#ifndef  _WIN64\n-    jint fp_control_word = (* (jint*) StubRoutines::x86::addr_fpu_cntrl_wrd_std());\n-    if (fp_control_word != ctx->FloatSave.ControlWord) {\n-      \/\/ Restore FPCW and mask out FLT exceptions\n-      ctx->FloatSave.ControlWord = fp_control_word | 0xffffffc0;\n-      \/\/ Mask out pending FLT exceptions\n-      ctx->FloatSave.StatusWord &=  0xffffff00;\n-      return true;\n-    }\n-#else \/\/ !_WIN64\n@@ -2670,1 +2609,0 @@\n-#endif \/\/ !_WIN64\n@@ -2678,17 +2616,0 @@\n-#ifndef _WIN64\n-static LONG WINAPI Uncaught_Exception_Handler(struct _EXCEPTION_POINTERS* exceptionInfo) {\n-  if (handle_FLT_exception(exceptionInfo)) {\n-    return EXCEPTION_CONTINUE_EXECUTION;\n-  }\n-\n-  \/\/ we only override this on 32 bits, so only check it there\n-  if (prev_uef_handler != nullptr) {\n-    \/\/ We didn't handle this exception so pass it to the previous\n-    \/\/ UnhandledExceptionFilter.\n-    return (prev_uef_handler)(exceptionInfo);\n-  }\n-\n-  return EXCEPTION_CONTINUE_SEARCH;\n-}\n-#endif\n-\n@@ -2714,1 +2635,1 @@\n-  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+  #error unknown architecture\n@@ -2718,81 +2639,1 @@\n-#ifndef _WIN64\n-  \/\/ Execution protection violation - win32 running on AMD64 only\n-  \/\/ Handled first to avoid misdiagnosis as a \"normal\" access violation;\n-  \/\/ This is safe to do because we have a new\/unique ExceptionInformation\n-  \/\/ code for this condition.\n-  if (exception_code == EXCEPTION_ACCESS_VIOLATION) {\n-    int exception_subcode = (int) exception_record->ExceptionInformation[0];\n-    address addr = (address) exception_record->ExceptionInformation[1];\n-\n-    if (exception_subcode == EXCEPTION_INFO_EXEC_VIOLATION) {\n-      size_t page_size = os::vm_page_size();\n-\n-      \/\/ Make sure the pc and the faulting address are sane.\n-      \/\/\n-      \/\/ If an instruction spans a page boundary, and the page containing\n-      \/\/ the beginning of the instruction is executable but the following\n-      \/\/ page is not, the pc and the faulting address might be slightly\n-      \/\/ different - we still want to unguard the 2nd page in this case.\n-      \/\/\n-      \/\/ 15 bytes seems to be a (very) safe value for max instruction size.\n-      bool pc_is_near_addr =\n-        (pointer_delta((void*) addr, (void*) pc, sizeof(char)) < 15);\n-      bool instr_spans_page_boundary =\n-        (align_down((intptr_t) pc ^ (intptr_t) addr,\n-                         (intptr_t) page_size) > 0);\n-\n-      if (pc == addr || (pc_is_near_addr && instr_spans_page_boundary)) {\n-        static volatile address last_addr =\n-          (address) os::non_memory_address_word();\n-\n-        \/\/ In conservative mode, don't unguard unless the address is in the VM\n-        if (UnguardOnExecutionViolation > 0 && addr != last_addr &&\n-            (UnguardOnExecutionViolation > 1 || os::address_is_in_vm(addr))) {\n-\n-          \/\/ Set memory to RWX and retry\n-          address page_start = align_down(addr, page_size);\n-          bool res = os::protect_memory((char*) page_start, page_size,\n-                                        os::MEM_PROT_RWX);\n-\n-          log_debug(os)(\"Execution protection violation \"\n-                        \"at \" INTPTR_FORMAT\n-                        \", unguarding \" INTPTR_FORMAT \": %s\", p2i(addr),\n-                        p2i(page_start), (res ? \"success\" : os::strerror(errno)));\n-\n-          \/\/ Set last_addr so if we fault again at the same address, we don't\n-          \/\/ end up in an endless loop.\n-          \/\/\n-          \/\/ There are two potential complications here.  Two threads trapping\n-          \/\/ at the same address at the same time could cause one of the\n-          \/\/ threads to think it already unguarded, and abort the VM.  Likely\n-          \/\/ very rare.\n-          \/\/\n-          \/\/ The other race involves two threads alternately trapping at\n-          \/\/ different addresses and failing to unguard the page, resulting in\n-          \/\/ an endless loop.  This condition is probably even more unlikely\n-          \/\/ than the first.\n-          \/\/\n-          \/\/ Although both cases could be avoided by using locks or thread\n-          \/\/ local last_addr, these solutions are unnecessary complication:\n-          \/\/ this handler is a best-effort safety net, not a complete solution.\n-          \/\/ It is disabled by default and should only be used as a workaround\n-          \/\/ in case we missed any no-execute-unsafe VM code.\n-\n-          last_addr = addr;\n-\n-          return EXCEPTION_CONTINUE_EXECUTION;\n-        }\n-      }\n-\n-      \/\/ Last unguard failed or not unguarding\n-      tty->print_raw_cr(\"Execution protection violation\");\n-#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n-      report_error(t, exception_code, addr, exception_record,\n-                   exceptionInfo->ContextRecord);\n-#endif\n-      return EXCEPTION_CONTINUE_SEARCH;\n-    }\n-  }\n-#endif \/\/ _WIN64\n-\n-#if defined(_M_AMD64) || defined(_M_IX86)\n+#if defined(_M_AMD64)\n@@ -2805,1 +2646,1 @@\n-#if !defined(PRODUCT) && defined(_LP64)\n+#if !defined(PRODUCT)\n@@ -2873,1 +2714,0 @@\n-#ifdef _WIN64\n@@ -2882,1 +2722,0 @@\n-#endif\n@@ -2893,1 +2732,0 @@\n-#ifdef _WIN64\n@@ -2901,1 +2739,0 @@\n-#endif\n@@ -2954,1 +2791,1 @@\n-#if defined(_M_AMD64) || defined(_M_IX86)\n+#if defined(_M_AMD64)\n@@ -2998,1 +2835,1 @@\n-  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+  #error unknown architecture\n@@ -3040,57 +2877,0 @@\n-#ifndef _WIN64\n-\/\/ Special care for fast JNI accessors.\n-\/\/ jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in and\n-\/\/ the heap gets shrunk before the field access.\n-\/\/ Need to install our own structured exception handler since native code may\n-\/\/ install its own.\n-LONG WINAPI fastJNIAccessorExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {\n-  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n-  if (exception_code == EXCEPTION_ACCESS_VIOLATION) {\n-    address pc = (address) exceptionInfo->ContextRecord->Eip;\n-    address addr = JNI_FastGetField::find_slowcase_pc(pc);\n-    if (addr != (address)-1) {\n-      return Handle_Exception(exceptionInfo, addr);\n-    }\n-  }\n-  return EXCEPTION_CONTINUE_SEARCH;\n-}\n-\n-#define DEFINE_FAST_GETFIELD(Return, Fieldname, Result)                     \\\n-  Return JNICALL jni_fast_Get##Result##Field_wrapper(JNIEnv *env,           \\\n-                                                     jobject obj,           \\\n-                                                     jfieldID fieldID) {    \\\n-    __try {                                                                 \\\n-      return (*JNI_FastGetField::jni_fast_Get##Result##Field_fp)(env,       \\\n-                                                                 obj,       \\\n-                                                                 fieldID);  \\\n-    } __except(fastJNIAccessorExceptionFilter((_EXCEPTION_POINTERS*)        \\\n-                                              _exception_info())) {         \\\n-    }                                                                       \\\n-    return 0;                                                               \\\n-  }\n-\n-DEFINE_FAST_GETFIELD(jboolean, bool,   Boolean)\n-DEFINE_FAST_GETFIELD(jbyte,    byte,   Byte)\n-DEFINE_FAST_GETFIELD(jchar,    char,   Char)\n-DEFINE_FAST_GETFIELD(jshort,   short,  Short)\n-DEFINE_FAST_GETFIELD(jint,     int,    Int)\n-DEFINE_FAST_GETFIELD(jlong,    long,   Long)\n-DEFINE_FAST_GETFIELD(jfloat,   float,  Float)\n-DEFINE_FAST_GETFIELD(jdouble,  double, Double)\n-\n-address os::win32::fast_jni_accessor_wrapper(BasicType type) {\n-  switch (type) {\n-  case T_BOOLEAN: return (address)jni_fast_GetBooleanField_wrapper;\n-  case T_BYTE:    return (address)jni_fast_GetByteField_wrapper;\n-  case T_CHAR:    return (address)jni_fast_GetCharField_wrapper;\n-  case T_SHORT:   return (address)jni_fast_GetShortField_wrapper;\n-  case T_INT:     return (address)jni_fast_GetIntField_wrapper;\n-  case T_LONG:    return (address)jni_fast_GetLongField_wrapper;\n-  case T_FLOAT:   return (address)jni_fast_GetFloatField_wrapper;\n-  case T_DOUBLE:  return (address)jni_fast_GetDoubleField_wrapper;\n-  default:        ShouldNotReachHere();\n-  }\n-  return (address)-1;\n-}\n-#endif\n-\n@@ -3372,6 +3152,1 @@\n-#if defined(IA32)\n-  if (size > 4 * M || LargePageSizeInBytes > 4 * M) {\n-    WARN(\"JVM cannot use large pages bigger than 4mb.\");\n-    return 0;\n-  }\n-#elif defined(AMD64)\n+#if defined(AMD64)\n@@ -3461,1 +3236,0 @@\n-#ifdef _LP64\n@@ -3464,4 +3238,0 @@\n-#else\n-  HANDLE fileMapping = CreateFileMapping(fh, nullptr, PAGE_READWRITE,\n-    0, (DWORD)size, nullptr);\n-#endif\n@@ -3856,2 +3626,1 @@\n-      fileStream fs(stdout);\n-      os::print_memory_mappings((char*)start, bytes, &fs);\n+      os::print_memory_mappings((char*)start, bytes, tty);\n@@ -4182,1 +3951,1 @@\n-  if (RegQueryValueExA(hKey, valueName, NULL, NULL, (LPBYTE)buffer, &valueLength) != ERROR_SUCCESS) {\n+  if (RegQueryValueExA(hKey, valueName, nullptr, nullptr, (LPBYTE)buffer, &valueLength) != ERROR_SUCCESS) {\n@@ -4650,26 +4419,0 @@\n-#ifndef PRODUCT\n-#ifndef _WIN64\n-\/\/ Helpers to check whether NX protection is enabled\n-int nx_exception_filter(_EXCEPTION_POINTERS *pex) {\n-  if (pex->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION &&\n-      pex->ExceptionRecord->NumberParameters > 0 &&\n-      pex->ExceptionRecord->ExceptionInformation[0] ==\n-      EXCEPTION_INFO_EXEC_VIOLATION) {\n-    return EXCEPTION_EXECUTE_HANDLER;\n-  }\n-  return EXCEPTION_CONTINUE_SEARCH;\n-}\n-\n-void nx_check_protection() {\n-  \/\/ If NX is enabled we'll get an exception calling into code on the stack\n-  char code[] = { (char)0xC3 }; \/\/ ret\n-  void *code_ptr = (void *)code;\n-  __try {\n-    __asm call code_ptr\n-  } __except(nx_exception_filter((_EXCEPTION_POINTERS*)_exception_info())) {\n-    tty->print_raw_cr(\"NX protection detected.\");\n-  }\n-}\n-#endif \/\/ _WIN64\n-#endif \/\/ PRODUCT\n-\n@@ -4695,3 +4438,0 @@\n-\n-  \/\/ initialize fast thread access - only used for 32-bit\n-  win32::initialize_thread_ptr_offset();\n@@ -4713,4 +4453,0 @@\n-#ifdef _LP64\n-#else\n-size_t os::_vm_internal_thread_min_stack_allowed = (48 DEBUG_ONLY(+ 4)) * K;\n-#endif \/\/ _LP64\n@@ -4745,10 +4481,0 @@\n-  \/\/ for debugging float code generation bugs\n-#if defined(ASSERT) && !defined(_WIN64)\n-  static long fp_control_word = 0;\n-  __asm { fstcw fp_control_word }\n-  \/\/ see Intel PPro Manual, Vol. 2, p 7-16\n-  const long invalid   = 0x01;\n-  fp_control_word |= invalid;\n-  __asm { fldcw fp_control_word }\n-#endif\n-\n@@ -4778,5 +4504,0 @@\n-#ifndef _WIN64\n-  \/\/ Print something if NX is enabled (win32 on AMD64)\n-  NOT_PRODUCT(if (PrintMiscellaneous && Verbose) nx_check_protection());\n-#endif\n-\n@@ -6072,7 +5793,0 @@\n-\/\/ WINDOWS CONTEXT Flags for THREAD_SAMPLING\n-#if defined(IA32)\n-  #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT | CONTEXT_EXTENDED_REGISTERS)\n-#elif defined(AMD64) || defined(_M_ARM64)\n-  #define sampling_context_flags (CONTEXT_FULL | CONTEXT_FLOATING_POINT)\n-#endif\n-\n@@ -6123,1 +5837,1 @@\n-    ctxt.ContextFlags = sampling_context_flags;\n+    ctxt.ContextFlags = (CONTEXT_FULL | CONTEXT_FLOATING_POINT);\n@@ -6169,1 +5883,0 @@\n-\/\/ Additionally for windows, takes into account __stdcall names.\n@@ -6210,0 +5923,2 @@\n+\n+  strcpy(agent_entry_name, sym_name);\n@@ -6211,17 +5926,2 @@\n-    const char *p = strrchr(sym_name, '@');\n-    if (p != nullptr && p != sym_name) {\n-      \/\/ sym_name == _Agent_OnLoad@XX\n-      strncpy(agent_entry_name, sym_name, (p - sym_name));\n-      agent_entry_name[(p-sym_name)] = '\\0';\n-      \/\/ agent_entry_name == _Agent_OnLoad\n-      strcat(agent_entry_name, \"_\");\n-      strncat(agent_entry_name, lib_name, name_len);\n-      strcat(agent_entry_name, p);\n-      \/\/ agent_entry_name == _Agent_OnLoad_lib_name@XX\n-    } else {\n-      strcpy(agent_entry_name, sym_name);\n-      strcat(agent_entry_name, \"_\");\n-      strncat(agent_entry_name, lib_name, name_len);\n-    }\n-  } else {\n-    strcpy(agent_entry_name, sym_name);\n+    strcat(agent_entry_name, \"_\");\n+    strncat(agent_entry_name, lib_name, name_len);\n@@ -6266,13 +5966,0 @@\n-\/\/ Fast current thread access\n-\n-int os::win32::_thread_ptr_offset = 0;\n-\n-static void call_wrapper_dummy() {}\n-\n-\/\/ We need to call the os_exception_wrapper once so that it sets\n-\/\/ up the offset from FS of the thread pointer.\n-void os::win32::initialize_thread_ptr_offset() {\n-  os::os_exception_wrapper((java_call_t)call_wrapper_dummy,\n-                           nullptr, methodHandle(), nullptr, nullptr);\n-}\n-\n@@ -6353,1 +6040,1 @@\n-  static const int num_words = LP64_ONLY(3) NOT_LP64(6);\n+  static const int num_words = 3;\n@@ -6396,2 +6083,1 @@\n-      st->print_raw(NOT_LP64 (\"                 \")\n-                    LP64_ONLY(\"                         \"));\n+      st->print_raw(\"                         \");\n@@ -6497,1 +6183,1 @@\n-      static const address end_virt = (address)(LP64_ONLY(0x7ffffffffffULL) NOT_LP64(3*G));\n+      static const address end_virt = (address)(0x7ffffffffffULL);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":22,"deletions":336,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,15 +149,0 @@\n-#ifndef _WIN64\n-  \/\/ A wrapper to install a structured exception handler for fast JNI accessors.\n-  static address fast_jni_accessor_wrapper(BasicType);\n-#endif\n-\n-  \/\/ Fast access to current thread\n-protected:\n-  static int _thread_ptr_offset;\n-private:\n-  static void initialize_thread_ptr_offset();\n-  static inline void set_thread_ptr_offset(int offset) {\n-    _thread_ptr_offset = offset;\n-  }\n-  static inline int get_thread_ptr_offset() { return _thread_ptr_offset; }\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -336,0 +336,6 @@\n+  if (!is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n+  }\n@@ -848,17 +854,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Bsd::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -590,17 +590,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Linux::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::fetch_frame_from_context(uc).pc();\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -442,1 +442,0 @@\n-  template(inheritedAccessControlContext_name,        \"inheritedAccessControlContext\")            \\\n@@ -445,1 +444,0 @@\n-  template(checkPackageAccess_name,                   \"checkPackageAccess\")                       \\\n@@ -519,0 +517,2 @@\n+  template(lockStackSize_name,                        \"lockStackSize\")                            \\\n+  template(objectWaiter_name,                         \"objectWaiter\")                             \\\n@@ -567,0 +567,1 @@\n+  template(vthread_signature,                         \"Ljava\/lang\/VirtualThread;\")                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+#include \"gc\/shared\/fullGCForwarding.hpp\"\n@@ -89,1 +90,0 @@\n-#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -1439,0 +1439,2 @@\n+  FullGCForwarding::initialize(heap_rs.region());\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"gc\/shared\/fullGCForwarding.inline.hpp\"\n@@ -131,0 +132,20 @@\n+bool ParallelCompactData::RegionData::is_clear() {\n+  return (_destination == nullptr) &&\n+         (_source_region == 0) &&\n+         (_partial_obj_addr == nullptr) &&\n+         (_partial_obj_size == 0) &&\n+         (_dc_and_los == 0) &&\n+         (_shadow_state == 0);\n+}\n+\n+#ifdef ASSERT\n+void ParallelCompactData::RegionData::verify_clear() {\n+  assert(_destination == nullptr, \"inv\");\n+  assert(_source_region == 0, \"inv\");\n+  assert(_partial_obj_addr == nullptr, \"inv\");\n+  assert(_partial_obj_size == 0, \"inv\");\n+  assert(_dc_and_los == 0, \"inv\");\n+  assert(_shadow_state == 0, \"inv\");\n+}\n+#endif\n+\n@@ -136,10 +157,2 @@\n-void SplitInfo::record(size_t src_region_idx, size_t partial_obj_size,\n-                       HeapWord* destination)\n-{\n-  assert(src_region_idx != 0, \"invalid src_region_idx\");\n-  assert(partial_obj_size != 0, \"invalid partial_obj_size argument\");\n-  assert(destination != nullptr, \"invalid destination argument\");\n-\n-  _src_region_idx = src_region_idx;\n-  _partial_obj_size = partial_obj_size;\n-  _destination = destination;\n+void SplitInfo::record(size_t split_region_idx, HeapWord* split_point, size_t preceding_live_words) {\n+  assert(split_region_idx != 0, \"precondition\");\n@@ -147,3 +160,2 @@\n-  \/\/ These fields may not be updated below, so make sure they're clear.\n-  assert(_dest_region_addr == nullptr, \"should have been cleared\");\n-  assert(_first_src_addr == nullptr, \"should have been cleared\");\n+  \/\/ Obj denoted by split_point will be deferred to the next space.\n+  assert(split_point != nullptr, \"precondition\");\n@@ -151,14 +163,11 @@\n-  \/\/ Determine the number of destination regions for the partial object.\n-  HeapWord* const last_word = destination + partial_obj_size - 1;\n-  HeapWord* const beg_region_addr = sd.region_align_down(destination);\n-  HeapWord* const end_region_addr = sd.region_align_down(last_word);\n-\n-  if (beg_region_addr == end_region_addr) {\n-    \/\/ One destination region.\n-    _destination_count = 1;\n-    if (end_region_addr == destination) {\n-      \/\/ The destination falls on a region boundary, thus the first word of the\n-      \/\/ partial object will be the first word copied to the destination region.\n-      _dest_region_addr = end_region_addr;\n-      _first_src_addr = sd.region_to_addr(src_region_idx);\n-    }\n+\n+  PSParallelCompact::RegionData* split_region_ptr = sd.region(split_region_idx);\n+  assert(preceding_live_words < split_region_ptr->data_size(), \"inv\");\n+\n+  HeapWord* preceding_destination = split_region_ptr->destination();\n+  assert(preceding_destination != nullptr, \"inv\");\n+\n+  \/\/ How many regions does the preceding part occupy\n+  uint preceding_destination_count;\n+  if (preceding_live_words == 0) {\n+    preceding_destination_count = 0;\n@@ -167,8 +176,7 @@\n-    \/\/ Two destination regions.  When copied, the partial object will cross a\n-    \/\/ destination region boundary, so a word somewhere within the partial\n-    \/\/ object will be the first word copied to the second destination region.\n-    _destination_count = 2;\n-    _dest_region_addr = end_region_addr;\n-    const size_t ofs = pointer_delta(end_region_addr, destination);\n-    assert(ofs < _partial_obj_size, \"sanity\");\n-    _first_src_addr = sd.region_to_addr(src_region_idx) + ofs;\n+    \/\/ -1 so that the ending address doesn't fall on the region-boundary\n+    if (sd.region_align_down(preceding_destination) ==\n+        sd.region_align_down(preceding_destination + preceding_live_words - 1)) {\n+      preceding_destination_count = 1;\n+    } else {\n+      preceding_destination_count = 2;\n+    }\n@@ -176,0 +184,6 @@\n+\n+  _split_region_idx = split_region_idx;\n+  _split_point = split_point;\n+  _preceding_live_words = preceding_live_words;\n+  _preceding_destination = preceding_destination;\n+  _preceding_destination_count = preceding_destination_count;\n@@ -180,6 +194,5 @@\n-  _src_region_idx = 0;\n-  _partial_obj_size = 0;\n-  _destination = nullptr;\n-  _destination_count = 0;\n-  _dest_region_addr = nullptr;\n-  _first_src_addr = nullptr;\n+  _split_region_idx = 0;\n+  _split_point = nullptr;\n+  _preceding_live_words = 0;\n+  _preceding_destination = nullptr;\n+  _preceding_destination_count = 0;\n@@ -192,6 +205,5 @@\n-  assert(_src_region_idx == 0, \"not clear\");\n-  assert(_partial_obj_size == 0, \"not clear\");\n-  assert(_destination == nullptr, \"not clear\");\n-  assert(_destination_count == 0, \"not clear\");\n-  assert(_dest_region_addr == nullptr, \"not clear\");\n-  assert(_first_src_addr == nullptr, \"not clear\");\n+  assert(_split_region_idx == 0, \"not clear\");\n+  assert(_split_point == nullptr, \"not clear\");\n+  assert(_preceding_live_words == 0, \"not clear\");\n+  assert(_preceding_destination == nullptr, \"not clear\");\n+  assert(_preceding_destination_count == 0, \"not clear\");\n@@ -300,23 +312,8 @@\n-\/\/ Find the point at which a space can be split and, if necessary, record the\n-\/\/ split point.\n-\/\/\n-\/\/ If the current src region (which overflowed the destination space) doesn't\n-\/\/ have a partial object, the split point is at the beginning of the current src\n-\/\/ region (an \"easy\" split, no extra bookkeeping required).\n-\/\/\n-\/\/ If the current src region has a partial object, the split point is in the\n-\/\/ region where that partial object starts (call it the split_region).  If\n-\/\/ split_region has a partial object, then the split point is just after that\n-\/\/ partial object (a \"hard\" split where we have to record the split data and\n-\/\/ zero the partial_obj_size field).  With a \"hard\" split, we know that the\n-\/\/ partial_obj ends within split_region because the partial object that caused\n-\/\/ the overflow starts in split_region.  If split_region doesn't have a partial\n-\/\/ obj, then the split is at the beginning of split_region (another \"easy\"\n-\/\/ split).\n-HeapWord*\n-ParallelCompactData::summarize_split_space(size_t src_region,\n-                                           SplitInfo& split_info,\n-                                           HeapWord* destination,\n-                                           HeapWord* target_end,\n-                                           HeapWord** target_next)\n-{\n+\/\/ The total live words on src_region would overflow the target space, so find\n+\/\/ the overflowing object and record the split point. The invariant is that an\n+\/\/ obj should not cross space boundary.\n+HeapWord* ParallelCompactData::summarize_split_space(size_t src_region,\n+                                                     SplitInfo& split_info,\n+                                                     HeapWord* const destination,\n+                                                     HeapWord* const target_end,\n+                                                     HeapWord** target_next) {\n@@ -328,2 +325,0 @@\n-  size_t split_region = src_region;\n-  HeapWord* split_destination = destination;\n@@ -333,3 +328,2 @@\n-    \/\/ The split point is just after the partial object (if any) in the\n-    \/\/ src_region that contains the start of the object that overflowed the\n-    \/\/ destination space.\n+    assert(partial_obj_size > 0, \"inv\");\n+    \/\/ The overflowing obj is from a previous region.\n@@ -337,8 +331,1 @@\n-    \/\/ Find the start of the \"overflow\" object and set split_region to the\n-    \/\/ region containing it.\n-    HeapWord* const overflow_obj = _region_data[src_region].partial_obj_addr();\n-    split_region = addr_to_region_idx(overflow_obj);\n-\n-    \/\/ Clear the source_region field of all destination regions whose first word\n-    \/\/ came from data after the split point (a non-null source_region field\n-    \/\/ implies a region must be filled).\n+    \/\/ source-regions:\n@@ -346,4 +333,5 @@\n-    \/\/ An alternative to the simple loop below:  clear during post_compact(),\n-    \/\/ which uses memcpy instead of individual stores, and is easy to\n-    \/\/ parallelize.  (The downside is that it clears the entire RegionData\n-    \/\/ object as opposed to just one field.)\n+    \/\/ ***************\n+    \/\/ |     A|AA    |\n+    \/\/ ***************\n+    \/\/       ^\n+    \/\/       | split-point\n@@ -351,2 +339,1 @@\n-    \/\/ post_compact() would have to clear the summary data up to the highest\n-    \/\/ address that was written during the summary phase, which would be\n+    \/\/ dest-region:\n@@ -354,1 +341,7 @@\n-    \/\/         max(top, max(new_top, clear_top))\n+    \/\/ ********\n+    \/\/ |~~~~A |\n+    \/\/ ********\n+    \/\/       ^^\n+    \/\/       || target-space-end\n+    \/\/       |\n+    \/\/       | destination\n@@ -356,7 +349,4 @@\n-    \/\/ where clear_top is a new field in SpaceInfo.  Would have to set clear_top\n-    \/\/ to target_end.\n-    const RegionData* const sr = region(split_region);\n-    const size_t beg_idx =\n-      addr_to_region_idx(region_align_up(sr->destination() +\n-                                         sr->partial_obj_size()));\n-    const size_t end_idx = addr_to_region_idx(target_end);\n+    \/\/ AAA would overflow target-space.\n+    \/\/\n+    HeapWord* overflowing_obj = _region_data[src_region].partial_obj_addr();\n+    size_t split_region = addr_to_region_idx(overflowing_obj);\n@@ -364,3 +354,8 @@\n-    log_develop_trace(gc, compaction)(\"split:  clearing source_region field in [\" SIZE_FORMAT \", \" SIZE_FORMAT \")\", beg_idx, end_idx);\n-    for (size_t idx = beg_idx; idx < end_idx; ++idx) {\n-      _region_data[idx].set_source_region(0);\n+    \/\/ The number of live words before the overflowing object on this split region\n+    size_t preceding_live_words;\n+    if (is_region_aligned(overflowing_obj)) {\n+      preceding_live_words = 0;\n+    } else {\n+      \/\/ Words accounted by the overflowing object on the split region\n+      size_t overflowing_size = pointer_delta(region_align_up(overflowing_obj), overflowing_obj);\n+      preceding_live_words = region(split_region)->data_size() - overflowing_size;\n@@ -369,4 +364,19 @@\n-    \/\/ Set split_destination and partial_obj_size to reflect the split region.\n-    split_destination = sr->destination();\n-    partial_obj_size = sr->partial_obj_size();\n-  }\n+    split_info.record(split_region, overflowing_obj, preceding_live_words);\n+\n+    HeapWord* src_region_start = region_to_addr(src_region);\n+    HeapWord* new_top = destination - pointer_delta(src_region_start, overflowing_obj);\n+\n+    \/\/ If the overflowing obj was relocated to its original destination,\n+    \/\/ those destination regions would have their source_region set. Now that\n+    \/\/ this overflowing obj is relocated somewhere else, reset the\n+    \/\/ source_region.\n+    {\n+      size_t range_start = addr_to_region_idx(region_align_up(new_top));\n+      size_t range_end = addr_to_region_idx(region_align_up(destination));\n+      for (size_t i = range_start; i < range_end; ++i) {\n+        region(i)->set_source_region(0);\n+      }\n+    }\n+\n+    \/\/ Update new top of target space\n+    *target_next = new_top;\n@@ -374,4 +384,1 @@\n-  \/\/ The split is recorded only if a partial object extends onto the region.\n-  if (partial_obj_size != 0) {\n-    _region_data[split_region].set_partial_obj_size(0);\n-    split_info.record(split_region, partial_obj_size, split_destination);\n+    return overflowing_obj;\n@@ -380,3 +387,5 @@\n-  \/\/ Setup the continuation addresses.\n-  *target_next = split_destination + partial_obj_size;\n-  HeapWord* const source_next = region_to_addr(split_region) + partial_obj_size;\n+  \/\/ Obj-iteration to locate the overflowing obj\n+  HeapWord* region_start = region_to_addr(src_region);\n+  HeapWord* region_end = region_start + RegionSize;\n+  HeapWord* cur_addr = region_start + partial_obj_size;\n+  size_t live_words = partial_obj_size;\n@@ -384,8 +393,5 @@\n-  if (log_develop_is_enabled(Trace, gc, compaction)) {\n-    const char * split_type = partial_obj_size == 0 ? \"easy\" : \"hard\";\n-    log_develop_trace(gc, compaction)(\"%s split:  src=\" PTR_FORMAT \" src_c=\" SIZE_FORMAT \" pos=\" SIZE_FORMAT,\n-                                      split_type, p2i(source_next), split_region, partial_obj_size);\n-    log_develop_trace(gc, compaction)(\"%s split:  dst=\" PTR_FORMAT \" dst_c=\" SIZE_FORMAT \" tn=\" PTR_FORMAT,\n-                                      split_type, p2i(split_destination),\n-                                      addr_to_region_idx(split_destination),\n-                                      p2i(*target_next));\n+  while (true) {\n+    assert(cur_addr < region_end, \"inv\");\n+    cur_addr = PSParallelCompact::mark_bitmap()->find_obj_beg(cur_addr, region_end);\n+    \/\/ There must be an overflowing obj in this region\n+    assert(cur_addr < region_end, \"inv\");\n@@ -393,7 +399,7 @@\n-    if (partial_obj_size != 0) {\n-      HeapWord* const po_beg = split_info.destination();\n-      HeapWord* const po_end = po_beg + split_info.partial_obj_size();\n-      log_develop_trace(gc, compaction)(\"%s split:  po_beg=\" PTR_FORMAT \" \" SIZE_FORMAT \" po_end=\" PTR_FORMAT \" \" SIZE_FORMAT,\n-                                        split_type,\n-                                        p2i(po_beg), addr_to_region_idx(po_beg),\n-                                        p2i(po_end), addr_to_region_idx(po_end));\n+    oop obj = cast_to_oop(cur_addr);\n+    size_t obj_size = obj->size();\n+    if (destination + live_words + obj_size > target_end) {\n+      \/\/ Found the overflowing obj\n+      split_info.record(src_region, cur_addr, live_words);\n+      *target_next = destination + live_words;\n+      return cur_addr;\n@@ -401,2 +407,3 @@\n-  }\n-  return source_next;\n+    live_words += obj_size;\n+    cur_addr += obj_size;\n+  }\n@@ -455,2 +462,13 @@\n-  while (cur_region < end_region) {\n-    \/\/ The destination must be set even if the region has no data.\n+  for (\/* empty *\/; cur_region < end_region; cur_region++) {\n+    size_t words = _region_data[cur_region].data_size();\n+\n+    \/\/ Skip empty ones\n+    if (words == 0) {\n+      continue;\n+    }\n+\n+    if (split_info.is_split(cur_region)) {\n+      assert(words > split_info.preceding_live_words(), \"inv\");\n+      words -= split_info.preceding_live_words();\n+    }\n+\n@@ -459,11 +477,9 @@\n-    size_t words = _region_data[cur_region].data_size();\n-    if (words > 0) {\n-      \/\/ If cur_region does not fit entirely into the target space, find a point\n-      \/\/ at which the source space can be 'split' so that part is copied to the\n-      \/\/ target space and the rest is copied elsewhere.\n-      if (dest_addr + words > target_end) {\n-        assert(source_next != nullptr, \"source_next is null when splitting\");\n-        *source_next = summarize_split_space(cur_region, split_info, dest_addr,\n-                                             target_end, target_next);\n-        return false;\n-      }\n+    \/\/ If cur_region does not fit entirely into the target space, find a point\n+    \/\/ at which the source space can be 'split' so that part is copied to the\n+    \/\/ target space and the rest is copied elsewhere.\n+    if (dest_addr + words > target_end) {\n+      assert(source_next != nullptr, \"source_next is null when splitting\");\n+      *source_next = summarize_split_space(cur_region, split_info, dest_addr,\n+                                           target_end, target_next);\n+      return false;\n+    }\n@@ -471,22 +487,3 @@\n-      \/\/ Compute the destination_count for cur_region, and if necessary, update\n-      \/\/ source_region for a destination region.  The source_region field is\n-      \/\/ updated if cur_region is the first (left-most) region to be copied to a\n-      \/\/ destination region.\n-      \/\/\n-      \/\/ The destination_count calculation is a bit subtle.  A region that has\n-      \/\/ data that compacts into itself does not count itself as a destination.\n-      \/\/ This maintains the invariant that a zero count means the region is\n-      \/\/ available and can be claimed and then filled.\n-      uint destination_count = 0;\n-      if (split_info.is_split(cur_region)) {\n-        \/\/ The current region has been split:  the partial object will be copied\n-        \/\/ to one destination space and the remaining data will be copied to\n-        \/\/ another destination space.  Adjust the initial destination_count and,\n-        \/\/ if necessary, set the source_region field if the partial object will\n-        \/\/ cross a destination region boundary.\n-        destination_count = split_info.destination_count();\n-        if (destination_count == 2) {\n-          size_t dest_idx = addr_to_region_idx(split_info.dest_region_addr());\n-          _region_data[dest_idx].set_source_region(cur_region);\n-        }\n-      }\n+    uint destination_count = split_info.is_split(cur_region)\n+                             ? split_info.preceding_destination_count()\n+                             : 0;\n@@ -494,19 +491,3 @@\n-      HeapWord* const last_addr = dest_addr + words - 1;\n-      const size_t dest_region_1 = addr_to_region_idx(dest_addr);\n-      const size_t dest_region_2 = addr_to_region_idx(last_addr);\n-\n-      \/\/ Initially assume that the destination regions will be the same and\n-      \/\/ adjust the value below if necessary.  Under this assumption, if\n-      \/\/ cur_region == dest_region_2, then cur_region will be compacted\n-      \/\/ completely into itself.\n-      destination_count += cur_region == dest_region_2 ? 0 : 1;\n-      if (dest_region_1 != dest_region_2) {\n-        \/\/ Destination regions differ; adjust destination_count.\n-        destination_count += 1;\n-        \/\/ Data from cur_region will be copied to the start of dest_region_2.\n-        _region_data[dest_region_2].set_source_region(cur_region);\n-      } else if (is_region_aligned(dest_addr)) {\n-        \/\/ Data from cur_region will be copied to the start of the destination\n-        \/\/ region.\n-        _region_data[dest_region_1].set_source_region(cur_region);\n-      }\n+    HeapWord* const last_addr = dest_addr + words - 1;\n+    const size_t dest_region_1 = addr_to_region_idx(dest_addr);\n+    const size_t dest_region_2 = addr_to_region_idx(last_addr);\n@@ -514,2 +495,14 @@\n-      _region_data[cur_region].set_destination_count(destination_count);\n-      dest_addr += words;\n+    \/\/ Initially assume that the destination regions will be the same and\n+    \/\/ adjust the value below if necessary.  Under this assumption, if\n+    \/\/ cur_region == dest_region_2, then cur_region will be compacted\n+    \/\/ completely into itself.\n+    destination_count += cur_region == dest_region_2 ? 0 : 1;\n+    if (dest_region_1 != dest_region_2) {\n+      \/\/ Destination regions differ; adjust destination_count.\n+      destination_count += 1;\n+      \/\/ Data from cur_region will be copied to the start of dest_region_2.\n+      _region_data[dest_region_2].set_source_region(cur_region);\n+    } else if (is_region_aligned(dest_addr)) {\n+      \/\/ Data from cur_region will be copied to the start of the destination\n+      \/\/ region.\n+      _region_data[dest_region_1].set_source_region(cur_region);\n@@ -518,1 +511,2 @@\n-    ++cur_region;\n+    _region_data[cur_region].set_destination_count(destination_count);\n+    dest_addr += words;\n@@ -526,6 +520,6 @@\n-void ParallelCompactData::verify_clear()\n-{\n-  const size_t* const beg = (const size_t*) _region_vspace->committed_low_addr();\n-  const size_t* const end = (const size_t*) _region_vspace->committed_high_addr();\n-  for (const size_t* p = beg; p < end; ++p) {\n-    assert(*p == 0, \"not zero\");\n+void ParallelCompactData::verify_clear() {\n+  for (uint cur_idx = 0; cur_idx < region_count(); ++cur_idx) {\n+    if (!region(cur_idx)->is_clear()) {\n+      log_warning(gc)(\"Uncleared Region: %u\", cur_idx);\n+      region(cur_idx)->verify_clear();\n+    }\n@@ -698,0 +692,7 @@\n+#ifdef ASSERT\n+  {\n+    mark_bitmap()->verify_clear();\n+    summary_data().verify_clear();\n+  }\n+#endif\n+\n@@ -777,0 +778,2 @@\n+  \/\/ With +UseCompactObjectHeaders, the minimum filler size is only one word,\n+  \/\/ because the Klass* gets encoded in the mark-word.\n@@ -784,8 +787,1 @@\n-  \/\/ Note: If min-fill-size decreases to 1, this whole method becomes redundant.\n-  assert(CollectedHeap::min_fill_size() >= 2, \"inv\");\n-#ifndef _LP64\n-  \/\/ In 32-bit system, each heap word is 4 bytes, so MinObjAlignment == 2.\n-  \/\/ The gap is always equal to min-fill-size, so nothing to do.\n-  return;\n-#endif\n-  if (MinObjAlignment > 1) {\n+  if (MinObjAlignment >= checked_cast<int>(CollectedHeap::min_fill_size())) {\n@@ -794,0 +790,2 @@\n+\n+  assert(!UseCompactObjectHeaders, \"Compact headers can allocate small objects\");\n@@ -884,4 +882,4 @@\n-    HeapWord* dense_prefix_end =\n-      maximum_compaction ? full_region_prefix_end\n-                         : compute_dense_prefix_for_old_space(old_space,\n-                                                              full_region_prefix_end);\n+    HeapWord* dense_prefix_end = maximum_compaction\n+                                 ? full_region_prefix_end\n+                                 : compute_dense_prefix_for_old_space(old_space,\n+                                                                      full_region_prefix_end);\n@@ -895,0 +893,2 @@\n+\n+    \/\/ Compacting objs inn [dense_prefix_end, old_space->top())\n@@ -1568,0 +1568,24 @@\n+    static void forward_objs_in_range(ParCompactionManager* cm,\n+                                      HeapWord* start,\n+                                      HeapWord* end,\n+                                      HeapWord* destination) {\n+      HeapWord* cur_addr = start;\n+      HeapWord* new_addr = destination;\n+\n+      while (cur_addr < end) {\n+        cur_addr = mark_bitmap()->find_obj_beg(cur_addr, end);\n+        if (cur_addr >= end) {\n+          return;\n+        }\n+        assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n+        oop obj = cast_to_oop(cur_addr);\n+        if (new_addr != cur_addr) {\n+          cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n+          FullGCForwarding::forward_to(obj, cast_to_oop(new_addr));\n+        }\n+        size_t obj_size = obj->size();\n+        new_addr += obj_size;\n+        cur_addr += obj_size;\n+      }\n+    }\n+\n@@ -1579,0 +1603,2 @@\n+        const SplitInfo& split_info = _space_info[SpaceId(id)].split_info();\n+\n@@ -1598,18 +1624,13 @@\n-          HeapWord* cur_addr = region_start + live_words;\n-\n-          HeapWord* destination = region_ptr->destination();\n-          while (cur_addr < region_end) {\n-            cur_addr = mark_bitmap()->find_obj_beg(cur_addr, region_end);\n-            if (cur_addr >= region_end) {\n-              break;\n-            }\n-            assert(mark_bitmap()->is_marked(cur_addr), \"inv\");\n-            HeapWord* new_addr = destination + live_words;\n-            oop obj = cast_to_oop(cur_addr);\n-            if (new_addr != cur_addr) {\n-              cm->preserved_marks()->push_if_necessary(obj, obj->mark());\n-              obj->forward_to(cast_to_oop(new_addr));\n-            }\n-            size_t obj_size = obj->size();\n-            live_words += obj_size;\n-            cur_addr += obj_size;\n+\n+          if (split_info.is_split(cur_region)) {\n+            \/\/ Part 1: will be relocated to space-1\n+            HeapWord* preceding_destination = split_info.preceding_destination();\n+            HeapWord* split_point = split_info.split_point();\n+            forward_objs_in_range(cm, region_start + live_words, split_point, preceding_destination + live_words);\n+\n+            \/\/ Part 2: will be relocated to space-2\n+            HeapWord* destination = region_ptr->destination();\n+            forward_objs_in_range(cm, split_point, region_end, destination);\n+          } else {\n+            HeapWord* destination = region_ptr->destination();\n+            forward_objs_in_range(cm, region_start + live_words, region_end, destination + live_words);\n@@ -1647,0 +1668,1 @@\n+      assert(bump_ptr <= _space_info[bump_ptr_space].new_top(), \"inv\");\n@@ -1653,2 +1675,4 @@\n-      if (cur_addr != bump_ptr) {\n-        assert(obj->forwardee() == cast_to_oop(bump_ptr), \"inv\");\n+      if (cur_addr == bump_ptr) {\n+        assert(!FullGCForwarding::is_forwarded(obj), \"inv\");\n+      } else {\n+        assert(FullGCForwarding::forwardee(obj) == cast_to_oop(bump_ptr), \"inv\");\n@@ -1908,1 +1932,1 @@\n-      Klass* k = cast_to_oop(cur_addr)->klass_without_asserts();\n+      Klass* k = cast_to_oop(cur_addr)->klass();\n@@ -1959,6 +1983,3 @@\n-\/\/ next live word.  Unless marked, the word corresponding to beg is assumed to\n-\/\/ be dead.  Callers must either ensure beg does not correspond to the middle of\n-\/\/ an object, or account for those live words in some other way.  Callers must\n-\/\/ also ensure that there are enough live words in the range [beg, end) to skip.\n-HeapWord*\n-PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)\n+\/\/ next live word. Callers must also ensure that there are enough live words in\n+\/\/ the range [beg, end) to skip.\n+HeapWord* PSParallelCompact::skip_live_words(HeapWord* beg, HeapWord* end, size_t count)\n@@ -1966,2 +1987,0 @@\n-  assert(count > 0, \"sanity\");\n-\n@@ -1983,0 +2002,39 @@\n+\/\/ On filling a destination region (dest-region), we need to know the location\n+\/\/ of the word that will be at the start of the dest-region after compaction.\n+\/\/ A dest-region can have one or more source regions, but only the first\n+\/\/ source-region contains this location. This location is retrieved by calling\n+\/\/ `first_src_addr` on a dest-region.\n+\/\/ Conversely, a source-region has a dest-region which holds the destination of\n+\/\/ the first live word on this source-region, based on which the destination\n+\/\/ for the rest of live words can be derived.\n+\/\/\n+\/\/ Note:\n+\/\/ There is some complication due to space-boundary-fragmentation (an obj can't\n+\/\/ cross space-boundary) -- a source-region may be split and behave like two\n+\/\/ distinct regions with their own dest-region, as depicted below.\n+\/\/\n+\/\/ source-region: region-n\n+\/\/\n+\/\/ **********************\n+\/\/ |     A|A~~~~B|B     |\n+\/\/ **********************\n+\/\/    n-1     n     n+1\n+\/\/\n+\/\/ AA, BB denote two live objs. ~~~~ denotes unknown number of live objs.\n+\/\/\n+\/\/ Assuming the dest-region for region-n is the final region before\n+\/\/ old-space-end and its first-live-word is the middle of AA, the heap content\n+\/\/ will look like the following after compaction:\n+\/\/\n+\/\/ **************                  *************\n+\/\/      A|A~~~~ |                  |BB    |\n+\/\/ **************                  *************\n+\/\/              ^                  ^\n+\/\/              | old-space-end    | eden-space-start\n+\/\/\n+\/\/ Therefore, in this example, region-n will have two dest-regions, one for\n+\/\/ the final region in old-space and the other for the first region in\n+\/\/ eden-space.\n+\/\/ To handle this special case, we introduce the concept of split-region, whose\n+\/\/ contents are relocated to two spaces. `SplitInfo` captures all necessary\n+\/\/ info about the split, the first part, spliting-point, and the second part.\n@@ -1987,11 +2045,2 @@\n-  assert(summary_data().is_region_aligned(dest_addr), \"not aligned\");\n-\n-  const SplitInfo& split_info = _space_info[src_space_id].split_info();\n-  if (split_info.dest_region_addr() == dest_addr) {\n-    \/\/ The partial object ending at the split point contains the first word to\n-    \/\/ be copied to dest_addr.\n-    return split_info.first_src_addr();\n-  }\n-\n-  const ParallelCompactData& sd = summary_data();\n-  ParMarkBitMap* const bitmap = mark_bitmap();\n+  const ParallelCompactData& sd = summary_data();\n+  assert(sd.is_region_aligned(dest_addr), \"precondition\");\n@@ -2000,1 +2049,2 @@\n-  assert(sd.is_region_aligned(dest_addr), \"not aligned\");\n+  assert(src_region_ptr->data_size() > 0, \"src region cannot be empty\");\n+\n@@ -2005,5 +2055,2 @@\n-  assert(dest_addr >= src_region_destination, \"wrong src region\");\n-  assert(src_region_ptr->data_size() > 0, \"src region cannot be empty\");\n-\n-  HeapWord* const src_region_beg = sd.region_to_addr(src_region_idx);\n-  HeapWord* const src_region_end = src_region_beg + RegionSize;\n+  HeapWord* const region_start = sd.region_to_addr(src_region_idx);\n+  HeapWord* const region_end = sd.region_to_addr(src_region_idx) + RegionSize;\n@@ -2011,6 +2058,8 @@\n-  HeapWord* addr = src_region_beg;\n-  if (dest_addr == src_region_destination) {\n-    \/\/ Return the first live word in the source region.\n-    if (partial_obj_size == 0) {\n-      addr = bitmap->find_obj_beg(addr, src_region_end);\n-      assert(addr < src_region_end, \"no objects start in src region\");\n+  \/\/ Identify the actual destination for the first live words on this region,\n+  \/\/ taking split-region into account.\n+  HeapWord* region_start_destination;\n+  const SplitInfo& split_info = _space_info[src_space_id].split_info();\n+  if (split_info.is_split(src_region_idx)) {\n+    \/\/ The second part of this split region; use the recorded split point.\n+    if (dest_addr == src_region_destination) {\n+      return split_info.split_point();\n@@ -2018,1 +2067,3 @@\n-    return addr;\n+    region_start_destination = split_info.preceding_destination();\n+  } else {\n+    region_start_destination = src_region_destination;\n@@ -2021,3 +2072,2 @@\n-  \/\/ Must skip some live data.\n-  size_t words_to_skip = dest_addr - src_region_destination;\n-  assert(src_region_ptr->data_size() > words_to_skip, \"wrong src region\");\n+  \/\/ Calculate the offset to be skipped\n+  size_t words_to_skip = pointer_delta(dest_addr, region_start_destination);\n@@ -2025,9 +2075,6 @@\n-  if (partial_obj_size >= words_to_skip) {\n-    \/\/ All the live words to skip are part of the partial object.\n-    addr += words_to_skip;\n-    if (partial_obj_size == words_to_skip) {\n-      \/\/ Find the first live word past the partial object.\n-      addr = bitmap->find_obj_beg(addr, src_region_end);\n-      assert(addr < src_region_end, \"wrong src region\");\n-    }\n-    return addr;\n+  HeapWord* result;\n+  if (partial_obj_size > words_to_skip) {\n+    result = region_start + words_to_skip;\n+  } else {\n+    words_to_skip -= partial_obj_size;\n+    result = skip_live_words(region_start + partial_obj_size, region_end, words_to_skip);\n@@ -2036,4 +2083,4 @@\n-  \/\/ Skip over the partial object (if any).\n-  if (partial_obj_size != 0) {\n-    words_to_skip -= partial_obj_size;\n-    addr += partial_obj_size;\n+  if (split_info.is_split(src_region_idx)) {\n+    assert(result < split_info.split_point(), \"postcondition\");\n+  } else {\n+    assert(result < region_end, \"postcondition\");\n@@ -2042,4 +2089,1 @@\n-  \/\/ Skip over live words due to objects that start in the region.\n-  addr = skip_live_words(addr, src_region_end, words_to_skip);\n-  assert(addr < src_region_end, \"wrong src region\");\n-  return addr;\n+  return result;\n@@ -2096,3 +2140,0 @@\n-  typedef ParallelCompactData::RegionData RegionData;\n-\n-  const size_t region_size = ParallelCompactData::RegionSize;\n@@ -2107,2 +2148,2 @@\n-  const RegionData* const top_region_ptr =\n-    sd.addr_to_region_ptr(top_aligned_up);\n+  const RegionData* const top_region_ptr = sd.addr_to_region_ptr(top_aligned_up);\n+\n@@ -2125,1 +2166,1 @@\n-  unsigned int space_id = src_space_id + 1;\n+  uint space_id = src_space_id + 1;\n@@ -2128,28 +2169,24 @@\n-  HeapWord* const destination = closure.destination();\n-\n-  do {\n-    MutableSpace* space = _space_info[space_id].space();\n-    HeapWord* const bottom = space->bottom();\n-    const RegionData* const bottom_cp = sd.addr_to_region_ptr(bottom);\n-\n-    \/\/ Iterate over the spaces that do not compact into themselves.\n-    if (bottom_cp->destination() != bottom) {\n-      HeapWord* const top_aligned_up = sd.region_align_up(space->top());\n-      const RegionData* const top_cp = sd.addr_to_region_ptr(top_aligned_up);\n-\n-      for (const RegionData* src_cp = bottom_cp; src_cp < top_cp; ++src_cp) {\n-        if (src_cp->live_obj_size() > 0) {\n-          \/\/ Found it.\n-          assert(src_cp->destination() == destination,\n-                 \"first live obj in the space must match the destination\");\n-          assert(src_cp->partial_obj_size() == 0,\n-                 \"a space cannot begin with a partial obj\");\n-\n-          src_space_id = SpaceId(space_id);\n-          src_space_top = space->top();\n-          const size_t src_region_idx = sd.region(src_cp);\n-          closure.set_source(sd.region_to_addr(src_region_idx));\n-          return src_region_idx;\n-        } else {\n-          assert(src_cp->data_size() == 0, \"sanity\");\n-        }\n+  for (\/* empty *\/; space_id < last_space_id; ++space_id) {\n+    HeapWord* bottom = _space_info[space_id].space()->bottom();\n+    HeapWord* top = _space_info[space_id].space()->top();\n+    \/\/ Skip empty space\n+    if (bottom == top) {\n+      continue;\n+    }\n+\n+    \/\/ Identify the first region that contains live words in this space\n+    size_t cur_region = sd.addr_to_region_idx(bottom);\n+    size_t end_region = sd.addr_to_region_idx(sd.region_align_up(top));\n+\n+    for (\/* empty *\/ ; cur_region < end_region; ++cur_region) {\n+      RegionData* cur = sd.region(cur_region);\n+      if (cur->live_obj_size() > 0) {\n+        HeapWord* region_start_addr = sd.region_to_addr(cur_region);\n+        HeapWord* region_end_addr = region_start_addr + ParallelCompactData::RegionSize;\n+        HeapWord* first_live_word = mark_bitmap()->find_obj_beg(region_start_addr, region_end_addr);\n+        assert(first_live_word < region_end_addr, \"inv\");\n+\n+        src_space_id = SpaceId(space_id);\n+        src_space_top = top;\n+        closure.set_source(first_live_word);\n+        return cur_region;\n@@ -2158,1 +2195,1 @@\n-  } while (++space_id < last_space_id);\n+  }\n@@ -2160,2 +2197,1 @@\n-  assert(false, \"no source region was found\");\n-  return 0;\n+  ShouldNotReachHere();\n@@ -2168,2 +2204,2 @@\n-  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends to region_start_addr.\n-  SplitInfo& split_info = _space_info[space_id(region_start_addr)].split_info();\n+  \/\/ Use per-region partial_obj_size to locate the end of the obj, that extends\n+  \/\/ to region_start_addr.\n@@ -2174,4 +2210,0 @@\n-    if (split_info.is_split(region_idx)) {\n-      accumulated_size += split_info.partial_obj_size();\n-      break;\n-    }\n@@ -2187,0 +2219,2 @@\n+\/\/ Use region_idx as the destination region, and evacuate all live objs on its\n+\/\/ source regions to this destination region.\n@@ -2207,0 +2241,18 @@\n+  \/\/ source-region:\n+  \/\/\n+  \/\/ **********\n+  \/\/ |   ~~~  |\n+  \/\/ **********\n+  \/\/      ^\n+  \/\/      |-- closure.source() \/ first_src_addr\n+  \/\/\n+  \/\/\n+  \/\/ ~~~ : live words\n+  \/\/\n+  \/\/ destination-region:\n+  \/\/\n+  \/\/ **********\n+  \/\/ |        |\n+  \/\/ **********\n+  \/\/ ^\n+  \/\/ |-- region-start\n@@ -2208,3 +2260,3 @@\n-    \/\/ The first source word is in the middle of an object; copy the remainder\n-    \/\/ of the object or as much as will fit.  The fact that pointer updates were\n-    \/\/ deferred will be noted when the object header is processed.\n+    \/\/ An object overflows the previous destination region, so this\n+    \/\/ destination region should copy the remainder of the object or as much as\n+    \/\/ will fit.\n@@ -2216,1 +2268,4 @@\n-      if (bitmap->is_marked(obj_start)) {\n+      if (obj_start != closure.source()) {\n+        assert(bitmap->is_marked(obj_start), \"inv\");\n+        \/\/ Found the actual obj-start, try to find the obj-end using either\n+        \/\/ size() if this obj is completely contained in the current region.\n@@ -2221,0 +2276,2 @@\n+        \/\/ This obj extends to next region iff partial_obj_addr of the *next*\n+        \/\/ region is the same as obj-start.\n@@ -2237,2 +2294,1 @@\n-      decrement_destination_counts(cm, src_space_id, src_region_idx,\n-                                   closure.source());\n+      decrement_destination_counts(cm, src_space_id, src_region_idx, closure.source());\n@@ -2243,0 +2299,1 @@\n+    \/\/ Finished copying without using up the current destination-region\n@@ -2245,0 +2302,1 @@\n+      assert(sd.region_align_up(old_src_addr) == end_addr, \"only one region\");\n@@ -2250,2 +2308,1 @@\n-      src_region_idx = next_src_region(closure, src_space_id, src_space_top,\n-                                       end_addr);\n+      src_region_idx = next_src_region(closure, src_space_id, src_space_top, end_addr);\n@@ -2255,0 +2312,1 @@\n+  \/\/ Handle the rest obj-by-obj, where we know obj-start.\n@@ -2259,1 +2317,2 @@\n-    HeapWord* partial_obj_start = (end_addr == src_space_top)\n+    \/\/ To handle the case where the final obj in source region extends to next region.\n+    HeapWord* final_obj_start = (end_addr == src_space_top)\n@@ -2262,1 +2321,1 @@\n-    \/\/ apply closure on objs inside [cur_addr, end_addr)\n+    \/\/ Apply closure on objs inside [cur_addr, end_addr)\n@@ -2269,1 +2328,1 @@\n-      if (partial_obj_start == cur_addr) {\n+      if (final_obj_start == cur_addr) {\n@@ -2280,2 +2339,1 @@\n-      decrement_destination_counts(cm, src_space_id, src_region_idx,\n-                                   closure.source());\n+      decrement_destination_counts(cm, src_space_id, src_region_idx, closure.source());\n@@ -2290,2 +2348,1 @@\n-    src_region_idx = next_src_region(closure, src_space_id, src_space_top,\n-                                     end_addr);\n+    src_region_idx = next_src_region(closure, src_space_id, src_space_top, end_addr);\n@@ -2413,2 +2470,2 @@\n-    assert(cast_to_oop(source())->is_forwarded(), \"inv\");\n-    assert(cast_to_oop(source())->forwardee() == cast_to_oop(destination()), \"inv\");\n+    assert(FullGCForwarding::is_forwarded(cast_to_oop(source())), \"inv\");\n+    assert(FullGCForwarding::forwardee(cast_to_oop(source())) == cast_to_oop(destination()), \"inv\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":393,"deletions":336,"binary":false,"changes":729,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"gc\/shared\/preservedMarks.inline.hpp\"\n@@ -231,1 +230,0 @@\n-    _preserved_marks_set(false \/* in_c_heap *\/),\n@@ -619,2 +617,0 @@\n-  \/\/ The preserved marks should be empty at the start of the GC.\n-  _preserved_marks_set.init(1);\n@@ -691,2 +687,0 @@\n-  \/\/ We should have processed and cleared all the preserved marks.\n-  _preserved_marks_set.reclaim();\n@@ -716,2 +710,6 @@\n-      if (obj->is_forwarded()) {\n-        obj->init_mark();\n+      if (obj->is_self_forwarded()) {\n+        obj->unset_self_forwarded();\n+      } else if (obj->is_forwarded()) {\n+        \/\/ To restore the klass-bits in the header.\n+        \/\/ Needed for object iteration to work properly.\n+        obj->set_mark(obj->forwardee()->prototype_mark());\n@@ -723,6 +721,0 @@\n-\n-  restore_preserved_marks();\n-}\n-\n-void DefNewGeneration::restore_preserved_marks() {\n-  _preserved_marks_set.restore(nullptr);\n@@ -736,1 +728,0 @@\n-  _preserved_marks_set.get()->push_if_necessary(old, old->mark());\n@@ -741,1 +732,1 @@\n-  old->forward_to(old);\n+  old->forward_to_self();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -223,0 +223,20 @@\n+static bool klass_is_sane(oop object) {\n+  if (UseCompactObjectHeaders) {\n+    \/\/ With compact headers, we can't safely access the Klass* when\n+    \/\/ the object has been forwarded, because non-full-GC-forwarding\n+    \/\/ temporarily overwrites the mark-word, and thus the Klass*, with\n+    \/\/ the forwarding pointer, and here we have no way to make a\n+    \/\/ distinction between Full-GC and regular GC forwarding.\n+    markWord mark = object->mark();\n+    if (mark.is_forwarded()) {\n+      \/\/ We can't access the Klass*. We optimistically assume that\n+      \/\/ it is ok. This happens very rarely.\n+      return true;\n+    }\n+\n+    return Metaspace::contains(mark.klass_without_asserts());\n+  }\n+\n+  return Metaspace::contains(object->klass_without_asserts());\n+}\n+\n@@ -232,1 +252,1 @@\n-  if (!Metaspace::contains(object->klass_without_asserts())) {\n+  if (!klass_is_sane(object)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-  static constexpr size_t min_dummy_object_size() {\n+  static size_t min_dummy_object_size() {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n- * Find a class from a boot class loader. Returns NULL if class not found.\n+ * Find a class from a boot class loader. Returns null if class not found.\n@@ -726,7 +726,0 @@\n-\/*\n- * java.security.*\n- *\/\n-\n-JNIEXPORT jobject JNICALL\n-JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls);\n-\n@@ -744,3 +737,0 @@\n-JNIEXPORT jobject JNICALL\n-JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls);\n-\n@@ -1148,0 +1138,6 @@\n+JNIEXPORT void JNICALL\n+JVM_VirtualThreadPinnedEvent(JNIEnv* env, jclass clazz, jstring op);\n+\n+JNIEXPORT jobject JNICALL\n+JVM_TakeVirtualThreadListToUnblock(JNIEnv* env, jclass ignored);\n+\n@@ -1160,0 +1156,7 @@\n+#define JNI_ONLOAD_SYMBOLS   {\"JNI_OnLoad\"}\n+#define JNI_ONUNLOAD_SYMBOLS {\"JNI_OnUnload\"}\n+#define JVM_ONLOAD_SYMBOLS      {\"JVM_OnLoad\"}\n+#define AGENT_ONLOAD_SYMBOLS    {\"Agent_OnLoad\"}\n+#define AGENT_ONUNLOAD_SYMBOLS  {\"Agent_OnUnload\"}\n+#define AGENT_ONATTACH_SYMBOLS  {\"Agent_OnAttach\"}\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-#if defined(_LP64) || defined(_WIN64)\n+#if defined(_LP64)\n@@ -1273,81 +1273,0 @@\n-\/\/ Returns the inherited_access_control_context field of the running thread.\n-JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))\n-  oop result = java_lang_Thread::inherited_access_control_context(thread->threadObj());\n-  return JNIHandles::make_local(THREAD, result);\n-JVM_END\n-\n-JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))\n-  if (!UsePrivilegedStack) return nullptr;\n-\n-  ResourceMark rm(THREAD);\n-  GrowableArray<Handle>* local_array = new GrowableArray<Handle>(12);\n-  JvmtiVMObjectAllocEventCollector oam;\n-\n-  \/\/ count the protection domains on the execution stack. We collapse\n-  \/\/ duplicate consecutive protection domains into a single one, as\n-  \/\/ well as stopping when we hit a privileged frame.\n-\n-  oop previous_protection_domain = nullptr;\n-  Handle privileged_context(thread, nullptr);\n-  bool is_privileged = false;\n-  oop protection_domain = nullptr;\n-\n-  \/\/ Iterate through Java frames\n-  vframeStream vfst(thread);\n-  for(; !vfst.at_end(); vfst.next()) {\n-    \/\/ get method of frame\n-    Method* method = vfst.method();\n-\n-    \/\/ stop at the first privileged frame\n-    if (method->method_holder() == vmClasses::AccessController_klass() &&\n-      method->name() == vmSymbols::executePrivileged_name())\n-    {\n-      \/\/ this frame is privileged\n-      is_privileged = true;\n-\n-      javaVFrame *priv = vfst.asJavaVFrame();       \/\/ executePrivileged\n-\n-      StackValueCollection* locals = priv->locals();\n-      StackValue* ctx_sv = locals->at(1); \/\/ AccessControlContext context\n-      StackValue* clr_sv = locals->at(2); \/\/ Class<?> caller\n-      assert(!ctx_sv->obj_is_scalar_replaced(), \"found scalar-replaced object\");\n-      assert(!clr_sv->obj_is_scalar_replaced(), \"found scalar-replaced object\");\n-      privileged_context    = ctx_sv->get_obj();\n-      Handle caller         = clr_sv->get_obj();\n-\n-      Klass *caller_klass = java_lang_Class::as_Klass(caller());\n-      protection_domain  = caller_klass->protection_domain();\n-    } else {\n-      protection_domain = method->method_holder()->protection_domain();\n-    }\n-\n-    if ((previous_protection_domain != protection_domain) && (protection_domain != nullptr)) {\n-      local_array->push(Handle(thread, protection_domain));\n-      previous_protection_domain = protection_domain;\n-    }\n-\n-    if (is_privileged) break;\n-  }\n-\n-\n-  \/\/ either all the domains on the stack were system domains, or\n-  \/\/ we had a privileged system domain\n-  if (local_array->is_empty()) {\n-    if (is_privileged && privileged_context.is_null()) return nullptr;\n-\n-    oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);\n-    return JNIHandles::make_local(THREAD, result);\n-  }\n-\n-  objArrayOop context = oopFactory::new_objArray(vmClasses::ProtectionDomain_klass(),\n-                                                 local_array->length(), CHECK_NULL);\n-  objArrayHandle h_context(thread, context);\n-  for (int index = 0; index < local_array->length(); index++) {\n-    h_context->obj_at_put(index, local_array->at(index)());\n-  }\n-\n-  oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);\n-\n-  return JNIHandles::make_local(THREAD, result);\n-JVM_END\n-\n@@ -3093,0 +3012,4 @@\n+\n+  \/\/ Set lock id of new current Thread\n+  thread->set_lock_id(java_lang_Thread::thread_id(threadObj));\n+\n@@ -3964,0 +3887,33 @@\n+JVM_ENTRY(void, JVM_VirtualThreadPinnedEvent(JNIEnv* env, jclass ignored, jstring op))\n+#if INCLUDE_JFR\n+  freeze_result result = THREAD->last_freeze_fail_result();\n+  assert(result != freeze_ok, \"sanity check\");\n+  EventVirtualThreadPinned event(UNTIMED);\n+  event.set_starttime(THREAD->last_freeze_fail_time());\n+  if (event.should_commit()) {\n+    ResourceMark rm(THREAD);\n+    const char *str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(op));\n+    THREAD->post_vthread_pinned_event(&event, str, result);\n+  }\n+#endif\n+JVM_END\n+\n+JVM_ENTRY(jobject, JVM_TakeVirtualThreadListToUnblock(JNIEnv* env, jclass ignored))\n+  ParkEvent* parkEvent = ObjectMonitor::vthread_unparker_ParkEvent();\n+  assert(parkEvent != nullptr, \"not initialized\");\n+\n+  OopHandle& list_head = ObjectMonitor::vthread_cxq_head();\n+  oop vthread_head = nullptr;\n+  while (true) {\n+    if (list_head.peek() != nullptr) {\n+      for (;;) {\n+        oop head = list_head.resolve();\n+        if (list_head.cmpxchg(head, nullptr) == head) {\n+          return JNIHandles::make_local(THREAD, head);\n+        }\n+      }\n+    }\n+    ThreadBlockInVM tbivm(THREAD);\n+    parkEvent->park();\n+  }\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":38,"deletions":82,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2873,0 +2873,13 @@\n+void JvmtiExport::vthread_post_monitor_waited(JavaThread *current, ObjectMonitor *obj_mntr, jboolean timed_out) {\n+  Handle vthread(current, current->vthread());\n+\n+  \/\/ Finish the VTMS transition temporarily to post the event.\n+  JvmtiVTMSTransitionDisabler::VTMS_vthread_mount((jthread)vthread.raw_value(), false);\n+\n+  \/\/ Post event.\n+  JvmtiExport::post_monitor_waited(current, obj_mntr, timed_out);\n+\n+  \/\/ Go back to VTMS transition state.\n+  JvmtiVTMSTransitionDisabler::VTMS_vthread_unmount((jthread)vthread.raw_value(), true);\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -403,0 +403,1 @@\n+  static void vthread_post_monitor_waited(JavaThread *current, ObjectMonitor *obj_mntr, jboolean timed_out) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1448,7 +1448,0 @@\n-void Arguments::set_use_compressed_klass_ptrs() {\n-#ifdef _LP64\n-  assert(!UseCompressedClassPointers || CompressedClassSpaceSize <= KlassEncodingMetaspaceMax,\n-         \"CompressedClassSpaceSize is too large for UseCompressedClassPointers\");\n-#endif \/\/ _LP64\n-}\n-\n@@ -1473,1 +1466,0 @@\n-  set_use_compressed_klass_ptrs();\n@@ -1844,0 +1836,9 @@\n+#ifndef _LP64\n+  if (LockingMode == LM_LEGACY) {\n+    FLAG_SET_CMDLINE(LockingMode, LM_LIGHTWEIGHT);\n+    \/\/ Self-forwarding in bit 3 of the mark-word conflicts\n+    \/\/ with 4-byte-aligned stack-locks.\n+    warning(\"Legacy locking not supported on this platform\");\n+  }\n+#endif\n+\n@@ -3743,0 +3744,26 @@\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders && FLAG_IS_CMDLINE(UseCompressedClassPointers) && !UseCompressedClassPointers) {\n+    warning(\"Compact object headers require compressed class pointers. Disabling compact object headers.\");\n+    FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+  }\n+  if (UseCompactObjectHeaders && LockingMode != LM_LIGHTWEIGHT) {\n+    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n+  }\n+  if (UseCompactObjectHeaders && !UseObjectMonitorTable) {\n+    \/\/ If UseCompactObjectHeaders is on the command line, turn on UseObjectMonitorTable.\n+    if (FLAG_IS_CMDLINE(UseCompactObjectHeaders)) {\n+      FLAG_SET_DEFAULT(UseObjectMonitorTable, true);\n+\n+    \/\/ If UseObjectMonitorTable is on the command line, turn off UseCompactObjectHeaders.\n+    } else if (FLAG_IS_CMDLINE(UseObjectMonitorTable)) {\n+      FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+    \/\/ If neither on the command line, the defaults are incompatible, but turn on UseObjectMonitorTable.\n+    } else {\n+      FLAG_SET_DEFAULT(UseObjectMonitorTable, true);\n+    }\n+  }\n+  if (UseCompactObjectHeaders && !UseCompressedClassPointers) {\n+    FLAG_SET_DEFAULT(UseCompressedClassPointers, true);\n+  }\n+#endif\n+\n@@ -3756,0 +3783,4 @@\n+  if (UseCompressedClassPointers) {\n+    CompressedKlassPointers::pre_initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":39,"deletions":8,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,0 @@\n-  static void set_use_compressed_klass_ptrs();\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,0 +134,3 @@\n+  product(bool, UseCompactObjectHeaders, false, EXPERIMENTAL,               \\\n+          \"Use compact 64-bit object headers in 64-bit VM\")                 \\\n+                                                                            \\\n@@ -150,0 +153,1 @@\n+const bool UseCompactObjectHeaders = false;\n@@ -685,3 +689,0 @@\n-  develop(bool, UsePrivilegedStack, true,                                   \\\n-          \"Enable the security JVM functions\")                              \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"runtime\/threadIdentifier.hpp\"\n@@ -50,0 +52,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -53,1 +56,0 @@\n-class ContinuationEntry;\n@@ -80,0 +82,2 @@\n+class EventVirtualThreadPinned;\n+\n@@ -162,0 +166,5 @@\n+  \/\/ ID used as owner for inflated monitors. Same as the j.l.Thread.tid of the\n+  \/\/ current _vthread object, except during creation of the primordial and JNI\n+  \/\/ attached thread cases where this field can have a temporary value.\n+  int64_t _lock_id;\n+\n@@ -163,0 +172,6 @@\n+  void set_lock_id(int64_t tid) {\n+    assert(tid >= ThreadIdentifier::initial() && tid < ThreadIdentifier::current(), \"invalid tid\");\n+    _lock_id = tid;\n+  }\n+  int64_t lock_id() const { return _lock_id; }\n+\n@@ -316,0 +331,2 @@\n+  bool                  _on_monitor_waited_event;        \/\/ Avoid callee arg processing for enterSpecial when posting waited event\n+  ObjectMonitor*        _contended_entered_monitor;      \/\/ Monitor for pending monitor_contended_entered callback\n@@ -457,2 +474,2 @@\n-  intptr_t* _cont_fastpath; \/\/ the sp of the oldest known interpreted\/call_stub frame inside the\n-                            \/\/ continuation that we know about\n+  intptr_t* _cont_fastpath; \/\/ the sp of the oldest known interpreted\/call_stub\/upcall_stub\/native_wrapper\n+                            \/\/ frame inside the continuation that we know about\n@@ -466,0 +483,22 @@\n+  \/\/ This is the field we poke in the interpreter and native\n+  \/\/ wrapper (Object.wait) to check for preemption.\n+  address _preempt_alternate_return;\n+  \/\/ When preempting on monitorenter we could have acquired the\n+  \/\/ monitor after freezing all vthread frames. In that case we\n+  \/\/ set this field so that in the preempt stub we call thaw again\n+  \/\/ instead of unmounting.\n+  bool _preemption_cancelled;\n+  \/\/ For Object.wait() we set this field to know if we need to\n+  \/\/ throw IE at the end of thawing before returning to Java.\n+  bool _pending_interrupted_exception;\n+\n+ public:\n+  bool preemption_cancelled()           { return _preemption_cancelled; }\n+  void set_preemption_cancelled(bool b) { _preemption_cancelled = b; }\n+\n+  bool pending_interrupted_exception()           { return _pending_interrupted_exception; }\n+  void set_pending_interrupted_exception(bool b) { _pending_interrupted_exception = b; }\n+\n+  bool preempting()           { return _preempt_alternate_return != nullptr; }\n+  void set_preempt_alternate_return(address val) { _preempt_alternate_return = val; }\n+\n@@ -630,1 +669,1 @@\n-  void clear_jni_monitor_count() { _jni_monitor_count = 0;   }\n+  void clear_jni_monitor_count() { _jni_monitor_count = 0; }\n@@ -685,0 +724,5 @@\n+  bool on_monitor_waited_event()             { return _on_monitor_waited_event; }\n+  void set_on_monitor_waited_event(bool val) { _on_monitor_waited_event = val; }\n+\n+  bool pending_contended_entered_event()         { return _contended_entered_monitor != nullptr; }\n+  ObjectMonitor* contended_entered_monitor()     { return _contended_entered_monitor; }\n@@ -691,0 +735,2 @@\n+  void set_contended_entered_monitor(ObjectMonitor* val) NOT_JVMTI_RETURN JVMTI_ONLY({ _contended_entered_monitor = val; })\n+\n@@ -841,0 +887,2 @@\n+  static ByteSize lock_id_offset()            { return byte_offset_of(JavaThread, _lock_id); }\n+\n@@ -845,0 +893,2 @@\n+  static ByteSize preemption_cancelled_offset()  { return byte_offset_of(JavaThread, _preemption_cancelled); }\n+  static ByteSize preempt_alternate_return_offset() { return byte_offset_of(JavaThread, _preempt_alternate_return); }\n@@ -1164,0 +1214,4 @@\n+  \/\/ Track executing class initializer, see ThreadInClassInitializer\n+  void set_class_being_initialized(InstanceKlass* k);\n+  InstanceKlass* class_being_initialized() const;\n+\n@@ -1166,0 +1220,1 @@\n+  InstanceKlass* _class_being_initialized;\n@@ -1169,0 +1224,7 @@\n+\n+#if INCLUDE_JFR\n+  \/\/ Support for jdk.VirtualThreadPinned event\n+  freeze_result _last_freeze_fail_result;\n+  Ticks _last_freeze_fail_time;\n+#endif\n+\n@@ -1178,0 +1240,9 @@\n+#if INCLUDE_JFR\n+  \/\/ Support for jdk.VirtualThreadPinned event\n+  freeze_result last_freeze_fail_result() { return _last_freeze_fail_result; }\n+  Ticks& last_freeze_fail_time() { return _last_freeze_fail_time; }\n+  void set_last_freeze_fail_result(freeze_result result);\n+#endif\n+  void post_vthread_pinned_event(EventVirtualThreadPinned* event, const char* op, freeze_result result) NOT_JFR_RETURN();\n+\n+\n@@ -1265,0 +1336,32 @@\n+class NoPreemptMark {\n+  ContinuationEntry* _ce;\n+  bool _unpin;\n+ public:\n+  NoPreemptMark(JavaThread* thread) : _ce(thread->last_continuation()), _unpin(false) {\n+    if (_ce != nullptr) _unpin = _ce->pin();\n+  }\n+  ~NoPreemptMark() { if (_unpin) _ce->unpin(); }\n+};\n+\n+class ThreadOnMonitorWaitedEvent {\n+  JavaThread* _thread;\n+ public:\n+  ThreadOnMonitorWaitedEvent(JavaThread* thread) : _thread(thread) {\n+    JVMTI_ONLY(_thread->set_on_monitor_waited_event(true);)\n+  }\n+  ~ThreadOnMonitorWaitedEvent() { JVMTI_ONLY(_thread->set_on_monitor_waited_event(false);) }\n+};\n+\n+class ThreadInClassInitializer : public StackObj {\n+  JavaThread* _thread;\n+  InstanceKlass* _previous;\n+ public:\n+  ThreadInClassInitializer(JavaThread* thread, InstanceKlass* ik) : _thread(thread) {\n+    _previous = _thread->class_being_initialized();\n+    _thread->set_class_being_initialized(ik);\n+  }\n+  ~ThreadInClassInitializer() {\n+    _thread->set_class_being_initialized(_previous);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":107,"deletions":4,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1086,0 +1086,20 @@\n+void os::print_tos_pc(outputStream* st, const void* context) {\n+  if (context == nullptr) return;\n+\n+  \/\/ First of all, carefully determine sp without inspecting memory near pc.\n+  \/\/ See comment below.\n+  intptr_t* sp = nullptr;\n+  fetch_frame_from_context(context, &sp, nullptr);\n+  print_tos(st, (address)sp);\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  \/\/ This version of fetch_frame_from_context finds the caller pc if the actual\n+  \/\/ one is bad.\n+  address pc = fetch_frame_from_context(context).pc();\n+  print_instructions(st, pc);\n+  st->cr();\n+}\n+\n@@ -2169,1 +2189,1 @@\n-    NmtVirtualMemoryLocker ml;\n+    ThreadCritical tc;\n@@ -2191,1 +2211,1 @@\n-    NmtVirtualMemoryLocker ml;\n+    ThreadCritical tc;\n@@ -2283,1 +2303,1 @@\n-    NmtVirtualMemoryLocker ml;\n+    ThreadCritical tc;\n@@ -2322,1 +2342,1 @@\n-    NmtVirtualMemoryLocker ml;\n+    ThreadCritical tc;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -896,4 +896,0 @@\n-  \/\/ JNI names\n-  static void     print_jni_name_prefix_on(outputStream* st, int args_size);\n-  static void     print_jni_name_suffix_on(outputStream* st, int args_size);\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,2 +170,4 @@\n-  JFR_ONLY(assert(JFR_JVM_THREAD_ID(thread) == static_cast<traceid>(java_lang_Thread::thread_id(thread_oop())),\n-             \"initial tid mismatch\");)\n+  DEBUG_ONLY(int64_t main_thread_tid = java_lang_Thread::thread_id(thread_oop());)\n+  assert(main_thread_tid == ThreadIdentifier::initial(), \"\");\n+  assert(main_thread_tid == thread->lock_id(), \"\");\n+  JFR_ONLY(assert(JFR_JVM_THREAD_ID(thread) == static_cast<traceid>(main_thread_tid), \"initial tid mismatch\");)\n@@ -565,0 +567,4 @@\n+  \/\/ Set the lock_id now since we will run Java code before the Thread instance\n+  \/\/ is even created. The same value will be assigned to the Thread instance on init.\n+  main_thread->set_lock_id(ThreadIdentifier::next());\n+\n@@ -616,0 +622,2 @@\n+  ObjectMonitor::Initialize2();\n+\n@@ -1261,10 +1269,2 @@\n-JavaThread *Threads::owning_thread_from_monitor_owner(ThreadsList * t_list,\n-                                                      address owner) {\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Not with new lightweight locking\");\n-  \/\/ null owner means not locked so we can skip the search\n-  if (owner == nullptr) return nullptr;\n-\n-  for (JavaThread* p : *t_list) {\n-    \/\/ first, see if owner is the address of a Java thread\n-    if (owner == (address)p) return p;\n-  }\n+JavaThread *Threads::owning_thread_from_stacklock(ThreadsList * t_list, address basicLock) {\n+  assert(LockingMode == LM_LEGACY, \"Not with new lightweight locking\");\n@@ -1272,9 +1272,0 @@\n-  \/\/ Cannot assert on lack of success here since this function may be\n-  \/\/ used by code that is trying to report useful problem information\n-  \/\/ like deadlock detection.\n-  if (LockingMode == LM_MONITOR) return nullptr;\n-\n-  \/\/ If we didn't find a matching Java thread and we didn't force use of\n-  \/\/ heavyweight monitors, then the owner is the stack address of the\n-  \/\/ Lock Word in the owning Java thread's stack.\n-  \/\/\n@@ -1283,1 +1274,1 @@\n-    if (q->is_lock_owned(owner)) {\n+    if (q->is_lock_owned(basicLock)) {\n@@ -1288,2 +1279,0 @@\n-\n-  \/\/ cannot assert on lack of success here; see above comment\n@@ -1310,2 +1299,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    if (monitor->is_owner_anonymous()) {\n+  if (monitor->has_anonymous_owner()) {\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n@@ -1314,3 +1303,2 @@\n-      Thread* owner = reinterpret_cast<Thread*>(monitor->owner());\n-      assert(owner == nullptr || owner->is_Java_thread(), \"only JavaThreads own monitors\");\n-      return reinterpret_cast<JavaThread*>(owner);\n+      assert(LockingMode == LM_LEGACY, \"invariant\");\n+      return owning_thread_from_stacklock(t_list, (address)monitor->stack_locker());\n@@ -1319,2 +1307,8 @@\n-    address owner = (address)monitor->owner();\n-    return owning_thread_from_monitor_owner(t_list, owner);\n+    JavaThread* the_owner = nullptr;\n+    for (JavaThread* q : *t_list) {\n+      if (monitor->has_owner(q)) {\n+        the_owner = q;\n+        break;\n+      }\n+    }\n+    return the_owner;\n@@ -1372,11 +1366,4 @@\n-        const oop thread_oop = p->threadObj();\n-        if (thread_oop != nullptr) {\n-          if (p->is_vthread_mounted()) {\n-            const oop vt = p->vthread();\n-            assert(vt != nullptr, \"vthread should not be null when vthread is mounted\");\n-            \/\/ JavaThread._vthread can refer to the carrier thread. Print only if _vthread refers to a virtual thread.\n-            if (vt != thread_oop) {\n-              st->print_cr(\"   Mounted virtual thread #\" INT64_FORMAT, (int64_t)java_lang_Thread::thread_id(vt));\n-              p->print_vthread_stack_on(st);\n-            }\n-          }\n+        if (p->is_vthread_mounted()) {\n+          \/\/ _lock_id is the thread ID of the mounted virtual thread\n+          st->print_cr(\"   Mounted virtual thread #\" INT64_FORMAT, p->lock_id());\n+          p->print_vthread_stack_on(st);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":29,"deletions":42,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -139,3 +139,2 @@\n-  \/\/ Get owning Java thread from the monitor's owner field.\n-  static JavaThread *owning_thread_from_monitor_owner(ThreadsList * t_list,\n-                                                      address owner);\n+  \/\/ Get owning Java thread from the basicLock address.\n+  static JavaThread *owning_thread_from_stacklock(ThreadsList * t_list, address basicLock);\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-  template(RendezvousGCThreads)\n+  template(RendezvousGCThreads)                   \\\n+  template(ReinitializeMDO)\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -668,0 +668,1 @@\n+  nonstatic_field(JavaThread,                  _lock_id,                                      int64_t)                               \\\n@@ -788,1 +789,2 @@\n-  unchecked_nonstatic_field(ObjectMonitor,     _owner,                                        sizeof(void *)) \/* NOTE: no type *\/    \\\n+  volatile_nonstatic_field(ObjectMonitor,      _owner,                                        int64_t)                               \\\n+  volatile_nonstatic_field(ObjectMonitor,      _stack_locker,                                 BasicLock*)                            \\\n@@ -2007,2 +2009,0 @@\n-  declare_constant(LogKlassAlignmentInBytes)                              \\\n-                                                                          \\\n@@ -2514,0 +2514,1 @@\n+  LP64_ONLY(declare_constant(markWord::klass_shift))                      \\\n@@ -2537,0 +2538,1 @@\n+  declare_constant(ObjectMonitor::NO_OWNER)                               \\\n@@ -2538,0 +2540,1 @@\n+  declare_constant(ObjectMonitor::DEFLATER_MARKER)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import jdk.internal.misc.Blocker;\n@@ -205,6 +204,9 @@\n-        try {\n-            begin(blocking);\n-            do {\n-                long startTime = timedPoll ? System.nanoTime() : 0;\n-                boolean attempted = Blocker.begin(blocking);\n-                try {\n+        if (Thread.currentThread().isVirtual()) {\n+            numEntries = (timedPoll)\n+                    ? timedPoll(TimeUnit.MILLISECONDS.toNanos(to))\n+                    : untimedPoll(blocking);\n+        } else {\n+            try {\n+                begin(blocking);\n+                do {\n+                    long startTime = timedPoll ? System.nanoTime() : 0;\n@@ -214,10 +216,8 @@\n-                } finally {\n-                    Blocker.end(attempted);\n-                }\n-                if (numEntries == IOStatus.INTERRUPTED && timedPoll) {\n-                    \/\/ timed poll interrupted so need to adjust timeout\n-                    long adjust = System.nanoTime() - startTime;\n-                    to -= (int) TimeUnit.NANOSECONDS.toMillis(adjust);\n-                    if (to <= 0) {\n-                        \/\/ timeout expired so no retry\n-                        numEntries = 0;\n+                    if (numEntries == IOStatus.INTERRUPTED && timedPoll) {\n+                        \/\/ timed poll interrupted so need to adjust timeout\n+                        long adjust = System.nanoTime() - startTime;\n+                        to -= (int) TimeUnit.NANOSECONDS.toMillis(adjust);\n+                        if (to <= 0) {\n+                            \/\/ timeout expired so no retry\n+                            numEntries = 0;\n+                        }\n@@ -226,6 +226,4 @@\n-                }\n-            } while (numEntries == IOStatus.INTERRUPTED);\n-            assert IOStatus.check(numEntries);\n-\n-        } finally {\n-            end(blocking);\n+                } while (numEntries == IOStatus.INTERRUPTED);\n+            } finally {\n+                end(blocking);\n+            }\n@@ -233,0 +231,2 @@\n+        assert IOStatus.check(numEntries);\n+\n@@ -237,0 +237,34 @@\n+    \/**\n+     * If blocking, parks the current virtual thread until a file descriptor is polled\n+     * or the thread is interrupted.\n+     *\/\n+    private int untimedPoll(boolean block) throws IOException {\n+        int numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, 0);\n+        if (block) {\n+            while (numEntries == 0 && !Thread.currentThread().isInterrupted()) {\n+                Poller.pollSelector(epfd, 0);\n+                numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, 0);\n+            }\n+        }\n+        return numEntries;\n+    }\n+\n+    \/**\n+     * Parks the current virtual thread until a file descriptor is polled, or the thread\n+     * is interrupted, for up to the specified waiting time.\n+     *\/\n+    private int timedPoll(long nanos) throws IOException {\n+        long startNanos = System.nanoTime();\n+        int numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, 0);\n+        while (numEntries == 0 && !Thread.currentThread().isInterrupted()) {\n+            long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+            if (remainingNanos <= 0) {\n+                \/\/ timeout\n+                break;\n+            }\n+            Poller.pollSelector(epfd, remainingNanos);\n+            numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, 0);\n+        }\n+        return numEntries;\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":57,"deletions":23,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -105,5 +105,0 @@\n-     * First, if there is a security\n-     * manager, its {@code checkRead} method\n-     * is called with the {@code name} argument\n-     * as its argument.\n-     * <p>\n@@ -119,4 +114,0 @@\n-     * @throws     SecurityException      if a security manager exists and its\n-     *             {@code checkRead} method denies read access\n-     *             to the file.\n-     * @see        java.lang.SecurityManager#checkRead(java.lang.String)\n@@ -136,5 +127,0 @@\n-     * First, if there is a security manager,\n-     * its {@code checkRead} method  is called\n-     * with the path represented by the {@code file}\n-     * argument as its argument.\n-     * <p>\n@@ -150,3 +136,0 @@\n-     * @throws     SecurityException      if a security manager exists and its\n-     *             {@code checkRead} method denies read access to the file.\n-     * @see        java.lang.SecurityManager#checkRead(java.lang.String)\n@@ -181,5 +164,0 @@\n-     * If there is a security manager, its {@code checkRead} method is\n-     * called with the file descriptor {@code fdObj} as its argument to\n-     * see if it's ok to read the file descriptor. If read access is denied\n-     * to the file descriptor a {@code SecurityException} is thrown.\n-     * <p>\n@@ -195,4 +173,0 @@\n-     * @throws     SecurityException      if a security manager exists and its\n-     *             {@code checkRead} method denies read access to the\n-     *             file descriptor.\n-     * @see        SecurityManager#checkRead(java.io.FileDescriptor)\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -125,3 +125,0 @@\n-     * First, if there is a security manager, its {@code checkWrite}\n-     * method is called with {@code name} as its argument.\n-     * <p>\n@@ -140,4 +137,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *               {@code checkWrite} method denies write access\n-     *               to the file.\n-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)\n@@ -159,3 +152,0 @@\n-     * First, if there is a security manager, its {@code checkWrite}\n-     * method is called with {@code name} as its argument.\n-     * <p>\n@@ -172,4 +162,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *               {@code checkWrite} method denies write access\n-     *               to the file.\n-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)\n@@ -193,4 +179,0 @@\n-     * First, if there is a security manager, its {@code checkWrite}\n-     * method is called with the path represented by the {@code file}\n-     * argument as its argument.\n-     * <p>\n@@ -205,5 +187,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *               {@code checkWrite} method denies write access\n-     *               to the file.\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)\n@@ -227,4 +204,0 @@\n-     * First, if there is a security manager, its {@code checkWrite}\n-     * method is called with the path represented by the {@code file}\n-     * argument as its argument.\n-     * <p>\n@@ -241,5 +214,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *               {@code checkWrite} method denies write access\n-     *               to the file.\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)\n@@ -283,4 +251,0 @@\n-     * First, if there is a security manager, its {@code checkWrite}\n-     * method is called with the file descriptor {@code fdObj}\n-     * argument as its argument.\n-     * <p>\n@@ -296,4 +260,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *               {@code checkWrite} method denies\n-     *               write access to the file descriptor\n-     * @see        java.lang.SecurityManager#checkWrite(java.io.FileDescriptor)\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -151,9 +151,0 @@\n-     * <p>\n-     * If there is a security manager, its {@code checkRead} method\n-     * is called with the {@code pathname} argument\n-     * as its argument to see if read access to the file is allowed.\n-     * If the mode allows writing, the security manager's\n-     * {@code checkWrite} method\n-     * is also called with the {@code pathname} argument\n-     * as its argument to see if write access to the file is allowed.\n-     *\n@@ -172,7 +163,0 @@\n-     * @throws     SecurityException   if a security manager exists and its\n-     *             {@code checkRead} method denies read access to the file\n-     *             or the mode is {@code \"rw\"} and the security manager's\n-     *             {@code checkWrite} method denies write access to the file\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkRead(java.lang.String)\n-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)\n@@ -242,7 +226,0 @@\n-     * <p>If there is a security manager, its {@code checkRead} method is\n-     * called with the pathname of the {@code file} argument as its\n-     * argument to see if read access to the file is allowed.  If the mode\n-     * allows writing, the security manager's {@code checkWrite} method is\n-     * also called with the pathname of the {@code file} argument to see if\n-     * write access to the file is allowed.\n-     *\n@@ -262,6 +239,0 @@\n-     * @throws      SecurityException  if a security manager exists and its\n-     *             {@code checkRead} method denies read access to the file\n-     *             or the mode is {@code \"rw\"} and the security manager's\n-     *             {@code checkWrite} method denies write access to the file\n-     * @see        java.lang.SecurityManager#checkRead(java.lang.String)\n-     * @see        java.lang.SecurityManager#checkWrite(java.lang.String)\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -763,2 +763,1 @@\n-     * {@link ProcessHandle#of(long) ProcessHandle.of(pid)} including the\n-     * check for a SecurityManager and {@code RuntimePermission(\"manageProcess\")}.\n+     * {@link ProcessHandle#of(long) ProcessHandle.of(pid)}.\n@@ -776,2 +775,0 @@\n-     * @throws SecurityException if a security manager has been installed and\n-     *         it denies RuntimePermission(\"manageProcess\")\n@@ -821,2 +818,0 @@\n-     * @throws SecurityException if a security manager has been installed and\n-     *         it denies RuntimePermission(\"manageProcess\")\n@@ -847,2 +842,0 @@\n-     * @throws SecurityException if a security manager has been installed and\n-     *         it denies RuntimePermission(\"manageProcess\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -340,6 +340,0 @@\n-     * <p>If a security manager exists, its\n-     * {@link SecurityManager#checkPermission checkPermission} method\n-     * is called with a\n-     * {@link RuntimePermission}{@code (\"getenv.*\")} permission.\n-     * This may result in a {@link SecurityException} being thrown.\n-     *\n@@ -352,5 +346,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and its\n-     *         {@link SecurityManager#checkPermission checkPermission}\n-     *         method doesn't allow access to the process environment\n-     *\n@@ -361,5 +350,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null)\n-            security.checkPermission(new RuntimePermission(\"getenv.*\"));\n-\n@@ -1022,6 +1006,0 @@\n-     * <p>If there is a security manager, its\n-     * {@link SecurityManager#checkExec checkExec}\n-     * method is called with the first component of this object's\n-     * {@code command} array as its argument. This may result in\n-     * a {@link SecurityException} being thrown.\n-     *\n@@ -1055,23 +1033,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and\n-     *         <ul>\n-     *\n-     *         <li>its\n-     *         {@link SecurityManager#checkExec checkExec}\n-     *         method doesn't allow creation of the subprocess, or\n-     *\n-     *         <li>the standard input to the subprocess was\n-     *         {@linkplain #redirectInput redirected from a file}\n-     *         and the security manager's\n-     *         {@link SecurityManager#checkRead(String) checkRead} method\n-     *         denies read access to the file, or\n-     *\n-     *         <li>the standard output or standard error of the\n-     *         subprocess was\n-     *         {@linkplain #redirectOutput redirected to a file}\n-     *         and the security manager's\n-     *         {@link SecurityManager#checkWrite(String) checkWrite} method\n-     *         denies write access to the file\n-     *\n-     *         <\/ul>\n-     *\n@@ -1122,5 +1077,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null)\n-            security.checkExec(prog);\n-\n@@ -1165,11 +1115,0 @@\n-            String exceptionInfo = \": \" + e.getMessage();\n-            Throwable cause = e;\n-            if ((e instanceof IOException) && security != null) {\n-                \/\/ Can not disclose the fail reason for read-protected files.\n-                try {\n-                    security.checkRead(prog);\n-                } catch (SecurityException se) {\n-                    exceptionInfo = \"\";\n-                    cause = se;\n-                }\n-            }\n@@ -1181,2 +1120,2 @@\n-                + exceptionInfo,\n-                cause);\n+                + \": \" + e.getMessage(),\n+                e);\n@@ -1229,6 +1168,0 @@\n-     * If there is a security manager, its\n-     * {@link SecurityManager#checkExec checkExec}\n-     * method is called with the first component of each process builder's\n-     * {@code command} array as its argument. This may result in\n-     * a {@link SecurityException} being thrown.\n-     * <p>\n@@ -1285,18 +1218,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and\n-     *         <ul>\n-     *         <li>its\n-     *         {@link SecurityManager#checkExec checkExec}\n-     *         method doesn't allow creation of the subprocess, or\n-     *         <li>the standard input to the subprocess was\n-     *         {@linkplain #redirectInput redirected from a file}\n-     *         and the security manager's\n-     *         {@link SecurityManager#checkRead(String) checkRead} method\n-     *         denies read access to the file, or\n-     *         <li>the standard output or standard error of the\n-     *         subprocess was\n-     *         {@linkplain #redirectOutput redirected to a file}\n-     *         and the security manager's\n-     *         {@link SecurityManager#checkWrite(String) checkWrite} method\n-     *         denies write access to the file\n-     *         <\/ul>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":3,"deletions":88,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-import java.lang.invoke.StringConcatFactory;\n-import java.lang.reflect.Constructor;\n@@ -46,1 +44,0 @@\n-import java.lang.reflect.Modifier;\n@@ -53,1 +50,0 @@\n-import java.security.AccessControlContext;\n@@ -78,1 +74,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -97,1 +92,0 @@\n-import sun.nio.fs.DefaultFileSystemProvider;\n@@ -196,9 +190,0 @@\n-    \/\/ indicates if a security manager is possible\n-    private static final int NEVER = 1;\n-    private static final int MAYBE = 2;\n-    private static @Stable int allowSecurityManager;\n-\n-    \/\/ current security manager\n-    @SuppressWarnings(\"removal\")\n-    private static volatile SecurityManager security;   \/\/ read by VM\n-\n@@ -210,5 +195,0 @@\n-    \/\/ return true if a security manager is allowed\n-    private static boolean allowSecurityManager() {\n-        return (allowSecurityManager != NEVER);\n-    }\n-\n@@ -218,4 +198,0 @@\n-     * First, if there is a security manager, its {@code checkPermission}\n-     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n-     *  to see if it's ok to reassign the \"standard\" input stream.\n-     *\n@@ -224,8 +200,0 @@\n-     * @throws SecurityException\n-     *        if a security manager exists and its\n-     *        {@code checkPermission} method doesn't allow\n-     *        reassigning of the standard input stream.\n-     *\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n-     *\n@@ -242,4 +210,0 @@\n-     * First, if there is a security manager, its {@code checkPermission}\n-     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n-     *  to see if it's ok to reassign the \"standard\" output stream.\n-     *\n@@ -248,8 +212,0 @@\n-     * @throws SecurityException\n-     *        if a security manager exists and its\n-     *        {@code checkPermission} method doesn't allow\n-     *        reassigning of the standard output stream.\n-     *\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n-     *\n@@ -266,4 +222,0 @@\n-     * First, if there is a security manager, its {@code checkPermission}\n-     * method is called with a {@code RuntimePermission(\"setIO\")} permission\n-     *  to see if it's ok to reassign the \"standard\" error output stream.\n-     *\n@@ -272,8 +224,0 @@\n-     * @throws SecurityException\n-     *        if a security manager exists and its\n-     *        {@code checkPermission} method doesn't allow\n-     *        reassigning of the standard error output stream.\n-     *\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n-     *\n@@ -328,4 +272,0 @@\n-     * @throws  SecurityException\n-     *          If a security manager is present and it does not\n-     *          permit access to the channel.\n-     *\n@@ -365,28 +305,5 @@\n-     * Sets the system-wide security manager.\n-     *\n-     * If there is a security manager already installed, this method first\n-     * calls the security manager's {@code checkPermission} method\n-     * with a {@code RuntimePermission(\"setSecurityManager\")}\n-     * permission to ensure it's ok to replace the existing\n-     * security manager.\n-     * This may result in throwing a {@code SecurityException}.\n-     *\n-     * <p> Otherwise, the argument is established as the current\n-     * security manager. If the argument is {@code null} and no\n-     * security manager has been established, then no action is taken and\n-     * the method simply returns.\n-     *\n-     * @implNote In the JDK implementation, if the Java virtual machine is\n-     * started with the system property {@code java.security.manager} not set or set to\n-     * the special token \"{@code disallow}\" then the {@code setSecurityManager}\n-     * method cannot be used to set a security manager. See the following\n-     * <a href=\"SecurityManager.html#set-security-manager\">section of the\n-     * {@code SecurityManager} class specification<\/a> for more details.\n-     *\n-     * @param  sm the security manager or {@code null}\n-     * @throws SecurityException\n-     *         if the security manager has already been set and its {@code\n-     *         checkPermission} method doesn't allow it to be replaced\n-     * @throws UnsupportedOperationException\n-     *         if {@code sm} is non-null and a security manager is not allowed\n-     *         to be set dynamically\n+     * Throws {@code UnsupportedOperationException}. Setting a security manager\n+     * is not supported.\n+     *\n+     * @param  sm ignored\n+     * @throws UnsupportedOperationException always\n@@ -394,8 +311,4 @@\n-     * @see SecurityManager#checkPermission\n-     * @see java.lang.RuntimePermission\n-     * @deprecated This method is only useful in conjunction with\n-     *       {@linkplain SecurityManager the Security Manager}, which is\n-     *       deprecated and subject to removal in a future release.\n-     *       Consequently, this method is also deprecated and subject to\n-     *       removal. There is no replacement for the Security Manager or this\n-     *       method.\n+     * @deprecated This method originally set\n+     *       {@linkplain SecurityManager the system-wide Security Manager}.\n+     *       Setting a Security Manager is no longer supported. There is no\n+     *       replacement for the Security Manager or this method.\n@@ -404,77 +317,2 @@\n-    @CallerSensitive\n-        if (allowSecurityManager()) {\n-            var callerClass = Reflection.getCallerClass();\n-            if (CallersHolder.callers.putIfAbsent(callerClass, true) == null) {\n-                URL url = codeSource(callerClass);\n-                final String source;\n-                if (url == null) {\n-                    source = callerClass.getName();\n-                } else {\n-                    source = callerClass.getName() + \" (\" + url + \")\";\n-                }\n-                initialErr.printf(\"\"\"\n-                        WARNING: A terminally deprecated method in java.lang.System has been called\n-                        WARNING: System::setSecurityManager has been called by %s\n-                        WARNING: Please consider reporting this to the maintainers of %s\n-                        WARNING: System::setSecurityManager will be removed in a future release\n-                        \"\"\", source, callerClass.getName());\n-            }\n-            implSetSecurityManager(sm);\n-        } else {\n-            \/\/ security manager not allowed\n-            if (sm != null) {\n-                throw new UnsupportedOperationException(\n-                    \"The Security Manager is deprecated and will be removed in a future release\");\n-            }\n-        }\n-    }\n-\n-    private static void implSetSecurityManager(@SuppressWarnings(\"removal\") SecurityManager sm) {\n-        if (security == null) {\n-            \/\/ ensure image reader is initialized\n-            Object.class.getResource(\"java\/lang\/ANY\");\n-            \/\/ ensure the default file system is initialized\n-            DefaultFileSystemProvider.theFileSystem();\n-        }\n-        if (sm != null) {\n-            try {\n-                \/\/ pre-populates the SecurityManager.packageAccess cache\n-                \/\/ to avoid recursive permission checking issues with custom\n-                \/\/ SecurityManager implementations\n-                sm.checkPackageAccess(\"java.lang\");\n-            } catch (Exception e) {\n-                \/\/ no-op\n-            }\n-        }\n-        setSecurityManager0(sm);\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static synchronized\n-    void setSecurityManager0(final SecurityManager s) {\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            \/\/ ask the currently installed security manager if we\n-            \/\/ can replace it.\n-            sm.checkPermission(new RuntimePermission(\"setSecurityManager\"));\n-        }\n-\n-        if ((s != null) && (s.getClass().getClassLoader() != null)) {\n-            \/\/ New security manager class is not on bootstrap classpath.\n-            \/\/ Force policy to get initialized before we install the new\n-            \/\/ security manager, in order to prevent infinite loops when\n-            \/\/ trying to initialize the policy (which usually involves\n-            \/\/ accessing some security and\/or system properties, which in turn\n-            \/\/ calls the installed security manager's checkPermission method\n-            \/\/ which will loop infinitely if there is a non-system class\n-            \/\/ (in this case: the new security manager class) on the stack).\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Object run() {\n-                    s.getClass().getProtectionDomain().implies\n-                        (SecurityConstants.ALL_PERMISSION);\n-                    return null;\n-                }\n-            });\n-        }\n-\n-        security = s;\n+        throw new UnsupportedOperationException(\n+                 \"Setting a Security Manager is not supported\");\n@@ -485,1 +323,1 @@\n-     * Gets the system-wide security manager.\n+     * Returns {@code null}. Setting a security manager is not supported.\n@@ -487,3 +325,1 @@\n-     * @return  if a security manager has already been established for the\n-     *          current application, then that security manager is returned;\n-     *          otherwise, {@code null} is returned.\n+     * @return  {@code null}\n@@ -491,6 +327,4 @@\n-     * @deprecated This method is only useful in conjunction with\n-     *       {@linkplain SecurityManager the Security Manager}, which is\n-     *       deprecated and subject to removal in a future release.\n-     *       Consequently, this method is also deprecated and subject to\n-     *       removal. There is no replacement for the Security Manager or this\n-     *       method.\n+     * @deprecated This method originally returned\n+     *       {@linkplain SecurityManager the system-wide Security Manager}.\n+     *       Setting a Security Manager is no longer supported. There is no\n+     *       replacement for the Security Manager or this method.\n@@ -501,5 +335,1 @@\n-        if (allowSecurityManager()) {\n-            return security;\n-        } else {\n-            return null;\n-        }\n+        return null;\n@@ -698,4 +528,0 @@\n-     *\n-     * First, if there is a security manager, its\n-     * {@code checkPropertiesAccess} method is called with no\n-     * arguments. This may result in a security exception.\n@@ -816,4 +642,0 @@\n-     * Note that even if the security manager does not permit the\n-     * {@code getProperties} operation, it may choose to permit the\n-     * {@link #getProperty(String)} operation.\n-     * <p>\n@@ -869,5 +691,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertiesAccess} method doesn't allow access\n-     *             to the system properties.\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n@@ -907,4 +724,0 @@\n-     *\n-     * First, if there is a security manager, its\n-     * {@code checkPropertiesAccess} method is called with no\n-     * arguments. This may result in a security exception.\n@@ -923,3 +736,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertiesAccess} method doesn't allow access\n-     *             to the system properties.\n@@ -928,2 +738,0 @@\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n@@ -948,4 +756,0 @@\n-     *\n-     * First, if there is a security manager, its\n-     * {@code checkPropertyAccess} method is called with the key as\n-     * its argument. This may result in a SecurityException.\n@@ -969,3 +773,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertyAccess} method doesn't allow\n-     *             access to the specified system property.\n@@ -975,2 +776,0 @@\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n@@ -992,4 +791,0 @@\n-     *\n-     * First, if there is a security manager, its\n-     * {@code checkPropertyAccess} method is called with the\n-     * {@code key} as its argument.\n@@ -1009,3 +804,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertyAccess} method doesn't allow\n-     *             access to the specified system property.\n@@ -1015,1 +807,0 @@\n-     * @see        java.lang.SecurityManager#checkPropertyAccess(java.lang.String)\n@@ -1032,7 +823,0 @@\n-     * First, if a security manager exists, its\n-     * {@code SecurityManager.checkPermission} method\n-     * is called with a {@code PropertyPermission(key, \"write\")}\n-     * permission. This may result in a SecurityException being thrown.\n-     * If no exception is thrown, the specified property is set to the given\n-     * value.\n-     *\n@@ -1049,3 +833,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPermission} method doesn't allow\n-     *             setting of the specified property.\n@@ -1058,2 +839,0 @@\n-     * @see        java.util.PropertyPermission\n-     * @see        SecurityManager#checkPermission\n@@ -1077,6 +856,0 @@\n-     * First, if a security manager exists, its\n-     * {@code SecurityManager.checkPermission} method\n-     * is called with a {@code PropertyPermission(key, \"write\")}\n-     * permission. This may result in a SecurityException being thrown.\n-     * If no exception is thrown, the specified property is removed.\n-     *\n@@ -1092,3 +865,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkPropertyAccess} method doesn't allow\n-     *              access to the specified system property.\n@@ -1100,2 +870,0 @@\n-     * @see        java.lang.SecurityException\n-     * @see        java.lang.SecurityManager#checkPropertiesAccess()\n@@ -1129,8 +897,0 @@\n-     * <p>If a security manager exists, its\n-     * {@link SecurityManager#checkPermission checkPermission}\n-     * method is called with a\n-     * {@link RuntimePermission RuntimePermission(\"getenv.\"+name)}\n-     * permission.  This may result in a {@link SecurityException}\n-     * being thrown.  If no exception is thrown the value of the\n-     * variable {@code name} is returned.\n-     *\n@@ -1168,5 +928,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and its\n-     *         {@link SecurityManager#checkPermission checkPermission}\n-     *         method doesn't allow access to the environment variable\n-     *         {@code name}\n@@ -1208,6 +963,0 @@\n-     * <p>If a security manager exists, its\n-     * {@link SecurityManager#checkPermission checkPermission}\n-     * method is called with a\n-     * {@link RuntimePermission RuntimePermission(\"getenv.*\")} permission.\n-     * This may result in a {@link SecurityException} being thrown.\n-     *\n@@ -1225,4 +974,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and its\n-     *         {@link SecurityManager#checkPermission checkPermission}\n-     *         method doesn't allow access to the process environment\n@@ -1649,10 +1394,0 @@\n-     * In addition, when a security manager is present, loggers provided to\n-     * system classes should not be directly configurable through the logging\n-     * backend without requiring permissions.\n-     * <br>\n-     * It is the responsibility of the provider of\n-     * the concrete {@code LoggerFinder} implementation to ensure that\n-     * these loggers are not configured by untrusted code without proper\n-     * permission checks, as configuration performed on such loggers usually\n-     * affects all applications in the same Java Runtime.\n-     * <p>\n@@ -1691,4 +1426,0 @@\n-         *\n-         * @throws SecurityException if a security manager is present and its\n-         *         {@code checkPermission} method doesn't allow the\n-         *         {@code RuntimePermission(\"loggerFinder\")}.\n@@ -1724,3 +1455,0 @@\n-         * @throws SecurityException if a security manager is present and its\n-         *         {@code checkPermission} method doesn't allow the\n-         *         {@code RuntimePermission(\"loggerFinder\")}.\n@@ -1767,3 +1495,0 @@\n-         * @throws SecurityException if a security manager is present and its\n-         *         {@code checkPermission} method doesn't allow the\n-         *         {@code RuntimePermission(\"loggerFinder\")}.\n@@ -1784,3 +1509,0 @@\n-         * @throws SecurityException if a security manager is present and its\n-         *         {@code checkPermission} method doesn't allow the\n-         *         {@code RuntimePermission(\"loggerFinder\")}.\n@@ -1931,4 +1653,4 @@\n-     * Initiates the {@linkplain Runtime##shutdown shutdown sequence} of the Java Virtual Machine.\n-     * Unless the security manager denies exiting, this method initiates the shutdown sequence\n-     * (if it is not already initiated) and then blocks indefinitely. This method neither returns\n-     * nor throws an exception; that is, it does not complete either normally or abruptly.\n+     * Initiates the {@linkplain Runtime##shutdown shutdown sequence} of the Java Virtual\n+     * Machine. This method initiates the shutdown sequence (if it is not already initiated)\n+     * and then blocks indefinitely. This method neither returns nor throws an exception;\n+     * that is, it does not complete either normally or abruptly.\n@@ -1948,3 +1670,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and its {@code checkExit} method\n-     *         doesn't allow exit with the specified status.\n@@ -2044,3 +1763,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkLink} method doesn't allow\n-     *             loading of the specified dynamic library\n@@ -2057,1 +1773,0 @@\n-     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n@@ -2087,3 +1802,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkLink} method doesn't allow\n-     *             loading of the specified dynamic library\n@@ -2100,1 +1812,0 @@\n-     * @see        java.lang.SecurityManager#checkLink(java.lang.String)\n@@ -2369,5 +2080,2 @@\n-     * 1. eagerly initialize bootstrap method factories that might interact\n-     *    negatively with custom security managers and custom class loaders\n-     * 2. set security manager\n-     * 3. set system class loader\n-     * 4. set TCCL\n+     * 1. set system class loader\n+     * 2. set TCCL\n@@ -2376,3 +2084,0 @@\n-     * The security manager and system class loader may be a custom class from\n-     * the application classpath or modulepath.\n-    @SuppressWarnings(\"removal\")\n@@ -2382,5 +2087,0 @@\n-        \/\/ Initialize the StringConcatFactory eagerly to avoid potential\n-        \/\/ bootstrap circularity issues that could be caused by a custom\n-        \/\/ SecurityManager\n-        Unsafe.getUnsafe().ensureClassInitialized(StringConcatFactory.class);\n-\n@@ -2394,1 +2094,0 @@\n-        boolean needWarning = false;\n@@ -2398,1 +2097,0 @@\n-                    allowSecurityManager = NEVER;\n@@ -2401,2 +2099,0 @@\n-                    allowSecurityManager = MAYBE;\n-                    break;\n@@ -2405,25 +2101,2 @@\n-                    implSetSecurityManager(new SecurityManager());\n-                    allowSecurityManager = MAYBE;\n-                    needWarning = true;\n-                    break;\n-                    try {\n-                        ClassLoader cl = ClassLoader.getBuiltinAppClassLoader();\n-                        Class<?> c = Class.forName(smProp, false, cl);\n-                        Constructor<?> ctor = c.getConstructor();\n-                        \/\/ Must be a public subclass of SecurityManager with\n-                        \/\/ a public no-arg constructor\n-                        if (!SecurityManager.class.isAssignableFrom(c) ||\n-                            !Modifier.isPublic(c.getModifiers()) ||\n-                            !Modifier.isPublic(ctor.getModifiers())) {\n-                            throw new Error(\"Could not create SecurityManager: \"\n-                                             + ctor.toString());\n-                        }\n-                        \/\/ custom security manager may be in non-exported package\n-                        ctor.setAccessible(true);\n-                        SecurityManager sm = (SecurityManager) ctor.newInstance();\n-                        implSetSecurityManager(sm);\n-                        needWarning = true;\n-                    } catch (Exception e) {\n-                        throw new InternalError(\"Could not create SecurityManager\", e);\n-                    }\n-                    allowSecurityManager = MAYBE;\n+                    throw new Error(\"A command line option has attempted to allow or enable the Security Manager.\"\n+                            + \" Enabling a Security Manager is not supported.\");\n@@ -2432,8 +2105,0 @@\n-        } else {\n-            allowSecurityManager = NEVER;\n-        }\n-\n-        if (needWarning) {\n-            System.err.println(\"\"\"\n-                    WARNING: A command line option has enabled the Security Manager\n-                    WARNING: The Security Manager is deprecated and will be removed in a future release\"\"\");\n@@ -2503,3 +2168,0 @@\n-            public Thread newThreadWithAcc(Runnable target, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n-                return new Thread(target, acc);\n-            }\n@@ -2526,8 +2188,0 @@\n-            @SuppressWarnings(\"removal\")\n-            public void addNonExportedPackages(ModuleLayer layer) {\n-                SecurityManager.addNonExportedPackages(layer);\n-            }\n-            @SuppressWarnings(\"removal\")\n-            public void invalidatePackageAccessCache() {\n-                SecurityManager.invalidatePackageAccessCache();\n-            }\n@@ -2826,5 +2480,0 @@\n-\n-            @Override\n-            public boolean allowSecurityManager() {\n-                return System.allowSecurityManager();\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":26,"deletions":377,"binary":false,"changes":403,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,3 +167,0 @@\n-     * The thread has no permissions, enforced only if a\n-     * {@linkplain java.lang.System#setSecurityManager(SecurityManager)\n-     * {@code SecurityManager} is set}.\n@@ -175,3 +172,0 @@\n-     *\n-     * @throws  SecurityException  if the current thread is not allowed to\n-     *               create or start the thread.\n@@ -203,2 +197,0 @@\n-     * @throws  SecurityException  if the current thread is not allowed to\n-     *               create or start the thread.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -347,5 +347,0 @@\n-\n-            @Override\n-            public <T> ReferenceQueue<T> newNativeReferenceQueue() {\n-                return new NativeReferenceQueue<T>();\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.Condition;\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -33,0 +30,2 @@\n+import jdk.internal.vm.Continuation;\n+import jdk.internal.vm.ContinuationSupport;\n@@ -53,2 +52,0 @@\n-        public Null() { super(0); }\n-\n@@ -67,14 +64,2 @@\n-    private final ReentrantLock lock;\n-    private final Condition notEmpty;\n-\n-    void signal() {\n-        notEmpty.signalAll();\n-    }\n-\n-    void await() throws InterruptedException {\n-        notEmpty.await();\n-    }\n-\n-    void await(long timeoutMillis) throws InterruptedException {\n-        notEmpty.await(timeoutMillis, TimeUnit.MILLISECONDS);\n-    }\n+    private static class Lock { };\n+    private final Lock lock = new Lock();\n@@ -86,7 +71,0 @@\n-        this.lock = new ReentrantLock();\n-        this.notEmpty = lock.newCondition();\n-    }\n-\n-    ReferenceQueue(int dummy) {\n-        this.lock = null;\n-        this.notEmpty = null;\n@@ -95,1 +73,1 @@\n-    final boolean enqueue0(Reference<? extends T> r) { \/\/ must hold lock\n+    private boolean enqueue0(Reference<? extends T> r) { \/\/ must hold lock\n@@ -114,1 +92,1 @@\n-        signal();\n+        lock.notifyAll();\n@@ -118,5 +96,1 @@\n-    final boolean headIsNull() {\n-        return head == null;\n-    }\n-\n-    final Reference<? extends T> poll0() { \/\/ must hold lock\n+    private Reference<? extends T> poll0() { \/\/ must hold lock\n@@ -145,2 +119,1 @@\n-    final Reference<? extends T> remove0(long timeout)\n-            throws IllegalArgumentException, InterruptedException { \/\/ must hold lock\n+    private Reference<? extends T> remove0(long timeout) throws InterruptedException { \/\/ must hold lock\n@@ -151,1 +124,1 @@\n-            await(timeout);\n+            lock.wait(timeout);\n@@ -154,1 +127,0 @@\n-\n@@ -162,1 +134,1 @@\n-    final Reference<? extends T> remove0() throws InterruptedException { \/\/ must hold lock\n+    private Reference<? extends T> remove0() throws InterruptedException { \/\/ must hold lock\n@@ -166,1 +138,1 @@\n-            await();\n+            lock.wait();\n@@ -171,2 +143,1 @@\n-        lock.lock();\n-        try {\n+        synchronized (lock) {\n@@ -174,2 +145,0 @@\n-        } finally {\n-            lock.unlock();\n@@ -179,0 +148,13 @@\n+    private boolean tryDisablePreempt() {\n+        if (Thread.currentThread().isVirtual() && ContinuationSupport.isSupported()) {\n+            Continuation.pin();\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void enablePreempt() {\n+        Continuation.unpin();\n+    }\n+\n@@ -189,1 +171,1 @@\n-        if (headIsNull())\n+        if (head == null)\n@@ -191,1 +173,4 @@\n-        lock.lock();\n+\n+        \/\/ Prevent a virtual thread from being preempted as this could potentially\n+        \/\/ deadlock with a carrier that is polling the same reference queue.\n+        boolean disabled = tryDisablePreempt();\n@@ -193,1 +178,3 @@\n-            return poll0();\n+            synchronized (lock) {\n+                return poll0();\n+            }\n@@ -195,1 +182,1 @@\n-            lock.unlock();\n+            if (disabled) enablePreempt();\n@@ -200,2 +187,1 @@\n-        lock.lock();\n-        try {\n+        synchronized (lock) {\n@@ -206,1 +192,1 @@\n-            notEmpty.await(timeout, TimeUnit.MILLISECONDS);\n+            lock.wait(timeout);\n@@ -208,2 +194,0 @@\n-        } finally {\n-            lock.unlock();\n@@ -214,5 +198,2 @@\n-        lock.lock();\n-        try {\n-            notEmpty.signalAll();\n-        } finally {\n-            lock.unlock();\n+        synchronized (lock) {\n+            lock.notifyAll();\n@@ -250,2 +231,1 @@\n-        lock.lock();\n-        try {\n+        synchronized (lock) {\n@@ -253,2 +233,0 @@\n-        } finally {\n-            lock.unlock();\n@@ -267,2 +245,1 @@\n-        lock.lock();\n-        try {\n+        synchronized (lock) {\n@@ -270,2 +247,0 @@\n-        } finally {\n-            lock.unlock();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":41,"deletions":66,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -187,6 +187,2 @@\n- * <p> By default, when a security manager is installed, in order to\n- * protect against DNS spoofing attacks,\n- * the result of positive host name resolutions are\n- * cached forever. When a security manager is not installed, the default\n- * behavior is to cache entries for a finite (implementation dependent)\n- * period of time. The result of unsuccessful host\n+ * <p> The default behavior is to cache entries for a finite (implementation\n+ * dependent) period of time. The result of unsuccessful host\n@@ -766,10 +762,1 @@\n-     * <p>If there is a security manager, its\n-     * {@code checkConnect} method is first called\n-     * with the hostname and {@code -1}\n-     * as its arguments to see if the operation is allowed.\n-     * If the operation is not allowed, it will return\n-     * the textual representation of the IP address.\n-     *\n-     * @return  the host name for this IP address, or if the operation\n-     *    is not allowed by the security check, the textual\n-     *    representation of the IP address.\n+     * @return  the host name for this IP address\n@@ -778,1 +765,0 @@\n-     * @see SecurityManager#checkConnect\n@@ -791,8 +777,0 @@\n-     * <p>If there is a security manager, this method first\n-     * calls its {@code checkConnect} method\n-     * with the hostname and {@code -1}\n-     * as its arguments to see if the calling code is allowed to know\n-     * the hostname for this IP address, i.e., to connect to the host.\n-     * If the operation is not allowed, it will return\n-     * the textual representation of the IP address.\n-     *\n@@ -804,2 +782,0 @@\n-     *\n-     * @see SecurityManager#checkConnect\n@@ -825,10 +801,1 @@\n-     * <p>If there is a security manager, this method first\n-     * calls its {@code checkConnect} method\n-     * with the hostname and {@code -1}\n-     * as its arguments to see if the calling code is allowed to know\n-     * the hostname for this IP address, i.e., to connect to the host.\n-     * If the operation is not allowed, it will return\n-     * the textual representation of the IP address.\n-     *\n-     *          If either the operation is not allowed by the security check\n-     *          or the system-wide resolver wasn't able to determine the\n+     *          If the system-wide resolver wasn't able to determine the\n@@ -839,2 +806,0 @@\n-     * @see SecurityManager#checkConnect\n-     *\n@@ -854,8 +819,0 @@\n-     * <p>If there is a security manager, this method first\n-     * calls its {@code checkConnect} method\n-     * with the hostname and {@code -1}\n-     * as its arguments to see if the calling code is allowed to know\n-     * the hostname for the given IP address, i.e., to connect to the host.\n-     * If the operation is not allowed, it will return\n-     * the textual representation of the IP address.\n-     *\n@@ -869,2 +826,0 @@\n-     *\n-     * @see SecurityManager#checkConnect\n@@ -1587,5 +1542,0 @@\n-     * <p> If there is a security manager, and {@code host} is not {@code null}\n-     * or {@code host.length() } is not equal to zero, the security manager's\n-     * {@code checkConnect} method is called with the hostname and {@code -1}\n-     * as its arguments to determine if the operation is allowed.\n-     *\n@@ -1597,2 +1547,0 @@\n-     * @throws     SecurityException if a security manager exists\n-     *             and its checkConnect method doesn't allow the operation\n@@ -1631,5 +1579,0 @@\n-     * <p> If there is a security manager, and {@code host} is not {@code null}\n-     * or {@code host.length() } is not equal to zero, the security manager's\n-     * {@code checkConnect} method is called with the hostname and {@code -1}\n-     * as its arguments to determine if the operation is allowed.\n-     *\n@@ -1642,2 +1585,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *               {@code checkConnect} method doesn't allow the operation.\n@@ -1647,1 +1588,0 @@\n-     * @see SecurityManager#checkConnect\n@@ -1904,7 +1844,0 @@\n-     * <p>If there is a security manager, its\n-     * {@code checkConnect} method is called\n-     * with the local host name and {@code -1}\n-     * as its arguments to see if the operation is allowed.\n-     * If the operation is not allowed, an InetAddress representing\n-     * the loopback address is returned.\n-     *\n@@ -1916,1 +1849,0 @@\n-     * @see SecurityManager#checkConnect\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":4,"deletions":72,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -189,4 +189,0 @@\n-     * If there is a security manager, its {@code checkConnect} method\n-     * is called with the proxy host address and port number\n-     * as its arguments. This could result in a SecurityException.\n-     * <P>\n@@ -205,3 +201,0 @@\n-     * @throws SecurityException if a security manager is present and\n-     *                           permission to connect to the proxy is\n-     *                           denied.\n@@ -267,3 +260,0 @@\n-     * @throws SecurityException if {@code impl} is non-null and a security manager is set\n-     * and its {@code checkPermission} method doesn't allow {@code NetPermission(\"setSocketImpl\")}.\n-     *\n@@ -302,5 +292,0 @@\n-     * <p>\n-     * If there is a security manager, its\n-     * {@code checkConnect} method is called\n-     * with the host address and {@code port}\n-     * as its arguments. This could result in a SecurityException.\n@@ -315,2 +300,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkConnect} method doesn't allow the operation.\n@@ -320,1 +303,0 @@\n-     * @see        SecurityManager#checkConnect\n@@ -340,5 +322,0 @@\n-     * <p>\n-     * If there is a security manager, its\n-     * {@code checkConnect} method is called\n-     * with the host address and {@code port}\n-     * as its arguments. This could result in a SecurityException.\n@@ -349,2 +326,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkConnect} method doesn't allow the operation.\n@@ -355,1 +330,0 @@\n-     * @see        SecurityManager#checkConnect\n@@ -376,5 +350,0 @@\n-     * <p>\n-     * If there is a security manager, its\n-     * {@code checkConnect} method is called\n-     * with the host address and {@code port}\n-     * as its arguments. This could result in a SecurityException.\n@@ -389,4 +358,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkConnect} method doesn't allow the connection\n-     *             to the destination, or if its {@code checkListen} method\n-     *             doesn't allow the bind to the local port.\n@@ -396,1 +361,0 @@\n-     * @see        SecurityManager#checkConnect\n@@ -418,5 +382,0 @@\n-     * <p>\n-     * If there is a security manager, its\n-     * {@code checkConnect} method is called\n-     * with the host address and {@code port}\n-     * as its arguments. This could result in a SecurityException.\n@@ -431,4 +390,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkConnect} method doesn't allow the connection\n-     *             to the destination, or if its {@code checkListen} method\n-     *             doesn't allow the bind to the local port.\n@@ -439,1 +394,0 @@\n-     * @see        SecurityManager#checkConnect\n@@ -469,5 +423,0 @@\n-     * If there is a security manager, its\n-     * {@code checkConnect} method is called\n-     * with the host address and {@code port}\n-     * as its arguments. This could result in a SecurityException.\n-     * <p>\n@@ -481,2 +430,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkConnect} method doesn't allow the operation.\n@@ -486,1 +433,0 @@\n-     * @see        SecurityManager#checkConnect\n@@ -510,5 +456,0 @@\n-     *\n-     * <p>If there is a security manager, its\n-     * {@code checkConnect} method is called\n-     * with {@code host.getHostAddress()} and {@code port}\n-     * as its arguments. This could result in a SecurityException.\n@@ -523,2 +464,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkConnect} method doesn't allow the operation.\n@@ -529,1 +468,0 @@\n-     * @see        SecurityManager#checkConnect\n@@ -787,3 +725,0 @@\n-     * @throws  SecurityException  if a security manager exists and its\n-     *          {@code checkListen} method doesn't allow the bind\n-     *          to the local port.\n@@ -852,7 +787,1 @@\n-     * <p>\n-     * If there is a security manager set, its {@code checkConnect} method is\n-     * called with the local address and {@code -1} as its arguments to see\n-     * if the operation is allowed. If the operation is not allowed,\n-     * the {@link InetAddress#getLoopbackAddress loopback} address is returned.\n-     * @return the local address to which the socket is bound,\n-     *         the loopback address if denied by the security manager, or\n+     * @return the local address to which the socket is bound, or\n@@ -862,2 +791,0 @@\n-     *\n-     * @see SecurityManager#checkConnect\n@@ -961,7 +888,0 @@\n-     * <p>\n-     * If there is a security manager set, its {@code checkConnect} method is\n-     * called with the local address and {@code -1} as its arguments to see\n-     * if the operation is allowed. If the operation is not allowed,\n-     * a {@code SocketAddress} representing the\n-     * {@link InetAddress#getLoopbackAddress loopback} address and the local\n-     * port to which this socket is bound is returned.\n@@ -970,3 +890,1 @@\n-     *         this socket, or a {@code SocketAddress} representing the\n-     *         loopback address if denied by the security manager, or\n-     *         {@code null} if the socket is not bound yet.\n+     *         this socket, or {@code null} if the socket is not bound yet.\n@@ -977,1 +895,0 @@\n-     * @see SecurityManager#checkConnect\n@@ -1919,4 +1836,0 @@\n-     * <p>If there is a security manager, this method first calls\n-     * the security manager's {@code checkSetFactory} method\n-     * to ensure the operation is allowed.\n-     * This could result in a SecurityException.\n@@ -1928,3 +1841,0 @@\n-     * @throws     SecurityException  if a security manager exists and its\n-     *             {@code checkSetFactory} method doesn't allow the operation.\n-     * @see        SecurityManager#checkSetFactory\n@@ -2022,6 +1932,0 @@\n-     * @throws SecurityException if a security manager is set and if the socket\n-     *         option requires a security permission and if the caller does\n-     *         not have the required permission.\n-     *         {@link java.net.StandardSocketOptions StandardSocketOptions}\n-     *         do not require any security permission.\n-     *\n@@ -2053,6 +1957,0 @@\n-     * @throws SecurityException if a security manager is set and if the socket\n-     *         option requires a security permission and if the caller does\n-     *         not have the required permission.\n-     *         {@link java.net.StandardSocketOptions StandardSocketOptions}\n-     *         do not require any security permission.\n-     *\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":2,"deletions":104,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -124,4 +124,0 @@\n-     * <p>First, if there is a security manager, its {@code checkRead}\n-     * method is called with the {@code name} argument as its argument\n-     * to ensure the read is allowed.\n-     *\n@@ -134,4 +130,0 @@\n-     * @throws SecurityException if a security manager exists and its\n-     *         {@code checkRead} method doesn't allow read access to the file.\n-     *\n-     * @see SecurityManager#checkRead(java.lang.String)\n@@ -148,4 +140,0 @@\n-     * <p>First, if there is a security manager, its {@code checkRead}\n-     * method is called with the {@code name} argument as its argument to\n-     * ensure the read is allowed.\n-     *\n@@ -159,6 +147,0 @@\n-     * @throws SecurityException if a security manager exists and\n-     *         its {@code checkRead} method\n-     *         doesn't allow read access to the file,\n-     *         or its {@code checkDelete} method doesn't allow deleting\n-     *         the file when the {@code OPEN_DELETE} flag is set.\n-     * @see SecurityManager#checkRead(java.lang.String)\n@@ -191,4 +173,0 @@\n-     * <p>First, if there is a security manager, its {@code checkRead}\n-     * method is called with the {@code name} argument as its argument to\n-     * ensure the read is allowed.\n-     *\n@@ -206,6 +184,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and its {@code checkRead}\n-     *         method doesn't allow read access to the file, or its\n-     *         {@code checkDelete} method doesn't allow deleting the\n-     *         file when the {@code OPEN_DELETE} flag is set\n-     *\n@@ -214,2 +186,0 @@\n-     * @see SecurityManager#checkRead(java.lang.String)\n-     *\n@@ -251,4 +221,0 @@\n-     * <p>First, if there is a security manager, its {@code checkRead}\n-     * method is called with the {@code name} argument as its argument\n-     * to ensure the read is allowed.\n-     *\n@@ -264,5 +230,0 @@\n-     * @throws SecurityException\n-     *         if a security manager exists and its {@code checkRead}\n-     *         method doesn't allow read access to the file\n-     *\n-     * @see SecurityManager#checkRead(java.lang.String)\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,7 +68,0 @@\n-\n-    \/**\n-     * Constructs a new NativeReferenceQueue.\n-     *\n-     * Invoked by jdk.internal.util.ReferencedKeyMap\n-     *\/\n-    <T> ReferenceQueue<T> newNativeReferenceQueue();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -167,2 +167,0 @@\n-        java.management.rmi,\n-        java.naming,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedExceptionAction;\n@@ -298,2 +296,1 @@\n-            \/\/ Perform security check before returning address\n-            return Net.getRevealedLocalAddress(localAddress);\n+            return localAddress;\n@@ -578,14 +575,5 @@\n-                @SuppressWarnings(\"removal\")\n-                SecurityManager sm = System.getSecurityManager();\n-                if (connected || (sm == null)) {\n-                    \/\/ connected or no security manager\n-                    int n = receive(dst, connected);\n-                    if (blocking) {\n-                        while (IOStatus.okayToRetry(n) && isOpen()) {\n-                            park(Net.POLLIN);\n-                            n = receive(dst, connected);\n-                        }\n-                    }\n-                    if (n > 0 || (n == 0 && isOpen())) {\n-                        \/\/ sender address is in socket address buffer\n-                        sender = sourceSocketAddress();\n+                int n = receive(dst, connected);\n+                if (blocking) {\n+                    while (IOStatus.okayToRetry(n) && isOpen()) {\n+                        park(Net.POLLIN);\n+                        n = receive(dst, connected);\n@@ -593,3 +581,4 @@\n-                } else {\n-                    \/\/ security manager and unconnected\n-                    sender = untrustedReceive(dst);\n+                }\n+                if (n > 0 || (n == 0 && isOpen())) {\n+                    \/\/ sender address is in socket address buffer\n+                    sender = sourceSocketAddress();\n@@ -606,43 +595,0 @@\n-    \/**\n-     * Receives a datagram into an untrusted buffer. When there is a security\n-     * manager set, and the socket is not connected, datagrams have to be received\n-     * into a buffer that is not accessible to the user. The datagram is copied\n-     * into the user's buffer when the sender address is accepted by the security\n-     * manager.\n-     *\/\n-    private SocketAddress untrustedReceive(ByteBuffer dst) throws IOException {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        assert readLock.isHeldByCurrentThread()\n-                && sm != null && remoteAddress == null;\n-\n-        boolean blocking = isBlocking();\n-        for (;;) {\n-            int n;\n-            ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining());\n-            try {\n-                n = receive(bb, false);\n-                if (n >= 0) {\n-                    \/\/ sender address is in socket address buffer\n-                    InetSocketAddress isa = sourceSocketAddress();\n-                    try {\n-                        sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n-                        bb.flip();\n-                        dst.put(bb);\n-                        return isa;\n-                    } catch (SecurityException se) {\n-                        \/\/ ignore datagram\n-                    }\n-                }\n-            } finally {\n-                Util.releaseTemporaryDirectBuffer(bb);\n-            }\n-\n-            if (blocking && IOStatus.okayToRetry(n) && isOpen()) {\n-                park(Net.POLLIN);\n-            } else {\n-                return null;\n-            }\n-        }\n-    }\n-\n@@ -680,3 +626,1 @@\n-            long startNanos = System.nanoTime();\n-            long remainingNanos = nanos;\n-            SocketAddress sender = null;\n+            boolean completed = false;\n@@ -686,3 +630,2 @@\n-                do {\n-                    ByteBuffer dst = tryBlockingReceive(connected, bufLength, remainingNanos);\n-\n+                ByteBuffer dst = tryBlockingReceive(connected, bufLength, nanos);\n+                if (dst != null) {\n@@ -690,37 +633,9 @@\n-                    if (dst != null) {\n-                        try {\n-                            \/\/ sender address is in socket address buffer\n-                            sender = sourceSocketAddress();\n-\n-                            \/\/ check sender when security manager set and not connected\n-                            @SuppressWarnings(\"removal\")\n-                            SecurityManager sm = System.getSecurityManager();\n-                            if (sm != null && !connected) {\n-                                InetSocketAddress isa = (InetSocketAddress) sender;\n-                                try {\n-                                    sm.checkAccept(isa.getAddress().getHostAddress(), isa.getPort());\n-                                } catch (SecurityException e) {\n-                                    sender = null;\n-                                }\n-                            }\n-\n-                            if (sender != null) {\n-                                \/\/ copy bytes to the DatagramPacket, and set length and sender\n-                                synchronized (p) {\n-                                    \/\/ re-read p.bufLength in case DatagramPacket changed\n-                                    int len = Math.min(dst.limit(), DatagramPackets.getBufLength(p));\n-                                    dst.get(p.getData(), p.getOffset(), len);\n-                                    DatagramPackets.setLength(p, len);\n-                                    p.setSocketAddress(sender);\n-                                }\n-                            } else {\n-                                \/\/ need to retry, adjusting timeout if needed\n-                                if (nanos > 0) {\n-                                    remainingNanos = nanos - (System.nanoTime() - startNanos);\n-                                    if (remainingNanos <= 0) {\n-                                        throw new SocketTimeoutException(\"Receive timed out\");\n-                                    }\n-                                }\n-                            }\n-                        } finally {\n-                            Util.offerFirstTemporaryDirectBuffer(dst);\n+                    try {\n+                        SocketAddress sender = sourceSocketAddress();\n+                        synchronized (p) {\n+                            \/\/ copy bytes to the DatagramPacket, and set length and sender.\n+                            \/\/ Need to re-read p.bufLength in case DatagramPacket changed\n+                            int len = Math.min(dst.limit(), DatagramPackets.getBufLength(p));\n+                            dst.get(p.getData(), p.getOffset(), len);\n+                            DatagramPackets.setLength(p, len);\n+                            p.setSocketAddress(sender);\n@@ -728,0 +643,2 @@\n+                    } finally {\n+                        Util.offerFirstTemporaryDirectBuffer(dst);\n@@ -729,1 +646,2 @@\n-                } while (sender == null && isOpen());\n+                    completed = true;\n+                }\n@@ -731,1 +649,1 @@\n-                endRead(true, (sender != null));\n+                endRead(true, completed);\n@@ -889,9 +807,0 @@\n-                    @SuppressWarnings(\"removal\")\n-                    SecurityManager sm = System.getSecurityManager();\n-                    if (sm != null) {\n-                        if (ia.isMulticastAddress()) {\n-                            sm.checkMulticast(ia);\n-                        } else {\n-                            sm.checkConnect(ia.getHostAddress(), isa.getPort());\n-                        }\n-                    }\n@@ -1349,4 +1258,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null)\n-            sm.checkListen(isa.getPort());\n@@ -1378,11 +1283,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            InetAddress ia = isa.getAddress();\n-            if (ia.isMulticastAddress()) {\n-                sm.checkMulticast(ia);\n-            } else {\n-                sm.checkConnect(ia.getHostAddress(), isa.getPort());\n-                sm.checkAccept(ia.getHostAddress(), isa.getPort());\n-            }\n-        }\n@@ -1594,1 +1488,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1599,6 +1492,3 @@\n-                PrivilegedExceptionAction<Method> pae = () -> {\n-                    Method m = AbstractSelectableChannel.class.getDeclaredMethod(\"forEach\", Consumer.class);\n-                    m.setAccessible(true);\n-                    return m;\n-                };\n-                FOREACH = AccessController.doPrivileged(pae);\n+                Method m = AbstractSelectableChannel.class.getDeclaredMethod(\"forEach\", Consumer.class);\n+                m.setAccessible(true);\n+                FOREACH = m;\n@@ -1651,5 +1541,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null)\n-            sm.checkMulticast(group);\n-\n@@ -2056,4 +1941,1 @@\n-                PrivilegedExceptionAction<MethodHandles.Lookup> pa = () ->\n-                    MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());\n-                @SuppressWarnings(\"removal\")\n-                MethodHandles.Lookup l = AccessController.doPrivileged(pa);\n+                MethodHandles.Lookup l = MethodHandles.privateLookupIn(DatagramPacket.class, MethodHandles.lookup());\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":31,"deletions":149,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -45,3 +45,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -53,1 +50,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -99,1 +95,1 @@\n-        String s = GetPropertyAction.privilegedGetProperty(\"jdk.lang.Process.launchMechanism\");\n+        String s = System.getProperty(\"jdk.lang.Process.launchMechanism\");\n@@ -286,1 +282,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -306,8 +301,1 @@\n-        try {\n-            AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {\n-                initStreams(fds, forceNullOutputStream);\n-                return null;\n-            });\n-        } catch (PrivilegedActionException ex) {\n-            throw (IOException) ex.getCause();\n-        }\n+        initStreams(fds, forceNullOutputStream);\n@@ -511,5 +499,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new RuntimePermission(\"manageProcess\"));\n-        }\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -111,7 +111,0 @@\n-#if defined(_WIN32) && !defined(_WIN64)\n-    onLoad = (jdwpTransport_OnLoad_t)\n-                 dbgsysFindLibraryEntry(handle, \"_jdwpTransport_OnLoad@16\");\n-    if (onLoad != NULL) {\n-        return onLoad;\n-    }\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/transport.c","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -118,0 +118,7 @@\n+runtime\/Dictionary\/CleanProtectionDomain.java 8341916 generic-all\n+runtime\/Dictionary\/ProtectionDomainCacheTest.java 8341916 generic-all\n+runtime\/logging\/ProtectionDomainVerificationTest.java 8341916 generic-all\n+\n+# Fails with +UseCompactObjectHeaders on aarch64\n+runtime\/cds\/appcds\/SharedBaseAddress.java 8340212 linux-aarch64,macosx-aarch64\n+runtime\/cds\/SharedBaseAddress.java 8340212 linux-aarch64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}