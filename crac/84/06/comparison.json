{"files":[{"patch":"@@ -39,1 +39,0 @@\n-#include \"memory\/oopFactory.hpp\"\n@@ -41,1 +40,0 @@\n-#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -46,1 +44,0 @@\n-#include \"perfMemory_linux.hpp\"\n@@ -57,2 +54,0 @@\n-#include \"runtime\/jniHandles.hpp\"\n-#include \"runtime\/jniHandles.inline.hpp\"\n@@ -73,2 +68,0 @@\n-#include \"services\/attachListener.hpp\"\n-#include \"services\/heapDumper.hpp\"\n@@ -78,1 +71,0 @@\n-#include \"linuxAttachOperation.hpp\"\n@@ -88,1 +80,0 @@\n-#include \"attachListener_linux.hpp\"\n@@ -94,1 +85,0 @@\n-# include <sys\/stat.h>\n@@ -97,1 +87,0 @@\n-# include <sys\/wait.h>\n@@ -114,1 +103,0 @@\n-# include <fcntl.h>\n@@ -169,243 +157,0 @@\n-class FdsInfo {\n-public:\n-\n-  enum state_t {\n-    INVALID = -3,\n-    CLOSED = -2,\n-    ROOT = -1,\n-    DUP_OF_0 = 0,\n-    \/\/ ...\n-  };\n-\n-  enum mark_t {\n-    M_CANT_RESTORE = 1 << 0,\n-  };\n-\n-private:\n-  struct fdinfo {\n-    int fd;\n-    struct stat stat;\n-    state_t state;\n-    unsigned mark;\n-\n-    int flags;\n-  };\n-\n-  \/\/ params are indices into _fdinfos\n-  bool same_fd(int i1, int i2);\n-\n-  bool _inited;\n-  GrowableArray<fdinfo> _fdinfos;\n-\n-  void assert_mark(int i) {\n-    assert(_inited, \"\");\n-    assert(i < _fdinfos.length(), \"\");\n-    assert(_fdinfos.at(i).state != CLOSED, \"\");\n-  }\n-\n-public:\n-  void initialize();\n-\n-  int len() { return _fdinfos.length(); }\n-\n-  state_t get_state(int i) {\n-    assert(_inited, \"\");\n-    assert(i < _fdinfos.length(), \"\");\n-    return _fdinfos.at(i).state;\n-  }\n-\n-  state_t find_state(int fd, state_t orstate) {\n-    for (int i = 0; i < _fdinfos.length(); ++i) {\n-      fdinfo *info = _fdinfos.adr_at(i);\n-      if (info->fd == fd) {\n-        return info->state;\n-      }\n-    }\n-    return orstate;\n-  }\n-\n-  int get_fd(int i) {\n-    assert(_inited, \"\");\n-    assert(i < _fdinfos.length(), \"\");\n-    return _fdinfos.at(i).fd;\n-  }\n-\n-  struct stat* get_stat(int i) {\n-    assert(_inited, \"\");\n-    assert(i < _fdinfos.length(), \"\");\n-    return &_fdinfos.at(i).stat;\n-  }\n-\n-  FdsInfo(bool do_init = true) :\n-    _inited(false),\n-    _fdinfos(16, mtInternal)\n-  {\n-    if (do_init) {\n-      initialize();\n-    }\n-  }\n-};\n-\n-struct CracFailDep {\n-  int _type;\n-  char* _msg;\n-  CracFailDep(int type, char* msg) :\n-    _type(type),\n-    _msg(msg)\n-  { }\n-  CracFailDep() :\n-    _type(JVM_CR_FAIL),\n-    _msg(NULL)\n-  { }\n-};\n-\n-class CracRestoreParameters : public CHeapObj<mtInternal> {\n-  char* _raw_content;\n-  GrowableArray<const char *>* _properties;\n-  const char* _args;\n-\n-  struct header {\n-    jlong _restore_time;\n-    jlong _restore_nanos;\n-    int _nflags;\n-    int _nprops;\n-    int _env_memory_size;\n-  };\n-\n-  static bool write_check_error(int fd, const void *buf, int count) {\n-    int wret = write(fd, buf, count);\n-    if (wret != count) {\n-      if (wret < 0) {\n-        perror(\"shm error\");\n-      } else {\n-        fprintf(stderr, \"write shm truncated\");\n-      }\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  static int system_props_length(const SystemProperty* props) {\n-    int len = 0;\n-    while (props != NULL) {\n-      ++len;\n-      props = props->next();\n-    }\n-    return len;\n-  }\n-\n-  static int env_vars_size(const char* const * env) {\n-    int len = 0;\n-    for (; *env; ++env) {\n-      len += strlen(*env) + 1;\n-    }\n-    return len;\n-  }\n-\n- public:\n-  const char *args() const { return _args; }\n-  GrowableArray<const char *>* properties() const { return _properties; }\n-\n-  CracRestoreParameters() :\n-    _raw_content(NULL),\n-    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n-    _args(NULL)\n-  {}\n-\n-  ~CracRestoreParameters() {\n-    if (_raw_content) {\n-      FREE_C_HEAP_ARRAY(char, _raw_content);\n-    }\n-    delete _properties;\n-  }\n-\n-  static bool write_to(int fd,\n-      const char* const* flags, int num_flags,\n-      const SystemProperty* props,\n-      const char *args,\n-      jlong restore_time,\n-      jlong restore_nanos) {\n-    header hdr = {\n-      restore_time,\n-      restore_nanos,\n-      num_flags,\n-      system_props_length(props),\n-      env_vars_size(environ)\n-    };\n-\n-    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n-      return false;\n-    }\n-\n-    for (int i = 0; i < num_flags; ++i) {\n-      if (!write_check_error(fd, flags[i], strlen(flags[i]) + 1)) {\n-        return false;\n-      }\n-    }\n-\n-    const SystemProperty* p = props;\n-    while (p != NULL) {\n-      char prop[4096];\n-      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n-      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n-      if (!write_check_error(fd, prop, len+1)) {\n-        return false;\n-      }\n-      p = p->next();\n-    }\n-\n-    \/\/ Write env vars\n-    for (char** env = environ; *env; ++env) {\n-      if (!write_check_error(fd, *env, strlen(*env) + 1)) {\n-        return false;\n-      }\n-    }\n-\n-    return write_check_error(fd, args, strlen(args)+1); \/\/ +1 for null char\n-  }\n-\n-  bool read_from(int fd);\n-\n-};\n-\n-class VM_Crac: public VM_Operation {\n-  jarray _fd_arr;\n-  const bool _dry_run;\n-  bool _ok;\n-  GrowableArray<CracFailDep>* _failures;\n-  CracRestoreParameters _restore_parameters;\n-  outputStream* _ostream;\n-  LinuxAttachOperation* _attach_op;\n-\n-public:\n-  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n-    _fd_arr(fd_arr),\n-    _dry_run(dry_run),\n-    _ok(false),\n-    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n-    _restore_parameters(),\n-    _ostream(jcmd_stream ? jcmd_stream : tty),\n-    _attach_op(jcmd_stream ? LinuxAttachListener::get_current_op() : NULL)\n-  { }\n-\n-  ~VM_Crac() {\n-    delete _failures;\n-  }\n-\n-  GrowableArray<CracFailDep>* failures() { return _failures; }\n-  bool ok() { return _ok; }\n-  const char* new_args() { return _restore_parameters.args(); }\n-  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n-  virtual bool allow_nested_vm_operations() const  { return true; }\n-  VMOp_Type type() const { return VMOp_VM_Crac; }\n-  void doit();\n-  bool read_shm(int shmid);\n-\n-private:\n-  bool is_claimed_fd(int fd);\n-  bool is_socket_from_jcmd(int sock_fd);\n-  void report_ok_to_jcmd_if_any();\n-  void print_resources(const char* msg, ...);\n-  void trace_cr(const char* msg, ...);\n-};\n-\n@@ -437,9 +182,0 @@\n-\/\/ CRaC\n-static const char* _crengine = NULL;\n-static char* _crengine_arg_str = NULL;\n-static unsigned int _crengine_argc = 0;\n-static const char* _crengine_args[32];\n-static jlong _restore_start_time;\n-static jlong _restore_start_nanos;\n-static FdsInfo _vm_inited_fds(false);\n-\n@@ -5707,776 +5443,0 @@\n-\/\/ CRaC\n-\n-jlong os::Linux::restore_start_time() {\n-  if (!_restore_start_time) {\n-    return -1;\n-  }\n-  return _restore_start_time;\n-}\n-\n-jlong os::Linux::uptime_since_restore() {\n-  if (!_restore_start_nanos) {\n-    return -1;\n-  }\n-  return javaTimeNanos() - _restore_start_nanos;\n-}\n-\n-void VM_Crac::trace_cr(const char* msg, ...) {\n-  if (CRTrace) {\n-    va_list ap;\n-    va_start(ap, msg);\n-    _ostream->print(\"CR: \");\n-    _ostream->vprint_cr(msg, ap);\n-    va_end(ap);\n-  }\n-}\n-\n-void VM_Crac::print_resources(const char* msg, ...) {\n-  if (CRPrintResourcesOnCheckpoint) {\n-    va_list ap;\n-    va_start(ap, msg);\n-    _ostream->vprint(msg, ap);\n-    va_end(ap);\n-  }\n-}\n-\n-void os::Linux::vm_create_start() {\n-  if (!CRaCCheckpointTo) {\n-    return;\n-  }\n-  close_extra_descriptors();\n-  _vm_inited_fds.initialize();\n-}\n-\n-\/* taken from criu, that took this from kernel *\/\n-#define NFS_PREF \".nfs\"\n-#define NFS_PREF_LEN ((unsigned)sizeof(NFS_PREF) - 1)\n-#define NFS_FILEID_LEN ((unsigned)sizeof(uint64_t) << 1)\n-#define NFS_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n-#define NFS_LEN (NFS_PREF_LEN + NFS_FILEID_LEN + NFS_COUNTER_LEN)\n-static bool nfs_silly_rename(char* path) {\n-  char *sep = strrchr(path, '\/');\n-  char *base = sep ? sep + 1 : path;\n-  if (strncmp(base, NFS_PREF, NFS_PREF_LEN)) {\n-    return false;\n-  }\n-  for (unsigned i = NFS_PREF_LEN; i < NFS_LEN; ++i) {\n-    if (!isxdigit(base[i])) {\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n-static int readfdlink(int fd, char *link, size_t len) {\n-  char fdpath[64];\n-  snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n-  int ret = readlink(fdpath, link, len);\n-  if (ret == -1) {\n-    return ret;\n-  }\n-  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n-  return ret;\n-}\n-\n-static bool same_stat(struct stat* st1, struct stat* st2) {\n-  return st1->st_dev == st2->st_dev &&\n-         st1->st_ino == st2->st_ino;\n-}\n-\n-bool FdsInfo::same_fd(int i1, int i2) {\n-  assert(i1 < _fdinfos.length(), \"\");\n-  assert(i2 < _fdinfos.length(), \"\");\n-  fdinfo *fi1 = _fdinfos.adr_at(i1);\n-  fdinfo *fi2 = _fdinfos.adr_at(i2);\n-  if (!same_stat(&fi1->stat, &fi2->stat)) {\n-    return false;\n-  }\n-\n-  int flags1 = fcntl(fi1->fd, F_GETFL);\n-  int flags2 = fcntl(fi2->fd, F_GETFL);\n-  if (flags1 != flags2) {\n-    return false;\n-  }\n-\n-  const int test_flag = O_NONBLOCK;\n-  const int new_flags1 = flags1 ^ test_flag;\n-  fcntl(fi1->fd, F_SETFL, new_flags1);\n-  if (fcntl(fi1->fd, F_GETFL) != new_flags1) {\n-    \/\/ flag write ignored or handled differently,\n-    \/\/ don't know what to do\n-    return false;\n-  }\n-\n-  const int new_flags2 = fcntl(fi2->fd, F_GETFL);\n-  const bool are_same = new_flags1 == new_flags2;\n-\n-  fcntl(fi2->fd, flags1);\n-\n-  return are_same;\n-}\n-\n-void FdsInfo::initialize() {\n-  assert(!_inited, \"should be called only once\");\n-\n-  char path[PATH_MAX];\n-  struct dirent *dp;\n-\n-  DIR *dir = opendir(\"\/proc\/self\/fd\");\n-  int dfd = dirfd(dir);\n-  while (dp = readdir(dir)) {\n-    if (dp->d_name[0] == '.') {\n-      \/\/ skip \".\" and \"..\"\n-      continue;\n-    }\n-    fdinfo info;\n-    info.fd = atoi(dp->d_name);\n-    if (info.fd == dfd) {\n-      continue;\n-    }\n-    int r = fstat(info.fd, &info.stat);\n-    if (r == -1) {\n-      info.state = CLOSED;\n-      continue;\n-    }\n-    info.state = ROOT; \/\/ can be changed to DUP_OF_0 + N below\n-    info.mark = 0;\n-    _fdinfos.append(info);\n-  }\n-  closedir(dir);\n-  _inited = true;\n-\n-  for (int i = 0; i < _fdinfos.length(); ++i) {\n-    fdinfo *info = _fdinfos.adr_at(i);\n-    for (int j = 0; j < i; ++j) {\n-      if (get_state(j) == ROOT && same_fd(i, j)) {\n-        info->state = (state_t)(DUP_OF_0 + j);\n-        break;\n-      }\n-    }\n-\n-    if (info->state == ROOT) {\n-      char fdpath[PATH_MAX];\n-      int r = readfdlink(info->fd, fdpath, sizeof(fdpath));\n-      guarantee(-1 != r, \"can't stat fd\");\n-      if (info->stat.st_nlink == 0 ||\n-          strstr(fdpath, \"(deleted)\") ||\n-          nfs_silly_rename(fdpath)) {\n-        info->mark |= FdsInfo::M_CANT_RESTORE;\n-      }\n-    }\n-  }\n-}\n-\n-static int cr_util_path(char* path, int len) {\n-  os::jvm_path(path, len);\n-  \/\/ path is \"...\/lib\/server\/libjvm.so\"\n-  char *after_elem = NULL;\n-  for (int i = 0; i < 2; ++i) {\n-    after_elem = strrchr(path, '\/');\n-    *after_elem = '\\0';\n-  }\n-  return after_elem - path;\n-}\n-\n-static bool compute_crengine() {\n-  \/\/ release possible old copies\n-  os::free((char *) _crengine); \/\/ NULL is allowed\n-  _crengine = NULL;\n-  os::free((char *) _crengine_arg_str);\n-  _crengine_arg_str = NULL;\n-\n-  if (!CREngine) {\n-    return true;\n-  }\n-  char *exec = os::strdup_check_oom(CREngine);\n-  char *comma = strchr(exec, ',');\n-  if (comma != NULL) {\n-    *comma = '\\0';\n-    _crengine_arg_str = os::strdup_check_oom(comma + 1);\n-  }\n-  if (exec[0] == '\/') {\n-    _crengine = exec;\n-  } else {\n-    char path[JVM_MAXPATHLEN];\n-    int pathlen = cr_util_path(path, sizeof(path));\n-    strcat(path + pathlen, \"\/\");\n-    strcat(path + pathlen, exec);\n-\n-    struct stat st;\n-    if (0 != stat(path, &st)) {\n-      warning(\"Could not find %s: %s\", path, strerror(errno));\n-      return false;\n-    }\n-    _crengine = os::strdup_check_oom(path);\n-    \/\/ we have read and duplicated args from exec, now we can release\n-    os::free(exec);\n-  }\n-  _crengine_args[0] = _crengine;\n-  _crengine_argc = 2;\n-\n-  if (_crengine_arg_str != NULL) {\n-    char *arg = _crengine_arg_str;\n-    char *target = _crengine_arg_str;\n-    bool escaped = false;\n-    for (char *c = arg; *c != '\\0'; ++c) {\n-      if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 2) {\n-        warning(\"Too many options to CREngine; cannot proceed with these: %s\", arg);\n-        return false;\n-      }\n-      if (!escaped) {\n-        switch(*c) {\n-        case '\\\\':\n-          escaped = true;\n-          continue; \/\/ for\n-        case ',':\n-          *target++ = '\\0';\n-          _crengine_args[_crengine_argc++] = arg;\n-          arg = target;\n-          continue; \/\/ for\n-        }\n-      }\n-      escaped = false;\n-      *target++ = *c;\n-    }\n-    *target = '\\0';\n-    _crengine_args[_crengine_argc++] = arg;\n-    _crengine_args[_crengine_argc] = NULL;\n-  }\n-  return true;\n-}\n-\n-static void add_crengine_arg(const char *arg) {\n-  if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 1) {\n-      warning(\"Too many options to CREngine; cannot add %s\", arg);\n-      return;\n-  }\n-  _crengine_args[_crengine_argc++] = arg;\n-  _crengine_args[_crengine_argc] = NULL;\n-}\n-\n-static int call_crengine() {\n-  if (!_crengine) {\n-    return -1;\n-  }\n-\n-  pid_t pid = fork();\n-  if (pid == -1) {\n-    perror(\"cannot fork for crengine\");\n-    return -1;\n-  }\n-  if (pid == 0) {\n-    _crengine_args[1] = \"checkpoint\";\n-    add_crengine_arg(CRaCCheckpointTo);\n-    execv(_crengine, (char * const*)_crengine_args);\n-    perror(\"execv CREngine checkpoint\");\n-    exit(1);\n-  }\n-\n-  int status;\n-  int ret;\n-  do {\n-    ret = waitpid(pid, &status, 0);\n-  } while (ret == -1 && errno == EINTR);\n-\n-  if (ret == -1 || !WIFEXITED(status)) {\n-    return -1;\n-  }\n-  return WEXITSTATUS(status) == 0 ? 0 : -1;\n-}\n-\n-class CracSHM {\n-  char _path[128];\n-public:\n-  CracSHM(int id) {\n-    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n-    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n-      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n-    }\n-  }\n-\n-  int open(int mode) {\n-    int shmfd = shm_open(_path, mode, 0600);\n-    if (-1 == shmfd) {\n-      perror(\"shm_open\");\n-    }\n-    return shmfd;\n-  }\n-\n-  void unlink() {\n-    shm_unlink(_path);\n-  }\n-};\n-\n-int os::Linux::checkpoint_restore(int *shmid) {\n-  os::record_time_before_checkpoint();\n-\n-  int cres = call_crengine();\n-  if (cres < 0) {\n-    return JVM_CHECKPOINT_ERROR;\n-  }\n-\n-  sigset_t waitmask;\n-  sigemptyset(&waitmask);\n-  sigaddset(&waitmask, RESTORE_SIGNAL);\n-\n-  siginfo_t info;\n-  int sig;\n-  do {\n-    sig = sigwaitinfo(&waitmask, &info);\n-  } while (sig == -1 && errno == EINTR);\n-  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n-\n-  if (CRaCCPUCountInit) {\n-    initialize_processor_count();\n-    if (_cpu_to_node != NULL)\n-      rebuild_cpu_to_node_map();\n-  }\n-\n-  os::update_javaTimeNanos_offset();\n-\n-  if (CRTraceStartupTime) {\n-    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n-  }\n-\n-  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n-    tty->print(\"JVM: invalid info for restore provided: %s\", info.si_code == SI_QUEUE ? \"queued\" : \"not queued\");\n-    if (info.si_code == SI_QUEUE) {\n-      tty->print(\" code %d\", info.si_int);\n-    }\n-    tty->cr();\n-    return JVM_CHECKPOINT_ERROR;\n-  }\n-\n-  if (0 < info.si_int) {\n-    *shmid = info.si_int;\n-  }\n-\n-  return JVM_CHECKPOINT_OK;\n-}\n-\n-static const char* stat2strtype(mode_t mode) {\n-  switch (mode & S_IFMT) {\n-  case S_IFSOCK: return \"socket\";\n-  case S_IFLNK:  return \"symlink\";\n-  case S_IFREG:  return \"regular\";\n-  case S_IFBLK:  return \"block\";\n-  case S_IFDIR:  return \"directory\";\n-  case S_IFCHR:  return \"character\";\n-  case S_IFIFO:  return \"fifo\";\n-  default:       break;\n-  }\n-  return \"unknown\";\n-}\n-\n-static int stat2stfail(mode_t mode) {\n-  switch (mode & S_IFMT) {\n-  case S_IFSOCK:\n-    return JVM_CR_FAIL_SOCK;\n-  case S_IFLNK:\n-  case S_IFREG:\n-  case S_IFBLK:\n-  case S_IFDIR:\n-  case S_IFCHR:\n-    return JVM_CR_FAIL_FILE;\n-  case S_IFIFO:\n-    return JVM_CR_FAIL_PIPE;\n-  default:\n-    break;\n-  }\n-  return JVM_CR_FAIL;\n-}\n-\n-bool VM_Crac::read_shm(int shmid) {\n-  CracSHM shm(shmid);\n-  int shmfd = shm.open(O_RDONLY);\n-  shm.unlink();\n-  if (shmfd < 0) {\n-    return false;\n-  }\n-  bool ret = _restore_parameters.read_from(shmfd);\n-  close(shmfd);\n-  return ret;\n-}\n-\n-\/\/ If checkpoint is called throught the API, jcmd operation and jcmd output doesn't exist.\n-bool VM_Crac::is_socket_from_jcmd(int sock) {\n-  if (_attach_op == NULL)\n-    return false;\n-  int sock_fd = _attach_op->socket();\n-  return sock == sock_fd;\n-}\n-\n-void VM_Crac::report_ok_to_jcmd_if_any() {\n-  if (_attach_op == NULL)\n-    return;\n-  bufferedStream* buf = static_cast<bufferedStream*>(_ostream);\n-  _attach_op->effectively_complete_raw(JNI_OK, buf);\n-  \/\/ redirect any further output to console\n-  _ostream = tty;\n-}\n-\n-bool VM_Crac::is_claimed_fd(int fd) {\n-  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n-  for (int j = 0; j < claimed_fds->length(); ++j) {\n-    jint cfd = claimed_fds->int_at(j);\n-    if (fd == cfd) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-void VM_Crac::doit() {\n-\n-  AttachListener::abort();\n-\n-  FdsInfo fds;\n-\n-  bool ok = true;\n-\n-  for (int i = 0; i < fds.len(); ++i) {\n-    if (fds.get_state(i) == FdsInfo::CLOSED) {\n-      continue;\n-    }\n-    int fd = fds.get_fd(i);\n-\n-    char detailsbuf[PATH_MAX];\n-    struct stat* st = fds.get_stat(i);\n-    const char* type = stat2strtype(st->st_mode);\n-    int linkret = readfdlink(fd, detailsbuf, sizeof(detailsbuf));\n-    const char* details = 0 < linkret ? detailsbuf : \"\";\n-    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\" \", fd, type, details);\n-\n-    if (is_claimed_fd(fd)) {\n-      print_resources(\"OK: claimed by java code\\n\");\n-      continue;\n-    }\n-\n-    if (_vm_inited_fds.find_state(fd, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n-      print_resources(\"OK: inherited from process env\\n\");\n-      continue;\n-    }\n-\n-    if (S_ISSOCK(st->st_mode)) {\n-      if (is_socket_from_jcmd(fd)){\n-        print_resources(\"OK: jcmd socket\\n\");\n-        continue;\n-      }\n-    }\n-\n-    print_resources(\"BAD: opened by application\\n\");\n-    ok = false;\n-\n-    const int maxinfo = 64;\n-    size_t buflen = strlen(details) + maxinfo;\n-    char* msg = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n-    int len = snprintf(msg, buflen, \"FD fd=%d type=%s path=%s\", fd, type, detailsbuf);\n-    msg[len < 0 ? 0 : ((size_t) len >= buflen ? buflen - 1 : len)] = '\\0';\n-    _failures->append(CracFailDep(stat2stfail(st->st_mode & S_IFMT), msg));\n-  }\n-\n-  if ((!ok || _dry_run) && CRHeapDumpOnCheckpointException) {\n-    HeapDumper::dump_heap();\n-  }\n-\n-  if (!ok && CRDoThrowCheckpointException) {\n-    return;\n-  } else if (_dry_run) {\n-    _ok = ok;\n-    return;\n-  }\n-\n-  if (!PerfMemoryLinux::checkpoint(CRaCCheckpointTo)) {\n-    return;\n-  }\n-\n-  int shmid = 0;\n-  if (CRAllowToSkipCheckpoint) {\n-    trace_cr(\"Skip Checkpoint\");\n-  } else {\n-    trace_cr(\"Checkpoint ...\");\n-    report_ok_to_jcmd_if_any();\n-    int ret = os::Linux::checkpoint_restore(&shmid);\n-    if (ret == JVM_CHECKPOINT_ERROR) {\n-      PerfMemoryLinux::restore();\n-      return;\n-    }\n-  }\n-\n-  VM_Version::crac_restore();\n-\n-  if (shmid <= 0 || !VM_Crac::read_shm(shmid)) {\n-    _restore_start_time = os::javaTimeMillis();\n-    _restore_start_nanos = os::javaTimeNanos();\n-  } else {\n-    _restore_start_nanos += os::monotonic_time_offset();\n-  }\n-  PerfMemoryLinux::restore();\n-\n-  _ok = true;\n-}\n-\n-bool os::Linux::prepare_checkpoint() {\n-  struct stat st;\n-\n-  if (0 == stat(CRaCCheckpointTo, &st)) {\n-    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n-      warning(\"%s: not a directory\", CRaCCheckpointTo);\n-      return false;\n-    }\n-  } else {\n-    if (-1 == mkdir(CRaCCheckpointTo, 0700)) {\n-      warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n-      return false;\n-    }\n-    if (-1 == rmdir(CRaCCheckpointTo)) {\n-      warning(\"cannot cleanup after check: %s\", strerror(errno));\n-      \/\/ not fatal\n-    }\n-  }\n-\n-  if (!compute_crengine()) {\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n-static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n-  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n-  objArrayHandle bundle(THREAD, bundleObj);\n-  jvalue jval = { .i = ret };\n-  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n-  bundle->obj_at_put(0, retObj);\n-  bundle->obj_at_put(1, new_args());\n-  bundle->obj_at_put(2, new_props());\n-  bundle->obj_at_put(3, err_codes());\n-  bundle->obj_at_put(4, err_msgs());\n-  return bundle;\n-}\n-\n-\/** Checkpoint main entry.\n- *\/\n-Handle os::Linux::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n-  if (!CRaCCheckpointTo) {\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n-  }\n-\n-  if (-1 == mkdir(CRaCCheckpointTo, 0700) && errno != EEXIST) {\n-    warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n-  }\n-\n-  Universe::heap()->set_cleanup_unused(true);\n-  Universe::heap()->collect(GCCause::_full_gc_alot);\n-  Universe::heap()->set_cleanup_unused(false);\n-\n-  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n-  {\n-    MutexLocker ml(Heap_lock);\n-    VMThread::execute(&cr);\n-  }\n-  if (cr.ok()) {\n-    oop new_args = NULL;\n-    if (cr.new_args()) {\n-      new_args = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n-    }\n-    GrowableArray<const char *>* new_properties = cr.new_properties();\n-    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n-    objArrayHandle props(THREAD, propsObj);\n-\n-    for (int i = 0; i < new_properties->length(); i++) {\n-      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n-      props->obj_at_put(i, propObj);\n-    }\n-    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n-  }\n-\n-  GrowableArray<CracFailDep>* failures = cr.failures();\n-\n-  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n-  typeArrayHandle codes(THREAD, codesObj);\n-  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n-  objArrayHandle msgs(THREAD, msgsObj);\n-\n-  for (int i = 0; i < failures->length(); ++i) {\n-    codes->int_at_put(i, failures->at(i)._type);\n-    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n-    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n-    msgs->obj_at_put(i, msgObj);\n-  }\n-\n-  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n-}\n-\n-void os::Linux::restore() {\n-  struct stat st;\n-\n-  jlong restore_time = javaTimeMillis();\n-  jlong restore_nanos = javaTimeNanos();\n-\n-  compute_crengine();\n-\n-  int id = getpid();\n-  CracSHM shm(id);\n-  int shmfd = shm.open(O_RDWR | O_CREAT);\n-  if (0 <= shmfd) {\n-    if (CracRestoreParameters::write_to(\n-          shmfd,\n-          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n-          Arguments::system_properties(),\n-          Arguments::java_command() ? Arguments::java_command() : \"\",\n-          restore_time,\n-          restore_nanos)) {\n-      char strid[32];\n-      snprintf(strid, sizeof(strid), \"%d\", id);\n-      setenv(\"CRAC_NEW_ARGS_ID\", strid, true);\n-    }\n-    close(shmfd);\n-  }\n-\n-\n-  if (_crengine) {\n-    _crengine_args[1] = \"restore\";\n-    add_crengine_arg(CRaCRestoreFrom);\n-    execv(_crengine, (char * const*) _crengine_args);\n-    warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", _crengine, strerror(errno));\n-  }\n-}\n-\n-static char modules_path[JVM_MAXPATHLEN] = { '\\0' };\n-\n-static bool is_fd_ignored(int fd, const char *path) {\n-  const char *list = CRaCIgnoredFileDescriptors;\n-  while (list && *list) {\n-    const char *end = strchr(list, ',');\n-    if (!end) {\n-      end = list + strlen(list);\n-    }\n-    char *invalid;\n-    int ignored_fd = strtol(list, &invalid, 10);\n-    if (invalid == end) { \/\/ entry was integer -> file descriptor\n-      if (fd == ignored_fd) {\n-        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n-        return true;\n-      }\n-    } else { \/\/ interpret entry as path\n-      int path_len = path ? strlen(path) : -1;\n-      if (path_len != -1 && path_len == end - list && !strncmp(path, list, end - list)) {\n-        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n-        return true;\n-      }\n-    }\n-    if (*end) {\n-      list = end + 1;\n-    } else {\n-      break;\n-    }\n-  }\n-\n-  if (os::same_files(modules_path, path)) {\n-    \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n-    \/\/ We can ignore this for purposes of CRaC.\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-void os::Linux::close_extra_descriptors() {\n-  \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n-  \/\/ We can ignore this for purposes of CRaC.\n-  if (modules_path[0] == '\\0') {\n-    const char* fileSep = os::file_separator();\n-    jio_snprintf(modules_path, JVM_MAXPATHLEN, \"%s%slib%s\" MODULES_IMAGE_NAME, Arguments::get_java_home(), fileSep, fileSep);\n-  }\n-\n-  char path[PATH_MAX];\n-  struct dirent *dp;\n-\n-  DIR *dir = opendir(\"\/proc\/self\/fd\");\n-  while (dp = readdir(dir)) {\n-    int fd = atoi(dp->d_name);\n-    if (fd > 2 && fd != dirfd(dir)) {\n-      int r = readfdlink(fd, path, sizeof(path));\n-      if (!is_fd_ignored(fd, r != -1 ? path : nullptr)) {\n-        log_warning(os)(\"CRaC closing file descriptor %d: %s\", fd, path);\n-        close(fd);\n-      }\n-    }\n-  }\n-  closedir(dir);\n-}\n-\n-bool CracRestoreParameters::read_from(int fd) {\n-  struct stat st;\n-  if (fstat(fd, &st)) {\n-    perror(\"fstat (ignoring restore parameters)\");\n-    return false;\n-  }\n-\n-  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n-  if (read(fd, contents, st.st_size) < 0) {\n-    perror(\"read (ignoring restore parameters)\");\n-    FREE_C_HEAP_ARRAY(char, contents);\n-    return false;\n-  }\n-\n-  _raw_content = contents;\n-\n-  \/\/ parse the contents to read new system properties and arguments\n-  header* hdr = (header*)_raw_content;\n-  char* cursor = _raw_content + sizeof(header);\n-\n-  ::_restore_start_time = hdr->_restore_time;\n-  ::_restore_start_nanos = hdr->_restore_nanos;\n-\n-  for (int i = 0; i < hdr->_nflags; i++) {\n-    FormatBuffer<80> err_msg(\"%s\", \"\");\n-    JVMFlag::Error result;\n-    const char *name = cursor;\n-    if (*cursor == '+' || *cursor == '-') {\n-      name = cursor + 1;\n-      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n-        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n-      cursor += strlen(cursor) + 1;\n-    } else {\n-      char* eq = strchrnul(cursor, '=');\n-      if (*eq == '\\0') {\n-        result = JVMFlag::Error::MISSING_VALUE;\n-        cursor = eq + 1;\n-      } else {\n-        *eq = '\\0';\n-        char* value = eq + 1;\n-        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n-        cursor = value + strlen(value) + 1;\n-      }\n-    }\n-    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %s\",\n-        name, JVMFlag::flag_error_str(result));\n-  }\n-\n-  for (int i = 0; i < hdr->_nprops; i++) {\n-    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n-    int idx = _properties->append(cursor);\n-    int prop_len = strlen(cursor) + 1;\n-    cursor = cursor + prop_len;\n-  }\n-\n-  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n-  memcpy(env_mem, cursor, hdr->_env_memory_size);\n-\n-  const char* env_end = env_mem + hdr->_env_memory_size;\n-  while (env_mem < env_end) {\n-    const size_t s = strlen(env_mem) + 1;\n-    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n-    putenv(env_mem);\n-    env_mem += s;\n-  }\n-  cursor += hdr->_env_memory_size;\n-\n-  _args = cursor;\n-  return true;\n-}\n-\n-\n@@ -6511,38 +5471,0 @@\n-\n-static bool read_all(int fd, char *dest, size_t n) {\n-  size_t rd = 0;\n-  do {\n-    ssize_t r = ::read(fd, dest + rd, n - rd);\n-    if (r == 0) {\n-      return false;\n-    } else if (r < 0) {\n-      if (errno == EINTR) {\n-        continue;\n-      }\n-      return false;\n-    }\n-    rd += r;\n-  } while (rd < n);\n-  return true;\n-}\n-\n-bool os::read_bootid(char *dest) {\n-  int fd = ::open(\"\/proc\/sys\/kernel\/random\/boot_id\", O_RDONLY);\n-  if (fd < 0 || !read_all(fd, dest, UUID_LENGTH)) {\n-    perror(\"CRaC: Cannot read system boot ID\");\n-    return false;\n-  }\n-  char c;\n-  if (!read_all(fd, &c, 1) || c != '\\n') {\n-    perror(\"CRaC: system boot ID does not end with newline\");\n-    return false;\n-  }\n-  if (::read(fd, &c, 1) != 0) {\n-    perror(\"CRaC: Unexpected data\/error reading system boot ID\");\n-    return false;\n-  }\n-  if (::close(fd) != 0) {\n-    perror(\"CRaC: Cannot close system boot ID file\");\n-  }\n-  return true;\n-}\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":1078,"binary":false,"changes":1078,"status":"modified"},{"patch":"@@ -175,9 +175,0 @@\n-  static void vm_create_start();\n-  static bool prepare_checkpoint();\n-  static Handle checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS);\n-  static void restore();\n-  static void close_extra_descriptors();\n-\n-  static jlong restore_start_time();\n-  static jlong uptime_since_restore();\n-\n@@ -188,2 +179,0 @@\n-  static int checkpoint_restore(int *shmid);\n-\n@@ -313,0 +302,7 @@\n+  static void initialize_cpu_count() {\n+    initialize_processor_count();\n+    if (cpu_to_node() != NULL) {\n+      rebuild_cpu_to_node_map();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1413,1 +1414,1 @@\n-  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + javaTimeNanos_offset;\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + crac::monotonic_time_offset();\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/crac.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3853,1 +3854,1 @@\n-  Handle ret = os::Linux::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3235,1 +3236,1 @@\n-  if (CRaCCheckpointTo && !os::Linux::prepare_checkpoint()) {\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,1153 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"attachListener_linux.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"jvm.h\"\n+#include \"linuxAttachOperation.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"perfMemory_linux.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/attachListener.hpp\"\n+#include \"services\/heapDumper.hpp\"\n+#include \"services\/writeableFlags.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+#include <fcntl.h>\n+#include <sys\/mman.h>\n+#include <sys\/stat.h>\n+#include <sys\/wait.h>\n+#include <unistd.h>\n+\n+class FdsInfo {\n+public:\n+\n+  enum state_t {\n+    INVALID = -3,\n+    CLOSED = -2,\n+    ROOT = -1,\n+    DUP_OF_0 = 0,\n+    \/\/ ...\n+  };\n+\n+  enum mark_t {\n+    M_CANT_RESTORE = 1 << 0,\n+  };\n+\n+private:\n+  struct fdinfo {\n+    int fd;\n+    struct stat stat;\n+    state_t state;\n+    unsigned mark;\n+\n+    int flags;\n+  };\n+\n+  \/\/ params are indices into _fdinfos\n+  bool same_fd(int i1, int i2);\n+\n+  bool _inited;\n+  GrowableArray<fdinfo> _fdinfos;\n+\n+  void assert_mark(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    assert(_fdinfos.at(i).state != CLOSED, \"\");\n+  }\n+\n+public:\n+  void initialize();\n+\n+  int len() { return _fdinfos.length(); }\n+\n+  state_t get_state(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).state;\n+  }\n+\n+  state_t find_state(int fd, state_t orstate) {\n+    for (int i = 0; i < _fdinfos.length(); ++i) {\n+      fdinfo *info = _fdinfos.adr_at(i);\n+      if (info->fd == fd) {\n+        return info->state;\n+      }\n+    }\n+    return orstate;\n+  }\n+\n+  int get_fd(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).fd;\n+  }\n+\n+  struct stat* get_stat(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return &_fdinfos.at(i).stat;\n+  }\n+\n+  FdsInfo(bool do_init = true) :\n+    _inited(false),\n+    _fdinfos(16, mtInternal)\n+  {\n+    if (do_init) {\n+      initialize();\n+    }\n+  }\n+};\n+\n+struct CracFailDep {\n+  int _type;\n+  char* _msg;\n+  CracFailDep(int type, char* msg) :\n+    _type(type),\n+    _msg(msg)\n+  { }\n+  CracFailDep() :\n+    _type(JVM_CR_FAIL),\n+    _msg(NULL)\n+  { }\n+};\n+\n+class CracRestoreParameters : public CHeapObj<mtInternal> {\n+  char* _raw_content;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  struct header {\n+    jlong _restore_time;\n+    jlong _restore_nanos;\n+    int _nflags;\n+    int _nprops;\n+    int _env_memory_size;\n+  };\n+\n+  static bool write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  static int system_props_length(const SystemProperty* props) {\n+    int len = 0;\n+    while (props != NULL) {\n+      ++len;\n+      props = props->next();\n+    }\n+    return len;\n+  }\n+\n+  static int env_vars_size(const char* const * env) {\n+    int len = 0;\n+    for (; *env; ++env) {\n+      len += strlen(*env) + 1;\n+    }\n+    return len;\n+  }\n+\n+ public:\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  CracRestoreParameters() :\n+    _raw_content(NULL),\n+    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(NULL)\n+  {}\n+\n+  ~CracRestoreParameters() {\n+    if (_raw_content) {\n+      FREE_C_HEAP_ARRAY(char, _raw_content);\n+    }\n+    delete _properties;\n+  }\n+\n+  static bool write_to(int fd,\n+      const char* const* flags, int num_flags,\n+      const SystemProperty* props,\n+      const char *args,\n+      jlong restore_time,\n+      jlong restore_nanos) {\n+    header hdr = {\n+      restore_time,\n+      restore_nanos,\n+      num_flags,\n+      system_props_length(props),\n+      env_vars_size(environ)\n+    };\n+\n+    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < num_flags; ++i) {\n+      if (!write_check_error(fd, flags[i], strlen(flags[i]) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    const SystemProperty* p = props;\n+    while (p != NULL) {\n+      char prop[4096];\n+      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n+      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n+      if (!write_check_error(fd, prop, len+1)) {\n+        return false;\n+      }\n+      p = p->next();\n+    }\n+\n+    \/\/ Write env vars\n+    for (char** env = environ; *env; ++env) {\n+      if (!write_check_error(fd, *env, strlen(*env) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    return write_check_error(fd, args, strlen(args)+1); \/\/ +1 for null char\n+  }\n+\n+  bool read_from(int fd);\n+\n+};\n+\n+class VM_Crac: public VM_Operation {\n+  jarray _fd_arr;\n+  const bool _dry_run;\n+  bool _ok;\n+  GrowableArray<CracFailDep>* _failures;\n+  CracRestoreParameters _restore_parameters;\n+  outputStream* _ostream;\n+  LinuxAttachOperation* _attach_op;\n+\n+public:\n+  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n+    _fd_arr(fd_arr),\n+    _dry_run(dry_run),\n+    _ok(false),\n+    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n+    _restore_parameters(),\n+    _ostream(jcmd_stream ? jcmd_stream : tty),\n+    _attach_op(jcmd_stream ? LinuxAttachListener::get_current_op() : NULL)\n+  { }\n+\n+  ~VM_Crac() {\n+    delete _failures;\n+  }\n+\n+  GrowableArray<CracFailDep>* failures() { return _failures; }\n+  bool ok() { return _ok; }\n+  const char* new_args() { return _restore_parameters.args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n+  virtual bool allow_nested_vm_operations() const  { return true; }\n+  VMOp_Type type() const { return VMOp_VM_Crac; }\n+  void doit();\n+  bool read_shm(int shmid);\n+\n+private:\n+  bool is_claimed_fd(int fd);\n+  bool is_socket_from_jcmd(int sock_fd);\n+  void report_ok_to_jcmd_if_any();\n+  void print_resources(const char* msg, ...);\n+  void trace_cr(const char* msg, ...);\n+};\n+\n+static const char* _crengine = NULL;\n+static char* _crengine_arg_str = NULL;\n+static unsigned int _crengine_argc = 0;\n+static const char* _crengine_args[32];\n+static jlong _restore_start_time;\n+static jlong _restore_start_nanos;\n+static FdsInfo _vm_inited_fds(false);\n+\n+\/\/ Timestamps recorded before checkpoint\n+jlong crac::checkpoint_millis;\n+jlong crac::checkpoint_nanos;\n+char crac::checkpoint_bootid[UUID_LENGTH];\n+\/\/ Value based on wall clock time difference that will guarantee monotonic\n+\/\/ System.nanoTime() close to actual wall-clock time difference.\n+jlong crac::javaTimeNanos_offset = 0;\n+\n+jlong crac::restore_start_time() {\n+  if (!_restore_start_time) {\n+    return -1;\n+  }\n+  return _restore_start_time;\n+}\n+\n+jlong crac::uptime_since_restore() {\n+  if (!_restore_start_nanos) {\n+    return -1;\n+  }\n+  return os::javaTimeNanos() - _restore_start_nanos;\n+}\n+\n+void VM_Crac::trace_cr(const char* msg, ...) {\n+  if (CRTrace) {\n+    va_list ap;\n+    va_start(ap, msg);\n+    _ostream->print(\"CR: \");\n+    _ostream->vprint_cr(msg, ap);\n+    va_end(ap);\n+  }\n+}\n+\n+void VM_Crac::print_resources(const char* msg, ...) {\n+  if (CRPrintResourcesOnCheckpoint) {\n+    va_list ap;\n+    va_start(ap, msg);\n+    _ostream->vprint(msg, ap);\n+    va_end(ap);\n+  }\n+}\n+\n+void crac::vm_create_start() {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  close_extra_descriptors();\n+  _vm_inited_fds.initialize();\n+}\n+\n+\/* taken from criu, that took this from kernel *\/\n+#define NFS_PREF \".nfs\"\n+#define NFS_PREF_LEN ((unsigned)sizeof(NFS_PREF) - 1)\n+#define NFS_FILEID_LEN ((unsigned)sizeof(uint64_t) << 1)\n+#define NFS_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n+#define NFS_LEN (NFS_PREF_LEN + NFS_FILEID_LEN + NFS_COUNTER_LEN)\n+static bool nfs_silly_rename(char* path) {\n+  char *sep = strrchr(path, '\/');\n+  char *base = sep ? sep + 1 : path;\n+  if (strncmp(base, NFS_PREF, NFS_PREF_LEN)) {\n+    return false;\n+  }\n+  for (unsigned i = NFS_PREF_LEN; i < NFS_LEN; ++i) {\n+    if (!isxdigit(base[i])) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+static int readfdlink(int fd, char *link, size_t len) {\n+  char fdpath[64];\n+  snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+  int ret = readlink(fdpath, link, len);\n+  if (ret == -1) {\n+    return ret;\n+  }\n+  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n+  return ret;\n+}\n+\n+static bool same_stat(struct stat* st1, struct stat* st2) {\n+  return st1->st_dev == st2->st_dev &&\n+         st1->st_ino == st2->st_ino;\n+}\n+\n+bool FdsInfo::same_fd(int i1, int i2) {\n+  assert(i1 < _fdinfos.length(), \"\");\n+  assert(i2 < _fdinfos.length(), \"\");\n+  fdinfo *fi1 = _fdinfos.adr_at(i1);\n+  fdinfo *fi2 = _fdinfos.adr_at(i2);\n+  if (!same_stat(&fi1->stat, &fi2->stat)) {\n+    return false;\n+  }\n+\n+  int flags1 = fcntl(fi1->fd, F_GETFL);\n+  int flags2 = fcntl(fi2->fd, F_GETFL);\n+  if (flags1 != flags2) {\n+    return false;\n+  }\n+\n+  const int test_flag = O_NONBLOCK;\n+  const int new_flags1 = flags1 ^ test_flag;\n+  fcntl(fi1->fd, F_SETFL, new_flags1);\n+  if (fcntl(fi1->fd, F_GETFL) != new_flags1) {\n+    \/\/ flag write ignored or handled differently,\n+    \/\/ don't know what to do\n+    return false;\n+  }\n+\n+  const int new_flags2 = fcntl(fi2->fd, F_GETFL);\n+  const bool are_same = new_flags1 == new_flags2;\n+\n+  fcntl(fi2->fd, flags1);\n+\n+  return are_same;\n+}\n+\n+void FdsInfo::initialize() {\n+  assert(!_inited, \"should be called only once\");\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  int dfd = dirfd(dir);\n+  while (dp = readdir(dir)) {\n+    if (dp->d_name[0] == '.') {\n+      \/\/ skip \".\" and \"..\"\n+      continue;\n+    }\n+    fdinfo info;\n+    info.fd = atoi(dp->d_name);\n+    if (info.fd == dfd) {\n+      continue;\n+    }\n+    int r = fstat(info.fd, &info.stat);\n+    if (r == -1) {\n+      info.state = CLOSED;\n+      continue;\n+    }\n+    info.state = ROOT; \/\/ can be changed to DUP_OF_0 + N below\n+    info.mark = 0;\n+    _fdinfos.append(info);\n+  }\n+  closedir(dir);\n+  _inited = true;\n+\n+  for (int i = 0; i < _fdinfos.length(); ++i) {\n+    fdinfo *info = _fdinfos.adr_at(i);\n+    for (int j = 0; j < i; ++j) {\n+      if (get_state(j) == ROOT && same_fd(i, j)) {\n+        info->state = (state_t)(DUP_OF_0 + j);\n+        break;\n+      }\n+    }\n+\n+    if (info->state == ROOT) {\n+      char fdpath[PATH_MAX];\n+      int r = readfdlink(info->fd, fdpath, sizeof(fdpath));\n+      guarantee(-1 != r, \"can't stat fd\");\n+      if (info->stat.st_nlink == 0 ||\n+          strstr(fdpath, \"(deleted)\") ||\n+          nfs_silly_rename(fdpath)) {\n+        info->mark |= FdsInfo::M_CANT_RESTORE;\n+      }\n+    }\n+  }\n+}\n+\n+static int cr_util_path(char* path, int len) {\n+  os::jvm_path(path, len);\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\"\n+  char *after_elem = NULL;\n+  for (int i = 0; i < 2; ++i) {\n+    after_elem = strrchr(path, '\/');\n+    *after_elem = '\\0';\n+  }\n+  return after_elem - path;\n+}\n+\n+static bool compute_crengine() {\n+  \/\/ release possible old copies\n+  os::free((char *) _crengine); \/\/ NULL is allowed\n+  _crengine = NULL;\n+  os::free((char *) _crengine_arg_str);\n+  _crengine_arg_str = NULL;\n+\n+  if (!CREngine) {\n+    return true;\n+  }\n+  char *exec = os::strdup_check_oom(CREngine);\n+  char *comma = strchr(exec, ',');\n+  if (comma != NULL) {\n+    *comma = '\\0';\n+    _crengine_arg_str = os::strdup_check_oom(comma + 1);\n+  }\n+  if (exec[0] == '\/') {\n+    _crengine = exec;\n+  } else {\n+    char path[JVM_MAXPATHLEN];\n+    int pathlen = cr_util_path(path, sizeof(path));\n+    strcat(path + pathlen, \"\/\");\n+    strcat(path + pathlen, exec);\n+\n+    struct stat st;\n+    if (0 != stat(path, &st)) {\n+      warning(\"Could not find %s: %s\", path, strerror(errno));\n+      return false;\n+    }\n+    _crengine = os::strdup_check_oom(path);\n+    \/\/ we have read and duplicated args from exec, now we can release\n+    os::free(exec);\n+  }\n+  _crengine_args[0] = _crengine;\n+  _crengine_argc = 2;\n+\n+  if (_crengine_arg_str != NULL) {\n+    char *arg = _crengine_arg_str;\n+    char *target = _crengine_arg_str;\n+    bool escaped = false;\n+    for (char *c = arg; *c != '\\0'; ++c) {\n+      if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 2) {\n+        warning(\"Too many options to CREngine; cannot proceed with these: %s\", arg);\n+        return false;\n+      }\n+      if (!escaped) {\n+        switch(*c) {\n+        case '\\\\':\n+          escaped = true;\n+          continue; \/\/ for\n+        case ',':\n+          *target++ = '\\0';\n+          _crengine_args[_crengine_argc++] = arg;\n+          arg = target;\n+          continue; \/\/ for\n+        }\n+      }\n+      escaped = false;\n+      *target++ = *c;\n+    }\n+    *target = '\\0';\n+    _crengine_args[_crengine_argc++] = arg;\n+    _crengine_args[_crengine_argc] = NULL;\n+  }\n+  return true;\n+}\n+\n+static void add_crengine_arg(const char *arg) {\n+  if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 1) {\n+      warning(\"Too many options to CREngine; cannot add %s\", arg);\n+      return;\n+  }\n+  _crengine_args[_crengine_argc++] = arg;\n+  _crengine_args[_crengine_argc] = NULL;\n+}\n+\n+static int call_crengine() {\n+  if (!_crengine) {\n+    return -1;\n+  }\n+\n+  pid_t pid = fork();\n+  if (pid == -1) {\n+    perror(\"cannot fork for crengine\");\n+    return -1;\n+  }\n+  if (pid == 0) {\n+    _crengine_args[1] = \"checkpoint\";\n+    add_crengine_arg(CRaCCheckpointTo);\n+    execv(_crengine, (char * const*)_crengine_args);\n+    perror(\"execv CREngine checkpoint\");\n+    exit(1);\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return -1;\n+  }\n+  return WEXITSTATUS(status) == 0 ? 0 : -1;\n+}\n+\n+class CracSHM {\n+  char _path[128];\n+public:\n+  CracSHM(int id) {\n+    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n+    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n+      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    }\n+  }\n+\n+  int open(int mode) {\n+    int shmfd = shm_open(_path, mode, 0600);\n+    if (-1 == shmfd) {\n+      perror(\"shm_open\");\n+    }\n+    return shmfd;\n+  }\n+\n+  void unlink() {\n+    shm_unlink(_path);\n+  }\n+};\n+\n+static int checkpoint_restore(int *shmid) {\n+  crac::record_time_before_checkpoint();\n+\n+  int cres = call_crengine();\n+  if (cres < 0) {\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  sigset_t waitmask;\n+  sigemptyset(&waitmask);\n+  sigaddset(&waitmask, RESTORE_SIGNAL);\n+\n+  siginfo_t info;\n+  int sig;\n+  do {\n+    sig = sigwaitinfo(&waitmask, &info);\n+  } while (sig == -1 && errno == EINTR);\n+  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n+\n+  if (CRaCCPUCountInit) {\n+    os::Linux::initialize_cpu_count();\n+  }\n+\n+  crac::update_javaTimeNanos_offset();\n+\n+  if (CRTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n+  }\n+\n+  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n+    tty->print(\"JVM: invalid info for restore provided: %s\", info.si_code == SI_QUEUE ? \"queued\" : \"not queued\");\n+    if (info.si_code == SI_QUEUE) {\n+      tty->print(\" code %d\", info.si_int);\n+    }\n+    tty->cr();\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  if (0 < info.si_int) {\n+    *shmid = info.si_int;\n+  }\n+\n+  return JVM_CHECKPOINT_OK;\n+}\n+\n+static const char* stat2strtype(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK: return \"socket\";\n+  case S_IFLNK:  return \"symlink\";\n+  case S_IFREG:  return \"regular\";\n+  case S_IFBLK:  return \"block\";\n+  case S_IFDIR:  return \"directory\";\n+  case S_IFCHR:  return \"character\";\n+  case S_IFIFO:  return \"fifo\";\n+  default:       break;\n+  }\n+  return \"unknown\";\n+}\n+\n+static int stat2stfail(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK:\n+    return JVM_CR_FAIL_SOCK;\n+  case S_IFLNK:\n+  case S_IFREG:\n+  case S_IFBLK:\n+  case S_IFDIR:\n+  case S_IFCHR:\n+    return JVM_CR_FAIL_FILE;\n+  case S_IFIFO:\n+    return JVM_CR_FAIL_PIPE;\n+  default:\n+    break;\n+  }\n+  return JVM_CR_FAIL;\n+}\n+\n+bool VM_Crac::read_shm(int shmid) {\n+  CracSHM shm(shmid);\n+  int shmfd = shm.open(O_RDONLY);\n+  shm.unlink();\n+  if (shmfd < 0) {\n+    return false;\n+  }\n+  bool ret = _restore_parameters.read_from(shmfd);\n+  close(shmfd);\n+  return ret;\n+}\n+\n+\/\/ If checkpoint is called throught the API, jcmd operation and jcmd output doesn't exist.\n+bool VM_Crac::is_socket_from_jcmd(int sock) {\n+  if (_attach_op == NULL)\n+    return false;\n+  int sock_fd = _attach_op->socket();\n+  return sock == sock_fd;\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+  if (_attach_op == NULL)\n+    return;\n+  bufferedStream* buf = static_cast<bufferedStream*>(_ostream);\n+  _attach_op->effectively_complete_raw(JNI_OK, buf);\n+  \/\/ redirect any further output to console\n+  _ostream = tty;\n+}\n+\n+bool VM_Crac::is_claimed_fd(int fd) {\n+  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n+  for (int j = 0; j < claimed_fds->length(); ++j) {\n+    jint cfd = claimed_fds->int_at(j);\n+    if (fd == cfd) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void VM_Crac::doit() {\n+\n+  AttachListener::abort();\n+\n+  FdsInfo fds;\n+\n+  bool ok = true;\n+\n+  for (int i = 0; i < fds.len(); ++i) {\n+    if (fds.get_state(i) == FdsInfo::CLOSED) {\n+      continue;\n+    }\n+    int fd = fds.get_fd(i);\n+\n+    char detailsbuf[PATH_MAX];\n+    struct stat* st = fds.get_stat(i);\n+    const char* type = stat2strtype(st->st_mode);\n+    int linkret = readfdlink(fd, detailsbuf, sizeof(detailsbuf));\n+    const char* details = 0 < linkret ? detailsbuf : \"\";\n+    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\" \", fd, type, details);\n+\n+    if (is_claimed_fd(fd)) {\n+      print_resources(\"OK: claimed by java code\\n\");\n+      continue;\n+    }\n+\n+    if (_vm_inited_fds.find_state(fd, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n+      print_resources(\"OK: inherited from process env\\n\");\n+      continue;\n+    }\n+\n+    if (S_ISSOCK(st->st_mode)) {\n+      if (is_socket_from_jcmd(fd)){\n+        print_resources(\"OK: jcmd socket\\n\");\n+        continue;\n+      }\n+    }\n+\n+    print_resources(\"BAD: opened by application\\n\");\n+    ok = false;\n+\n+    const int maxinfo = 64;\n+    size_t buflen = strlen(details) + maxinfo;\n+    char* msg = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n+    int len = snprintf(msg, buflen, \"FD fd=%d type=%s path=%s\", fd, type, detailsbuf);\n+    msg[len < 0 ? 0 : ((size_t) len >= buflen ? buflen - 1 : len)] = '\\0';\n+    _failures->append(CracFailDep(stat2stfail(st->st_mode & S_IFMT), msg));\n+  }\n+\n+  if ((!ok || _dry_run) && CRHeapDumpOnCheckpointException) {\n+    HeapDumper::dump_heap();\n+  }\n+\n+  if (!ok && CRDoThrowCheckpointException) {\n+    return;\n+  } else if (_dry_run) {\n+    _ok = ok;\n+    return;\n+  }\n+\n+  if (!PerfMemoryLinux::checkpoint(CRaCCheckpointTo)) {\n+    return;\n+  }\n+\n+  int shmid = 0;\n+  if (CRAllowToSkipCheckpoint) {\n+    trace_cr(\"Skip Checkpoint\");\n+  } else {\n+    trace_cr(\"Checkpoint ...\");\n+    report_ok_to_jcmd_if_any();\n+    int ret = checkpoint_restore(&shmid);\n+    if (ret == JVM_CHECKPOINT_ERROR) {\n+      PerfMemoryLinux::restore();\n+      return;\n+    }\n+  }\n+\n+  VM_Version::crac_restore();\n+\n+  if (shmid <= 0 || !VM_Crac::read_shm(shmid)) {\n+    _restore_start_time = os::javaTimeMillis();\n+    _restore_start_nanos = os::javaTimeNanos();\n+  } else {\n+    _restore_start_nanos += crac::monotonic_time_offset();\n+  }\n+  PerfMemoryLinux::restore();\n+\n+  _ok = true;\n+}\n+\n+bool crac::prepare_checkpoint() {\n+  struct stat st;\n+\n+  if (0 == stat(CRaCCheckpointTo, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      warning(\"%s: not a directory\", CRaCCheckpointTo);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == mkdir(CRaCCheckpointTo, 0700)) {\n+      warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+      return false;\n+    }\n+    if (-1 == rmdir(CRaCCheckpointTo)) {\n+      warning(\"cannot cleanup after check: %s\", strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+\n+  if (!compute_crengine()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n+  objArrayHandle bundle(THREAD, bundleObj);\n+  jvalue jval = { .i = ret };\n+  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n+  bundle->obj_at_put(0, retObj);\n+  bundle->obj_at_put(1, new_args());\n+  bundle->obj_at_put(2, new_props());\n+  bundle->obj_at_put(3, err_codes());\n+  bundle->obj_at_put(4, err_msgs());\n+  return bundle;\n+}\n+\n+\/** Checkpoint main entry.\n+ *\/\n+Handle crac::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n+  if (!CRaCCheckpointTo) {\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+  if (-1 == mkdir(CRaCCheckpointTo, 0700) && errno != EEXIST) {\n+    warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+  Universe::heap()->set_cleanup_unused(true);\n+  Universe::heap()->collect(GCCause::_full_gc_alot);\n+  Universe::heap()->set_cleanup_unused(false);\n+\n+  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    VMThread::execute(&cr);\n+  }\n+  if (cr.ok()) {\n+    oop new_args = NULL;\n+    if (cr.new_args()) {\n+      new_args = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n+    }\n+    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n+    objArrayHandle props(THREAD, propsObj);\n+\n+    for (int i = 0; i < new_properties->length(); i++) {\n+      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n+      props->obj_at_put(i, propObj);\n+    }\n+    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n+  }\n+\n+  GrowableArray<CracFailDep>* failures = cr.failures();\n+\n+  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n+  typeArrayHandle codes(THREAD, codesObj);\n+  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n+  objArrayHandle msgs(THREAD, msgsObj);\n+\n+  for (int i = 0; i < failures->length(); ++i) {\n+    codes->int_at_put(i, failures->at(i)._type);\n+    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n+    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n+    msgs->obj_at_put(i, msgObj);\n+  }\n+\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n+}\n+\n+void crac::restore() {\n+  struct stat st;\n+\n+  jlong restore_time = os::javaTimeMillis();\n+  jlong restore_nanos = os::javaTimeNanos();\n+\n+  compute_crengine();\n+\n+  int id = getpid();\n+  CracSHM shm(id);\n+  int shmfd = shm.open(O_RDWR | O_CREAT);\n+  if (0 <= shmfd) {\n+    if (CracRestoreParameters::write_to(\n+          shmfd,\n+          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n+          Arguments::system_properties(),\n+          Arguments::java_command() ? Arguments::java_command() : \"\",\n+          restore_time,\n+          restore_nanos)) {\n+      char strid[32];\n+      snprintf(strid, sizeof(strid), \"%d\", id);\n+      setenv(\"CRAC_NEW_ARGS_ID\", strid, true);\n+    }\n+    close(shmfd);\n+  }\n+\n+\n+  if (_crengine) {\n+    _crengine_args[1] = \"restore\";\n+    add_crengine_arg(CRaCRestoreFrom);\n+    execv(_crengine, (char * const*) _crengine_args);\n+    warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", _crengine, strerror(errno));\n+  }\n+}\n+\n+static char modules_path[JVM_MAXPATHLEN] = { '\\0' };\n+\n+static bool is_fd_ignored(int fd, const char *path) {\n+  const char *list = CRaCIgnoredFileDescriptors;\n+  while (list && *list) {\n+    const char *end = strchr(list, ',');\n+    if (!end) {\n+      end = list + strlen(list);\n+    }\n+    char *invalid;\n+    int ignored_fd = strtol(list, &invalid, 10);\n+    if (invalid == end) { \/\/ entry was integer -> file descriptor\n+      if (fd == ignored_fd) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    } else { \/\/ interpret entry as path\n+      int path_len = path ? strlen(path) : -1;\n+      if (path_len != -1 && path_len == end - list && !strncmp(path, list, end - list)) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    }\n+    if (*end) {\n+      list = end + 1;\n+    } else {\n+      break;\n+    }\n+  }\n+\n+  if (os::same_files(modules_path, path)) {\n+    \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+    \/\/ We can ignore this for purposes of CRaC.\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void crac::close_extra_descriptors() {\n+  \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+  \/\/ We can ignore this for purposes of CRaC.\n+  if (modules_path[0] == '\\0') {\n+    const char* fileSep = os::file_separator();\n+    jio_snprintf(modules_path, JVM_MAXPATHLEN, \"%s%slib%s\" MODULES_IMAGE_NAME, Arguments::get_java_home(), fileSep, fileSep);\n+  }\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  while (dp = readdir(dir)) {\n+    int fd = atoi(dp->d_name);\n+    if (fd > 2 && fd != dirfd(dir)) {\n+      int r = readfdlink(fd, path, sizeof(path));\n+      if (!is_fd_ignored(fd, r != -1 ? path : nullptr)) {\n+        log_warning(os)(\"CRaC closing file descriptor %d: %s\", fd, path);\n+        close(fd);\n+      }\n+    }\n+  }\n+  closedir(dir);\n+}\n+\n+bool CracRestoreParameters::read_from(int fd) {\n+  struct stat st;\n+  if (fstat(fd, &st)) {\n+    perror(\"fstat (ignoring restore parameters)\");\n+    return false;\n+  }\n+\n+  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+  if (read(fd, contents, st.st_size) < 0) {\n+    perror(\"read (ignoring restore parameters)\");\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return false;\n+  }\n+\n+  _raw_content = contents;\n+\n+  \/\/ parse the contents to read new system properties and arguments\n+  header* hdr = (header*)_raw_content;\n+  char* cursor = _raw_content + sizeof(header);\n+\n+  ::_restore_start_time = hdr->_restore_time;\n+  ::_restore_start_nanos = hdr->_restore_nanos;\n+\n+  for (int i = 0; i < hdr->_nflags; i++) {\n+    FormatBuffer<80> err_msg(\"%s\", \"\");\n+    JVMFlag::Error result;\n+    const char *name = cursor;\n+    if (*cursor == '+' || *cursor == '-') {\n+      name = cursor + 1;\n+      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n+        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+      cursor += strlen(cursor) + 1;\n+    } else {\n+      char* eq = strchrnul(cursor, '=');\n+      if (*eq == '\\0') {\n+        result = JVMFlag::Error::MISSING_VALUE;\n+        cursor = eq + 1;\n+      } else {\n+        *eq = '\\0';\n+        char* value = eq + 1;\n+        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+        cursor = value + strlen(value) + 1;\n+      }\n+    }\n+    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %s\",\n+        name, JVMFlag::flag_error_str(result));\n+  }\n+\n+  for (int i = 0; i < hdr->_nprops; i++) {\n+    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+    int idx = _properties->append(cursor);\n+    int prop_len = strlen(cursor) + 1;\n+    cursor = cursor + prop_len;\n+  }\n+\n+  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n+  memcpy(env_mem, cursor, hdr->_env_memory_size);\n+\n+  const char* env_end = env_mem + hdr->_env_memory_size;\n+  while (env_mem < env_end) {\n+    const size_t s = strlen(env_mem) + 1;\n+    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n+    putenv(env_mem);\n+    env_mem += s;\n+  }\n+  cursor += hdr->_env_memory_size;\n+\n+  _args = cursor;\n+  return true;\n+}\n+\n+void crac::record_time_before_checkpoint() {\n+  checkpoint_millis = os::javaTimeMillis();\n+  checkpoint_nanos = os::javaTimeNanos();\n+  memset(checkpoint_bootid, 0, UUID_LENGTH);\n+  read_bootid(checkpoint_bootid);\n+}\n+\n+void crac::update_javaTimeNanos_offset() {\n+  char buf[UUID_LENGTH];\n+  \/\/ We will change the nanotime offset only if this is not the same boot\n+  \/\/ to prevent reducing the accuracy of System.nanoTime() unnecessarily.\n+  \/\/ It is possible that in a real-world case the boot_id does not change\n+  \/\/ (containers keep the boot_id) - but the monotonic time changes. We will\n+  \/\/ only guarantee that the nanotime does not go backwards in that case but\n+  \/\/ won't offset the time based on wall-clock time as this change in monotonic\n+  \/\/ time is likely intentional.\n+  if (!read_bootid(buf) || memcmp(buf, checkpoint_bootid, UUID_LENGTH) != 0) {\n+    assert(checkpoint_millis >= 0, \"Restore without a checkpoint?\");\n+    long diff_millis = os::javaTimeMillis() - checkpoint_millis;\n+    \/\/ If the wall clock has gone backwards we won't add it to the offset\n+    if (diff_millis < 0) {\n+      diff_millis = 0;\n+    }\n+    \/\/ javaTimeNanos() call on the second line below uses the *_offset, so we will zero\n+    \/\/ it to make the call return true monotonic time rather than the adjusted value.\n+    javaTimeNanos_offset = 0;\n+    javaTimeNanos_offset = checkpoint_nanos - os::javaTimeNanos() + diff_millis * 1000000L;\n+  } else {\n+    \/\/ ensure monotonicity even if this looks like the same boot\n+    jlong diff = os::javaTimeNanos() - checkpoint_nanos;\n+    if (diff < 0) {\n+      javaTimeNanos_offset -= diff;\n+    }\n+  }\n+}\n+\n+static bool read_all(int fd, char *dest, size_t n) {\n+  size_t rd = 0;\n+  do {\n+    ssize_t r = ::read(fd, dest + rd, n - rd);\n+    if (r == 0) {\n+      return false;\n+    } else if (r < 0) {\n+      if (errno == EINTR) {\n+        continue;\n+      }\n+      return false;\n+    }\n+    rd += r;\n+  } while (rd < n);\n+  return true;\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  int fd = ::open(\"\/proc\/sys\/kernel\/random\/boot_id\", O_RDONLY);\n+  if (fd < 0 || !read_all(fd, dest, UUID_LENGTH)) {\n+    perror(\"CRaC: Cannot read system boot ID\");\n+    return false;\n+  }\n+  char c;\n+  if (!read_all(fd, &c, 1) || c != '\\n') {\n+    perror(\"CRaC: system boot ID does not end with newline\");\n+    return false;\n+  }\n+  if (::read(fd, &c, 1) != 0) {\n+    perror(\"CRaC: Unexpected data\/error reading system boot ID\");\n+    return false;\n+  }\n+  if (::close(fd) != 0) {\n+    perror(\"CRaC: Cannot close system boot ID file\");\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":1153,"deletions":0,"binary":false,"changes":1153,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_HPP\n+#define SHARE_RUNTIME_CRAC_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n+#define UUID_LENGTH 36\n+\n+class crac: AllStatic {\n+public:\n+  static void vm_create_start();\n+  static bool prepare_checkpoint();\n+  static Handle checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS);\n+  static void restore();\n+  static void close_extra_descriptors();\n+\n+  static jlong restore_start_time();\n+  static jlong uptime_since_restore();\n+\n+  static void record_time_before_checkpoint();\n+  static void update_javaTimeNanos_offset();\n+\n+  static jlong monotonic_time_offset() {\n+    return javaTimeNanos_offset;\n+  }\n+\n+private:\n+  static bool read_bootid(char *dest);\n+\n+  static jlong checkpoint_millis;\n+  static jlong checkpoint_nanos;\n+  static char checkpoint_bootid[UUID_LENGTH];\n+  static jlong javaTimeNanos_offset;\n+};\n+\n+#endif \/\/SHARE_RUNTIME_CRAC_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -85,8 +85,0 @@\n-\/\/ Timestamps recorded before checkpoint\n-jlong os::checkpoint_millis;\n-jlong os::checkpoint_nanos;\n-char os::checkpoint_bootid[UUID_LENGTH];\n-\/\/ Value based on wall clock time difference that will guarantee monotonic\n-\/\/ System.nanoTime() close to actual wall-clock time difference.\n-jlong os::javaTimeNanos_offset = 0;\n-\n@@ -2034,36 +2026,0 @@\n-\n-void os::record_time_before_checkpoint() {\n-  checkpoint_millis = javaTimeMillis();\n-  checkpoint_nanos = javaTimeNanos();\n-  memset(checkpoint_bootid, 0, UUID_LENGTH);\n-  read_bootid(checkpoint_bootid);\n-}\n-\n-void os::update_javaTimeNanos_offset() {\n-  char buf[UUID_LENGTH];\n-  \/\/ We will change the nanotime offset only if this is not the same boot\n-  \/\/ to prevent reducing the accuracy of System.nanoTime() unnecessarily.\n-  \/\/ It is possible that in a real-world case the boot_id does not change\n-  \/\/ (containers keep the boot_id) - but the monotonic time changes. We will\n-  \/\/ only guarantee that the nanotime does not go backwards in that case but\n-  \/\/ won't offset the time based on wall-clock time as this change in monotonic\n-  \/\/ time is likely intentional.\n-  if (!read_bootid(buf) || memcmp(buf, checkpoint_bootid, UUID_LENGTH) != 0) {\n-    assert(checkpoint_millis >= 0, \"Restore without a checkpoint?\");\n-    long diff_millis = javaTimeMillis() - checkpoint_millis;\n-    \/\/ If the wall clock has gone backwards we won't add it to the offset\n-    if (diff_millis < 0) {\n-      diff_millis = 0;\n-    }\n-    \/\/ javaTimeNanos() call on the second line below uses the *_offset, so we will zero\n-    \/\/ it to make the call return true monotonic time rather than the adjusted value.\n-    javaTimeNanos_offset = 0;\n-    javaTimeNanos_offset = checkpoint_nanos - javaTimeNanos() + diff_millis * 1000000L;\n-  } else {\n-    \/\/ ensure monotonicity even if this looks like the same boot\n-    jlong diff = javaTimeNanos() - checkpoint_nanos;\n-    if (diff < 0) {\n-      javaTimeNanos_offset -= diff;\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -85,3 +85,0 @@\n-\/\/ xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n-#define UUID_LENGTH 36\n-\n@@ -136,5 +133,0 @@\n-  static jlong checkpoint_millis;\n-  static jlong checkpoint_nanos;\n-  static char checkpoint_bootid[UUID_LENGTH];\n-  static jlong javaTimeNanos_offset;\n-\n@@ -185,2 +177,0 @@\n-  static bool read_bootid(char *dest);\n-\n@@ -212,6 +202,0 @@\n-  static void record_time_before_checkpoint();\n-  static void update_javaTimeNanos_offset();\n-  static jlong monotonic_time_offset() {\n-    return javaTimeNanos_offset;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -2712,1 +2713,1 @@\n-    os::Linux::restore();\n+    crac::restore();\n@@ -2788,1 +2789,1 @@\n-  os::Linux::vm_create_start();\n+  crac::vm_create_start();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -957,1 +958,1 @@\n-    return os::Linux::restore_start_time();\n+    return crac::restore_start_time();\n@@ -961,1 +962,1 @@\n-      jlong ticks = os::Linux::uptime_since_restore();\n+      jlong ticks = crac::uptime_since_restore();\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}