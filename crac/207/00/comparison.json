{"files":[{"patch":"@@ -318,0 +318,3 @@\n+################################################################################\n+# Setup CRaC CRIU\n+################################################################################\n","filename":"make\/autoconf\/lib-bundled.m4","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,0 +203,14 @@\n+\n+################################################################################\n+# Build checkpoint\/restore exec library\n+################################################################################\n+\n+# CFLAGS_windows from make\/autoconf\/flags-cflags.m4#FLAGS_SETUP_CFLAGS_HELPER\n+$(eval $(call SetupJdkLibrary, BUILD_LIBCREXEC, \\\n+    NAME := crexec, \\\n+    EXTRA_HEADER_DIRS := libjvm, \\\n+    CFLAGS := $(CFLAGS_JDKLIB) -DCRLIB_IS_IMPL, \\\n+    CFLAGS_windows := -D_WINDOWS -DWIN32, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB), \\\n+))\n+TARGETS += $(BUILD_LIBCREXEC)\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2051,26 +2051,0 @@\n-int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n-  char** env = os::get_environ();\n-\n-  pid_t pid = fork();\n-  if (pid == -1) {\n-    perror(\"cannot fork for subprocess\");\n-    return -1;\n-  }\n-  if (pid == 0) {\n-    execve(path, (char* const*)argv, env);\n-    perror(\"execve\");\n-    exit(1);\n-  }\n-\n-  int status;\n-  int ret;\n-  do {\n-    ret = waitpid(pid, &status, 0);\n-  } while (ret == -1 && errno == EINTR);\n-\n-  if (ret == -1 || !WIFEXITED(status)) {\n-    return -1;\n-  }\n-  return WEXITSTATUS(status) == 0 ? 0 : -1;\n-}\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1372,0 +1372,4 @@\n+  \/\/ We cannot keep the filename because some C\/R engines might not preserve PID numbers\n+  \/\/ Also, username might change.\n+  FREE_C_HEAP_ARRAY(char, backing_store_file_name);\n+  backing_store_file_name = nullptr;\n@@ -1377,1 +1381,3 @@\n-  if (!backing_store_file_name) {\n+  assert(backing_store_file_name == nullptr, \"Should be nil'ed on checkpoint\");\n+  \/\/ With -XX:-UsePerfData the capacity is zero\n+  if (PerfDisableSharedMem || PerfMemory::capacity() == 0) {\n@@ -1380,1 +1386,0 @@\n-\n@@ -1390,0 +1395,1 @@\n+  backing_store_file_name = get_sharedmem_filename(dirname, vmid, -1);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1545,1 +1545,9 @@\n-  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+  \/\/ The signal is used with default crexec library, other CRaCEngines might use\n+  \/\/ signals in a different way and having this signal blocked could interfere.\n+  const char *signal_engines[] = { \"criu\", \"criuengine\", \"sim\", \"simengine\", \"pause\", \"pauseengine\", NULL };\n+  for (int i = 0; signal_engines[i] != NULL; ++i) {\n+    if (strcmp(CRaCEngine, signal_engines[i]) == 0) {\n+      sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+      break;\n+    }\n+  }\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5761,5 +5761,0 @@\n-int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n-  const int status = _spawnv(_P_WAIT, path, argv); \/\/ env is inherited by a child process\n-  return 0 == status ? 0 : -1;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CRLIB_H\n+#define CRLIB_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/\/ Configuration storage used by CRaC engine to persist data between API calls.\n+typedef struct crlib_conf crlib_conf_t;\n+\n+\/\/ The first member in an actual structure defining an extension of CRaC engine API.\n+typedef struct crlib_extension {\n+  \/\/ Name of the extension.\n+  \/\/ If there is a non-backwards compatible change in the extension (from API point of view) the\n+  \/\/ name should be changed, e.g. foo -> foo:v2.\n+  const char *name;\n+  \/\/ Size of the full extension structure, in bytes.\n+  \/\/ Adding members to the end of the full structure is considered a backwards-compatible change.\n+  size_t size;\n+} crlib_extension_t;\n+\n+\/\/ CRaC engine API.\n+\/\/\n+\/\/ Unless noted otherwise, the engine should copy data passed through these methods into the\n+\/\/ configuration storage if it needs to keep it.\n+struct crlib_api {\n+  \/\/ Initializes a configuration structure.\n+  crlib_conf_t *(*create_conf)();\n+  \/\/ Destroys a configuration structure. The argument can be null.\n+  void (*destroy_conf)(crlib_conf_t *);\n+\n+  \/\/ Triggers a checkpoint. Returns zero on success.\n+  int (*checkpoint)(crlib_conf_t *);\n+  \/\/ Triggers a restore. Does not normally return, but if it does returns a error code.\n+  int (*restore)(crlib_conf_t *);\n+\n+  \/\/ Returns true if the given configuration key is supported by the engine, false otherwise.\n+  \/\/ Key is a valid C-string.\n+  \/\/ Use of this before configuring is not a requirement.\n+  bool (*can_configure)(crlib_conf_t *, const char *key);\n+  \/\/ Sets a configuration option. Returns true on success.\n+  \/\/ Key and value are valid C-strings.\n+  bool (*configure)(crlib_conf_t *, const char *key, const char *value);\n+\n+  \/\/ Returns an API extension with the given name (C-string) and size, or null if an extension with\n+  \/\/ such name is not present or its size is lower than requested.\n+  \/\/ The extension should have static storage duration. The application is supposed to cast it to\n+  \/\/ the actual extension type.\n+  const crlib_extension_t *(*get_extension)(const char *name, size_t size);\n+};\n+typedef const struct crlib_api crlib_api_t;\n+\n+#define CRLIB_API crlib_api\n+#define CRLIB_API_FUNC \"crlib_api\"\n+\n+#define CRLIB_API_VERSION 2\n+\n+#if defined(WINDOWS) || defined(_WINDOWS)\n+  #ifdef CRLIB_IS_IMPL\n+    #define IMPORTEXPORT __declspec(dllexport)\n+  #else\n+    #define IMPORTEXPORT __declspec(dllimport)\n+  #endif\n+#else\n+  #define IMPORTEXPORT\n+#endif\n+\n+\/\/ Returns a CRaC API of the given version and size, or null if such API version is not supported\n+\/\/ or its size is lower than requested.\n+\/\/ The API should have static storage duration.\n+extern IMPORTEXPORT crlib_api_t *CRLIB_API(int api_version, size_t api_size);\n+\n+#define CRLIB_EXTENSION(api, type, name) ((type *) (api)->get_extension(name, sizeof(type)))\n+\n+#ifdef __cplusplus\n+} \/\/ extern \"C\"\n+#endif\n+\n+#endif \/\/ CRLIB_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib.h","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CRLIB_RESTORE_DATA_H\n+#define CRLIB_RESTORE_DATA_H\n+\n+#include \"crlib.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CRLIB_EXTENSION_RESTORE_DATA_NAME \"restore data\"\n+#define CRLIB_EXTENSION_RESTORE_DATA(api) \\\n+  CRLIB_EXTENSION(api, crlib_restore_data_t, CRLIB_EXTENSION_RESTORE_DATA_NAME)\n+\n+\/\/ API for passing data from a restoring application to a restored application.\n+struct crlib_restore_data {\n+  crlib_extension_t header;\n+\n+  \/\/ Called by the restoring application to pass data to the restored application.\n+  \/\/ 'data' must not be null, size must be greater than 0.\n+  \/\/ The engine may impose limits on the data size and return false if it is not accepted.\n+  bool (*set_restore_data)(crlib_conf_t *, const void *data, size_t size);\n+\n+  \/\/ Called by the restored application to retrieve the data passed by the restoring application.\n+  \/\/ Copies up to 'size' > 0 bytes of the data into 'buf' != null.\n+  \/\/ Returns the size of the data the engine has, in bytes — it can be more, equal to or less than\n+  \/\/ 'size'. Returned value of 0 represents an error.\n+  size_t (*get_restore_data)(crlib_conf_t *, void *buf, size_t size);\n+};\n+typedef const struct crlib_restore_data crlib_restore_data_t;\n+\n+#ifdef __cplusplus\n+} \/\/ extern \"C\"\n+#endif\n+\n+#endif \/\/ CRLIB_RESTORE_DATA_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib_restore_data.h","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -81,0 +81,1 @@\n+#include <type_traits>\n@@ -2193,2 +2194,10 @@\n-    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n-      return true;\n+    if (!match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      continue;\n+    }\n+    \/\/ ccstr is never set to an empty string by the parser so we should not\n+    \/\/ treat an empty string value as the option being set. If it ever becomes\n+    \/\/ ccstrlist or the parser changes, the value check will need to be removed.\n+    static_assert(std::is_same<ccstr, decltype(CRaCRestoreFrom)>(), \"expected ccstr\");\n+    const char* eq = strchr(tail, '=');\n+    if (eq != nullptr && eq[1] != '\\0') {\n+      return true; \/\/ the value is not an empty string\n@@ -2229,0 +2238,4 @@\n+\n+      if (key != tail) { \/\/ key was copied\n+        FreeHeap(const_cast<char *>(key));\n+      }\n@@ -2230,2 +2243,0 @@\n-      \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n-      \/\/ already been handled\n@@ -2250,0 +2261,3 @@\n+\n+  postcond(CRaCRestoreFrom != nullptr);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n@@ -29,0 +31,1 @@\n+#include \"logging\/log.hpp\"\n@@ -31,0 +34,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -36,0 +40,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -40,1 +45,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -47,0 +51,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -48,4 +53,0 @@\n-static const char* _crengine = NULL;\n-static char* _crengine_arg_str = NULL;\n-static unsigned int _crengine_argc = 0;\n-static const char* _crengine_args[32];\n@@ -55,0 +56,1 @@\n+const crac::EngineHandle *crac::_engine = nullptr;\n@@ -100,8 +102,5 @@\n-static size_t cr_util_path(char* path, int len) {\n-  os::jvm_path(path, len);\n-  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n-  assert(1 == strlen(os::file_separator()), \"file separator must be a single-char, not a string\");\n-  char *after_elem = NULL;\n-  for (int i = 0; i < 2; ++i) {\n-    after_elem = strrchr(path, *os::file_separator());\n-    *after_elem = '\\0';\n+#ifdef _WINDOWS\n+static char *strsep(char **strp, const char *delim) {\n+  char *str = *strp;\n+  if (str == nullptr) {\n+    return nullptr;\n@@ -109,1 +108,8 @@\n-  return after_elem - path;\n+  size_t len = strcspn(str, delim);\n+  if (str[len] == '\\0') {\n+    *strp = nullptr;\n+    return str;\n+  }\n+  str[len] = '\\0';\n+  *strp += len + 1;\n+  return str;\n@@ -111,0 +117,15 @@\n+#endif \/\/ _WINDOWS\n+\n+class crac::EngineHandle : public CHeapObj<mtInternal> {\n+private:\n+  void *_lib = nullptr;\n+  crlib_api_t *_api = nullptr;\n+  crlib_conf_t *_conf = nullptr;\n+\n+public:\n+  \/\/ Use is_initialized() to check whether the constructor succeeded.\n+  explicit EngineHandle(bool checkpoint);\n+  ~EngineHandle();\n+\n+  crlib_api_t *api() const   { return _api; }\n+  crlib_conf_t *conf() const { return _conf; }\n@@ -112,6 +133,33 @@\n-static bool compute_crengine() {\n-  \/\/ release possible old copies\n-  os::free((char *) _crengine); \/\/ NULL is allowed\n-  _crengine = NULL;\n-  os::free((char *) _crengine_arg_str);\n-  _crengine_arg_str = NULL;\n+  bool is_initialized() const {\n+    assert((_lib == nullptr && _api == nullptr && _conf == nullptr) ||\n+           (_lib != nullptr && _api != nullptr && _conf != nullptr), \"invariant\");\n+    return _lib != nullptr;\n+  }\n+};\n+\n+static bool find_crac_engine(const char *dll_dir, char *path, size_t path_size, bool *is_library) {\n+  \/\/ Try to interpret as a file path\n+  if (os::is_path_absolute(CRaCEngine)) {\n+    const size_t path_len = strlen(CRaCEngine);\n+    if (path_len + 1 > path_size) {\n+      log_error(crac)(\"CRaCEngine file path is too long: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    if (!os::file_exists(CRaCEngine)) {\n+      log_error(crac)(\"CRaCEngine file does not exist: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    strcpy(path, CRaCEngine);\n+\n+    const char *last_slash = strrchr(CRaCEngine, *os::file_separator());\n+    const char *basename;\n+    if (last_slash == nullptr) {\n+      basename = CRaCEngine;\n+    } else {\n+      basename = last_slash + strlen(os::file_separator());\n+    }\n+    *is_library = strncmp(basename, JNI_LIB_PREFIX, strlen(JNI_LIB_PREFIX)) == 0 &&\n+      strcmp(path + path_len - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0;\n+    log_debug(crac)(\"CRaCEngine path %s is %s library\", CRaCEngine, *is_library ? \"a\" : \"not a\");\n@@ -119,1 +167,0 @@\n-  if (!CRaCEngine) {\n@@ -122,5 +169,6 @@\n-  char *exec = os::strdup_check_oom(CRaCEngine);\n-  char *comma = strchr(exec, ',');\n-  if (comma != NULL) {\n-    *comma = '\\0';\n-    _crengine_arg_str = os::strdup_check_oom(comma + 1);\n+\n+  \/\/ Try to interpret as a library name\n+  if (os::dll_locate_lib(path, path_size, dll_dir, CRaCEngine)) {\n+    *is_library = true;\n+    log_debug(crac)(\"Found CRaCEngine %s as a library in %s\", CRaCEngine, path);\n+    return true;\n@@ -128,13 +176,21 @@\n-  if (os::is_path_absolute(exec)) {\n-    _crengine = exec;\n-  } else {\n-    char path[JVM_MAXPATHLEN];\n-    size_t pathlen = cr_util_path(path, sizeof(path));\n-    strcat(path + pathlen, os::file_separator());\n-    strcat(path + pathlen, exec);\n-    WINDOWS_ONLY(strcat(path + pathlen, \".exe\"));\n-\n-    struct stat st;\n-    if (0 != os::stat(path, &st)) {\n-      warning(\"Could not find CRaCEngine %s: %s\", path, os::strerror(errno));\n-      return false;\n+\n+  *is_library = false;\n+  log_debug(crac)(\"CRaCEngine %s is not a library in %s\", CRaCEngine, dll_dir);\n+\n+#ifdef _WINDOWS\n+  const char *suffix = \".exe\";\n+#else\n+  const char *suffix = \"\";\n+#endif \/\/ ! _WINDOWS\n+#ifndef S_ISREG\n+# define S_ISREG(__mode) ((__mode & S_IFMT) == S_IFREG)\n+#endif \/\/ S_ISREG\n+  struct stat st;\n+\n+  \/\/ Try to interpret as an executable name with \"engine\" suffix omitted\n+  size_t path_len = strlen(dll_dir) + strlen(os::file_separator()) + strlen(CRaCEngine) + strlen(\"engine\") + strlen(suffix);\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%sengine%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n@@ -142,30 +198,12 @@\n-    _crengine = os::strdup_check_oom(path);\n-    \/\/ we have read and duplicated args from exec, now we can release\n-    os::free(exec);\n-  }\n-  _crengine_args[0] = _crengine;\n-  _crengine_argc = 2;\n-\n-  if (_crengine_arg_str != NULL) {\n-    char *arg = _crengine_arg_str;\n-    char *target = _crengine_arg_str;\n-    bool escaped = false;\n-    for (char *c = arg; *c != '\\0'; ++c) {\n-      if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 2) {\n-        warning(\"Too many options to CRaCEngine; cannot proceed with these: %s\", arg);\n-        return false;\n-      }\n-      if (!escaped) {\n-        switch(*c) {\n-        case '\\\\':\n-          escaped = true;\n-          continue; \/\/ for\n-        case ',':\n-          *target++ = '\\0';\n-          _crengine_args[_crengine_argc++] = arg;\n-          arg = target;\n-          continue; \/\/ for\n-        }\n-      }\n-      escaped = false;\n-      *target++ = *c;\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine an executable name with 'engine' omitted: path is too long\");\n+  }\n+\n+  \/\/ Try to interpret as an executable name\n+  precond(path_len > strlen(\"engine\"));\n+  path_len -= strlen(\"engine\");\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%s%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n@@ -173,3 +211,16 @@\n-    *target = '\\0';\n-    _crengine_args[_crengine_argc++] = arg;\n-    _crengine_args[_crengine_argc] = NULL;\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine as an executable name: path is too long\");\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ CRaC engine configuration options JVM sets directly instead of relaying from the user\n+#define ENGINE_OPT_IMAGE_LOCATION \"image_location\"\n+#define ENGINE_OPT_EXEC_LOCATION \"exec_location\"\n+\n+static bool configure_image_location(const crlib_api_t &api, crlib_conf_t *conf, const char *image_location) {\n+  precond(image_location != nullptr && image_location[0] != '\\0');\n+  if (!api.configure(conf, ENGINE_OPT_IMAGE_LOCATION, image_location)) {\n+    log_error(crac)(\"CRaC engine failed to configure: '\" ENGINE_OPT_IMAGE_LOCATION \"' = '%s'\", image_location);\n+    return false;\n@@ -180,3 +231,81 @@\n-static void add_crengine_arg(const char *arg) {\n-  if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 1) {\n-      warning(\"Too many options to CRaCEngine; cannot add %s\", arg);\n+static crlib_conf_t *create_engine_conf(\n+    const crlib_api_t &api, const char *image_location, const char *exec_location) {\n+  crlib_conf_t * const conf = api.create_conf();\n+  if (conf == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to create its configuration\");\n+    return nullptr;\n+  }\n+\n+  if (!configure_image_location(api, conf, image_location)) {\n+    api.destroy_conf(conf);\n+    return nullptr;\n+  }\n+\n+  if (exec_location != nullptr) { \/\/ Only passed when using crexec\n+    guarantee(api.can_configure(conf, ENGINE_OPT_EXEC_LOCATION),\n+              \"crexec does not support an internal option: \" ENGINE_OPT_EXEC_LOCATION);\n+    if (!api.configure(conf, ENGINE_OPT_EXEC_LOCATION, exec_location)) {\n+      log_error(crac)(\"crexec failed to configure: '\" ENGINE_OPT_EXEC_LOCATION \"' = '%s'\", exec_location);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+  }\n+\n+  if (CRaCEngineOptions == nullptr || CRaCEngineOptions[0] == '\\0' \/* possible for ccstrlist *\/) {\n+    return conf;\n+  }\n+\n+  char *engine_options = os::strdup_check_oom(CRaCEngineOptions, mtInternal);\n+  char *const engine_options_start = engine_options;\n+  do {\n+    char *key_value = strsep(&engine_options, \",\");\n+    const char *key = strsep(&key_value, \"=\");\n+    const char *value = key_value != nullptr ? key_value : \"\";\n+    assert(key != nullptr, \"Should have terminated before\");\n+    if (strcmp(key, ENGINE_OPT_IMAGE_LOCATION) == 0 ||\n+        (exec_location != nullptr && strcmp(key, ENGINE_OPT_EXEC_LOCATION) == 0)) {\n+      log_warning(crac)(\"Internal CRaC engine option provided, skipping: %s\", key);\n+      continue;\n+    }\n+    if (!api.configure(conf, key, value)) {\n+      log_error(crac)(\"CRaC engine failed to configure: '%s' = '%s'\", key, value);\n+      os::free(engine_options_start);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+    log_debug(crac)(\"CRaC engine option: '%s' = '%s'\", key, value);\n+  } while (engine_options != nullptr);\n+  os::free(engine_options_start);\n+\n+  return conf;\n+}\n+\n+crac::EngineHandle::EngineHandle(bool checkpoint) {\n+  if (CRaCEngine == nullptr) {\n+    log_error(crac)(\"CRaCEngine must not be empty\");\n+    return;\n+  }\n+\n+  \/\/ Arguments::get_dll_dir() might not have been initialized yet\n+  char dll_dir[JVM_MAXPATHLEN];\n+  os::jvm_path(dll_dir, sizeof(dll_dir));\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n+  char *after_elem = nullptr;\n+  for (int i = 0; i < 2; ++i) {\n+    after_elem = strrchr(dll_dir, *os::file_separator());\n+    *after_elem = '\\0';\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  bool is_library;\n+  if (!find_crac_engine(dll_dir, path, sizeof(path), &is_library)) {\n+    log_error(crac)(\"Cannot find CRaC engine %s\", CRaCEngine);\n+    return;\n+  }\n+  postcond(path[0] != '\\0');\n+\n+  char exec_path[JVM_MAXPATHLEN] = \"\\0\";\n+  if (!is_library) {\n+    strcpy(exec_path, path); \/\/ Save to later pass it to crexec\n+    if (!os::dll_locate_lib(path, sizeof(path), dll_dir, \"crexec\")) {\n+      log_error(crac)(\"Cannot find crexec library to use CRaCEngine executable\");\n@@ -184,0 +313,32 @@\n+    }\n+  }\n+\n+  char error_buf[1024];\n+  void * const lib = os::dll_load(path, error_buf, sizeof(error_buf));\n+  if (lib == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library from %s: %s\", path, error_buf);\n+    return;\n+  }\n+\n+  using api_func_t = decltype(&CRLIB_API);\n+  const auto api_func = reinterpret_cast<api_func_t>(os::dll_lookup(lib, CRLIB_API_FUNC));\n+  if (api_func == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library entrypoint '\" CRLIB_API_FUNC \"' from %s\", path);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  crlib_api_t * const api = api_func(CRLIB_API_VERSION, sizeof(crlib_api_t));\n+  if (api == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to initialize its API (version %i). \"\n+                    \"Maybe this version is not supported?\", CRLIB_API_VERSION);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+  if (api->create_conf == nullptr || api->destroy_conf == nullptr ||\n+      api->checkpoint == nullptr || api->restore == nullptr ||\n+      api->can_configure == nullptr || api->configure == nullptr ||\n+      api->get_extension == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to fully initialize its API\");\n+    os::dll_unload(lib);\n+    return;\n@@ -185,2 +346,12 @@\n-  _crengine_args[_crengine_argc++] = arg;\n-  _crengine_args[_crengine_argc] = NULL;\n+\n+  const char *image_location = checkpoint ? CRaCCheckpointTo : CRaCRestoreFrom;\n+  const char *exec_location = exec_path[0] != '\\0' ? exec_path : nullptr;\n+  crlib_conf_t * const conf = create_engine_conf(*api, image_location, exec_location);\n+  if (conf == nullptr) {\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  _lib = lib;\n+  _api = api;\n+  _conf = conf;\n@@ -189,3 +360,13 @@\n-static int call_crengine() {\n-  if (!_crengine) {\n-    return -1;\n+crac::EngineHandle::~EngineHandle() {\n+  if (is_initialized()) {\n+    _api->destroy_conf(_conf);\n+    os::dll_unload(_lib);\n+  }\n+}\n+\n+static crlib_restore_data_t *get_restore_data_api(const crlib_api_t *api) {\n+  precond(api != nullptr);\n+  crlib_restore_data_t * const restore_data_api = CRLIB_EXTENSION_RESTORE_DATA(api);\n+  if (restore_data_api == nullptr) {\n+    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n+    return nullptr;\n@@ -193,3 +374,5 @@\n-  _crengine_args[1] = \"checkpoint\";\n-  add_crengine_arg(CRaCCheckpointTo);\n-  return os::exec_child_process_and_wait(_crengine, _crengine_args);\n+  if (restore_data_api->set_restore_data == nullptr || restore_data_api->get_restore_data == nullptr) {\n+    log_debug(crac)(\"CRaC engine failed to fully initialize API extension: %s\", CRLIB_EXTENSION_RESTORE_DATA_NAME);\n+    return nullptr;\n+  }\n+  return restore_data_api;\n@@ -198,1 +381,3 @@\n-static int checkpoint_restore(int *shmid) {\n+int crac::checkpoint_restore(int *shmid) {\n+  guarantee(_engine != nullptr, \"CRaC engine is not initialized\");\n+\n@@ -201,3 +386,7 @@\n-  int cres = call_crengine();\n-  if (cres < 0) {\n-    tty->print_cr(\"CRaC error executing: %s\\n\", _crengine);\n+  \/\/ CRaCCheckpointTo can be changed on restore so we need to update the conf\n+  \/\/ to account for that.\n+  \/\/ Note that CRaCEngine and CRaCEngineOptions are not updated (as documented)\n+  \/\/ so we don't need to re-init the whole engine handle.\n+  \/\/ TODO: do this only if there has been at least one restore (cannot check via\n+  \/\/  CRaCRestoreFrom != nullptr because it can remain unset even after restore)\n+  if (!configure_image_location(*_engine->api(), _engine->conf(), CRaCCheckpointTo)) {\n@@ -207,4 +396,5 @@\n-#ifdef LINUX\n-  sigset_t waitmask;\n-  sigemptyset(&waitmask);\n-  sigaddset(&waitmask, RESTORE_SIGNAL);\n+  const int ret = _engine->api()->checkpoint(_engine->conf());\n+  if (ret != 0) {\n+    log_error(crac)(\"CRaC engine failed to checkpoint to %s: error %i\", CRaCCheckpointTo, ret);\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n@@ -212,6 +402,7 @@\n-  siginfo_t info;\n-  int sig;\n-  do {\n-    sig = sigwaitinfo(&waitmask, &info);\n-  } while (sig == -1 && errno == EINTR);\n-  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n+  const auto *restore_data_api = get_restore_data_api(_engine->api());\n+  if (restore_data_api == nullptr) {\n+    *shmid = 0; \/\/ Not an error, just no restore data\n+  } else if (restore_data_api->get_restore_data(_engine->conf(), shmid, sizeof(*shmid)) < sizeof(*shmid)) {\n+    log_error(crac)(\"CRaC engine failed to provide restore data\");\n+    *shmid = -1; \/\/ Error\n+  }\n@@ -219,0 +410,1 @@\n+#ifdef LINUX\n@@ -222,2 +414,0 @@\n-#else\n-  \/\/ TODO add sync processing\n@@ -232,16 +422,0 @@\n-#ifdef LINUX\n-  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n-    tty->print(\"JVM: invalid info for restore provided: %s\", info.si_code == SI_QUEUE ? \"queued\" : \"not queued\");\n-    if (info.si_code == SI_QUEUE) {\n-      tty->print(\" code %d\", info.si_int);\n-    }\n-    tty->cr();\n-    return JVM_CHECKPOINT_ERROR;\n-  }\n-\n-  if (0 < info.si_int) {\n-    *shmid = info.si_int;\n-  }\n-#else\n-  *shmid = 0;\n-#endif \/\/LINUX\n@@ -252,0 +426,1 @@\n+  precond(shmid > 0);\n@@ -256,1 +431,1 @@\n-    log_error(crac)(\"Cannot read restore parameters (JVM flags, env vars, system properties, arguments...)\");\n+    log_error(crac)(\"Cannot read restore parameters\");\n@@ -308,1 +483,0 @@\n-\n@@ -338,1 +512,1 @@\n-  int shmid = 0;\n+  int shmid = -1;\n@@ -341,0 +515,1 @@\n+    shmid = 0;\n@@ -344,1 +519,1 @@\n-    int ret = checkpoint_restore(&shmid);\n+    int ret = crac::checkpoint_restore(&shmid);\n@@ -354,1 +529,3 @@\n-  if (shmid <= 0) {\n+\n+  if (shmid == 0) { \/\/ E.g. engine does not support restore data\n+    log_debug(crac)(\"Restore parameters (JVM flags, env vars, system properties, arguments...) not provided\");\n@@ -357,3 +534,0 @@\n-  } else if (!VM_Crac::read_shm(shmid)) {\n-    vm_direct_exit(1, \"Restore cannot continue, VM will exit.\");\n-    ShouldNotReachHere();\n@@ -361,0 +535,4 @@\n+    if (shmid < 0 || !VM_Crac::read_shm(shmid)) {\n+      vm_direct_exit(1, \"Restore cannot continue, VM will exit.\"); \/\/ More info in logs\n+      ShouldNotReachHere();\n+    }\n@@ -378,1 +556,0 @@\n-\n@@ -380,1 +557,1 @@\n-  struct stat st;\n+  precond(CRaCCheckpointTo != nullptr);\n@@ -382,0 +559,1 @@\n+  struct stat st;\n@@ -384,1 +562,1 @@\n-      warning(\"%s: not a directory\", CRaCCheckpointTo);\n+      log_error(crac)(\"CRaCCheckpointTo=%s is not a directory\", CRaCCheckpointTo);\n@@ -389,1 +567,1 @@\n-      warning(\"cannot create %s: %s\", CRaCCheckpointTo, os::strerror(errno));\n+      log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n@@ -393,1 +571,1 @@\n-      warning(\"cannot cleanup after check: %s\", os::strerror(errno));\n+      log_warning(crac)(\"Cannot cleanup after CRaCCheckpointTo check: %s\", os::strerror(errno));\n@@ -398,2 +576,6 @@\n-  if (!compute_crengine()) {\n-    return false;\n+  \/\/ Initialize CRaC engine now to verify all the related VM options\n+  assert(_engine == nullptr, \"CRaC engine should be initialized only once\");\n+  _engine = new EngineHandle(true);\n+  if (!_engine->is_initialized()) {\n+    delete _engine;\n+    _engine = nullptr;\n@@ -401,2 +583,1 @@\n-\n-  return true;\n+  return _engine != nullptr;\n@@ -422,1 +603,4 @@\n-  if (!CRaCCheckpointTo) {\n+  log_debug(crac)(\"Checkpoint %i requested (dry run=%s)\", os::current_process_id(), BOOL_TO_STR(dry_run));\n+\n+  if (CRaCCheckpointTo == nullptr) {\n+    log_error(crac)(\"CRaCCheckpointTo is not specified\");\n@@ -427,1 +611,1 @@\n-    warning(\"cannot create %s: %s\", CRaCCheckpointTo, os::strerror(errno));\n+    log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n@@ -524,0 +708,2 @@\n+  precond(CRaCRestoreFrom != nullptr);\n+\n@@ -526,2 +712,1 @@\n-    fprintf(stderr, \"Cannot open restore directory of the -XX:CRaCRestoreFrom parameter: \");\n-    perror(CRaCRestoreFrom);\n+    log_error(crac)(\"Cannot open CRaCRestoreFrom=%s: %s\", CRaCRestoreFrom, os::strerror(errno));\n@@ -531,1 +716,1 @@\n-    fprintf(stderr, \"-XX:CRaCRestoreFrom parameter is not a directory: %s\\n\", CRaCRestoreFrom);\n+    log_error(crac)(\"CRaCRestoreFrom=%s is not a directory\", CRaCRestoreFrom);\n@@ -535,3 +720,5 @@\n-  compute_crengine();\n-\n-  const int id = os::current_process_id();\n+  \/\/ Note that this is a local, i.e. the handle will be destroyed if we fail to restore\n+  const EngineHandle engine = EngineHandle(false);\n+  if (!engine.is_initialized()) {\n+    return;\n+  }\n@@ -539,15 +726,8 @@\n-  CracSHM shm(id);\n-  int shmfd = shm.open(O_RDWR | O_CREAT | O_TRUNC);\n-  if (shmfd < 0) {\n-    log_error(crac)(\"Cannot pass parameters (JVM flags, env vars, system properties, arguments...) to the restored process.\");\n-  } else {\n-    if (CracRestoreParameters::write_to(\n-          shmfd,\n-          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n-          Arguments::system_properties(),\n-          Arguments::java_command_crac() ? Arguments::java_command_crac() : \"\",\n-          restore_data.restore_time,\n-          restore_data.restore_nanos)) {\n-      char strid[32];\n-      snprintf(strid, sizeof(strid), \"%d\", id);\n-      LINUX_ONLY(setenv(\"CRAC_NEW_ARGS_ID\", strid, true));\n+  const auto *restore_data_api = get_restore_data_api(engine.api());\n+  if (restore_data_api != nullptr) {\n+    const int shmid = os::current_process_id();\n+    CracSHM shm(shmid);\n+    const int shmfd = shm.open(O_RDWR | O_CREAT | O_TRUNC);\n+    if (shmfd < 0) {\n+      log_error(crac)(\"Failed to open a space shared with restored process\");\n+      return;\n@@ -555,0 +735,8 @@\n+    const bool write_success = CracRestoreParameters::write_to(\n+      shmfd,\n+      Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n+      Arguments::system_properties(),\n+      Arguments::java_command_crac() ? Arguments::java_command_crac() : \"\",\n+      restore_data.restore_time,\n+      restore_data.restore_nanos\n+    );\n@@ -556,0 +744,11 @@\n+    if (!write_success) {\n+      log_error(crac)(\"Failed to write to a space shared with restored process\");\n+      return;\n+    }\n+    if (!restore_data_api->set_restore_data(engine.conf(), &shmid, sizeof(shmid))) {\n+      log_error(crac)(\"CRaC engine failed to record restore data\");\n+      return;\n+    }\n+  } else {\n+    log_warning(crac)(\"Cannot pass restore parameters (JVM flags, env vars, system properties, arguments...) \"\n+                      \"with the selected CRaC engine\");\n@@ -558,5 +757,3 @@\n-  if (_crengine) {\n-    _crengine_args[1] = \"restore\";\n-    add_crengine_arg(CRaCRestoreFrom);\n-    os::execv(_crengine, _crengine_args);\n-    warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", _crengine, os::strerror(errno));\n+  const int ret = engine.api()->restore(engine.conf());\n+  if (ret != 0) {\n+    log_error(crac)(\"CRaC engine failed to restore from %s: error %i\", CRaCRestoreFrom, ret);\n@@ -598,0 +795,7 @@\n+    } else if (strncmp(name, \"CRaCEngine\", ARRAY_SIZE(\"CRaCEngine\") - 1) == 0) {\n+      \/\/ CRaCEngine and CRaCEngineOptions are not updated from the restoring process\n+      assert(strncmp(name, \"CRaCEngine=\", strlen(\"CRaCEngine=\")) == 0 ||\n+             strncmp(name, \"CRaCEngineOptions=\", strlen(\"CRaCEngineOptions=\")) == 0,\n+             \"unexpected CRaCEngine* flag: %s\", name);\n+      result = JVMFlag::Error::SUCCESS;\n+      cursor += strlen(cursor) + 1;\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":364,"deletions":160,"binary":false,"changes":524,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+  friend class VM_Crac;\n@@ -50,3 +51,0 @@\n-  static void record_time_before_checkpoint();\n-  static void update_javaTimeNanos_offset();\n-\n@@ -60,2 +58,0 @@\n-  static bool read_bootid(char *dest);\n-\n@@ -66,0 +62,10 @@\n+\n+  class EngineHandle;\n+  static const EngineHandle *_engine;\n+\n+  static bool read_bootid(char *dest);\n+\n+  static void record_time_before_checkpoint();\n+  static void update_javaTimeNanos_offset();\n+\n+  static int checkpoint_restore(int *shmid);\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1963,5 +1963,12 @@\n-      \"Path or name of a program implementing checkpoint\/restore and \"      \\\n-      \"optional extra parameters as a comma-separated list: \"               \\\n-      \"-XX:CRaCEngine=program,--key,value,--anotherkey results in calling \" \\\n-      \"'program --key value --anotherkey'. Commas used as part of args \"    \\\n-      \"should be escaped with a backslash character ('\\\\').\")               \\\n+      \"Path or name of a program or a shared library implementing \"         \\\n+      \"checkpoint and restore. On restore this value applies only to the \"  \\\n+      \"restoring VM, i.e. the restored VM keeps the value it had before \"   \\\n+      \"the checkpoint.\")                                                    \\\n+                                                                            \\\n+  product(ccstrlist, CRaCEngineOptions, nullptr, RESTORE_SETTABLE,          \\\n+      \"Options passed to CRaCEngine, in the form of 'key1=value,key2'. \"    \\\n+      \"The list of supported options is engine-dependent. Engines are \"     \\\n+      \"encouraged to recognize 'help' option for printing information \"     \\\n+      \"about supported options. On restore this value applies only to the \" \\\n+      \"restoring VM, i.e. the restored VM keeps the value it had before \"   \\\n+      \"the checkpoint.\")                                                    \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -642,2 +642,0 @@\n-  static int exec_child_process_and_wait(const char *path, const char *argv[]);\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,527 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <assert.h>\n+#include <stdbool.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n+#include \"hashtable.h\"\n+#include \"jni.h\"\n+\n+#ifdef LINUX\n+#include <signal.h>\n+\n+#include \"jvm.h\"\n+#endif \/\/ LINUX\n+\n+#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(*(x)))\n+\n+#define CREXEC \"crexec: \"\n+\n+\/\/ When adding a new option also add its description into the help message and\n+\/\/ ensure the proper default value is set for it on configuration init. Also\n+\/\/ consider checking for its inappropriate use on checkpoint\/restore.\n+\/\/\n+\/\/ More frequently used options should go first: this means they'll be the first\n+\/\/ to be placed in the options hash table which is implemented so that the keys\n+\/\/ added first are faster to find.\n+#define CONFIGURE_OPTIONS(OPT) \\\n+  OPT(exec_location, \"exec_location\") \\\n+  OPT(image_location, \"image_location\") \\\n+  OPT(keep_running, \"keep_running\") \\\n+  OPT(direct_map, \"direct_map\") \\\n+  OPT(args, \"args\") \\\n+  OPT(help, \"help\") \\\n+\n+#define DEFINE_OPT(id, str) static const char opt_##id[] = str;\n+CONFIGURE_OPTIONS(DEFINE_OPT)\n+#undef DEFINE_OPT\n+#define ADD_ARR_ELEM(id, str) opt_##id,\n+static const char *configure_options[] = { CONFIGURE_OPTIONS(ADD_ARR_ELEM) };\n+#undef ADD_ARR_ELEM\n+\n+\/\/ Indices of argv arrag members\n+enum Argv {\n+  ARGV_EXEC_LOCATION,\n+  ARGV_ACTION,\n+  ARGV_IMAGE_LOCATION,\n+  ARGV_FREE, \/\/ First index for user-provided arguments\n+  ARGV_LAST = 31,\n+};\n+\n+struct crlib_conf {\n+  hashtable_t *options;\n+\n+  bool keep_running;\n+  bool direct_map;\n+  int restore_data;\n+\n+  unsigned int argc;\n+  const char *argv[ARGV_LAST + 2]; \/\/ Last element is required to be null\n+};\n+\n+\/\/ crexec_md.c\n+const char *file_separator(void);\n+bool is_path_absolute(const char *path);\n+bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]);\n+char **get_environ(void);\n+void exec_in_this_process(const char *path, const char *argv[], const char *env[]);\n+\n+typedef bool (*configure_func)(crlib_conf_t *, const char *value);\n+\n+static bool configure_help(crlib_conf_t *conf, const char *ignored) {\n+  \/\/ Internal options which are expected to be set by the program crexec is linked against are\n+  \/\/ omitted from the print since users are not supposed to pass them directly:\n+  \/\/ * image_location=<path> — path to a directory with checkpoint\/restore files.\n+  \/\/ * exec_location=<path> — path to the engine executable.\n+  const int ret = printf(\n+    \"\\n\"\n+    \"crexec — pseudo-CRaC-engine used to relay data from JVM to a \\\"real\\\" engine implemented as \"\n+    \"an executable (instead of a library).\\n\"\n+    \"The engine executable is expected to have CRaC-CRIU-like CLI. Support of the options below \"\n+    \"also depends on the engine executable.\\n\"\n+    \"\\n\"\n+    \"Configuration options:\\n\"\n+    \"* keep_running=<true\/false> (default: false) — keep the process running after the checkpoint \"\n+    \"or kill it.\\n\"\n+    \"* direct_map=<true\/false> (default: false) — on restore, map process data directly from saved \"\n+    \"files. This may speedup the restore but the resulting process will not be the same as before \"\n+    \"the checkpoint.\\n\"\n+    \"* args=<string> (default: \\\"\\\") — free space-separated arguments passed directly to the \"\n+    \"engine executable, e.g. \\\"--arg1 --arg2 --arg3\\\".\\n\"\n+    \"* help — print this message.\\n\"\n+    \"\\n\"\n+  );\n+  return ret > 0;\n+}\n+\n+static char *strdup_checked(const char *src) {\n+  char *res = strdup(src);\n+  if (res == NULL) {\n+    fprintf(stderr, CREXEC \"out of memory\\n\");\n+  }\n+  return res;\n+}\n+\n+static bool parse_bool(const char *str, bool *result) {\n+  if (strcmp(str, \"true\") == 0) {\n+    *result = true;\n+    return true;\n+  }\n+  if (strcmp(str, \"false\") == 0) {\n+    *result = false;\n+    return true;\n+  }\n+  fprintf(stderr, CREXEC \"expected '%s' to be either 'true' or 'false'\\n\", str);\n+  return false;\n+}\n+\n+static bool configure_exec_location(crlib_conf_t *conf, const char *exec_location) {\n+  if (!is_path_absolute(exec_location)) {\n+    fprintf(stderr, CREXEC \"expected absolute path: %s\\n\", exec_location);\n+    return false;\n+  }\n+  free((char *) conf->argv[ARGV_EXEC_LOCATION]);\n+  conf->argv[ARGV_EXEC_LOCATION] = strdup_checked(exec_location);\n+  if (conf->argv[ARGV_EXEC_LOCATION] == NULL) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+static bool configure_image_location(crlib_conf_t *conf, const char *image_location) {\n+  free((char *) conf->argv[ARGV_IMAGE_LOCATION]);\n+  conf->argv[ARGV_IMAGE_LOCATION] = strdup_checked(image_location);\n+  return conf->argv[ARGV_IMAGE_LOCATION] != NULL;\n+}\n+\n+static bool configure_keep_running(crlib_conf_t *conf, const char *keep_running_str) {\n+  return parse_bool(keep_running_str, &conf->keep_running);\n+}\n+\n+static bool configure_direct_map(crlib_conf_t *conf, const char *direct_map_str) {\n+  return parse_bool(direct_map_str, &conf->direct_map);\n+}\n+\n+static bool configure_args(crlib_conf_t *conf, const char *args) {\n+  free((char *) conf->argv[ARGV_FREE]);\n+  char *arg = strdup_checked(args);\n+  if (arg == NULL) {\n+    conf->argv[ARGV_FREE] = NULL;\n+    return false;\n+  }\n+\n+  assert(ARGV_FREE <= ARGV_LAST);\n+  for (int i = ARGV_FREE; i <= ARGV_LAST && arg[0] != '\\0'; i++) {\n+    conf->argv[i] = arg;\n+    char * const delim = strchr(arg, ' ');\n+    if (delim != NULL) {\n+      *delim = '\\0';\n+      arg = delim + 1;\n+    } else {\n+      arg = \"\\0\";\n+    }\n+  }\n+\n+  if (arg[0] != '\\0') {\n+    fprintf(stderr, CREXEC \"too many free arguments, at most %i are allowed\\n\",\n+            (ARGV_LAST - ARGV_FREE) + 1);\n+    free((char *) conf->argv[ARGV_FREE]);\n+    conf->argv[ARGV_FREE] = NULL;\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+static bool can_configure(crlib_conf_t *conf, const char *key) {\n+  assert(key != NULL);\n+  return hashtable_contains(conf->options, key);\n+}\n+\n+static bool configure(crlib_conf_t *conf, const char *key, const char *value) {\n+  assert(key != NULL && value != NULL);\n+  const configure_func func = (configure_func) hashtable_get(conf->options, key);\n+  if (func != NULL) {\n+    return func(conf, value);\n+  }\n+  fprintf(stderr, CREXEC \"unknown configure option: %s\\n\", key);\n+  return false;\n+}\n+\n+static bool set_restore_data(crlib_conf_t *conf, const void *data, size_t size) {\n+  if (size != sizeof(conf->restore_data)) {\n+    fprintf(stderr, CREXEC \"unsupported size of restore data: %zu — only %zu is supported\\n\",\n+            size, sizeof(conf->restore_data));\n+    return false;\n+  }\n+  conf->restore_data = *(int *) data;\n+  return true;\n+}\n+\n+static size_t get_restore_data(crlib_conf_t *conf, void *buf, size_t size) {\n+  if (size < sizeof(conf->restore_data)) {\n+    fprintf(stderr, CREXEC \"can only provide >= %zu bytes of restore data but %zu was requested\\n\",\n+            sizeof(conf->restore_data), size);\n+    return 0;\n+  }\n+  *(int *) buf = conf->restore_data;\n+  return sizeof(conf->restore_data);\n+}\n+\n+static crlib_restore_data_t restore_data_extension = {\n+  .header = {\n+    .name = CRLIB_EXTENSION_RESTORE_DATA_NAME,\n+    .size = sizeof(crlib_restore_data_t)\n+  },\n+  .set_restore_data = set_restore_data,\n+  .get_restore_data = get_restore_data\n+};\n+\n+static const crlib_extension_t *extensions[] = { &restore_data_extension.header };\n+\n+static const crlib_extension_t *get_extension(const char *name, size_t size) {\n+  for (size_t i = 0; i < ARRAY_SIZE(extensions); i++) {\n+    const crlib_extension_t *ext = extensions[i];\n+    if (strcmp(name, ext->name) == 0) {\n+      if (size <= ext->size) {\n+        return ext;\n+      }\n+      return NULL;\n+    }\n+  }\n+  return NULL;\n+}\n+\n+static void destroy_conf(crlib_conf_t *conf) {\n+  if (conf == NULL) {\n+    return;\n+  }\n+  hashtable_destroy(conf->options);\n+  for (int i = 0; i <= ARGV_FREE \/* all free args are allocated together *\/; i++) {\n+    if (i != ARGV_ACTION) { \/\/ Action is a static string\n+      free((char*) conf->argv[i]);\n+    }\n+  }\n+  free(conf);\n+}\n+\n+static crlib_conf_t *create_conf() {\n+  crlib_conf_t * const conf = (crlib_conf_t *) malloc(sizeof(crlib_conf_t));\n+  if (conf == NULL) {\n+    fprintf(stderr, CREXEC \"out of memory\\n\");\n+    return NULL;\n+  }\n+  memset(conf, 0, sizeof(*conf));\n+\n+  conf->options = hashtable_create(configure_options, ARRAY_SIZE(configure_options));\n+  if (conf->options == NULL) {\n+    fprintf(stderr, CREXEC \"out of memory\\n\");\n+    destroy_conf(conf);\n+    return NULL;\n+  }\n+#define PUT_HANDLER(id, str) hashtable_put(conf->options, opt_##id, configure_##id);\n+  CONFIGURE_OPTIONS(PUT_HANDLER)\n+#undef PUT_HANDLER\n+\n+  return conf;\n+}\n+\n+static void free_environ(char **env) {\n+  for (size_t i = 0; env[i] != NULL; ++i) {\n+    free(env[i]);\n+  }\n+  free(env);\n+}\n+\n+static char **copy_environ(char * const *env) {\n+  size_t len = 0;\n+  for (; env[len] != NULL; len++) {}\n+\n+  char ** const new_env = malloc((len + 1) * sizeof(char *));\n+  if (new_env == NULL) {\n+    fprintf(stderr, CREXEC \"out of memory\\n\");\n+    return NULL;\n+  }\n+\n+  for (size_t i = 0; i < len; i++) {\n+    new_env[i] = strdup(env[i]);\n+    if (new_env[i] == NULL) {\n+      fprintf(stderr, CREXEC \"out of memory\\n\");\n+      free_environ(new_env);\n+      return NULL;\n+    }\n+  }\n+  new_env[len] = NULL;\n+\n+  return new_env;\n+}\n+\n+static char **set_env_var(char **env, const char *var, const char *value) {\n+  const size_t str_size = strlen(var) + strlen(\"=\") + strlen(value) + 1;\n+  char * const str = malloc(sizeof(char) * str_size);\n+  if (str == NULL) {\n+    fprintf(stderr, CREXEC \"out of memory\\n\");\n+    return NULL;\n+  }\n+  if (snprintf(str, str_size, \"%s=%s\", var, value) != (int) str_size - 1) {\n+    perror(CREXEC \"snprintf env var\");\n+    free(str);\n+    return NULL;\n+  }\n+\n+  size_t len = 0;\n+  for (; env[len] != NULL; len++) {}\n+\n+  char ** const new_env = realloc(env, (len + 2) * sizeof(char *));\n+  if (new_env == NULL) {\n+    fprintf(stderr, CREXEC \"out of memory\\n\");\n+    free(str);\n+    return NULL;\n+  }\n+\n+  new_env[len] = str;\n+  new_env[len + 1] = NULL;\n+\n+  return new_env;\n+}\n+\n+static char **add_criu_option(char **env, const char *opt) {\n+  static const char CRAC_CRIU_OPTS[] = \"CRAC_CRIU_OPTS\";\n+  static const size_t CRAC_CRIU_OPTS_LEN = ARRAY_SIZE(CRAC_CRIU_OPTS) - 1;\n+\n+  bool opts_found = false;\n+  size_t opts_index = 0;\n+  for (; env[opts_index] != NULL; opts_index++) {\n+    if (strcmp(env[opts_index], CRAC_CRIU_OPTS) == 0 && env[opts_index][CRAC_CRIU_OPTS_LEN] == '=') {\n+      opts_found = true;\n+      break;\n+    }\n+  }\n+\n+  if (!opts_found) {\n+    return set_env_var(env, CRAC_CRIU_OPTS, opt);\n+  }\n+\n+  if (strstr(env[opts_index] + CRAC_CRIU_OPTS_LEN + 1, opt) != NULL) {\n+    return env;\n+  }\n+\n+  const size_t new_opts_size = strlen(env[opts_index]) + strlen(\" \") + strlen(opt) + 1;\n+  char * const new_opts = malloc(new_opts_size * sizeof(char));\n+  if (new_opts == NULL) {\n+    fprintf(stderr, CREXEC \"out of memory\\n\");\n+    return NULL;\n+  }\n+  if (snprintf(new_opts, new_opts_size, \"%s %s\", env[opts_index], opt) != (int) new_opts_size - 1) {\n+    perror(CREXEC \"snprintf CRAC_CRIU_OPTS (append)\");\n+    free(new_opts);\n+    return NULL;\n+  }\n+  free(env[opts_index]);\n+  env[opts_index] = new_opts;\n+\n+  return env;\n+}\n+\n+static int checkpoint(crlib_conf_t *conf) {\n+  if (conf->argv[ARGV_EXEC_LOCATION] == NULL) {\n+    fprintf(stderr, CREXEC \"%s must be set before checkpoint\\n\", opt_exec_location);\n+    return -1;\n+  }\n+  if (conf->argv[ARGV_IMAGE_LOCATION] == NULL) {\n+    fprintf(stderr, CREXEC \"%s must be set before checkpoint\\n\", opt_image_location);\n+    return -1;\n+  }\n+  conf->argv[ARGV_ACTION] = \"checkpoint\";\n+\n+  if (conf->direct_map) {\n+    fprintf(stderr, CREXEC \"%s has no effect on checkpoint\\n\", opt_direct_map);\n+  }\n+\n+  char **env = copy_environ(get_environ());\n+  if (env == NULL) {\n+    return -1;\n+  }\n+  if (conf->keep_running) {\n+    char ** const new_env = set_env_var(env, \"CRAC_CRIU_LEAVE_RUNNING\", \"\");\n+    if (new_env == NULL) {\n+      free_environ(env);\n+      return -1;\n+    }\n+    env = new_env;\n+  }\n+\n+  const bool ok = exec_child_process_and_wait(conf->argv[ARGV_EXEC_LOCATION],\n+                                              (char **) conf->argv, env);\n+  free_environ(env);\n+  if (!ok) {\n+    return -1;\n+  }\n+\n+#ifdef LINUX\n+  siginfo_t info;\n+  sigset_t waitmask;\n+  sigemptyset(&waitmask);\n+  sigaddset(&waitmask, RESTORE_SIGNAL);\n+\n+  int sig;\n+  do {\n+    sig = sigwaitinfo(&waitmask, &info);\n+  } while (sig == -1 && errno == EINTR);\n+\n+  if (info.si_code != SI_QUEUE) {\n+    return false;\n+  }\n+  conf->restore_data = info.si_int;\n+#endif \/\/ LINUX\n+\n+  return 0;\n+}\n+\n+static int restore(crlib_conf_t *conf) {\n+  if (conf->argv[ARGV_EXEC_LOCATION] == NULL) {\n+    fprintf(stderr, CREXEC \"%s must be set before restore\\n\", opt_exec_location);\n+    return -1;\n+  }\n+  if (conf->argv[ARGV_IMAGE_LOCATION] == NULL) {\n+    fprintf(stderr, CREXEC \"%s must be set before restore\\n\", opt_image_location);\n+    return -1;\n+  }\n+  conf->argv[ARGV_ACTION] = \"restore\";\n+\n+  if (conf->keep_running) {\n+    fprintf(stderr, CREXEC \"%s has no effect on restore\\n\", opt_keep_running);\n+  }\n+\n+  char **env = copy_environ(get_environ());\n+  if (env == NULL) {\n+    return -1;\n+  }\n+\n+  {\n+    char ** const new_env = set_env_var(env, \"CRAC_CRIU_LEAVE_RUNNING\", \"\");\n+    if (new_env == NULL) {\n+      free_environ(env);\n+      return -1;\n+    }\n+    env = new_env;\n+  }\n+\n+  char restore_data_str[32];\n+  if (snprintf(restore_data_str, sizeof(restore_data_str), \"%i\", conf->restore_data) >\n+      (int) sizeof(restore_data_str) - 1) {\n+    perror(CREXEC \"snprintf restore data\");\n+    free_environ(env);\n+    return -1;\n+  }\n+  {\n+    char ** const new_env = set_env_var(env, \"CRAC_NEW_ARGS_ID\", restore_data_str);\n+    if (new_env == NULL) {\n+      free_environ(env);\n+      return -1;\n+    }\n+    env = new_env;\n+  }\n+\n+  if (!conf->direct_map) {\n+    char ** const new_env = add_criu_option(env, \"--no-mmap-page-image\");\n+    if (new_env == NULL) {\n+      free_environ(env);\n+      return -1;\n+    }\n+    env = new_env;\n+  }\n+\n+  exec_in_this_process(conf->argv[ARGV_EXEC_LOCATION], conf->argv, (const char **) env);\n+\n+  free_environ(env); \/\/ shouldn't be needed\n+  fprintf(stderr, CREXEC \"restore failed\\n\");\n+  return -1;\n+}\n+\n+static struct crlib_api api = {\n+  .create_conf = create_conf,\n+  .destroy_conf = destroy_conf,\n+  .checkpoint = checkpoint,\n+  .restore = restore,\n+  .can_configure = can_configure,\n+  .configure = configure,\n+  .get_extension = get_extension,\n+};\n+\n+JNIEXPORT crlib_api_t *CRLIB_API(int api_version, size_t api_size) {\n+  if (api_version != CRLIB_API_VERSION) {\n+    return NULL;\n+  }\n+  if (sizeof(crlib_api_t) < api_size) {\n+    return NULL;\n+  }\n+  return &api;\n+}\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.c","additions":527,"deletions":0,"binary":false,"changes":527,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include \"hashtable.h\"\n+\n+#include <assert.h>\n+#include <stdbool.h>\n+#include <stddef.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+static unsigned int string_hash(const char *str) {\n+  unsigned int hash = 0;\n+  for (; *str; str++) {\n+    hash = 31 * hash + *str;\n+  }\n+  return hash;\n+}\n+\n+hashtable_t *hashtable_create(const char **keys, size_t length) {\n+  hashtable_t * const ht = (hashtable_t *) malloc(sizeof(hashtable_t));\n+  if (ht == NULL) {\n+    return NULL;\n+  }\n+\n+  ht->length = length;\n+  ht->keys = (const char **) malloc(length * sizeof(const char **));\n+  if (ht->keys == NULL) {\n+    hashtable_destroy(ht);\n+    return NULL;\n+  }\n+  ht->values = (void **) malloc(length * sizeof(void **));\n+  if (ht->values == NULL) {\n+    hashtable_destroy(ht);\n+    return NULL;\n+  }\n+\n+  memset((char **) ht->keys, 0, length * sizeof(const char **)); \/\/ Cast silences MSVC warning C4090\n+  memset(ht->values, 0, length * sizeof(void **));\n+\n+  for (size_t i = 0; i < length; i++) {\n+    const char *key = keys[i];\n+    assert(key != NULL);\n+    const unsigned int hash = string_hash(key) % length;\n+    bool place_found = false;\n+    for (size_t j = hash; !place_found && j < length; j++) {\n+      if (ht->keys[j] == NULL) {\n+        ht->keys[j] = key;\n+        place_found = true;\n+      }\n+    }\n+    for (size_t j = 0; !place_found && j < hash; j++) {\n+      if (ht->keys[j] == NULL) {\n+        ht->keys[j] = key;\n+        place_found = true;\n+      }\n+    }\n+    assert(place_found); \/\/ There should be enough space for all keys to fit\n+  }\n+\n+  return ht;\n+}\n+\n+void hashtable_destroy(hashtable_t *ht) {\n+  if (ht == NULL) {\n+    return;\n+  }\n+  free((char **) ht->keys); \/\/ Cast silences MSVC warning C4090\n+  free(ht->values);\n+  free(ht);\n+}\n+\n+static void **find_value(hashtable_t *ht, const char *key) {\n+  const unsigned int hash = string_hash(key) % ht->length;\n+  for (size_t i = hash; i < ht->length; i++) {\n+    if (strcmp(key, ht->keys[i]) == 0) {\n+      return &ht->values[i];\n+    }\n+  }\n+  for (size_t i = 0; i < hash; i++) {\n+    if (strcmp(key, ht->keys[i]) == 0) {\n+      return &ht->values[i];\n+    }\n+  }\n+  return NULL;\n+}\n+\n+bool hashtable_contains(hashtable_t *ht, const char *key) {\n+  return find_value(ht, key) != NULL;\n+}\n+\n+void *hashtable_get(hashtable_t *ht, const char *key) {\n+  void ** const value_ptr = find_value(ht, key);\n+  return value_ptr != NULL ? *value_ptr : NULL;\n+}\n+\n+bool hashtable_put(hashtable_t *ht, const char *key, void *value) {\n+  void ** const value_ptr = find_value(ht, key);\n+  if (value_ptr == NULL) {\n+    return false;\n+  }\n+  *value_ptr = value;\n+  return true;\n+}\n","filename":"src\/java.base\/share\/native\/libcrexec\/hashtable.c","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef HASHTABLE_H\n+#define HASHTABLE_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+\n+typedef struct hashtable {\n+  size_t length;\n+  const char **keys;\n+  void **values;\n+} hashtable_t;\n+\n+hashtable_t *hashtable_create(const char **keys, size_t length);\n+void hashtable_destroy(hashtable_t *ht);\n+\n+bool hashtable_contains(hashtable_t *ht, const char *key);\n+\n+void *hashtable_get(hashtable_t *ht, const char *key);\n+bool hashtable_put(hashtable_t *ht, const char *key, void *value);\n+\n+#endif \/\/ HASHTABLE_H\n","filename":"src\/java.base\/share\/native\/libcrexec\/hashtable.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-        const char* argsidstr = getenv(\"SIM_CRAC_NEW_ARGS_ID\");\n+        const char* argsidstr = getenv(\"CRAC_NEW_ARGS_ID\");\n@@ -64,1 +64,1 @@\n-        printf(\"SIM_CRAC_NEW_ARGS_ID=%s\\n\", strid ? strid : \"0\");\n+        printf(\"CRAC_NEW_ARGS_ID=%s\\n\", strid ? strid : \"0\");\n","filename":"src\/java.base\/share\/native\/simengine\/simengine.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <errno.h>\n+#include <spawn.h>\n+#include <stdbool.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <sys\/types.h>\n+#include <sys\/stat.h>\n+#include <sys\/wait.h>\n+#include <unistd.h>\n+\n+#define slash '\/'\n+\n+const char *file_separator() {\n+  return \"\/\";\n+}\n+\n+bool is_path_absolute(const char* path) {\n+  return path[0] == slash;\n+}\n+\n+\/\/ Darwin has no \"environ\" in a dynamic library.\n+#ifdef __APPLE__\n+  #include <crt_externs.h>\n+  #define environ (*_NSGetEnviron())\n+#else\n+  extern char** environ;\n+#endif\n+\n+char **get_environ() {\n+  return environ;\n+}\n+\n+bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]) {\n+  pid_t pid;\n+  if (posix_spawn(&pid, path, NULL, NULL, argv, env)) {\n+    perror(\"Cannot spawn cracengine\");\n+    return false;\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return false;\n+  }\n+  return WEXITSTATUS(status) == 0;\n+}\n+\n+void exec_in_this_process(const char *path, const char *argv[], const char *env[]) {\n+  execve(path, (char **) argv, (char **) env);\n+}\n","filename":"src\/java.base\/unix\/native\/libcrexec\/crexec_md.c","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -679,0 +679,1 @@\n+      \/\/ TODO: this should depend on CRaCEngine!\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024-2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <direct.h>\n+#include <process.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <windows.h>\n+\n+#define slash '\\\\'\n+\n+const char *file_separator() {\n+    return \"\\\\\";\n+}\n+\n+static inline int isLetter(char c) {\n+    return ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'));\n+}\n+\n+\/\/ Copy from FileSystemSupport_md.c\n+static int prefix_length(const char* path) {\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == slash) {\n+        if (c1 == slash) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (isLetter(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == slash))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool is_path_absolute(const char* path) {\n+    int pl = prefix_length(path);\n+    return (((pl == 2) && (path[0] == slash)) || (pl == 3));\n+}\n+\n+char **get_environ() {\n+  return _environ;\n+}\n+\n+bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]) {\n+  \/\/ Avoid crashing in _spawnve(), https:\/\/bugs.python.org\/issue29908\n+  SetEnvironmentVariable(TEXT(\"=CRAC_DUMMY\"), TEXT(\"dummy\"));\n+  intptr_t status = _spawnve(_P_WAIT, path, argv, env); \/\/ env is inherited by a child process\n+  return !status;\n+}\n+\n+void exec_in_this_process(const char *path, const char *argv[], const char *env[]) {\n+  \/\/ The same problem as above\n+  SetEnvironmentVariable(TEXT(\"=CRAC_DUMMY\"), TEXT(\"dummy\"));\n+  _execve(path, argv, env);\n+}\n","filename":"src\/java.base\/windows\/native\/libcrexec\/crexec_md.c","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.Test;\n+import org.junit.BeforeClass;\n+import static org.junit.Assert.*;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.nio.file.Path;\n+\n+\/*\n+* @test\n+* @summary Testing CRaCEngine and CRaCEngineOptions VM options.\n+* @library \/test\/lib\n+* @build CracEngineOptionsTest\n+* @run junit\/othervm CracEngineOptionsTest\n+*\/\n+public class CracEngineOptionsTest {\n+    @BeforeClass\n+    public static void checkCriu() {\n+        final boolean hasCriu = Path.of(Utils.TEST_JDK, \"lib\", \"criuengine\").toFile().exists();\n+        assertEquals(\"CRIU exists iff we are on Linux\", Platform.isLinux(), hasCriu);\n+    }\n+\n+    @Test\n+    public void test_default() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-XX:CRaCCheckpointTo=cr\",\n+                \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    @Test\n+    public void test_engines() throws Exception {\n+        test(\"sim\");\n+        test(\"simengine\");\n+        test(\"pause\");\n+        test(\"pauseengine\");\n+        if (Platform.isLinux()) {\n+            test(\"criu\");\n+            test(\"criuengine\");\n+        }\n+\n+        final String absolute = Platform.isWindows() ?\n+            Path.of(Utils.TEST_JDK, \"bin\", \"simengine.exe\").toString() :\n+            Path.of(Utils.TEST_JDK, \"lib\", \"simengine\").toString();\n+        test(absolute);\n+\n+        test(\"unknown\", null, 1, \"Cannot find CRaC engine unknown\");\n+        test(\"simengine,--arg\", null, 1, \"Cannot find CRaC engine simengine,--arg\");\n+        test(\"one two\", null, 1, \"Cannot find CRaC engine one two\");\n+        test(\"\", null, 1, \"CRaCEngine must not be empty\");\n+    }\n+\n+    @Test\n+    public void test_options() throws Exception {\n+        test(\"simengine\", \"\");\n+        test(\"simengine\", \"help\", 0,\n+                \"CRaC engine option: 'help' = ''\",\n+                \"Configuration options:\"); \/\/ A line from the help message\n+        test(\"simengine\", \"image_location=cr\", 0,\n+                \"Internal CRaC engine option provided, skipping: image_location\");\n+        if (Platform.isLinux()) {\n+            test(\"criuengine\", \"keep_running=true,args=-v -v -v -v,keep_running=false\", 0,\n+                    \"CRaC engine option: 'keep_running' = 'true'\",\n+                    \"CRaC engine option: 'args' = '-v -v -v -v'\",\n+                    \"CRaC engine option: 'keep_running' = 'false'\");\n+        }\n+\n+        test(\"simengine\", \"unknown=123\", 1,\n+                \"unknown configure option: unknown\",\n+                \"CRaC engine failed to configure: 'unknown' = '123'\");\n+        test(\"simengine\", \"unknown=\", 1,\n+                \"unknown configure option: unknown\",\n+                \"CRaC engine failed to configure: 'unknown' = ''\");\n+        test(\"simengine\", \"=\", 1,\n+                \"unknown configure option: \\n\",\n+                \"CRaC engine failed to configure: '' = ''\");\n+        test(\"simengine\", \"=,\", 1,\n+                \"unknown configure option: \\n\",\n+                \"CRaC engine failed to configure: '' = ''\");\n+        test(\"simengine\", \",=\", 1,\n+                \"unknown configure option: \\n\",\n+                \"CRaC engine failed to configure: '' = ''\");\n+        test(\"simengine\", \",\", 1,\n+                \"unknown configure option: \\n\",\n+                \"CRaC engine failed to configure: '' = ''\");\n+\n+        if (Platform.isLinux()) {\n+            test(\"criuengine\", \"direct_map=not a bool\", 1,\n+                    \"CRaC engine failed to configure: 'direct_map' = 'not a bool'\");\n+        }\n+    }\n+\n+    private void test(String engine) throws Exception {\n+        test(engine, null, 0);\n+    }\n+\n+    private void test(String engine, String opts) throws Exception {\n+        test(engine, opts, 0);\n+    }\n+\n+    private void test(String engine, String opts, int expectedExitValue, String... expectedTexts) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-XX:CRaCCheckpointTo=cr\",\n+                \"-XX:CRaCEngine=\" + engine,\n+                \"-Xlog:crac=debug\",\n+                \"-version\");\n+        if (opts != null) {\n+            pb.command().add(pb.command().size() - 2, \"-XX:CRaCEngineOptions=\" + opts);\n+        }\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(expectedExitValue);\n+        for (String text : expectedTexts) {\n+            out.shouldContain(text);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/CracEngineOptionsTest.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-import jdk.crac.*;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.channels.Pipe;\n-import java.nio.file.*;\n-import java.util.Objects;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * @test CracOptionTest\n- * @library \/test\/lib\n- * @build CracOptionTest\n- * @run driver jdk.test.lib.crac.CracTest\n- * @requires (os.family == \"linux\")\n- *\/\n-\n-public class CracOptionTest implements CracTest {\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder();\n-        builder.javaOption(\"k\",\"v\");\n-        builder.doCheckpointAndRestore();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        Core.checkpointRestore();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/CracOptionTest.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- import org.junit.Test;\n-\n- import jdk.test.lib.process.OutputAnalyzer;\n- import jdk.test.lib.process.ProcessTools;\n- \/*\n-  * @test CracVersionTest\n-  * @library \/test\/lib\n-  * @build CracVersionTest\n-  * @run junit\/othervm CracVersionTest\n-  *\/\n- public class CracVersionTest {\n-     @Test\n-     public void test_default() throws Exception {\n-         ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                 \"-XX:CRaCCheckpointTo=cr\",\n-                 \"-version\");\n-         OutputAnalyzer out = new OutputAnalyzer(pb.start());\n-         out.shouldHaveExitValue(0);\n-     }\n-\n-     private final String UNKNOWN_ENGINE = \"unknown\";\n-\n-     @Test\n-     public void test_fail() throws Exception {\n-         ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                 \"-XX:CRaCCheckpointTo=cr\",\n-                 \"-XX:CRaCEngine=\" + UNKNOWN_ENGINE,\n-                 \"-version\");\n-         OutputAnalyzer out = new OutputAnalyzer(pb.start());\n-         out.shouldHaveExitValue(1);\n-         if (System.getProperty(\"os.name\").contains(\"Windows\")) {\n-            out.shouldContain(UNKNOWN_ENGINE + \".exe:\");\n-         } else {\n-            out.shouldContain(UNKNOWN_ENGINE + \":\");\n-         }\n-     }\n- }\n","filename":"test\/jdk\/jdk\/crac\/CracVersionTest.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022-2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build PropertyTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+\n+public class PropertyTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.javaOption(\"k\", \"v\");\n+        builder.doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/PropertyTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+\n@@ -27,0 +28,1 @@\n+import jdk.test.lib.Utils;\n@@ -28,1 +30,0 @@\n-import jdk.test.lib.crac.CracEngine;\n@@ -32,0 +33,1 @@\n+import java.nio.file.Path;\n@@ -45,0 +47,2 @@\n+        final String enginePath = Path.of(Utils.TEST_JDK, \"lib\", \"criuengine\").toString();\n+\n@@ -46,2 +50,2 @@\n-        \/\/ this is here just to test passing CRaCEngine params\n-        builder.engine(CracEngine.CRIU, \"--verbosity=4\", \"--log-file=\/dev\/null\");\n+        builder.vmOption(\"-XX:CRaCEngine=criuengine\");\n+        builder.vmOption(\"-XX:CRaCEngineOptions=args=-v1\");\n@@ -51,2 +55,4 @@\n-        builder.vmOption(\"-XX:CRaCCheckpointTo=another\"); \/\/ manageable\n-        builder.vmOption(\"-XX:CRaCIgnoredFileDescriptors=42,43\"); \/\/ restore_settable\n+        builder.vmOption(\"-XX:CRaCEngine=\" + enginePath);\n+        builder.vmOption(\"-XX:CRaCEngineOptions=args=-v2\");\n+        builder.vmOption(\"-XX:CRaCCheckpointTo=another\");\n+        builder.vmOption(\"-XX:CRaCIgnoredFileDescriptors=42,43\");\n@@ -63,0 +69,9 @@\n+\n+            VMOption engine1 = bean.getVMOption(\"CRaCEngine\");\n+            assertEquals(\"criuengine\", engine1.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engine1.getOrigin());\n+\n+            VMOption engineOptions1 = bean.getVMOption(\"CRaCEngineOptions\");\n+            assertEquals(\"args=-v1\", engineOptions1.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engineOptions1.getOrigin());\n+\n@@ -66,0 +81,5 @@\n+\n+            VMOption restoreFrom1 = bean.getVMOption(\"CRaCRestoreFrom\");\n+            assertEquals(\"\", restoreFrom1.getValue());\n+            assertEquals(VMOption.Origin.DEFAULT, restoreFrom1.getOrigin());\n+\n@@ -75,0 +95,13 @@\n+\n+            \/\/ Should not change\n+\n+            VMOption engine2 = bean.getVMOption(\"CRaCEngine\");\n+            assertEquals(\"criuengine\", engine2.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engine2.getOrigin());\n+\n+            VMOption engineOptions2 = bean.getVMOption(\"CRaCEngineOptions\");\n+            assertEquals(\"args=-v1\", engineOptions2.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engineOptions2.getOrigin());\n+\n+            \/\/ Should change\n+\n@@ -78,0 +111,5 @@\n+\n+            VMOption restoreFrom2 = bean.getVMOption(\"CRaCRestoreFrom\");\n+            assertEquals(\"cr\", restoreFrom2.getValue());\n+            assertEquals(VMOption.Origin.OTHER, restoreFrom2.getOrigin());\n+\n@@ -81,0 +119,1 @@\n+\n","filename":"test\/jdk\/jdk\/crac\/VMOptionsTest.java","additions":44,"deletions":5,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                exception = new RuntimeException(\"Restore ERROR \" + e);\n+                exception = new RuntimeException(\"Restore ERROR\", e);\n@@ -104,1 +104,1 @@\n-                exception = new RuntimeException(\"Restore ERROR \" + e);\n+                exception = new RuntimeException(\"Restore ERROR\", e);\n@@ -124,1 +124,1 @@\n-            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+            throw new RuntimeException(\"Checkpoint ERROR\", e);\n@@ -126,1 +126,1 @@\n-            throw new RuntimeException(\"Restore ERROR \" + e);\n+            throw new RuntimeException(\"Restore ERROR\", e);\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    String[] engineArgs;\n+    String[] engineOptions;\n@@ -94,1 +94,1 @@\n-        other.engineArgs = engineArgs == null ? null : Arrays.copyOf(engineArgs, engineArgs.length);\n+        other.engineOptions = engineOptions == null ? null : Arrays.copyOf(engineOptions, engineOptions.length);\n@@ -143,2 +143,2 @@\n-    public CracBuilder engine(CracEngine engine, String... args) {\n-        assertTrue(this.engine == null || this.engine.equals(engine)); \/\/ allow overwriting args\n+    public CracBuilder engine(CracEngine engine) {\n+        assertTrue(this.engine == null || this.engine.equals(engine));\n@@ -146,1 +146,5 @@\n-        this.engineArgs = args;\n+        return this;\n+    }\n+\n+    public CracBuilder engineOptions(String... options) {\n+        this.engineOptions = options;\n@@ -487,5 +491,4 @@\n-            String engArgs = engineArgs == null || engineArgs.length == 0 ? \"\" :\n-                    \",\" + Arrays.stream(engineArgs)\n-                            .map(str -> str.replace(\",\", \"\\\\,\"))\n-                            .collect(Collectors.joining(\",\"));\n-            cmd.add(\"-XX:CRaCEngine=\" + engine.engine + engArgs);\n+            cmd.add(\"-XX:CRaCEngine=\" + engine.engine);\n+        }\n+        if (engineOptions != null) {\n+            cmd.add(\"-XX:CRaCEngineOptions=\" + String.join(\",\", engineOptions));\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"}]}