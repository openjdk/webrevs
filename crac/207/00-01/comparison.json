{"files":[{"patch":"@@ -211,0 +211,1 @@\n+    LINK_TYPE := C++, \\\n@@ -212,2 +213,2 @@\n-    CFLAGS := $(CFLAGS_JDKLIB) -DCRLIB_IS_IMPL, \\\n-    CFLAGS_windows := -D_WINDOWS -DWIN32, \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB) -DCRLIB_IS_IMPL, \\\n+    CXXFLAGS_windows := -D_WINDOWS -DWIN32, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-typedef struct crlib_extension {\n+struct crlib_extension {\n@@ -45,1 +45,2 @@\n-} crlib_extension_t;\n+};\n+typedef const struct crlib_extension crlib_extension_t;\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CRLIB_DESCRIPTION_H\n+#define CRLIB_DESCRIPTION_H\n+\n+#include \"crlib.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CRLIB_EXTENSION_DESCRIPTION_NAME \"description\"\n+#define CRLIB_EXTENSION_DESCRIPTION(api) \\\n+  CRLIB_EXTENSION(api, crlib_description_t, CRLIB_EXTENSION_DESCRIPTION_NAME)\n+\n+\/\/ API for obtaining engine description.\n+\/\/\n+\/\/ Unless noted otherwise, storage duration of the returned data should (1) be either static or\n+\/\/ tied to the storage duration of conf, (2) not change between calls with the same arguments.\n+struct crlib_description {\n+  crlib_extension_t header;\n+\n+  \/\/ Returns a valid C-string containing concise information about the engine, e.g. its name and\n+  \/\/ version, or null on error.\n+  const char *(*identity)(crlib_conf_t *);\n+  \/\/ Returns a valid C-string containing a short user-friendly description of the engine, or null\n+  \/\/ on error.\n+  const char *(*description)(crlib_conf_t *);\n+\n+  \/\/ Returns a valid C-string with a formatted list of configuration keys supported by the engine\n+  \/\/ with their descriptions, or null on error.\n+  \/\/\n+  \/\/ Some keys can be excluded if they are not supposed to be set by a user but rather by the\n+  \/\/ application the engine is linked to.\n+  \/\/\n+  \/\/ Example:\n+  \/\/ \"\n+  \/\/ * do_stuff=<true\/false> (default: true) — whether to do stuff.\\n\n+  \/\/ * args=<string> (default: \\\"\\\") — other arguments.\n+  \/\/ \"\n+  const char *(*configuration_doc)(crlib_conf_t *);\n+\n+  \/\/ Returns a null-terminated array of all configuration keys supported by the engine, or null if\n+  \/\/ this method is not supported.\n+  const char * const *(*configurable_keys)(crlib_conf_t *);\n+  \/\/ Returns a null-terminated array of all API extensions supported by the engine, or null if this\n+  \/\/ method is not supported.\n+  crlib_extension_t * const *(*supported_extensions)(crlib_conf_t *);\n+};\n+typedef const struct crlib_description crlib_description_t;\n+\n+#ifdef __cplusplus\n+} \/\/ extern \"C\"\n+#endif\n+\n+#endif \/\/ CRLIB_DESCRIPTION_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib_description.h","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -3091,0 +3091,4 @@\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return JNI_ERR;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-#include \"crlib\/crlib.h\"\n-#include \"crlib\/crlib_restore_data.h\"\n@@ -38,0 +36,1 @@\n+#include \"runtime\/crac_engine.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -48,0 +48,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -56,1 +57,1 @@\n-const crac::EngineHandle *crac::_engine = nullptr;\n+CracEngine *crac::_engine = nullptr;\n@@ -102,279 +103,0 @@\n-#ifdef _WINDOWS\n-static char *strsep(char **strp, const char *delim) {\n-  char *str = *strp;\n-  if (str == nullptr) {\n-    return nullptr;\n-  }\n-  size_t len = strcspn(str, delim);\n-  if (str[len] == '\\0') {\n-    *strp = nullptr;\n-    return str;\n-  }\n-  str[len] = '\\0';\n-  *strp += len + 1;\n-  return str;\n-}\n-#endif \/\/ _WINDOWS\n-\n-class crac::EngineHandle : public CHeapObj<mtInternal> {\n-private:\n-  void *_lib = nullptr;\n-  crlib_api_t *_api = nullptr;\n-  crlib_conf_t *_conf = nullptr;\n-\n-public:\n-  \/\/ Use is_initialized() to check whether the constructor succeeded.\n-  explicit EngineHandle(bool checkpoint);\n-  ~EngineHandle();\n-\n-  crlib_api_t *api() const   { return _api; }\n-  crlib_conf_t *conf() const { return _conf; }\n-\n-  bool is_initialized() const {\n-    assert((_lib == nullptr && _api == nullptr && _conf == nullptr) ||\n-           (_lib != nullptr && _api != nullptr && _conf != nullptr), \"invariant\");\n-    return _lib != nullptr;\n-  }\n-};\n-\n-static bool find_crac_engine(const char *dll_dir, char *path, size_t path_size, bool *is_library) {\n-  \/\/ Try to interpret as a file path\n-  if (os::is_path_absolute(CRaCEngine)) {\n-    const size_t path_len = strlen(CRaCEngine);\n-    if (path_len + 1 > path_size) {\n-      log_error(crac)(\"CRaCEngine file path is too long: %s\", CRaCEngine);\n-      return false;\n-    }\n-\n-    if (!os::file_exists(CRaCEngine)) {\n-      log_error(crac)(\"CRaCEngine file does not exist: %s\", CRaCEngine);\n-      return false;\n-    }\n-\n-    strcpy(path, CRaCEngine);\n-\n-    const char *last_slash = strrchr(CRaCEngine, *os::file_separator());\n-    const char *basename;\n-    if (last_slash == nullptr) {\n-      basename = CRaCEngine;\n-    } else {\n-      basename = last_slash + strlen(os::file_separator());\n-    }\n-    *is_library = strncmp(basename, JNI_LIB_PREFIX, strlen(JNI_LIB_PREFIX)) == 0 &&\n-      strcmp(path + path_len - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0;\n-    log_debug(crac)(\"CRaCEngine path %s is %s library\", CRaCEngine, *is_library ? \"a\" : \"not a\");\n-\n-    return true;\n-  }\n-\n-  \/\/ Try to interpret as a library name\n-  if (os::dll_locate_lib(path, path_size, dll_dir, CRaCEngine)) {\n-    *is_library = true;\n-    log_debug(crac)(\"Found CRaCEngine %s as a library in %s\", CRaCEngine, path);\n-    return true;\n-  }\n-\n-  *is_library = false;\n-  log_debug(crac)(\"CRaCEngine %s is not a library in %s\", CRaCEngine, dll_dir);\n-\n-#ifdef _WINDOWS\n-  const char *suffix = \".exe\";\n-#else\n-  const char *suffix = \"\";\n-#endif \/\/ ! _WINDOWS\n-#ifndef S_ISREG\n-# define S_ISREG(__mode) ((__mode & S_IFMT) == S_IFREG)\n-#endif \/\/ S_ISREG\n-  struct stat st;\n-\n-  \/\/ Try to interpret as an executable name with \"engine\" suffix omitted\n-  size_t path_len = strlen(dll_dir) + strlen(os::file_separator()) + strlen(CRaCEngine) + strlen(\"engine\") + strlen(suffix);\n-  if (path_len + 1 <= path_size) {\n-    os::snprintf_checked(path, path_size, \"%s%s%sengine%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n-    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n-      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n-      return true;\n-    }\n-  } else {\n-    log_debug(crac)(\"Not looking for CRaCEngine an executable name with 'engine' omitted: path is too long\");\n-  }\n-\n-  \/\/ Try to interpret as an executable name\n-  precond(path_len > strlen(\"engine\"));\n-  path_len -= strlen(\"engine\");\n-  if (path_len + 1 <= path_size) {\n-    os::snprintf_checked(path, path_size, \"%s%s%s%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n-    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n-      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n-      return true;\n-    }\n-  } else {\n-    log_debug(crac)(\"Not looking for CRaCEngine as an executable name: path is too long\");\n-  }\n-\n-  return false;\n-}\n-\n-\/\/ CRaC engine configuration options JVM sets directly instead of relaying from the user\n-#define ENGINE_OPT_IMAGE_LOCATION \"image_location\"\n-#define ENGINE_OPT_EXEC_LOCATION \"exec_location\"\n-\n-static bool configure_image_location(const crlib_api_t &api, crlib_conf_t *conf, const char *image_location) {\n-  precond(image_location != nullptr && image_location[0] != '\\0');\n-  if (!api.configure(conf, ENGINE_OPT_IMAGE_LOCATION, image_location)) {\n-    log_error(crac)(\"CRaC engine failed to configure: '\" ENGINE_OPT_IMAGE_LOCATION \"' = '%s'\", image_location);\n-    return false;\n-  }\n-  return true;\n-}\n-\n-static crlib_conf_t *create_engine_conf(\n-    const crlib_api_t &api, const char *image_location, const char *exec_location) {\n-  crlib_conf_t * const conf = api.create_conf();\n-  if (conf == nullptr) {\n-    log_error(crac)(\"CRaC engine failed to create its configuration\");\n-    return nullptr;\n-  }\n-\n-  if (!configure_image_location(api, conf, image_location)) {\n-    api.destroy_conf(conf);\n-    return nullptr;\n-  }\n-\n-  if (exec_location != nullptr) { \/\/ Only passed when using crexec\n-    guarantee(api.can_configure(conf, ENGINE_OPT_EXEC_LOCATION),\n-              \"crexec does not support an internal option: \" ENGINE_OPT_EXEC_LOCATION);\n-    if (!api.configure(conf, ENGINE_OPT_EXEC_LOCATION, exec_location)) {\n-      log_error(crac)(\"crexec failed to configure: '\" ENGINE_OPT_EXEC_LOCATION \"' = '%s'\", exec_location);\n-      api.destroy_conf(conf);\n-      return nullptr;\n-    }\n-  }\n-\n-  if (CRaCEngineOptions == nullptr || CRaCEngineOptions[0] == '\\0' \/* possible for ccstrlist *\/) {\n-    return conf;\n-  }\n-\n-  char *engine_options = os::strdup_check_oom(CRaCEngineOptions, mtInternal);\n-  char *const engine_options_start = engine_options;\n-  do {\n-    char *key_value = strsep(&engine_options, \",\");\n-    const char *key = strsep(&key_value, \"=\");\n-    const char *value = key_value != nullptr ? key_value : \"\";\n-    assert(key != nullptr, \"Should have terminated before\");\n-    if (strcmp(key, ENGINE_OPT_IMAGE_LOCATION) == 0 ||\n-        (exec_location != nullptr && strcmp(key, ENGINE_OPT_EXEC_LOCATION) == 0)) {\n-      log_warning(crac)(\"Internal CRaC engine option provided, skipping: %s\", key);\n-      continue;\n-    }\n-    if (!api.configure(conf, key, value)) {\n-      log_error(crac)(\"CRaC engine failed to configure: '%s' = '%s'\", key, value);\n-      os::free(engine_options_start);\n-      api.destroy_conf(conf);\n-      return nullptr;\n-    }\n-    log_debug(crac)(\"CRaC engine option: '%s' = '%s'\", key, value);\n-  } while (engine_options != nullptr);\n-  os::free(engine_options_start);\n-\n-  return conf;\n-}\n-\n-crac::EngineHandle::EngineHandle(bool checkpoint) {\n-  if (CRaCEngine == nullptr) {\n-    log_error(crac)(\"CRaCEngine must not be empty\");\n-    return;\n-  }\n-\n-  \/\/ Arguments::get_dll_dir() might not have been initialized yet\n-  char dll_dir[JVM_MAXPATHLEN];\n-  os::jvm_path(dll_dir, sizeof(dll_dir));\n-  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n-  char *after_elem = nullptr;\n-  for (int i = 0; i < 2; ++i) {\n-    after_elem = strrchr(dll_dir, *os::file_separator());\n-    *after_elem = '\\0';\n-  }\n-\n-  char path[JVM_MAXPATHLEN];\n-  bool is_library;\n-  if (!find_crac_engine(dll_dir, path, sizeof(path), &is_library)) {\n-    log_error(crac)(\"Cannot find CRaC engine %s\", CRaCEngine);\n-    return;\n-  }\n-  postcond(path[0] != '\\0');\n-\n-  char exec_path[JVM_MAXPATHLEN] = \"\\0\";\n-  if (!is_library) {\n-    strcpy(exec_path, path); \/\/ Save to later pass it to crexec\n-    if (!os::dll_locate_lib(path, sizeof(path), dll_dir, \"crexec\")) {\n-      log_error(crac)(\"Cannot find crexec library to use CRaCEngine executable\");\n-      return;\n-    }\n-  }\n-\n-  char error_buf[1024];\n-  void * const lib = os::dll_load(path, error_buf, sizeof(error_buf));\n-  if (lib == nullptr) {\n-    log_error(crac)(\"Cannot load CRaC engine library from %s: %s\", path, error_buf);\n-    return;\n-  }\n-\n-  using api_func_t = decltype(&CRLIB_API);\n-  const auto api_func = reinterpret_cast<api_func_t>(os::dll_lookup(lib, CRLIB_API_FUNC));\n-  if (api_func == nullptr) {\n-    log_error(crac)(\"Cannot load CRaC engine library entrypoint '\" CRLIB_API_FUNC \"' from %s\", path);\n-    os::dll_unload(lib);\n-    return;\n-  }\n-\n-  crlib_api_t * const api = api_func(CRLIB_API_VERSION, sizeof(crlib_api_t));\n-  if (api == nullptr) {\n-    log_error(crac)(\"CRaC engine failed to initialize its API (version %i). \"\n-                    \"Maybe this version is not supported?\", CRLIB_API_VERSION);\n-    os::dll_unload(lib);\n-    return;\n-  }\n-  if (api->create_conf == nullptr || api->destroy_conf == nullptr ||\n-      api->checkpoint == nullptr || api->restore == nullptr ||\n-      api->can_configure == nullptr || api->configure == nullptr ||\n-      api->get_extension == nullptr) {\n-    log_error(crac)(\"CRaC engine failed to fully initialize its API\");\n-    os::dll_unload(lib);\n-    return;\n-  }\n-\n-  const char *image_location = checkpoint ? CRaCCheckpointTo : CRaCRestoreFrom;\n-  const char *exec_location = exec_path[0] != '\\0' ? exec_path : nullptr;\n-  crlib_conf_t * const conf = create_engine_conf(*api, image_location, exec_location);\n-  if (conf == nullptr) {\n-    os::dll_unload(lib);\n-    return;\n-  }\n-\n-  _lib = lib;\n-  _api = api;\n-  _conf = conf;\n-}\n-\n-crac::EngineHandle::~EngineHandle() {\n-  if (is_initialized()) {\n-    _api->destroy_conf(_conf);\n-    os::dll_unload(_lib);\n-  }\n-}\n-\n-static crlib_restore_data_t *get_restore_data_api(const crlib_api_t *api) {\n-  precond(api != nullptr);\n-  crlib_restore_data_t * const restore_data_api = CRLIB_EXTENSION_RESTORE_DATA(api);\n-  if (restore_data_api == nullptr) {\n-    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n-    return nullptr;\n-  }\n-  if (restore_data_api->set_restore_data == nullptr || restore_data_api->get_restore_data == nullptr) {\n-    log_debug(crac)(\"CRaC engine failed to fully initialize API extension: %s\", CRLIB_EXTENSION_RESTORE_DATA_NAME);\n-    return nullptr;\n-  }\n-  return restore_data_api;\n-}\n-\n@@ -392,1 +114,1 @@\n-  if (!configure_image_location(*_engine->api(), _engine->conf(), CRaCCheckpointTo)) {\n+  if (!_engine->configure_image_location(CRaCCheckpointTo)) {\n@@ -396,1 +118,1 @@\n-  const int ret = _engine->api()->checkpoint(_engine->conf());\n+  const int ret = _engine->checkpoint();\n@@ -402,6 +124,16 @@\n-  const auto *restore_data_api = get_restore_data_api(_engine->api());\n-  if (restore_data_api == nullptr) {\n-    *shmid = 0; \/\/ Not an error, just no restore data\n-  } else if (restore_data_api->get_restore_data(_engine->conf(), shmid, sizeof(*shmid)) < sizeof(*shmid)) {\n-    log_error(crac)(\"CRaC engine failed to provide restore data\");\n-    *shmid = -1; \/\/ Error\n+  switch (_engine->prepare_restore_data_api()) {\n+    case CracEngine::ApiStatus::OK: {\n+      constexpr size_t required_size = sizeof(*shmid);\n+      const size_t available_size = _engine->get_restore_data(shmid, sizeof(*shmid));\n+      if (available_size == required_size) {\n+        break;\n+      }\n+      if (available_size > required_size) {\n+        log_debug(crac)(\"CRaC engine has more restore data than expected\");\n+        break;\n+      }\n+      log_error(crac)(\"CRaC engine failed to provide restore data\");\n+      \/\/ fallthrough\n+    }\n+    case CracEngine::ApiStatus::ERR:         *shmid = -1; break; \/\/ Indicates error to the caller\n+    case CracEngine::ApiStatus::UNSUPPORTED: *shmid = 0;  break; \/\/ Not an error, just no restore data\n@@ -556,0 +288,39 @@\n+void crac::print_engine_info_and_exit() {\n+  auto engine = CracEngine();\n+  if (!engine.is_initialized()) {\n+    return;\n+  }\n+\n+  const CracEngine::ApiStatus status = engine.prepare_description_api();\n+  if (status == CracEngine::ApiStatus::ERR) {\n+    return;\n+  }\n+  if (status == CracEngine::ApiStatus::UNSUPPORTED) {\n+    if (printf(\"Selected CRaC engine does not provide information about itself.\\n\") < 0) {\n+      log_error(crac)(\"printf failed\");\n+      return;\n+    }\n+    vm_exit(0);\n+    ShouldNotReachHere();\n+  }\n+  postcond(status == CracEngine::ApiStatus::OK);\n+\n+  const char *description = engine.description();\n+  if (description == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to provide its textual description\");\n+    return;\n+  }\n+  const char *conf_doc = engine.configuration_doc();\n+  if (conf_doc == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to provide documentation of its configuration options\");\n+    return;\n+  }\n+  if (printf(\"%s\\n\\nConfiguration options:\\n%s\\n\", description, conf_doc) < 0) {\n+    log_error(crac)(\"printf failed\");\n+    return;\n+  }\n+\n+  vm_exit(0);\n+  ShouldNotReachHere();\n+}\n+\n@@ -578,1 +349,1 @@\n-  _engine = new EngineHandle(true);\n+  _engine = new CracEngine(CRaCCheckpointTo);\n@@ -721,1 +492,1 @@\n-  const EngineHandle engine = EngineHandle(false);\n+  auto engine = CracEngine(CRaCRestoreFrom);\n@@ -726,25 +497,27 @@\n-  const auto *restore_data_api = get_restore_data_api(engine.api());\n-  if (restore_data_api != nullptr) {\n-    const int shmid = os::current_process_id();\n-    CracSHM shm(shmid);\n-    const int shmfd = shm.open(O_RDWR | O_CREAT | O_TRUNC);\n-    if (shmfd < 0) {\n-      log_error(crac)(\"Failed to open a space shared with restored process\");\n-      return;\n-    }\n-    const bool write_success = CracRestoreParameters::write_to(\n-      shmfd,\n-      Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n-      Arguments::system_properties(),\n-      Arguments::java_command_crac() ? Arguments::java_command_crac() : \"\",\n-      restore_data.restore_time,\n-      restore_data.restore_nanos\n-    );\n-    close(shmfd);\n-    if (!write_success) {\n-      log_error(crac)(\"Failed to write to a space shared with restored process\");\n-      return;\n-    }\n-    if (!restore_data_api->set_restore_data(engine.conf(), &shmid, sizeof(shmid))) {\n-      log_error(crac)(\"CRaC engine failed to record restore data\");\n-      return;\n+  switch (engine.prepare_restore_data_api()) {\n+    case CracEngine::ApiStatus::OK: {\n+      const int shmid = os::current_process_id();\n+      CracSHM shm(shmid);\n+      const int shmfd = shm.open(O_RDWR | O_CREAT | O_TRUNC);\n+      if (shmfd < 0) {\n+        log_error(crac)(\"Failed to open a space shared with restored process\");\n+        return;\n+      }\n+      const bool write_success = CracRestoreParameters::write_to(\n+        shmfd,\n+        Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n+        Arguments::system_properties(),\n+        Arguments::java_command_crac() ? Arguments::java_command_crac() : \"\",\n+        restore_data.restore_time,\n+        restore_data.restore_nanos\n+      );\n+      close(shmfd);\n+      if (!write_success) {\n+        log_error(crac)(\"Failed to write to a space shared with restored process\");\n+        return;\n+      }\n+      if (!engine.set_restore_data(&shmid, sizeof(shmid))) {\n+        log_error(crac)(\"CRaC engine failed to record restore data\");\n+        return;\n+      }\n+      break;\n@@ -752,3 +525,5 @@\n-  } else {\n-    log_warning(crac)(\"Cannot pass restore parameters (JVM flags, env vars, system properties, arguments...) \"\n-                      \"with the selected CRaC engine\");\n+    case CracEngine::ApiStatus::ERR: break;\n+    case CracEngine::ApiStatus::UNSUPPORTED:\n+      log_warning(crac)(\"Cannot pass restore parameters (JVM flags, env vars, system properties, arguments...) \"\n+        \"with the selected CRaC engine\");\n+      break;\n@@ -757,1 +532,1 @@\n-  const int ret = engine.api()->restore(engine.conf());\n+  const int ret = engine.restore();\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":96,"deletions":321,"binary":false,"changes":417,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/crac_engine.hpp\"\n@@ -29,1 +30,1 @@\n-#include \"utilities\/macros.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n@@ -37,0 +38,1 @@\n+  static void print_engine_info_and_exit();\n@@ -38,0 +40,1 @@\n+\n@@ -63,2 +66,1 @@\n-  class EngineHandle;\n-  static const EngineHandle *_engine;\n+  static CracEngine *_engine;\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,337 @@\n+#include \"precompiled.hpp\"\n+\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/crac_engine.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <cstddef>\n+#include <cstring>\n+\n+\/\/ CRaC engine configuration options JVM sets directly instead of relaying from the user\n+#define ENGINE_OPT_IMAGE_LOCATION \"image_location\"\n+#define ENGINE_OPT_EXEC_LOCATION \"exec_location\"\n+\n+#ifdef _WINDOWS\n+static char *strsep(char **strp, const char *delim) {\n+  char *str = *strp;\n+  if (str == nullptr) {\n+    return nullptr;\n+  }\n+  size_t len = strcspn(str, delim);\n+  if (str[len] == '\\0') {\n+    *strp = nullptr;\n+    return str;\n+  }\n+  str[len] = '\\0';\n+  *strp += len + 1;\n+  return str;\n+}\n+#endif \/\/ _WINDOWS\n+\n+static bool find_engine(const char *dll_dir, char *path, size_t path_size, bool *is_library) {\n+  \/\/ Try to interpret as a file path\n+  if (os::is_path_absolute(CRaCEngine)) {\n+    const size_t path_len = strlen(CRaCEngine);\n+    if (path_len + 1 > path_size) {\n+      log_error(crac)(\"CRaCEngine file path is too long: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    if (!os::file_exists(CRaCEngine)) {\n+      log_error(crac)(\"CRaCEngine file does not exist: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    strcpy(path, CRaCEngine);\n+\n+    const char *last_slash = strrchr(CRaCEngine, *os::file_separator());\n+    const char *basename;\n+    if (last_slash == nullptr) {\n+      basename = CRaCEngine;\n+    } else {\n+      basename = last_slash + strlen(os::file_separator());\n+    }\n+    *is_library = strncmp(basename, JNI_LIB_PREFIX, strlen(JNI_LIB_PREFIX)) == 0 &&\n+      strcmp(path + path_len - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0;\n+    log_debug(crac)(\"CRaCEngine path %s is %s library\", CRaCEngine, *is_library ? \"a\" : \"not a\");\n+\n+    return true;\n+  }\n+\n+  \/\/ Try to interpret as a library name\n+  if (os::dll_locate_lib(path, path_size, dll_dir, CRaCEngine)) {\n+    *is_library = true;\n+    log_debug(crac)(\"Found CRaCEngine %s as a library in %s\", CRaCEngine, path);\n+    return true;\n+  }\n+\n+  *is_library = false;\n+  log_debug(crac)(\"CRaCEngine %s is not a library in %s\", CRaCEngine, dll_dir);\n+\n+  constexpr const char suffix[] = WINDOWS_ONLY(\".exe\") NOT_WINDOWS(\"\");\n+#ifndef S_ISREG\n+# define S_ISREG(__mode) ((__mode & S_IFMT) == S_IFREG)\n+#endif \/\/ S_ISREG\n+  struct stat st;\n+\n+  \/\/ Try to interpret as an executable name with \"engine\" suffix omitted\n+  size_t path_len = strlen(dll_dir) + strlen(os::file_separator()) + strlen(CRaCEngine) + strlen(\"engine\") + strlen(suffix);\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%sengine%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n+    }\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine an executable name with 'engine' omitted: path is too long\");\n+  }\n+\n+  \/\/ Try to interpret as an executable name\n+  precond(path_len > strlen(\"engine\"));\n+  path_len -= strlen(\"engine\");\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%s%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n+    }\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine as an executable name: path is too long\");\n+  }\n+\n+  return false;\n+}\n+\n+static bool configure_image_location(const crlib_api_t &api, crlib_conf_t *conf, const char *image_location) {\n+  precond(image_location != nullptr && image_location[0] != '\\0');\n+  if (!api.configure(conf, ENGINE_OPT_IMAGE_LOCATION, image_location)) {\n+    log_error(crac)(\"CRaC engine failed to configure: '\" ENGINE_OPT_IMAGE_LOCATION \"' = '%s'\", image_location);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+static crlib_conf_t *create_conf(const crlib_api_t &api, const char *image_location, const char *exec_location) {\n+  crlib_conf_t * const conf = api.create_conf();\n+  if (conf == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to create its configuration\");\n+    return nullptr;\n+  }\n+\n+  if (CRaCEngineOptions != nullptr && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    return conf;\n+  }\n+\n+  if (image_location != nullptr && !configure_image_location(api, conf, image_location)) {\n+    api.destroy_conf(conf);\n+    return nullptr;\n+  }\n+\n+  if (exec_location != nullptr) { \/\/ Only passed when using crexec\n+    guarantee(api.can_configure(conf, ENGINE_OPT_EXEC_LOCATION),\n+              \"crexec does not support an internal option: \" ENGINE_OPT_EXEC_LOCATION);\n+    if (!api.configure(conf, ENGINE_OPT_EXEC_LOCATION, exec_location)) {\n+      log_error(crac)(\"crexec failed to configure: '\" ENGINE_OPT_EXEC_LOCATION \"' = '%s'\", exec_location);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+  }\n+\n+  if (CRaCEngineOptions == nullptr || CRaCEngineOptions[0] == '\\0' \/* possible for ccstrlist *\/) {\n+    return conf;\n+  }\n+\n+  char *engine_options = os::strdup_check_oom(CRaCEngineOptions, mtInternal);\n+  char *const engine_options_start = engine_options;\n+  do {\n+    char *key_value = strsep(&engine_options, \",\\n\"); \/\/ '\\n' appears when ccstrlist is appended to\n+    const char *key = strsep(&key_value, \"=\");\n+    const char *value = key_value != nullptr ? key_value : \"\";\n+    assert(key != nullptr, \"Should have terminated before\");\n+    if (strcmp(key, ENGINE_OPT_IMAGE_LOCATION) == 0 ||\n+        (exec_location != nullptr && strcmp(key, ENGINE_OPT_EXEC_LOCATION) == 0)) {\n+      log_warning(crac)(\"Internal CRaC engine option provided, skipping: %s\", key);\n+      continue;\n+    }\n+    if (!api.configure(conf, key, value)) {\n+      log_error(crac)(\"CRaC engine failed to configure: '%s' = '%s'\", key, value);\n+      os::free(engine_options_start);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+    log_debug(crac)(\"CRaC engine option: '%s' = '%s'\", key, value);\n+  } while (engine_options != nullptr);\n+  os::free(engine_options_start);\n+\n+  return conf;\n+}\n+\n+CracEngine::CracEngine(const char *image_location) {\n+  if (CRaCEngine == nullptr) {\n+    log_error(crac)(\"CRaCEngine must not be empty\");\n+    return;\n+  }\n+\n+  \/\/ Arguments::get_dll_dir() might not have been initialized yet\n+  char dll_dir[JVM_MAXPATHLEN];\n+  os::jvm_path(dll_dir, sizeof(dll_dir));\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n+  char *after_elem = nullptr;\n+  for (int i = 0; i < 2; ++i) {\n+    after_elem = strrchr(dll_dir, *os::file_separator());\n+    *after_elem = '\\0';\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  bool is_library;\n+  if (!find_engine(dll_dir, path, sizeof(path), &is_library)) {\n+    log_error(crac)(\"Cannot find CRaC engine %s\", CRaCEngine);\n+    return;\n+  }\n+  postcond(path[0] != '\\0');\n+\n+  char exec_path[JVM_MAXPATHLEN] = \"\\0\";\n+  if (!is_library) {\n+    strcpy(exec_path, path); \/\/ Save to later pass it to crexec\n+    if (!os::dll_locate_lib(path, sizeof(path), dll_dir, \"crexec\")) {\n+      log_error(crac)(\"Cannot find crexec library to use CRaCEngine executable\");\n+      return;\n+    }\n+  }\n+\n+  char error_buf[1024];\n+  void * const lib = os::dll_load(path, error_buf, sizeof(error_buf));\n+  if (lib == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library from %s: %s\", path, error_buf);\n+    return;\n+  }\n+\n+  using api_func_t = decltype(&CRLIB_API);\n+  const auto api_func = reinterpret_cast<api_func_t>(os::dll_lookup(lib, CRLIB_API_FUNC));\n+  if (api_func == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library entrypoint '\" CRLIB_API_FUNC \"' from %s\", path);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  crlib_api_t * const api = api_func(CRLIB_API_VERSION, sizeof(crlib_api_t));\n+  if (api == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to initialize its API (version %i). \"\n+                    \"Maybe this version is not supported?\", CRLIB_API_VERSION);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+  if (api->create_conf == nullptr || api->destroy_conf == nullptr ||\n+      api->checkpoint == nullptr || api->restore == nullptr ||\n+      api->can_configure == nullptr || api->configure == nullptr ||\n+      api->get_extension == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid API\");\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  const char *exec_location = exec_path[0] != '\\0' ? exec_path : nullptr;\n+  crlib_conf_t * const conf = create_conf(*api, image_location, exec_location);\n+  if (conf == nullptr) {\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  _lib = lib;\n+  _api = api;\n+  _conf = conf;\n+}\n+\n+CracEngine::~CracEngine() {\n+  if (is_initialized()) {\n+    _api->destroy_conf(_conf);\n+    os::dll_unload(_lib);\n+  }\n+}\n+\n+bool CracEngine::is_initialized() const {\n+  assert((_lib == nullptr && _api == nullptr && _conf == nullptr) ||\n+          (_lib != nullptr && _api != nullptr && _conf != nullptr), \"invariant\");\n+  return _lib != nullptr;\n+}\n+\n+int CracEngine::checkpoint() const {\n+  precond(is_initialized());\n+  return _api->checkpoint(_conf);\n+}\n+\n+int CracEngine::restore() const {\n+  precond(is_initialized());\n+  return _api->restore(_conf);\n+}\n+\n+bool CracEngine::configure_image_location(const char *image_location) const {\n+  precond(is_initialized());\n+  return ::configure_image_location(*_api, _conf, image_location);\n+}\n+\n+CracEngine::ApiStatus CracEngine::prepare_restore_data_api() {\n+  precond(is_initialized());\n+  if (_restore_data_api != nullptr) {\n+    return ApiStatus::OK;\n+  }\n+\n+  crlib_restore_data_t * const restore_data_api = CRLIB_EXTENSION_RESTORE_DATA(_api);\n+  if (restore_data_api == nullptr) {\n+    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n+    return ApiStatus::UNSUPPORTED;\n+  }\n+  if (restore_data_api->set_restore_data == nullptr || restore_data_api->get_restore_data == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid restore data API\");\n+    return ApiStatus::ERR;\n+  }\n+  _restore_data_api = restore_data_api;\n+  return ApiStatus::OK;\n+}\n+\n+bool CracEngine::set_restore_data(const void *data, size_t size) const {\n+  precond(_restore_data_api != nullptr);\n+  return _restore_data_api->set_restore_data(_conf, data, size);\n+}\n+\n+size_t CracEngine::get_restore_data(void *buf, size_t size) const {\n+  precond(_restore_data_api != nullptr);\n+  return _restore_data_api->get_restore_data(_conf, buf, size);\n+}\n+\n+CracEngine::ApiStatus CracEngine::prepare_description_api() {\n+  precond(is_initialized());\n+  if (_description_api != nullptr) {\n+    return ApiStatus::OK;\n+  }\n+\n+  crlib_description_t * const description_api = CRLIB_EXTENSION_DESCRIPTION(_api);\n+  if (description_api == nullptr) {\n+    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_DESCRIPTION_NAME);\n+    return ApiStatus::UNSUPPORTED;\n+  }\n+  if (description_api->identity == nullptr || description_api->description == nullptr ||\n+      description_api->configuration_doc == nullptr ||\n+      description_api->configurable_keys == nullptr ||\n+      description_api->supported_extensions == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid restore data API\");\n+    return ApiStatus::ERR;\n+  }\n+  _description_api = description_api;\n+  return ApiStatus::OK;\n+}\n+\n+const char *CracEngine::description() const {\n+  precond(_description_api != nullptr);\n+  return _description_api->description(_conf);\n+}\n+\n+const char *CracEngine::configuration_doc() const {\n+  precond(_description_api != nullptr);\n+  return _description_api->configuration_doc(_conf);\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_ENGINE_HPP\n+#define SHARE_RUNTIME_CRAC_ENGINE_HPP\n+\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_description.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+\n+#include <cstddef>\n+\n+\/\/ CRaC engine library wrapper.\n+class CracEngine : public CHeapObj<mtInternal> {\n+public:\n+  explicit CracEngine(const char *image_location = nullptr);\n+  ~CracEngine();\n+\n+  \/\/ Use this to check whether the constructor succeeded.\n+  bool is_initialized() const;\n+\n+  \/\/ Operations supported by all engines\n+\n+  int checkpoint() const;\n+  int restore() const;\n+  bool configure_image_location(const char *image_location) const;\n+\n+  \/\/ Optionally-supported operations\n+\n+  enum class ApiStatus { OK, ERR, UNSUPPORTED };\n+\n+  ApiStatus prepare_restore_data_api();\n+  bool set_restore_data(const void *data, size_t size) const;\n+  size_t get_restore_data(void *buf, size_t size) const;\n+\n+  ApiStatus prepare_description_api();\n+  const char *description() const;\n+  const char *configuration_doc() const;\n+\n+private:\n+  void *_lib = nullptr;\n+  crlib_api_t *_api = nullptr;\n+  crlib_conf_t *_conf = nullptr;\n+\n+  crlib_restore_data_t *_restore_data_api = nullptr;\n+  crlib_description_t *_description_api = nullptr;\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_CRAC_ENGINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -1964,3 +1964,3 @@\n-      \"checkpoint and restore. On restore this value applies only to the \"  \\\n-      \"restoring VM, i.e. the restored VM keeps the value it had before \"   \\\n-      \"the checkpoint.\")                                                    \\\n+      \"checkpoint and restore. On restore this option applies only to \"     \\\n+      \"the restoring VM, i.e. the restored VM keeps the value it had \"      \\\n+      \"before the checkpoint.\")                                             \\\n@@ -1970,5 +1970,5 @@\n-      \"The list of supported options is engine-dependent. Engines are \"     \\\n-      \"encouraged to recognize 'help' option for printing information \"     \\\n-      \"about supported options. On restore this value applies only to the \" \\\n-      \"restoring VM, i.e. the restored VM keeps the value it had before \"   \\\n-      \"the checkpoint.\")                                                    \\\n+      \"The list of supported options is engine-dependent, use \"             \\\n+      \"'-XX:CRaCEngineOptions=help' to make the VM print the information \"  \\\n+      \"about the engine, including its supported options, and exit. On \"    \\\n+      \"restore this option applies only to the restoring VM, i.e. the \"     \\\n+      \"restored VM keeps the value it had before the checkpoint.\")          \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,527 +0,0 @@\n-\/*\n- * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <assert.h>\n-#include <stdbool.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"crlib\/crlib.h\"\n-#include \"crlib\/crlib_restore_data.h\"\n-#include \"hashtable.h\"\n-#include \"jni.h\"\n-\n-#ifdef LINUX\n-#include <signal.h>\n-\n-#include \"jvm.h\"\n-#endif \/\/ LINUX\n-\n-#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(*(x)))\n-\n-#define CREXEC \"crexec: \"\n-\n-\/\/ When adding a new option also add its description into the help message and\n-\/\/ ensure the proper default value is set for it on configuration init. Also\n-\/\/ consider checking for its inappropriate use on checkpoint\/restore.\n-\/\/\n-\/\/ More frequently used options should go first: this means they'll be the first\n-\/\/ to be placed in the options hash table which is implemented so that the keys\n-\/\/ added first are faster to find.\n-#define CONFIGURE_OPTIONS(OPT) \\\n-  OPT(exec_location, \"exec_location\") \\\n-  OPT(image_location, \"image_location\") \\\n-  OPT(keep_running, \"keep_running\") \\\n-  OPT(direct_map, \"direct_map\") \\\n-  OPT(args, \"args\") \\\n-  OPT(help, \"help\") \\\n-\n-#define DEFINE_OPT(id, str) static const char opt_##id[] = str;\n-CONFIGURE_OPTIONS(DEFINE_OPT)\n-#undef DEFINE_OPT\n-#define ADD_ARR_ELEM(id, str) opt_##id,\n-static const char *configure_options[] = { CONFIGURE_OPTIONS(ADD_ARR_ELEM) };\n-#undef ADD_ARR_ELEM\n-\n-\/\/ Indices of argv arrag members\n-enum Argv {\n-  ARGV_EXEC_LOCATION,\n-  ARGV_ACTION,\n-  ARGV_IMAGE_LOCATION,\n-  ARGV_FREE, \/\/ First index for user-provided arguments\n-  ARGV_LAST = 31,\n-};\n-\n-struct crlib_conf {\n-  hashtable_t *options;\n-\n-  bool keep_running;\n-  bool direct_map;\n-  int restore_data;\n-\n-  unsigned int argc;\n-  const char *argv[ARGV_LAST + 2]; \/\/ Last element is required to be null\n-};\n-\n-\/\/ crexec_md.c\n-const char *file_separator(void);\n-bool is_path_absolute(const char *path);\n-bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]);\n-char **get_environ(void);\n-void exec_in_this_process(const char *path, const char *argv[], const char *env[]);\n-\n-typedef bool (*configure_func)(crlib_conf_t *, const char *value);\n-\n-static bool configure_help(crlib_conf_t *conf, const char *ignored) {\n-  \/\/ Internal options which are expected to be set by the program crexec is linked against are\n-  \/\/ omitted from the print since users are not supposed to pass them directly:\n-  \/\/ * image_location=<path> — path to a directory with checkpoint\/restore files.\n-  \/\/ * exec_location=<path> — path to the engine executable.\n-  const int ret = printf(\n-    \"\\n\"\n-    \"crexec — pseudo-CRaC-engine used to relay data from JVM to a \\\"real\\\" engine implemented as \"\n-    \"an executable (instead of a library).\\n\"\n-    \"The engine executable is expected to have CRaC-CRIU-like CLI. Support of the options below \"\n-    \"also depends on the engine executable.\\n\"\n-    \"\\n\"\n-    \"Configuration options:\\n\"\n-    \"* keep_running=<true\/false> (default: false) — keep the process running after the checkpoint \"\n-    \"or kill it.\\n\"\n-    \"* direct_map=<true\/false> (default: false) — on restore, map process data directly from saved \"\n-    \"files. This may speedup the restore but the resulting process will not be the same as before \"\n-    \"the checkpoint.\\n\"\n-    \"* args=<string> (default: \\\"\\\") — free space-separated arguments passed directly to the \"\n-    \"engine executable, e.g. \\\"--arg1 --arg2 --arg3\\\".\\n\"\n-    \"* help — print this message.\\n\"\n-    \"\\n\"\n-  );\n-  return ret > 0;\n-}\n-\n-static char *strdup_checked(const char *src) {\n-  char *res = strdup(src);\n-  if (res == NULL) {\n-    fprintf(stderr, CREXEC \"out of memory\\n\");\n-  }\n-  return res;\n-}\n-\n-static bool parse_bool(const char *str, bool *result) {\n-  if (strcmp(str, \"true\") == 0) {\n-    *result = true;\n-    return true;\n-  }\n-  if (strcmp(str, \"false\") == 0) {\n-    *result = false;\n-    return true;\n-  }\n-  fprintf(stderr, CREXEC \"expected '%s' to be either 'true' or 'false'\\n\", str);\n-  return false;\n-}\n-\n-static bool configure_exec_location(crlib_conf_t *conf, const char *exec_location) {\n-  if (!is_path_absolute(exec_location)) {\n-    fprintf(stderr, CREXEC \"expected absolute path: %s\\n\", exec_location);\n-    return false;\n-  }\n-  free((char *) conf->argv[ARGV_EXEC_LOCATION]);\n-  conf->argv[ARGV_EXEC_LOCATION] = strdup_checked(exec_location);\n-  if (conf->argv[ARGV_EXEC_LOCATION] == NULL) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n-static bool configure_image_location(crlib_conf_t *conf, const char *image_location) {\n-  free((char *) conf->argv[ARGV_IMAGE_LOCATION]);\n-  conf->argv[ARGV_IMAGE_LOCATION] = strdup_checked(image_location);\n-  return conf->argv[ARGV_IMAGE_LOCATION] != NULL;\n-}\n-\n-static bool configure_keep_running(crlib_conf_t *conf, const char *keep_running_str) {\n-  return parse_bool(keep_running_str, &conf->keep_running);\n-}\n-\n-static bool configure_direct_map(crlib_conf_t *conf, const char *direct_map_str) {\n-  return parse_bool(direct_map_str, &conf->direct_map);\n-}\n-\n-static bool configure_args(crlib_conf_t *conf, const char *args) {\n-  free((char *) conf->argv[ARGV_FREE]);\n-  char *arg = strdup_checked(args);\n-  if (arg == NULL) {\n-    conf->argv[ARGV_FREE] = NULL;\n-    return false;\n-  }\n-\n-  assert(ARGV_FREE <= ARGV_LAST);\n-  for (int i = ARGV_FREE; i <= ARGV_LAST && arg[0] != '\\0'; i++) {\n-    conf->argv[i] = arg;\n-    char * const delim = strchr(arg, ' ');\n-    if (delim != NULL) {\n-      *delim = '\\0';\n-      arg = delim + 1;\n-    } else {\n-      arg = \"\\0\";\n-    }\n-  }\n-\n-  if (arg[0] != '\\0') {\n-    fprintf(stderr, CREXEC \"too many free arguments, at most %i are allowed\\n\",\n-            (ARGV_LAST - ARGV_FREE) + 1);\n-    free((char *) conf->argv[ARGV_FREE]);\n-    conf->argv[ARGV_FREE] = NULL;\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n-static bool can_configure(crlib_conf_t *conf, const char *key) {\n-  assert(key != NULL);\n-  return hashtable_contains(conf->options, key);\n-}\n-\n-static bool configure(crlib_conf_t *conf, const char *key, const char *value) {\n-  assert(key != NULL && value != NULL);\n-  const configure_func func = (configure_func) hashtable_get(conf->options, key);\n-  if (func != NULL) {\n-    return func(conf, value);\n-  }\n-  fprintf(stderr, CREXEC \"unknown configure option: %s\\n\", key);\n-  return false;\n-}\n-\n-static bool set_restore_data(crlib_conf_t *conf, const void *data, size_t size) {\n-  if (size != sizeof(conf->restore_data)) {\n-    fprintf(stderr, CREXEC \"unsupported size of restore data: %zu — only %zu is supported\\n\",\n-            size, sizeof(conf->restore_data));\n-    return false;\n-  }\n-  conf->restore_data = *(int *) data;\n-  return true;\n-}\n-\n-static size_t get_restore_data(crlib_conf_t *conf, void *buf, size_t size) {\n-  if (size < sizeof(conf->restore_data)) {\n-    fprintf(stderr, CREXEC \"can only provide >= %zu bytes of restore data but %zu was requested\\n\",\n-            sizeof(conf->restore_data), size);\n-    return 0;\n-  }\n-  *(int *) buf = conf->restore_data;\n-  return sizeof(conf->restore_data);\n-}\n-\n-static crlib_restore_data_t restore_data_extension = {\n-  .header = {\n-    .name = CRLIB_EXTENSION_RESTORE_DATA_NAME,\n-    .size = sizeof(crlib_restore_data_t)\n-  },\n-  .set_restore_data = set_restore_data,\n-  .get_restore_data = get_restore_data\n-};\n-\n-static const crlib_extension_t *extensions[] = { &restore_data_extension.header };\n-\n-static const crlib_extension_t *get_extension(const char *name, size_t size) {\n-  for (size_t i = 0; i < ARRAY_SIZE(extensions); i++) {\n-    const crlib_extension_t *ext = extensions[i];\n-    if (strcmp(name, ext->name) == 0) {\n-      if (size <= ext->size) {\n-        return ext;\n-      }\n-      return NULL;\n-    }\n-  }\n-  return NULL;\n-}\n-\n-static void destroy_conf(crlib_conf_t *conf) {\n-  if (conf == NULL) {\n-    return;\n-  }\n-  hashtable_destroy(conf->options);\n-  for (int i = 0; i <= ARGV_FREE \/* all free args are allocated together *\/; i++) {\n-    if (i != ARGV_ACTION) { \/\/ Action is a static string\n-      free((char*) conf->argv[i]);\n-    }\n-  }\n-  free(conf);\n-}\n-\n-static crlib_conf_t *create_conf() {\n-  crlib_conf_t * const conf = (crlib_conf_t *) malloc(sizeof(crlib_conf_t));\n-  if (conf == NULL) {\n-    fprintf(stderr, CREXEC \"out of memory\\n\");\n-    return NULL;\n-  }\n-  memset(conf, 0, sizeof(*conf));\n-\n-  conf->options = hashtable_create(configure_options, ARRAY_SIZE(configure_options));\n-  if (conf->options == NULL) {\n-    fprintf(stderr, CREXEC \"out of memory\\n\");\n-    destroy_conf(conf);\n-    return NULL;\n-  }\n-#define PUT_HANDLER(id, str) hashtable_put(conf->options, opt_##id, configure_##id);\n-  CONFIGURE_OPTIONS(PUT_HANDLER)\n-#undef PUT_HANDLER\n-\n-  return conf;\n-}\n-\n-static void free_environ(char **env) {\n-  for (size_t i = 0; env[i] != NULL; ++i) {\n-    free(env[i]);\n-  }\n-  free(env);\n-}\n-\n-static char **copy_environ(char * const *env) {\n-  size_t len = 0;\n-  for (; env[len] != NULL; len++) {}\n-\n-  char ** const new_env = malloc((len + 1) * sizeof(char *));\n-  if (new_env == NULL) {\n-    fprintf(stderr, CREXEC \"out of memory\\n\");\n-    return NULL;\n-  }\n-\n-  for (size_t i = 0; i < len; i++) {\n-    new_env[i] = strdup(env[i]);\n-    if (new_env[i] == NULL) {\n-      fprintf(stderr, CREXEC \"out of memory\\n\");\n-      free_environ(new_env);\n-      return NULL;\n-    }\n-  }\n-  new_env[len] = NULL;\n-\n-  return new_env;\n-}\n-\n-static char **set_env_var(char **env, const char *var, const char *value) {\n-  const size_t str_size = strlen(var) + strlen(\"=\") + strlen(value) + 1;\n-  char * const str = malloc(sizeof(char) * str_size);\n-  if (str == NULL) {\n-    fprintf(stderr, CREXEC \"out of memory\\n\");\n-    return NULL;\n-  }\n-  if (snprintf(str, str_size, \"%s=%s\", var, value) != (int) str_size - 1) {\n-    perror(CREXEC \"snprintf env var\");\n-    free(str);\n-    return NULL;\n-  }\n-\n-  size_t len = 0;\n-  for (; env[len] != NULL; len++) {}\n-\n-  char ** const new_env = realloc(env, (len + 2) * sizeof(char *));\n-  if (new_env == NULL) {\n-    fprintf(stderr, CREXEC \"out of memory\\n\");\n-    free(str);\n-    return NULL;\n-  }\n-\n-  new_env[len] = str;\n-  new_env[len + 1] = NULL;\n-\n-  return new_env;\n-}\n-\n-static char **add_criu_option(char **env, const char *opt) {\n-  static const char CRAC_CRIU_OPTS[] = \"CRAC_CRIU_OPTS\";\n-  static const size_t CRAC_CRIU_OPTS_LEN = ARRAY_SIZE(CRAC_CRIU_OPTS) - 1;\n-\n-  bool opts_found = false;\n-  size_t opts_index = 0;\n-  for (; env[opts_index] != NULL; opts_index++) {\n-    if (strcmp(env[opts_index], CRAC_CRIU_OPTS) == 0 && env[opts_index][CRAC_CRIU_OPTS_LEN] == '=') {\n-      opts_found = true;\n-      break;\n-    }\n-  }\n-\n-  if (!opts_found) {\n-    return set_env_var(env, CRAC_CRIU_OPTS, opt);\n-  }\n-\n-  if (strstr(env[opts_index] + CRAC_CRIU_OPTS_LEN + 1, opt) != NULL) {\n-    return env;\n-  }\n-\n-  const size_t new_opts_size = strlen(env[opts_index]) + strlen(\" \") + strlen(opt) + 1;\n-  char * const new_opts = malloc(new_opts_size * sizeof(char));\n-  if (new_opts == NULL) {\n-    fprintf(stderr, CREXEC \"out of memory\\n\");\n-    return NULL;\n-  }\n-  if (snprintf(new_opts, new_opts_size, \"%s %s\", env[opts_index], opt) != (int) new_opts_size - 1) {\n-    perror(CREXEC \"snprintf CRAC_CRIU_OPTS (append)\");\n-    free(new_opts);\n-    return NULL;\n-  }\n-  free(env[opts_index]);\n-  env[opts_index] = new_opts;\n-\n-  return env;\n-}\n-\n-static int checkpoint(crlib_conf_t *conf) {\n-  if (conf->argv[ARGV_EXEC_LOCATION] == NULL) {\n-    fprintf(stderr, CREXEC \"%s must be set before checkpoint\\n\", opt_exec_location);\n-    return -1;\n-  }\n-  if (conf->argv[ARGV_IMAGE_LOCATION] == NULL) {\n-    fprintf(stderr, CREXEC \"%s must be set before checkpoint\\n\", opt_image_location);\n-    return -1;\n-  }\n-  conf->argv[ARGV_ACTION] = \"checkpoint\";\n-\n-  if (conf->direct_map) {\n-    fprintf(stderr, CREXEC \"%s has no effect on checkpoint\\n\", opt_direct_map);\n-  }\n-\n-  char **env = copy_environ(get_environ());\n-  if (env == NULL) {\n-    return -1;\n-  }\n-  if (conf->keep_running) {\n-    char ** const new_env = set_env_var(env, \"CRAC_CRIU_LEAVE_RUNNING\", \"\");\n-    if (new_env == NULL) {\n-      free_environ(env);\n-      return -1;\n-    }\n-    env = new_env;\n-  }\n-\n-  const bool ok = exec_child_process_and_wait(conf->argv[ARGV_EXEC_LOCATION],\n-                                              (char **) conf->argv, env);\n-  free_environ(env);\n-  if (!ok) {\n-    return -1;\n-  }\n-\n-#ifdef LINUX\n-  siginfo_t info;\n-  sigset_t waitmask;\n-  sigemptyset(&waitmask);\n-  sigaddset(&waitmask, RESTORE_SIGNAL);\n-\n-  int sig;\n-  do {\n-    sig = sigwaitinfo(&waitmask, &info);\n-  } while (sig == -1 && errno == EINTR);\n-\n-  if (info.si_code != SI_QUEUE) {\n-    return false;\n-  }\n-  conf->restore_data = info.si_int;\n-#endif \/\/ LINUX\n-\n-  return 0;\n-}\n-\n-static int restore(crlib_conf_t *conf) {\n-  if (conf->argv[ARGV_EXEC_LOCATION] == NULL) {\n-    fprintf(stderr, CREXEC \"%s must be set before restore\\n\", opt_exec_location);\n-    return -1;\n-  }\n-  if (conf->argv[ARGV_IMAGE_LOCATION] == NULL) {\n-    fprintf(stderr, CREXEC \"%s must be set before restore\\n\", opt_image_location);\n-    return -1;\n-  }\n-  conf->argv[ARGV_ACTION] = \"restore\";\n-\n-  if (conf->keep_running) {\n-    fprintf(stderr, CREXEC \"%s has no effect on restore\\n\", opt_keep_running);\n-  }\n-\n-  char **env = copy_environ(get_environ());\n-  if (env == NULL) {\n-    return -1;\n-  }\n-\n-  {\n-    char ** const new_env = set_env_var(env, \"CRAC_CRIU_LEAVE_RUNNING\", \"\");\n-    if (new_env == NULL) {\n-      free_environ(env);\n-      return -1;\n-    }\n-    env = new_env;\n-  }\n-\n-  char restore_data_str[32];\n-  if (snprintf(restore_data_str, sizeof(restore_data_str), \"%i\", conf->restore_data) >\n-      (int) sizeof(restore_data_str) - 1) {\n-    perror(CREXEC \"snprintf restore data\");\n-    free_environ(env);\n-    return -1;\n-  }\n-  {\n-    char ** const new_env = set_env_var(env, \"CRAC_NEW_ARGS_ID\", restore_data_str);\n-    if (new_env == NULL) {\n-      free_environ(env);\n-      return -1;\n-    }\n-    env = new_env;\n-  }\n-\n-  if (!conf->direct_map) {\n-    char ** const new_env = add_criu_option(env, \"--no-mmap-page-image\");\n-    if (new_env == NULL) {\n-      free_environ(env);\n-      return -1;\n-    }\n-    env = new_env;\n-  }\n-\n-  exec_in_this_process(conf->argv[ARGV_EXEC_LOCATION], conf->argv, (const char **) env);\n-\n-  free_environ(env); \/\/ shouldn't be needed\n-  fprintf(stderr, CREXEC \"restore failed\\n\");\n-  return -1;\n-}\n-\n-static struct crlib_api api = {\n-  .create_conf = create_conf,\n-  .destroy_conf = destroy_conf,\n-  .checkpoint = checkpoint,\n-  .restore = restore,\n-  .can_configure = can_configure,\n-  .configure = configure,\n-  .get_extension = get_extension,\n-};\n-\n-JNIEXPORT crlib_api_t *CRLIB_API(int api_version, size_t api_size) {\n-  if (api_version != CRLIB_API_VERSION) {\n-    return NULL;\n-  }\n-  if (sizeof(crlib_api_t) < api_size) {\n-    return NULL;\n-  }\n-  return &api;\n-}\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.c","additions":0,"deletions":527,"binary":false,"changes":527,"status":"deleted"},{"patch":"@@ -0,0 +1,594 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <cassert>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <cstring>\n+#include <new>\n+\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_description.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n+#include \"hashtable.hpp\"\n+#include \"jni.h\"\n+\n+#ifdef LINUX\n+#include <csignal>\n+\n+#include \"jvm.h\"\n+#endif \/\/ LINUX\n+\n+extern \"C\" {\n+\n+JNIEXPORT crlib_api_t *CRLIB_API(int api_version, size_t api_size);\n+\n+static crlib_conf_t *create_conf();\n+static void destroy_conf(crlib_conf_t *conf);\n+static int checkpoint(crlib_conf_t *conf);\n+static int restore(crlib_conf_t *conf);\n+static bool can_configure(crlib_conf_t *conf, const char *key);\n+static bool configure(crlib_conf_t *conf, const char *key, const char *value);\n+static const crlib_extension_t *get_extension(const char *name, size_t size);\n+\n+static const char *identity(crlib_conf_t *conf);\n+static const char *description(crlib_conf_t *conf);\n+static const char *configuration_doc(crlib_conf_t *conf);\n+static const char * const *configurable_keys(crlib_conf_t *conf);\n+static crlib_extension_t * const *supported_extensions(crlib_conf_t *conf);\n+\n+static bool set_restore_data(crlib_conf_t *conf, const void *data, size_t size);\n+static size_t get_restore_data(crlib_conf_t *conf, void *buf, size_t size);\n+\n+} \/\/ extern \"C\"\n+\n+static crlib_api_t api = {\n+  create_conf,\n+  destroy_conf,\n+  checkpoint,\n+  restore,\n+  can_configure,\n+  configure,\n+  get_extension,\n+};\n+\n+static crlib_description_t description_extension = {\n+  {\n+    CRLIB_EXTENSION_DESCRIPTION_NAME,\n+    sizeof(description_extension)\n+  },\n+  identity,\n+  description,\n+  configuration_doc,\n+  configurable_keys,\n+  supported_extensions,\n+};\n+\n+static crlib_restore_data_t restore_data_extension = {\n+  {\n+    CRLIB_EXTENSION_RESTORE_DATA_NAME,\n+    sizeof(restore_data_extension)\n+  },\n+  set_restore_data,\n+  get_restore_data,\n+};\n+\n+static const crlib_extension_t *extensions[] = {\n+  &restore_data_extension.header,\n+  &description_extension.header,\n+  nullptr\n+};\n+\n+#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(*(x)))\n+\n+#define CREXEC \"crexec: \"\n+\n+\/\/ crexec_md.cpp\n+const char *file_separator();\n+bool is_path_absolute(const char *path);\n+bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]);\n+char **get_environ();\n+void exec_in_this_process(const char *path, const char *argv[], const char *env[]);\n+\n+JNIEXPORT crlib_api_t *CRLIB_API(int api_version, size_t api_size) {\n+  if (api_version != CRLIB_API_VERSION) {\n+    return nullptr;\n+  }\n+  if (sizeof(crlib_api_t) < api_size) {\n+    return nullptr;\n+  }\n+  return &api;\n+}\n+\n+\/\/ When adding a new option also add its description into the help message,\n+\/\/ ensure the proper default value is set for it in the configuration struct and\n+\/\/ consider checking for inappropriate use on checkpoint\/restore.\n+\/\/\n+\/\/ Place more frequently used options first - this will make them faster to find\n+\/\/ in the options hash table.\n+#define CONFIGURE_OPTIONS(OPT) \\\n+  OPT(image_location) \\\n+  OPT(exec_location) \\\n+  OPT(keep_running) \\\n+  OPT(direct_map) \\\n+  OPT(args) \\\n+\n+#define DEFINE_OPT(id) static constexpr char opt_##id[] = #id;\n+CONFIGURE_OPTIONS(DEFINE_OPT)\n+#undef DEFINE_OPT\n+#define ADD_ARR_ELEM(id) opt_##id,\n+static constexpr const char *configure_options[] = { CONFIGURE_OPTIONS(ADD_ARR_ELEM) nullptr };\n+#undef ADD_ARR_ELEM\n+\n+static char *strdup_checked(const char *src) {\n+  char * const res = strdup(src);\n+  if (res == nullptr) {\n+    fprintf(stderr, CREXEC \"out of memory\\n\");\n+  }\n+  return res;\n+}\n+\n+static bool parse_bool(const char *str, bool *result) {\n+  if (strcmp(str, \"true\") == 0) {\n+    *result = true;\n+    return true;\n+  }\n+  if (strcmp(str, \"false\") == 0) {\n+    *result = false;\n+    return true;\n+  }\n+  fprintf(stderr, CREXEC \"expected '%s' to be either 'true' or 'false'\\n\", str);\n+  return false;\n+}\n+\n+\/\/ Indices of argv array members.\n+enum Argv {\n+  ARGV_EXEC_LOCATION,\n+  ARGV_ACTION,\n+  ARGV_IMAGE_LOCATION,\n+  ARGV_FREE, \/\/ First index for user-provided arguments\n+  ARGV_LAST = 31,\n+};\n+\n+struct crlib_conf {\n+private:\n+  using configure_func = bool (crlib_conf::*) (const char *value);\n+  Hashtable<configure_func> _options {\n+    configure_options, ARRAY_SIZE(configure_options) - 1 \/* omit nullptr *\/\n+  };\n+\n+  bool _keep_running = false;\n+  bool _direct_map = false;\n+  int _restore_data = 0;\n+  const char *_argv[ARGV_LAST + 2] = {}; \/\/ Last element is required to be null\n+\n+public:\n+  crlib_conf() {\n+    if (!_options.is_initialized()) {\n+      fprintf(stderr, CREXEC \"out of memory\\n\");\n+      assert(!is_initialized());\n+      return;\n+    }\n+#define PUT_HANDLER(id) _options.put(opt_##id, &crlib_conf::configure_##id);\n+    CONFIGURE_OPTIONS(PUT_HANDLER)\n+#undef PUT_HANDLER\n+  }\n+\n+  ~crlib_conf() {\n+    for (int i = 0; i <= ARGV_FREE \/* all free args are allocated together *\/; i++) {\n+      if (i != ARGV_ACTION) { \/\/ Action is a static string\n+        free(const_cast<char*>(_argv[i]));\n+      }\n+    }\n+  }\n+\n+  \/\/ Use this to check whether the constructor succeeded.\n+  bool is_initialized() const { return _options.is_initialized(); }\n+\n+  bool keep_running() const { return _keep_running; }\n+  bool direct_map() const { return _direct_map; }\n+  int restore_data() const { return _restore_data; }\n+  const char * const *argv() const { return _argv; }\n+\n+  bool can_configure(const char *key) const {\n+    assert(key != nullptr);\n+    return _options.contains(key);\n+  }\n+\n+  bool configure(const char *key, const char *value) {\n+    assert(key != nullptr && value != nullptr);\n+    auto * const func = _options.get(key);\n+    if (func != nullptr) {\n+      return (this->**func)(value);\n+    }\n+    fprintf(stderr, CREXEC \"unknown configure option: %s\\n\", key);\n+    return false;\n+  }\n+\n+  void set_argv_action(const char *action) { _argv[ARGV_ACTION] = action; }\n+\n+  bool set_restore_data(const void *data, size_t size) {\n+    if (size != sizeof(_restore_data)) {\n+      fprintf(stderr, CREXEC \"unsupported size of restore data: %zu - only %zu is supported\\n\",\n+              size, sizeof(_restore_data));\n+      return false;\n+    }\n+    _restore_data = *static_cast<const int *>(data);\n+    return true;\n+  }\n+\n+  size_t get_restore_data(void *buf, size_t size) {\n+    if (size < sizeof(_restore_data)) {\n+      fprintf(stderr, CREXEC \"can only provide >= %zu bytes of restore data but %zu was requested\\n\",\n+              sizeof(_restore_data), size);\n+      return 0;\n+    }\n+    *static_cast<int *>(buf) = _restore_data;\n+    return sizeof(_restore_data);\n+  }\n+\n+private:\n+  bool configure_image_location(const char *image_location) {\n+    free(const_cast<char *>(_argv[ARGV_IMAGE_LOCATION]));\n+    _argv[ARGV_IMAGE_LOCATION] = strdup_checked(image_location);\n+    return _argv[ARGV_IMAGE_LOCATION] != nullptr;\n+  }\n+\n+  bool configure_exec_location(const char *exec_location) {\n+    if (!is_path_absolute(exec_location)) {\n+      fprintf(stderr, CREXEC \"expected absolute path: %s\\n\", exec_location);\n+      return false;\n+    }\n+    free(const_cast<char *>(_argv[ARGV_EXEC_LOCATION]));\n+    _argv[ARGV_EXEC_LOCATION] = strdup_checked(exec_location);\n+    if (_argv[ARGV_EXEC_LOCATION] == nullptr) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  bool configure_keep_running(const char *keep_running_str) {\n+    return parse_bool(keep_running_str, &_keep_running);\n+  }\n+\n+  bool configure_direct_map(const char *direct_map_str) {\n+    return parse_bool(direct_map_str, &_direct_map);\n+  }\n+\n+  bool configure_args(const char *args) {\n+    free(const_cast<char *>(_argv[ARGV_FREE]));\n+    char *arg = strdup_checked(args);\n+    if (arg == nullptr) {\n+      _argv[ARGV_FREE] = nullptr;\n+      return false;\n+    }\n+\n+    assert(ARGV_FREE <= ARGV_LAST);\n+    static constexpr char SEP = ' ';\n+    for (int i = ARGV_FREE; i <= ARGV_LAST && arg[0] != '\\0'; i++) {\n+      _argv[i] = arg;\n+      for (; arg[0] != SEP && arg[0] != '\\0'; arg++) {}\n+      if (arg[0] == SEP) {\n+        *(arg++) = '\\0';\n+      }\n+    }\n+\n+    if (arg[0] != '\\0') {\n+      fprintf(stderr, CREXEC \"too many free arguments, at most %i are allowed\\n\",\n+              (ARGV_LAST - ARGV_FREE) + 1);\n+      free(const_cast<char *>(_argv[ARGV_FREE]));\n+      _argv[ARGV_FREE] = nullptr;\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+};\n+\n+static crlib_conf_t *create_conf() {\n+  auto * const conf = new(std::nothrow) crlib_conf();\n+  if (conf == nullptr || !conf->is_initialized()) {\n+    delete conf;\n+    return nullptr;\n+  }\n+  return conf;\n+}\n+\n+static void destroy_conf(crlib_conf_t *conf) {\n+  delete conf;\n+}\n+\n+static bool can_configure(crlib_conf_t *conf, const char *key) {\n+  return conf->can_configure(key);\n+}\n+\n+static bool configure(crlib_conf_t *conf, const char *key, const char *value) {\n+  return conf->configure(key, value);\n+}\n+\n+static const char *identity(crlib_conf_t *conf) {\n+  return \"crexec\";\n+}\n+\n+static const char *description(crlib_conf_t *conf) {\n+  return\n+    \"crexec - pseudo-CRaC-engine used to relay data from JVM to a \\\"real\\\" engine implemented as \"\n+    \"an executable (instead of a library). The engine executable is expected to have \"\n+    \"CRaC-CRIU-like CLI. Support of the configuration options also depends on the engine \"\n+    \"executable.\";\n+}\n+\n+static const char *configuration_doc(crlib_conf_t *conf) {\n+  \/\/ Internal options which are expected to be set by the program crexec is linked to are omitted\n+  \/\/ since users are not supposed to pass them directly:\n+  \/\/ * image_location=<path> (no default) - path to a directory with checkpoint\/restore files.\n+  \/\/ * exec_location=<path> (no default) - path to the engine executable.\n+  return\n+    \"* keep_running=<true\/false> (default: false) - keep the process running after the checkpoint \"\n+    \"or kill it.\\n\"\n+    \"* direct_map=<true\/false> (default: false) - on restore, map process data directly from saved \"\n+    \"files. This may speedup the restore but the resulting process will not be the same as before \"\n+    \"the checkpoint.\\n\"\n+    \"* args=<string> (default: \\\"\\\") - free space-separated arguments passed directly to the \"\n+    \"engine executable, e.g. \\\"--arg1 --arg2 --arg3\\\".\";\n+}\n+\n+static const char * const *configurable_keys(crlib_conf_t *conf) {\n+  return configure_options;\n+}\n+\n+static crlib_extension_t * const *supported_extensions(crlib_conf_t *conf) {\n+  return extensions;\n+}\n+\n+static bool set_restore_data(crlib_conf_t *conf, const void *data, size_t size) {\n+  return conf->set_restore_data(data, size);\n+}\n+\n+static size_t get_restore_data(crlib_conf_t *conf, void *buf, size_t size) {\n+  return conf->get_restore_data(buf, size);\n+}\n+\n+static const crlib_extension_t *get_extension(const char *name, size_t size) {\n+  for (size_t i = 0; i < ARRAY_SIZE(extensions) - 1 \/* omit nullptr *\/; i++) {\n+    const crlib_extension_t *ext = extensions[i];\n+    if (strcmp(name, ext->name) == 0) {\n+      if (size <= ext->size) {\n+        return ext;\n+      }\n+      return nullptr;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+class Environment {\n+private:\n+  char **_env;\n+  size_t _length;\n+\n+public:\n+  explicit Environment(const char * const *env = get_environ()) {\n+    _length = 0;\n+    for (; env[_length] != nullptr; _length++) {}\n+\n+    \/\/ Not using new here because we cannot safely use realloc with it\n+    _env = static_cast<char**>(malloc((_length + 1) * sizeof(char *)));\n+    if (_env == nullptr) {\n+      return;\n+    }\n+\n+    for (size_t i = 0; i < _length; i++) {\n+      _env[i] = strdup(env[i]);\n+      if (_env[i] == nullptr) {\n+        for (size_t j = 0; j < i; i++) {\n+          free(_env[j]);\n+          free(_env);\n+          _env = nullptr;\n+        }\n+        assert(!is_initialized());\n+        return;\n+      }\n+    }\n+    _env[_length] = nullptr;\n+  }\n+\n+  ~Environment() {\n+    if (is_initialized()) {\n+      for (size_t i = 0; i < _length; i++) {\n+        free(_env[i]);\n+      }\n+      free(_env);\n+    }\n+  }\n+\n+  \/\/ Use this to check whether the constructor succeeded.\n+  bool is_initialized() const { return _env != nullptr; }\n+\n+  char **env() { return _env; }\n+\n+  bool append(const char *var, const char *value) {\n+    assert(is_initialized());\n+\n+    const size_t str_size = strlen(var) + strlen(\"=\") + strlen(value) + 1;\n+    char * const str = static_cast<char *>(malloc(sizeof(char) * str_size));\n+    if (str == nullptr) {\n+      fprintf(stderr, CREXEC \"out of memory\\n\");\n+      return false;\n+    }\n+    if (snprintf(str, str_size, \"%s=%s\", var, value) != static_cast<int>(str_size) - 1) {\n+      perror(CREXEC \"snprintf env var\");\n+      free(str);\n+      return false;\n+    }\n+\n+    {\n+      char ** const new_env = static_cast<char **>(realloc(_env, (_length + 2) * sizeof(char *)));\n+      if (new_env == nullptr) {\n+        fprintf(stderr, CREXEC \"out of memory\\n\");\n+        free(str);\n+        return false;\n+      }\n+      _env = new_env;\n+    }\n+\n+    _env[_length++] = str;\n+    _env[_length] = nullptr;\n+\n+    return true;\n+  }\n+\n+  bool add_criu_option(const char *opt) {\n+    constexpr char CRAC_CRIU_OPTS[] = \"CRAC_CRIU_OPTS\";\n+    constexpr size_t CRAC_CRIU_OPTS_LEN = ARRAY_SIZE(CRAC_CRIU_OPTS) - 1;\n+\n+    assert(is_initialized());\n+\n+    bool opts_found = false;\n+    size_t opts_index = 0;\n+    for (; _env[opts_index] != nullptr; opts_index++) {\n+      if (strcmp(_env[opts_index], CRAC_CRIU_OPTS) == 0 && _env[opts_index][CRAC_CRIU_OPTS_LEN] == '=') {\n+        opts_found = true;\n+        break;\n+      }\n+    }\n+\n+    if (!opts_found) {\n+      return append(CRAC_CRIU_OPTS, opt);\n+    }\n+\n+    if (strstr(_env[opts_index] + CRAC_CRIU_OPTS_LEN + 1, opt) != nullptr) {\n+      return true;\n+    }\n+\n+    const size_t new_opts_size = strlen(_env[opts_index]) + strlen(\" \") + strlen(opt) + 1;\n+    char * const new_opts = static_cast<char *>(malloc(new_opts_size * sizeof(char)));\n+    if (new_opts == nullptr) {\n+      fprintf(stderr, CREXEC \"out of memory\\n\");\n+      return false;\n+    }\n+    if (snprintf(new_opts, new_opts_size, \"%s %s\", _env[opts_index], opt) !=\n+          static_cast<int>(new_opts_size) - 1) {\n+      perror(CREXEC \"snprintf CRAC_CRIU_OPTS (append)\");\n+      free(new_opts);\n+      return false;\n+    }\n+    free(_env[opts_index]);\n+    _env[opts_index] = new_opts;\n+\n+    return true;\n+  }\n+};\n+\n+static int checkpoint(crlib_conf_t *conf) {\n+  if (conf->argv()[ARGV_EXEC_LOCATION] == nullptr) {\n+    fprintf(stderr, CREXEC \"%s must be set before checkpoint\\n\", opt_exec_location);\n+    return -1;\n+  }\n+  if (conf->argv()[ARGV_IMAGE_LOCATION] == nullptr) {\n+    fprintf(stderr, CREXEC \"%s must be set before checkpoint\\n\", opt_image_location);\n+    return -1;\n+  }\n+  conf->set_argv_action(\"checkpoint\");\n+\n+  if (conf->direct_map()) {\n+    fprintf(stderr, CREXEC \"%s has no effect on checkpoint\\n\", opt_direct_map);\n+  }\n+\n+  {\n+    Environment env;\n+    if (!env.is_initialized()||\n+        (conf->keep_running() && !env.append(\"CRAC_CRIU_LEAVE_RUNNING\", \"\"))) {\n+      return -1;\n+    }\n+\n+    if (!exec_child_process_and_wait(conf->argv()[ARGV_EXEC_LOCATION],\n+                                     const_cast<char **>(conf->argv()), env.env())) {\n+      return -1;\n+    }\n+  }\n+\n+#ifdef LINUX\n+  siginfo_t info;\n+  sigset_t waitmask;\n+  sigemptyset(&waitmask);\n+  sigaddset(&waitmask, RESTORE_SIGNAL);\n+\n+  int sig;\n+  do {\n+    sig = sigwaitinfo(&waitmask, &info);\n+  } while (sig == -1 && errno == EINTR);\n+\n+  if (info.si_code != SI_QUEUE) {\n+    return false;\n+  }\n+  {\n+#ifndef NDEBUG\n+    const bool ok =\n+#endif \/\/ NDEBUG\n+    conf->set_restore_data(&info.si_int, sizeof(info.si_int));\n+    assert(ok);\n+  }\n+#endif \/\/ LINUX\n+\n+  return 0;\n+}\n+\n+static int restore(crlib_conf_t *conf) {\n+  if (conf->argv()[ARGV_EXEC_LOCATION] == nullptr) {\n+    fprintf(stderr, CREXEC \"%s must be set before restore\\n\", opt_exec_location);\n+    return -1;\n+  }\n+  if (conf->argv()[ARGV_IMAGE_LOCATION] == nullptr) {\n+    fprintf(stderr, CREXEC \"%s must be set before restore\\n\", opt_image_location);\n+    return -1;\n+  }\n+  conf->set_argv_action(\"restore\");\n+\n+  if (conf->keep_running()) {\n+    fprintf(stderr, CREXEC \"%s has no effect on restore\\n\", opt_keep_running);\n+  }\n+\n+  char restore_data_str[32];\n+  if (snprintf(restore_data_str, sizeof(restore_data_str), \"%i\", conf->restore_data()) >\n+      static_cast<int>(sizeof(restore_data_str)) - 1) {\n+    perror(CREXEC \"snprintf restore data\");\n+    return -1;\n+  }\n+\n+  Environment env;\n+  if (!env.is_initialized() ||\n+      !env.append(\"CRAC_NEW_ARGS_ID\", restore_data_str) ||\n+      (!conf->direct_map() && !env.add_criu_option(\"--no-mmap-page-image\"))) {\n+    return -1;\n+  }\n+\n+  exec_in_this_process(conf->argv()[ARGV_EXEC_LOCATION],\n+                       const_cast<const char **>(conf->argv()),\n+                       const_cast<const char **>(env.env()));\n+\n+  fprintf(stderr, CREXEC \"restore failed\\n\");\n+  return -1;\n+}\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.cpp","additions":594,"deletions":0,"binary":false,"changes":594,"status":"added"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include \"hashtable.h\"\n-\n-#include <assert.h>\n-#include <stdbool.h>\n-#include <stddef.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-static unsigned int string_hash(const char *str) {\n-  unsigned int hash = 0;\n-  for (; *str; str++) {\n-    hash = 31 * hash + *str;\n-  }\n-  return hash;\n-}\n-\n-hashtable_t *hashtable_create(const char **keys, size_t length) {\n-  hashtable_t * const ht = (hashtable_t *) malloc(sizeof(hashtable_t));\n-  if (ht == NULL) {\n-    return NULL;\n-  }\n-\n-  ht->length = length;\n-  ht->keys = (const char **) malloc(length * sizeof(const char **));\n-  if (ht->keys == NULL) {\n-    hashtable_destroy(ht);\n-    return NULL;\n-  }\n-  ht->values = (void **) malloc(length * sizeof(void **));\n-  if (ht->values == NULL) {\n-    hashtable_destroy(ht);\n-    return NULL;\n-  }\n-\n-  memset((char **) ht->keys, 0, length * sizeof(const char **)); \/\/ Cast silences MSVC warning C4090\n-  memset(ht->values, 0, length * sizeof(void **));\n-\n-  for (size_t i = 0; i < length; i++) {\n-    const char *key = keys[i];\n-    assert(key != NULL);\n-    const unsigned int hash = string_hash(key) % length;\n-    bool place_found = false;\n-    for (size_t j = hash; !place_found && j < length; j++) {\n-      if (ht->keys[j] == NULL) {\n-        ht->keys[j] = key;\n-        place_found = true;\n-      }\n-    }\n-    for (size_t j = 0; !place_found && j < hash; j++) {\n-      if (ht->keys[j] == NULL) {\n-        ht->keys[j] = key;\n-        place_found = true;\n-      }\n-    }\n-    assert(place_found); \/\/ There should be enough space for all keys to fit\n-  }\n-\n-  return ht;\n-}\n-\n-void hashtable_destroy(hashtable_t *ht) {\n-  if (ht == NULL) {\n-    return;\n-  }\n-  free((char **) ht->keys); \/\/ Cast silences MSVC warning C4090\n-  free(ht->values);\n-  free(ht);\n-}\n-\n-static void **find_value(hashtable_t *ht, const char *key) {\n-  const unsigned int hash = string_hash(key) % ht->length;\n-  for (size_t i = hash; i < ht->length; i++) {\n-    if (strcmp(key, ht->keys[i]) == 0) {\n-      return &ht->values[i];\n-    }\n-  }\n-  for (size_t i = 0; i < hash; i++) {\n-    if (strcmp(key, ht->keys[i]) == 0) {\n-      return &ht->values[i];\n-    }\n-  }\n-  return NULL;\n-}\n-\n-bool hashtable_contains(hashtable_t *ht, const char *key) {\n-  return find_value(ht, key) != NULL;\n-}\n-\n-void *hashtable_get(hashtable_t *ht, const char *key) {\n-  void ** const value_ptr = find_value(ht, key);\n-  return value_ptr != NULL ? *value_ptr : NULL;\n-}\n-\n-bool hashtable_put(hashtable_t *ht, const char *key, void *value) {\n-  void ** const value_ptr = find_value(ht, key);\n-  if (value_ptr == NULL) {\n-    return false;\n-  }\n-  *value_ptr = value;\n-  return true;\n-}\n","filename":"src\/java.base\/share\/native\/libcrexec\/hashtable.c","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#ifndef HASHTABLE_H\n-#define HASHTABLE_H\n-\n-#include <stdbool.h>\n-#include <stddef.h>\n-\n-typedef struct hashtable {\n-  size_t length;\n-  const char **keys;\n-  void **values;\n-} hashtable_t;\n-\n-hashtable_t *hashtable_create(const char **keys, size_t length);\n-void hashtable_destroy(hashtable_t *ht);\n-\n-bool hashtable_contains(hashtable_t *ht, const char *key);\n-\n-void *hashtable_get(hashtable_t *ht, const char *key);\n-bool hashtable_put(hashtable_t *ht, const char *key, void *value);\n-\n-#endif \/\/ HASHTABLE_H\n","filename":"src\/java.base\/share\/native\/libcrexec\/hashtable.h","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef HASHTABLE_HPP\n+#define HASHTABLE_HPP\n+\n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <new>\n+\n+template<class T>\n+class Hashtable {\n+public:\n+  Hashtable(const char * const keys[], size_t length);\n+  ~Hashtable();\n+\n+  \/\/ Use this to check whether the constructor succeeded.\n+  bool is_initialized() const { return _keys != nullptr; }\n+\n+  size_t length() const { return _length; }\n+\n+  bool contains(const char *key) const;\n+  T *get(const char *key) const;\n+  bool put(const char *key, T value);\n+\n+private:\n+  size_t _length;\n+  const char **_keys;\n+  T *_values;\n+\n+  static unsigned int string_hash(const char *str);\n+};\n+\n+template<class T>\n+unsigned int Hashtable<T>::string_hash(const char *str) {\n+  assert(str != nullptr);\n+  unsigned int hash = 0;\n+  for (; *str != '\\0'; str++) {\n+    hash = 31 * hash + *str;\n+  }\n+  return hash;\n+}\n+\n+template<class T>\n+Hashtable<T>::Hashtable(const char * const keys[], size_t length) :\n+    _length(length),\n+    _keys(new(std::nothrow) const char*[length]()),\n+    _values(new(std::nothrow) T[length]()) {\n+  if (_keys == nullptr || _values == nullptr) {\n+    delete[] _keys;\n+    delete[] _values;\n+    _keys = nullptr;\n+    _values = nullptr;\n+    assert(!is_initialized());\n+    return;\n+  }\n+\n+  for (size_t i = 0; i < length; i++) {\n+    const char *key = keys[i];\n+    assert(key != nullptr);\n+    const unsigned int hash = string_hash(key) % length;\n+    bool place_found = false;\n+    for (size_t j = hash; !place_found && j < length; j++) {\n+      if (_keys[j] == nullptr) {\n+        _keys[j] = key;\n+        place_found = true;\n+      }\n+    }\n+    for (size_t j = 0; !place_found && j < hash; j++) {\n+      if (_keys[j] == nullptr) {\n+        _keys[j] = key;\n+        place_found = true;\n+      }\n+    }\n+    assert(place_found); \/\/ There should be enough space for all keys to fit\n+  }\n+\n+  assert(is_initialized());\n+}\n+\n+template<class T>\n+Hashtable<T>::~Hashtable() {\n+  delete[] _keys;\n+  delete[] _values;\n+}\n+\n+template<class T>\n+bool Hashtable<T>::contains(const char *key) const {\n+  return get(key) != nullptr;\n+}\n+\n+template<class T>\n+T *Hashtable<T>::get(const char *key) const {\n+  assert(key != nullptr);\n+  const unsigned int hash = string_hash(key) % _length;\n+  for (size_t i = hash; i < _length; i++) {\n+    if (strcmp(key, _keys[i]) == 0) {\n+      return &_values[i];\n+    }\n+  }\n+  for (size_t i = 0; i < hash; i++) {\n+    if (strcmp(key, _keys[i]) == 0) {\n+      return &_values[i];\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+template<class T>\n+bool Hashtable<T>::put(const char *key, T value) {\n+  T * const value_ptr = get(key);\n+  if (value_ptr == nullptr) {\n+    return false;\n+  }\n+  *value_ptr = value;\n+  return true;\n+}\n+\n+#endif \/\/ HASHTABLE_HPP\n","filename":"src\/java.base\/share\/native\/libcrexec\/hashtable.hpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <errno.h>\n-#include <spawn.h>\n-#include <stdbool.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include <sys\/types.h>\n-#include <sys\/stat.h>\n-#include <sys\/wait.h>\n-#include <unistd.h>\n-\n-#define slash '\/'\n-\n-const char *file_separator() {\n-  return \"\/\";\n-}\n-\n-bool is_path_absolute(const char* path) {\n-  return path[0] == slash;\n-}\n-\n-\/\/ Darwin has no \"environ\" in a dynamic library.\n-#ifdef __APPLE__\n-  #include <crt_externs.h>\n-  #define environ (*_NSGetEnviron())\n-#else\n-  extern char** environ;\n-#endif\n-\n-char **get_environ() {\n-  return environ;\n-}\n-\n-bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]) {\n-  pid_t pid;\n-  if (posix_spawn(&pid, path, NULL, NULL, argv, env)) {\n-    perror(\"Cannot spawn cracengine\");\n-    return false;\n-  }\n-\n-  int status;\n-  int ret;\n-  do {\n-    ret = waitpid(pid, &status, 0);\n-  } while (ret == -1 && errno == EINTR);\n-\n-  if (ret == -1 || !WIFEXITED(status)) {\n-    return false;\n-  }\n-  return WEXITSTATUS(status) == 0;\n-}\n-\n-void exec_in_this_process(const char *path, const char *argv[], const char *env[]) {\n-  execve(path, (char **) argv, (char **) env);\n-}\n","filename":"src\/java.base\/unix\/native\/libcrexec\/crexec_md.c","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <cerrno>\n+#include <cstdio>\n+#include <spawn.h>\n+#include <sys\/types.h>\n+#include <sys\/wait.h>\n+#include <unistd.h>\n+\n+static constexpr char SLASH = '\/';\n+static constexpr const char SEP[] = { SLASH, '\\0' };\n+\n+const char *file_separator() {\n+  return SEP;\n+}\n+\n+bool is_path_absolute(const char* path) {\n+  return path[0] == SLASH;\n+}\n+\n+\/\/ Darwin has no \"environ\" in a dynamic library.\n+#ifdef __APPLE__\n+  #include <crt_externs.h>\n+  #define environ (*_NSGetEnviron())\n+#else\n+  extern char** environ;\n+#endif\n+\n+char **get_environ() {\n+  return environ;\n+}\n+\n+bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]) {\n+  pid_t pid;\n+  if (posix_spawn(&pid, path, nullptr, nullptr, argv, env) != 0) {\n+    perror(\"Cannot spawn cracengine\");\n+    return false;\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return false;\n+  }\n+  return WEXITSTATUS(status) == 0;\n+}\n+\n+void exec_in_this_process(const char *path, const char *argv[], const char *env[]) {\n+  execve(path, const_cast<char **>(argv), const_cast<char **>(env));\n+}\n","filename":"src\/java.base\/unix\/native\/libcrexec\/crexec_md.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2024-2025, Azul Systems, Inc. All rights reserved.\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <direct.h>\n-#include <process.h>\n-#include <stdbool.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <windows.h>\n-\n-#define slash '\\\\'\n-\n-const char *file_separator() {\n-    return \"\\\\\";\n-}\n-\n-static inline int isLetter(char c) {\n-    return ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'));\n-}\n-\n-\/\/ Copy from FileSystemSupport_md.c\n-static int prefix_length(const char* path) {\n-    char c0, c1;\n-\n-    int n = (int)strlen(path);\n-    if (n == 0) return 0;\n-    c0 = path[0];\n-    c1 = (n > 1) ? path[1] : 0;\n-    if (c0 == slash) {\n-        if (c1 == slash) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n-        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n-    }\n-    if (isLetter(c0) && (c1 == ':')) {\n-        if ((n > 2) && (path[2] == slash))\n-            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n-        return 2;                       \/* Directory-relative \"z:foo\" *\/\n-    }\n-    return 0;                   \/* Completely relative *\/\n-}\n-\n-bool is_path_absolute(const char* path) {\n-    int pl = prefix_length(path);\n-    return (((pl == 2) && (path[0] == slash)) || (pl == 3));\n-}\n-\n-char **get_environ() {\n-  return _environ;\n-}\n-\n-bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]) {\n-  \/\/ Avoid crashing in _spawnve(), https:\/\/bugs.python.org\/issue29908\n-  SetEnvironmentVariable(TEXT(\"=CRAC_DUMMY\"), TEXT(\"dummy\"));\n-  intptr_t status = _spawnve(_P_WAIT, path, argv, env); \/\/ env is inherited by a child process\n-  return !status;\n-}\n-\n-void exec_in_this_process(const char *path, const char *argv[], const char *env[]) {\n-  \/\/ The same problem as above\n-  SetEnvironmentVariable(TEXT(\"=CRAC_DUMMY\"), TEXT(\"dummy\"));\n-  _execve(path, argv, env);\n-}\n","filename":"src\/java.base\/windows\/native\/libcrexec\/crexec_md.c","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024-2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <cstdlib>\n+#include <cstring>\n+#include <direct.h>\n+#include <process.h>\n+#include <windows.h>\n+\n+static constexpr char SLASH = '\\\\';\n+static constexpr const char SEP[] = { SLASH, '\\0' };\n+\n+const char *file_separator() {\n+  return SEP;\n+}\n+\n+static inline int isLetter(char c) {\n+  return ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'));\n+}\n+\n+\/\/ Copy from FileSystemSupport_md.c\n+static int prefixLength(const char* path) {\n+  char c0, c1;\n+\n+  int n = (int)strlen(path);\n+  if (n == 0) return 0;\n+  c0 = path[0];\n+  c1 = (n > 1) ? path[1] : 0;\n+  if (c0 == SLASH) {\n+    if (c1 == SLASH) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+    return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+  }\n+  if (isLetter(c0) && (c1 == ':')) {\n+    if ((n > 2) && (path[2] == SLASH))\n+      return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+    return 2;                       \/* Directory-relative \"z:foo\" *\/\n+  }\n+  return 0;                   \/* Completely relative *\/\n+}\n+\n+bool is_path_absolute(const char* path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == SLASH)) || (pl == 3));\n+}\n+\n+char **get_environ() {\n+  return _environ;\n+}\n+\n+bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]) {\n+  \/\/ Avoid crashing in _spawnve(), https:\/\/bugs.python.org\/issue29908\n+  SetEnvironmentVariable(TEXT(\"=CRAC_DUMMY\"), TEXT(\"dummy\"));\n+  intptr_t status = _spawnve(_P_WAIT, path, argv, env); \/\/ env is inherited by a child process\n+  return !status;\n+}\n+\n+void exec_in_this_process(const char *path, const char *argv[], const char *env[]) {\n+  \/\/ The same problem as above\n+  SetEnvironmentVariable(TEXT(\"=CRAC_DUMMY\"), TEXT(\"dummy\"));\n+  _execve(path, argv, env);\n+}\n","filename":"src\/java.base\/windows\/native\/libcrexec\/crexec_md.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.*;\n@@ -74,4 +75,4 @@\n-        test(\"unknown\", null, 1, \"Cannot find CRaC engine unknown\");\n-        test(\"simengine,--arg\", null, 1, \"Cannot find CRaC engine simengine,--arg\");\n-        test(\"one two\", null, 1, \"Cannot find CRaC engine one two\");\n-        test(\"\", null, 1, \"CRaCEngine must not be empty\");\n+        test(\"unknown\", Collections.emptyList(), 1, \"Cannot find CRaC engine unknown\");\n+        test(\"simengine,--arg\", Collections.emptyList(), 1, \"Cannot find CRaC engine simengine,--arg\");\n+        test(\"one two\", Collections.emptyList(), 1, \"Cannot find CRaC engine one two\");\n+        test(\"\", Collections.emptyList(), 1, \"CRaCEngine must not be empty\");\n@@ -83,3 +84,0 @@\n-        test(\"simengine\", \"help\", 0,\n-                \"CRaC engine option: 'help' = ''\",\n-                \"Configuration options:\"); \/\/ A line from the help message\n@@ -95,0 +93,3 @@\n+        test(\"simengine\", \"help=true\", 1,\n+                \"unknown configure option: help\",\n+                \"CRaC engine failed to configure: 'help' = 'true'\");\n@@ -120,0 +121,32 @@\n+    @Test\n+    public void test_options_separated() throws Exception {\n+        test(\"simengine\",\n+                Arrays.asList(\n+                    \"args=simengine ignores this\",\n+                    \"args=another arg,keep_running=true,args=and another\",\n+                    \"args=this is also ignored\"\n+                ),\n+                0,\n+                \"CRaC engine option: 'args' = 'simengine ignores this'\",\n+                \"CRaC engine option: 'args' = 'another arg'\",\n+                \"CRaC engine option: 'keep_running' = 'true'\",\n+                \"CRaC engine option: 'args' = 'and another'\",\n+                \"CRaC engine option: 'args' = 'this is also ignored'\");\n+\n+        test(\"simengine\",\n+                Arrays.asList(\"args=--arg1 --arg2\", \"--arg3\"),\n+                1,\n+                \"CRaC engine option: 'args' = '--arg1 --arg2'\",\n+                \"unknown configure option: --arg3\",\n+                \"CRaC engine failed to configure: '--arg3' = ''\");\n+    }\n+\n+    @Test\n+    public void test_options_help() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-XX:CRaCEngineOptions=help\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+        out.shouldContain(\"Configuration options:\");\n+    }\n+\n@@ -121,1 +154,1 @@\n-        test(engine, null, 0);\n+        test(engine, Collections.emptyList(), 0);\n@@ -125,1 +158,1 @@\n-        test(engine, opts, 0);\n+        test(engine, Arrays.asList(opts), 0);\n@@ -129,0 +162,4 @@\n+        test(engine, Arrays.asList(opts), expectedExitValue, expectedTexts);\n+    }\n+\n+    private void test(String engine, List<String> opts, int expectedExitValue, String... expectedTexts) throws Exception {\n@@ -134,2 +171,2 @@\n-        if (opts != null) {\n-            pb.command().add(pb.command().size() - 2, \"-XX:CRaCEngineOptions=\" + opts);\n+        for (String opt : opts) {\n+            pb.command().add(pb.command().size() - 2, \"-XX:CRaCEngineOptions=\" + opt);\n","filename":"test\/jdk\/jdk\/crac\/CracEngineOptionsTest.java","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2022-2025, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-import jdk.crac.*;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @build PropertyTest\n- * @run driver jdk.test.lib.crac.CracTest\n- * @requires (os.family == \"linux\")\n- *\/\n-\n-public class PropertyTest implements CracTest {\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder();\n-        builder.javaOption(\"k\", \"v\");\n-        builder.doCheckpointAndRestore();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        Core.checkpointRestore();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/PropertyTest.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"}]}