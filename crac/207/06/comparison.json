{"files":[{"patch":"@@ -318,0 +318,3 @@\n+################################################################################\n+# Setup CRaC CRIU\n+################################################################################\n","filename":"make\/autoconf\/lib-bundled.m4","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,0 +203,15 @@\n+\n+################################################################################\n+# Build checkpoint\/restore exec library\n+################################################################################\n+\n+# CFLAGS_windows from make\/autoconf\/flags-cflags.m4#FLAGS_SETUP_CFLAGS_HELPER\n+$(eval $(call SetupJdkLibrary, BUILD_LIBCREXEC, \\\n+    NAME := crexec, \\\n+    LINK_TYPE := C++, \\\n+    EXTRA_HEADER_DIRS := libjvm, \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB) -DCRLIB_IS_IMPL, \\\n+    CXXFLAGS_windows := -D_WINDOWS -DWIN32, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB), \\\n+))\n+TARGETS += $(BUILD_LIBCREXEC)\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2051,26 +2051,0 @@\n-int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n-  char** env = os::get_environ();\n-\n-  pid_t pid = fork();\n-  if (pid == -1) {\n-    perror(\"cannot fork for subprocess\");\n-    return -1;\n-  }\n-  if (pid == 0) {\n-    execve(path, (char* const*)argv, env);\n-    perror(\"execve\");\n-    exit(1);\n-  }\n-\n-  int status;\n-  int ret;\n-  do {\n-    ret = waitpid(pid, &status, 0);\n-  } while (ret == -1 && errno == EINTR);\n-\n-  if (ret == -1 || !WIFEXITED(status)) {\n-    return -1;\n-  }\n-  return WEXITSTATUS(status) == 0 ? 0 : -1;\n-}\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1372,0 +1372,4 @@\n+  \/\/ We cannot keep the filename because some C\/R engines might not preserve PID numbers\n+  \/\/ Also, username might change.\n+  FREE_C_HEAP_ARRAY(char, backing_store_file_name);\n+  backing_store_file_name = nullptr;\n@@ -1377,1 +1381,3 @@\n-  if (!backing_store_file_name) {\n+  assert(backing_store_file_name == nullptr, \"Should be nil'ed on checkpoint\");\n+  \/\/ With -XX:-UsePerfData the capacity is zero\n+  if (PerfDisableSharedMem || PerfMemory::capacity() == 0) {\n@@ -1380,1 +1386,0 @@\n-\n@@ -1390,0 +1395,1 @@\n+  backing_store_file_name = get_sharedmem_filename(dirname, vmid, -1);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1545,1 +1545,9 @@\n-  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+  \/\/ The signal is used with default crexec library, other CRaCEngines might use\n+  \/\/ signals in a different way and having this signal blocked could interfere.\n+  const char *signal_engines[] = { \"criu\", \"criuengine\", \"sim\", \"simengine\", \"pause\", \"pauseengine\", NULL };\n+  for (int i = 0; signal_engines[i] != NULL; ++i) {\n+    if (strcmp(CRaCEngine, signal_engines[i]) == 0) {\n+      sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+      break;\n+    }\n+  }\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5761,5 +5761,0 @@\n-int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n-  const int status = _spawnv(_P_WAIT, path, argv); \/\/ env is inherited by a child process\n-  return 0 == status ? 0 : -1;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CRLIB_H\n+#define CRLIB_H\n+\n+#include <stdbool.h>\n+#include <stddef.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+\/\/ Configuration storage used by CRaC engine to persist data between API calls.\n+typedef struct crlib_conf crlib_conf_t;\n+\n+\/\/ The first member in an actual structure defining an extension of CRaC engine API.\n+struct crlib_extension {\n+  \/\/ Name of the extension.\n+  \/\/ If there is a non-backwards compatible change in the extension (from API point of view) the\n+  \/\/ name should be changed, e.g. foo -> foo:v2.\n+  const char *name;\n+  \/\/ Size of the full extension structure, in bytes.\n+  \/\/ Adding members to the end of the full structure is considered a backwards-compatible change.\n+  size_t size;\n+};\n+typedef const struct crlib_extension crlib_extension_t;\n+\n+\/\/ CRaC engine API.\n+\/\/\n+\/\/ Unless noted otherwise, the engine should copy data passed through these methods into the\n+\/\/ configuration storage if it needs to keep it.\n+struct crlib_api {\n+  \/\/ Initializes a configuration structure.\n+  crlib_conf_t *(*create_conf)();\n+  \/\/ Destroys a configuration structure. The argument can be null.\n+  void (*destroy_conf)(crlib_conf_t *);\n+\n+  \/\/ Triggers a checkpoint. Returns zero on success.\n+  int (*checkpoint)(crlib_conf_t *);\n+  \/\/ Triggers a restore. Does not normally return, but if it does returns a error code.\n+  int (*restore)(crlib_conf_t *);\n+\n+  \/\/ Returns true if the given configuration key is supported by the engine, false otherwise.\n+  \/\/ Key is a valid C-string.\n+  \/\/ Use of this before configuring is not a requirement.\n+  bool (*can_configure)(crlib_conf_t *, const char *key);\n+  \/\/ Sets a configuration option. Returns true on success.\n+  \/\/ Key and value are valid C-strings.\n+  bool (*configure)(crlib_conf_t *, const char *key, const char *value);\n+\n+  \/\/ Returns an API extension with the given name (C-string) and size, or null if an extension with\n+  \/\/ such name is not present or its size is lower than requested.\n+  \/\/ The extension should have static storage duration. The application is supposed to cast it to\n+  \/\/ the actual extension type.\n+  const crlib_extension_t *(*get_extension)(const char *name, size_t size);\n+};\n+typedef const struct crlib_api crlib_api_t;\n+\n+#define CRLIB_API crlib_api\n+#define CRLIB_API_FUNC \"crlib_api\"\n+\n+#define CRLIB_API_VERSION 2\n+\n+#if defined(WINDOWS) || defined(_WINDOWS)\n+  #ifdef CRLIB_IS_IMPL\n+    #define IMPORTEXPORT __declspec(dllexport)\n+  #else\n+    #define IMPORTEXPORT __declspec(dllimport)\n+  #endif\n+#else\n+  #define IMPORTEXPORT\n+#endif\n+\n+\/\/ Returns a CRaC API of the given version and size, or null if such API version is not supported\n+\/\/ or its size is lower than requested.\n+\/\/ The API should have static storage duration.\n+extern IMPORTEXPORT crlib_api_t *CRLIB_API(int api_version, size_t api_size);\n+\n+#define CRLIB_EXTENSION(api, type, name) ((type *) (api)->get_extension(name, sizeof(type)))\n+\n+#ifdef __cplusplus\n+} \/\/ extern \"C\"\n+#endif\n+\n+#endif \/\/ CRLIB_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib.h","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CRLIB_DESCRIPTION_H\n+#define CRLIB_DESCRIPTION_H\n+\n+#include \"crlib.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CRLIB_EXTENSION_DESCRIPTION_NAME \"description\"\n+#define CRLIB_EXTENSION_DESCRIPTION(api) \\\n+  CRLIB_EXTENSION(api, crlib_description_t, CRLIB_EXTENSION_DESCRIPTION_NAME)\n+\n+\/\/ API for obtaining engine description.\n+\/\/\n+\/\/ Unless noted otherwise, storage duration of the returned data should (1) be either static or\n+\/\/ tied to the storage duration of conf, (2) not change between calls with the same arguments.\n+struct crlib_description {\n+  crlib_extension_t header;\n+\n+  \/\/ Returns a valid C-string containing concise information about the engine, e.g. its name and\n+  \/\/ version, or null on error.\n+  const char *(*identity)(crlib_conf_t *);\n+  \/\/ Returns a valid C-string containing a short user-friendly description of the engine, or null\n+  \/\/ on error.\n+  const char *(*description)(crlib_conf_t *);\n+\n+  \/\/ Returns a valid C-string with a formatted list of configuration keys supported by the engine\n+  \/\/ with their descriptions, or null on error.\n+  \/\/\n+  \/\/ Some keys can be excluded if they are not supposed to be set by a user but rather by the\n+  \/\/ application the engine is linked to.\n+  \/\/\n+  \/\/ Example:\n+  \/\/ \"\n+  \/\/ * do_stuff=<true\/false> (default: true) — whether to do stuff.\\n\n+  \/\/ * args=<string> (default: \\\"\\\") — other arguments.\n+  \/\/ \"\n+  const char *(*configuration_doc)(crlib_conf_t *);\n+\n+  \/\/ Returns a null-terminated array of all configuration keys supported by the engine, or null if\n+  \/\/ this method is not supported.\n+  const char * const *(*configurable_keys)(crlib_conf_t *);\n+  \/\/ Returns a null-terminated array of all API extensions supported by the engine, or null if this\n+  \/\/ method is not supported.\n+  crlib_extension_t * const *(*supported_extensions)(crlib_conf_t *);\n+};\n+typedef const struct crlib_description crlib_description_t;\n+\n+#ifdef __cplusplus\n+} \/\/ extern \"C\"\n+#endif\n+\n+#endif \/\/ CRLIB_DESCRIPTION_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib_description.h","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CRLIB_RESTORE_DATA_H\n+#define CRLIB_RESTORE_DATA_H\n+\n+#include \"crlib.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CRLIB_EXTENSION_RESTORE_DATA_NAME \"restore data\"\n+#define CRLIB_EXTENSION_RESTORE_DATA(api) \\\n+  CRLIB_EXTENSION(api, crlib_restore_data_t, CRLIB_EXTENSION_RESTORE_DATA_NAME)\n+\n+\/\/ API for passing data from a restoring application to a restored application.\n+struct crlib_restore_data {\n+  crlib_extension_t header;\n+\n+  \/\/ Called by the restoring application to pass data to the restored application.\n+  \/\/ 'data' must not be null, size must be greater than 0.\n+  \/\/ The engine may impose limits on the data size and return false if it is not accepted.\n+  bool (*set_restore_data)(crlib_conf_t *, const void *data, size_t size);\n+\n+  \/\/ Called by the restored application to retrieve the data passed by the restoring application.\n+  \/\/ Copies up to 'size' > 0 bytes of the data into 'buf' != null.\n+  \/\/ Returns the size of the data the engine has, in bytes — it can be more, equal to or less than\n+  \/\/ 'size'. Returned value of 0 represents an error.\n+  size_t (*get_restore_data)(crlib_conf_t *, void *buf, size_t size);\n+};\n+typedef const struct crlib_restore_data crlib_restore_data_t;\n+\n+#ifdef __cplusplus\n+} \/\/ extern \"C\"\n+#endif\n+\n+#endif \/\/ CRLIB_RESTORE_DATA_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib_restore_data.h","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -81,0 +81,1 @@\n+#include <type_traits>\n@@ -2193,2 +2194,10 @@\n-    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n-      return true;\n+    if (!match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      continue;\n+    }\n+    \/\/ ccstr is never set to an empty string by the parser so we should not\n+    \/\/ treat an empty string value as the option being set. If it ever becomes\n+    \/\/ ccstrlist or the parser changes, the value check will need to be removed.\n+    static_assert(std::is_same<ccstr, decltype(CRaCRestoreFrom)>(), \"expected ccstr\");\n+    const char* eq = strchr(tail, '=');\n+    if (eq != nullptr && eq[1] != '\\0') {\n+      return true; \/\/ the value is not an empty string\n@@ -2229,0 +2238,4 @@\n+\n+      if (key != tail) { \/\/ key was copied\n+        FreeHeap(const_cast<char *>(key));\n+      }\n@@ -2230,2 +2243,0 @@\n-      \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n-      \/\/ already been handled\n@@ -2250,0 +2261,3 @@\n+\n+  postcond(CRaCRestoreFrom != nullptr);\n+\n@@ -3077,0 +3091,4 @@\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return JNI_ERR;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/log.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -34,0 +36,1 @@\n+#include \"runtime\/crac_engine.hpp\"\n@@ -36,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -37,0 +41,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -40,1 +45,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -44,0 +48,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -47,0 +52,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n@@ -48,4 +55,0 @@\n-static const char* _crengine = NULL;\n-static char* _crengine_arg_str = NULL;\n-static unsigned int _crengine_argc = 0;\n-static const char* _crengine_args[32];\n@@ -55,0 +58,1 @@\n+CracEngine *crac::_engine = nullptr;\n@@ -100,11 +104,2 @@\n-static size_t cr_util_path(char* path, int len) {\n-  os::jvm_path(path, len);\n-  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n-  assert(1 == strlen(os::file_separator()), \"file separator must be a single-char, not a string\");\n-  char *after_elem = NULL;\n-  for (int i = 0; i < 2; ++i) {\n-    after_elem = strrchr(path, *os::file_separator());\n-    *after_elem = '\\0';\n-  }\n-  return after_elem - path;\n-}\n+int crac::checkpoint_restore(int *shmid) {\n+  guarantee(_engine != nullptr, \"CRaC engine is not initialized\");\n@@ -112,6 +107,1 @@\n-static bool compute_crengine() {\n-  \/\/ release possible old copies\n-  os::free((char *) _crengine); \/\/ NULL is allowed\n-  _crengine = NULL;\n-  os::free((char *) _crengine_arg_str);\n-  _crengine_arg_str = NULL;\n+  crac::record_time_before_checkpoint();\n@@ -119,2 +109,7 @@\n-  if (!CRaCEngine) {\n-    return true;\n+  \/\/ CRaCCheckpointTo can be changed on restore so we need to update the conf\n+  \/\/ to account for that.\n+  \/\/ Note that CRaCEngine and CRaCEngineOptions are not updated (as documented)\n+  \/\/ so we don't need to re-init the whole engine handle.\n+  if (restore_start_time() != -1 && \/\/ A way to detect we've restored at least once\n+      !_engine->configure_image_location(CRaCCheckpointTo)) {\n+    return JVM_CHECKPOINT_ERROR;\n@@ -122,5 +117,5 @@\n-  char *exec = os::strdup_check_oom(CRaCEngine);\n-  char *comma = strchr(exec, ',');\n-  if (comma != NULL) {\n-    *comma = '\\0';\n-    _crengine_arg_str = os::strdup_check_oom(comma + 1);\n+\n+  const int ret = _engine->checkpoint();\n+  if (ret != 0) {\n+    log_error(crac)(\"CRaC engine failed to checkpoint to %s: error %i\", CRaCCheckpointTo, ret);\n+    return JVM_CHECKPOINT_ERROR;\n@@ -128,29 +123,7 @@\n-  if (os::is_path_absolute(exec)) {\n-    _crengine = exec;\n-  } else {\n-    char path[JVM_MAXPATHLEN];\n-    size_t pathlen = cr_util_path(path, sizeof(path));\n-    strcat(path + pathlen, os::file_separator());\n-    strcat(path + pathlen, exec);\n-    WINDOWS_ONLY(strcat(path + pathlen, \".exe\"));\n-\n-    struct stat st;\n-    if (0 != os::stat(path, &st)) {\n-      warning(\"Could not find CRaCEngine %s: %s\", path, os::strerror(errno));\n-      return false;\n-    }\n-    _crengine = os::strdup_check_oom(path);\n-    \/\/ we have read and duplicated args from exec, now we can release\n-    os::free(exec);\n-  }\n-  _crengine_args[0] = _crengine;\n-  _crengine_argc = 2;\n-\n-  if (_crengine_arg_str != NULL) {\n-    char *arg = _crengine_arg_str;\n-    char *target = _crengine_arg_str;\n-    bool escaped = false;\n-    for (char *c = arg; *c != '\\0'; ++c) {\n-      if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 2) {\n-        warning(\"Too many options to CRaCEngine; cannot proceed with these: %s\", arg);\n-        return false;\n+\n+  switch (_engine->prepare_restore_data_api()) {\n+    case CracEngine::ApiStatus::OK: {\n+      constexpr size_t required_size = sizeof(*shmid);\n+      const size_t available_size = _engine->get_restore_data(shmid, sizeof(*shmid));\n+      if (available_size == required_size) {\n+        break;\n@@ -158,11 +131,3 @@\n-      if (!escaped) {\n-        switch(*c) {\n-        case '\\\\':\n-          escaped = true;\n-          continue; \/\/ for\n-        case ',':\n-          *target++ = '\\0';\n-          _crengine_args[_crengine_argc++] = arg;\n-          arg = target;\n-          continue; \/\/ for\n-        }\n+      if (available_size > required_size) {\n+        log_debug(crac)(\"CRaC engine has more restore data than expected\");\n+        break;\n@@ -170,2 +135,2 @@\n-      escaped = false;\n-      *target++ = *c;\n+      log_error(crac)(\"CRaC engine failed to provide restore data\");\n+      \/\/ fallthrough\n@@ -173,32 +138,2 @@\n-    *target = '\\0';\n-    _crengine_args[_crengine_argc++] = arg;\n-    _crengine_args[_crengine_argc] = NULL;\n-  }\n-  return true;\n-}\n-\n-static void add_crengine_arg(const char *arg) {\n-  if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 1) {\n-      warning(\"Too many options to CRaCEngine; cannot add %s\", arg);\n-      return;\n-  }\n-  _crengine_args[_crengine_argc++] = arg;\n-  _crengine_args[_crengine_argc] = NULL;\n-}\n-\n-static int call_crengine() {\n-  if (!_crengine) {\n-    return -1;\n-  }\n-  _crengine_args[1] = \"checkpoint\";\n-  add_crengine_arg(CRaCCheckpointTo);\n-  return os::exec_child_process_and_wait(_crengine, _crengine_args);\n-}\n-\n-static int checkpoint_restore(int *shmid) {\n-  crac::record_time_before_checkpoint();\n-\n-  int cres = call_crengine();\n-  if (cres < 0) {\n-    tty->print_cr(\"CRaC error executing: %s\\n\", _crengine);\n-    return JVM_CHECKPOINT_ERROR;\n+    case CracEngine::ApiStatus::ERR:         *shmid = -1; break; \/\/ Indicates error to the caller\n+    case CracEngine::ApiStatus::UNSUPPORTED: *shmid = 0;  break; \/\/ Not an error, just no restore data\n@@ -208,11 +143,0 @@\n-  sigset_t waitmask;\n-  sigemptyset(&waitmask);\n-  sigaddset(&waitmask, RESTORE_SIGNAL);\n-\n-  siginfo_t info;\n-  int sig;\n-  do {\n-    sig = sigwaitinfo(&waitmask, &info);\n-  } while (sig == -1 && errno == EINTR);\n-  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n-\n@@ -222,2 +146,0 @@\n-#else\n-  \/\/ TODO add sync processing\n@@ -232,16 +154,0 @@\n-#ifdef LINUX\n-  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n-    tty->print(\"JVM: invalid info for restore provided: %s\", info.si_code == SI_QUEUE ? \"queued\" : \"not queued\");\n-    if (info.si_code == SI_QUEUE) {\n-      tty->print(\" code %d\", info.si_int);\n-    }\n-    tty->cr();\n-    return JVM_CHECKPOINT_ERROR;\n-  }\n-\n-  if (0 < info.si_int) {\n-    *shmid = info.si_int;\n-  }\n-#else\n-  *shmid = 0;\n-#endif \/\/LINUX\n@@ -252,0 +158,1 @@\n+  precond(shmid > 0);\n@@ -256,1 +163,1 @@\n-    log_error(crac)(\"Cannot read restore parameters (JVM flags, env vars, system properties, arguments...)\");\n+    log_error(crac)(\"Cannot read restore parameters\");\n@@ -308,1 +215,0 @@\n-\n@@ -338,1 +244,1 @@\n-  int shmid = 0;\n+  int shmid = -1;\n@@ -341,0 +247,1 @@\n+    shmid = 0;\n@@ -344,1 +251,1 @@\n-    int ret = checkpoint_restore(&shmid);\n+    int ret = crac::checkpoint_restore(&shmid);\n@@ -354,1 +261,3 @@\n-  if (shmid <= 0) {\n+\n+  if (shmid == 0) { \/\/ E.g. engine does not support restore data\n+    log_debug(crac)(\"Restore parameters (JVM flags, env vars, system properties, arguments...) not provided\");\n@@ -357,3 +266,0 @@\n-  } else if (!VM_Crac::read_shm(shmid)) {\n-    vm_direct_exit(1, \"Restore cannot continue, VM will exit.\");\n-    ShouldNotReachHere();\n@@ -361,0 +267,4 @@\n+    if (shmid < 0 || !VM_Crac::read_shm(shmid)) {\n+      vm_direct_exit(1, \"Restore cannot continue, VM will exit.\"); \/\/ More info in logs\n+      ShouldNotReachHere();\n+    }\n@@ -378,0 +288,32 @@\n+void crac::print_engine_info_and_exit() {\n+  CracEngine engine;\n+  if (!engine.is_initialized()) {\n+    return;\n+  }\n+\n+  const CracEngine::ApiStatus status = engine.prepare_description_api();\n+  if (status == CracEngine::ApiStatus::ERR) {\n+    return;\n+  }\n+  if (status == CracEngine::ApiStatus::UNSUPPORTED) {\n+    tty->print_cr(\"Selected CRaC engine does not provide information about itself\");\n+    vm_exit(0);\n+    ShouldNotReachHere();\n+  }\n+  postcond(status == CracEngine::ApiStatus::OK);\n+\n+  const char *description = engine.description();\n+  if (description == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to provide its textual description\");\n+    return;\n+  }\n+  const char *conf_doc = engine.configuration_doc();\n+  if (conf_doc == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to provide documentation of its configuration options\");\n+    return;\n+  }\n+  tty->print_cr(\"%s\\n\\nConfiguration options:\\n%s\", description, conf_doc);\n+\n+  vm_exit(0);\n+  ShouldNotReachHere();\n+}\n@@ -380,1 +322,1 @@\n-  struct stat st;\n+  precond(CRaCCheckpointTo != nullptr);\n@@ -382,0 +324,1 @@\n+  struct stat st;\n@@ -384,1 +327,1 @@\n-      warning(\"%s: not a directory\", CRaCCheckpointTo);\n+      log_error(crac)(\"CRaCCheckpointTo=%s is not a directory\", CRaCCheckpointTo);\n@@ -389,1 +332,1 @@\n-      warning(\"cannot create %s: %s\", CRaCCheckpointTo, os::strerror(errno));\n+      log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n@@ -393,1 +336,1 @@\n-      warning(\"cannot cleanup after check: %s\", os::strerror(errno));\n+      log_warning(crac)(\"Cannot cleanup after CRaCCheckpointTo check: %s\", os::strerror(errno));\n@@ -398,2 +341,6 @@\n-  if (!compute_crengine()) {\n-    return false;\n+  \/\/ Initialize CRaC engine now to verify all the related VM options\n+  assert(_engine == nullptr, \"CRaC engine should be initialized only once\");\n+  _engine = new CracEngine(CRaCCheckpointTo);\n+  if (!_engine->is_initialized()) {\n+    delete _engine;\n+    _engine = nullptr;\n@@ -401,2 +348,1 @@\n-\n-  return true;\n+  return _engine != nullptr;\n@@ -422,1 +368,4 @@\n-  if (!CRaCCheckpointTo) {\n+  log_debug(crac)(\"Checkpoint %i requested (dry run=%s)\", os::current_process_id(), BOOL_TO_STR(dry_run));\n+\n+  if (CRaCCheckpointTo == nullptr) {\n+    log_error(crac)(\"CRaCCheckpointTo is not specified\");\n@@ -427,1 +376,1 @@\n-    warning(\"cannot create %s: %s\", CRaCCheckpointTo, os::strerror(errno));\n+    log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n@@ -524,0 +473,2 @@\n+  precond(CRaCRestoreFrom != nullptr);\n+\n@@ -526,2 +477,1 @@\n-    fprintf(stderr, \"Cannot open restore directory of the -XX:CRaCRestoreFrom parameter: \");\n-    perror(CRaCRestoreFrom);\n+    log_error(crac)(\"Cannot open CRaCRestoreFrom=%s: %s\", CRaCRestoreFrom, os::strerror(errno));\n@@ -531,1 +481,1 @@\n-    fprintf(stderr, \"-XX:CRaCRestoreFrom parameter is not a directory: %s\\n\", CRaCRestoreFrom);\n+    log_error(crac)(\"CRaCRestoreFrom=%s is not a directory\", CRaCRestoreFrom);\n@@ -535,3 +485,5 @@\n-  compute_crengine();\n-\n-  const int id = os::current_process_id();\n+  \/\/ Note that this is a local, i.e. the handle will be destroyed if we fail to restore\n+  CracEngine engine(CRaCRestoreFrom);\n+  if (!engine.is_initialized()) {\n+    return;\n+  }\n@@ -539,15 +491,27 @@\n-  CracSHM shm(id);\n-  int shmfd = shm.open(O_RDWR | O_CREAT | O_TRUNC);\n-  if (shmfd < 0) {\n-    log_error(crac)(\"Cannot pass parameters (JVM flags, env vars, system properties, arguments...) to the restored process.\");\n-  } else {\n-    if (CracRestoreParameters::write_to(\n-          shmfd,\n-          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n-          Arguments::system_properties(),\n-          Arguments::java_command_crac() ? Arguments::java_command_crac() : \"\",\n-          restore_data.restore_time,\n-          restore_data.restore_nanos)) {\n-      char strid[32];\n-      snprintf(strid, sizeof(strid), \"%d\", id);\n-      LINUX_ONLY(setenv(\"CRAC_NEW_ARGS_ID\", strid, true));\n+  switch (engine.prepare_restore_data_api()) {\n+    case CracEngine::ApiStatus::OK: {\n+      const int shmid = os::current_process_id();\n+      CracSHM shm(shmid);\n+      const int shmfd = shm.open(O_RDWR | O_CREAT | O_TRUNC);\n+      if (shmfd < 0) {\n+        log_error(crac)(\"Failed to open a space shared with restored process\");\n+        return;\n+      }\n+      const bool write_success = CracRestoreParameters::write_to(\n+        shmfd,\n+        Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n+        Arguments::system_properties(),\n+        Arguments::java_command_crac() ? Arguments::java_command_crac() : \"\",\n+        restore_data.restore_time,\n+        restore_data.restore_nanos\n+      );\n+      close(shmfd);\n+      if (!write_success) {\n+        log_error(crac)(\"Failed to write to a space shared with restored process\");\n+        return;\n+      }\n+      if (!engine.set_restore_data(&shmid, sizeof(shmid))) {\n+        log_error(crac)(\"CRaC engine failed to record restore data\");\n+        return;\n+      }\n+      break;\n@@ -555,1 +519,5 @@\n-    close(shmfd);\n+    case CracEngine::ApiStatus::ERR: break;\n+    case CracEngine::ApiStatus::UNSUPPORTED:\n+      log_warning(crac)(\"Cannot pass restore parameters (JVM flags, env vars, system properties, arguments...) \"\n+        \"with the selected CRaC engine\");\n+      break;\n@@ -558,5 +526,3 @@\n-  if (_crengine) {\n-    _crengine_args[1] = \"restore\";\n-    add_crengine_arg(CRaCRestoreFrom);\n-    os::execv(_crengine, _crengine_args);\n-    warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", _crengine, os::strerror(errno));\n+  const int ret = engine.restore();\n+  if (ret != 0) {\n+    log_error(crac)(\"CRaC engine failed to restore from %s: error %i\", CRaCRestoreFrom, ret);\n@@ -598,0 +564,7 @@\n+    } else if (strncmp(name, \"CRaCEngine\", ARRAY_SIZE(\"CRaCEngine\") - 1) == 0) {\n+      \/\/ CRaCEngine and CRaCEngineOptions are not updated from the restoring process\n+      assert(strncmp(name, \"CRaCEngine=\", strlen(\"CRaCEngine=\")) == 0 ||\n+             strncmp(name, \"CRaCEngineOptions=\", strlen(\"CRaCEngineOptions=\")) == 0,\n+             \"unexpected CRaCEngine* flag: %s\", name);\n+      result = JVMFlag::Error::SUCCESS;\n+      cursor += strlen(cursor) + 1;\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":150,"deletions":177,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/crac_engine.hpp\"\n@@ -29,1 +30,1 @@\n-#include \"utilities\/macros.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n@@ -35,0 +36,1 @@\n+  friend class VM_Crac;\n@@ -36,0 +38,1 @@\n+  static void print_engine_info_and_exit();\n@@ -37,0 +40,1 @@\n+\n@@ -50,3 +54,0 @@\n-  static void record_time_before_checkpoint();\n-  static void update_javaTimeNanos_offset();\n-\n@@ -60,2 +61,0 @@\n-  static bool read_bootid(char *dest);\n-\n@@ -66,0 +65,9 @@\n+\n+  static CracEngine *_engine;\n+\n+  static bool read_bootid(char *dest);\n+\n+  static void record_time_before_checkpoint();\n+  static void update_javaTimeNanos_offset();\n+\n+  static int checkpoint_restore(int *shmid);\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,368 @@\n+#include \"precompiled.hpp\"\n+\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/crac_engine.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+#include <cstddef>\n+#include <cstring>\n+\n+\/\/ CRaC engine configuration options JVM sets directly instead of relaying from the user\n+#define ENGINE_OPT_IMAGE_LOCATION \"image_location\"\n+#define ENGINE_OPT_EXEC_LOCATION \"exec_location\"\n+\n+#ifdef _WINDOWS\n+static char *strsep(char **strp, const char *delim) {\n+  char *str = *strp;\n+  if (str == nullptr) {\n+    return nullptr;\n+  }\n+  size_t len = strcspn(str, delim);\n+  if (str[len] == '\\0') {\n+    *strp = nullptr;\n+    return str;\n+  }\n+  str[len] = '\\0';\n+  *strp += len + 1;\n+  return str;\n+}\n+#endif \/\/ _WINDOWS\n+\n+static bool find_engine(const char *dll_dir, char *path, size_t path_size, bool *is_library) {\n+  \/\/ Try to interpret as a file path\n+  if (os::is_path_absolute(CRaCEngine)) {\n+    const size_t path_len = strlen(CRaCEngine);\n+    if (path_len + 1 > path_size) {\n+      log_error(crac)(\"CRaCEngine file path is too long: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    if (!os::file_exists(CRaCEngine)) {\n+      log_error(crac)(\"CRaCEngine file does not exist: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    strcpy(path, CRaCEngine);\n+\n+    const char *last_slash = strrchr(CRaCEngine, *os::file_separator());\n+    const char *basename;\n+    if (last_slash == nullptr) {\n+      basename = CRaCEngine;\n+    } else {\n+      basename = last_slash + strlen(os::file_separator());\n+    }\n+    *is_library = strncmp(basename, JNI_LIB_PREFIX, strlen(JNI_LIB_PREFIX)) == 0 &&\n+      strcmp(path + path_len - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0;\n+    log_debug(crac)(\"CRaCEngine path %s is %s library\", CRaCEngine, *is_library ? \"a\" : \"not a\");\n+\n+    return true;\n+  }\n+\n+  \/\/ Try to interpret as a library name\n+  if (os::dll_locate_lib(path, path_size, dll_dir, CRaCEngine)) {\n+    *is_library = true;\n+    log_debug(crac)(\"Found CRaCEngine %s as a library in %s\", CRaCEngine, path);\n+    return true;\n+  }\n+\n+  *is_library = false;\n+  log_debug(crac)(\"CRaCEngine %s is not a library in %s\", CRaCEngine, dll_dir);\n+\n+  constexpr const char suffix[] = WINDOWS_ONLY(\".exe\") NOT_WINDOWS(\"\");\n+#ifndef S_ISREG\n+# define S_ISREG(__mode) (((__mode) & S_IFMT) == S_IFREG)\n+#endif \/\/ S_ISREG\n+  struct stat st;\n+\n+  \/\/ Try to interpret as an executable name with \"engine\" suffix omitted\n+  size_t path_len = strlen(dll_dir) + strlen(os::file_separator()) + strlen(CRaCEngine) + strlen(\"engine\") + strlen(suffix);\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%sengine%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n+    }\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine an executable name with 'engine' omitted: path is too long\");\n+  }\n+\n+  \/\/ Try to interpret as an executable name\n+  precond(path_len > strlen(\"engine\"));\n+  path_len -= strlen(\"engine\");\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%s%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n+    }\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine as an executable name: path is too long\");\n+  }\n+\n+  return false;\n+}\n+\n+static bool configure_image_location(const crlib_api_t &api, crlib_conf_t *conf, const char *image_location) {\n+  precond(image_location != nullptr && image_location[0] != '\\0');\n+  if (!api.configure(conf, ENGINE_OPT_IMAGE_LOCATION, image_location)) {\n+    log_error(crac)(\"CRaC engine failed to configure: '\" ENGINE_OPT_IMAGE_LOCATION \"' = '%s'\", image_location);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ These functions are used in a template instantiation and need to have external linkage. Otherwise\n+\/\/ Windows-debug build fails with linkage errors for the instantiation's symbols.\n+class CStringUtils : public AllStatic {\n+public:\n+  static unsigned int hash(const char * const &s) {\n+    unsigned int h = 0;\n+    for (const char *p = s; *p != '\\0'; p++) {\n+      h = 31 * h + *p;\n+    }\n+    return h;\n+  }\n+\n+  static bool equals(const char * const &s0, const char * const &s1) {\n+    return strcmp(s0, s1) == 0;\n+  }\n+};\n+\n+\/\/ Have to use C-heap because resource area may yet be unavailable when this is used\n+using CStringSet = ResourceHashtable<const char *, bool, 256, AnyObj::C_HEAP, MemTag::mtInternal,\n+                                     CStringUtils::hash, CStringUtils::equals>;\n+\n+static crlib_conf_t *create_conf(const crlib_api_t &api, const char *image_location, const char *exec_location) {\n+  crlib_conf_t * const conf = api.create_conf();\n+  if (conf == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to create its configuration\");\n+    return nullptr;\n+  }\n+\n+  if (CRaCEngineOptions != nullptr && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    return conf;\n+  }\n+\n+  if (image_location != nullptr && !configure_image_location(api, conf, image_location)) {\n+    api.destroy_conf(conf);\n+    return nullptr;\n+  }\n+\n+  if (exec_location != nullptr) { \/\/ Only passed when using crexec\n+    guarantee(api.can_configure(conf, ENGINE_OPT_EXEC_LOCATION),\n+              \"crexec does not support an internal option: \" ENGINE_OPT_EXEC_LOCATION);\n+    if (!api.configure(conf, ENGINE_OPT_EXEC_LOCATION, exec_location)) {\n+      log_error(crac)(\"crexec failed to configure: '\" ENGINE_OPT_EXEC_LOCATION \"' = '%s'\", exec_location);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+  }\n+\n+  if (CRaCEngineOptions == nullptr || CRaCEngineOptions[0] == '\\0' \/* possible for ccstrlist *\/) {\n+    return conf;\n+  }\n+\n+  char *engine_options = os::strdup_check_oom(CRaCEngineOptions, mtInternal);\n+  char *const engine_options_start = engine_options;\n+  CStringSet keys;\n+  do {\n+    char *key_value = strsep(&engine_options, \",\\n\"); \/\/ '\\n' appears when ccstrlist is appended to\n+    const char *key = strsep(&key_value, \"=\");\n+    const char *value = key_value != nullptr ? key_value : \"\";\n+    assert(key != nullptr, \"Should have terminated before\");\n+    if (strcmp(key, ENGINE_OPT_IMAGE_LOCATION) == 0 ||\n+        (exec_location != nullptr && strcmp(key, ENGINE_OPT_EXEC_LOCATION) == 0)) {\n+      log_warning(crac)(\"Internal CRaC engine option provided, skipping: %s\", key);\n+      continue;\n+    }\n+    {\n+      bool is_new_key;\n+      keys.put_if_absent(key, &is_new_key);\n+      if (!is_new_key) {\n+        log_warning(crac)(\"CRaC engine option '%s' specified multiple times\", key);\n+      }\n+    }\n+    if (!api.configure(conf, key, value)) {\n+      log_error(crac)(\"CRaC engine failed to configure: '%s' = '%s'\", key, value);\n+      os::free(engine_options_start);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+    log_debug(crac)(\"CRaC engine option: '%s' = '%s'\", key, value);\n+  } while (engine_options != nullptr);\n+  os::free(engine_options_start);\n+\n+  return conf;\n+}\n+\n+CracEngine::CracEngine(const char *image_location) {\n+  if (CRaCEngine == nullptr) {\n+    log_error(crac)(\"CRaCEngine must not be empty\");\n+    return;\n+  }\n+\n+  \/\/ Arguments::get_dll_dir() might not have been initialized yet\n+  char dll_dir[JVM_MAXPATHLEN];\n+  os::jvm_path(dll_dir, sizeof(dll_dir));\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n+  char *after_elem = nullptr;\n+  for (int i = 0; i < 2; ++i) {\n+    after_elem = strrchr(dll_dir, *os::file_separator());\n+    *after_elem = '\\0';\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  bool is_library;\n+  if (!find_engine(dll_dir, path, sizeof(path), &is_library)) {\n+    log_error(crac)(\"Cannot find CRaC engine %s\", CRaCEngine);\n+    return;\n+  }\n+  postcond(path[0] != '\\0');\n+\n+  char exec_path[JVM_MAXPATHLEN] = \"\\0\";\n+  if (!is_library) {\n+    strcpy(exec_path, path); \/\/ Save to later pass it to crexec\n+    if (!os::dll_locate_lib(path, sizeof(path), dll_dir, \"crexec\")) {\n+      log_error(crac)(\"Cannot find crexec library to use CRaCEngine executable\");\n+      return;\n+    }\n+  }\n+\n+  char error_buf[1024];\n+  void * const lib = os::dll_load(path, error_buf, sizeof(error_buf));\n+  if (lib == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library from %s: %s\", path, error_buf);\n+    return;\n+  }\n+\n+  using api_func_t = decltype(&CRLIB_API);\n+  const auto api_func = reinterpret_cast<api_func_t>(os::dll_lookup(lib, CRLIB_API_FUNC));\n+  if (api_func == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library entrypoint '\" CRLIB_API_FUNC \"' from %s\", path);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  crlib_api_t * const api = api_func(CRLIB_API_VERSION, sizeof(crlib_api_t));\n+  if (api == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to initialize its API (version %i). \"\n+                    \"Maybe this version is not supported?\", CRLIB_API_VERSION);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+  if (api->create_conf == nullptr || api->destroy_conf == nullptr ||\n+      api->checkpoint == nullptr || api->restore == nullptr ||\n+      api->can_configure == nullptr || api->configure == nullptr ||\n+      api->get_extension == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid API\");\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  const char *exec_location = exec_path[0] != '\\0' ? exec_path : nullptr;\n+  crlib_conf_t * const conf = create_conf(*api, image_location, exec_location);\n+  if (conf == nullptr) {\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  _lib = lib;\n+  _api = api;\n+  _conf = conf;\n+}\n+\n+CracEngine::~CracEngine() {\n+  if (is_initialized()) {\n+    _api->destroy_conf(_conf);\n+    os::dll_unload(_lib);\n+  }\n+}\n+\n+bool CracEngine::is_initialized() const {\n+  assert((_lib == nullptr && _api == nullptr && _conf == nullptr) ||\n+          (_lib != nullptr && _api != nullptr && _conf != nullptr), \"invariant\");\n+  return _lib != nullptr;\n+}\n+\n+int CracEngine::checkpoint() const {\n+  precond(is_initialized());\n+  return _api->checkpoint(_conf);\n+}\n+\n+int CracEngine::restore() const {\n+  precond(is_initialized());\n+  return _api->restore(_conf);\n+}\n+\n+bool CracEngine::configure_image_location(const char *image_location) const {\n+  precond(is_initialized());\n+  return ::configure_image_location(*_api, _conf, image_location);\n+}\n+\n+CracEngine::ApiStatus CracEngine::prepare_restore_data_api() {\n+  precond(is_initialized());\n+  if (_restore_data_api != nullptr) {\n+    return ApiStatus::OK;\n+  }\n+\n+  crlib_restore_data_t * const restore_data_api = CRLIB_EXTENSION_RESTORE_DATA(_api);\n+  if (restore_data_api == nullptr) {\n+    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n+    return ApiStatus::UNSUPPORTED;\n+  }\n+  if (restore_data_api->set_restore_data == nullptr || restore_data_api->get_restore_data == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid restore data API\");\n+    return ApiStatus::ERR;\n+  }\n+  _restore_data_api = restore_data_api;\n+  return ApiStatus::OK;\n+}\n+\n+bool CracEngine::set_restore_data(const void *data, size_t size) const {\n+  precond(_restore_data_api != nullptr);\n+  return _restore_data_api->set_restore_data(_conf, data, size);\n+}\n+\n+size_t CracEngine::get_restore_data(void *buf, size_t size) const {\n+  precond(_restore_data_api != nullptr);\n+  return _restore_data_api->get_restore_data(_conf, buf, size);\n+}\n+\n+CracEngine::ApiStatus CracEngine::prepare_description_api() {\n+  precond(is_initialized());\n+  if (_description_api != nullptr) {\n+    return ApiStatus::OK;\n+  }\n+\n+  crlib_description_t * const description_api = CRLIB_EXTENSION_DESCRIPTION(_api);\n+  if (description_api == nullptr) {\n+    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_DESCRIPTION_NAME);\n+    return ApiStatus::UNSUPPORTED;\n+  }\n+  if (description_api->identity == nullptr || description_api->description == nullptr ||\n+      description_api->configuration_doc == nullptr ||\n+      description_api->configurable_keys == nullptr ||\n+      description_api->supported_extensions == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid restore data API\");\n+    return ApiStatus::ERR;\n+  }\n+  _description_api = description_api;\n+  return ApiStatus::OK;\n+}\n+\n+const char *CracEngine::description() const {\n+  precond(_description_api != nullptr);\n+  return _description_api->description(_conf);\n+}\n+\n+const char *CracEngine::configuration_doc() const {\n+  precond(_description_api != nullptr);\n+  return _description_api->configuration_doc(_conf);\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":368,"deletions":0,"binary":false,"changes":368,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_ENGINE_HPP\n+#define SHARE_RUNTIME_CRAC_ENGINE_HPP\n+\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_description.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n+#include \"memory\/allocation.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+\n+#include <cstddef>\n+#include <cstdint>\n+\n+\/\/ CRaC engine library wrapper.\n+class CracEngine : public CHeapObj<mtInternal> {\n+public:\n+  explicit CracEngine(const char *image_location = nullptr);\n+  ~CracEngine();\n+\n+  CracEngine(const CracEngine &) = delete;\n+  CracEngine &operator=(const CracEngine &) = delete;\n+\n+  \/\/ Use this to check whether the constructor succeeded.\n+  bool is_initialized() const;\n+\n+  \/\/ Operations supported by all engines\n+\n+  int checkpoint() const;\n+  int restore() const;\n+  bool configure_image_location(const char *image_location) const;\n+\n+  \/\/ Optionally-supported operations\n+\n+  enum class ApiStatus : uint8_t { OK, ERR, UNSUPPORTED };\n+\n+  ApiStatus prepare_restore_data_api();\n+  bool set_restore_data(const void *data, size_t size) const;\n+  size_t get_restore_data(void *buf, size_t size) const;\n+\n+  ApiStatus prepare_description_api();\n+  const char *description() const;\n+  const char *configuration_doc() const;\n+\n+private:\n+  void *_lib = nullptr;\n+  crlib_api_t *_api = nullptr;\n+  crlib_conf_t *_conf = nullptr;\n+\n+  crlib_restore_data_t *_restore_data_api = nullptr;\n+  crlib_description_t *_description_api = nullptr;\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_CRAC_ENGINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -1963,5 +1963,12 @@\n-      \"Path or name of a program implementing checkpoint\/restore and \"      \\\n-      \"optional extra parameters as a comma-separated list: \"               \\\n-      \"-XX:CRaCEngine=program,--key,value,--anotherkey results in calling \" \\\n-      \"'program --key value --anotherkey'. Commas used as part of args \"    \\\n-      \"should be escaped with a backslash character ('\\\\').\")               \\\n+      \"Path or name of a program or a shared library implementing \"         \\\n+      \"checkpoint and restore. On restore this option applies only to \"     \\\n+      \"the restoring VM, i.e. the restored VM keeps the value it had \"      \\\n+      \"before the checkpoint.\")                                             \\\n+                                                                            \\\n+  product(ccstrlist, CRaCEngineOptions, nullptr, RESTORE_SETTABLE,          \\\n+      \"Options passed to CRaCEngine, in the form of 'key1=value,key2'. \"    \\\n+      \"The list of supported options is engine-dependent, use \"             \\\n+      \"'-XX:CRaCEngineOptions=help' to make the VM print the information \"  \\\n+      \"about the engine, including its supported options, and exit. On \"    \\\n+      \"restore this option applies only to the restoring VM, i.e. the \"     \\\n+      \"restored VM keeps the value it had before the checkpoint.\")          \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -642,2 +642,0 @@\n-  static int exec_child_process_and_wait(const char *path, const char *argv[]);\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,605 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <cassert>\n+#include <cstdint>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <cstring>\n+#include <new>\n+\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_description.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n+#include \"hashtable.hpp\"\n+#include \"jni.h\"\n+\n+#ifdef LINUX\n+#include <csignal>\n+\n+#include \"jvm.h\"\n+#endif \/\/ LINUX\n+\n+extern \"C\" {\n+\n+JNIEXPORT crlib_api_t *CRLIB_API(int api_version, size_t api_size);\n+\n+static crlib_conf_t *create_conf();\n+static void destroy_conf(crlib_conf_t *conf);\n+static int checkpoint(crlib_conf_t *conf);\n+static int restore(crlib_conf_t *conf);\n+static bool can_configure(crlib_conf_t *conf, const char *key);\n+static bool configure(crlib_conf_t *conf, const char *key, const char *value);\n+static const crlib_extension_t *get_extension(const char *name, size_t size);\n+\n+static const char *identity(crlib_conf_t *conf);\n+static const char *description(crlib_conf_t *conf);\n+static const char *configuration_doc(crlib_conf_t *conf);\n+static const char * const *configurable_keys(crlib_conf_t *conf);\n+static crlib_extension_t * const *supported_extensions(crlib_conf_t *conf);\n+\n+static bool set_restore_data(crlib_conf_t *conf, const void *data, size_t size);\n+static size_t get_restore_data(crlib_conf_t *conf, void *buf, size_t size);\n+\n+} \/\/ extern \"C\"\n+\n+static crlib_api_t api = {\n+  create_conf,\n+  destroy_conf,\n+  checkpoint,\n+  restore,\n+  can_configure,\n+  configure,\n+  get_extension,\n+};\n+\n+static crlib_description_t description_extension = {\n+  {\n+    CRLIB_EXTENSION_DESCRIPTION_NAME,\n+    sizeof(description_extension)\n+  },\n+  identity,\n+  description,\n+  configuration_doc,\n+  configurable_keys,\n+  supported_extensions,\n+};\n+\n+static crlib_restore_data_t restore_data_extension = {\n+  {\n+    CRLIB_EXTENSION_RESTORE_DATA_NAME,\n+    sizeof(restore_data_extension)\n+  },\n+  set_restore_data,\n+  get_restore_data,\n+};\n+\n+static const crlib_extension_t *extensions[] = {\n+  &restore_data_extension.header,\n+  &description_extension.header,\n+  nullptr\n+};\n+\n+#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(*(x)))\n+\n+#define CREXEC \"crexec: \"\n+\n+\/\/ crexec_md.cpp\n+const char *file_separator();\n+bool is_path_absolute(const char *path);\n+bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]);\n+char **get_environ();\n+void exec_in_this_process(const char *path, const char *argv[], const char *env[]);\n+\n+JNIEXPORT crlib_api_t *CRLIB_API(int api_version, size_t api_size) {\n+  if (api_version != CRLIB_API_VERSION) {\n+    return nullptr;\n+  }\n+  if (sizeof(crlib_api_t) < api_size) {\n+    return nullptr;\n+  }\n+  return &api;\n+}\n+\n+\/\/ When adding a new option also add its description into the help message,\n+\/\/ ensure the proper default value is set for it in the configuration struct and\n+\/\/ consider checking for inappropriate use on checkpoint\/restore.\n+\/\/\n+\/\/ Place more frequently used options first - this will make them faster to find\n+\/\/ in the options hash table.\n+#define CONFIGURE_OPTIONS(OPT) \\\n+  OPT(image_location) \\\n+  OPT(exec_location) \\\n+  OPT(keep_running) \\\n+  OPT(direct_map) \\\n+  OPT(args) \\\n+\n+#define DEFINE_OPT(id) static constexpr char opt_##id[] = #id;\n+CONFIGURE_OPTIONS(DEFINE_OPT)\n+#undef DEFINE_OPT\n+#define ADD_ARR_ELEM(id) opt_##id,\n+static constexpr const char *configure_options[] = { CONFIGURE_OPTIONS(ADD_ARR_ELEM) nullptr };\n+#undef ADD_ARR_ELEM\n+\n+static char *strdup_checked(const char *src) {\n+  char * const res = strdup(src);\n+  if (res == nullptr) {\n+    fprintf(stderr, CREXEC \"out of memory\\n\");\n+  }\n+  return res;\n+}\n+\n+static bool parse_bool(const char *str, bool *result) {\n+  if (strcmp(str, \"true\") == 0) {\n+    *result = true;\n+    return true;\n+  }\n+  if (strcmp(str, \"false\") == 0) {\n+    *result = false;\n+    return true;\n+  }\n+  fprintf(stderr, CREXEC \"expected '%s' to be either 'true' or 'false'\\n\", str);\n+  return false;\n+}\n+\n+\/\/ Indices of argv array members.\n+enum Argv : std::uint8_t {\n+  ARGV_EXEC_LOCATION,\n+  ARGV_ACTION,\n+  ARGV_IMAGE_LOCATION,\n+  ARGV_FREE, \/\/ First index for user-provided arguments\n+  ARGV_LAST = 31,\n+};\n+\n+struct crlib_conf {\n+private:\n+  using configure_func = bool (crlib_conf::*) (const char *value);\n+  Hashtable<configure_func> _options {\n+    configure_options, ARRAY_SIZE(configure_options) - 1 \/* omit nullptr *\/\n+  };\n+\n+  bool _keep_running = false;\n+  bool _direct_map = false;\n+  int _restore_data = 0;\n+  const char *_argv[ARGV_LAST + 2] = {}; \/\/ Last element is required to be null\n+\n+public:\n+  crlib_conf() {\n+    if (!_options.is_initialized()) {\n+      fprintf(stderr, CREXEC \"out of memory\\n\");\n+      assert(!is_initialized());\n+      return;\n+    }\n+#define PUT_HANDLER(id) _options.put(opt_##id, &crlib_conf::configure_##id);\n+    CONFIGURE_OPTIONS(PUT_HANDLER)\n+#undef PUT_HANDLER\n+  }\n+\n+  ~crlib_conf() {\n+    for (int i = 0; i <= ARGV_FREE \/* all free args are allocated together *\/; i++) {\n+      if (i != ARGV_ACTION) { \/\/ Action is a static string\n+        free(const_cast<char*>(_argv[i]));\n+      }\n+    }\n+  }\n+\n+  \/\/ Use this to check whether the constructor succeeded.\n+  bool is_initialized() const { return _options.is_initialized(); }\n+\n+  bool keep_running() const { return _keep_running; }\n+  bool direct_map() const { return _direct_map; }\n+  int restore_data() const { return _restore_data; }\n+  const char * const *argv() const { return _argv; }\n+\n+  bool can_configure(const char *key) const {\n+    assert(key != nullptr);\n+    return _options.contains(key);\n+  }\n+\n+  bool configure(const char *key, const char *value) {\n+    assert(key != nullptr && value != nullptr);\n+    auto * const func = _options.get(key);\n+    if (func != nullptr) {\n+      return (this->**func)(value);\n+    }\n+    fprintf(stderr, CREXEC \"unknown configure option: %s\\n\", key);\n+    return false;\n+  }\n+\n+  void set_argv_action(const char *action) { _argv[ARGV_ACTION] = action; }\n+\n+  bool set_restore_data(const void *data, size_t size) {\n+    if (size != sizeof(_restore_data)) {\n+      fprintf(stderr, CREXEC \"unsupported size of restore data: %zu - only %zu is supported\\n\",\n+              size, sizeof(_restore_data));\n+      return false;\n+    }\n+    _restore_data = *static_cast<const int *>(data);\n+    return true;\n+  }\n+\n+  size_t get_restore_data(void *buf, size_t size) {\n+    if (size < sizeof(_restore_data)) {\n+      fprintf(stderr, CREXEC \"can only provide >= %zu bytes of restore data but %zu was requested\\n\",\n+              sizeof(_restore_data), size);\n+      return 0;\n+    }\n+    *static_cast<int *>(buf) = _restore_data;\n+    return sizeof(_restore_data);\n+  }\n+\n+private:\n+  bool configure_image_location(const char *image_location) {\n+    const char *copy = strdup_checked(image_location);\n+    if (copy == nullptr) {\n+      return false;\n+    }\n+    free(const_cast<char *>(_argv[ARGV_IMAGE_LOCATION]));\n+    _argv[ARGV_IMAGE_LOCATION] = copy;\n+    return true;\n+  }\n+\n+  bool configure_exec_location(const char *exec_location) {\n+    if (!is_path_absolute(exec_location)) {\n+      fprintf(stderr, CREXEC \"expected absolute path: %s\\n\", exec_location);\n+      return false;\n+    }\n+    const char *copy = strdup_checked(exec_location);\n+    if (copy == nullptr) {\n+      return false;\n+    }\n+    free(const_cast<char *>(_argv[ARGV_EXEC_LOCATION]));\n+    _argv[ARGV_EXEC_LOCATION] = copy;\n+    return true;\n+  }\n+\n+  bool configure_keep_running(const char *keep_running_str) {\n+    return parse_bool(keep_running_str, &_keep_running);\n+  }\n+\n+  bool configure_direct_map(const char *direct_map_str) {\n+    return parse_bool(direct_map_str, &_direct_map);\n+  }\n+\n+  bool configure_args(const char *args_str) {\n+    char *arg = strdup_checked(args_str);\n+    if (arg == nullptr) {\n+      return false;\n+    }\n+\n+    static constexpr int MAX_ARGS_NUM = ARGV_LAST - ARGV_FREE + 1;\n+    static_assert(MAX_ARGS_NUM >= 0, \"sanity check\");\n+    const char *args[MAX_ARGS_NUM];\n+\n+    int arg_i = 0;\n+    static constexpr char SEP = ' ';\n+    for (; arg_i < MAX_ARGS_NUM; arg_i++) {\n+      args[arg_i] = arg;\n+      for (; arg[0] != SEP && arg[0] != '\\0'; arg++) {}\n+      if (arg[0] == '\\0') {\n+        break;\n+      }\n+      assert(arg[0] == SEP);\n+      *(arg++) = '\\0';\n+    }\n+\n+    if (arg[0] != '\\0') {\n+      assert(arg_i == MAX_ARGS_NUM);\n+      fprintf(stderr, CREXEC \"too many free arguments, at most %i allowed\\n\", MAX_ARGS_NUM);\n+      free(const_cast<char *>(args[0]));\n+      return false;\n+    }\n+\n+    free(const_cast<char *>(_argv[ARGV_FREE]));\n+    memcpy(&_argv[ARGV_FREE], args, (arg_i + 1) * sizeof(const char *));\n+    return true;\n+  }\n+};\n+\n+static crlib_conf_t *create_conf() {\n+  auto * const conf = new(std::nothrow) crlib_conf();\n+  if (conf == nullptr || !conf->is_initialized()) {\n+    delete conf;\n+    return nullptr;\n+  }\n+  return conf;\n+}\n+\n+static void destroy_conf(crlib_conf_t *conf) {\n+  delete conf;\n+}\n+\n+static bool can_configure(crlib_conf_t *conf, const char *key) {\n+  return conf->can_configure(key);\n+}\n+\n+static bool configure(crlib_conf_t *conf, const char *key, const char *value) {\n+  return conf->configure(key, value);\n+}\n+\n+static const char *identity(crlib_conf_t *conf) {\n+  return \"crexec\";\n+}\n+\n+static const char *description(crlib_conf_t *conf) {\n+  return\n+    \"crexec - pseudo-CRaC-engine used to relay data from JVM to a \\\"real\\\" engine implemented as \"\n+    \"an executable (instead of a library). The engine executable is expected to have \"\n+    \"CRaC-CRIU-like CLI. Support of the configuration options also depends on the engine \"\n+    \"executable.\";\n+}\n+\n+static const char *configuration_doc(crlib_conf_t *conf) {\n+  \/\/ Internal options which are expected to be set by the program crexec is linked to are omitted\n+  \/\/ since users are not supposed to pass them directly:\n+  \/\/ * image_location=<path> (no default) - path to a directory with checkpoint\/restore files.\n+  \/\/ * exec_location=<path> (no default) - path to the engine executable.\n+  return\n+    \"* keep_running=<true\/false> (default: false) - keep the process running after the checkpoint \"\n+    \"or kill it.\\n\"\n+    \"* direct_map=<true\/false> (default: false) - on restore, map process data directly from saved \"\n+    \"files. This may speedup the restore but the resulting process will not be the same as before \"\n+    \"the checkpoint.\\n\"\n+    \"* args=<string> (default: \\\"\\\") - free space-separated arguments passed directly to the \"\n+    \"engine executable, e.g. \\\"--arg1 --arg2 --arg3\\\".\";\n+}\n+\n+static const char * const *configurable_keys(crlib_conf_t *conf) {\n+  return configure_options;\n+}\n+\n+static crlib_extension_t * const *supported_extensions(crlib_conf_t *conf) {\n+  return extensions;\n+}\n+\n+static bool set_restore_data(crlib_conf_t *conf, const void *data, size_t size) {\n+  return conf->set_restore_data(data, size);\n+}\n+\n+static size_t get_restore_data(crlib_conf_t *conf, void *buf, size_t size) {\n+  return conf->get_restore_data(buf, size);\n+}\n+\n+static const crlib_extension_t *get_extension(const char *name, size_t size) {\n+  for (size_t i = 0; i < ARRAY_SIZE(extensions) - 1 \/* omit nullptr *\/; i++) {\n+    const crlib_extension_t *ext = extensions[i];\n+    if (strcmp(name, ext->name) == 0) {\n+      if (size <= ext->size) {\n+        return ext;\n+      }\n+      return nullptr;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+class Environment {\n+private:\n+  char **_env;\n+  size_t _length;\n+\n+public:\n+  explicit Environment(const char * const *env = get_environ()) {\n+    _length = 0;\n+    for (; env[_length] != nullptr; _length++) {}\n+\n+    \/\/ Not using new here because we cannot safely use realloc with it\n+    _env = static_cast<char**>(malloc((_length + 1) * sizeof(char *)));\n+    if (_env == nullptr) {\n+      return;\n+    }\n+\n+    for (size_t i = 0; i < _length; i++) {\n+      _env[i] = strdup(env[i]);\n+      if (_env[i] == nullptr) {\n+        for (size_t j = 0; j < i; i++) {\n+          free(_env[j]);\n+          free(_env);\n+          _env = nullptr;\n+        }\n+        assert(!is_initialized());\n+        return;\n+      }\n+    }\n+    _env[_length] = nullptr;\n+  }\n+\n+  ~Environment() {\n+    if (is_initialized()) {\n+      for (size_t i = 0; i < _length; i++) {\n+        free(_env[i]);\n+      }\n+      free(_env);\n+    }\n+  }\n+\n+  \/\/ Use this to check whether the constructor succeeded.\n+  bool is_initialized() const { return _env != nullptr; }\n+\n+  char **env() { return _env; }\n+\n+  bool append(const char *var, const char *value) {\n+    assert(is_initialized());\n+\n+    const size_t str_size = strlen(var) + strlen(\"=\") + strlen(value) + 1;\n+    char * const str = static_cast<char *>(malloc(sizeof(char) * str_size));\n+    if (str == nullptr) {\n+      fprintf(stderr, CREXEC \"out of memory\\n\");\n+      return false;\n+    }\n+    if (snprintf(str, str_size, \"%s=%s\", var, value) != static_cast<int>(str_size) - 1) {\n+      perror(CREXEC \"snprintf env var\");\n+      free(str);\n+      return false;\n+    }\n+\n+    {\n+      char ** const new_env = static_cast<char **>(realloc(_env, (_length + 2) * sizeof(char *)));\n+      if (new_env == nullptr) {\n+        fprintf(stderr, CREXEC \"out of memory\\n\");\n+        free(str);\n+        return false;\n+      }\n+      _env = new_env;\n+    }\n+\n+    _env[_length++] = str;\n+    _env[_length] = nullptr;\n+\n+    return true;\n+  }\n+\n+  bool add_criu_option(const char *opt) {\n+    constexpr char CRAC_CRIU_OPTS[] = \"CRAC_CRIU_OPTS\";\n+    constexpr size_t CRAC_CRIU_OPTS_LEN = ARRAY_SIZE(CRAC_CRIU_OPTS) - 1;\n+\n+    assert(is_initialized());\n+\n+    bool opts_found = false;\n+    size_t opts_index = 0;\n+    for (; _env[opts_index] != nullptr; opts_index++) {\n+      if (strcmp(_env[opts_index], CRAC_CRIU_OPTS) == 0 && _env[opts_index][CRAC_CRIU_OPTS_LEN] == '=') {\n+        opts_found = true;\n+        break;\n+      }\n+    }\n+\n+    if (!opts_found) {\n+      return append(CRAC_CRIU_OPTS, opt);\n+    }\n+\n+    if (strstr(_env[opts_index] + CRAC_CRIU_OPTS_LEN + 1, opt) != nullptr) {\n+      return true;\n+    }\n+\n+    const size_t new_opts_size = strlen(_env[opts_index]) + strlen(\" \") + strlen(opt) + 1;\n+    char * const new_opts = static_cast<char *>(malloc(new_opts_size * sizeof(char)));\n+    if (new_opts == nullptr) {\n+      fprintf(stderr, CREXEC \"out of memory\\n\");\n+      return false;\n+    }\n+    if (snprintf(new_opts, new_opts_size, \"%s %s\", _env[opts_index], opt) !=\n+          static_cast<int>(new_opts_size) - 1) {\n+      perror(CREXEC \"snprintf CRAC_CRIU_OPTS (append)\");\n+      free(new_opts);\n+      return false;\n+    }\n+    free(_env[opts_index]);\n+    _env[opts_index] = new_opts;\n+\n+    return true;\n+  }\n+};\n+\n+static int checkpoint(crlib_conf_t *conf) {\n+  if (conf->argv()[ARGV_EXEC_LOCATION] == nullptr) {\n+    fprintf(stderr, CREXEC \"%s must be set before checkpoint\\n\", opt_exec_location);\n+    return -1;\n+  }\n+  if (conf->argv()[ARGV_IMAGE_LOCATION] == nullptr) {\n+    fprintf(stderr, CREXEC \"%s must be set before checkpoint\\n\", opt_image_location);\n+    return -1;\n+  }\n+  conf->set_argv_action(\"checkpoint\");\n+\n+  if (conf->direct_map()) {\n+    fprintf(stderr, CREXEC \"%s has no effect on checkpoint\\n\", opt_direct_map);\n+  }\n+\n+  {\n+    Environment env;\n+    if (!env.is_initialized()||\n+        (conf->keep_running() && !env.append(\"CRAC_CRIU_LEAVE_RUNNING\", \"\"))) {\n+      return -1;\n+    }\n+\n+    if (!exec_child_process_and_wait(conf->argv()[ARGV_EXEC_LOCATION],\n+                                     const_cast<char **>(conf->argv()), env.env())) {\n+      return -1;\n+    }\n+  }\n+\n+#ifdef LINUX\n+  siginfo_t info;\n+  sigset_t waitmask;\n+  sigemptyset(&waitmask);\n+  sigaddset(&waitmask, RESTORE_SIGNAL);\n+\n+  int sig;\n+  do {\n+    sig = sigwaitinfo(&waitmask, &info);\n+  } while (sig == -1 && errno == EINTR);\n+\n+  if (info.si_code != SI_QUEUE) {\n+    return false;\n+  }\n+  {\n+#ifndef NDEBUG\n+    const bool ok =\n+#endif \/\/ NDEBUG\n+    conf->set_restore_data(&info.si_int, sizeof(info.si_int));\n+    assert(ok);\n+  }\n+#endif \/\/ LINUX\n+\n+  return 0;\n+}\n+\n+static int restore(crlib_conf_t *conf) {\n+  if (conf->argv()[ARGV_EXEC_LOCATION] == nullptr) {\n+    fprintf(stderr, CREXEC \"%s must be set before restore\\n\", opt_exec_location);\n+    return -1;\n+  }\n+  if (conf->argv()[ARGV_IMAGE_LOCATION] == nullptr) {\n+    fprintf(stderr, CREXEC \"%s must be set before restore\\n\", opt_image_location);\n+    return -1;\n+  }\n+  conf->set_argv_action(\"restore\");\n+\n+  if (conf->keep_running()) {\n+    fprintf(stderr, CREXEC \"%s has no effect on restore\\n\", opt_keep_running);\n+  }\n+\n+  char restore_data_str[32];\n+  if (snprintf(restore_data_str, sizeof(restore_data_str), \"%i\", conf->restore_data()) >\n+      static_cast<int>(sizeof(restore_data_str)) - 1) {\n+    perror(CREXEC \"snprintf restore data\");\n+    return -1;\n+  }\n+\n+  Environment env;\n+  if (!env.is_initialized() ||\n+      !env.append(\"CRAC_NEW_ARGS_ID\", restore_data_str) ||\n+      (!conf->direct_map() && !env.add_criu_option(\"--no-mmap-page-image\"))) {\n+    return -1;\n+  }\n+\n+  exec_in_this_process(conf->argv()[ARGV_EXEC_LOCATION],\n+                       const_cast<const char **>(conf->argv()),\n+                       const_cast<const char **>(env.env()));\n+\n+  fprintf(stderr, CREXEC \"restore failed\\n\");\n+  return -1;\n+}\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.cpp","additions":605,"deletions":0,"binary":false,"changes":605,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef HASHTABLE_HPP\n+#define HASHTABLE_HPP\n+\n+#include <cassert>\n+#include <cstddef>\n+#include <cstring>\n+#include <new>\n+\n+template<class T>\n+class Hashtable {\n+public:\n+  Hashtable(const char * const keys[], size_t length);\n+  ~Hashtable();\n+\n+  \/\/ Use this to check whether the constructor succeeded.\n+  bool is_initialized() const { return _keys != nullptr; }\n+\n+  size_t length() const { return _length; }\n+\n+  bool contains(const char *key) const;\n+  T *get(const char *key) const;\n+  bool put(const char *key, T value);\n+\n+private:\n+  size_t _length;\n+  const char **_keys;\n+  T *_values;\n+\n+  static unsigned int string_hash(const char *str);\n+};\n+\n+template<class T>\n+unsigned int Hashtable<T>::string_hash(const char *str) {\n+  assert(str != nullptr);\n+  unsigned int hash = 0;\n+  for (; *str != '\\0'; str++) {\n+    hash = 31 * hash + *str;\n+  }\n+  return hash;\n+}\n+\n+template<class T>\n+Hashtable<T>::Hashtable(const char * const keys[], size_t length) :\n+    _length(length),\n+    _keys(new(std::nothrow) const char*[length]()),\n+    _values(new(std::nothrow) T[length]()) {\n+  if (_keys == nullptr || _values == nullptr) {\n+    delete[] _keys;\n+    delete[] _values;\n+    _keys = nullptr;\n+    _values = nullptr;\n+    assert(!is_initialized());\n+    return;\n+  }\n+\n+  for (size_t i = 0; i < length; i++) {\n+    const char *key = keys[i];\n+    assert(key != nullptr);\n+    const unsigned int hash = string_hash(key) % length;\n+    bool place_found = false;\n+    for (size_t j = hash; !place_found && j < length; j++) {\n+      if (_keys[j] == nullptr) {\n+        _keys[j] = key;\n+        place_found = true;\n+      }\n+    }\n+    for (size_t j = 0; !place_found && j < hash; j++) {\n+      if (_keys[j] == nullptr) {\n+        _keys[j] = key;\n+        place_found = true;\n+      }\n+    }\n+    assert(place_found); \/\/ There should be enough space for all keys to fit\n+  }\n+\n+  assert(is_initialized());\n+}\n+\n+template<class T>\n+Hashtable<T>::~Hashtable() {\n+  delete[] _keys;\n+  delete[] _values;\n+}\n+\n+template<class T>\n+bool Hashtable<T>::contains(const char *key) const {\n+  return get(key) != nullptr;\n+}\n+\n+template<class T>\n+T *Hashtable<T>::get(const char *key) const {\n+  assert(key != nullptr);\n+  const unsigned int hash = string_hash(key) % _length;\n+  for (size_t i = hash; i < _length; i++) {\n+    if (strcmp(key, _keys[i]) == 0) {\n+      return &_values[i];\n+    }\n+  }\n+  for (size_t i = 0; i < hash; i++) {\n+    if (strcmp(key, _keys[i]) == 0) {\n+      return &_values[i];\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+template<class T>\n+bool Hashtable<T>::put(const char *key, T value) {\n+  T * const value_ptr = get(key);\n+  if (value_ptr == nullptr) {\n+    return false;\n+  }\n+  *value_ptr = value;\n+  return true;\n+}\n+\n+#endif \/\/ HASHTABLE_HPP\n","filename":"src\/java.base\/share\/native\/libcrexec\/hashtable.hpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-        const char* argsidstr = getenv(\"SIM_CRAC_NEW_ARGS_ID\");\n+        const char* argsidstr = getenv(\"CRAC_NEW_ARGS_ID\");\n@@ -64,1 +64,1 @@\n-        printf(\"SIM_CRAC_NEW_ARGS_ID=%s\\n\", strid ? strid : \"0\");\n+        printf(\"CRAC_NEW_ARGS_ID=%s\\n\", strid ? strid : \"0\");\n","filename":"src\/java.base\/share\/native\/simengine\/simengine.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <cerrno>\n+#include <cstdio>\n+#include <spawn.h>\n+#include <sys\/types.h>\n+#include <sys\/wait.h>\n+#include <unistd.h>\n+\n+static constexpr char SLASH = '\/';\n+static constexpr const char SEP[] = { SLASH, '\\0' };\n+\n+const char *file_separator() {\n+  return SEP;\n+}\n+\n+bool is_path_absolute(const char* path) {\n+  return path[0] == SLASH;\n+}\n+\n+\/\/ Darwin has no \"environ\" in a dynamic library.\n+#ifdef __APPLE__\n+  #include <crt_externs.h>\n+  #define environ (*_NSGetEnviron())\n+#else\n+  extern char** environ;\n+#endif\n+\n+char **get_environ() {\n+  return environ;\n+}\n+\n+bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]) {\n+  pid_t pid;\n+  if (posix_spawn(&pid, path, nullptr, nullptr, argv, env) != 0) {\n+    perror(\"Cannot spawn cracengine\");\n+    return false;\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return false;\n+  }\n+  return WEXITSTATUS(status) == 0;\n+}\n+\n+void exec_in_this_process(const char *path, const char *argv[], const char *env[]) {\n+  execve(path, const_cast<char **>(argv), const_cast<char **>(env));\n+}\n","filename":"src\/java.base\/unix\/native\/libcrexec\/crexec_md.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -679,0 +679,1 @@\n+      \/\/ TODO: this should depend on CRaCEngine!\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024-2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <cstdlib>\n+#include <cstring>\n+#include <direct.h>\n+#include <process.h>\n+#include <windows.h>\n+\n+static constexpr char SLASH = '\\\\';\n+static constexpr const char SEP[] = { SLASH, '\\0' };\n+\n+const char *file_separator() {\n+  return SEP;\n+}\n+\n+static inline int isLetter(char c) {\n+  return ((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'));\n+}\n+\n+\/\/ Copy from FileSystemSupport_md.c\n+static int prefixLength(const char* path) {\n+  char c0, c1;\n+\n+  int n = (int)strlen(path);\n+  if (n == 0) return 0;\n+  c0 = path[0];\n+  c1 = (n > 1) ? path[1] : 0;\n+  if (c0 == SLASH) {\n+    if (c1 == SLASH) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+    return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+  }\n+  if (isLetter(c0) && (c1 == ':')) {\n+    if ((n > 2) && (path[2] == SLASH))\n+      return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+    return 2;                       \/* Directory-relative \"z:foo\" *\/\n+  }\n+  return 0;                   \/* Completely relative *\/\n+}\n+\n+bool is_path_absolute(const char* path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == SLASH)) || (pl == 3));\n+}\n+\n+char **get_environ() {\n+  return _environ;\n+}\n+\n+bool exec_child_process_and_wait(const char *path, char * const argv[], char * const env[]) {\n+  \/\/ Avoid crashing in _spawnve(), https:\/\/bugs.python.org\/issue29908\n+  SetEnvironmentVariable(TEXT(\"=CRAC_DUMMY\"), TEXT(\"dummy\"));\n+  intptr_t status = _spawnve(_P_WAIT, path, argv, env); \/\/ env is inherited by a child process\n+  return status == 0;\n+}\n+\n+void exec_in_this_process(const char *path, const char *argv[], const char *env[]) {\n+  \/\/ The same problem as above\n+  SetEnvironmentVariable(TEXT(\"=CRAC_DUMMY\"), TEXT(\"dummy\"));\n+  _execve(path, argv, env);\n+}\n","filename":"src\/java.base\/windows\/native\/libcrexec\/crexec_md.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.Test;\n+import org.junit.BeforeClass;\n+import static org.junit.Assert.*;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+\/*\n+* @test\n+* @summary Testing CRaCEngine and CRaCEngineOptions VM options.\n+* @library \/test\/lib\n+* @build CracEngineOptionsTest\n+* @run junit\/othervm CracEngineOptionsTest\n+*\/\n+public class CracEngineOptionsTest {\n+    @BeforeClass\n+    public static void checkCriu() {\n+        final boolean hasCriu = Path.of(Utils.TEST_JDK, \"lib\", \"criuengine\").toFile().exists();\n+        assertEquals(\"CRIU exists iff we are on Linux\", Platform.isLinux(), hasCriu);\n+    }\n+\n+    @Test\n+    public void test_default() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-XX:CRaCCheckpointTo=cr\",\n+                \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    @Test\n+    public void test_engines() throws Exception {\n+        test(\"sim\");\n+        test(\"simengine\");\n+        test(\"pause\");\n+        test(\"pauseengine\");\n+        if (Platform.isLinux()) {\n+            test(\"criu\");\n+            test(\"criuengine\");\n+        }\n+\n+        final String absolute = Platform.isWindows() ?\n+            Path.of(Utils.TEST_JDK, \"bin\", \"simengine.exe\").toString() :\n+            Path.of(Utils.TEST_JDK, \"lib\", \"simengine\").toString();\n+        test(absolute);\n+\n+        test(\"unknown\", null, 1, \"Cannot find CRaC engine unknown\");\n+        test(\"simengine,--arg\", null, 1, \"Cannot find CRaC engine simengine,--arg\");\n+        test(\"one two\", null, 1, \"Cannot find CRaC engine one two\");\n+        test(\"\", null, 1, \"CRaCEngine must not be empty\");\n+    }\n+\n+    @Test\n+    public void test_options() throws Exception {\n+        test(\"simengine\", \"\");\n+        test(\"simengine\", \"image_location=cr\", 0,\n+                \"Internal CRaC engine option provided, skipping: image_location\");\n+        if (Platform.isLinux()) {\n+            test(\"criuengine\", Arrays.asList(\"keep_running=true,args=-v -v -v -v\"), 0,\n+                    Arrays.asList(\n+                        \"CRaC engine option: 'keep_running' = 'true'\",\n+                        \"CRaC engine option: 'args' = '-v -v -v -v'\"\n+                    ),\n+                    Arrays.asList(\"specified multiple times\"));\n+            test(\"criuengine\", \"keep_running=true,args=-v -v -v -v,keep_running=false\", 0,\n+                    \"CRaC engine option: 'keep_running' = 'true'\",\n+                    \"CRaC engine option: 'args' = '-v -v -v -v'\",\n+                    \"CRaC engine option: 'keep_running' = 'false'\",\n+                    \"CRaC engine option 'keep_running' specified multiple times\");\n+        }\n+\n+        test(\"simengine\", \"help=true\", 1,\n+                \"unknown configure option: help\",\n+                \"CRaC engine failed to configure: 'help' = 'true'\");\n+        test(\"simengine\", \"unknown=123\", 1,\n+                \"unknown configure option: unknown\",\n+                \"CRaC engine failed to configure: 'unknown' = '123'\");\n+        test(\"simengine\", \"unknown=\", 1,\n+                \"unknown configure option: unknown\",\n+                \"CRaC engine failed to configure: 'unknown' = ''\");\n+        test(\"simengine\", \"=\", 1,\n+                \"unknown configure option: \\n\",\n+                \"CRaC engine failed to configure: '' = ''\");\n+        test(\"simengine\", \"=,\", 1,\n+                \"unknown configure option: \\n\",\n+                \"CRaC engine failed to configure: '' = ''\");\n+        test(\"simengine\", \",=\", 1,\n+                \"unknown configure option: \\n\",\n+                \"CRaC engine failed to configure: '' = ''\");\n+        test(\"simengine\", \",\", 1,\n+                \"unknown configure option: \\n\",\n+                \"CRaC engine failed to configure: '' = ''\");\n+\n+        if (Platform.isLinux()) {\n+            test(\"criuengine\", \"direct_map=not a bool\", 1,\n+                    \"CRaC engine failed to configure: 'direct_map' = 'not a bool'\");\n+        }\n+    }\n+\n+    @Test\n+    public void test_options_separated() throws Exception {\n+        test(\"simengine\",\n+                Arrays.asList(\n+                    \"args=simengine ignores this\",\n+                    \"args=another arg,keep_running=true,args=and another\",\n+                    \"args=this is also ignored\"\n+                ),\n+                0,\n+                Arrays.asList(\n+                    \"CRaC engine option: 'args' = 'simengine ignores this'\",\n+                    \"CRaC engine option: 'args' = 'another arg'\",\n+                    \"CRaC engine option: 'keep_running' = 'true'\",\n+                    \"CRaC engine option: 'args' = 'and another'\",\n+                    \"CRaC engine option: 'args' = 'this is also ignored'\",\n+                    \"CRaC engine option 'args' specified multiple times\"\n+                ),\n+                Collections.emptyList());\n+\n+        test(\"simengine\",\n+                Arrays.asList(\"args=--arg1 --arg2\", \"--arg3\"),\n+                1,\n+                Arrays.asList(\n+                    \"CRaC engine option: 'args' = '--arg1 --arg2'\",\n+                    \"unknown configure option: --arg3\",\n+                    \"CRaC engine failed to configure: '--arg3' = ''\"\n+                ),\n+                Arrays.asList(\"specified multiple times\"));\n+    }\n+\n+    @Test\n+    public void test_options_help() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-XX:CRaCEngineOptions=help\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+        out.stdoutShouldContain(\"Configuration options:\");\n+        out.stderrShouldBeEmpty();\n+        out.shouldNotContain(\"CRaC engine option:\");\n+    }\n+\n+    private void test(String engine) throws Exception {\n+        test(engine, Collections.emptyList(), 0, Collections.emptyList(), Collections.emptyList());\n+    }\n+\n+    private void test(String engine, String opts) throws Exception {\n+        test(engine, opts != null ? Arrays.asList(opts) : Collections.emptyList(),\n+            0, Collections.emptyList(), Collections.emptyList());\n+    }\n+\n+    private void test(String engine, String opts, int expectedExitValue,\n+            String... expectedTexts) throws Exception {\n+        test(engine, opts != null ? Arrays.asList(opts) : Collections.emptyList(),\n+                expectedExitValue, Arrays.asList(expectedTexts), Collections.emptyList());\n+    }\n+\n+    private void test(String engine, List<String> opts, int expectedExitValue,\n+            List<String> expectedTexts, List<String> notExpectedTexts) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-XX:CRaCCheckpointTo=cr\",\n+                \"-XX:CRaCEngine=\" + engine,\n+                \"-Xlog:crac=debug\",\n+                \"-version\");\n+        for (String opt : opts) {\n+            pb.command().add(pb.command().size() - 2, \"-XX:CRaCEngineOptions=\" + opt);\n+        }\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(expectedExitValue);\n+        for (String text : expectedTexts) {\n+            out.shouldContain(text);\n+        }\n+        for (String text : notExpectedTexts) {\n+            out.shouldNotContain(text);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/CracEngineOptionsTest.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-import jdk.crac.*;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.channels.Pipe;\n-import java.nio.file.*;\n-import java.util.Objects;\n-import java.util.concurrent.TimeUnit;\n-\n-\/**\n- * @test CracOptionTest\n- * @library \/test\/lib\n- * @build CracOptionTest\n- * @run driver jdk.test.lib.crac.CracTest\n- * @requires (os.family == \"linux\")\n- *\/\n-\n-public class CracOptionTest implements CracTest {\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder();\n-        builder.javaOption(\"k\",\"v\");\n-        builder.doCheckpointAndRestore();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        Core.checkpointRestore();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/CracOptionTest.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- import org.junit.Test;\n-\n- import jdk.test.lib.process.OutputAnalyzer;\n- import jdk.test.lib.process.ProcessTools;\n- \/*\n-  * @test CracVersionTest\n-  * @library \/test\/lib\n-  * @build CracVersionTest\n-  * @run junit\/othervm CracVersionTest\n-  *\/\n- public class CracVersionTest {\n-     @Test\n-     public void test_default() throws Exception {\n-         ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                 \"-XX:CRaCCheckpointTo=cr\",\n-                 \"-version\");\n-         OutputAnalyzer out = new OutputAnalyzer(pb.start());\n-         out.shouldHaveExitValue(0);\n-     }\n-\n-     private final String UNKNOWN_ENGINE = \"unknown\";\n-\n-     @Test\n-     public void test_fail() throws Exception {\n-         ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                 \"-XX:CRaCCheckpointTo=cr\",\n-                 \"-XX:CRaCEngine=\" + UNKNOWN_ENGINE,\n-                 \"-version\");\n-         OutputAnalyzer out = new OutputAnalyzer(pb.start());\n-         out.shouldHaveExitValue(1);\n-         if (System.getProperty(\"os.name\").contains(\"Windows\")) {\n-            out.shouldContain(UNKNOWN_ENGINE + \".exe:\");\n-         } else {\n-            out.shouldContain(UNKNOWN_ENGINE + \":\");\n-         }\n-     }\n- }\n","filename":"test\/jdk\/jdk\/crac\/CracVersionTest.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+\n@@ -27,0 +28,1 @@\n+import jdk.test.lib.Utils;\n@@ -28,1 +30,0 @@\n-import jdk.test.lib.crac.CracEngine;\n@@ -32,0 +33,1 @@\n+import java.nio.file.Path;\n@@ -33,1 +35,1 @@\n-import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.*;\n@@ -43,0 +45,2 @@\n+    private static final String LOG_FILE_NAME = \"custom-log-file.log\";\n+\n@@ -45,0 +49,2 @@\n+        final String enginePath = Path.of(Utils.TEST_JDK, \"lib\", \"criuengine\").toString();\n+\n@@ -46,2 +52,3 @@\n-        \/\/ this is here just to test passing CRaCEngine params\n-        builder.engine(CracEngine.CRIU, \"--verbosity=4\", \"--log-file=\/dev\/null\");\n+\n+        builder.vmOption(\"-XX:CRaCEngine=criuengine\");\n+        builder.vmOption(\"-XX:CRaCEngineOptions=args=-o \" + LOG_FILE_NAME);\n@@ -50,0 +57,5 @@\n+\n+        \/\/ Checking whether CRaCEngineOptions had an effect\n+        final Path logFilePath = Path.of(\"cr\", LOG_FILE_NAME);\n+        assertTrue(logFilePath.toFile().exists(), logFilePath.toAbsolutePath() + \" must exist\");\n+\n@@ -51,2 +63,4 @@\n-        builder.vmOption(\"-XX:CRaCCheckpointTo=another\"); \/\/ manageable\n-        builder.vmOption(\"-XX:CRaCIgnoredFileDescriptors=42,43\"); \/\/ restore_settable\n+        builder.vmOption(\"-XX:CRaCEngine=\" + enginePath);\n+        builder.vmOption(\"-XX:CRaCEngineOptions=args=-v2\");\n+        builder.vmOption(\"-XX:CRaCCheckpointTo=another\");\n+        builder.vmOption(\"-XX:CRaCIgnoredFileDescriptors=42,43\");\n@@ -54,0 +68,1 @@\n+\n@@ -63,0 +78,9 @@\n+\n+            VMOption engine1 = bean.getVMOption(\"CRaCEngine\");\n+            assertEquals(\"criuengine\", engine1.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engine1.getOrigin());\n+\n+            VMOption engineOptions1 = bean.getVMOption(\"CRaCEngineOptions\");\n+            assertEquals(\"args=-o \" + LOG_FILE_NAME, engineOptions1.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engineOptions1.getOrigin());\n+\n@@ -66,0 +90,5 @@\n+\n+            VMOption restoreFrom1 = bean.getVMOption(\"CRaCRestoreFrom\");\n+            assertEquals(\"\", restoreFrom1.getValue());\n+            assertEquals(VMOption.Origin.DEFAULT, restoreFrom1.getOrigin());\n+\n@@ -75,0 +104,13 @@\n+\n+            \/\/ Should not change\n+\n+            VMOption engine2 = bean.getVMOption(\"CRaCEngine\");\n+            assertEquals(\"criuengine\", engine2.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engine2.getOrigin());\n+\n+            VMOption engineOptions2 = bean.getVMOption(\"CRaCEngineOptions\");\n+            assertEquals(\"args=-o \" + LOG_FILE_NAME, engineOptions2.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engineOptions2.getOrigin());\n+\n+            \/\/ Should change\n+\n@@ -78,0 +120,5 @@\n+\n+            VMOption restoreFrom2 = bean.getVMOption(\"CRaCRestoreFrom\");\n+            assertEquals(\"cr\", restoreFrom2.getValue());\n+            assertEquals(VMOption.Origin.OTHER, restoreFrom2.getOrigin());\n+\n@@ -81,0 +128,1 @@\n+\n","filename":"test\/jdk\/jdk\/crac\/VMOptionsTest.java","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                exception = new RuntimeException(\"Restore ERROR \" + e);\n+                exception = new RuntimeException(\"Restore ERROR\", e);\n@@ -104,1 +104,1 @@\n-                exception = new RuntimeException(\"Restore ERROR \" + e);\n+                exception = new RuntimeException(\"Restore ERROR\", e);\n@@ -124,1 +124,1 @@\n-            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+            throw new RuntimeException(\"Checkpoint ERROR\", e);\n@@ -126,1 +126,1 @@\n-            throw new RuntimeException(\"Restore ERROR \" + e);\n+            throw new RuntimeException(\"Restore ERROR\", e);\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    String[] engineArgs;\n+    String[] engineOptions;\n@@ -94,1 +94,1 @@\n-        other.engineArgs = engineArgs == null ? null : Arrays.copyOf(engineArgs, engineArgs.length);\n+        other.engineOptions = engineOptions == null ? null : Arrays.copyOf(engineOptions, engineOptions.length);\n@@ -143,2 +143,2 @@\n-    public CracBuilder engine(CracEngine engine, String... args) {\n-        assertTrue(this.engine == null || this.engine.equals(engine)); \/\/ allow overwriting args\n+    public CracBuilder engine(CracEngine engine) {\n+        assertTrue(this.engine == null || this.engine.equals(engine));\n@@ -146,1 +146,5 @@\n-        this.engineArgs = args;\n+        return this;\n+    }\n+\n+    public CracBuilder engineOptions(String... options) {\n+        this.engineOptions = options;\n@@ -487,5 +491,4 @@\n-            String engArgs = engineArgs == null || engineArgs.length == 0 ? \"\" :\n-                    \",\" + Arrays.stream(engineArgs)\n-                            .map(str -> str.replace(\",\", \"\\\\,\"))\n-                            .collect(Collectors.joining(\",\"));\n-            cmd.add(\"-XX:CRaCEngine=\" + engine.engine + engArgs);\n+            cmd.add(\"-XX:CRaCEngine=\" + engine.engine);\n+        }\n+        if (engineOptions != null) {\n+            cmd.add(\"-XX:CRaCEngineOptions=\" + String.join(\",\", engineOptions));\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"}]}