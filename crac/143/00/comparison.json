{"files":[{"patch":"@@ -827,0 +827,8 @@\n+    case EXT_EVENT_CRAC_BEFORE_CHECKPOINT :\n+      ext_callbacks->CracBeforeCheckpoint = callback;\n+      env->env_event_enable()->set_user_enabled(event_type, enabling);\n+      break;\n+    case EXT_EVENT_CRAC_AFTER_RESTORE :\n+      ext_callbacks->CracAfterRestore = callback;\n+      env->env_event_enable()->set_user_enabled(event_type, enabling);\n+      break;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+  EXT_EVENT_CRAC_AFTER_RESTORE = JVMTI_MIN_EVENT_TYPE_VAL-5,\n+  EXT_EVENT_CRAC_BEFORE_CHECKPOINT = JVMTI_MIN_EVENT_TYPE_VAL-4,\n@@ -50,1 +52,1 @@\n-  EXT_MIN_EVENT_TYPE_VAL = EXT_EVENT_VIRTUAL_THREAD_UNMOUNT,\n+  EXT_MIN_EVENT_TYPE_VAL = EXT_EVENT_CRAC_AFTER_RESTORE,\n@@ -58,0 +60,2 @@\n+  jvmtiExtensionEvent CracBeforeCheckpoint;\n+  jvmtiExtensionEvent CracAfterRestore;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3194,0 +3194,36 @@\n+\n+void JvmtiExport::post_crac_before_checkpoint() {\n+  JavaThread *thread = JavaThread::current();\n+  HandleMark hm(thread);\n+  EVT_TRIG_TRACE(EXT_EVENT_CRAC_BEFORE_CHECKPOINT, (\"Trg CRaC Before Checkpoint event triggered\"));\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n+    if (env->is_enabled((jvmtiEvent)EXT_EVENT_CRAC_BEFORE_CHECKPOINT)) {\n+      EVT_TRACE(EXT_EVENT_CRAC_BEFORE_CHECKPOINT, (\"[?] Evt Before Checkpoint sent\"));\n+      JvmtiEventMark jem(thread);\n+      JvmtiJavaThreadEventTransition jet(thread);\n+      jvmtiExtensionEvent callback = env->ext_callbacks()->CracBeforeCheckpoint;\n+      if (callback != nullptr) {\n+        (*callback)(env->jvmti_external());\n+      }\n+    }\n+  }\n+}\n+\n+void JvmtiExport::post_crac_after_restore() {\n+  JavaThread *thread = JavaThread::current();\n+  HandleMark hm(thread);\n+  EVT_TRIG_TRACE(EXT_EVENT_CRAC_AFTER_RESTORE, (\"Trg CRaC After Restore event triggered\"));\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n+    if (env->is_enabled((jvmtiEvent)EXT_EVENT_CRAC_AFTER_RESTORE)) {\n+      EVT_TRACE(EXT_EVENT_CRAC_AFTER_RESTORE, (\"[?] Evt After Restore sent\"));\n+      JvmtiEventMark jem(thread);\n+      JvmtiJavaThreadEventTransition jet(thread);\n+      jvmtiExtensionEvent callback = env->ext_callbacks()->CracAfterRestore;\n+      if (callback != nullptr) {\n+        (*callback)(env->jvmti_external());\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -350,0 +350,3 @@\n+  static void post_crac_before_checkpoint() NOT_JVMTI_RETURN;\n+  static void post_crac_after_restore() NOT_JVMTI_RETURN;\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -238,0 +238,6 @@\n+  static jvmtiParamInfo crac_before_checkpoint_params[] = {\n+    { (char*)\"JNI Environment\", JVMTI_KIND_IN_PTR, JVMTI_TYPE_JNIENV, JNI_FALSE }\n+  };\n+  static jvmtiParamInfo crac_after_restore_params[] = {\n+    { (char*)\"JNI Environment\", JVMTI_KIND_IN_PTR, JVMTI_TYPE_JNIENV, JNI_FALSE }\n+  };\n@@ -260,0 +266,14 @@\n+  static jvmtiExtensionEventInfo crac_before_checkpoint_ext_event = {\n+    EXT_EVENT_CRAC_BEFORE_CHECKPOINT,\n+    (char*)\"jdk.crac.events.BeforeCheckpoint\",\n+    (char*)\"CRAC_BEFORE_CHECKPOINT event\",\n+    sizeof(crac_before_checkpoint_params)\/sizeof(crac_before_checkpoint_params[0]),\n+    crac_before_checkpoint_params\n+  };\n+  static jvmtiExtensionEventInfo crac_after_restore_ext_event = {\n+    EXT_EVENT_CRAC_AFTER_RESTORE,\n+    (char*)\"jdk.crac.events.AfterRestore\",\n+    (char*)\"CRAC_AFTER_RESTORE event\",\n+    sizeof(crac_after_restore_params)\/sizeof(crac_after_restore_params[0]),\n+    crac_after_restore_params\n+  };\n@@ -264,0 +284,2 @@\n+  _ext_events->append(&crac_before_checkpoint_ext_event);\n+  _ext_events->append(&crac_after_restore_ext_event);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-      return (num != EXT_EVENT_CLASS_UNLOAD);\n+      return (num != EXT_EVENT_CLASS_UNLOAD && num != EXT_EVENT_CRAC_BEFORE_CHECKPOINT && num != EXT_EVENT_CRAC_AFTER_RESTORE);\n","filename":"src\/hotspot\/share\/prims\/jvmtiUtil.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -428,0 +429,4 @@\n+#if INCLUDE_JVMTI\n+  JvmtiExport::post_crac_before_checkpoint();\n+#endif\n+\n@@ -445,0 +450,4 @@\n+#if INCLUDE_JVMTI\n+  JvmtiExport::post_crac_after_restore();\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+ \/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build JvmtiEventTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+\n+public class JvmtiEventTest implements CracTest {\n+\n+    private static final String JAVA_LIBRARY_PATH = System.getProperty(\"java.library.path\");\n+    private static final String AGENT_CALLBACK_BEFORE_CHECKPOINT = \"callbackBeforeCheckpoint\";\n+    private static final String AGENT_CALLBACK_AFTER_RESTORE = \"callbackAfterRestore\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.vmOption(\"-agentpath:\" + JAVA_LIBRARY_PATH + File.separator + \"libCracJvmtiAgent.so\");\n+\n+        \/\/ Start and checkpoint\n+        CracProcess process = builder.captureOutput(true).startCheckpoint();\n+        process.waitForCheckpointed();\n+        process.outputAnalyzer().shouldContain(AGENT_CALLBACK_BEFORE_CHECKPOINT);\n+\n+        \/\/ Restore\n+        builder.captureOutput(true).doRestore().waitForSuccess()\n+                .outputAnalyzer()\n+                .shouldContain(RESTORED_MESSAGE)\n+                .shouldContain(AGENT_CALLBACK_AFTER_RESTORE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(\"Started\");\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/jvmtiEvents\/JvmtiEventTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jvmti.h>\n+\n+#include <string.h>\n+\n+void JNICALL callbackBeforeCheckpoint(jvmtiEnv* jvmti_env, ...) {\n+    printf(\"%s:%d : %s\\n\", __FILE__, __LINE__, __FUNCTION__);\n+    fflush(NULL);\n+}\n+\n+void JNICALL callbackAfterRestore(jvmtiEnv* jvmti_env, ...) {\n+    printf(\"%s:%d : %s\\n\", __FILE__, __LINE__, __FUNCTION__);\n+    fflush(NULL);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+    printf(\"%s:%d : %s : JVMTI agent loading...\\n\", __FILE__, __LINE__, __FUNCTION__);\n+\n+    jvmtiEnv* jvmti = NULL;\n+    jint extensionEventCount = 0;\n+    jvmtiExtensionEventInfo* extensionEvents = NULL;\n+    (*jvm)->GetEnv(jvm, (void**)&jvmti, JVMTI_VERSION_1_0);\n+    (*jvmti)->GetExtensionEvents(jvmti, &extensionEventCount, &extensionEvents);\n+\n+    for (int i = 0; i < extensionEventCount; ++i) {\n+        if (0 == strcmp(\"jdk.crac.events.BeforeCheckpoint\", extensionEvents[i].id)) {\n+            (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents[i].extension_event_index, &callbackBeforeCheckpoint);\n+        }\n+        if (0 == strcmp(\"jdk.crac.events.AfterRestore\", extensionEvents[i].id)) {\n+            (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents[i].extension_event_index, &callbackAfterRestore);\n+        }\n+    }\n+\n+    return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL Agent_OnUnload(JavaVM* jvm) {\n+    printf(\"%s:%d : %s : JVMTI agent unloading...\\n\", __FILE__, __LINE__, __FUNCTION__);\n+}\n","filename":"test\/jdk\/jdk\/crac\/jvmtiEvents\/libCracJvmtiAgent.c","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}