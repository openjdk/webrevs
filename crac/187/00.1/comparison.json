{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -100,0 +101,1 @@\n+static jlong restore_time_count = 0;\n@@ -869,0 +871,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -891,0 +897,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1356,0 +1370,4 @@\n+  initialize_time_counters();\n+}\n+\n+void os::Posix::initialize_time_counters(void) {\n@@ -1357,0 +1375,5 @@\n+  restore_time_count = initial_time_count;\n+}\n+\n+void os::Posix::reset_time_counters(void) {\n+  restore_time_count = javaTimeNanos();\n@@ -1510,1 +1533,1 @@\n-  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec);\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + crac::monotonic_time_offset();\n@@ -1539,0 +1562,4 @@\n+jlong os::elapsed_counter_since_restore() {\n+  return os::javaTimeNanos() - restore_time_count;\n+}\n+\n@@ -2063,0 +2090,30 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  char** env = os::get_environ();\n+\n+  pid_t pid = fork();\n+  if (pid == -1) {\n+    perror(\"cannot fork for subprocess\");\n+    return -1;\n+  }\n+  if (pid == 0) {\n+    execve(path, (char* const*)argv, env);\n+    perror(\"execve\");\n+    exit(1);\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return -1;\n+  }\n+  return WEXITSTATUS(status) == 0 ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return ::execv(path, (char * const *)argv);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n@@ -1548,0 +1548,7 @@\n+\n+  sigemptyset(&blocked_sigs);\n+\/\/ RESTORE_SIGNAL is used only on Linux, other platform don't send this\n+#ifdef LINUX\n+  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+#endif\n+\n@@ -1558,0 +1565,5 @@\n+static sigset_t* blocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &blocked_sigs;\n+}\n+\n@@ -1575,0 +1587,1 @@\n+  pthread_sigmask(SIG_BLOCK, blocked_signals(), nullptr);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -804,0 +805,1 @@\n+static jlong restore_performance_count;\n@@ -811,1 +813,0 @@\n-\n@@ -816,0 +817,5 @@\n+jlong os::elapsed_counter_since_restore() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceCounter(&count);\n+  return count.QuadPart - restore_performance_count;\n+}\n@@ -1095,0 +1101,1 @@\n+  restore_performance_count = initial_performance_count;\n@@ -1097,0 +1104,9 @@\n+void os::win32::reset_performance_counters() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceFrequency(&count);\n+  \/\/ Until we perform a real C\/R on Windows this is safe, performance frequency\n+  \/\/ should be the same. With real C\/R the counters will be probably incomparable.\n+  assert(performance_frequency == count.QuadPart, \"Performance frequency changed\");\n+  QueryPerformanceCounter(&count);\n+  restore_performance_count = count.QuadPart;\n+}\n@@ -1532,0 +1548,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -4684,0 +4727,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5687,0 +5755,9 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  const int status = _spawnv(_P_WAIT, path, argv); \/\/ env is inherited by a child process\n+  return 0 == status ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return _execv(path, argv);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":78,"deletions":1,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -742,0 +742,4 @@\n+  template(jdk_internal_crac_mirror_Core,          \"jdk\/internal\/crac\/mirror\/Core\")                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+  template(checkpointRestoreInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -979,0 +980,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1133,0 +1141,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2024, Azul Systems, Inc. All rights reserved.\n@@ -54,0 +55,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -559,0 +561,9 @@\n+  { \"CREngine\",                     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowedOpenFilePrefixes\",    JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowToSkipCheckpoint\",      JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRHeapDumpOnCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPrintResourcesOnCheckpoint\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTraceStartupTime\",           JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRDoThrowCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPauseOnCheckpointError\",     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+\n@@ -570,0 +581,8 @@\n+  { \"CREngine\",                        \"CRaCEngine\" },\n+  { \"CRAllowedOpenFilePrefixes\",       \"CRaCAllowedOpenFilePrefixes\" },\n+  { \"CRAllowToSkipCheckpoint\",         \"CRaCAllowToSkipCheckpoint \"},\n+  { \"CRHeapDumpOnCheckpointException\", \"CRaCHeapDumpOnCheckpointException\" },\n+  { \"CRPrintResourcesOnCheckpoint\",    \"CRaCPrintResourcesOnCheckpoint\" },\n+  { \"CRTraceStartupTime\",              \"CRaCTraceStartupTime\" },\n+  { \"CRDoThrowCheckpointException\",    \"CRaCDoThrowCheckpointException\" },\n+  { \"CRPauseOnCheckpointError\",        \"CRaCPauseOnCheckpointError\" },\n@@ -1097,0 +1116,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == NULL) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1106,4 +1138,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1111,6 +1140,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == nullptr) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1247,1 +1272,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1249,2 +1276,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1254,1 +1279,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1262,1 +1288,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1264,1 +1290,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1266,0 +1292,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2142,0 +2175,65 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = NULL;\n+      const char* value = NULL;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.command\") == 0) {\n+        char *old_java_command = _java_command;\n+        _java_command = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != NULL) {\n+          os::free(old_java_command);\n+        }\n+      } else {\n+        add_property(tail);\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n+      \/\/ already been handled\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != NULL) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n+          return false;\n+        }\n+        build_jvm_flags(tail);\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2904,0 +3002,7 @@\n+  if (CRaCCheckpointTo && UseZGC) {\n+    \/\/ jdk.crac.impl.CheckpointOpenFileException: FD fd=3 type=regular path=\/memfd:java_heap (deleted)\n+    jio_fprintf(defaultStream::output_stream(),\n+      \"-XX:+UseZGC is currently unsupported for -XX:CRaCCheckpointTo.\\n\");\n+    return JNI_ERR;\n+  }\n+\n@@ -2961,0 +3066,4 @@\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n@@ -3972,0 +4081,7 @@\n+\n+void Arguments::reset_for_crac_restore() {\n+  if (!FLAG_IS_DEFAULT(LogVMOutput)){\n+    FLAG_SET_DEFAULT(LogVMOutput, false);\n+    FLAG_SET_DEFAULT(LogFile, nullptr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":132,"deletions":16,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -283,0 +283,4 @@\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n+\n@@ -452,0 +456,2 @@\n+  \/\/ Reset LogVMoutput to default values\n+  static void reset_for_crac_restore();\n@@ -516,0 +522,4 @@\n+  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -293,0 +293,2 @@\n+  \/\/ Before restore returns the same value as elapsed_counter()\n+  static jlong elapsed_counter_since_restore();\n@@ -479,0 +481,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n@@ -638,0 +642,4 @@\n+  static int exec_child_process_and_wait(const char *path, const char *argv[]);\n+\n+  static int execv(const char *path, const char *argv[]);\n+\n@@ -697,0 +705,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -700,0 +711,2 @@\n+  static bool           is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -428,0 +429,15 @@\n+static jint check_for_restore(JavaVMInitArgs* args, crac::crac_restore_data& restore_data) {\n+  if (Arguments::is_restore_option_set(args)) {\n+    if (!Arguments::parse_options_for_restore(args)) {\n+      return JNI_ERR;\n+    }\n+    crac::restore(restore_data);\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -431,0 +447,8 @@\n+#ifdef __APPLE__\n+  \/\/ BSD clock would be initialized in os::init() but we need to do that earlier\n+  \/\/ as crac::prepare_restore() calls os::javaTimeNanos().\n+  os::Bsd::clock_init();\n+#endif\n+  crac::crac_restore_data restore_data;\n+  crac::prepare_restore(restore_data);\n+\n@@ -461,0 +485,4 @@\n+  \/\/ Output stream module should be already initialized for error reporting during restore.\n+  \/\/ JDK version should also be intialized for arguments parsing.\n+  if (check_for_restore(args, restore_data) != JNI_OK) return JNI_ERR;\n+\n@@ -495,0 +523,2 @@\n+  crac::vm_create_start();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2483,0 +2483,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -361,0 +361,5 @@\n+     * @crac When the process is restored on another machine or if the machine\n+     * rebooted the value is updated based on wall-clock time difference,\n+     * resulting in a loss of accuracy when comparing timestamps obtained\n+     * before and after checkpoint.\n+     *\n@@ -616,0 +621,6 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload system properties in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -650,0 +661,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -709,0 +721,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -730,0 +745,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -830,0 +848,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -837,0 +861,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -866,0 +891,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload the environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -871,0 +902,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -59,0 +61,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -232,0 +236,6 @@\n+ * @crac This class holds a cache of resolved hostname-address pairs;\n+ * this cache is wiped out before checkpoint. Therefore, lookups after restore\n+ * will cause name address resolution.\n+ * This ensures that the addresses are up-to-date in the environment where\n+ * the process is restored.\n+ *\n@@ -350,0 +360,3 @@\n+    \/* Resource registration uses weak references; we need to keep it locally. *\/\n+    private static final JDKResource checkpointListener;\n+\n@@ -386,0 +399,14 @@\n+        \/\/ DNS cache is cleared before the checkpoint; application restored at a later point\n+        \/\/ or in a different environment should query DNS again.\n+        checkpointListener = new JDKResource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                cache.clear();\n+                expirySet.clear();\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            }\n+        };\n+        Core.Priority.NORMAL.getContext().register(checkpointListener);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-\n@@ -180,0 +179,4 @@\n+    exports jdk.internal.crac to\n+        java.rmi,\n+        jdk.management.agent,\n+        jdk.sctp;\n@@ -420,0 +423,7 @@\n+    exports jdk.internal.crac.mirror to\n+        java.rmi,\n+        jdk.crac,\n+        jdk.management.agent;\n+\n+    exports jdk.internal.crac.mirror.impl to\n+        jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -104,0 +105,1 @@\n+    private final JDKSocketResource resource = new Resource();\n@@ -1964,0 +1966,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(DatagramChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -128,0 +129,5 @@\n+    static {\n+        \/\/ trigger eager initialization\n+        new FileDispatcherImpl();\n+    }\n+\n@@ -1200,1 +1206,1 @@\n-    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+    private static Runnable closerFor0(FileDescriptor fd, boolean stream) {\n@@ -1220,0 +1226,14 @@\n+    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+\n+        \/\/ FIXME ensure FileDispatcherImpl's Resource is registered before the closer is used,\n+        \/\/ otherwise the closer during beforeCheckpoint may be the first one to access\n+        \/\/ FileDescriptor, and then Dispatcher Resource will be blocked for registration.\n+        try {\n+            MethodHandles.lookup().ensureInitialized(FileDispatcherImpl.class);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        return closerFor0(fd, stream);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1075,0 +1075,15 @@\n+`-XX:CRaCCheckpointTo=`*directory*\n+:   The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+    a running Java program into an image directory. Restoring from the image should\n+    solve some of the problematic start-up and warm-up times.\n+\n+    This option defines a path to the snapshot which is currently a directory. The\n+    directory will be created if it does not exist, but no parent directories are\n+    created.\n+\n+`-XX:CRaCRestoreFrom=`*directory*\n+:   Restores a snapshot created by `-XX:CRaCCheckpointTo=`*directory*.\n+\n+`-XX:CRaCMinPid=`*value*\n+:   A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+\n@@ -1818,0 +1833,7 @@\n+`-XX:CPUFeatures=`*0xnumber*\n+:   CPU feature set, use `-XX:CPUFeatures=`*0xnumber* with `-XX:CRaCCheckpointTo` when\n+    you get an error during `-XX:CRaCRestoreFrom` on a different machine.\n+    `-XX:CPUFeatures=native` is the default.\n+    `-XX:CPUFeatures=generic` is compatible with any CPU but not as slow\n+    as `-XX:CPUFeatures=0`.\n+\n@@ -1985,0 +2007,4 @@\n+`-XX:+ShowCPUFeatures`\n+:   Show features of this CPU to be possibly used for the\n+    `-XX:CPUFeatures=`*0xnumber* option.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -53,0 +53,5 @@\n+\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -258,0 +263,1 @@\n+    private static JMXConnectorServer localServer = null;\n@@ -260,0 +266,1 @@\n+    private static JDKResource cracResource;\n@@ -316,2 +323,2 @@\n-            JMXConnectorServer cs = ConnectorBootstrap.startLocalConnectorServer();\n-            String address = cs.getAddress().toString();\n+            localServer = ConnectorBootstrap.startLocalConnectorServer();\n+            String address = localServer.getAddress().toString();\n@@ -332,0 +339,14 @@\n+    private static synchronized void stopLocalManagementAgent() throws IOException {\n+        Properties agentProps = VMSupport.getAgentProperties();\n+        agentProps.remove(LOCAL_CONNECTOR_ADDRESS_PROP);\n+        try {\n+            localServer.stop();\n+            localServer = null;\n+        } catch (IOException e) {\n+            warning(CONNECTOR_SERVER_IO_ERROR, e.getMessage());\n+            \/\/ rethrowing to fail the checkpoint\n+            throw e;\n+        }\n+        ConnectorAddressLink.unexportLocal();\n+    }\n+\n@@ -443,1 +464,1 @@\n-                if (jmxremotePort != null) {\n+                if (jmxremotePort != null && jmxServer == null) {\n@@ -450,0 +471,17 @@\n+            if (cracResource == null) {\n+                cracResource = new JDKResource() {\n+                    @Override\n+                    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                        stopRemoteManagementAgent();\n+                        stopLocalManagementAgent();\n+                        \/\/ reload properties after restore\n+                        mgmtProps = null;\n+                    }\n+\n+                    @Override\n+                    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                        startAgent();\n+                    }\n+                };\n+                Core.Priority.NORMAL.getContext().register(cracResource);\n+            }\n","filename":"src\/jdk.management.agent\/share\/classes\/jdk\/internal\/agent\/Agent.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.crac.management.CRaCMXBean;\n@@ -43,0 +44,2 @@\n+\n+import jdk.crac.management.internal.CRaCImpl;\n@@ -55,0 +58,5 @@\n+    \/\/ CRaC\n+    private static CRaCMXBean cracMXBean = null;\n+    public static final String CRAC_MXBEAN_NAME =\n+        \"jdk.management:type=CRaC\";\n+\n@@ -298,0 +306,30 @@\n+        \/**\n+         * CRaC MXBean\n+         *\/\n+        initMBeanList.add(new PlatformComponent<CRaCMXBean>() {\n+            private final Set<String> cracMXBeanInterfaceNames =\n+                Collections.singleton(\"jdk.crac.management.CRaCMXBean\");\n+\n+            @Override\n+            public Set<Class<? extends CRaCMXBean>> mbeanInterfaces() {\n+                return Collections.singleton(CRaCMXBean.class);\n+            }\n+\n+            @Override\n+            public Set<String> mbeanInterfaceNames() {\n+                return cracMXBeanInterfaceNames;\n+            }\n+\n+            @Override\n+            public String getObjectNamePattern() {\n+                return CRAC_MXBEAN_NAME;\n+            }\n+\n+            @Override\n+            public Map<String, CRaCMXBean> nameToMBeanMap() {\n+                return Collections.<String, CRaCMXBean>singletonMap(\n+                    CRAC_MXBEAN_NAME,\n+                    getCRaCMXBean());\n+            }\n+        });\n+\n@@ -315,0 +353,7 @@\n+\n+    private static synchronized CRaCMXBean getCRaCMXBean() {\n+        if (cracMXBean == null) {\n+            cracMXBean = new CRaCImpl(ManagementFactoryHelper.getVMManagement());\n+        }\n+        return cracMXBean;\n+    }\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+# JDK-8310862 was closed but we're still seeing errors with the updated test\n+runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8310862 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}