{"files":[{"patch":"@@ -2171,1 +2171,1 @@\n-void os::abort(bool dump_core, void* siginfo, const void* context) {\n+void os::abort(bool dump_core, const void* siginfo, const void* context) {\n@@ -2246,0 +2246,40 @@\n+\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+static ucontext_t _saved_assert_context;\n+static bool _has_saved_context = false;\n+#endif \/\/ CAN_SHOW_REGISTERS_ON_ASSERT\n+\n+void os::save_assert_context(const void* ucVoid) {\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  assert(ucVoid != nullptr, \"invariant\");\n+  assert(!_has_saved_context, \"invariant\");\n+  memcpy(&_saved_assert_context, ucVoid, sizeof(ucontext_t));\n+  \/\/ on Linux ppc64, ucontext_t contains pointers into itself which have to be patched up\n+  \/\/  after copying the context (see comment in sys\/ucontext.h):\n+#if defined(PPC64)\n+  *((void**)&_saved_assert_context.uc_mcontext.regs) = &(_saved_assert_context.uc_mcontext.gp_regs);\n+#elif defined(AMD64)\n+  \/\/ In the copied version, fpregs should point to the copied contents.\n+  \/\/ Sanity check: fpregs should point into the context.\n+  if ((address)((const ucontext_t*)ucVoid)->uc_mcontext.fpregs > (address)ucVoid) {\n+    size_t fpregs_offset = pointer_delta(((const ucontext_t*)ucVoid)->uc_mcontext.fpregs, ucVoid, 1);\n+    if (fpregs_offset < sizeof(ucontext_t)) {\n+      \/\/ Preserve the offset.\n+      *((void**)&_saved_assert_context.uc_mcontext.fpregs) = (void*)((address)(void*)&_saved_assert_context + fpregs_offset);\n+    }\n+  }\n+#endif\n+  _has_saved_context = true;\n+#endif \/\/ CAN_SHOW_REGISTERS_ON_ASSERT\n+}\n+\n+const void* os::get_saved_assert_context(const void** sigInfo) {\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  assert(sigInfo != nullptr, \"invariant\");\n+  *sigInfo = nullptr;\n+  return _has_saved_context ? &_saved_assert_context : nullptr;\n+#endif\n+  *sigInfo = nullptr;\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -581,3 +581,2 @@\n-  if (!signal_was_handled &&\n-      ((sig == SIGSEGV || sig == SIGBUS) && info != nullptr && info->si_addr == g_assert_poison)) {\n-    signal_was_handled = handle_assert_poison_fault(ucVoid, info->si_addr);\n+  if (VMError::was_assert_poison_crash(info)) {\n+    signal_was_handled = handle_assert_poison_fault(ucVoid);\n@@ -1139,0 +1138,8 @@\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  \/\/ If we are here because of an assert\/guarantee, we suppress\n+  \/\/ printing the siginfo, because it is only an implementation\n+  \/\/ detail capturing the context for said assert\/guarantee.\n+  if (VMError::was_assert_poison_crash(si0)) {\n+    return;\n+  }\n+#endif\n@@ -1140,1 +1147,1 @@\n-  const siginfo_t* const si = (const siginfo_t*) si0;\n+  const siginfo_t* const si = (const siginfo_t*)si0;\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -1336,1 +1337,1 @@\n-void os::abort(bool dump_core, void* siginfo, const void* context) {\n+void os::abort(bool dump_core, const void* siginfo, const void* context) {\n@@ -2158,0 +2159,9 @@\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  \/\/ If we are here because of an assert\/guarantee, we suppress\n+  \/\/ printing the siginfo, because it is only an implementation\n+  \/\/ detail capturing the context for said assert\/guarantee.\n+  if (VMError::was_assert_poison_crash(siginfo)) {\n+    return;\n+  }\n+#endif\n+\n@@ -2159,0 +2169,1 @@\n+\n@@ -2671,0 +2682,8 @@\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  if (VMError::was_assert_poison_crash(exception_record)) {\n+    if (handle_assert_poison_fault(exceptionInfo)) {\n+      return EXCEPTION_CONTINUE_EXECUTION;\n+    }\n+  }\n+#endif\n+\n@@ -6245,0 +6264,23 @@\n+\n+static CONTEXT _saved_assert_context;\n+static EXCEPTION_RECORD _saved_exception_record;\n+static bool _has_saved_context = false;\n+\n+void os::save_assert_context(const void* ucVoid) {\n+  assert(ucVoid != nullptr, \"invariant\");\n+  assert(!_has_saved_context, \"invariant\");\n+  const EXCEPTION_POINTERS* ep = static_cast<const EXCEPTION_POINTERS*>(ucVoid);\n+  memcpy(&_saved_assert_context, ep->ContextRecord, sizeof(CONTEXT));\n+  memcpy(&_saved_exception_record, ep->ExceptionRecord, sizeof(EXCEPTION_RECORD));\n+  _has_saved_context = true;\n+}\n+\n+const void* os::get_saved_assert_context(const void** sigInfo) {\n+  assert(sigInfo != nullptr, \"invariant\");\n+  if (_has_saved_context) {\n+    *sigInfo = &_saved_exception_record;\n+    return &_saved_assert_context;\n+  }\n+  *sigInfo = nullptr;\n+  return nullptr;\n+}\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -726,0 +726,2 @@\n+  template(getResourceAsByteArray_name,                     \"getResourceAsByteArray\")                             \\\n+  template(getResourceAsByteArray_signature,                \"(Ljava\/lang\/String;)[B\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -366,2 +366,3 @@\n-    HeapWord* src_region_start = region_to_addr(src_region);\n-    HeapWord* new_top = destination - pointer_delta(src_region_start, overflowing_obj);\n+    \/\/ The [overflowing_obj, src_region_start) part has been accounted for, so\n+    \/\/ must move back the new_top, now that this overflowing obj is deferred.\n+    HeapWord* new_top = destination - pointer_delta(region_to_addr(src_region), overflowing_obj);\n@@ -894,1 +895,1 @@\n-    \/\/ Compacting objs inn [dense_prefix_end, old_space->top())\n+    \/\/ Compacting objs in [dense_prefix_end, old_space->top())\n@@ -1614,1 +1615,1 @@\n-          size_t live_words = region_ptr->partial_obj_size();\n+          size_t partial_obj_size = region_ptr->partial_obj_size();\n@@ -1616,1 +1617,1 @@\n-          if (live_words == ParallelCompactData::RegionSize) {\n+          if (partial_obj_size == ParallelCompactData::RegionSize) {\n@@ -1624,1 +1625,0 @@\n-\n@@ -1629,1 +1629,1 @@\n-            forward_objs_in_range(cm, region_start + live_words, split_point, preceding_destination + live_words);\n+            forward_objs_in_range(cm, region_start + partial_obj_size, split_point, preceding_destination + partial_obj_size);\n@@ -1636,1 +1636,1 @@\n-            forward_objs_in_range(cm, region_start + live_words, region_end, destination + live_words);\n+            forward_objs_in_range(cm, region_start + partial_obj_size, region_end, destination + partial_obj_size);\n@@ -2002,5 +2002,5 @@\n-\/\/ On filling a destination region (dest-region), we need to know the location\n-\/\/ of the word that will be at the start of the dest-region after compaction.\n-\/\/ A dest-region can have one or more source regions, but only the first\n-\/\/ source-region contains this location. This location is retrieved by calling\n-\/\/ `first_src_addr` on a dest-region.\n+\/\/ On starting to fill a destination region (dest-region), we need to know the\n+\/\/ location of the word that will be at the start of the dest-region after\n+\/\/ compaction. A dest-region can have one or more source regions, but only the\n+\/\/ first source-region contains this location. This location is retrieved by\n+\/\/ calling `first_src_addr` on a dest-region.\n@@ -2035,3 +2035,3 @@\n-\/\/ Therefore, in this example, region-n will have two dest-regions, one for\n-\/\/ the final region in old-space and the other for the first region in\n-\/\/ eden-space.\n+\/\/ Therefore, in this example, region-n will have two dest-regions:\n+\/\/ 1. the final region in old-space\n+\/\/ 2. the first region in eden-space.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3766,0 +3766,4 @@\n+  return JNI_OK;\n+}\n+\n+void Arguments::set_compact_headers_flags() {\n@@ -3771,3 +3775,0 @@\n-  if (UseCompactObjectHeaders && LockingMode != LM_LIGHTWEIGHT) {\n-    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n-  }\n@@ -3779,1 +3780,1 @@\n-    \/\/ If UseObjectMonitorTable is on the command line, turn off UseCompactObjectHeaders.\n+      \/\/ If UseObjectMonitorTable is on the command line, turn off UseCompactObjectHeaders.\n@@ -3782,1 +3783,1 @@\n-    \/\/ If neither on the command line, the defaults are incompatible, but turn on UseObjectMonitorTable.\n+      \/\/ If neither on the command line, the defaults are incompatible, but turn on UseObjectMonitorTable.\n@@ -3787,0 +3788,3 @@\n+  if (UseCompactObjectHeaders && LockingMode != LM_LIGHTWEIGHT) {\n+    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n+  }\n@@ -3791,2 +3795,0 @@\n-\n-  return JNI_OK;\n@@ -3805,0 +3807,2 @@\n+  set_compact_headers_flags();\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+  static void set_compact_headers_flags();\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -624,0 +624,4 @@\n+  \/\/ For saving an os specific context generated by an assert or guarantee.\n+  static void       save_assert_context(const void* ucVoid);\n+  static const void* get_saved_assert_context(const void** sigInfo);\n+\n@@ -654,1 +658,1 @@\n-  [[noreturn]] static void abort(bool dump_core, void *siginfo, const void *context);\n+  [[noreturn]] static void abort(bool dump_core, const void *siginfo, const void *context);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -530,3 +530,0 @@\n-  \/\/ Initialize object layout after parsing the args\n-  ObjLayout::initialize();\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -662,1 +662,0 @@\n-  nonstatic_field(JavaThread,                  _osthread,                                     OSThread*)                             \\\n@@ -670,0 +669,1 @@\n+  nonstatic_field(Thread,                      _osthread,                                     OSThread*)                             \\\n@@ -1025,1 +1025,6 @@\n-  nonstatic_field(UpcallStub::FrameData,       jfa,                                           JavaFrameAnchor)\n+  nonstatic_field(UpcallStub::FrameData,       jfa,                                           JavaFrameAnchor)                       \\\n+                                                                                                                                     \\\n+  nonstatic_field(Mutex,                       _name,                                         const char*)                           \\\n+  static_field(Mutex,                          _mutex_array,                                  Mutex**)                               \\\n+  static_field(Mutex,                          _num_mutex,                                    int)                                   \\\n+  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)\n@@ -1939,0 +1944,1 @@\n+  declare_toplevel_type(Mutex)                                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.net.URL;\n@@ -50,4 +49,0 @@\n-import java.security.AccessController;\n-import java.security.CodeSource;\n-import java.security.PrivilegedAction;\n-import java.util.Collections;\n@@ -60,1 +55,0 @@\n-import java.util.PropertyPermission;\n@@ -63,1 +57,0 @@\n-import java.util.WeakHashMap;\n@@ -95,1 +88,0 @@\n-import sun.security.util.SecurityConstants;\n@@ -203,1 +195,0 @@\n-        checkIO();\n@@ -215,1 +206,0 @@\n-        checkIO();\n@@ -227,1 +217,0 @@\n-        checkIO();\n@@ -278,8 +267,0 @@\n-    private static void checkIO() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new RuntimePermission(\"setIO\"));\n-        }\n-    }\n-\n@@ -290,14 +271,0 @@\n-    private static class CallersHolder {\n-        \/\/ Remember callers of setSecurityManager() here so that warning\n-        \/\/ is only printed once for each different caller\n-        static final Map<Class<?>, Boolean> callers\n-            = Collections.synchronizedMap(new WeakHashMap<>());\n-    }\n-\n-    static URL codeSource(Class<?> clazz) {\n-        PrivilegedAction<ProtectionDomain> pa = clazz::getProtectionDomain;\n-        @SuppressWarnings(\"removal\")\n-        CodeSource cs = AccessController.doPrivileged(pa).getCodeSource();\n-        return (cs != null) ? cs.getLocation() : null;\n-    }\n-\n@@ -696,6 +663,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPropertiesAccess();\n-        }\n-\n@@ -740,6 +701,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPropertiesAccess();\n-        }\n-\n@@ -780,6 +735,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPropertyAccess(key);\n-        }\n-\n@@ -811,6 +760,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPropertyAccess(key);\n-        }\n-\n@@ -843,7 +786,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new PropertyPermission(key,\n-                SecurityConstants.PROPERTY_WRITE_ACTION));\n-        }\n-\n@@ -874,6 +810,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new PropertyPermission(key, \"write\"));\n-        }\n-\n@@ -933,6 +863,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new RuntimePermission(\"getenv.\"+name));\n-        }\n-\n@@ -980,6 +904,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new RuntimePermission(\"getenv.*\"));\n-        }\n-\n@@ -1411,7 +1329,0 @@\n-        \/**\n-         * The {@code RuntimePermission(\"loggerFinder\")} is\n-         * necessary to subclass and instantiate the {@code LoggerFinder} class,\n-         * as well as to obtain loggers from an instance of that class.\n-         *\/\n-        static final RuntimePermission LOGGERFINDER_PERMISSION =\n-                new RuntimePermission(\"loggerFinder\");\n@@ -1428,14 +1339,0 @@\n-            this(checkPermission());\n-        }\n-\n-        private LoggerFinder(Void unused) {\n-            \/\/ nothing to do.\n-        }\n-\n-        private static Void checkPermission() {\n-            @SuppressWarnings(\"removal\")\n-            final SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkPermission(LOGGERFINDER_PERMISSION);\n-            }\n-            return null;\n@@ -1511,5 +1408,0 @@\n-            @SuppressWarnings(\"removal\")\n-            final SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkPermission(LOGGERFINDER_PERMISSION);\n-            }\n@@ -1528,4 +1420,1 @@\n-                PrivilegedAction<LoggerFinder> pa =\n-                        () -> LoggerFinderLoader.getLoggerFinder();\n-                finder = AccessController.doPrivileged(pa, null,\n-                        LOGGERFINDER_PERMISSION);\n+                finder = LoggerFinderLoader.getLoggerFinder();\n@@ -1637,11 +1526,0 @@\n-        final SecurityManager sm = System.getSecurityManager();\n-        \/\/ We don't use LazyLoggers if a resource bundle is specified.\n-        \/\/ Bootstrap sensitive classes in the JDK do not use resource bundles\n-        \/\/ when logging. This could be revisited later, if it needs to.\n-        if (sm != null) {\n-            final PrivilegedAction<Logger> pa =\n-                    () -> LoggerFinder.accessProvider()\n-                            .getLocalizedLogger(name, rb, caller.getModule());\n-            return AccessController.doPrivileged(pa, null,\n-                                         LoggerFinder.LOGGERFINDER_PERMISSION);\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":1,"deletions":123,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -69,1 +67,0 @@\n-import sun.security.action.*;\n@@ -380,1 +377,1 @@\n-                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv4Stack\");\n+                System.getProperty(\"java.net.preferIPv4Stack\");\n@@ -382,1 +379,1 @@\n-                GetPropertyAction.privilegedGetProperty(\"java.net.preferIPv6Addresses\");\n+                System.getProperty(\"java.net.preferIPv6Addresses\");\n@@ -384,1 +381,1 @@\n-                GetPropertyAction.privilegedGetProperty(\"jdk.net.hosts.file\");\n+                System.getProperty(\"jdk.net.hosts.file\");\n@@ -470,9 +467,0 @@\n-    \/**\n-     * The {@code RuntimePermission(\"inetAddressResolverProvider\")} is\n-     * necessary to subclass and instantiate the {@code InetAddressResolverProvider}\n-     * class, as well as to obtain resolver from an instance of that class,\n-     * and it is also required to obtain the operating system name resolution configurations.\n-     *\/\n-    private static final RuntimePermission INET_ADDRESS_RESOLVER_PERMISSION =\n-            new RuntimePermission(\"inetAddressResolverProvider\");\n-\n@@ -482,1 +470,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -506,4 +493,0 @@\n-                } else if (System.getSecurityManager() != null) {\n-                    PrivilegedAction<InetAddressResolver> pa = InetAddress::loadResolver;\n-                    cns = AccessController.doPrivileged(\n-                            pa, null, INET_ADDRESS_RESOLVER_PERMISSION);\n@@ -767,18 +750,1 @@\n-        return getHostName(true);\n-    }\n-\n-    \/**\n-     * Returns the hostname for this address.\n-     * If the host is equal to null, then this address refers to any\n-     * of the local machine's available network addresses.\n-     * this is package private so SocketPermission can make calls into\n-     * here without a security check.\n-     *\n-     * @return  the host name for this IP address, or if the operation\n-     *    is not allowed by the security check, the textual\n-     *    representation of the IP address.\n-     *\n-     * @param check make security check if true\n-     *\/\n-    String getHostName(boolean check) {\n-            holder().hostName = InetAddress.getHostFromNameService(this, check);\n+            holder().hostName = InetAddress.getHostFromNameService(this);\n@@ -812,1 +778,1 @@\n-                InetAddress.getHostFromNameService(this, true);\n+                InetAddress.getHostFromNameService(this);\n@@ -819,4 +785,1 @@\n-     * @param check make security check if true\n-     *\n-     *          If either the operation is not allowed by the security check\n-     *          or the system-wide resolver wasn't able to determine the\n+     *          If the system-wide resolver wasn't able to determine the\n@@ -827,1 +790,1 @@\n-    private static String getHostFromNameService(InetAddress addr, boolean check) {\n+    private static String getHostFromNameService(InetAddress addr) {\n@@ -834,11 +797,0 @@\n-            \/* check to see if calling code is allowed to know\n-             * the hostname for this IP address, ie, connect to the host\n-             *\/\n-            if (check) {\n-                @SuppressWarnings(\"removal\")\n-                SecurityManager sec = System.getSecurityManager();\n-                if (sec != null) {\n-                    sec.checkConnect(host, -1);\n-                }\n-            }\n-\n@@ -850,1 +802,1 @@\n-            InetAddress[] arr = InetAddress.getAllByName0(host, check);\n+            InetAddress[] arr = InetAddress.getAllByName0(host);\n@@ -1643,1 +1595,1 @@\n-        return getAllByName0(host, true, true);\n+        return getAllByName0(host, true);\n@@ -1669,3 +1621,2 @@\n-    static InetAddress[] getAllByName0 (String host, boolean check)\n-        throws UnknownHostException  {\n-        return getAllByName0(host, check, true);\n+    static InetAddress[] getAllByName0(String host) throws UnknownHostException {\n+        return getAllByName0(host, true);\n@@ -1712,1 +1663,0 @@\n-     * @param check perform security check\n@@ -1719,1 +1669,0 @@\n-                                               boolean check,\n@@ -1724,12 +1673,0 @@\n-\n-        \/* make sure the connection to the host is allowed, before we\n-         * give out a hostname\n-         *\/\n-        if (check) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager security = System.getSecurityManager();\n-            if (security != null) {\n-                security.checkConnect(host, -1);\n-            }\n-        }\n-\n@@ -1852,0 +1789,5 @@\n+        \/\/ is cached data still valid?\n+        CachedLocalHost clh = cachedLocalHost;\n+        if (clh != null && (clh.expiryTime - System.nanoTime()) >= 0L) {\n+            return clh.addr;\n+        }\n@@ -1853,17 +1795,1 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        try {\n-            \/\/ is cached data still valid?\n-            CachedLocalHost clh = cachedLocalHost;\n-            if (clh != null && (clh.expiryTime - System.nanoTime()) >= 0L) {\n-                if (security != null) {\n-                    security.checkConnect(clh.host, -1);\n-                }\n-                return clh.addr;\n-            }\n-\n-            String local = impl.getLocalHostName();\n-\n-            if (security != null) {\n-                security.checkConnect(local, -1);\n-            }\n+        String local = impl.getLocalHostName();\n@@ -1871,12 +1797,11 @@\n-            InetAddress localAddr;\n-            if (local.equals(\"localhost\")) {\n-                \/\/ shortcut for \"localhost\" host name\n-                localAddr = impl.loopbackAddress();\n-            } else {\n-                \/\/ call getAllByName0 without security checks and\n-                \/\/ without using cached data\n-                try {\n-                    localAddr = getAllByName0(local, false, false)[0];\n-                } catch (UnknownHostException uhe) {\n-                    \/\/ Rethrow with a more informative error message.\n-                    UnknownHostException uhe2 =\n+        InetAddress localAddr;\n+        if (local.equals(\"localhost\")) {\n+            \/\/ shortcut for \"localhost\" host name\n+            localAddr = impl.loopbackAddress();\n+        } else {\n+            \/\/ call getAllByName0 without using cached data\n+            try {\n+                localAddr = getAllByName0(local, false)[0];\n+            } catch (UnknownHostException uhe) {\n+                \/\/ Rethrow with a more informative error message.\n+                UnknownHostException uhe2 =\n@@ -1884,4 +1809,3 @@\n-                                                 uhe.getMessage());\n-                    uhe2.initCause(uhe);\n-                    throw uhe2;\n-                }\n+                                uhe.getMessage());\n+                uhe2.initCause(uhe);\n+                throw uhe2;\n@@ -1889,4 +1813,2 @@\n-            cachedLocalHost = new CachedLocalHost(local, localAddr);\n-            return localAddr;\n-        } catch (java.lang.SecurityException e) {\n-            return impl.loopbackAddress();\n+        cachedLocalHost = new CachedLocalHost(local, localAddr);\n+        return localAddr;\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":33,"deletions":111,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -297,1 +297,0 @@\n-        java.desktop,\n@@ -325,3 +324,0 @@\n-    exports sun.security.action to\n-        java.desktop,\n-        java.security.jgss;\n@@ -353,1 +349,0 @@\n-        java.desktop,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-import sun.net.ResourceManager;\n@@ -199,1 +198,0 @@\n-        ResourceManager.beforeUdpCreate();\n@@ -222,1 +220,0 @@\n-                ResourceManager.afterUdpClose();\n@@ -237,1 +234,0 @@\n-        ResourceManager.beforeUdpCreate();\n@@ -262,1 +258,0 @@\n-                ResourceManager.afterUdpClose();\n@@ -604,2 +599,1 @@\n-        Objects.requireNonNull(p);\n-        assert nanos >= 0;\n+        assert Thread.holdsLock(p) && nanos >= 0;\n@@ -620,6 +614,0 @@\n-            \/\/ p.bufLength is the maximum size of the datagram that can be received\n-            int bufLength;\n-            synchronized (p) {\n-                bufLength = DatagramPackets.getBufLength(p);\n-            }\n-\n@@ -630,0 +618,3 @@\n+\n+                \/\/ p.bufLength is the maximum size of the datagram that can be received\n+                int bufLength = DatagramPackets.getBufLength(p);\n@@ -632,1 +623,1 @@\n-                    \/\/ if datagram received then get sender and copy to DatagramPacket\n+                    \/\/ copy to DatagramPacket, set length and sender\n@@ -634,9 +625,4 @@\n-                        SocketAddress sender = sourceSocketAddress();\n-                        synchronized (p) {\n-                            \/\/ copy bytes to the DatagramPacket, and set length and sender.\n-                            \/\/ Need to re-read p.bufLength in case DatagramPacket changed\n-                            int len = Math.min(dst.limit(), DatagramPackets.getBufLength(p));\n-                            dst.get(p.getData(), p.getOffset(), len);\n-                            DatagramPackets.setLength(p, len);\n-                            p.setSocketAddress(sender);\n-                        }\n+                        int len = dst.limit();\n+                        dst.get(p.getData(), p.getOffset(), len);\n+                        DatagramPackets.setLength(p, len);\n+                        p.setSocketAddress(sourceSocketAddress());\n@@ -648,0 +634,1 @@\n+\n@@ -651,0 +638,1 @@\n+\n@@ -840,1 +828,1 @@\n-        Objects.requireNonNull(p);\n+        assert Thread.holdsLock(p);\n@@ -848,1 +836,2 @@\n-            ByteBuffer src = null;\n+            int len = p.getLength();\n+            ByteBuffer src = Util.getTemporaryDirectBuffer(len);\n@@ -850,0 +839,5 @@\n+                \/\/ copy bytes to temporary direct buffer\n+                src.put(p.getData(), p.getOffset(), len);\n+                src.flip();\n+\n+                \/\/ target address\n@@ -851,20 +845,4 @@\n-                synchronized (p) {\n-                    int len = p.getLength();\n-                    src = Util.getTemporaryDirectBuffer(len);\n-\n-                    \/\/ copy bytes to temporary direct buffer\n-                    src.put(p.getData(), p.getOffset(), len);\n-                    src.flip();\n-\n-                    \/\/ target address\n-                    if (p.getAddress() == null) {\n-                        InetSocketAddress remote = remoteAddress();\n-                        if (remote == null) {\n-                            throw new IllegalArgumentException(\"Address not set\");\n-                        }\n-                        \/\/ set address\/port to be compatible with long standing behavior\n-                        p.setAddress(remote.getAddress());\n-                        p.setPort(remote.getPort());\n-                        target = remote;\n-                    } else {\n-                        target = (InetSocketAddress) p.getSocketAddress();\n+                if (p.getAddress() == null) {\n+                    InetSocketAddress remote = remoteAddress();\n+                    if (remote == null) {\n+                        throw new IllegalArgumentException(\"Address not set\");\n@@ -872,0 +850,6 @@\n+                    \/\/ set address\/port to be compatible with long-standing behavior\n+                    p.setAddress(remote.getAddress());\n+                    p.setPort(remote.getPort());\n+                    target = remote;\n+                } else {\n+                    target = (InetSocketAddress) p.getSocketAddress();\n@@ -876,2 +860,1 @@\n-\n-                if (src != null) Util.offerFirstTemporaryDirectBuffer(src);\n+                Util.offerFirstTemporaryDirectBuffer(src);\n@@ -880,0 +863,1 @@\n+\n@@ -1925,2 +1909,1 @@\n-                \/\/ decrement socket count and release memory\n-                ResourceManager.afterUdpClose();\n+                \/\/ release memory\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":32,"deletions":49,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-import sun.net.ResourceManager;\n@@ -464,13 +463,5 @@\n-            if (!stream)\n-                ResourceManager.beforeUdpCreate();\n-            try {\n-                if (server) {\n-                    assert stream;\n-                    fd = Net.serverSocket(true);\n-                } else {\n-                    fd = Net.socket(stream);\n-                }\n-            } catch (IOException ioe) {\n-                if (!stream)\n-                    ResourceManager.afterUdpClose();\n-                throw ioe;\n+            if (server) {\n+                assert stream;\n+                fd = Net.serverSocket(true);\n+            } else {\n+                fd = Net.socket(stream);\n@@ -1230,3 +1221,0 @@\n-                } finally {\n-                    \/\/ decrement\n-                    ResourceManager.afterUdpClose();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -982,1 +982,1 @@\n-    The default value when the option is not specified is `allow`.\n+    The default value when the option is not specified is `warn`.\n","filename":"src\/java.base\/share\/man\/java.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n","filename":"src\/jdk.management.agent\/share\/classes\/jdk\/internal\/agent\/Agent.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -66,4 +64,1 @@\n-       AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-           System.loadLibrary(\"management_ext\");\n-           return null;\n-       });\n+       System.loadLibrary(\"management_ext\");\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,11 +103,0 @@\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id0 8344583 macosx-aarch64\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id1 8344583 macosx-aarch64\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id2 8344583 macosx-aarch64\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id3 8344583 macosx-aarch64\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id4 8344583 macosx-aarch64\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id5 8344583 macosx-aarch64\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id6 8344583 macosx-aarch64\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id7 8344583 macosx-aarch64\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id8 8344583 macosx-aarch64\n-runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java#id9 8344583 macosx-aarch64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"}]}