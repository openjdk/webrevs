{"files":[{"patch":"@@ -34,6 +34,0 @@\n-      apt-gcc-version:\n-        required: true\n-        type: string\n-      apt-gcc-cross-version:\n-        required: true\n-        type: string\n@@ -94,1 +88,1 @@\n-        uses: actions\/checkout@v3\n+        uses: actions\/checkout@v4\n@@ -116,6 +110,5 @@\n-              gcc-${{ inputs.gcc-major-version }}=${{ inputs.apt-gcc-version }} \\\n-              g++-${{ inputs.gcc-major-version }}=${{ inputs.apt-gcc-version }} \\\n-              gcc-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-cross-version }} \\\n-              g++-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-cross-version }} \\\n-              libxrandr-dev libxtst-dev libcups2-dev libasound2-dev \\\n-              debian-ports-archive-keyring\n+              gcc-${{ inputs.gcc-major-version }} \\\n+              g++-${{ inputs.gcc-major-version }} \\\n+              gcc-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}} \\\n+              g++-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}} \\\n+              libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n@@ -140,1 +133,1 @@\n-          --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev\n+          --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype-dev,libpng-dev\n@@ -143,1 +136,0 @@\n-          $(test -n \"${{ matrix.debian-keyring }}\" && echo \"--keyring=${{ matrix.debian-keyring }}\")\n@@ -156,1 +148,2 @@\n-          rm -rf sysroot\/usr\/lib\/{apt,udev,systemd}\n+          rm -rf sysroot\/usr\/lib\/{apt,gcc,udev,systemd}\n+          rm -rf sysroot\/usr\/libexec\/gcc\n","filename":".github\/workflows\/build-cross-compile.yml","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-        uses: actions\/checkout@v3\n+        uses: actions\/checkout@v4\n@@ -139,1 +139,1 @@\n-          sudo xcode-select --switch \/Applications\/Xcode_11.7.app\/Contents\/Developer\n+          sudo xcode-select --switch \/Applications\/Xcode_14.3.1.app\/Contents\/Developer\n","filename":".github\/workflows\/test.yml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,5 +69,0 @@\n-    -tag beaninfo:X \\\n-    -tag revised:X \\\n-    -tag since.unbundled:X \\\n-    -tag Note:X \\\n-    -tag ToDo:X \\\n","filename":"make\/Docs.gmk","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-GTEST_VERSION=1.13.0\n-JTREG_VERSION=7.3+1\n+GTEST_VERSION=1.14.0\n+JTREG_VERSION=7.3.1+1\n@@ -32,2 +32,2 @@\n-LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk20\/bdc68b4b9cbc4ebcb30745c85038d91d\/36\/GPL\/openjdk-20_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_SHA256=bb863b2d542976d1ae4b7b81af3e78b1e4247a64644350b552d298d8dc5980dc\n+LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=a30c454a9bef8f46d5f1bf3122830014a8fbe7ac03b5f8729bc3add4b92a1d0a\n@@ -40,2 +40,2 @@\n-MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk20\/bdc68b4b9cbc4ebcb30745c85038d91d\/36\/GPL\/openjdk-20_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_SHA256=47cf960d9bb89dbe987535a389f7e26c42de7c984ef5108612d77c81aa8cc6a4\n+MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=af32e84c11009f72f783fdcdc9917efc277893988f097e198e2576875d1e88c1\n@@ -44,2 +44,2 @@\n-WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk20\/bdc68b4b9cbc4ebcb30745c85038d91d\/36\/GPL\/openjdk-20_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_SHA256=c92fae5e42b9aecf444a66c8ec563c652f60b1e231dfdd33a4f5a3e3603058fb\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=5434faaf029e66e7ce6e75770ca384de476750984a7d2881ef7686894c4b4944\n","filename":"make\/conf\/github-actions.conf","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+\n+  static bool profile_all_receivers_at_type_check() { return false; }\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,6 @@\n+\n+  \/\/ JEDEC encoded as ((bank - 1) << 7) | (0x7f & JEDEC)\n+  enum VendorId {\n+    RIVOS = 0x6cf, \/\/ JEDEC: 0x4f, Bank: 14\n+  };\n+\n@@ -137,0 +143,1 @@\n+  decl(ext_Ztso        , \"Ztso\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZtso))        \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -575,0 +575,1 @@\n+  static bool profile_all_receivers_at_type_check() { return false; }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -217,0 +217,4 @@\n+  \/* Autodetected, see vm_version_x86.cpp *\/                                \\\n+  product(bool, EnableX86ECoreOpts, false, DIAGNOSTIC,                      \\\n+          \"Perform Ecore Optimization\")                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -1335,0 +1336,6 @@\n+  \/\/ Check if processor has Intel Ecore\n+  if (FLAG_IS_DEFAULT(EnableX86ECoreOpts) && is_intel() && cpu_family() == 6 &&\n+    (_model == 0x97 || _model == 0xAC || _model == 0xAF)) {\n+    FLAG_SET_DEFAULT(EnableX86ECoreOpts, true);\n+  }\n+\n@@ -2392,1 +2399,1 @@\n-        log->print_cr(\" at distance %d, %d lines of %d bytes\", (int) AllocatePrefetchDistance, (int) AllocatePrefetchLines, (int) AllocatePrefetchStepSize);\n+        log->print_cr(\" at distance %d, %d lines of %d bytes\", AllocatePrefetchDistance, AllocatePrefetchLines, AllocatePrefetchStepSize);\n@@ -2394,1 +2401,1 @@\n-        log->print_cr(\" at distance %d, one line of %d bytes\", (int) AllocatePrefetchDistance, (int) AllocatePrefetchStepSize);\n+        log->print_cr(\" at distance %d, one line of %d bytes\", AllocatePrefetchDistance, AllocatePrefetchStepSize);\n@@ -3766,1 +3773,1 @@\n-intx VM_Version::allocate_prefetch_distance(bool use_watermark_prefetch) {\n+int VM_Version::allocate_prefetch_distance(bool use_watermark_prefetch) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -856,1 +856,1 @@\n-  static intx allocate_prefetch_distance(bool use_watermark_prefetch);\n+  static int allocate_prefetch_distance(bool use_watermark_prefetch);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  static bool profile_all_receivers_at_type_check() { return false; }\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -193,1 +194,1 @@\n-  const int max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n+  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n@@ -202,2 +203,2 @@\n-  int off = 0;\n-  int left = max_len;\n+  size_t off = 0;\n+  size_t left = max_len;\n@@ -206,1 +207,1 @@\n-    int n;\n+    ssize_t n;\n@@ -208,1 +209,1 @@\n-    assert(n <= left, \"buffer was too small, impossible!\");\n+    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n@@ -216,1 +217,1 @@\n-    for (int i=0; i<n; i++) {\n+    for (ssize_t i=0; i<n; i++) {\n@@ -320,1 +321,1 @@\n-int LinuxAttachListener::write_fully(int s, char* buf, int len) {\n+int LinuxAttachListener::write_fully(int s, char* buf, size_t len) {\n@@ -525,9 +526,0 @@\n-AttachOperationFunctionInfo* AttachListener::pd_find_operation(const char* n) {\n-  return nullptr;\n-}\n-\n-jint AttachListener::pd_set_flag(AttachOperation* op, outputStream* out) {\n-  out->print_cr(\"flag '%s' cannot be changed\", op->arg(0));\n-  return JNI_ERR;\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  static int write_fully(int s, char* buf, int len);\n+  static int write_fully(int s, char* buf, size_t len);\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,3 +47,0 @@\n-  product(bool, UseHugeTLBFS, false,                                    \\\n-          \"Use MAP_HUGETLB for large pages\")                            \\\n-                                                                        \\\n@@ -56,3 +53,0 @@\n-  product(bool, UseSHM, false,                                          \\\n-          \"Use SYSV shared memory for large pages\")                     \\\n-                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"osContainer_linux.hpp\"\n@@ -44,1 +46,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -69,2 +70,0 @@\n-#include \"signals_posix.hpp\"\n-#include \"services\/memTracker.hpp\"\n@@ -72,0 +71,1 @@\n+#include \"signals_posix.hpp\"\n@@ -75,0 +75,2 @@\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/debug.hpp\"\n@@ -77,2 +79,1 @@\n-#include \"utilities\/events.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/events.hpp\"\n@@ -81,0 +82,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -86,0 +88,1 @@\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n@@ -93,0 +96,1 @@\n+# include <sys\/sendfile.h>\n@@ -98,0 +102,1 @@\n+# include <fenv.h>\n@@ -114,1 +119,0 @@\n-# include <sys\/shm.h>\n@@ -408,1 +412,1 @@\n-  int rslt = syscall(SYS_gettid);\n+  long rslt = syscall(SYS_gettid);\n@@ -430,1 +434,1 @@\n-  set_processor_count(sysconf(_SC_NPROCESSORS_CONF));\n+  set_processor_count((int)sysconf(_SC_NPROCESSORS_CONF));\n@@ -753,1 +757,1 @@\n-  osthread->set_thread_id(os::current_thread_id());\n+  osthread->set_thread_id(checked_cast<OSThread::thread_id_t>(os::current_thread_id()));\n@@ -920,1 +924,6 @@\n-  pthread_attr_init(&attr);\n+  int rslt = pthread_attr_init(&attr);\n+  if (rslt != 0) {\n+    thread->set_osthread(nullptr);\n+    delete osthread;\n+    return false;\n+  }\n@@ -969,0 +978,1 @@\n+    pthread_attr_destroy(&attr);\n@@ -1276,1 +1286,1 @@\n-    int statlen;\n+    size_t statlen;\n@@ -1485,1 +1495,1 @@\n-      if (offset != nullptr) *offset = addr - (address)dlinfo.dli_saddr;\n+      if (offset != nullptr) *offset = pointer_delta_as_int(addr, (address)dlinfo.dli_saddr);\n@@ -1513,1 +1523,1 @@\n-      *offset = addr - (address)dlinfo.dli_fbase;\n+      *offset = pointer_delta_as_int(addr, (address)dlinfo.dli_fbase);\n@@ -1612,4 +1622,3 @@\n-  int diag_msg_max_length=ebuflen-strlen(ebuf);\n-  char* diag_msg_buf=ebuf+strlen(ebuf);\n-\n-  if (diag_msg_max_length==0) {\n+  size_t prefix_len = strlen(ebuf);\n+  ssize_t diag_msg_max_length = ebuflen - prefix_len;\n+  if (diag_msg_max_length <= 0) {\n@@ -1620,0 +1629,1 @@\n+  char* diag_msg_buf = ebuf + prefix_len;\n@@ -1738,1 +1748,1 @@\n-#elif  (defined LOONGARCH)\n+#elif  (defined LOONGARCH64)\n@@ -1742,1 +1752,1 @@\n-        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, LOONGARCH, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n+        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n@@ -1803,9 +1813,23 @@\n-void * os::Linux::dlopen_helper(const char *filename, char *ebuf,\n-                                int ebuflen) {\n-  void * result = ::dlopen(filename, RTLD_LAZY);\n-\n-#if INCLUDE_JFR\n-  EventNativeLibraryLoad event;\n-  event.set_name(filename);\n-#endif\n-\n+void * os::Linux::dlopen_helper(const char *filename, char *ebuf, int ebuflen) {\n+#ifndef IA32\n+  \/\/ Save and restore the floating-point environment around dlopen().\n+  \/\/ There are known cases where global library initialization sets\n+  \/\/ FPU flags that affect computation accuracy, for example, enabling\n+  \/\/ Flush-To-Zero and Denormals-Are-Zero. Do not let those libraries\n+  \/\/ break Java arithmetic. Unfortunately, this might affect libraries\n+  \/\/ that might depend on these FPU features for performance and\/or\n+  \/\/ numerical \"accuracy\", but we need to protect Java semantics first\n+  \/\/ and foremost. See JDK-8295159.\n+\n+  \/\/ This workaround is ineffective on IA32 systems because the MXCSR\n+  \/\/ register (which controls flush-to-zero mode) is not stored in the\n+  \/\/ legacy fenv.\n+\n+  fenv_t default_fenv;\n+  int rtn = fegetenv(&default_fenv);\n+  assert(rtn == 0, \"fegetenv must succeed\");\n+#endif \/\/ IA32\n+\n+  void* result;\n+  JFR_ONLY(NativeLibraryLoadEvent load_event(filename, &result);)\n+  result = ::dlopen(filename, RTLD_LAZY);\n@@ -1823,5 +1847,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(error_report);\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(error_report);)\n@@ -1831,5 +1851,10 @@\n-#if INCLUDE_JFR\n-    event.set_success(true);\n-    event.set_errorMessage(nullptr);\n-    event.commit();\n-#endif\n+#ifndef IA32\n+    \/\/ Quickly test to make sure subnormals are correctly handled.\n+    if (! IEEE_subnormal_handling_OK()) {\n+      \/\/ We just dlopen()ed a library that mangled the floating-point\n+      \/\/ flags. Silently fix things now.\n+      int rtn = fesetenv(&default_fenv);\n+      assert(rtn == 0, \"fesetenv must succeed\");\n+      assert(IEEE_subnormal_handling_OK(), \"fsetenv didn't work\");\n+    }\n+#endif \/\/ IA32\n@@ -1902,1 +1927,1 @@\n-  int bytes;\n+  ssize_t bytes;\n@@ -2393,1 +2418,1 @@\n-        steal_ticks_perc = (double) steal_ticks_difference \/ total_ticks_difference;\n+        steal_ticks_perc = (double) steal_ticks_difference \/ (double)total_ticks_difference;\n@@ -2435,1 +2460,1 @@\n-      if (fgets(buf, buflen, fp)) {\n+      if (fgets(buf, (int)buflen, fp)) {\n@@ -2678,1 +2703,1 @@\n-        len = strlen(buf);\n+        len = checked_cast<int>(strlen(buf));\n@@ -2688,1 +2713,1 @@\n-          len = strlen(buf);\n+          len = (int)strlen(buf);\n@@ -2841,0 +2866,10 @@\n+\/\/ Note that the value for MAP_FIXED_NOREPLACE differs between architectures, but all architectures\n+\/\/ supported by OpenJDK share the same flag value.\n+#define MAP_FIXED_NOREPLACE_value 0x100000\n+#ifndef MAP_FIXED_NOREPLACE\n+  #define MAP_FIXED_NOREPLACE MAP_FIXED_NOREPLACE_value\n+#else\n+  \/\/ Sanity-check our assumed default value if we build with a new enough libc.\n+  static_assert(MAP_FIXED_NOREPLACE == MAP_FIXED_NOREPLACE_value, \"MAP_FIXED_NOREPLACE != MAP_FIXED_NOREPLACE_value\");\n+#endif\n+\n@@ -2957,1 +2992,1 @@\n-size_t os::numa_get_leaf_groups(int *ids, size_t size) {\n+size_t os::numa_get_leaf_groups(uint *ids, size_t size) {\n@@ -2966,2 +3001,2 @@\n-    if (Linux::is_node_in_bound_nodes((unsigned int)node)) {\n-      ids[i++] = node;\n+    if (Linux::is_node_in_bound_nodes(node)) {\n+      ids[i++] = checked_cast<uint>(node);\n@@ -2981,1 +3016,1 @@\n-  int retval = -1;\n+  long retval = -1;\n@@ -3000,1 +3035,1 @@\n-  return (retval == -1) ? retval : cpu;\n+  return (retval == -1) ? -1 : cpu;\n@@ -3153,12 +3188,12 @@\n-  const size_t NCPUS = 32768; \/\/ Since the buffer size computation is very obscure\n-                              \/\/ in libnuma (possible values are starting from 16,\n-                              \/\/ and continuing up with every other power of 2, but less\n-                              \/\/ than the maximum number of CPUs supported by kernel), and\n-                              \/\/ is a subject to change (in libnuma version 2 the requirements\n-                              \/\/ are more reasonable) we'll just hardcode the number they use\n-                              \/\/ in the library.\n-  const size_t BitsPerCLong = sizeof(long) * CHAR_BIT;\n-\n-  size_t cpu_num = processor_count();\n-  size_t cpu_map_size = NCPUS \/ BitsPerCLong;\n-  size_t cpu_map_valid_size =\n+  const int NCPUS = 32768; \/\/ Since the buffer size computation is very obscure\n+                           \/\/ in libnuma (possible values are starting from 16,\n+                           \/\/ and continuing up with every other power of 2, but less\n+                           \/\/ than the maximum number of CPUs supported by kernel), and\n+                           \/\/ is a subject to change (in libnuma version 2 the requirements\n+                           \/\/ are more reasonable) we'll just hardcode the number they use\n+                           \/\/ in the library.\n+  constexpr int BitsPerCLong = (int)sizeof(long) * CHAR_BIT;\n+\n+  int cpu_num = processor_count();\n+  int cpu_map_size = NCPUS \/ BitsPerCLong;\n+  int cpu_map_valid_size =\n@@ -3170,1 +3205,1 @@\n-  size_t node_num = get_existing_num_nodes();\n+  int node_num = get_existing_num_nodes();\n@@ -3176,1 +3211,1 @@\n-  for (size_t i = 0; i < node_num; i++) {\n+  for (int i = 0; i < node_num; i++) {\n@@ -3187,1 +3222,1 @@\n-      for (size_t m = 0; m < node_num; m++) {\n+      for (int m = 0; m < node_num; m++) {\n@@ -3209,2 +3244,2 @@\n-    if (numa_node_to_cpus(nindex_to_node()->at(i), cpu_map, cpu_map_size * sizeof(unsigned long)) != -1) {\n-      for (size_t j = 0; j < cpu_map_valid_size; j++) {\n+    if (numa_node_to_cpus(nindex_to_node()->at(i), cpu_map, cpu_map_size * (int)sizeof(unsigned long)) != -1) {\n+      for (int j = 0; j < cpu_map_valid_size; j++) {\n@@ -3212,1 +3247,1 @@\n-          for (size_t k = 0; k < BitsPerCLong; k++) {\n+          for (int k = 0; k < BitsPerCLong; k++) {\n@@ -3297,1 +3332,1 @@\n-  unsigned pages = size \/ page_sz;\n+  unsigned pages = checked_cast<unsigned>(size \/ page_sz);\n@@ -3347,1 +3382,1 @@\n-  size_t pages = size \/ page_sz;\n+  uintx pages = size \/ page_sz;\n@@ -3354,1 +3389,1 @@\n-  int loops = (pages + stripe - 1) \/ stripe;\n+  int loops = checked_cast<int>((pages + stripe - 1) \/ stripe);\n@@ -3361,1 +3396,1 @@\n-    int pages_to_query = (pages >= stripe) ? stripe : pages;\n+    uintx pages_to_query = (pages >= stripe) ? stripe : pages;\n@@ -3374,0 +3409,5 @@\n+    \/\/ If mincore is not supported.\n+    if (mincore_return_value == -1 && errno == ENOSYS) {\n+      return false;\n+    }\n+\n@@ -3377,1 +3417,1 @@\n-    for (int vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n+    for (uintx vecIdx = 0; vecIdx < pages_to_query; vecIdx ++) {\n@@ -3481,2 +3521,17 @@\n-  \/\/ MAP_FIXED is intentionally left out, to leave existing mappings intact.\n-  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n+  \/\/ If a requested address was given:\n+  \/\/\n+  \/\/ The POSIX-conforming way is to *omit* MAP_FIXED. This will leave existing mappings intact.\n+  \/\/ If the requested mapping area is blocked by a pre-existing mapping, the kernel will map\n+  \/\/ somewhere else. On Linux, that alternative address appears to have no relation to the\n+  \/\/ requested address.\n+  \/\/ Unfortunately, this is not what we need - if we requested a specific address, we'd want\n+  \/\/ to map there and nowhere else. Therefore we will unmap the block again, which means we\n+  \/\/ just executed a needless mmap->munmap cycle.\n+  \/\/ Since Linux 4.17, the kernel offers MAP_FIXED_NOREPLACE. With this flag, if a pre-\n+  \/\/ existing mapping exists, the kernel will not map at an alternative point but instead\n+  \/\/ return an error. We can therefore save that unnecessary mmap-munmap cycle.\n+  \/\/\n+  \/\/ Backward compatibility: Older kernels will ignore the unknown flag; so mmap will behave\n+  \/\/ as in mode (a).\n+  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS |\n+                    ((requested_addr != nullptr) ? MAP_FIXED_NOREPLACE : 0);\n@@ -3590,1 +3645,1 @@\n-int os::Linux::hugetlbfs_page_size_flag(size_t page_size) {\n+static int hugetlbfs_page_size_flag(size_t page_size) {\n@@ -3597,1 +3652,4 @@\n-bool os::Linux::hugetlbfs_sanity_check(bool warn, size_t page_size) {\n+static bool hugetlbfs_sanity_check(size_t page_size) {\n+  const os::PageSizes page_sizes = HugePages::static_info().pagesizes();\n+  assert(page_sizes.contains(page_size), \"Invalid page sizes passed\");\n+\n@@ -3611,3 +3669,3 @@\n-      for (size_t page_size_ = _page_sizes.next_smaller(page_size);\n-          page_size_ != os::vm_page_size();\n-          page_size_ = _page_sizes.next_smaller(page_size_)) {\n+      for (size_t page_size_ = page_sizes.next_smaller(page_size);\n+          page_size_ > os::vm_page_size();\n+          page_size_ = page_sizes.next_smaller(page_size_)) {\n@@ -3627,4 +3685,0 @@\n-  if (warn) {\n-    warning(\"HugeTLBFS is not configured or not supported by the operating system.\");\n-  }\n-\n@@ -3634,24 +3688,0 @@\n-bool os::Linux::shm_hugetlbfs_sanity_check(bool warn, size_t page_size) {\n-  \/\/ Try to create a large shared memory segment.\n-  int shmid = shmget(IPC_PRIVATE, page_size, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);\n-  if (shmid == -1) {\n-    \/\/ Possible reasons for shmget failure:\n-    \/\/ 1. shmmax is too small for the request.\n-    \/\/    > check shmmax value: cat \/proc\/sys\/kernel\/shmmax\n-    \/\/    > increase shmmax value: echo \"new_value\" > \/proc\/sys\/kernel\/shmmax\n-    \/\/ 2. not enough large page memory.\n-    \/\/    > check available large pages: cat \/proc\/meminfo\n-    \/\/    > increase amount of large pages:\n-    \/\/          sysctl -w vm.nr_hugepages=new_value\n-    \/\/    > For more information regarding large pages please refer to:\n-    \/\/      https:\/\/www.kernel.org\/doc\/Documentation\/vm\/hugetlbpage.txt\n-    if (warn) {\n-      warning(\"Large pages using UseSHM are not configured on this system.\");\n-    }\n-    return false;\n-  }\n-  \/\/ Managed to create a segment, now delete it.\n-  shmctl(shmid, IPC_RMID, nullptr);\n-  return true;\n-}\n-\n@@ -3705,42 +3735,0 @@\n-bool os::Linux::setup_large_page_type(size_t page_size) {\n-  if (FLAG_IS_DEFAULT(UseHugeTLBFS) &&\n-      FLAG_IS_DEFAULT(UseSHM) &&\n-      FLAG_IS_DEFAULT(UseTransparentHugePages)) {\n-\n-    \/\/ The type of large pages has not been specified by the user.\n-\n-    \/\/ Try UseHugeTLBFS and then UseSHM.\n-    UseHugeTLBFS = UseSHM = true;\n-\n-    \/\/ Don't try UseTransparentHugePages since there are known\n-    \/\/ performance issues with it turned on. This might change in the future.\n-    UseTransparentHugePages = false;\n-  }\n-\n-  if (UseTransparentHugePages) {\n-    UseHugeTLBFS = false;\n-    UseSHM = false;\n-    return true;\n-  }\n-\n-  if (UseHugeTLBFS) {\n-    bool warn_on_failure = !FLAG_IS_DEFAULT(UseHugeTLBFS);\n-    if (hugetlbfs_sanity_check(warn_on_failure, page_size)) {\n-      UseSHM = false;\n-      return true;\n-    }\n-    UseHugeTLBFS = false;\n-  }\n-\n-  if (UseSHM) {\n-    bool warn_on_failure = !FLAG_IS_DEFAULT(UseSHM);\n-    if (shm_hugetlbfs_sanity_check(warn_on_failure, page_size)) {\n-      return true;\n-    }\n-    UseSHM = false;\n-  }\n-\n-  warn_no_large_pages_configured();\n-  return false;\n-}\n-\n@@ -3753,2 +3741,1 @@\n-        ls.print_cr(\"UseLargePages=1, UseTransparentHugePages=%d, UseHugeTLBFS=%d, UseSHM=%d\",\n-                    UseTransparentHugePages, UseHugeTLBFS, UseSHM);\n+        ls.print_cr(\"UseLargePages=1, UseTransparentHugePages=%d\", UseTransparentHugePages);\n@@ -3788,3 +3775,1 @@\n-      !UseTransparentHugePages &&\n-      !UseHugeTLBFS &&\n-      !UseSHM) {\n+      !UseTransparentHugePages) {\n@@ -3797,3 +3782,0 @@\n-    \/\/ Ignore the rest of the large pages flags.\n-    UseHugeTLBFS = false;\n-    UseSHM = false;\n@@ -3804,4 +3786,9 @@\n-  \/\/ 2) check if large pages are configured\n-  if ( ( UseTransparentHugePages && HugePages::supports_thp() == false) ||\n-       (!UseTransparentHugePages && HugePages::supports_static_hugepages() == false) ) {\n-    \/\/ No large pages configured, return.\n+  \/\/ 2) check if the OS supports THPs resp. static hugepages.\n+  if (UseTransparentHugePages && !HugePages::supports_thp()) {\n+    if (!FLAG_IS_DEFAULT(UseTransparentHugePages)) {\n+      log_warning(pagesize)(\"UseTransparentHugePages disabled, transparent huge pages are not supported by the operating system.\");\n+    }\n+    UseLargePages = UseTransparentHugePages = false;\n+    return;\n+  }\n+  if (!UseTransparentHugePages && !HugePages::supports_static_hugepages()) {\n@@ -3809,4 +3796,1 @@\n-    UseLargePages = false;\n-    UseTransparentHugePages = false;\n-    UseHugeTLBFS = false;\n-    UseSHM = false;\n+    UseLargePages = UseTransparentHugePages = false;\n@@ -3824,0 +3808,2 @@\n+    \/\/ +UseTransparentHugePages implies +UseLargePages\n+    UseLargePages = true;\n@@ -3836,0 +3822,2 @@\n+    size_t large_page_size = 0;\n+\n@@ -3843,1 +3831,1 @@\n-      _large_page_size = default_large_page_size;\n+      large_page_size = default_large_page_size;\n@@ -3845,2 +3833,2 @@\n-                         byte_size_in_exact_unit(_large_page_size),\n-                         exact_unit_for_byte_size(_large_page_size));\n+                         byte_size_in_exact_unit(large_page_size),\n+                         exact_unit_for_byte_size(large_page_size));\n@@ -3849,1 +3837,1 @@\n-        _large_page_size = LargePageSizeInBytes;\n+        large_page_size = LargePageSizeInBytes;\n@@ -3854,2 +3842,2 @@\n-                           byte_size_in_exact_unit(_large_page_size),\n-                           exact_unit_for_byte_size(_large_page_size));\n+                           byte_size_in_exact_unit(large_page_size),\n+                           exact_unit_for_byte_size(large_page_size));\n@@ -3857,1 +3845,1 @@\n-        _large_page_size = default_large_page_size;\n+        large_page_size = default_large_page_size;\n@@ -3862,2 +3850,2 @@\n-                           byte_size_in_exact_unit(_large_page_size),\n-                           exact_unit_for_byte_size(_large_page_size));\n+                           byte_size_in_exact_unit(large_page_size),\n+                           exact_unit_for_byte_size(large_page_size));\n@@ -3867,0 +3855,10 @@\n+    \/\/ Do an additional sanity check to see if we can use the desired large page size\n+    if (!hugetlbfs_sanity_check(large_page_size)) {\n+      warn_no_large_pages_configured();\n+      UseLargePages = false;\n+      UseTransparentHugePages = false;\n+      return;\n+    }\n+\n+    _large_page_size = large_page_size;\n+\n@@ -3875,3 +3873,0 @@\n-  \/\/ Now determine the type of large pages to use:\n-  UseLargePages = os::Linux::setup_large_page_type(_large_page_size);\n-\n@@ -3881,144 +3876,0 @@\n-#ifndef SHM_HUGETLB\n-  #define SHM_HUGETLB 04000\n-#endif\n-\n-#define shm_warning_format(format, ...)              \\\n-  do {                                               \\\n-    if (UseLargePages &&                             \\\n-        (!FLAG_IS_DEFAULT(UseLargePages) ||          \\\n-         !FLAG_IS_DEFAULT(UseSHM) ||                 \\\n-         !FLAG_IS_DEFAULT(LargePageSizeInBytes))) {  \\\n-      warning(format, __VA_ARGS__);                  \\\n-    }                                                \\\n-  } while (0)\n-\n-#define shm_warning(str) shm_warning_format(\"%s\", str)\n-\n-#define shm_warning_with_errno(str)                \\\n-  do {                                             \\\n-    int err = errno;                               \\\n-    shm_warning_format(str \" (error = %d)\", err);  \\\n-  } while (0)\n-\n-static char* shmat_with_alignment(int shmid, size_t bytes, size_t alignment) {\n-  assert(is_aligned(bytes, alignment), \"Must be divisible by the alignment\");\n-\n-  if (!is_aligned(alignment, SHMLBA)) {\n-    assert(false, \"Code below assumes that alignment is at least SHMLBA aligned\");\n-    return nullptr;\n-  }\n-\n-  \/\/ To ensure that we get 'alignment' aligned memory from shmat,\n-  \/\/ we pre-reserve aligned virtual memory and then attach to that.\n-\n-  char* pre_reserved_addr = anon_mmap_aligned(nullptr \/* req_addr *\/, bytes, alignment);\n-  if (pre_reserved_addr == nullptr) {\n-    \/\/ Couldn't pre-reserve aligned memory.\n-    shm_warning(\"Failed to pre-reserve aligned memory for shmat.\");\n-    return nullptr;\n-  }\n-\n-  \/\/ SHM_REMAP is needed to allow shmat to map over an existing mapping.\n-  char* addr = (char*)shmat(shmid, pre_reserved_addr, SHM_REMAP);\n-\n-  if ((intptr_t)addr == -1) {\n-    int err = errno;\n-    shm_warning_with_errno(\"Failed to attach shared memory.\");\n-\n-    assert(err != EACCES, \"Unexpected error\");\n-    assert(err != EIDRM,  \"Unexpected error\");\n-    assert(err != EINVAL, \"Unexpected error\");\n-\n-    \/\/ Since we don't know if the kernel unmapped the pre-reserved memory area\n-    \/\/ we can't unmap it, since that would potentially unmap memory that was\n-    \/\/ mapped from other threads.\n-    return nullptr;\n-  }\n-\n-  return addr;\n-}\n-\n-static char* shmat_at_address(int shmid, char* req_addr) {\n-  if (!is_aligned(req_addr, SHMLBA)) {\n-    assert(false, \"Requested address needs to be SHMLBA aligned\");\n-    return nullptr;\n-  }\n-\n-  char* addr = (char*)shmat(shmid, req_addr, 0);\n-\n-  if ((intptr_t)addr == -1) {\n-    shm_warning_with_errno(\"Failed to attach shared memory.\");\n-    return nullptr;\n-  }\n-\n-  return addr;\n-}\n-\n-static char* shmat_large_pages(int shmid, size_t bytes, size_t alignment, char* req_addr) {\n-  \/\/ If a req_addr has been provided, we assume that the caller has already aligned the address.\n-  if (req_addr != nullptr) {\n-    assert(is_aligned(req_addr, os::large_page_size()), \"Must be divisible by the large page size\");\n-    assert(is_aligned(req_addr, alignment), \"Must be divisible by given alignment\");\n-    return shmat_at_address(shmid, req_addr);\n-  }\n-\n-  \/\/ Since shmid has been setup with SHM_HUGETLB, shmat will automatically\n-  \/\/ return large page size aligned memory addresses when req_addr == nullptr.\n-  \/\/ However, if the alignment is larger than the large page size, we have\n-  \/\/ to manually ensure that the memory returned is 'alignment' aligned.\n-  if (alignment > os::large_page_size()) {\n-    assert(is_aligned(alignment, os::large_page_size()), \"Must be divisible by the large page size\");\n-    return shmat_with_alignment(shmid, bytes, alignment);\n-  } else {\n-    return shmat_at_address(shmid, nullptr);\n-  }\n-}\n-\n-char* os::Linux::reserve_memory_special_shm(size_t bytes, size_t alignment,\n-                                            char* req_addr, bool exec) {\n-  \/\/ \"exec\" is passed in but not used.  Creating the shared image for\n-  \/\/ the code cache doesn't have an SHM_X executable permission to check.\n-  assert(UseLargePages && UseSHM, \"only for SHM large pages\");\n-  assert(is_aligned(req_addr, os::large_page_size()), \"Unaligned address\");\n-  assert(is_aligned(req_addr, alignment), \"Unaligned address\");\n-\n-  if (!is_aligned(bytes, os::large_page_size())) {\n-    return nullptr; \/\/ Fallback to small pages.\n-  }\n-\n-  \/\/ Create a large shared memory region to attach to based on size.\n-  \/\/ Currently, size is the total size of the heap.\n-  int shmid = shmget(IPC_PRIVATE, bytes, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);\n-  if (shmid == -1) {\n-    \/\/ Possible reasons for shmget failure:\n-    \/\/ 1. shmmax is too small for the request.\n-    \/\/    > check shmmax value: cat \/proc\/sys\/kernel\/shmmax\n-    \/\/    > increase shmmax value: echo \"new_value\" > \/proc\/sys\/kernel\/shmmax\n-    \/\/ 2. not enough large page memory.\n-    \/\/    > check available large pages: cat \/proc\/meminfo\n-    \/\/    > increase amount of large pages:\n-    \/\/          sysctl -w vm.nr_hugepages=new_value\n-    \/\/    > For more information regarding large pages please refer to:\n-    \/\/      https:\/\/www.kernel.org\/doc\/Documentation\/vm\/hugetlbpage.txt\n-    \/\/      Note 1: different Linux may use different name for this property,\n-    \/\/            e.g. on Redhat AS-3 it is \"hugetlb_pool\".\n-    \/\/      Note 2: it's possible there's enough physical memory available but\n-    \/\/            they are so fragmented after a long run that they can't\n-    \/\/            coalesce into large pages. Try to reserve large pages when\n-    \/\/            the system is still \"fresh\".\n-    shm_warning_with_errno(\"Failed to reserve shared memory.\");\n-    return nullptr;\n-  }\n-\n-  \/\/ Attach to the region.\n-  char* addr = shmat_large_pages(shmid, bytes, alignment, req_addr);\n-\n-  \/\/ Remove shmid. If shmat() is successful, the actual shared memory segment\n-  \/\/ will be deleted when it's detached by shmdt() or when the process\n-  \/\/ terminates. If shmat() is not successful this will remove the shared\n-  \/\/ segment immediately.\n-  shmctl(shmid, IPC_RMID, nullptr);\n-\n-  return addr;\n-}\n-\n@@ -4035,1 +3886,1 @@\n-bool os::Linux::commit_memory_special(size_t bytes,\n+static bool commit_memory_special(size_t bytes,\n@@ -4039,1 +3890,1 @@\n-  assert(UseLargePages && UseHugeTLBFS, \"Should only get here when HugeTLBFS large pages are used\");\n+  assert(UseLargePages && !UseTransparentHugePages, \"Should only get here for static hugepage mode (+UseLargePages)\");\n@@ -4068,6 +3919,7 @@\n-char* os::Linux::reserve_memory_special_huge_tlbfs(size_t bytes,\n-                                                   size_t alignment,\n-                                                   size_t page_size,\n-                                                   char* req_addr,\n-                                                   bool exec) {\n-  assert(UseLargePages && UseHugeTLBFS, \"only for Huge TLBFS large pages\");\n+static char* reserve_memory_special_huge_tlbfs(size_t bytes,\n+                                               size_t alignment,\n+                                               size_t page_size,\n+                                               char* req_addr,\n+                                               bool exec) {\n+  const os::PageSizes page_sizes = HugePages::static_info().pagesizes();\n+  assert(UseLargePages, \"only for Huge TLBFS large pages\");\n@@ -4077,1 +3929,1 @@\n-  assert(_page_sizes.contains(page_size), \"Must be a valid page size\");\n+  assert(page_sizes.contains(page_size), \"Must be a valid page size\");\n@@ -4130,8 +3982,1 @@\n-  char* addr;\n-  if (UseSHM) {\n-    \/\/ No support for using specific page sizes with SHM.\n-    addr = os::Linux::reserve_memory_special_shm(bytes, alignment, req_addr, exec);\n-  } else {\n-    assert(UseHugeTLBFS, \"must be\");\n-    addr = os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, page_size, req_addr, exec);\n-  }\n+  char* const addr = reserve_memory_special_huge_tlbfs(bytes, alignment, page_size, req_addr, exec);\n@@ -4148,9 +3993,0 @@\n-bool os::Linux::release_memory_special_shm(char* base, size_t bytes) {\n-  \/\/ detaching the SHM segment will also delete it, see reserve_memory_special_shm()\n-  return shmdt(base) == 0;\n-}\n-\n-bool os::Linux::release_memory_special_huge_tlbfs(char* base, size_t bytes) {\n-  return pd_release_memory(base, bytes);\n-}\n-\n@@ -4159,9 +3995,2 @@\n-  bool res;\n-\n-  if (UseSHM) {\n-    res = os::Linux::release_memory_special_shm(base, bytes);\n-  } else {\n-    assert(UseHugeTLBFS, \"must be\");\n-    res = os::Linux::release_memory_special_huge_tlbfs(base, bytes);\n-  }\n-  return res;\n+  \/\/ Plain munmap is sufficient\n+  return pd_release_memory(base, bytes);\n@@ -4174,4 +4003,3 @@\n-\/\/ With SysV SHM the entire memory region must be allocated as shared\n-\/\/ memory.\n-\/\/ HugeTLBFS allows application to commit large page memory on demand.\n-\/\/ However, when committing memory with HugeTLBFS fails, the region\n+\/\/ static hugepages (hugetlbfs) allow application to commit large page memory\n+\/\/ on demand.\n+\/\/ However, when committing memory with hugepages fails, the region\n@@ -4180,1 +4008,2 @@\n-\/\/ behavior we can't commit HugeTLBFS memory.\n+\/\/ behavior we can't commit hugetlbfs memory. Instead, we commit that\n+\/\/ memory at reservation.\n@@ -4186,1 +4015,1 @@\n-  return UseTransparentHugePages || UseHugeTLBFS;\n+  return UseTransparentHugePages;\n@@ -4220,0 +4049,1 @@\n+    log_trace(os, map)(\"Kernel rejected \" PTR_FORMAT \", offered \" PTR_FORMAT \".\", p2i(requested_addr), p2i(addr));\n@@ -4226,0 +4056,20 @@\n+size_t os::vm_min_address() {\n+  \/\/ Determined by sysctl vm.mmap_min_addr. It exists as a safety zone to prevent\n+  \/\/ NULL pointer dereferences.\n+  \/\/ Most distros set this value to 64 KB. It *can* be zero, but rarely is. Here,\n+  \/\/ we impose a minimum value if vm.mmap_min_addr is too low, for increased protection.\n+  static size_t value = 0;\n+  if (value == 0) {\n+    assert(is_aligned(_vm_min_address_default, os::vm_allocation_granularity()), \"Sanity\");\n+    FILE* f = os::fopen(\"\/proc\/sys\/vm\/mmap_min_addr\", \"r\");\n+    if (f != nullptr) {\n+      if (fscanf(f, \"%zu\", &value) != 1) {\n+        value = _vm_min_address_default;\n+      }\n+      fclose(f);\n+    }\n+    value = MAX2(_vm_min_address_default, value);\n+  }\n+  return value;\n+}\n+\n@@ -4332,0 +4182,7 @@\n+\/\/ copy data between two file descriptor within the kernel\n+\/\/ the number of bytes written to out_fd is returned if transfer was successful\n+\/\/ otherwise, returns -1 that implies an error\n+jlong os::Linux::sendfile(int out_fd, int in_fd, jlong* offset, jlong count) {\n+  return ::sendfile64(out_fd, in_fd, (off64_t*)offset, (size_t)count);\n+}\n+\n@@ -4404,2 +4261,2 @@\n-  clock_tics_per_sec = sysconf(_SC_CLK_TCK);\n-  int sys_pg_size = sysconf(_SC_PAGESIZE);\n+  clock_tics_per_sec = checked_cast<int>(sysconf(_SC_CLK_TCK));\n+  int sys_pg_size = checked_cast<int>(sysconf(_SC_PAGESIZE));\n@@ -4410,1 +4267,1 @@\n-  size_t page_size = (size_t) sys_pg_size;\n+  size_t page_size = sys_pg_size;\n@@ -4514,1 +4371,1 @@\n-    \/\/ With SHM and HugeTLBFS large pages we cannot uncommit a page, so there's no way\n+    \/\/ With static large pages we cannot uncommit a page, so there's no way\n@@ -4516,2 +4373,1 @@\n-    \/\/ UseNUMA and UseLargePages (or UseSHM\/UseHugeTLBFS) on the command line - warn\n-    \/\/ and disable adaptive resizing.\n+    \/\/ UseNUMA and UseLargePages on the command line - warn and disable adaptive resizing.\n@@ -4519,1 +4375,1 @@\n-      warning(\"UseNUMA is not fully compatible with SHM\/HugeTLBFS large pages, \"\n+      warning(\"UseNUMA is not fully compatible with +UseLargePages, \"\n@@ -4754,1 +4610,1 @@\n-  int cpus_size = sizeof(cpu_set_t);\n+  size_t cpus_size = sizeof(cpu_set_t);\n@@ -4778,1 +4634,1 @@\n-       int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);\n+       int online_cpus = checked_cast<int>(::sysconf(_SC_NPROCESSORS_ONLN));\n@@ -4810,1 +4666,1 @@\n-    cpu_count = ::sysconf(_SC_NPROCESSORS_ONLN);\n+    cpu_count = checked_cast<int>(::sysconf(_SC_NPROCESSORS_ONLN));\n@@ -5172,1 +5028,1 @@\n-  int statlen;\n+  size_t statlen;\n@@ -5318,1 +5174,1 @@\n-  return strlen(buffer);\n+  return checked_cast<int>(strlen(buffer));\n@@ -5378,1 +5234,1 @@\n-\/\/ ** P1 (aka bottom) and size (P2 = P1 - size) are the address and stack size\n+\/\/ ** P1 (aka bottom) and size are the address and stack size\n@@ -5380,0 +5236,1 @@\n+\/\/ ** P2 (aka stack top or base) = P1 + size\n@@ -5385,1 +5242,2 @@\n-static void current_stack_region(address * bottom, size_t * size) {\n+void os::current_stack_base_and_size(address* base, size_t* size) {\n+  address bottom;\n@@ -5389,2 +5247,3 @@\n-    *bottom = os::Linux::initial_thread_stack_bottom();\n-    *size   = os::Linux::initial_thread_stack_size();\n+    bottom = os::Linux::initial_thread_stack_bottom();\n+    *size = os::Linux::initial_thread_stack_size();\n+    *base = bottom + *size;\n@@ -5405,1 +5264,1 @@\n-    if (pthread_attr_getstack(&attr, (void **)bottom, size) != 0) {\n+    if (pthread_attr_getstack(&attr, (void **)&bottom, size) != 0) {\n@@ -5409,0 +5268,2 @@\n+    *base = bottom + *size;\n+\n@@ -5415,2 +5276,2 @@\n-      *bottom += guard_size;\n-      *size   -= guard_size;\n+      bottom += guard_size;\n+      *size  -= guard_size;\n@@ -5420,3 +5281,2 @@\n-\n-  assert(os::current_stack_pointer() >= *bottom &&\n-         os::current_stack_pointer() < *bottom + *size, \"just checking\");\n+  assert(os::current_stack_pointer() >= bottom &&\n+         os::current_stack_pointer() < *base, \"just checking\");\n@@ -5426,15 +5286,0 @@\n-address os::current_stack_base() {\n-  address bottom;\n-  size_t size;\n-  current_stack_region(&bottom, &size);\n-  return (bottom + size);\n-}\n-\n-size_t os::current_stack_size() {\n-  \/\/ This stack size includes the usable stack and HotSpot guard pages\n-  \/\/ (for the threads that have Hotspot guard pages).\n-  address bottom;\n-  size_t size;\n-  current_stack_region(&bottom, &size);\n-  return size;\n-}\n@@ -5453,1 +5298,1 @@\n-  int diff = filetime1.tv_sec - filetime2.tv_sec;\n+  int diff = primitive_compare(filetime1.tv_sec, filetime2.tv_sec);\n@@ -5455,1 +5300,1 @@\n-    return filetime1.tv_nsec - filetime2.tv_nsec;\n+    diff = primitive_compare(filetime1.tv_nsec, filetime2.tv_nsec);\n@@ -5488,1 +5333,0 @@\n-    st->cr();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":245,"deletions":401,"binary":false,"changes":646,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-  friend class TestReserveMemorySpecial;\n@@ -80,14 +79,0 @@\n-  static bool setup_large_page_type(size_t page_size);\n-  static bool hugetlbfs_sanity_check(bool warn, size_t page_size);\n-  static bool shm_hugetlbfs_sanity_check(bool warn, size_t page_size);\n-\n-  static int hugetlbfs_page_size_flag(size_t page_size);\n-\n-  static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec);\n-  static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, size_t page_size, char* req_addr, bool exec);\n-  static bool commit_memory_special(size_t bytes, size_t page_size, char* req_addr, bool exec);\n-\n-  static bool release_memory_special_impl(char* base, size_t bytes);\n-  static bool release_memory_special_shm(char* base, size_t bytes);\n-  static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);\n-\n@@ -172,0 +157,2 @@\n+  static jlong sendfile(int out_fd, int in_fd, jlong* offset, jlong count);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -31,7 +32,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/osThread.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-#include \"services\/attachListener.hpp\"\n-#include \"services\/memTracker.hpp\"\n@@ -41,0 +35,3 @@\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -43,0 +40,1 @@\n+#include \"runtime\/osThread.hpp\"\n@@ -45,0 +43,2 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"services\/attachListener.hpp\"\n@@ -46,0 +46,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -53,0 +54,4 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n+#endif\n+\n@@ -155,5 +160,1 @@\n-        fr.sender_pc() == nullptr || os::is_first_C_frame(&fr)) break;\n-\n-    if (fr.sender_pc() && !os::is_first_C_frame(&fr)) {\n-      fr = os::get_sender_for_C_frame(&fr);\n-    } else {\n+        fr.sender_pc() == nullptr || os::is_first_C_frame(&fr)) {\n@@ -162,0 +163,1 @@\n+    fr = os::get_sender_for_C_frame(&fr);\n@@ -449,1 +451,1 @@\n-  int currsec = time(nullptr);\n+  time_t currsec = time(nullptr);\n@@ -460,1 +462,1 @@\n-    os::print_dhm(st, \"OS uptime:\", (long) (currsec-bootsec));\n+    os::print_dhm(st, \"OS uptime:\", currsec-bootsec);\n@@ -718,0 +720,1 @@\n+\n@@ -725,0 +728,3 @@\n+\n+  JFR_ONLY(NativeLibraryUnloadEvent unload_event(l_path);)\n+\n@@ -734,0 +740,1 @@\n+    JFR_ONLY(unload_event.set_result(true);)\n@@ -744,0 +751,1 @@\n+    JFR_ONLY(unload_event.set_error_msg(error_report);)\n@@ -815,2 +823,2 @@\n-int os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n-  RESTARTABLE_RETURN_INT(::recv(fd, buf, nBytes, flags));\n+ssize_t os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n+  RESTARTABLE_RETURN_SSIZE_T(::recv(fd, buf, nBytes, flags));\n@@ -819,2 +827,2 @@\n-int os::send(int fd, char* buf, size_t nBytes, uint flags) {\n-  RESTARTABLE_RETURN_INT(::send(fd, buf, nBytes, flags));\n+ssize_t os::send(int fd, char* buf, size_t nBytes, uint flags) {\n+  RESTARTABLE_RETURN_SSIZE_T(::send(fd, buf, nBytes, flags));\n@@ -823,1 +831,1 @@\n-int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {\n+ssize_t os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {\n@@ -827,2 +835,2 @@\n-int os::connect(int fd, struct sockaddr* him, socklen_t len) {\n-  RESTARTABLE_RETURN_INT(::connect(fd, him, len));\n+ssize_t os::connect(int fd, struct sockaddr* him, socklen_t len) {\n+  RESTARTABLE_RETURN_SSIZE_T(::connect(fd, him, len));\n@@ -1224,1 +1232,1 @@\n-  clock_tics_per_sec = sysconf(_SC_CLK_TCK);\n+  clock_tics_per_sec = checked_cast<int>(sysconf(_SC_CLK_TCK));\n@@ -1352,1 +1360,1 @@\n-  DEBUG_ONLY(int max_secs = MAX_SECS;)\n+  DEBUG_ONLY(time_t max_secs = MAX_SECS;)\n@@ -1434,1 +1442,1 @@\n-  return ((double)os::elapsed_counter()) \/ os::elapsed_frequency(); \/\/ nanosecond resolution\n+  return ((double)os::elapsed_counter()) \/ (double)os::elapsed_frequency(); \/\/ nanosecond resolution\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-#define RESTARTABLE_RETURN_INT(_cmd) do { \\\n-  int _result; \\\n+#define RESTARTABLE_RETURN_SSIZE_T(_cmd) do { \\\n+  ssize_t _result; \\\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n@@ -684,1 +686,1 @@\n-  os::print_function_and_library_name(os, handler, buf, buflen,\n+  os::print_function_and_library_name(os, handler, buf, checked_cast<int>(buflen),\n@@ -1742,2 +1744,3 @@\n-    int sig = ::strtol(s, 0, 10);\n-    if (sig > MAX2(SIGSEGV, SIGBUS) &&  \/\/ See 4355769.\n+    int sig;\n+    bool result = parse_integer(s, &sig);\n+    if (result && sig > MAX2(SIGSEGV, SIGBUS) &&  \/\/ See 4355769.\n@@ -1747,2 +1750,2 @@\n-      warning(\"You set _JAVA_SR_SIGNUM=%d. It must be in range [%d, %d]. Using %d instead.\",\n-              sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, PosixSignals::SR_signum);\n+      warning(\"You set _JAVA_SR_SIGNUM=%s. It must be a number in range [%d, %d]. Using %d instead.\",\n+              s, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, PosixSignals::SR_signum);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -67,1 +68,1 @@\n-#include \"runtime\/threads.hpp\"\n+#include \"runtime\/threads.hpp\"\n@@ -72,1 +73,0 @@\n-#include \"services\/memTracker.hpp\"\n@@ -84,0 +84,1 @@\n+#include \"jfr\/support\/jfrNativeLibraryLoadEvent.hpp\"\n@@ -284,0 +285,1 @@\n+#ifndef _WIN64\n@@ -286,0 +288,1 @@\n+#endif\n@@ -287,1 +290,1 @@\n-LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo);\n+static LONG WINAPI Uncaught_Exception_Handler(struct _EXCEPTION_POINTERS* exceptionInfo);\n@@ -401,1 +404,1 @@\n-  prev_uef_handler = SetUnhandledExceptionFilter(Handle_FLT_Exception);\n+  prev_uef_handler = SetUnhandledExceptionFilter(Uncaught_Exception_Handler);\n@@ -429,2 +432,0 @@\n-\/\/ os::current_stack_base()\n-\/\/\n@@ -435,1 +436,1 @@\n-address os::current_stack_base() {\n+void os::current_stack_base_and_size(address* stack_base, size_t* stack_size) {\n@@ -438,1 +439,1 @@\n-  size_t stack_size;\n+  size_t size;\n@@ -441,2 +442,2 @@\n-  stack_bottom =  (address)minfo.AllocationBase;\n-  stack_size = minfo.RegionSize;\n+  stack_bottom = (address)minfo.AllocationBase;\n+  size = minfo.RegionSize;\n@@ -447,1 +448,1 @@\n-    VirtualQuery(stack_bottom+stack_size, &minfo, sizeof(minfo));\n+    VirtualQuery(stack_bottom + size, &minfo, sizeof(minfo));\n@@ -449,1 +450,1 @@\n-      stack_size += minfo.RegionSize;\n+      size += minfo.RegionSize;\n@@ -454,9 +455,2 @@\n-  return stack_bottom + stack_size;\n-}\n-\n-size_t os::current_stack_size() {\n-  size_t sz;\n-  MEMORY_BASIC_INFORMATION minfo;\n-  VirtualQuery(&minfo, &minfo, sizeof(minfo));\n-  sz = (size_t)os::current_stack_base() - (size_t)minfo.AllocationBase;\n-  return sz;\n+  *stack_base = stack_bottom + size;\n+  *stack_size = size;\n@@ -516,0 +510,5 @@\n+enum Ept { EPT_THREAD, EPT_PROCESS, EPT_PROCESS_DIE };\n+\/\/ Wrapper around _endthreadex(), exit() and _exit()\n+[[noreturn]]\n+static void exit_process_or_thread(Ept what, int code);\n+\n@@ -521,1 +520,1 @@\n-unsigned __stdcall os::win32::thread_native_entry(void* t) {\n+static unsigned __stdcall thread_native_entry(void* t) {\n@@ -569,1 +568,2 @@\n-  return (unsigned)os::win32::exit_process_or_thread(os::win32::EPT_THREAD, res);\n+  exit_process_or_thread(EPT_THREAD, res);\n+  return res;\n@@ -756,1 +756,1 @@\n-                             &os::win32::thread_native_entry,\n+                             &thread_native_entry,\n@@ -812,9 +812,1 @@\n-\n-\n-jlong as_long(LARGE_INTEGER x) {\n-  jlong result = 0; \/\/ initialization to avoid warning\n-  set_high(&result, x.HighPart);\n-  set_low(&result, x.LowPart);\n-  return result;\n-}\n-\n+static double nanos_per_count; \/\/ NANOSECS_PER_SEC \/ performance_frequency\n@@ -825,1 +817,1 @@\n-  return as_long(count) - initial_performance_count;\n+  return count.QuadPart - initial_performance_count;\n@@ -989,1 +981,2 @@\n-  performance_frequency = as_long(count);\n+  performance_frequency = count.QuadPart;\n+  nanos_per_count = NANOSECS_PER_SEC \/ (double)performance_frequency;\n@@ -991,1 +984,1 @@\n-  initial_performance_count = as_long(count);\n+  initial_performance_count = count.QuadPart;\n@@ -1093,3 +1086,2 @@\n-    double current = as_long(current_count);\n-    double freq = performance_frequency;\n-    jlong time = (jlong)((current\/freq) * NANOSECS_PER_SEC);\n+    double current = current_count.QuadPart;\n+    jlong time = (jlong)(current * nanos_per_count);\n@@ -1221,1 +1213,1 @@\n-    win32::exit_process_or_thread(win32::EPT_PROCESS, 1);\n+    exit_process_or_thread(EPT_PROCESS, 1);\n@@ -1245,1 +1237,1 @@\n-  win32::exit_process_or_thread(win32::EPT_PROCESS, 1);\n+  exit_process_or_thread(EPT_PROCESS, 1);\n@@ -1250,1 +1242,1 @@\n-  win32::exit_process_or_thread(win32::EPT_PROCESS_DIE, -1);\n+  exit_process_or_thread(EPT_PROCESS_DIE, -1);\n@@ -1258,0 +1250,3 @@\n+\n+  JFR_ONLY(NativeLibraryUnloadEvent unload_event(name);)\n+\n@@ -1261,0 +1256,1 @@\n+    JFR_ONLY(unload_event.set_result(true);)\n@@ -1263,0 +1259,2 @@\n+    char buf[500];\n+    size_t tl = os::lasterror(buf, sizeof(buf));\n@@ -1265,0 +1263,4 @@\n+    if (tl == 0) {\n+      os::snprintf(buf, sizeof(buf), \"Attempt to unload dll failed (error code %d)\", (int) errcode);\n+    }\n+    JFR_ONLY(unload_event.set_error_msg(buf);)\n@@ -1560,5 +1562,3 @@\n-#if INCLUDE_JFR\n-  EventNativeLibraryLoad event;\n-  event.set_name(name);\n-#endif\n-  void * result = LoadLibrary(name);\n+  void* result;\n+  JFR_ONLY(NativeLibraryLoadEvent load_event(name, &result);)\n+  result = LoadLibrary(name);\n@@ -1570,5 +1570,0 @@\n-#if INCLUDE_JFR\n-    event.set_success(true);\n-    event.set_errorMessage(nullptr);\n-    event.commit();\n-#endif\n@@ -1588,5 +1583,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(ebuf);\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(ebuf);)\n@@ -1603,5 +1594,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(\"open on dll file did not work\");\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(\"open on dll file did not work\");)\n@@ -1634,5 +1621,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(\"failed to get lib architecture\");\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(\"failed to get lib architecture\");)\n@@ -1683,5 +1666,1 @@\n-#if INCLUDE_JFR\n-    event.set_success(false);\n-    event.set_errorMessage(\"lib architecture matches, but other error occured\");\n-    event.commit();\n-#endif\n+    JFR_ONLY(load_event.set_error_msg(\"lib architecture matches, but other error occured\");)\n@@ -1701,6 +1680,1 @@\n-#if INCLUDE_JFR\n-  event.set_success(false);\n-  event.set_errorMessage(ebuf);\n-  event.commit();\n-#endif\n-\n+  JFR_ONLY(load_event.set_error_msg(ebuf);)\n@@ -1793,1 +1767,1 @@\n-  return t1 - t2;\n+  return primitive_compare(t1, t2);\n@@ -2275,1 +2249,1 @@\n-    return ::signal(sig, handler);\n+    return CAST_FROM_FN_PTR(void*, ::signal(sig, handler));\n@@ -2513,2 +2487,2 @@\n-  assert(pc[0] == 0x83, \"not an sdiv opcode\"); \/\/Fixme did i get the right opcode?\n-  assert(ctx->X4 == min_jint, \"unexpected idiv exception\");\n+  guarantee(pc[0] == 0x83, \"not an sdiv opcode(0x83), the actual value = 0x%x\", pc[0]); \/\/Fixme did i get the right opcode?\n+  guarantee(ctx->X4 == min_jint, \"unexpected idiv exception, the actual value = %d while the expected is %d\", ctx->X4, min_jint);\n@@ -2523,2 +2497,4 @@\n-  assert(pc[0] >= Assembler::REX && pc[0] <= Assembler::REX_WRXB && pc[1] == 0xF7 || pc[0] == 0xF7, \"not an idiv opcode\");\n-  assert(pc[0] >= Assembler::REX && pc[0] <= Assembler::REX_WRXB && (pc[2] & ~0x7) == 0xF8 || (pc[1] & ~0x7) == 0xF8, \"cannot handle non-register operands\");\n+  guarantee(pc[0] >= Assembler::REX && pc[0] <= Assembler::REX_WRXB && pc[1] == 0xF7 || pc[0] == 0xF7,\n+            \"not an idiv opcode, pc[0] = 0x%x and pc[1] = 0x%x\", pc[0], pc[1]);\n+  guarantee(pc[0] >= Assembler::REX && pc[0] <= Assembler::REX_WRXB && (pc[2] & ~0x7) == 0xF8 || (pc[1] & ~0x7) == 0xF8,\n+            \"cannot handle non-register operands, pc[0] = 0x%x, pc[1] = 0x%x and pc[2] = 0x%x\", pc[0], pc[1], pc[2]);\n@@ -2539,3 +2515,3 @@\n-  assert(pc[0] == 0xF7, \"not an idiv opcode\");\n-  assert((pc[1] & ~0x7) == 0xF8, \"cannot handle non-register operands\");\n-  assert(ctx->Eax == min_jint, \"unexpected idiv exception\");\n+  guarantee(pc[0] == 0xF7, \"not an idiv opcode(0xF7), the actual value = 0x%x\", pc[1]);\n+  guarantee((pc[1] & ~0x7) == 0xF8, \"cannot handle non-register operands, the actual value = 0x%x\", pc[1]);\n+  guarantee(ctx->Eax == min_jint, \"unexpected idiv exception, the actual value = %d while the expected is %d\", ctx->Eax, min_jint);\n@@ -2553,3 +2529,1 @@\n-LONG WINAPI Handle_FLT_Exception(struct _EXCEPTION_POINTERS* exceptionInfo) {\n-  PCONTEXT ctx = exceptionInfo->ContextRecord;\n-#ifndef  _WIN64\n+static bool handle_FLT_exception(struct _EXCEPTION_POINTERS* exceptionInfo) {\n@@ -2566,1 +2540,3 @@\n-  case EXCEPTION_FLT_UNDERFLOW:\n+  case EXCEPTION_FLT_UNDERFLOW: {\n+    PCONTEXT ctx = exceptionInfo->ContextRecord;\n+#ifndef  _WIN64\n@@ -2573,1 +2549,1 @@\n-      return EXCEPTION_CONTINUE_EXECUTION;\n+      return true;\n@@ -2575,0 +2551,23 @@\n+#else \/\/ !_WIN64\n+    \/\/ On Windows, the mxcsr control bits are non-volatile across calls\n+    \/\/ See also CR 6192333\n+    \/\/\n+    jint MxCsr = INITIAL_MXCSR;\n+    \/\/ we can't use StubRoutines::x86::addr_mxcsr_std()\n+    \/\/ because in Win64 mxcsr is not saved there\n+    if (MxCsr != ctx->MxCsr) {\n+      ctx->MxCsr = MxCsr;\n+      return true;\n+    }\n+#endif \/\/ !_WIN64\n+  }\n+  }\n+\n+  return false;\n+}\n+#endif\n+\n+#ifndef _WIN64\n+static LONG WINAPI Uncaught_Exception_Handler(struct _EXCEPTION_POINTERS* exceptionInfo) {\n+  if (handle_FLT_exception(exceptionInfo)) {\n+    return EXCEPTION_CONTINUE_EXECUTION;\n@@ -2577,0 +2576,1 @@\n+  \/\/ we only override this on 32 bits, so only check it there\n@@ -2582,12 +2582,0 @@\n-#else \/\/ !_WIN64\n-  \/\/ On Windows, the mxcsr control bits are non-volatile across calls\n-  \/\/ See also CR 6192333\n-  \/\/\n-  jint MxCsr = INITIAL_MXCSR;\n-  \/\/ we can't use StubRoutines::x86::addr_mxcsr_std()\n-  \/\/ because in Win64 mxcsr is not saved there\n-  if (MxCsr != ctx->MxCsr) {\n-    ctx->MxCsr = MxCsr;\n-    return EXCEPTION_CONTINUE_EXECUTION;\n-  }\n-#endif \/\/ !_WIN64\n@@ -2850,3 +2838,2 @@\n-    if ((in_java || in_native) && exception_code != EXCEPTION_UNCAUGHT_CXX_EXCEPTION) {\n-      LONG result=Handle_FLT_Exception(exceptionInfo);\n-      if (result==EXCEPTION_CONTINUE_EXECUTION) return result;\n+    if ((in_java || in_native) && handle_FLT_exception(exceptionInfo)) {\n+      return EXCEPTION_CONTINUE_EXECUTION;\n@@ -2915,2 +2902,2 @@\n-  if (InterceptOSException) goto exit;\n-  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n+  if (!InterceptOSException) {\n+    DWORD exceptionCode = exceptionInfo->ExceptionRecord->ExceptionCode;\n@@ -2918,1 +2905,1 @@\n-  address pc = (address)exceptionInfo->ContextRecord->Pc;\n+    address pc = (address) exceptionInfo->ContextRecord->Pc;\n@@ -2920,1 +2907,1 @@\n-  address pc = (address) exceptionInfo->ContextRecord->Rip;\n+    address pc = (address) exceptionInfo->ContextRecord->Rip;\n@@ -2922,1 +2909,1 @@\n-  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+    address pc = (address) exceptionInfo->ContextRecord->Eip;\n@@ -2924,1 +2911,1 @@\n-  Thread* t = Thread::current_or_null_safe();\n+    Thread* thread = Thread::current_or_null_safe();\n@@ -2926,3 +2913,4 @@\n-  if (exception_code != EXCEPTION_BREAKPOINT) {\n-    report_error(t, exception_code, pc, exceptionInfo->ExceptionRecord,\n-                exceptionInfo->ContextRecord);\n+    if (exceptionCode != EXCEPTION_BREAKPOINT) {\n+      report_error(thread, exceptionCode, pc, exceptionInfo->ExceptionRecord,\n+                  exceptionInfo->ContextRecord);\n+    }\n@@ -2930,1 +2918,1 @@\n-exit:\n+\n@@ -3454,0 +3442,5 @@\n+size_t os::vm_min_address() {\n+  assert(is_aligned(_vm_min_address_default, os::vm_allocation_granularity()), \"Sanity\");\n+  return _vm_min_address_default;\n+}\n+\n@@ -3839,1 +3832,1 @@\n-size_t os::numa_get_leaf_groups(int *ids, size_t size) {\n+size_t os::numa_get_leaf_groups(uint *ids, size_t size) {\n@@ -3848,1 +3841,2 @@\n-      ids[i] = numa_node_list_holder.get_node_list_entry(i);\n+      int node_id = numa_node_list_holder.get_node_list_entry(i);\n+      ids[i] = checked_cast<uint>(node_id);\n@@ -4103,1 +4097,1 @@\n-int os::win32::exit_process_or_thread(Ept what, int exit_code) {\n+static void exit_process_or_thread(Ept what, int exit_code) {\n@@ -4281,1 +4275,1 @@\n-  return exit_code;\n+  os::infinite_sleep();\n@@ -4884,1 +4878,1 @@\n-  win32::exit_process_or_thread(win32::EPT_PROCESS, num);\n+  exit_process_or_thread(EPT_PROCESS, num);\n@@ -4888,1 +4882,1 @@\n-  win32::exit_process_or_thread(win32::EPT_PROCESS_DIE, num);\n+  exit_process_or_thread(EPT_PROCESS_DIE, num);\n@@ -5673,1 +5667,1 @@\n-int os::connect(int fd, struct sockaddr* him, socklen_t len) {\n+ssize_t os::connect(int fd, struct sockaddr* him, socklen_t len) {\n@@ -5677,1 +5671,1 @@\n-int os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n+ssize_t os::recv(int fd, char* buf, size_t nBytes, uint flags) {\n@@ -5681,1 +5675,1 @@\n-int os::send(int fd, char* buf, size_t nBytes, uint flags) {\n+ssize_t os::send(int fd, char* buf, size_t nBytes, uint flags) {\n@@ -5685,1 +5679,1 @@\n-int os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {\n+ssize_t os::raw_send(int fd, char* buf, size_t nBytes, uint flags) {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":121,"deletions":127,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -74,7 +74,0 @@\n-  \/\/ The handler passed to _beginthreadex().\n-  \/\/ Called with the associated Thread* as the argument.\n-  static unsigned __stdcall thread_native_entry(void*);\n-\n-  enum Ept { EPT_THREAD, EPT_PROCESS, EPT_PROCESS_DIE };\n-  \/\/ Wrapper around _endthreadex(), exit() and _exit()\n-  static int exit_process_or_thread(Ept what, int exit_code);\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-\/\/ needed by current_stack_region() workaround for Mavericks\n+\/\/ needed by current_stack_base_and_size() workaround for Mavericks\n@@ -721,2 +721,3 @@\n-\/\/ ** P1 (aka bottom) and size ( P2 = P1 - size) are the address and stack size returned from\n-\/\/    pthread_attr_getstack()\n+\/\/ ** P1 (aka bottom) and size are the address and stack size\n+\/\/    returned from pthread_attr_getstack().\n+\/\/ ** P2 (aka stack top or base) = P1 + size\n@@ -724,1 +725,2 @@\n-static void current_stack_region(address * bottom, size_t * size) {\n+void os::current_stack_base_and_size(address* base, size_t* size) {\n+  address bottom;\n@@ -727,1 +729,1 @@\n-  void *stacktop = pthread_get_stackaddr_np(self);\n+  *base = (address) pthread_get_stackaddr_np(self);\n@@ -750,1 +752,1 @@\n-  *bottom = (address) stacktop - *size;\n+  bottom = *base - *size;\n@@ -758,2 +760,3 @@\n-  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);\n-  *size   = ss.ss_size;\n+  *base = (address) ss.ss_sp;\n+  *size = ss.ss_size;\n+  bottom = *base - *size;\n@@ -774,2 +777,2 @@\n-  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||\n-    pthread_attr_getstacksize(&attr, size) != 0) {\n+  if (pthread_attr_getstackaddr(&attr, (void **)&bottom) != 0 ||\n+      pthread_attr_getstacksize(&attr, size) != 0) {\n@@ -779,0 +782,2 @@\n+  *base = bottom + *size;\n+\n@@ -781,17 +786,2 @@\n-  assert(os::current_stack_pointer() >= *bottom &&\n-         os::current_stack_pointer() < *bottom + *size, \"just checking\");\n-}\n-\n-address os::current_stack_base() {\n-  address bottom;\n-  size_t size;\n-  current_stack_region(&bottom, &size);\n-  return (bottom + size);\n-}\n-\n-size_t os::current_stack_size() {\n-  \/\/ stack size includes normal stack and HotSpot guard pages\n-  address bottom;\n-  size_t size;\n-  current_stack_region(&bottom, &size);\n-  return size;\n+  assert(os::current_stack_pointer() >= bottom &&\n+         os::current_stack_pointer() < *base, \"just checking\");\n@@ -866,1 +856,1 @@\n-  print_instructions(st, pc, sizeof(char));\n+  print_instructions(st, pc);\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":18,"deletions":28,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -51,1 +52,0 @@\n-#include \"services\/memTracker.hpp\"\n@@ -475,1 +475,1 @@\n-    size_t len = sizeof(data);\n+    int len = (int)sizeof(data);\n@@ -583,1 +583,1 @@\n-  print_instructions(st, pc, sizeof(char));\n+  print_instructions(st, pc);\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+  template(java_util_DualPivotQuicksort,              \"java\/util\/DualPivotQuicksort\")             \\\n@@ -381,0 +382,1 @@\n+  template(java_lang_ClassFrameInfo,                  \"java\/lang\/ClassFrameInfo\")                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2203,2 +2203,2 @@\n-  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n-            capacity()\/K, heap_used\/K);\n+  st->print(\" total reserved %zuK, committed %zuK, used %zuK\",\n+            _hrm.reserved().byte_size()\/K, capacity()\/K, heap_used\/K);\n@@ -2220,1 +2220,1 @@\n-    const int* node_ids = _numa->node_ids();\n+    const uint* node_ids = _numa->node_ids();\n@@ -2223,1 +2223,1 @@\n-      st->print(\"%d=%u \", node_ids[node_index], num_free_regions);\n+      st->print(\"%u=%u \", node_ids[node_index], num_free_regions);\n@@ -3013,2 +3013,1 @@\n-      \/\/ HeapRegion::add_code_root_locked() avoids adding duplicate entries.\n-      hr->add_code_root_locked(_nm);\n+      hr->add_code_root(_nm);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -220,1 +220,8 @@\n-  const size_t used_after_gc = capacity_after_gc - _g1h->unused_committed_regions_in_bytes();\n+  const size_t used_after_gc = capacity_after_gc -\n+                               _g1h->unused_committed_regions_in_bytes() -\n+                               \/\/ Discount space used by current Eden to establish a\n+                               \/\/ situation during Remark similar to at the end of full\n+                               \/\/ GC where eden is empty. During Remark there can be an\n+                               \/\/ arbitrary number of eden regions which would skew the\n+                               \/\/ results.\n+                               _g1h->eden_regions_count() * HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -84,1 +85,0 @@\n-#include \"services\/memTracker.hpp\"\n@@ -2070,3 +2070,10 @@\n-    CodeCache::UnloadingScope scope(is_alive_closure());\n-    \/\/ Follow system dictionary roots and unload classes.\n-    bool purged_class = SystemDictionary::do_unloading(&_gc_timer);\n+    bool unloading_occurred;\n+    {\n+      CodeCache::UnlinkingScope scope(is_alive_closure());\n+\n+      \/\/ Follow system dictionary roots and unload classes.\n+      unloading_occurred = SystemDictionary::do_unloading(&_gc_timer);\n+\n+      \/\/ Unload nmethods.\n+      CodeCache::do_unloading(unloading_occurred);\n+    }\n@@ -2075,2 +2082,2 @@\n-    \/\/ Unload nmethods.\n-    CodeCache::do_unloading(purged_class);\n+    \/\/ Release unloaded nmethods's memory.\n+    CodeCache::flush_unlinked_nmethods();\n@@ -2079,1 +2086,1 @@\n-    Klass::clean_weak_klass_links(purged_class);\n+    Klass::clean_weak_klass_links(unloading_occurred);\n@@ -2082,1 +2089,1 @@\n-    JVMCI_ONLY(JVMCI::do_unloading(purged_class));\n+    JVMCI_ONLY(JVMCI::do_unloading(unloading_occurred));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  SerialHeap* gch = SerialHeap::heap();\n@@ -566,1 +566,1 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  SerialHeap* gch = SerialHeap::heap();\n@@ -702,1 +702,1 @@\n-                        GenCollectedHeap::heap()->incremental_collection_will_fail(false \/* don't consult_young *\/) ?\n+                        SerialHeap::heap()->incremental_collection_will_fail(false \/* don't consult_young *\/) ?\n@@ -726,1 +726,1 @@\n-    GCPolicyCounters* gc_counters = GenCollectedHeap::heap()->counters();\n+    GCPolicyCounters* gc_counters = SerialHeap::heap()->counters();\n@@ -856,2 +856,0 @@\n-    \/\/ Inform the next generation that a promotion failure occurred.\n-    _old_gen->promotion_failure_occurred();\n@@ -1021,2 +1019,1 @@\n-    GenCollectedHeap* gch = GenCollectedHeap::heap();\n-    _old_gen = gch->old_gen();\n+    _old_gen = SerialHeap::heap()->old_gen();\n@@ -1035,1 +1032,1 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  SerialHeap* gch = SerialHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -459,1 +460,1 @@\n-  if (DumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_heap()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-  \/\/ that of GenCollectedHeap::ensure_parsability().\n+  \/\/ that of ParallelScavengeHeap::ensure_parsability().\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,2 +247,1 @@\n-  JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,\n-  JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,\n+  JVM_STACKWALK_CLASS_INFO_ONLY            = 0x2,\n@@ -253,0 +252,3 @@\n+JNIEXPORT void JNICALL\n+JVM_ExpandStackFrameInfo(JNIEnv *env, jobject obj);\n+\n@@ -254,1 +256,1 @@\n-JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,\n+JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jint mode,\n@@ -256,1 +258,1 @@\n-                  jint frame_count, jint start_index, jobjectArray frames);\n+                  jint buffer_size, jint start_index, jobjectArray frames);\n@@ -259,2 +261,2 @@\n-JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,\n-                  jint frame_count, jint start_index,\n+JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jint mode, jlong anchor,\n+                  jint last_batch_count, jint buffer_size, jint start_index,\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrType.hpp\"\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -40,0 +38,2 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/jfrType.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -41,1 +41,1 @@\n-#include \"jfr\/writers\/jfrJavaEventWriter.hpp\"\n+#include \"jfr\/writers\/jfrJavaEventWriter.hpp\"\n@@ -48,0 +48,1 @@\n+#include \"nmt\/nmtCommon.hpp\"\n@@ -56,1 +57,0 @@\n-#include \"services\/nmtCommon.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +52,2 @@\n-  const size_t sz = Message::calc_size(strlen(msg));\n+  const size_t len = strlen(msg);\n+  const size_t sz = Message::calc_size(len);\n@@ -57,1 +59,1 @@\n-    new(_buf + _pos) Message(output, decorations, msg);\n+    new(_buf + _pos) Message(output, decorations, msg, len);\n@@ -117,23 +119,1 @@\n-void AsyncLogWriter::write() {\n-  ResourceMark rm;\n-  AsyncLogMap<AnyObj::RESOURCE_AREA> snapshot;\n-\n-  \/\/ lock protection. This guarantees I\/O jobs don't block logsites.\n-  {\n-    AsyncLogLocker locker;\n-\n-    _buffer_staging->reset();\n-    swap(_buffer, _buffer_staging);\n-\n-    \/\/ move counters to snapshot and reset them.\n-    _stats.iterate([&] (LogFileStreamOutput* output, uint32_t& counter) {\n-      if (counter > 0) {\n-        bool created = snapshot.put(output, counter);\n-        assert(created == true, \"sanity check\");\n-        counter = 0;\n-      }\n-      return true;\n-    });\n-    _data_available = false;\n-  }\n-\n+void AsyncLogWriter::write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot) {\n@@ -160,1 +140,1 @@\n-      output->write_blocking(decorations, ss.as_string(false));\n+      output->write_blocking(decorations, ss.freeze());\n@@ -173,0 +153,2 @@\n+    ResourceMark rm;\n+    AsyncLogMap<AnyObj::RESOURCE_AREA> snapshot;\n@@ -179,0 +161,15 @@\n+      \/\/ Only doing a swap and statistics under the lock to\n+      \/\/ guarantee that I\/O jobs don't block logsites.\n+      _buffer_staging->reset();\n+      swap(_buffer, _buffer_staging);\n+\n+      \/\/ move counters to snapshot and reset them.\n+      _stats.iterate([&] (LogFileStreamOutput* output, uint32_t& counter) {\n+        if (counter > 0) {\n+          bool created = snapshot.put(output, counter);\n+          assert(created == true, \"sanity check\");\n+          counter = 0;\n+        }\n+        return true;\n+      });\n+      _data_available = false;\n@@ -180,2 +177,1 @@\n-\n-    write();\n+    write(snapshot);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +70,1 @@\n-  \/\/ Messsage is the envelop of a log line and its associative data.\n+  \/\/ Messsage is the envelope of a log line and its associative data.\n@@ -75,1 +76,1 @@\n-  \/\/ |_output|_decorations|\"a log line\", |pad| <- pointer aligned.\n+  \/\/ |_output|_decorations|\"a log line\", |pad| <- Message aligned.\n@@ -87,1 +88,2 @@\n-    Message(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg)\n+    \/\/ msglen excludes NUL-byte\n+    Message(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msglen)\n@@ -90,2 +92,1 @@\n-      PRAGMA_STRINGOP_OVERFLOW_IGNORED\n-      strcpy(reinterpret_cast<char* >(this+1), msg);\n+      memcpy(reinterpret_cast<char* >(this+1), msg, msglen + 1);\n@@ -96,1 +97,1 @@\n-      return align_up(sizeof(Message) + message_len + 1, sizeof(void*));\n+      return align_up(sizeof(Message) + message_len + 1, alignof(Message));\n@@ -117,0 +118,2 @@\n+      \/\/ Ensure _pos is Message-aligned\n+      _pos = align_up(_buf, alignof(Message)) - _buf;\n@@ -127,1 +130,4 @@\n-    void reset() { _pos = 0; }\n+    void reset() {\n+      \/\/ Ensure _pos is Message-aligned\n+      _pos = align_up(_buf, alignof(Message)) - _buf;\n+    }\n@@ -171,1 +177,1 @@\n-  void write();\n+  void write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot);\n@@ -177,1 +183,0 @@\n-  const char* name() const override { return \"AsyncLog Thread\"; }\n@@ -204,0 +209,2 @@\n+\n+  const char* name() const override { return \"AsyncLog Thread\"; }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -508,0 +508,6 @@\n+  } else if (strcmp(outputstr, StdoutLog->name()) == 0) { \/\/ stdout\n+    idx = 0;\n+    assert(find_output(outputstr) == idx, \"sanity check\");\n+  } else if (strcmp(outputstr, StderrLog->name()) == 0) { \/\/ stderr\n+    idx = 1;\n+    assert(find_output(outputstr) == idx, \"sanity check\");\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -61,1 +62,0 @@\n-#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -99,0 +100,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -105,0 +107,1 @@\n+#include \"utilities\/zipLibrary.hpp\"\n@@ -545,1 +548,1 @@\n-  java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);\n+  java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, CHECK);\n@@ -550,0 +553,2 @@\n+JVM_ENTRY(void, JVM_ExpandStackFrameInfo(JNIEnv *env, jobject obj))\n+  Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(obj));\n@@ -551,0 +556,12 @@\n+  bool have_name = (java_lang_StackFrameInfo::name(stack_frame_info()) != nullptr);\n+  bool have_type = (java_lang_StackFrameInfo::type(stack_frame_info()) != nullptr);\n+  Method* method = java_lang_StackFrameInfo::get_method(stack_frame_info());\n+  if (!have_name) {\n+    oop name = StringTable::intern(method->name(), CHECK);\n+    java_lang_StackFrameInfo::set_name(stack_frame_info(), name);\n+  }\n+  if (!have_type) {\n+    Handle type = java_lang_String::create_from_symbol(method->signature(), CHECK);\n+    java_lang_StackFrameInfo::set_type(stack_frame_info(), type());\n+  }\n+JVM_END\n@@ -552,1 +569,1 @@\n-JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,\n+JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jint mode,\n@@ -554,1 +571,1 @@\n-                                     jint frame_count, jint start_index, jobjectArray frames))\n+                                     jint buffer_size, jint start_index, jobjectArray frames))\n@@ -562,1 +579,1 @@\n-  \/\/ frames array is a Class<?>[] array when only getting caller reference,\n+  \/\/ frames array is a ClassFrameInfo[] array when only getting caller reference,\n@@ -568,2 +585,1 @@\n-  int limit = start_index + frame_count;\n-  if (frames_array_h->length() < limit) {\n+  if (frames_array_h->length() < buffer_size) {\n@@ -574,1 +590,1 @@\n-                               frame_count, start_index, frames_array_h, CHECK_NULL);\n+                               buffer_size, start_index, frames_array_h, CHECK_NULL);\n@@ -579,2 +595,2 @@\n-JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,\n-                                  jint frame_count, jint start_index,\n+JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jint mode, jlong anchor,\n+                                  jint last_batch_count, jint buffer_size, jint start_index,\n@@ -582,1 +598,1 @@\n-  \/\/ frames array is a Class<?>[] array when only getting caller reference,\n+  \/\/ frames array is a ClassFrameInfo[] array when only getting caller reference,\n@@ -588,2 +604,1 @@\n-  int limit = start_index+frame_count;\n-  if (frames_array_h->length() < limit) {\n+  if (frames_array_h->length() < buffer_size) {\n@@ -594,1 +609,1 @@\n-  return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,\n+  return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, last_batch_count, buffer_size,\n@@ -3403,2 +3418,1 @@\n-  ClassLoader::load_zip_library_if_needed();\n-  return ClassLoader::zip_library_handle();\n+  return ZipLibrary::handle();\n@@ -3597,1 +3611,1 @@\n-  if (!Arguments::is_dumping_archive()) {\n+  if (!CDSConfig::is_dumping_archive()) {\n@@ -3685,1 +3699,1 @@\n-  return Arguments::is_dumping_archive();\n+  return CDSConfig::is_dumping_archive();\n@@ -3716,1 +3730,1 @@\n-  return ClassListWriter::is_enabled() || DynamicDumpSharedSpaces;\n+  return ClassListWriter::is_enabled() || CDSConfig::is_dumping_dynamic_archive();\n@@ -3724,1 +3738,1 @@\n-  assert(ClassListWriter::is_enabled() || DynamicDumpSharedSpaces,  \"Should be set and open or do dynamic dump\");\n+  assert(ClassListWriter::is_enabled() || CDSConfig::is_dumping_dynamic_archive(),  \"Should be set and open or do dynamic dump\");\n@@ -3729,1 +3743,1 @@\n-    if (DynamicDumpSharedSpaces) {\n+    if (CDSConfig::is_dumping_dynamic_archive()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":34,"deletions":20,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -189,0 +189,2 @@\n+  static bool profile_all_receivers_at_type_check() { return true; }\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"nmt\/nmtCommon.hpp\"\n@@ -63,1 +65,1 @@\n-#include \"services\/nmtCommon.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n@@ -134,0 +136,3 @@\n+\/\/ True if -Xint\/-Xmixed\/-Xcomp were specified\n+static bool mode_flag_cmd_line = false;\n+\n@@ -528,0 +533,6 @@\n+  { \"DoReserveCopyInSuperWord\",     JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+\n+#ifdef LINUX\n+  { \"UseHugeTLBFS\",                 JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+  { \"UseSHM\",                       JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+#endif\n@@ -1188,1 +1199,1 @@\n-  char quote_c        = 0;\n+  int  quote_c        = 0;\n@@ -1200,1 +1211,1 @@\n-          token[pos++] = c;\n+          token[pos++] = checked_cast<char>(c);\n@@ -1220,1 +1231,1 @@\n-        token[pos++] = c;\n+        token[pos++] = checked_cast<char>(c);\n@@ -1270,2 +1281,1 @@\n-  if (is_internal_module_property(key) ||\n-      strcmp(key, \"jdk.module.main\") == 0) {\n+  if (is_internal_module_property(key)) {\n@@ -1344,1 +1354,1 @@\n-  assert(is_dumping_archive(),\n+  assert(CDSConfig::is_dumping_archive(),\n@@ -1584,1 +1594,1 @@\n-    MaxRAMPercentage = 100.0 \/ MaxRAMFraction;\n+    MaxRAMPercentage = 100.0 \/ (double)MaxRAMFraction;\n@@ -1588,1 +1598,1 @@\n-    MinRAMPercentage = 100.0 \/ MinRAMFraction;\n+    MinRAMPercentage = 100.0 \/ (double)MinRAMFraction;\n@@ -1592,1 +1602,1 @@\n-    InitialRAMPercentage = 100.0 \/ InitialRAMFraction;\n+    InitialRAMPercentage = 100.0 \/ (double)InitialRAMFraction;\n@@ -1598,2 +1608,2 @@\n-    julong reasonable_max = (julong)((phys_mem * MaxRAMPercentage) \/ 100);\n-    const julong reasonable_min = (julong)((phys_mem * MinRAMPercentage) \/ 100);\n+    julong reasonable_max = (julong)(((double)phys_mem * MaxRAMPercentage) \/ 100);\n+    const julong reasonable_min = (julong)(((double)phys_mem * MinRAMPercentage) \/ 100);\n@@ -1683,1 +1693,1 @@\n-      julong reasonable_initial = (julong)((phys_mem * InitialRAMPercentage) \/ 100);\n+      julong reasonable_initial = (julong)(((double)phys_mem * InitialRAMPercentage) \/ 100);\n@@ -1921,2 +1931,1 @@\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n@@ -1929,9 +1938,0 @@\n-  if (UseHeavyMonitors) {\n-    if (FLAG_IS_CMDLINE(LockingMode) && LockingMode != LM_MONITOR) {\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"Conflicting -XX:+UseHeavyMonitors and -XX:LockingMode=%d flags\\n\", LockingMode);\n-      return false;\n-    }\n-    FLAG_SET_CMDLINE(LockingMode, LM_MONITOR);\n-  }\n-\n@@ -1984,4 +1984,4 @@\n-bool Arguments::parse_uintx(const char* value,\n-                            uintx* uintx_arg,\n-                            uintx min_size) {\n-  uintx n;\n+bool Arguments::parse_uint(const char* value,\n+                           uint* uint_arg,\n+                           uint min_size) {\n+  uint n;\n@@ -1992,1 +1992,1 @@\n-    *uintx_arg = n;\n+    *uint_arg = n;\n@@ -2686,0 +2686,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2689,0 +2690,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2693,0 +2695,1 @@\n+          mode_flag_cmd_line = true;\n@@ -2812,2 +2815,2 @@\n-      uintx max_tenuring_thresh = 0;\n-      if (!parse_uintx(tail, &max_tenuring_thresh, 0)) {\n+      uint max_tenuring_thresh = 0;\n+      if (!parse_uint(tail, &max_tenuring_thresh, 0)) {\n@@ -3124,8 +3127,12 @@\n-    \/\/ Compiler threads may concurrently update the class metadata (such as method entries), so it's\n-    \/\/ unsafe with -Xshare:dump (which modifies the class metadata in place). Let's disable\n-    \/\/ compiler just to be safe.\n-    \/\/\n-    \/\/ Note: this is not a concern for dynamically dumping shared spaces, which makes a copy of the\n-    \/\/ class metadata instead of modifying them in place. The copy is inaccessible to the compiler.\n-    \/\/ TODO: revisit the following for the static archive case.\n-    set_mode_flags(_int);\n+    if (!mode_flag_cmd_line) {\n+      \/\/ By default, -Xshare:dump runs in interpreter-only mode, which is required for deterministic archive.\n+      \/\/\n+      \/\/ If your classlist is large and you don't care about deterministic dumping, you can use\n+      \/\/ -Xshare:dump -Xmixed to improve dumping speed.\n+      set_mode_flags(_int);\n+    } else if (_mode == _comp) {\n+      \/\/ -Xcomp may use excessive CPU for the test tiers. Also, -Xshare:dump runs a small and fixed set of\n+      \/\/ Java code, so there's not much benefit in running -Xcomp.\n+      log_info(cds)(\"reduced -Xcomp to -Xmixed for static dumping\");\n+      set_mode_flags(_mixed);\n+    }\n@@ -3147,1 +3154,1 @@\n-    DynamicDumpSharedSpaces = false;\n+    CDSConfig::disable_dumping_dynamic_archive();\n@@ -3149,1 +3156,1 @@\n-    DynamicDumpSharedSpaces = true;\n+    CDSConfig::enable_dumping_dynamic_archive();\n@@ -3170,1 +3177,1 @@\n-  if (DumpSharedSpaces || DynamicDumpSharedSpaces) {\n+  if (CDSConfig::is_dumping_archive()) {\n@@ -3549,1 +3556,1 @@\n-    if (is_dumping_archive() && archives > 1) {\n+    if (CDSConfig::is_dumping_archive() && archives > 1) {\n@@ -3581,1 +3588,1 @@\n-            DynamicDumpSharedSpaces = true;\n+            CDSConfig::enable_dumping_dynamic_archive();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":51,"deletions":44,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -385,4 +385,4 @@\n-  \/\/ parameter passed and returns the value in uintx_arg.  Returns\n-  \/\/ false otherwise, with uintx_arg undefined.\n-  static bool parse_uintx(const char* value, uintx* uintx_arg,\n-                          uintx min_size);\n+  \/\/ parameter passed and returns the value in uint_arg.  Returns\n+  \/\/ false otherwise, with uint_arg undefined.\n+  static bool parse_uint(const char* value, uint* uintx_arg,\n+                         uint min_size);\n@@ -532,6 +532,0 @@\n-  static bool is_dumping_archive() { return DumpSharedSpaces || DynamicDumpSharedSpaces; }\n-\n-  static void assert_is_dumping_archive() {\n-    assert(Arguments::is_dumping_archive(), \"dump time only\");\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -438,0 +438,4 @@\n+  product(uint64_t, AbortVMOnSafepointTimeoutDelay, 0, DIAGNOSTIC,          \\\n+          \"Delay in milliseconds for option AbortVMOnSafepointTimeout\")     \\\n+          range(0, max_jlong)                                               \\\n+                                                                            \\\n@@ -451,1 +455,1 @@\n-  product(uintx, LogEventsBufferEntries, 20, DIAGNOSTIC,                    \\\n+  product(int, LogEventsBufferEntries, 20, DIAGNOSTIC,                      \\\n@@ -561,1 +565,1 @@\n-  product(intx, HeapDumpGzipLevel, 0, MANAGEABLE,                           \\\n+  product(int, HeapDumpGzipLevel, 0, MANAGEABLE,                            \\\n@@ -734,1 +738,1 @@\n-          \"at one time (minimum is 1024).\")                      \\\n+          \"at one time (minimum is 1024).\")                                 \\\n@@ -737,1 +741,1 @@\n-  product(intx, MonitorUsedDeflationThreshold, 90, DIAGNOSTIC,              \\\n+  product(int, MonitorUsedDeflationThreshold, 90, DIAGNOSTIC,               \\\n@@ -1063,4 +1067,0 @@\n-  develop(bool, UseHeavyMonitors, false,                                    \\\n-          \"(Deprecated) Use heavyweight instead of lightweight Java \"       \\\n-          \"monitors\")                                                       \\\n-                                                                            \\\n@@ -1069,1 +1069,1 @@\n-          \"+UseHeavyMonitors\")                                              \\\n+          \"-XX:LockingMode=0 (LM_MONITOR)\")                                 \\\n@@ -1109,1 +1109,1 @@\n-  develop(intx, FastAllocateSizeLimit, 128*K,                               \\\n+  develop(int, FastAllocateSizeLimit, 128*K,                                \\\n@@ -1242,1 +1242,1 @@\n-  product(intx,  AllocatePrefetchStyle, 1,                                  \\\n+  product(int,  AllocatePrefetchStyle, 1,                                   \\\n@@ -1249,1 +1249,1 @@\n-  product(intx,  AllocatePrefetchDistance, -1,                              \\\n+  product(int,  AllocatePrefetchDistance, -1,                               \\\n@@ -1254,1 +1254,1 @@\n-  product(intx,  AllocatePrefetchLines, 3,                                  \\\n+  product(int,  AllocatePrefetchLines, 3,                                   \\\n@@ -1258,1 +1258,1 @@\n-  product(intx,  AllocateInstancePrefetchLines, 1,                          \\\n+  product(int,  AllocateInstancePrefetchLines, 1,                           \\\n@@ -1263,1 +1263,1 @@\n-  product(intx,  AllocatePrefetchStepSize, 16,                              \\\n+  product(int,  AllocatePrefetchStepSize, 16,                               \\\n@@ -1316,1 +1316,1 @@\n-  develop(intx, StackPrintLimit, 100,                                       \\\n+  develop(int, StackPrintLimit, 100,                                        \\\n@@ -1323,1 +1323,1 @@\n-  notproduct(intx, MaxElementPrintSize, 256,                                \\\n+  notproduct(int, MaxElementPrintSize, 256,                                 \\\n@@ -1427,0 +1427,3 @@\n+  develop(bool, RandomizeClassSpaceLocation, true,                          \\\n+          \"Randomize location of class space.\")                             \\\n+                                                                            \\\n@@ -1465,1 +1468,1 @@\n-  product(uintx, MaxMetaspaceFreeRatio,    70,                              \\\n+  product(uint, MaxMetaspaceFreeRatio,    70,                               \\\n@@ -1471,1 +1474,1 @@\n-  product(uintx, MinMetaspaceFreeRatio,    40,                              \\\n+  product(uint, MinMetaspaceFreeRatio,    40,                               \\\n@@ -1750,1 +1753,1 @@\n-  product(intx, PerfDataSamplingInterval, 50,                               \\\n+  product(int, PerfDataSamplingInterval, 50,                                \\\n@@ -1893,4 +1896,0 @@\n-  product(size_t, ArrayAllocatorMallocLimit, SIZE_MAX, EXPERIMENTAL,        \\\n-          \"Allocation less than this value will be allocated \"              \\\n-          \"using malloc. Larger allocations will use mmap.\")                \\\n-                                                                            \\\n@@ -2047,1 +2046,1 @@\n-  product(int, LockingMode, LM_LEGACY, EXPERIMENTAL,                        \\\n+  product(int, LockingMode, LM_LEGACY,                                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -453,0 +453,1 @@\n+\n@@ -454,7 +455,2 @@\n-#ifdef _LP64\n-  int64_t _held_monitor_count;  \/\/ used by continuations for fast lock detection\n-  int64_t _jni_monitor_count;\n-#else\n-  int32_t _held_monitor_count;  \/\/ used by continuations for fast lock detection\n-  int32_t _jni_monitor_count;\n-#endif\n+  intx _held_monitor_count;  \/\/ used by continuations for fast lock detection\n+  intx _jni_monitor_count;\n@@ -602,2 +598,2 @@\n-  void inc_held_monitor_count(int i = 1, bool jni = false);\n-  void dec_held_monitor_count(int i = 1, bool jni = false);\n+  void inc_held_monitor_count(intx i = 1, bool jni = false);\n+  void dec_held_monitor_count(intx i = 1, bool jni = false);\n@@ -605,2 +601,2 @@\n-  int64_t held_monitor_count() { return (int64_t)_held_monitor_count; }\n-  int64_t jni_monitor_count()  { return (int64_t)_jni_monitor_count;  }\n+  intx held_monitor_count() { return _held_monitor_count; }\n+  intx jni_monitor_count()  { return _jni_monitor_count;  }\n@@ -907,0 +903,1 @@\n+  const char* name_raw() const;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,0 +42,5 @@\n+#include \"nmt\/mallocHeader.inline.hpp\"\n+#include \"nmt\/mallocTracker.hpp\"\n+#include \"nmt\/memTracker.inline.hpp\"\n+#include \"nmt\/nmtCommon.hpp\"\n+#include \"nmt\/nmtPreInit.hpp\"\n@@ -44,1 +49,1 @@\n-#include \"prims\/jvmtiAgent.hpp\"\n+#include \"prims\/jvmtiAgent.hpp\"\n@@ -66,5 +71,0 @@\n-#include \"services\/mallocTracker.hpp\"\n-#include \"services\/mallocHeader.inline.hpp\"\n-#include \"services\/memTracker.inline.hpp\"\n-#include \"services\/nmtPreInit.hpp\"\n-#include \"services\/nmtCommon.hpp\"\n@@ -73,0 +73,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -76,0 +77,1 @@\n+#include \"utilities\/fastrand.hpp\"\n@@ -139,1 +141,1 @@\n-  const int milliseconds_per_microsecond = 1000;\n+  const int milliseconds_per_second = 1000;\n@@ -141,1 +143,1 @@\n-    milliseconds_since_19700101 \/ milliseconds_per_microsecond;\n+    milliseconds_since_19700101 \/ milliseconds_per_second;\n@@ -143,1 +145,1 @@\n-    milliseconds_since_19700101 % milliseconds_per_microsecond;\n+    checked_cast<int>(milliseconds_since_19700101 % milliseconds_per_second);\n@@ -931,7 +933,57 @@\n-ATTRIBUTE_NO_ASAN static void print_hex_readable_pointer(outputStream* st, address p,\n-                                                         int unitsize) {\n-  switch (unitsize) {\n-    case 1: st->print(\"%02x\", *(u1*)p); break;\n-    case 2: st->print(\"%04x\", *(u2*)p); break;\n-    case 4: st->print(\"%08x\", *(u4*)p); break;\n-    case 8: st->print(\"%016\" FORMAT64_MODIFIER \"x\", *(u8*)p); break;\n+ATTRIBUTE_NO_ASAN static bool read_safely_from(intptr_t* p, intptr_t* result) {\n+  const intptr_t errval = 0x1717;\n+  intptr_t i = SafeFetchN(p, errval);\n+  if (i == errval) {\n+    i = SafeFetchN(p, ~errval);\n+    if (i == ~errval) {\n+      return false;\n+    }\n+  }\n+  (*result) = i;\n+  return true;\n+}\n+\n+static void print_hex_location(outputStream* st, address p, int unitsize) {\n+  assert(is_aligned(p, unitsize), \"Unaligned\");\n+  address pa = align_down(p, sizeof(intptr_t));\n+#ifndef _LP64\n+  \/\/ Special handling for printing qwords on 32-bit platforms\n+  if (unitsize == 8) {\n+    intptr_t i1, i2;\n+    if (read_safely_from((intptr_t*)pa, &i1) &&\n+        read_safely_from((intptr_t*)pa + 1, &i2)) {\n+      const uint64_t value =\n+        LITTLE_ENDIAN_ONLY((((uint64_t)i2) << 32) | i1)\n+        BIG_ENDIAN_ONLY((((uint64_t)i1) << 32) | i2);\n+      st->print(\"%016\" FORMAT64_MODIFIER \"x\", value);\n+    } else {\n+      st->print_raw(\"????????????????\");\n+    }\n+    return;\n+  }\n+#endif \/\/ 32-bit, qwords\n+  intptr_t i = 0;\n+  if (read_safely_from((intptr_t*)pa, &i)) {\n+    \/\/ bytes:   CA FE BA BE DE AD C0 DE\n+    \/\/ bytoff:   0  1  2  3  4  5  6  7\n+    \/\/ LE bits:  0  8 16 24 32 40 48 56\n+    \/\/ BE bits: 56 48 40 32 24 16  8  0\n+    const int offset = (int)(p - (address)pa);\n+    const int bitoffset =\n+      LITTLE_ENDIAN_ONLY(offset * BitsPerByte)\n+      BIG_ENDIAN_ONLY((int)((sizeof(intptr_t) - unitsize - offset) * BitsPerByte));\n+    const int bitfieldsize = unitsize * BitsPerByte;\n+    intptr_t value = bitfield(i, bitoffset, bitfieldsize);\n+    switch (unitsize) {\n+      case 1: st->print(\"%02x\", (u1)value); break;\n+      case 2: st->print(\"%04x\", (u2)value); break;\n+      case 4: st->print(\"%08x\", (u4)value); break;\n+      case 8: st->print(\"%016\" FORMAT64_MODIFIER \"x\", (u8)value); break;\n+    }\n+  } else {\n+    switch (unitsize) {\n+      case 1: st->print_raw(\"??\"); break;\n+      case 2: st->print_raw(\"????\"); break;\n+      case 4: st->print_raw(\"????????\"); break;\n+      case 8: st->print_raw(\"????????????????\"); break;\n+    }\n@@ -958,5 +1010,1 @@\n-    if (is_readable_pointer(p)) {\n-      print_hex_readable_pointer(st, p, unitsize);\n-    } else {\n-      st->print(\"%*.*s\", 2*unitsize, 2*unitsize, \"????????????????\");\n-    }\n+    print_hex_location(st, p, unitsize);\n@@ -1394,1 +1442,1 @@\n-    buf = (void *)((char *)buf + nBytes);\n+    buf = (void *)((char *)buf + res);\n@@ -1767,0 +1815,1 @@\n+    log_debug(os)(\"Reserved memory at \" INTPTR_FORMAT \" for \" SIZE_FORMAT \" bytes.\", p2i(addr), bytes);\n@@ -1771,0 +1820,188 @@\n+\n+  return result;\n+}\n+\n+#ifdef ASSERT\n+static void print_points(const char* s, unsigned* points, unsigned num) {\n+  stringStream ss;\n+  for (unsigned i = 0; i < num; i ++) {\n+    ss.print(\"%u \", points[i]);\n+  }\n+  log_trace(os, map)(\"%s, %u Points: %s\", s, num, ss.base());\n+}\n+#endif\n+\n+\/\/ Helper for os::attempt_reserve_memory_between\n+\/\/ Given an array of things, shuffle them (Fisher-Yates)\n+template <typename T>\n+static void shuffle_fisher_yates(T* arr, unsigned num, FastRandom& frand) {\n+  for (unsigned i = num - 1; i >= 1; i--) {\n+    unsigned j = frand.next() % i;\n+    swap(arr[i], arr[j]);\n+  }\n+}\n+\n+\/\/ Helper for os::attempt_reserve_memory_between\n+\/\/ Given an array of things, do a hemisphere split such that the resulting\n+\/\/ order is: [first, last, first + 1, last - 1, ...]\n+template <typename T>\n+static void hemi_split(T* arr, unsigned num) {\n+  T* tmp = (T*)::alloca(sizeof(T) * num);\n+  for (unsigned i = 0; i < num; i++) {\n+    tmp[i] = arr[i];\n+  }\n+  for (unsigned i = 0; i < num; i++) {\n+    arr[i] = is_even(i) ? tmp[i \/ 2] : tmp[num - (i \/ 2) - 1];\n+  }\n+}\n+\n+\/\/ Given an address range [min, max), attempts to reserve memory within this area, with the given alignment.\n+\/\/ If randomize is true, the location will be randomized.\n+char* os::attempt_reserve_memory_between(char* min, char* max, size_t bytes, size_t alignment, bool randomize) {\n+\n+  \/\/ Please keep the following constants in sync with the companion gtests:\n+\n+  \/\/ Number of mmap attemts we will undertake.\n+  constexpr unsigned max_attempts = 32;\n+\n+  \/\/ In randomization mode: We require a minimum number of possible attach points for\n+  \/\/ randomness. Below that we refuse to reserve anything.\n+  constexpr unsigned min_random_value_range = 16;\n+\n+  \/\/ In randomization mode: If the possible value range is below this threshold, we\n+  \/\/ use a total shuffle without regard for address space fragmentation, otherwise\n+  \/\/ we attempt to minimize fragmentation.\n+  constexpr unsigned total_shuffle_threshold = 1024;\n+\n+#define ARGSFMT \" range [\" PTR_FORMAT \"-\" PTR_FORMAT \"), size \" SIZE_FORMAT_X \", alignment \" SIZE_FORMAT_X \", randomize: %d\"\n+#define ARGSFMTARGS p2i(min), p2i(max), bytes, alignment, randomize\n+\n+  log_trace(os, map) (\"reserve_between (\" ARGSFMT \")\", ARGSFMTARGS);\n+\n+  assert(is_power_of_2(alignment), \"alignment invalid (\" ARGSFMT \")\", ARGSFMTARGS);\n+  assert(alignment < SIZE_MAX \/ 2, \"alignment too large (\" ARGSFMT \")\", ARGSFMTARGS);\n+  assert(is_aligned(bytes, os::vm_page_size()), \"size not page aligned (\" ARGSFMT \")\", ARGSFMTARGS);\n+  assert(max >= min, \"invalid range (\" ARGSFMT \")\", ARGSFMTARGS);\n+\n+  char* const absolute_max = (char*)(NOT_LP64(G * 3) LP64_ONLY(G * 128 * 1024));\n+  char* const absolute_min = (char*) os::vm_min_address();\n+\n+  const size_t alignment_adjusted = MAX2(alignment, os::vm_allocation_granularity());\n+\n+  \/\/ Calculate first and last possible attach points:\n+  char* const lo_att = align_up(MAX2(absolute_min, min), alignment_adjusted);\n+  if (lo_att == nullptr) {\n+    return nullptr; \/\/ overflow\n+  }\n+\n+  char* const hi_att = align_down(MIN2(max, absolute_max) - bytes, alignment_adjusted);\n+  if (hi_att > max) {\n+    return nullptr; \/\/ overflow\n+  }\n+\n+  \/\/ no possible attach points\n+  if (hi_att < lo_att) {\n+    return nullptr;\n+  }\n+\n+  char* result = nullptr;\n+\n+  const size_t num_attach_points = (size_t)((hi_att - lo_att) \/ alignment_adjusted) + 1;\n+  assert(num_attach_points > 0, \"Sanity\");\n+\n+  \/\/ If this fires, the input range is too large for the given alignment (we work\n+  \/\/ with int below to keep things simple). Since alignment is bound to page size,\n+  \/\/ and the lowest page size is 4K, this gives us a minimum of 4K*4G=8TB address\n+  \/\/ range.\n+  assert(num_attach_points <= UINT_MAX,\n+         \"Too many possible attach points - range too large or alignment too small (\" ARGSFMT \")\", ARGSFMTARGS);\n+\n+  const unsigned num_attempts = MIN2((unsigned)num_attach_points, max_attempts);\n+  unsigned points[max_attempts];\n+\n+  if (randomize) {\n+    FastRandom frand;\n+\n+    if (num_attach_points < min_random_value_range) {\n+      return nullptr;\n+    }\n+\n+    \/\/ We pre-calc the attach points:\n+    \/\/ 1 We divide the attach range into equidistant sections and calculate an attach\n+    \/\/   point within each section.\n+    \/\/ 2 We wiggle those attach points around within their section (depends on attach\n+    \/\/   point granularity)\n+    \/\/ 3 Should that not be enough to get effective randomization, shuffle all\n+    \/\/   attach points\n+    \/\/ 4 Otherwise, re-order them to get an optimized probing sequence.\n+    const unsigned stepsize = (unsigned)num_attach_points \/ num_attempts;\n+    const unsigned half = num_attempts \/ 2;\n+\n+    \/\/ 1+2: pre-calc points\n+    for (unsigned i = 0; i < num_attempts; i++) {\n+      const unsigned deviation = stepsize > 1 ? (frand.next() % stepsize) : 0;\n+      points[i] = (i * stepsize) + deviation;\n+    }\n+\n+    if (num_attach_points < total_shuffle_threshold) {\n+      \/\/ 3:\n+      \/\/ The numeber of possible attach points is too low for the \"wiggle\" from\n+      \/\/ point 2 to be enough to provide randomization. In that case, shuffle\n+      \/\/ all attach points at the cost of possible fragmentation (e.g. if we\n+      \/\/ end up mapping into the middle of the range).\n+      shuffle_fisher_yates(points, num_attempts, frand);\n+    } else {\n+      \/\/ 4\n+      \/\/ We have a large enough number of attach points to satisfy the randomness\n+      \/\/ goal without. In that case, we optimize probing by sorting the attach\n+      \/\/ points: We attempt outermost points first, then work ourselves up to\n+      \/\/ the middle. That reduces address space fragmentation. We also alternate\n+      \/\/ hemispheres, which increases the chance of successfull mappings if the\n+      \/\/ previous mapping had been blocked by large maps.\n+      hemi_split(points, num_attempts);\n+    }\n+  } \/\/ end: randomized\n+  else\n+  {\n+    \/\/ Non-randomized. We just attempt to reserve by probing sequentially. We\n+    \/\/ alternate between hemispheres, working ourselves up to the middle.\n+    const int stepsize = (unsigned)num_attach_points \/ num_attempts;\n+    for (unsigned i = 0; i < num_attempts; i++) {\n+      points[i] = (i * stepsize);\n+    }\n+    hemi_split(points, num_attempts);\n+  }\n+\n+#ifdef ASSERT\n+  \/\/ Print + check all pre-calculated attach points\n+  print_points(\"before reserve\", points, num_attempts);\n+  for (unsigned i = 0; i < num_attempts; i++) {\n+    assert(points[i] < num_attach_points, \"Candidate attach point %d out of range (%u, num_attach_points: %zu) \" ARGSFMT,\n+           i, points[i], num_attach_points, ARGSFMTARGS);\n+  }\n+#endif\n+\n+  \/\/ Now reserve\n+  for (unsigned i = 0; result == nullptr && i < num_attempts; i++) {\n+    const unsigned candidate_offset = points[i];\n+    char* const candidate = lo_att + candidate_offset * alignment_adjusted;\n+    assert(candidate <= hi_att, \"Invalid offset %u (\" ARGSFMT \")\", candidate_offset, ARGSFMTARGS);\n+    result = os::pd_attempt_reserve_memory_at(candidate, bytes, false);\n+    if (!result) {\n+      log_trace(os, map)(\"Failed to attach at \" PTR_FORMAT, p2i(candidate));\n+    }\n+  }\n+\n+  \/\/ Sanity checks, logging, NMT stuff:\n+  if (result != nullptr) {\n+#define ERRFMT \"result: \" PTR_FORMAT \" \" ARGSFMT\n+#define ERRFMTARGS p2i(result), ARGSFMTARGS\n+    assert(result >= min, \"OOB min (\" ERRFMT \")\", ERRFMTARGS);\n+    assert((result + bytes) <= max, \"OOB max (\" ERRFMT \")\", ERRFMTARGS);\n+    assert(result >= (char*)os::vm_min_address(), \"OOB vm.map min (\" ERRFMT \")\", ERRFMTARGS);\n+    assert((result + bytes) <= absolute_max, \"OOB vm.map max (\" ERRFMT \")\", ERRFMTARGS);\n+    assert(is_aligned(result, alignment), \"alignment invalid (\" ERRFMT \")\", ERRFMTARGS);\n+    log_trace(os, map)(ERRFMT, ERRFMTARGS);\n+    log_debug(os, map)(\"successfully attached at \" PTR_FORMAT, p2i(result));\n+    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n+  }\n@@ -1772,0 +2009,4 @@\n+#undef ARGSFMT\n+#undef ERRFMT\n+#undef ARGSFMTARGS\n+#undef ERRFMTARGS\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":263,"deletions":22,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -193,0 +193,5 @@\n+  \/\/ The default value for os::vm_min_address() unless the platform knows better. This value\n+  \/\/ is chosen to give us reasonable protection against NULL pointer dereferences while being\n+  \/\/ low enough to leave most of the valuable low-4gb address space open.\n+  static constexpr size_t _vm_min_address_default = 16 * M;\n+\n@@ -423,0 +428,3 @@\n+  \/\/ Returns the lowest address the process is allowed to map against.\n+  static size_t vm_min_address();\n+\n@@ -435,0 +443,4 @@\n+  \/\/ Given an address range [min, max), attempts to reserve memory within this area, with the given alignment.\n+  \/\/ If randomize is true, the location will be randomized.\n+  static char* attempt_reserve_memory_between(char* min, char* max, size_t bytes, size_t alignment, bool randomize);\n+\n@@ -505,1 +517,1 @@\n-  static size_t numa_get_leaf_groups(int *ids, size_t size);\n+  static size_t numa_get_leaf_groups(uint *ids, size_t size);\n@@ -601,2 +613,1 @@\n-  static address current_stack_base();\n-  static size_t current_stack_size();\n+  static void current_stack_base_and_size(address* base, size_t* size);\n@@ -786,1 +797,1 @@\n-  static void print_instructions(outputStream* st, address pc, int unitsize);\n+  static void print_instructions(outputStream* st, address pc, int unitsize = 1);\n@@ -900,4 +911,4 @@\n-  static int recv(int fd, char* buf, size_t nBytes, uint flags);\n-  static int send(int fd, char* buf, size_t nBytes, uint flags);\n-  static int raw_send(int fd, char* buf, size_t nBytes, uint flags);\n-  static int connect(int fd, struct sockaddr* him, socklen_t len);\n+  static ssize_t recv(int fd, char* buf, size_t nBytes, uint flags);\n+  static ssize_t send(int fd, char* buf, size_t nBytes, uint flags);\n+  static ssize_t raw_send(int fd, char* buf, size_t nBytes, uint flags);\n+  static ssize_t connect(int fd, struct sockaddr* him, socklen_t len);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -59,1 +60,1 @@\n-#include \"prims\/jvmtiAgentList.hpp\"\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -65,1 +66,1 @@\n-#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n@@ -87,1 +88,1 @@\n-#include \"runtime\/threads.hpp\"\n+#include \"runtime\/threads.hpp\"\n@@ -96,1 +97,0 @@\n-#include \"services\/memTracker.hpp\"\n@@ -676,1 +676,1 @@\n-  MutexLocker::post_initialize();\n+  MutexLockerImpl::post_initialize();\n@@ -703,1 +703,1 @@\n-  Chunk::start_chunk_pool_cleaner_task();\n+  Arena::start_chunk_pool_cleaner_task();\n@@ -715,0 +715,1 @@\n+  bool init_compilation = true;\n@@ -716,1 +717,1 @@\n-  bool force_JVMCI_intialization = false;\n+  bool force_JVMCI_initialization = false;\n@@ -720,6 +721,11 @@\n-    force_JVMCI_intialization = EagerJVMCI || JVMCIPrintProperties || JVMCILibDumpJNIConfig;\n-\n-    if (!force_JVMCI_intialization) {\n-      \/\/ 8145270: Force initialization of JVMCI runtime otherwise requests for blocking\n-      \/\/ compilations via JVMCI will not actually block until JVMCI is initialized.\n-      force_JVMCI_intialization = UseJVMCICompiler && (!UseInterpreter || !BackgroundCompilation);\n+    force_JVMCI_initialization = EagerJVMCI || JVMCIPrintProperties || JVMCILibDumpJNIConfig;\n+    if (!force_JVMCI_initialization && UseJVMCICompiler && !UseJVMCINativeLibrary && (!UseInterpreter || !BackgroundCompilation)) {\n+      \/\/ Force initialization of jarjvmci otherwise requests for blocking\n+      \/\/ compilations will not actually block until jarjvmci is initialized.\n+      force_JVMCI_initialization = true;\n+    }\n+    if (JVMCIPrintProperties || JVMCILibDumpJNIConfig) {\n+      \/\/ Both JVMCILibDumpJNIConfig and JVMCIPrintProperties exit the VM\n+      \/\/ so compilation should be disabled. This prevents dumping or\n+      \/\/ printing from happening more than once.\n+      init_compilation = false;\n@@ -729,5 +735,2 @@\n-  CompileBroker::compilation_init_phase1(CHECK_JNI_ERR);\n-  \/\/ Postpone completion of compiler initialization to after JVMCI\n-  \/\/ is initialized to avoid timeouts of blocking compilations.\n-  if (JVMCI_ONLY(!force_JVMCI_intialization) NOT_JVMCI(true)) {\n-    CompileBroker::compilation_init_phase2();\n+  if (init_compilation) {\n+    CompileBroker::compilation_init(CHECK_JNI_ERR);\n@@ -777,1 +780,1 @@\n-  if (force_JVMCI_intialization) {\n+  if (force_JVMCI_initialization) {\n@@ -779,1 +782,0 @@\n-    CompileBroker::compilation_init_phase2();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-                   static_ptr_volatile_field,                                                                                        \\\n+                   volatile_static_field,                                                                                            \\\n@@ -197,0 +197,1 @@\n+                volatile_static_field,                                                                                               \\\n@@ -450,1 +451,1 @@\n-     static_field(PerfMemory,                  _initialized,                                  int)                                   \\\n+     volatile_static_field(PerfMemory,         _initialized,                                  int)                                   \\\n@@ -480,1 +481,1 @@\n-  static_ptr_volatile_field(ClassLoaderDataGraph, _head,                                      ClassLoaderData*)                      \\\n+  volatile_static_field(ClassLoaderDataGraph, _head,                                          ClassLoaderData*)                      \\\n@@ -641,1 +642,1 @@\n-  static_ptr_volatile_field(ThreadsSMRSupport, _java_thread_list,                             ThreadsList*)                          \\\n+  volatile_static_field(ThreadsSMRSupport, _java_thread_list,                                 ThreadsList*)                          \\\n@@ -950,3 +951,0 @@\n-     static_field(JDK_Version,                 _current,                                      JDK_Version)                           \\\n-  nonstatic_field(JDK_Version,                 _major,                                        unsigned char)                         \\\n-                                                                                                                                     \\\n@@ -1498,0 +1496,1 @@\n+  declare_c2_type(ConvertNode, TypeNode)                                  \\\n@@ -1753,6 +1752,1 @@\n-  declare_c2_type(ReplicateBNode, VectorNode)                             \\\n-  declare_c2_type(ReplicateSNode, VectorNode)                             \\\n-  declare_c2_type(ReplicateINode, VectorNode)                             \\\n-  declare_c2_type(ReplicateLNode, VectorNode)                             \\\n-  declare_c2_type(ReplicateFNode, VectorNode)                             \\\n-  declare_c2_type(ReplicateDNode, VectorNode)                             \\\n+  declare_c2_type(ReplicateNode, VectorNode)                              \\\n@@ -1876,1 +1870,0 @@\n-  declare_toplevel_type(JDK_Version)                                      \\\n@@ -2693,1 +2686,1 @@\n-             GENERATE_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY,\n+             GENERATE_VOLATILE_STATIC_VM_STRUCT_ENTRY,\n@@ -2895,1 +2888,1 @@\n-             CHECK_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY,\n+             CHECK_VOLATILE_STATIC_VM_STRUCT_ENTRY,\n@@ -3041,1 +3034,1 @@\n-    int len = end - start + 1;\n+    int len = pointer_delta_as_int(end, start) + 1;\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -34,0 +34,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -41,0 +43,3 @@\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"nmt\/nmtDCmd.hpp\"\n@@ -60,1 +65,0 @@\n-#include \"services\/nmtDCmd.hpp\"\n@@ -70,0 +74,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n@@ -71,1 +76,1 @@\n-#include \"trimCHeapDCmd.hpp\"\n+#include \"os_posix.hpp\"\n@@ -73,0 +78,2 @@\n+#include \"trimCHeapDCmd.hpp\"\n+#include <errno.h>\n@@ -137,0 +144,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemMapDCmd>(full_export, true,false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemDumpMapDCmd>(full_export, true,false));\n@@ -144,0 +153,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilationMemoryStatisticDCmd>(full_export, true, false));\n@@ -887,1 +897,1 @@\n-  long max = -1;\n+  int max = -1;\n@@ -890,2 +900,2 @@\n-    max = ::strtol(max_value, &endptr, 10);\n-    if (max == 0 && max_value == endptr) {\n+    int max;\n+    if (!parse_integer(max_value, &max)) {\n@@ -1168,0 +1178,56 @@\n+\n+CompilationMemoryStatisticDCmd::CompilationMemoryStatisticDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  _minsize(\"-s\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _dcmdparser.add_dcmd_option(&_minsize);\n+}\n+\n+void CompilationMemoryStatisticDCmd::execute(DCmdSource source, TRAPS) {\n+  const bool human_readable = _human_readable.value();\n+  const size_t minsize = _minsize.has_value() ? _minsize.value()._size : 0;\n+  CompilationMemoryStatistic::print_all_by_size(output(), human_readable, minsize);\n+}\n+\n+#ifdef LINUX\n+\n+SystemMapDCmd::SystemMapDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+}\n+\n+void SystemMapDCmd::execute(DCmdSource source, TRAPS) {\n+  MemMapPrinter::print_all_mappings(output(), _human_readable.value());\n+}\n+\n+SystemDumpMapDCmd::SystemDumpMapDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  _filename(\"-F\", \"file path (defaults: \\\"vm_memory_map_<pid>.txt\\\")\", \"STRING\", false) {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _dcmdparser.add_dcmd_option(&_filename);\n+}\n+\n+void SystemDumpMapDCmd::execute(DCmdSource source, TRAPS) {\n+  stringStream default_name;\n+  default_name.print(\"vm_memory_map_%d.txt\", os::current_process_id());\n+  const char* name = _filename.is_set() ? _filename.value() : default_name.base();\n+  fileStream fs(name);\n+  if (fs.is_open()) {\n+    if (!MemTracker::enabled()) {\n+      output()->print_cr(\"(NMT is disabled, will not annotate mappings).\");\n+    }\n+    MemMapPrinter::print_all_mappings(&fs, _human_readable.value());\n+    \/\/ For the readers convenience, resolve path name.\n+    char tmp[JVM_MAXPATHLEN];\n+    const char* absname = os::Posix::realpath(name, tmp, sizeof(tmp));\n+    name = absname != nullptr ? absname : name;\n+    output()->print_cr(\"Memory map dumped to \\\"%s\\\".\", name);\n+  } else {\n+    output()->print_cr(\"Failed to open \\\"%s\\\" for writing (%s).\", name, os::strerror(errno));\n+  }\n+}\n+\n+#endif \/\/ LINUX\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":72,"deletions":6,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -971,0 +971,65 @@\n+class CompilationMemoryStatisticDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<MemorySizeArgument> _minsize;\n+public:\n+  static int num_arguments() { return 2; }\n+  CompilationMemoryStatisticDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"Compiler.memory\";\n+  }\n+  static const char* description() {\n+    return \"Print compilation footprint\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of compiled methods\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+#ifdef LINUX\n+\n+class SystemMapDCmd : public DCmdWithParser {\n+  DCmdArgument<bool> _human_readable;\n+public:\n+  static int num_arguments() { return 1; }\n+  SystemMapDCmd(outputStream* output, bool heap);\n+  static const char* name() { return \"System.map\"; }\n+  static const char* description() {\n+    return \"Prints an annotated process memory map of the VM process (linux only).\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"control\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class SystemDumpMapDCmd : public DCmdWithParser {\n+  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<char*> _filename;\n+public:\n+  static int num_arguments() { return 2; }\n+  SystemDumpMapDCmd(outputStream* output, bool heap);\n+  static const char* name() { return \"System.dump_map\"; }\n+  static const char* description() {\n+    return \"Dumps an annotated process memory map to an output file (linux only).\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"control\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+#endif \/\/ LINUX\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -509,2 +509,0 @@\n-     *\n-     * @revised 1.4\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -421,2 +421,0 @@\n-     *\n-     * @revised 1.4\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-     * to write to, a file with the specified name. A new\n+     * to write to, a file with the specified pathname. A new\n@@ -140,1 +140,1 @@\n-     * is called with the {@code name} argument\n+     * is called with the {@code pathname} argument\n@@ -144,1 +144,1 @@\n-     * is also called with the {@code name} argument\n+     * is also called with the {@code pathname} argument\n@@ -147,2 +147,2 @@\n-     * @param      name   the system-dependent filename\n-     * @param      mode   the access <a href=\"#mode\">mode<\/a>\n+     * @param      pathname   the system-dependent pathname string\n+     * @param      mode       the access <a href=\"#mode\">mode<\/a>\n@@ -153,1 +153,1 @@\n-     *             if the mode is {@code \"r\"} but the given string does not\n+     *             if the mode is {@code \"r\"} but the given pathname string does not\n@@ -155,1 +155,1 @@\n-     *             {@code \"rw\"} but the given string does not denote an\n+     *             {@code \"rw\"} but the given pathname string does not denote an\n@@ -157,2 +157,2 @@\n-     *             that name cannot be created, or if some other error occurs\n-     *             while opening or creating the file\n+     *             that pathname cannot be created, or if some other error\n+     *             occurs while opening or creating the file\n@@ -166,2 +166,1 @@\n-     * @revised 1.4\n-    public RandomAccessFile(String name, String mode)\n+    public RandomAccessFile(String pathname, String mode)\n@@ -171,1 +170,1 @@\n-        this(name != null ? new File(name) : null, mode);\n+        this(pathname != null ? new File(pathname) : null, mode);\n@@ -229,2 +228,2 @@\n-     * also called with the path argument to see if write access to the file is\n-     * allowed.\n+     * also called with the pathname of the {@code file} argument to see if\n+     * write access to the file is allowed.\n@@ -243,2 +242,2 @@\n-     *             that name cannot be created, or if some other error occurs\n-     *             while opening or creating the file\n+     *             that pathname cannot be created, or if some other error\n+     *             occurs while opening or creating the file\n@@ -252,1 +251,0 @@\n-     * @revised 1.4\n@@ -741,2 +739,0 @@\n-     *\n-     * @revised 1.4\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -71,0 +72,1 @@\n+import jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;\n@@ -90,1 +92,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -1798,1 +1799,2 @@\n-            if (service == null) {\n+            LoggerFinder finder = service;\n+            if (finder == null) {\n@@ -1801,1 +1803,1 @@\n-                service = AccessController.doPrivileged(pa, null,\n+                finder = AccessController.doPrivileged(pa, null,\n@@ -1803,0 +1805,2 @@\n+                if (finder instanceof TemporaryLoggerFinder) return finder;\n+                service = finder;\n@@ -1804,1 +1808,1 @@\n-            return service;\n+            return finder;\n@@ -2482,2 +2486,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName) {\n-                m.ensureNativeAccess(owner, methodName);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n+                m.ensureNativeAccess(owner, methodName, currentClass);\n@@ -2695,1 +2699,11 @@\n-                return loader.nameAndId();\n+                return loader != null ? loader.nameAndId() : \"null\";\n+            }\n+\n+            @Override\n+            public void copyToSegmentRaw(String string, MemorySegment segment, long offset) {\n+                string.copyToSegmentRaw(segment, offset);\n+            }\n+\n+            @Override\n+            public boolean bytesCompatible(String string, Charset charset) {\n+                return string.bytesCompatible(charset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n- * <h3> Textual representation of IP addresses <\/h3>\n+ * <h3> <a id=\"format\">Textual representation of IP addresses<\/a> <\/h3>\n@@ -761,2 +761,2 @@\n-     * and the result will be returned based on the system\n-     * configured resolver. If a lookup of the name service\n+     * and the result will be returned based on the system-wide\n+     * resolver. If a lookup of the name service\n@@ -815,3 +815,9 @@\n-     * Gets the fully qualified domain name for this IP address.\n-     * Best effort method, meaning we may not be able to return\n-     * the FQDN depending on the underlying system configuration.\n+     * Gets the fully qualified domain name for this\n+     * {@linkplain InetAddress#getAddress() IP address} using the system-wide\n+     * {@linkplain InetAddressResolver resolver}.\n+     *\n+     * <p>The system-wide resolver will be used to do a reverse name lookup of the IP address.\n+     * The lookup can fail for many reasons that include the host not being registered with the name\n+     * service. If the resolver is unable to determine the fully qualified\n+     * domain name, this method returns the {@linkplain #getHostAddress() textual representation}\n+     * of the IP address.\n@@ -827,3 +833,5 @@\n-     * @return  the fully qualified domain name for this IP address,\n-     *    or if the operation is not allowed by the security check,\n-     *    the textual representation of the IP address.\n+     * @return  the fully qualified domain name for this IP address.\n+     *          If either the operation is not allowed by the security check\n+     *          or the system-wide resolver wasn't able to determine the\n+     *          fully qualified domain name for the IP address, the textual\n+     *          representation of the IP address is returned instead.\n@@ -844,1 +852,1 @@\n-     * Returns the hostname for this address.\n+     * Returns the fully qualified domain name for the given address.\n@@ -850,1 +858,1 @@\n-     * the hostname for this IP address, i.e., to connect to the host.\n+     * the hostname for the given IP address, i.e., to connect to the host.\n@@ -854,4 +862,0 @@\n-     * @return  the host name for this IP address, or if the operation\n-     *    is not allowed by the security check, the textual\n-     *    representation of the IP address.\n-     *\n@@ -860,0 +864,6 @@\n+     * @return  the fully qualified domain name for the given IP address.\n+     *          If either the operation is not allowed by the security check\n+     *          or the system-wide resolver wasn't able to determine the\n+     *          fully qualified domain name for the IP address, the textual\n+     *          representation of the IP address is returned instead.\n+     *\n@@ -1437,1 +1447,1 @@\n-                addrArray = IPAddressUtil.validateNumericFormatV4(addrStr);\n+                addrArray = IPAddressUtil.validateNumericFormatV4(addrStr, false);\n@@ -1600,1 +1610,1 @@\n-     * based on the configured system {@linkplain InetAddressResolver resolver}.\n+     * based on the system-wide {@linkplain InetAddressResolver resolver}.\n@@ -1664,4 +1674,1 @@\n-            byte[] addr = null;\n-            int numericZone = -1;\n-            String ifname = null;\n-\n+            InetAddress inetAddress = null;\n@@ -1671,1 +1678,2 @@\n-                    addr = IPAddressUtil.validateNumericFormatV4(host);\n+                    \/\/ Here we check the address string for ambiguity only\n+                    inetAddress = Inet4Address.parseAddressString(host, false);\n@@ -1678,11 +1686,5 @@\n-            if (addr == null) {\n-                \/\/ Try to parse host string as an IPv6 literal\n-                \/\/ Check if a numeric or string zone id is present first\n-                int pos;\n-                if ((pos = host.indexOf('%')) != -1) {\n-                    numericZone = checkNumericZone(host);\n-                    if (numericZone == -1) { \/* remainder of string must be an ifname *\/\n-                        ifname = host.substring(pos + 1);\n-                    }\n-                }\n-                if ((addr = IPAddressUtil.textToNumericFormatV6(host)) == null &&\n+            if (inetAddress == null) {\n+                \/\/ This is supposed to be an IPv6 literal\n+                \/\/ Check for presence of a numeric or string zone id\n+                \/\/ is done in Inet6Address.parseAddressString\n+                if ((inetAddress = Inet6Address.parseAddressString(host, false)) == null &&\n@@ -1693,16 +1695,2 @@\n-            if(addr != null) {\n-                InetAddress[] ret = new InetAddress[1];\n-                if (addr.length == Inet4Address.INADDRSZ) {\n-                    if (numericZone != -1 || ifname != null) {\n-                        \/\/ IPv4-mapped address must not contain zone-id\n-                        throw new UnknownHostException(host + \": invalid IPv4-mapped address\");\n-                    }\n-                    ret[0] = new Inet4Address(null, addr);\n-                } else {\n-                    if (ifname != null) {\n-                        ret[0] = new Inet6Address(null, addr, ifname);\n-                    } else {\n-                        ret[0] = new Inet6Address(null, addr, numericZone);\n-                    }\n-                }\n-                return ret;\n+            if (inetAddress != null) {\n+                return new InetAddress[]{inetAddress};\n@@ -1738,33 +1726,0 @@\n-\n-    \/**\n-     * check if the literal address string has %nn appended\n-     * returns -1 if not, or the numeric value otherwise.\n-     *\n-     * %nn may also be a string that represents the displayName of\n-     * a currently available NetworkInterface.\n-     *\/\n-    private static int checkNumericZone (String s) throws UnknownHostException {\n-        int percent = s.indexOf ('%');\n-        int slen = s.length();\n-        int digit, zone=0;\n-        int multmax = Integer.MAX_VALUE \/ 10; \/\/ for int overflow detection\n-        if (percent == -1) {\n-            return -1;\n-        }\n-        for (int i=percent+1; i<slen; i++) {\n-            char c = s.charAt(i);\n-            if ((digit = IPAddressUtil.parseAsciiDigit(c, 10)) < 0) {\n-                return -1;\n-            }\n-            if (zone > multmax) {\n-                return -1;\n-            }\n-            zone = (zone * 10) + digit;\n-            if (zone < 0) {\n-                return -1;\n-            }\n-\n-        }\n-        return zone;\n-    }\n-\n@@ -1779,0 +1734,33 @@\n+    \/**\n+     * Creates an {@code InetAddress} based on the provided {@linkplain InetAddress##format\n+     * textual representation} of an IP address.\n+     * <p> The provided IP address literal is parsed as\n+     * {@linkplain Inet4Address#ofLiteral(String) an IPv4 address literal} first.\n+     * If it cannot be parsed as an IPv4 address literal, then the method attempts\n+     * to parse it as {@linkplain Inet6Address#ofLiteral(String) an IPv6 address literal}.\n+     * If neither attempts succeed an {@code IllegalArgumentException} is thrown.\n+     * <p> This method doesn't block, i.e. no reverse lookup is performed.\n+     *\n+     * @param ipAddressLiteral the textual representation of an IP address.\n+     * @return an {@link InetAddress} object with no hostname set, and constructed\n+     *         from the provided IP address literal.\n+     * @throws IllegalArgumentException if the {@code ipAddressLiteral} cannot be parsed\n+     *         as an IPv4 or IPv6 address literal.\n+     * @throws NullPointerException if the {@code ipAddressLiteral} is {@code null}.\n+     * @see Inet4Address#ofLiteral(String)\n+     * @see Inet6Address#ofLiteral(String)\n+     * @since 22\n+     *\/\n+    public static InetAddress ofLiteral(String ipAddressLiteral) {\n+        Objects.requireNonNull(ipAddressLiteral);\n+        InetAddress inetAddress;\n+        try {\n+            \/\/ First try to parse the input as an IPv4 address literal\n+            inetAddress = Inet4Address.ofLiteral(ipAddressLiteral);\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ If it fails try to parse the input as an IPv6 address literal\n+            inetAddress = Inet6Address.ofLiteral(ipAddressLiteral);\n+        }\n+        return inetAddress;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":70,"deletions":82,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.event.SocketReadEvent;\n+import jdk.internal.event.SocketWriteEvent;\n@@ -181,1 +183,0 @@\n-     * @revised 1.4\n@@ -1056,2 +1057,0 @@\n-     *\n-     * @revised 1.4\n@@ -1081,3 +1080,0 @@\n-     *\n-     * This class is instrumented by Java Flight Recorder (JFR) to get socket\n-     * I\/O events.\n@@ -1100,0 +1096,13 @@\n+            if (!SocketReadEvent.enabled()) {\n+                return implRead(b, off, len);\n+            }\n+            long start = SocketReadEvent.timestamp();\n+            int nbytes = implRead(b, off, len);\n+            long duration = SocketReadEvent.timestamp() - start;\n+            if (SocketReadEvent.shouldCommit(duration)) {\n+                SocketReadEvent.emit(start, duration, nbytes, parent.getRemoteSocketAddress(), getSoTimeout());\n+            }\n+            return nbytes;\n+        }\n+\n+        private int implRead(byte[] b, int off, int len) throws IOException {\n@@ -1113,0 +1122,10 @@\n+\n+        private int getSoTimeout() {\n+            try {\n+                return parent.getSoTimeout();\n+            } catch (SocketException e) {\n+                \/\/ ignored - avoiding exceptions in jfr event data gathering\n+            }\n+            return 0;\n+        }\n+\n@@ -1154,1 +1173,0 @@\n-     * @revised 1.4\n@@ -1178,3 +1196,0 @@\n-     *\n-     * This class is instrumented by Java Flight Recorder (JFR) to get socket\n-     * I\/O events.\n@@ -1196,0 +1211,13 @@\n+            if (!SocketWriteEvent.enabled()) {\n+                implWrite(b, off, len);\n+                return;\n+            }\n+            long start = SocketWriteEvent.timestamp();\n+            implWrite(b, off, len);\n+            long duration = SocketWriteEvent.timestamp() - start;\n+            if (SocketWriteEvent.shouldCommit(duration)) {\n+                SocketWriteEvent.emit(start, duration, len, parent.getRemoteSocketAddress());\n+            }\n+        }\n+\n+        private void implWrite(byte[] b, int off, int len) throws IOException {\n@@ -1722,1 +1750,0 @@\n-     * @revised 1.4\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n- * <p>Java 5.0 introduced the {@code java.util.concurrent} package and\n+ * @apiNote Java 5.0 introduced the {@code java.util.concurrent} package and\n@@ -77,2 +77,1 @@\n- *\n- * <p>Implementation note: This class scales to large numbers of concurrently\n+ * @implNote This class scales to large numbers of concurrently\n@@ -82,2 +81,1 @@\n- *\n- * <p>Implementation note: All constructors start a timer thread.\n+ * <p> All constructors start a timer thread.\n@@ -437,2 +435,6 @@\n-     * Terminates this timer, discarding any currently scheduled tasks.\n-     * Does not interfere with a currently executing task (if it exists).\n+     * Terminates this timer, <i>discarding<\/i> any currently scheduled tasks.\n+     * It should be noted that this method does not <i>cancel<\/i> the scheduled\n+     * tasks. For a task to be considered cancelled, the task itself should\n+     * invoke {@link TimerTask#cancel()}.\n+     *\n+     * <p>This method does not interfere with a currently executing task (if it exists).\n@@ -449,0 +451,1 @@\n+     * @see TimerTask#cancel()\n@@ -458,3 +461,3 @@\n-     * Removes all cancelled tasks from this timer's task queue.  <i>Calling\n-     * this method has no effect on the behavior of the timer<\/i>, but\n-     * eliminates the references to the cancelled tasks from the queue.\n+     * Removes all <i>cancelled<\/i> tasks from this timer's task queue.\n+     * <i>Calling this method has no effect on the behavior of the timer<\/i>,\n+     * but eliminates the references to the cancelled tasks from the queue.\n@@ -467,3 +470,3 @@\n-     * runtime of the method may be proportional to n + c log n, where n\n-     * is the number of tasks in the queue and c is the number of cancelled\n-     * tasks.\n+     * runtime of the method may be proportional to {@code n + c log n}, where\n+     * {@code n} is the number of tasks in the queue and {@code c} is the number\n+     * of cancelled tasks.\n@@ -475,0 +478,2 @@\n+     * @see #cancel()\n+     * @see TimerTask#cancel()\n","filename":"src\/java.base\/share\/classes\/java\/util\/Timer.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-import sun.security.action.GetBooleanAction;\n+import sun.security.action.GetPropertyAction;\n@@ -128,2 +128,2 @@\n-     * Flag which specifies whether the validation of the Zip64 extra\n-     * fields should be disabled\n+     * Flag to specify whether the Extra ZIP64 validation should be\n+     * disabled.\n@@ -131,2 +131,3 @@\n-    private static final boolean disableZip64ExtraFieldValidation =\n-            GetBooleanAction.privilegedGetProperty(\"jdk.util.zip.disableZip64ExtraFieldValidation\");\n+    private static final boolean DISABLE_ZIP64_EXTRA_VALIDATION =\n+            getDisableZip64ExtraFieldValidation();\n+\n@@ -1109,0 +1110,16 @@\n+    \/**\n+     * Returns the value of the System property which indicates whether the\n+     * Extra ZIP64 validation should be disabled.\n+     *\/\n+    static boolean getDisableZip64ExtraFieldValidation() {\n+        boolean result;\n+        String value = GetPropertyAction.privilegedGetProperty(\n+                \"jdk.util.zip.disableZip64ExtraFieldValidation\");\n+        if (value == null) {\n+            result = false;\n+        } else {\n+            result = value.isEmpty() || value.equalsIgnoreCase(\"true\");\n+        }\n+        return result;\n+    }\n+\n@@ -1223,0 +1240,2 @@\n+            int elen = CENEXT(cen, pos);\n+            int clen = CENCOM(cen, pos);\n@@ -1227,2 +1246,1 @@\n-            int elen = CENEXT(cen, pos);\n-            if (elen > 0 && !disableZip64ExtraFieldValidation) {\n+            if (elen > 0 && !DISABLE_ZIP64_EXTRA_VALIDATION) {\n@@ -1234,0 +1252,5 @@\n+            } else if (elen == 0 && (CENSIZ(cen, pos) == ZIP64_MAGICVAL\n+                    || CENLEN(cen, pos) == ZIP64_MAGICVAL\n+                    || CENOFF(cen, pos) == ZIP64_MAGICVAL\n+                    || CENDSK(cen, pos) == ZIP64_MAGICCOUNT)) {\n+                zerror(\"Invalid CEN header (invalid zip64 extra len size)\");\n@@ -1246,2 +1269,2 @@\n-                \/\/ Validate comment if it exists\n-                \/\/ if the bytes representing the comment cannot be converted to\n+                \/\/ Validate comment if it exists.\n+                \/\/ If the bytes representing the comment cannot be converted to\n@@ -1249,1 +1272,0 @@\n-                int clen = CENCOM(cen, pos);\n@@ -1262,0 +1284,1 @@\n+         * @param cenPos The CEN offset for the current Entry\n@@ -1276,1 +1299,1 @@\n-            if (extraEndOffset > cen.length) {\n+            if (extraEndOffset > cen.length - ENDHDR) {\n@@ -1280,1 +1303,4 @@\n-            while (currentOffset < extraEndOffset) {\n+            \/\/ Walk through each Extra Header. Each Extra Header Must consist of:\n+            \/\/       Header ID - 2 bytes\n+            \/\/       Data Size - 2 bytes:\n+            while (currentOffset + Integer.BYTES <= extraEndOffset) {\n@@ -1285,0 +1311,1 @@\n+                currentOffset += Short.BYTES;\n@@ -1290,1 +1317,4 @@\n-                    zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+                    zerror(String.format(\n+                            \"Invalid CEN header (invalid extra data field size for \" +\n+                                    \"tag: 0x%04x at %d)\",\n+                            tag, cenPos));\n@@ -1292,1 +1322,0 @@\n-                currentOffset += Short.BYTES;\n@@ -1299,0 +1328,5 @@\n+                    \/\/ Get the LOC offset\n+                    long locoff = CENOFF(cen, cenPos);\n+                    \/\/ Get the Disk Number\n+                    int diskNo = CENDSK(cen, cenPos);\n+\n@@ -1300,1 +1334,1 @@\n-                            csize, size);\n+                            csize, size, locoff, diskNo);\n@@ -1308,4 +1342,5 @@\n-         * size and that the uncompressed size and compressed size field\n-         * values are not negative.\n-         * Note:  As we do not use the LOC offset or Starting disk number\n-         * field value we will not validate them\n+         * size; that the uncompressed size, compressed size field and LOC\n+         * offset fields are not negative. Also make sure the field exists if\n+         * the CEN header field is set to 0xFFFFFFFF.\n+         * Note:  As we do not use the Starting disk number field,\n+         * we will not validate its value\n@@ -1316,0 +1351,2 @@\n+         * @param locoff CEN header LOC offset\n+         * @param diskNo CEN header Disk number\n@@ -1319,1 +1356,1 @@\n-                                                long size)\n+                                                long size, long locoff, int diskNo)\n@@ -1322,0 +1359,11 @@\n+            \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n+            \/\/ versions of Apache Ant and Commons Compress, validate csize and size\n+            \/\/ to make sure neither field == ZIP64_MAGICVAL\n+            if (blockSize == 0) {\n+                if (csize == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL ||\n+                        locoff == ZIP64_MAGICVAL || diskNo == ZIP64_MAGICCOUNT) {\n+                    zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+                }\n+                \/\/ Only validate the ZIP64_EXTID data if the block size > 0\n+                return;\n+            }\n@@ -1324,1 +1372,1 @@\n-            if (!isZip64ExtBlockSizeValid(blockSize)) {\n+            if (!isZip64ExtBlockSizeValid(blockSize, csize, size, locoff, diskNo)) {\n@@ -1328,6 +1376,9 @@\n-            \/\/ Note we do not need to check blockSize is >= 8 as\n-            \/\/ we know its length is at least 8 from the call to\n-            \/\/ isZip64ExtBlockSizeValid()\n-            if ((size == ZIP64_MAGICVAL)) {\n-                if(get64(cen, off) < 0) {\n-                    zerror(\"Invalid zip64 extra block size value\");\n+            if (size == ZIP64_MAGICVAL) {\n+                if ( blockSize >= Long.BYTES) {\n+                    if (get64(cen, off) < 0) {\n+                        zerror(\"Invalid zip64 extra block size value\");\n+                    }\n+                    off += Long.BYTES;\n+                    blockSize -= Long.BYTES;\n+                } else {\n+                    zerror(\"Invalid Zip64 extra block, missing size\");\n@@ -1337,3 +1388,23 @@\n-            if ((csize == ZIP64_MAGICVAL) && (blockSize >= 16)) {\n-                if (get64(cen, off + 8) < 0) {\n-                    zerror(\"Invalid zip64 extra block compressed size value\");\n+            if (csize == ZIP64_MAGICVAL) {\n+                if (blockSize >= Long.BYTES) {\n+                    if (get64(cen, off) < 0) {\n+                        zerror(\"Invalid zip64 extra block compressed size value\");\n+                    }\n+                    off += Long.BYTES;\n+                    blockSize -= Long.BYTES;\n+                } else {\n+                    zerror(\"Invalid Zip64 extra block, missing compressed size\");\n+                }\n+            }\n+            \/\/ Check the LOC offset is not negative\n+            if (locoff == ZIP64_MAGICVAL) {\n+                if (blockSize >= Long.BYTES) {\n+                    if (get64(cen, off) < 0) {\n+                        zerror(\"Invalid zip64 extra block LOC OFFSET value\");\n+                    }\n+                    \/\/ Note: We do not need to adjust the following fields as\n+                    \/\/ this is the last field we are leveraging\n+                    \/\/ off += Long.BYTES;\n+                    \/\/ blockSize -= Long.BYTES;\n+                } else {\n+                    zerror(\"Invalid Zip64 extra block, missing LOC offset value\");\n@@ -1356,0 +1427,4 @@\n+         * @param csize CEN header compressed size value\n+         * @param size CEN header uncompressed size value\n+         * @param locoff CEN header LOC offset\n+         * @param diskNo CEN header Disk number\n@@ -1358,14 +1433,10 @@\n-        private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n-            \/*\n-             * As the fields must appear in order, the block size indicates which\n-             * fields to expect:\n-             *  8 - uncompressed size\n-             * 16 - uncompressed size, compressed size\n-             * 24 - uncompressed size, compressed sise, LOC Header offset\n-             * 28 - uncompressed size, compressed sise, LOC Header offset,\n-             * and Disk start number\n-             *\/\n-            return switch(blockSize) {\n-                case 8, 16, 24, 28 -> true;\n-                default -> false;\n-            };\n+        private static boolean isZip64ExtBlockSizeValid(int blockSize, long csize,\n+                                                        long size, long locoff,\n+                                                        int diskNo) {\n+            int expectedBlockSize =\n+                    (csize == ZIP64_MAGICVAL ? Long.BYTES : 0) +\n+                    (size == ZIP64_MAGICVAL ? Long.BYTES : 0) +\n+                    (locoff == ZIP64_MAGICVAL ? Long.BYTES : 0) +\n+                    (diskNo == ZIP64_MAGICCOUNT ? Integer.BYTES : 0);\n+            return expectedBlockSize == blockSize;\n+\n@@ -1381,0 +1452,7 @@\n+        \/**\n+         * A class representing a key to a zip file. A key is based\n+         * on the file key if available, or the path value if the\n+         * file key is not available. The key is also based on the\n+         * file's last modified time to allow for cases where a zip\n+         * file is re-opened after it has been modified.\n+         *\/\n@@ -1395,1 +1473,3 @@\n-                return ((int)(t ^ (t >>> 32))) + file.hashCode();\n+                Object fk = attrs.fileKey();\n+                return Long.hashCode(t) +\n+                        (fk != null ? fk.hashCode() : file.hashCode());\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":125,"deletions":45,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -437,3 +437,1 @@\n-            \/\/ Skip this URL if it already has a Loader. (Loader\n-            \/\/ may be null in the case where URL has not been opened\n-            \/\/ but is referenced by a JAR index.)\n+            \/\/ Skip this URL if it already has a Loader.\n@@ -493,1 +491,1 @@\n-                                    return new JarLoader(nestedUrl, jarHandler, lmap, acc);\n+                                    return new JarLoader(nestedUrl, jarHandler, acc);\n@@ -498,1 +496,1 @@\n-                                return new JarLoader(url, jarHandler, lmap, acc);\n+                                return new JarLoader(url, jarHandler, acc);\n@@ -712,2 +710,0 @@\n-        private URLStreamHandler handler;\n-        private final HashMap<String, Loader> lmap;\n@@ -725,1 +721,0 @@\n-                          HashMap<String, Loader> loaderMap,\n@@ -731,2 +726,0 @@\n-            handler = jarHandler;\n-            lmap = loaderMap;\n@@ -756,4 +749,0 @@\n-        JarFile getJarFile () {\n-            return jar;\n-        }\n-\n@@ -875,27 +864,0 @@\n-\n-        \/*\n-         * Returns true iff at least one resource in the jar file has the same\n-         * package name as that of the specified resource name.\n-         *\/\n-        boolean validIndex(final String name) {\n-            String packageName = name;\n-            int pos;\n-            if ((pos = name.lastIndexOf('\/')) != -1) {\n-                packageName = name.substring(0, pos);\n-            }\n-\n-            String entryName;\n-            ZipEntry entry;\n-            Enumeration<JarEntry> enum_ = jar.entries();\n-            while (enum_.hasMoreElements()) {\n-                entry = enum_.nextElement();\n-                entryName = entry.getName();\n-                if ((pos = entryName.lastIndexOf('\/')) != -1)\n-                    entryName = entryName.substring(0, pos);\n-                if (entryName.equals(packageName)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":3,"deletions":41,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-        jdk.incubator.vector, \/\/ participates in preview features\n+        jdk.incubator.vector,\n@@ -193,0 +193,2 @@\n+        jdk.jdeps,\n+        jdk.jfr,\n@@ -197,0 +199,2 @@\n+        jdk.jdeps,\n+        jdk.jfr,\n@@ -198,0 +202,2 @@\n+    exports jdk.internal.classfile.components to\n+        jdk.jfr;\n@@ -200,0 +206,2 @@\n+        jdk.jdeps,\n+        jdk.jfr,\n@@ -202,0 +210,1 @@\n+        jdk.jdeps,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    private ReadWriteLock closeLock = new ReentrantReadWriteLock();\n+    private final ReadWriteLock closeLock = new ReentrantReadWriteLock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n+import jdk.internal.foreign.SegmentFactories;\n@@ -1195,1 +1194,1 @@\n-    private abstract static class Unmapper\n+    private sealed abstract static class Unmapper\n@@ -1198,1 +1197,1 @@\n-        private volatile long address;\n+        private final long address;\n@@ -1235,3 +1234,0 @@\n-            if (address == 0)\n-                return;\n-            address = 0;\n@@ -1255,1 +1251,1 @@\n-    private static class DefaultUnmapper extends Unmapper {\n+    private static final class DefaultUnmapper extends Unmapper {\n@@ -1288,1 +1284,1 @@\n-    private static class SyncUnmapper extends Unmapper {\n+    private static final class SyncUnmapper extends Unmapper {\n@@ -1379,16 +1375,1 @@\n-        if (unmapper != null) {\n-            AbstractMemorySegmentImpl segment =\n-                new MappedMemorySegmentImpl(unmapper.address(), unmapper, size,\n-                                            readOnly, sessionImpl);\n-            MemorySessionImpl.ResourceList.ResourceCleanup resource =\n-                new MemorySessionImpl.ResourceList.ResourceCleanup() {\n-                    @Override\n-                    public void cleanup() {\n-                        unmapper.unmap();\n-                    }\n-                };\n-            sessionImpl.addOrCleanupIfFail(resource);\n-            return segment;\n-        } else {\n-            return new MappedMemorySegmentImpl(0, null, 0, readOnly, sessionImpl);\n-        }\n+        return SegmentFactories.mapSegment(size, unmapper, readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+import jdk.internal.event.SocketReadEvent;\n+import jdk.internal.event.SocketWriteEvent;\n@@ -406,2 +408,1 @@\n-    @Override\n-    public int read(ByteBuffer buf) throws IOException {\n+    private int implRead(ByteBuffer buf) throws IOException {\n@@ -448,2 +449,1 @@\n-    @Override\n-    public long read(ByteBuffer[] dsts, int offset, int length)\n+    private long implRead(ByteBuffer[] dsts, int offset, int length)\n@@ -492,0 +492,25 @@\n+    @Override\n+    public int read(ByteBuffer buf) throws IOException {\n+        if (!SocketReadEvent.enabled()) {\n+            return implRead(buf);\n+        }\n+        long start = SocketReadEvent.timestamp();\n+        int nbytes = implRead(buf);\n+        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n+        return nbytes;\n+    }\n+\n+\n+    @Override\n+    public long read(ByteBuffer[] dsts, int offset, int length)\n+        throws IOException\n+    {\n+        if (!SocketReadEvent.enabled()) {\n+            return implRead(dsts, offset, length);\n+        }\n+        long start = SocketReadEvent.timestamp();\n+        long nbytes = implRead(dsts, offset, length);\n+        SocketReadEvent.offer(start, nbytes, remoteAddress(), 0);\n+        return nbytes;\n+    }\n+\n@@ -533,2 +558,1 @@\n-    @Override\n-    public int write(ByteBuffer buf) throws IOException {\n+    private int implWrite(ByteBuffer buf) throws IOException {\n@@ -562,2 +586,1 @@\n-    @Override\n-    public long write(ByteBuffer[] srcs, int offset, int length)\n+    private long implWrite(ByteBuffer[] srcs, int offset, int length)\n@@ -594,0 +617,24 @@\n+    @Override\n+    public int write(ByteBuffer buf) throws IOException {\n+        if (!SocketWriteEvent.enabled()) {\n+            return implWrite(buf);\n+        }\n+        long start = SocketWriteEvent.timestamp();\n+        int nbytes = implWrite(buf);\n+        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n+        return nbytes;\n+    }\n+\n+    @Override\n+    public long write(ByteBuffer[] srcs, int offset, int length)\n+        throws IOException\n+    {\n+        if (!SocketWriteEvent.enabled()) {\n+            return implWrite(srcs, offset, length);\n+        }\n+        long start = SocketWriteEvent.timestamp();\n+        long nbytes = implWrite(srcs, offset, length);\n+        SocketWriteEvent.offer(start, nbytes, remoteAddress());\n+        return nbytes;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":55,"deletions":8,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.io.InvalidObjectException;\n@@ -266,1 +267,1 @@\n-     *\n+     * <p>\n@@ -365,2 +366,4 @@\n-     * readObject is called to restore the state of the random object from\n-     * a stream.  We have to create a new instance of MessageDigest, because\n+     * This method is called to restore the state of the random object from\n+     * a stream.\n+     * <p>\n+     * We have to create a new instance of {@code MessageDigest}, because\n@@ -368,3 +371,3 @@\n-     *\n-     * Note that the engineNextBytes() method invoked on the restored random\n-     * object will yield the exact same (random) bytes as the original.\n+     * <p>\n+     * Note that the {@code engineNextBytes()} method invoked on the restored\n+     * random object will yield the exact same (random) bytes as the original.\n@@ -372,1 +375,5 @@\n-     * random object, using engineSetSeed().\n+     * random object, using {@code engineSetSeed()}.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -376,1 +383,1 @@\n-        throws IOException, ClassNotFoundException {\n+            throws IOException, ClassNotFoundException {\n@@ -395,0 +402,29 @@\n+\n+        \/\/ Various consistency checks\n+        if ((remainder == null) && (remCount > 0)) {\n+            throw new InvalidObjectException(\n+                    \"Remainder indicated, but no data available\");\n+        }\n+\n+        \/\/ Not yet allocated state\n+        if (state == null) {\n+            if (remainder == null) {\n+                return;\n+            } else {\n+                throw new InvalidObjectException(\n+                        \"Inconsistent buffer allocations\");\n+            }\n+        }\n+\n+        \/\/ Sanity check on sizes\/pointer\n+        if ((state.length != DIGEST_SIZE) ||\n+                ((remainder != null) && (remainder.length != DIGEST_SIZE)) ||\n+                (remCount < 0 ) || (remCount >= DIGEST_SIZE)) {\n+            throw new InvalidObjectException(\n+                    \"Inconsistent buffer sizes\/state\");\n+        }\n+\n+        state = state.clone();\n+        if (remainder != null) {\n+            remainder = remainder.clone();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -524,0 +524,14 @@\n+\\f[V]--enable-native-access\\f[R] \\f[I]module\\f[R][\\f[V],\\f[R]\\f[I]module\\f[R]...]\n+Native access involves access to code or data outside the Java runtime.\n+This is generally unsafe and, if done incorrectly, might crash the JVM\n+or result in memory corruption.\n+Methods that provide native access are restricted, and by default their\n+use causes warnings.\n+This option allows code in the specified modules to use restricted\n+methods without warnings.\n+\\f[I]module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to indicate code on the\n+class path.\n+When this option is present, any use of restricted methods by code\n+outside the specified modules causes an\n+\\f[V]IllegalCallerException\\f[R].\n+.TP\n@@ -533,4 +547,5 @@\n-Specifies where to find application modules with a list of path elements.\n-The elements of a module path can be a file path to a module or a directory\n-containing modules. Each module is either a modular JAR or an\n-exploded-module directory.\n+Specifies where to find application modules with a list of path\n+elements.\n+The elements of a module path can be a file path to a module or a\n+directory containing modules.\n+Each module is either a modular JAR or an exploded-module directory.\n@@ -539,2 +554,2 @@\n-On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this list;\n-on other platforms it is a colon (\\f[V]:\\f[R]).\n+On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this\n+list; on other platforms it is a colon (\\f[V]:\\f[R]).\n@@ -544,5 +559,5 @@\n-Specifies where to find module replacements of upgradeable modules in the\n-runtime image with a list of path elements.\n-The elements of a module path can be a file path to a module or a directory\n-containing modules. Each module is either a modular JAR or an\n-exploded-module directory.\n+Specifies where to find module replacements of upgradeable modules in\n+the runtime image with a list of path elements.\n+The elements of a module path can be a file path to a module or a\n+directory containing modules.\n+Each module is either a modular JAR or an exploded-module directory.\n@@ -551,2 +566,2 @@\n-On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this list;\n-on other platforms it is a colon (\\f[V]:\\f[R]).\n+On Windows, semicolons (\\f[V];\\f[R]) separate path elements in this\n+list; on other platforms it is a colon (\\f[V]:\\f[R]).\n@@ -557,1 +572,1 @@\n-\\f[I]module\\f[R] also can be \\f[V]ALL-DEFAULT\\f[R],\n+\\f[I]module\\f[R] can also be \\f[V]ALL-DEFAULT\\f[R],\n@@ -1119,1 +1134,2 @@\n-\\f[I]target-module\\f[R] can be all unnamed to read all unnamed modules.\n+\\f[I]target-module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to read all unnamed\n+modules.\n@@ -1124,2 +1140,2 @@\n-The \\f[I]target-module\\f[R] can be all unnamed to export to all unnamed\n-modules.\n+\\f[I]target-module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to export to all\n+unnamed modules.\n@@ -1328,0 +1344,1 @@\n+Multiple parameters can be specified by separating them with a comma.\n@@ -1393,3 +1410,0 @@\n-.PP\n-You can specify values for multiple parameters by separating them with a\n-comma.\n@@ -1682,0 +1696,3 @@\n+.PP\n+If %p and\/or %t is specified in the filename, it expands to the\n+JVM\\[aq]s PID and the current timestamp, respectively.\n@@ -1836,13 +1853,0 @@\n-\\f[V]-XX:+UseHugeTLBFS\\f[R]\n-\\f[B]Linux only:\\f[R] This option is the equivalent of specifying\n-\\f[V]-XX:+UseLargePages\\f[R].\n-This option is disabled by default.\n-This option pre-allocates all large pages up-front, when memory is\n-reserved; consequently the JVM can\\[aq]t dynamically grow or shrink\n-large pages memory areas; see \\f[V]-XX:UseTransparentHugePages\\f[R] if\n-you want this behavior.\n-.RS\n-.PP\n-See \\f[B]Large Pages\\f[R].\n-.RE\n-.TP\n@@ -2196,16 +2200,0 @@\n-Specify each method with the full class name (including the packages and\n-subpackages).\n-For example, to compile only the \\f[V]length()\\f[R] method of the\n-\\f[V]String\\f[R] class and the \\f[V]size()\\f[R] method of the\n-\\f[V]List\\f[R] class, use the following:\n-.RS\n-.RS\n-.PP\n-\\f[V]-XX:CompileOnly=java\/lang\/String.length,java\/util\/List.size\\f[R]\n-.RE\n-.PP\n-Note that the full class name is specified, including all packages and\n-subpackages separated by a slash (\\f[V]\/\\f[R]).\n-For easier cut and paste operations, it\\[aq]s also possible to use the\n-method name format produced by the \\f[V]-XX:+PrintCompilation\\f[R] and\n-\\f[V]-XX:+LogCompilation\\f[R] options:\n@@ -2214,7 +2202,1 @@\n-\\f[V]-XX:CompileOnly=java.lang.String::length,java.util.List::size\\f[R]\n-.RE\n-.PP\n-Although wildcards aren\\[aq]t supported, you can specify only the class\n-or package name to compile all methods in that class or package, as well\n-as specify just the method to compile methods with this name in any\n-class:\n+\\f[V]-XX:CompileOnly=method1,method2,...,methodN\\f[R] is an alias for:\n@@ -2224,3 +2206,4 @@\n--XX:CompileOnly=java\/lang\/String\n--XX:CompileOnly=java\/lang\n--XX:CompileOnly=.length\n+-XX:CompileCommand=compileonly,method1\n+-XX:CompileCommand=compileonly,method2\n+\\&...\n+-XX:CompileCommand=compileonly,methodN\n@@ -3694,8 +3677,0 @@\n-\\f[V]-XX:+UseSHM\\f[R]\n-\\f[B]Linux only:\\f[R] Enables the JVM to use shared memory to set up\n-large pages.\n-.RS\n-.PP\n-See \\f[B]Large Pages\\f[R] for setting up large pages.\n-.RE\n-.TP\n@@ -3854,0 +3829,13 @@\n+.TP\n+\\f[V]-XX:+UseHugeTLBFS\\f[R]\n+\\f[B]Linux only:\\f[R] This option is the equivalent of specifying\n+\\f[V]-XX:+UseLargePages\\f[R].\n+This option is disabled by default.\n+This option pre-allocates all large pages up-front, when memory is\n+reserved; consequently the JVM can\\[aq]t dynamically grow or shrink\n+large pages memory areas; see \\f[V]-XX:UseTransparentHugePages\\f[R] if\n+you want this behavior.\n+.TP\n+\\f[V]-XX:+UseSHM\\f[R]\n+\\f[B]Linux only:\\f[R] Enables the JVM to use shared memory to set up\n+large pages.\n@@ -4954,14 +4942,0 @@\n-.PP\n-When using the option \\f[V]-XX:+UseSHM\\f[R] to enable large pages you\n-also need to make sure the \\f[V]SHMMAX\\f[R] parameter is configured to\n-allow large enough shared memory segments to be allocated.\n-To allow a maximum shared segment of 8 GB, login as \\f[V]root\\f[R] and\n-run:\n-.RS\n-.PP\n-\\f[V]# echo 8589934592 > \/proc\/sys\/kernel\/shmmax\\f[R]\n-.RE\n-.PP\n-In some environments this is not needed since the default value is large\n-enough, but it is important to make sure the value is large enough to\n-fit the amount of memory intended to be backed by large pages.\n@@ -5134,0 +5108,12 @@\n+.PP\n+By default, when the \\f[V]-Xshare:dump\\f[R] option is used, the JVM runs\n+in interpreter-only mode (as if the \\f[V]-Xint\\f[R] option were\n+specified).\n+This is required for generating deterministic output in the shared\n+archive file.\n+I.e., the exact same archive will be generated, bit-for-bit, every time\n+you dump it.\n+However, if deterministic output is not needed, and you have a large\n+classlist, you can explicitly add \\f[V]-Xmixed\\f[R] to the command-line\n+to enable the JIT compiler.\n+This will speed up the archive creation.\n","filename":"src\/java.base\/share\/man\/java.1","additions":67,"deletions":81,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java 8315969 generic-all\n+\n@@ -74,0 +76,5 @@\n+compiler\/codecache\/CheckLargePages.java 8317831 linux-x64\n+\n+compiler\/floatingpoint\/TestSubnormalFloat.java 8317810 generic-i586\n+compiler\/floatingpoint\/TestSubnormalDouble.java 8317810 generic-i586\n+\n@@ -92,2 +99,1 @@\n-\n-runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8219652 aix-ppc64\n+runtime\/jni\/terminatedThread\/TestTerminatedThread.java 8317789 aix-ppc64\n@@ -104,2 +110,1 @@\n-runtime\/CompressedOops\/CompressedClassPointers.java 8305765 generic-all\n-runtime\/ErrorHandling\/TestDwarf.java 8305489 linux-all\n+runtime\/ErrorHandling\/TestDwarf.java#checkDecoder 8305489 linux-all\n@@ -108,0 +113,1 @@\n+runtime\/cds\/appcds\/customLoader\/HelloCustom_JFR.java 8241075 linux-all,windows-x64\n@@ -110,1 +116,0 @@\n-applications\/ctw\/modules\/jdk_crypto_ec.java 8312194 generic-all\n@@ -113,1 +118,3 @@\n-containers\/docker\/TestMemoryAwareness.java 8303470 linux-x64\n+containers\/docker\/TestMemoryAwareness.java 8303470 linux-all\n+\n+runtime\/CompressedOops\/CompressedClassPointers.java 8317610 linux-x64,windows-x64\n@@ -124,1 +131,1 @@\n-serviceability\/dcmd\/gc\/RunFinalizationTest.java 8227120 linux-all,windows-x64\n+serviceability\/dcmd\/gc\/RunFinalizationTest.java 8227120 linux-all,windows-x64,aix-ppc64\n@@ -133,0 +140,1 @@\n+serviceability\/sa\/ClhsdbDumpclass.java 8316342 generic-all\n@@ -136,0 +144,2 @@\n+serviceability\/jvmti\/stress\/StackTrace\/NotSuspended\/GetStackTraceNotSuspendedStressTest.java 8315980 linux-all,windows-x64\n+\n@@ -142,2 +152,0 @@\n-gtest\/NMTGtests.java#nmt-detail 8306561 aix-ppc64\n-gtest\/NMTGtests.java#nmt-summary 8306561 aix-ppc64\n@@ -157,4 +165,1 @@\n-vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI05\/ji05t001\/TestDescription.java 8219652 aix-ppc64\n-vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI06\/ji06t001\/TestDescription.java 8219652 aix-ppc64\n-vmTestbase\/nsk\/jvmti\/SetJNIFunctionTable\/setjniftab001\/TestDescription.java 8219652 aix-ppc64\n-vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/TestDescription.java 8288911 macosx-x64\n+vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/TestDescription.java 8288911 macosx-all\n@@ -177,0 +182,2 @@\n+\n+vmTestbase\/nsk\/monitoring\/ThreadMXBean\/findMonitorDeadlockedThreads\/find006\/TestDescription.java 8310144 macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"}]}