{"files":[{"patch":"@@ -0,0 +1,73 @@\n+#\n+# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+name: 'Setup CRIU '\n+description: 'Download and install CRIU to JDK'\n+inputs:\n+  jdk-path:\n+    description: 'Path to JDK root'\n+    required: true\n+\n+runs:\n+  using: composite\n+  steps:\n+    - name: 'Get CRIU URL configuration'\n+      id: criu_url\n+      uses: .\/.github\/actions\/config\n+      with:\n+        var: LINUX_X64_CRIU_URL\n+\n+    - name: 'Get CRIU SHA256 configuration'\n+      id: criu_sha256\n+      uses: .\/.github\/actions\/config\n+      with:\n+        var: LINUX_X64_CRIU_SHA256\n+\n+    - name: Restore CRIU from cache\n+      id: criu_cache\n+      uses: actions\/cache@v3\n+      with:\n+        path: ~\/criu\/criu\n+        key: criu-${{ runner.os }}-${{ steps.criu_url.outputs.value }}\n+\n+    - name: Download CRIU\n+      run: |\n+        CRIU_URL=${{ steps.criu_url.outputs.value }}\n+        CRIU_FILENAME=$(basename $CRIU_URL)\n+        wget --progress=dot:mega $CRIU_URL\n+        echo \"${{ steps.criu_sha256.outputs.value }} $CRIU_FILENAME\" | sha256sum -c >\/dev\/null -\n+        mkdir -p criu\/\n+        tar -xf $CRIU_FILENAME -C criu\n+        mv $(find criu\/ -type f -name criu) criu\/criu\n+      shell: bash\n+      if: steps.criu.outputs.cache-hit != 'true'\n+\n+    - name: Setup CRIU\n+      run: |\n+        JDK_CRIU=${{ inputs.jdk-path }}\/lib\/criu\n+        cp criu\/criu $JDK_CRIU\n+        sudo chown root:root $JDK_CRIU\n+        sudo chmod u+s $JDK_CRIU\n+      shell: bash\n","filename":".github\/actions\/setup-criu\/action.yml","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -55,3 +55,3 @@\n-          - s390x\n-          - ppc64le\n-          - riscv64\n+          # - s390x\n+          # - ppc64le\n+          # - riscv64\n@@ -72,18 +72,18 @@\n-          - target-cpu: s390x\n-            gnu-arch: s390x\n-            debian-arch: s390x\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: bullseye\n-            tolerate-sysroot-errors: false\n-          - target-cpu: ppc64le\n-            gnu-arch: powerpc64le\n-            debian-arch: ppc64el\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: bullseye\n-            tolerate-sysroot-errors: false\n-          - target-cpu: riscv64\n-            gnu-arch: riscv64\n-            debian-arch: riscv64\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: sid\n-            tolerate-sysroot-errors: true\n+#          - target-cpu: s390x\n+#            gnu-arch: s390x\n+#            debian-arch: s390x\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: bullseye\n+#            tolerate-sysroot-errors: false\n+#          - target-cpu: ppc64le\n+#            gnu-arch: powerpc64le\n+#            debian-arch: ppc64el\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: bullseye\n+#            tolerate-sysroot-errors: false\n+#          - target-cpu: riscv64\n+#            gnu-arch: riscv64\n+#            debian-arch: riscv64\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: sid\n+#            tolerate-sysroot-errors: true\n","filename":".github\/workflows\/build-cross-compile.yml","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+          - 'jdk\/crac'\n@@ -73,0 +74,3 @@\n+          - test-name: 'jdk\/crac'\n+            test-suite: 'test\/jdk\/jdk\/crac\/'\n+\n@@ -166,0 +170,6 @@\n+      - name: 'Setup CRIU'\n+        uses: .\/.github\/actions\/setup-criu\n+        with:\n+          jdk-path: ${{ steps.bundles.outputs.jdk-path }}\n+        if: runner.os == 'Linux' && matrix.test-name == 'jdk\/crac'\n+\n","filename":".github\/workflows\/test.yml","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=crac\n@@ -7,2 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n-warning=issuestitle\n+error=whitespace\n@@ -10,3 +9,3 @@\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=\n+[checks \"reviewers\"]\n+committers=1\n+ignore=duke\n@@ -17,20 +16,0 @@\n-\n-[checks \"whitespace\"]\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.S|.*\\.md|.*\\.properties|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n-ignore-tabs=.*\\.gmk|Makefile\n-\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n-[checks \"committer\"]\n-role=committer\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":5,"deletions":26,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,1 +1,24 @@\n-# Welcome to the JDK!\n+# CRaC JDK\n+\n+## Build\n+\n+CRaC JDK have extended build procedure.\n+\n+1. Build JDK as usual\n+```\n+bash configure\n+make images\n+mv build\/linux-x86_64-server-release\/images\/jdk\/ .\n+```\n+2. Download a build of [modified CRIU](https:\/\/github.com\/CRaC\/criu\/releases\/tag\/release-1.4)\n+3. Extract and copy `criu` binary over a same named file in the JDK\n+```\n+cp criu-dist\/sbin\/criu jdk\/lib\/criu\n+```\n+Grant permissions to allow regular user to run it\n+```\n+sudo chown root:root jdk\/lib\/criu\n+sudo chmod u+s jdk\/lib\/criu\n+```\n+\n+# JDK\n","filename":"README.md","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -229,0 +229,4 @@\n+$(eval $(call SetupBuildDemo, JavaCompilerCRaC, \\\n+    DEMO_SUBDIR := crac, \\\n+))\n+\n","filename":"make\/CompileDemos.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    -tag crac:cmopt:'CRaC:' \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,4 +24,13 @@\n-# This Makefile was generated by configure @DATE_WHEN_CONFIGURED@\n-# GENERATED FILE, DO NOT EDIT\n-SPEC:=@OUTPUTDIR@\/spec.gmk\n-include @WORKSPACE_ROOT@\/Makefile\n+AsyncGetCallTrace\n+jio_fprintf\n+jio_printf\n+jio_snprintf\n+jio_vfprintf\n+jio_vsnprintf\n+JNI_CreateJavaVM\n+JNI_GetCreatedJavaVMs\n+JNI_GetDefaultJavaVMInitArgs\n+JVM_IsForeignLinkerSupported\n+JVM_FindClassFromBootLoader\n+JVM_InitAgentProperties\n+JVM_Checkpoint\n","filename":"make\/autoconf\/Makefile.template","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    cpu_feature_active \\\n@@ -368,0 +369,22 @@\n+###############################################################################\n+# Check if glibc CPU_FEATURE_ACTIVE is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(cpu_feature_active, [\n+    AC_MSG_CHECKING([if glibc CPU_FEATURE_ACTIVE is supported])\n+    AC_COMPILE_IFELSE(\n+      [AC_LANG_PROGRAM([[#include <sys\/platform\/x86.h>]],\n+        [[int x = CPU_FEATURE_ACTIVE(SSE2);]])\n+      ],\n+      [\n+        AC_MSG_RESULT([yes])\n+      ],\n+      [\n+        AC_MSG_RESULT([no])\n+        AVAILABLE=false\n+      ]\n+    )\n+  ])\n+])\n+\n@@ -383,0 +406,1 @@\n+  JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE\n","filename":"make\/autoconf\/jvm-features.m4","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+LINUX_X64_CRIU_FILENAME=criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_URL=https:\/\/github.com\/CRaC\/criu\/releases\/download\/release-1.3\/criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_SHA256=82a014bf342c957305b98a71867c0994ebf6e7379f01f083121884793768d966\n+\n","filename":"make\/conf\/github-actions.conf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=ea\n+DEFAULT_PROMOTED_VERSION_PRE=\n","filename":"make\/conf\/version-numbers.conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,0 +151,4 @@\n+ifneq ($(call check-jvm-feature, cpu_feature_active), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_CPU_FEATURE_ACTIVE=0\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -781,1 +781,1 @@\n-        result.appendLine(\"protected int mult(long[] a, long[] b, long[] r) {\");\n+        result.appendLine(\"protected void mult(long[] a, long[] b, long[] r) {\");\n@@ -807,3 +807,0 @@\n-        result.appendIndent();\n-        result.append(\"return 0;\");\n-        result.appendLine();\n@@ -839,1 +836,1 @@\n-        result.appendLine(\"protected int square(long[] a, long[] r) {\");\n+        result.appendLine(\"protected void square(long[] a, long[] r) {\");\n@@ -880,3 +877,0 @@\n-        result.appendIndent();\n-        result.append(\"return 0;\");\n-        result.appendLine();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-        String simpleTypeName = element.getSimpleName().toString();\n+        String simpleTypeName = packagelessCanonicalName(typeElement).replace('.', '\/');\n@@ -318,0 +318,1 @@\n+    }\n@@ -319,7 +320,5 @@\n-        private static String packagelessCanonicalName(TypeElement element) {\n-            String result = element.getSimpleName().toString();\n-            while (element.getNestingKind() == NestingKind.MEMBER) {\n-                element = (TypeElement) element.getEnclosingElement();\n-                result = element.getSimpleName().toString() + '.' + result;\n-            }\n-            return result;\n+    private static String packagelessCanonicalName(TypeElement element) {\n+        String result = element.getSimpleName().toString();\n+        while (element.getNestingKind() == NestingKind.MEMBER) {\n+            element = (TypeElement) element.getEnclosingElement();\n+            result = element.getSimpleName().toString() + '.' + result;\n@@ -327,0 +326,1 @@\n+        return result;\n","filename":"make\/jdk\/src\/classes\/build\/tools\/taglet\/SealedGraph.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -103,0 +103,49 @@\n+\n+################################################################################\n+\n+ifeq ($(OPENJDK_TARGET_OS), linux)\n+  $(eval $(call SetupJdkExecutable, BUILD_CRIUENGINE, \\\n+      NAME := criuengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criuengine, \\\n+      INCLUDE_FILES := criuengine.c, \\\n+      OPTIMIZATION := HIGH, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_CRIUENGINE)\n+\n+endif\n+\n+ifeq ($(call isTargetOs, macosx linux windows), true)\n+  ifeq ($(OPENJDK_TARGET_OS), windows)\n+    CRAC_ENGINE_DIR = modules_cmds\n+  else\n+    CRAC_ENGINE_DIR = modules_libs\n+  endif\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n+      NAME := pauseengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/pauseengine, \\\n+      INCLUDE_FILES := pauseengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_PAUSEENGINE)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_SIMENGINE, \\\n+      NAME := simengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/simengine, \\\n+      INCLUDE_FILES := simengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_SIMENGINE)\n+\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    EXCLUDES := jdk\/test\/lib\/containers jdk\/test\/lib\/security, \\\n+    EXCLUDES := jdk\/test\/lib\/containers\/cgroup jdk\/test\/lib\/security, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,5 @@\n+public class Compile {\n+    public static void main(String... args) throws Exception {\n+        JavaCompilerCRaC.runJavac(args);\n+    }\n+}\n","filename":"src\/demo\/share\/crac\/JavaCompilerCRaC\/Compile.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+import java.util.Arrays;\n+import jdk.crac.Core;\n+\n+public class JavaCompilerCRaC {\n+\n+    static void runJavac(String... args) {\n+        System.out.println(\"javac \" + String.join(\" \", args));\n+        int status = com.sun.tools.javac.Main.compile(args);\n+        if (status != 0) {\n+            System.exit(status);\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        int startIdx = 0;\n+        for (int endIdx = 1; endIdx < args.length; ++endIdx) {\n+            if (args[endIdx].equals(\"--\")) {\n+                runJavac(Arrays.copyOfRange(args, startIdx, endIdx));\n+                startIdx = endIdx + 1;\n+            }\n+        }\n+\n+        if (startIdx < args.length) {\n+            runJavac(Arrays.copyOfRange(args, startIdx, args.length));\n+        }\n+\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"src\/demo\/share\/crac\/JavaCompilerCRaC\/JavaCompilerCRaC.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -66,0 +66,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -189,0 +191,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -127,0 +129,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -275,0 +275,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -409,0 +409,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -569,0 +571,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, unsigned long features[] = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -239,0 +239,15 @@\n+                                                                            \\\n+  product(ccstr, CPUFeatures, NULL, \"CPU feature set, \"                     \\\n+      \"use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when you \"    \\\n+      \"get an error during -XX:CRaCRestoreFrom on a different machine; \"    \\\n+      \"-XX:CPUFeatures=native is the default; \"                             \\\n+      \"-XX:CPUFeatures=ignore will disable the CPU features check; \"        \\\n+      \"-XX:CPUFeatures=generic is compatible but not as slow as 0\")         \\\n+                                                                            \\\n+  product(bool, ShowCPUFeatures, false, \"Show features of this CPU \"        \\\n+      \"to be possibly used for the -XX:CPUFeatures=0xnumber option\")        \\\n+                                                                            \\\n+  product(bool, IgnoreCPUFeatures, false, RESTORE_SETTABLE | EXPERIMENTAL,  \\\n+      \"Do not refuse to run after -XX:CRaCRestoreFrom finds out some \"      \\\n+      \"CPU features are missing\")\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-  __ mov64(rax, 0x1); \/\/ Return 1 (Fig. 5, Step 6 [1] skipped in montgomeryMultiply)\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -44,0 +45,3 @@\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# include <sys\/platform\/x86.h>\n+#endif\n@@ -50,0 +54,1 @@\n+uint64_t VM_Version::_glibc_features;\n@@ -52,1 +57,2 @@\n-const char* VM_Version::_features_names[] = { CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::      _features_names[] = {   CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::_glibc_features_names[] = { GLIBC_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n@@ -82,2 +88,11 @@\n-  assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), \"clflush should be available\");\n-  return true;\n+  if (!Universe::is_fully_initialized()) {\n+    return true;\n+  }\n+  if ((_features & CPU_FLUSH) != 0) {\n+    return true;\n+  }\n+  if (FLAG_IS_DEFAULT(CPUFeatures)) {\n+    vm_exit_during_initialization(\"clflush should be available\");\n+  }\n+  vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: \" UINT64_FORMAT_X, CPU_FLUSH));\n+  return false;\n@@ -799,1 +814,446 @@\n-void VM_Version::get_processor_features() {\n+uint64_t VM_Version::CPUFeatures_parse(uint64_t &glibc_features) {\n+  glibc_features = _glibc_features;\n+#ifndef LINUX\n+  _ignore_glibc_not_using = true;\n+  return _features;\n+#endif\n+  if (CPUFeatures == NULL || strcmp(CPUFeatures, \"native\") == 0) {\n+    return _features;\n+  }\n+  if (strcmp(CPUFeatures, \"ignore\") == 0) {\n+    _ignore_glibc_not_using = true;\n+    return _features;\n+  }\n+  glibc_features = 0;\n+  if (strcmp(CPUFeatures, \"generic\") == 0) {\n+    \/\/ 32-bit x86 cannot rely on anything.\n+    return 0\n+#ifdef AMD64\n+      \/\/ The following options are all in \/proc\/cpuinfo of one of the first 64-bit CPUs - Atom D2700 (and Opteron 1352): https:\/\/superuser.com\/q\/1572306\/1015048\n+      | CPU_SSE \/\/ enabled in 'gcc -Q --help=target', used by OpenJDK\n+      | CPU_SSE2 \/\/ enabled in 'gcc -Q --help=target', required by OpenJDK\n+      | CPU_FXSR \/\/ enabled in 'gcc -Q --help=target', not used by OpenJDK\n+      | CPU_MMX \/\/ enabled in 'gcc -Q --help=target', used only by 32-bit x86 OpenJDK\n+      | CPU_TSC \/\/ not used by gcc, used by OpenJDK\n+      | CPU_CX8 \/\/ gcc detects it to set cpu \"pentium\" (=32-bit only), used by OpenJDK\n+      | CPU_CMOV \/\/ gcc detects it to set cpu \"pentiumpro\" (=32-bit only), used by OpenJDK\n+      | CPU_FLUSH \/\/ =\"clflush\" in cpuinfo, not used by gcc, required by OpenJDK\n+      \/\/ GLIBC_MOVBE is disabled in 'gcc -Q --help=target' and some CPUs do not support it: https:\/\/stackoverflow.com\/a\/5246553\/2995591\n+      \/\/ GLIBC_LAHFSAHF is disabled in 'gcc -Q --help=target' and \"Early Intel Pentium 4 CPUs with Intel 64 support ... lacked the LAHF and SAHF instructions\"\n+#endif\n+    ;\n+  }\n+  char *endptr;\n+  errno = 0;\n+  uint64_t retval;\n+  unsigned long long ull = strtoull(CPUFeatures, &endptr, 0);\n+  retval = ull;\n+  if (!errno && *endptr == ',' && retval == ull) {\n+    ull = strtoull(endptr + 1, &endptr, 0);\n+    glibc_features = ull;\n+    if (!errno && !*endptr && glibc_features == ull) {\n+      return retval;\n+    }\n+  }\n+  vm_exit_during_initialization(err_msg(\"VM option 'CPUFeatures=%s' must be of the form: 0xnum,0xnum\", CPUFeatures));\n+  return -1;\n+}\n+\n+bool VM_Version::_ignore_glibc_not_using = false;\n+bool VM_Version::_crac_restore_missing_features;\n+#ifdef LINUX\n+const char VM_Version::glibc_prefix[] = \":glibc.cpu.hwcaps=\";\n+const size_t VM_Version::glibc_prefix_len = strlen(glibc_prefix);\n+\n+bool VM_Version::glibc_env_set(char *disable_str) {\n+#define TUNABLES_NAME \"GLIBC_TUNABLES\"\n+  char *env_val = disable_str;\n+  const char *env = getenv(TUNABLES_NAME);\n+  if (env && strcmp(env, env_val) == 0) {\n+    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Environment variable already set, glibc CPU_FEATURE_ACTIVE is unavailable - re-exec suppressed: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      return true;\n+    }\n+  }\n+  char env_buf[strlen(disable_str) + (!env ? 0 : strlen(env) + 100)];\n+  if (env) {\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+    }\n+    const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n+    if (!hwcaps) {\n+      strcpy(env_buf, env);\n+      strcat(env_buf, disable_str);\n+    } else {\n+      const char *colon = strchr(hwcaps, ':');\n+      if (!colon) {\n+        strcpy(env_buf, env);\n+        strcat(env_buf, disable_str + glibc_prefix_len);\n+      } else {\n+        int err = jio_snprintf(env_buf, sizeof(env_buf), \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n+        assert(err >= 0 && (unsigned)err < sizeof(env_buf), \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+      }\n+    }\n+    env_val = env_buf;\n+  }\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+  }\n+  int err = setenv(TUNABLES_NAME, env_val, 1);\n+  if (err)\n+    vm_exit_during_initialization(err_msg(\"setenv \" TUNABLES_NAME \" error: %m\"));\n+\n+#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n+  if (getenv(REEXEC_NAME))\n+    vm_exit_during_initialization(err_msg(\"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str));\n+  if (setenv(REEXEC_NAME, \"1\", 1))\n+    vm_exit_during_initialization(err_msg(\"setenv \" REEXEC_NAME \" error: %m\"));\n+#undef REEXEC_NAME\n+#undef TUNABLES_NAME\n+  return false;\n+}\n+\n+void VM_Version::glibc_reexec() {\n+  char *buf = NULL;\n+  size_t buf_allocated = 0;\n+  size_t buf_used = 0;\n+#define CMDLINE \"\/proc\/self\/cmdline\"\n+  int fd = open(CMDLINE, O_RDONLY);\n+  if (fd == -1)\n+    vm_exit_during_initialization(err_msg(\"Cannot open \" CMDLINE \": %m\"));\n+  ssize_t got;\n+  do {\n+    if (buf_used == buf_allocated) {\n+      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n+      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n+      if (buf == NULL)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu bytes\", buf_allocated));\n+    }\n+    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n+    if (got == -1)\n+      vm_exit_during_initialization(err_msg(\"Cannot read \" CMDLINE \": %m\"));\n+    buf_used += got;\n+  } while (got);\n+  if (close(fd))\n+    vm_exit_during_initialization(err_msg(\"Cannot close \" CMDLINE \": %m\"));\n+  char **argv = NULL;\n+  size_t argv_allocated = 0;\n+  size_t argv_used = 0;\n+  char *s = buf;\n+  while (s <= buf + buf_used) {\n+    if (argv_used == argv_allocated) {\n+      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n+      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n+      if (argv == NULL)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu pointers\", argv_allocated));\n+    }\n+    if (s == buf + buf_used) {\n+      break;\n+    }\n+    argv[argv_used++] = s;\n+    s += strnlen(s, buf + buf_used - s);\n+    if (s == buf + buf_used)\n+      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n+    ++s;\n+  }\n+  argv[argv_used] = NULL;\n+#undef CMDLINE\n+\n+#define EXEC \"\/proc\/self\/exe\"\n+  execv(EXEC, argv);\n+  vm_exit_during_initialization(err_msg(\"Cannot re-execute \" EXEC \": %m\"));\n+#undef EXEC\n+}\n+\n+void VM_Version::glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC) {\n+#ifndef ASSERT\n+  if (!excessive_CPU && !excessive_GLIBC)\n+    return;\n+#endif\n+\n+  \/\/ glibc: sysdeps\/x86\/get-isa-level.h:\n+  \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMOV)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, CX8)\n+  \/\/ glibc:     && CPU_FEATURE_CPU_P (cpu_features, FPU)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FXSR)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MMX)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE2))\n+  \/\/ glibc:     isa_level = GNU_PROPERTY_X86_ISA_1_BASELINE;\n+  if ((_features & CPU_CMOV) &&\n+      (_features & CPU_CX8) &&\n+      \/\/ FPU is always present on i686+: (_features & CPU_FPU) &&\n+      (_features & CPU_SSE2)) {\n+    \/\/ These cannot be disabled by GLIBC_TUNABLES.\n+    if (excessive_CPU & (CPU_FXSR | CPU_MMX | CPU_SSE)) {\n+      assert(!(excessive_CPU & CPU_SSE2), \"CPU_SSE2 in both _features and excessive_CPU cannot happen\");\n+      \/\/ FIXME: The choice should be based on glibc impact, not the feature age.\n+      \/\/ CX8 is i586+, CMOV is i686+ 1995+, SSE2 is 2000+\n+      excessive_CPU |= CPU_SSE2;\n+    }\n+    if ((_features & CPU_FXSR) &&\n+        (_features & CPU_MMX) &&\n+        (_features & CPU_SSE)) {\n+      \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMPXCHG16B)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LAHF64_SAHF64)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, POPCNT)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_1)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_2))\n+      \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V2;\n+      if ((_features & CPU_POPCNT) &&\n+          (_features & CPU_SSSE3) &&\n+          (_features & CPU_SSE4_1) &&\n+          (_features & CPU_SSE4_2)) {\n+        if ((excessive_CPU & CPU_SSE3) ||\n+            (excessive_GLIBC & (GLIBC_CMPXCHG16 | GLIBC_LAHFSAHF))) {\n+          assert(!(excessive_CPU & CPU_SSE4_2), \"CPU_SSE4_2 in both _features and excessive_CPU cannot happen\");\n+          \/\/ POPCNT is 2007+, SSSE3 is 2006+, SSE4_1 is 2007+, SSE4_2 is 2008+.\n+          excessive_CPU |= CPU_SSE4_2;\n+        }\n+        if ((_features & CPU_SSE3) &&\n+            (_glibc_features & GLIBC_CMPXCHG16) &&\n+            (_glibc_features & GLIBC_LAHFSAHF)) {\n+          \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI1)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, F16C)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FMA)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LZCNT)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MOVBE))\n+          \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V3;\n+          if ((_features & CPU_AVX) &&\n+              (_features & CPU_AVX2) &&\n+              (_features & CPU_BMI1) &&\n+              (_features & CPU_BMI2) &&\n+              (_features & CPU_FMA) &&\n+              (_features & CPU_LZCNT) &&\n+              (_glibc_features & GLIBC_MOVBE)) {\n+            if (excessive_GLIBC & GLIBC_F16C) {\n+              assert(!(excessive_GLIBC & GLIBC_MOVBE), \"GLIBC_MOVBE in both _glibc_features and excessive_GLIBC cannot happen\");\n+              \/\/ FMA is 2012+, AVX2+BMI1+BMI2+LZCNT are 2013+, MOVBE is 2015+\n+              excessive_GLIBC |= GLIBC_MOVBE;\n+            }\n+            if (_glibc_features & GLIBC_F16C) {\n+              \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX512F)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512BW)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512CD)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512DQ)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512VL))\n+              \/\/ glibc:   isa_level |= GNU_PROPERTY_X86_ISA_1_V4;\n+              \/\/ All these flags are supported by GLIBC_DISABLE below.\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  uint64_t disable_CPU   = 0;\n+  uint64_t disable_GLIBC = 0;\n+#define PASTE_TOKENS3(x, y, z) PASTE_TOKENS(x, PASTE_TOKENS(y, z))\n+#ifdef ASSERT\n+  uint64_t excessive_handled_CPU   = 0;\n+  uint64_t excessive_handled_GLIBC = 0;\n+  uint64_t disable_handled_CPU   = 0;\n+  uint64_t disable_handled_GLIBC = 0;\n+#endif\n+#define EXCESSIVE_HANDLED(kind, hotspot) do {                                                                                         \\\n+    assert(!(PASTE_TOKENS(excessive_handled_, kind) & PASTE_TOKENS3(kind, _, hotspot)), \"already used \" STR(kind) \"_\" STR(hotspot) ); \\\n+    DEBUG_ONLY(PASTE_TOKENS(excessive_handled_, kind) |= PASTE_TOKENS3(kind, _, hotspot));                                            \\\n+  } while (0)\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# define FEATURE_ACTIVE(glibc) CPU_FEATURE_ACTIVE(glibc)\n+#else\n+# define FEATURE_ACTIVE(glibc) true\n+#endif\n+#define EXCESSIVE3(kind, hotspot, glibc) do {                                                        \\\n+    EXCESSIVE_HANDLED(kind, hotspot);                                                                \\\n+    if (PASTE_TOKENS(excessive_, kind) & PASTE_TOKENS3(kind, _, hotspot) && FEATURE_ACTIVE(glibc)) { \\\n+      PASTE_TOKENS(disable_, kind) |= PASTE_TOKENS3(kind, _, hotspot);                               \\\n+    }                                                                                                \\\n+  } while (0)\n+#define EXCESSIVE(kind, hotspotglibc) EXCESSIVE3(kind, hotspotglibc, hotspotglibc)\n+  EXCESSIVE(CPU  , AVX     );\n+  EXCESSIVE(CPU  , CX8     );\n+  EXCESSIVE(CPU  , FMA     );\n+  EXCESSIVE(CPU  , RTM     );\n+  EXCESSIVE(CPU  , AVX2    );\n+  EXCESSIVE(CPU  , BMI1    );\n+  EXCESSIVE(CPU  , BMI2    );\n+  EXCESSIVE(CPU  , CMOV    );\n+  EXCESSIVE(CPU  , ERMS    );\n+  EXCESSIVE(CPU  , SSE2    );\n+  EXCESSIVE(CPU  , LZCNT   );\n+  EXCESSIVE(CPU  , SSSE3   );\n+  EXCESSIVE(CPU  , POPCNT  );\n+  EXCESSIVE(CPU  , SSE4_1  );\n+  EXCESSIVE(CPU  , SSE4_2  );\n+  EXCESSIVE(CPU  , AVX512F );\n+  EXCESSIVE(CPU  , AVX512CD);\n+  EXCESSIVE(CPU  , AVX512BW);\n+  EXCESSIVE(CPU  , AVX512DQ);\n+  EXCESSIVE(CPU  , AVX512ER);\n+  EXCESSIVE(CPU  , AVX512PF);\n+  EXCESSIVE(CPU  , AVX512VL);\n+  EXCESSIVE3(CPU , CET_IBT , IBT  );\n+  EXCESSIVE3(CPU , CET_SS  , SHSTK);\n+  EXCESSIVE(GLIBC, FMA4    );\n+  EXCESSIVE(GLIBC, MOVBE   );\n+  EXCESSIVE(GLIBC, XSAVE   );\n+  EXCESSIVE(GLIBC, OSXSAVE );\n+  EXCESSIVE(GLIBC, HTT     );\n+#undef EXCESSIVE\n+#undef EXCESSIVE3\n+\n+  char disable_str[64 * (10 + 3) + 1];\n+  strcpy(disable_str, glibc_prefix);\n+  char *disable_end = disable_str + glibc_prefix_len;\n+#define GLIBC_DISABLE2(kind, hotspot, glibc) do {                                                                                   \\\n+    assert(!(PASTE_TOKENS(disable_handled_, kind) & PASTE_TOKENS3(kind, _, hotspot)), \"already used \" STR(kind) \"_\" STR(hotspot) ); \\\n+    DEBUG_ONLY(PASTE_TOKENS(disable_handled_, kind) |= PASTE_TOKENS3(kind, _, hotspot));                                            \\\n+    if (PASTE_TOKENS(disable_, kind) & PASTE_TOKENS3(kind, _, hotspot)) {                                                           \\\n+      const char str[] = \",-\" STR(glibc);                                                                                           \\\n+      size_t remains = disable_str + sizeof(disable_str) - disable_end;                                                             \\\n+      strncpy(disable_end, str, remains);                                                                                           \\\n+      size_t len = strnlen(disable_end, remains);                                                                                   \\\n+      remains -= len;                                                                                                               \\\n+      assert(remains > 0, \"internal error: disable_str overflow\");                                                                  \\\n+      disable_end += len;                                                                                                           \\\n+    }                                                                                                                               \\\n+  } while (0);\n+#define GLIBC_DISABLE(kind, hotspot_glibc) GLIBC_DISABLE2(kind, hotspot_glibc, hotspot_glibc)\n+  GLIBC_DISABLE(CPU  , AVX)\n+  GLIBC_DISABLE(CPU  , CX8)\n+  GLIBC_DISABLE(CPU  , FMA)\n+  GLIBC_DISABLE(CPU  , RTM)\n+  GLIBC_DISABLE(CPU  , AVX2)\n+  GLIBC_DISABLE(CPU  , BMI1)\n+  GLIBC_DISABLE(CPU  , BMI2)\n+  GLIBC_DISABLE(CPU  , CMOV)\n+  GLIBC_DISABLE(CPU  , ERMS)\n+  GLIBC_DISABLE(CPU  , SSE2)\n+  GLIBC_DISABLE(CPU  , LZCNT)\n+  GLIBC_DISABLE(CPU  , SSSE3)\n+  GLIBC_DISABLE(CPU  , POPCNT)\n+  GLIBC_DISABLE(CPU  , SSE4_1)\n+  GLIBC_DISABLE(CPU  , SSE4_2)\n+  GLIBC_DISABLE(CPU  , AVX512F)\n+  GLIBC_DISABLE(CPU  , AVX512CD)\n+  GLIBC_DISABLE(CPU  , AVX512BW)\n+  GLIBC_DISABLE(CPU  , AVX512DQ)\n+  GLIBC_DISABLE(CPU  , AVX512ER)\n+  GLIBC_DISABLE(CPU  , AVX512PF)\n+  GLIBC_DISABLE(CPU  , AVX512VL)\n+  GLIBC_DISABLE2(CPU , CET_IBT, IBT)\n+  GLIBC_DISABLE2(CPU , CET_SS , SHSTK)\n+  GLIBC_DISABLE(GLIBC, FMA4)\n+  GLIBC_DISABLE(GLIBC, MOVBE)\n+  GLIBC_DISABLE(GLIBC, XSAVE)\n+  GLIBC_DISABLE(GLIBC, OSXSAVE)\n+  GLIBC_DISABLE(GLIBC, HTT)\n+#undef GLIBC_DISABLE\n+#undef GLIBC_DISABLE2\n+  *disable_end = 0;\n+\n+#ifdef ASSERT\n+#define CHECK_KIND(kind) do {                                                                                                            \\\n+    if (PASTE_TOKENS(disable_handled_, kind) != PASTE_TOKENS(excessive_handled_, kind))                                                  \\\n+      vm_exit_during_initialization(err_msg(\"internal error: Unsupported disabling of \" STR(kind) \"_* 0x%\" PRIx64 \" != used 0x%\" PRIx64, \\\n+                                            PASTE_TOKENS(disable_handled_, kind), PASTE_TOKENS(excessive_handled_, kind)));              \\\n+  } while (0)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+\n+  \/\/ These cannot be disabled by GLIBC_TUNABLES interface.\n+#define GLIBC_UNSUPPORTED(kind, hotspot) EXCESSIVE_HANDLED(kind, hotspot)\n+  GLIBC_UNSUPPORTED(CPU  , 3DNOW_PREFETCH   );\n+  GLIBC_UNSUPPORTED(CPU  , SSE4A            );\n+  GLIBC_UNSUPPORTED(CPU  , TSC              );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV_BIT       );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV           );\n+  GLIBC_UNSUPPORTED(CPU  , AES              );\n+  GLIBC_UNSUPPORTED(CPU  , CLMUL            );\n+  GLIBC_UNSUPPORTED(CPU  , ADX              );\n+  GLIBC_UNSUPPORTED(CPU  , SHA              );\n+  GLIBC_UNSUPPORTED(CPU  , VZEROUPPER       );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPOPCNTDQ );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPCLMULQDQ);\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VAES      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VNNI      );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSH            );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSHOPT         );\n+  GLIBC_UNSUPPORTED(CPU  , CLWB             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI2     );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI      );\n+  GLIBC_UNSUPPORTED(CPU  , HV               );\n+  GLIBC_UNSUPPORTED(CPU  , SSE3             );\n+  GLIBC_UNSUPPORTED(CPU  , SERIALIZE        );\n+  GLIBC_UNSUPPORTED(CPU  , RDTSCP           );\n+  GLIBC_UNSUPPORTED(CPU  , RDPID            );\n+  GLIBC_UNSUPPORTED(CPU  , FSRM             );\n+  GLIBC_UNSUPPORTED(CPU  , GFNI             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_BITALG    );\n+  GLIBC_UNSUPPORTED(CPU  , F16C             );\n+  GLIBC_UNSUPPORTED(CPU  , PKU              );\n+  GLIBC_UNSUPPORTED(CPU  , OSPKE            );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_IFMA      );\n+  \/\/ These are handled as an exception above.\n+  GLIBC_UNSUPPORTED(CPU  , FXSR             );\n+  GLIBC_UNSUPPORTED(CPU  , MMX              );\n+  GLIBC_UNSUPPORTED(CPU  , SSE              );\n+  GLIBC_UNSUPPORTED(CPU  , HT               );\n+  GLIBC_UNSUPPORTED(GLIBC, CMPXCHG16        );\n+  GLIBC_UNSUPPORTED(GLIBC, LAHFSAHF         );\n+  GLIBC_UNSUPPORTED(GLIBC, F16C             );\n+#undef GLIBC_UNSUPPORTED\n+#define CHECK_KIND(kind) do {                                                                                                                 \\\n+    if (PASTE_TOKENS(excessive_handled_, kind) != PASTE_TOKENS(MAX_, kind) - 1)                                                               \\\n+      vm_exit_during_initialization(err_msg(\"internal error: Unsupported disabling of some \" STR(kind) \"_* 0x%\" PRIx64 \" != full 0x%\" PRIx64, \\\n+                                            PASTE_TOKENS(excessive_handled_, kind), PASTE_TOKENS(MAX_, kind) - 1));                           \\\n+  } while (0)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+#endif \/\/ ASSERT\n+\n+  if (disable_end == disable_str + glibc_prefix_len)\n+    return;\n+  if (glibc_env_set(disable_str))\n+    return;\n+  glibc_reexec();\n+}\n+#endif \/\/LINUX\n+\n+void VM_Version::nonlibc_tty_print_uint64(uint64_t num) {\n+  static const char prefix[] = \"0x\";\n+  tty->write(prefix, sizeof(prefix) - 1);\n+  bool first = true;\n+  for (int pos = 64 - 4; pos >= 0; pos -= 4) {\n+    unsigned nibble = (num >> pos) & 0xf;\n+    if (first && nibble == 0 && pos)\n+      continue;\n+    first = false;\n+    char c = nibble >= 0xa ? 'a' + nibble - 0xa : '0' + nibble;\n+    tty->write(&c, sizeof(c));\n+  }\n+}\n+\n+void VM_Version::nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2) {\n+  nonlibc_tty_print_uint64(num1);\n+  static const char comma = ',';\n+  tty->print_raw(&comma, sizeof(comma));\n+  nonlibc_tty_print_uint64(num2);\n+}\n+\n+void VM_Version::print_using_features_cr() {\n+  if (_ignore_glibc_not_using) {\n+    tty->print_cr(\"CPU features are being kept intact as requested by -XX:CPUFeatures=ignore\");\n+  } else {\n+    tty->print_cr(\"CPU features being used are: -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, _features, _glibc_features);\n+  }\n+}\n@@ -801,0 +1261,1 @@\n+void VM_Version::get_processor_features_hardware() {\n@@ -805,0 +1266,1 @@\n+  _glibc_features = 0;\n@@ -821,0 +1283,1 @@\n+    LINUX_ONLY(_glibc_features = _cpuid_info.glibc_flags();)\n@@ -833,0 +1296,9 @@\n+  if (ShowCPUFeatures) {\n+    static const char prefix[] = \"This machine's CPU features are: -XX:CPUFeatures=\";\n+    tty->print_raw(prefix, sizeof(prefix) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    tty->cr();\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hotspot() {\n@@ -836,0 +1308,2 @@\n+    if (!FLAG_IS_DEFAULT(CPUFeatures))\n+      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, CPU_SSE2, (uint64_t)0));\n@@ -1026,1 +1500,1 @@\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  insert_features_names(buf + res, sizeof(buf) - res);\n@@ -2121,0 +2595,72 @@\n+\/\/ Print the feature names as \" = feat1, ..., featN\\n\";\n+void VM_Version::missing_features(uint64_t features_missing, uint64_t glibc_features_missing) {\n+  static const char part1[] = \"; missing features of this CPU are \";\n+  tty->print_raw(part1, sizeof(part1) - 1);\n+  nonlibc_tty_print_uint64_comma_uint64(features_missing, glibc_features_missing);\n+  static const char part2[] = \" =\";\n+  tty->print_raw(part2, sizeof(part2) - 1);\n+  char buf[512] = \"\";\n+  \/\/ insert_features_names() does crash for undefined too high-numbered features.\n+  insert_features_names(buf, sizeof(buf)          ,       features_missing & (  MAX_CPU - 1));\n+  char *s = buf;\n+  while (*s)\n+    ++s;\n+  insert_features_names(s  , buf + sizeof(buf) - s, glibc_features_missing & (MAX_GLIBC - 1));\n+  while (*s)\n+    ++s;\n+  \/* +1 to skip the first ','. *\/\n+  tty->print_raw(buf + 1, s - (buf + 1));\n+  tty->cr();\n+  static const char line2[] = \"If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures .\";\n+  tty->print_raw(line2, sizeof(line2) - 1);\n+  tty->cr();\n+}\n+\n+void VM_Version::crac_restore() {\n+  assert(CRaCCheckpointTo != NULL, \"\");\n+\n+  if (ShowCPUFeatures) {\n+    static const char prefix[] = \"This snapshot's stored CPU features are: -XX:CPUFeatures=\";\n+    tty->print_raw(prefix, sizeof(prefix) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    tty->cr();\n+  }\n+\n+  VM_Version::CpuidInfo cpuid_info = { 0, };\n+  get_cpu_info_stub(&cpuid_info);\n+  cpuid_info.assert_is_initialized();\n+\n+  uint64_t       new_cpu_features = 0;\n+  uint64_t new_cpu_glibc_features = 0;\n+  if (cpuid_info.extended_cpu_family() > 4) { \/\/ it supports CPUID\n+    new_cpu_features = cpuid_info.feature_flags();\n+    LINUX_ONLY(new_cpu_glibc_features = cpuid_info.glibc_flags();)\n+  }\n+\n+  uint64_t       features_missing =       _features & ~      new_cpu_features;\n+  uint64_t glibc_features_missing = _glibc_features & ~new_cpu_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  _crac_restore_missing_features = features_missing || glibc_features_missing;\n+  if (_crac_restore_missing_features) {\n+    static const char part1[] = \"You have to specify -XX:CPUFeatures=\";\n+    tty->print_raw(part1, sizeof(part1) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(new_cpu_features & _features, new_cpu_glibc_features & _glibc_features);\n+    static const char part2[] = \" together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features \";\n+    tty->print_raw(part2, sizeof(part2) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    missing_features(features_missing, glibc_features_missing);\n+  }\n+\n+  if (ShowCPUFeatures)\n+    print_using_features_cr();\n+}\n+\n+void VM_Version::crac_restore_finalize() {\n+  if (_crac_restore_missing_features && !IgnoreCPUFeatures) {\n+    vm_exit_during_initialization();\n+  }\n+}\n+\n@@ -2163,1 +2709,47 @@\n-  get_processor_features();\n+  assert(      _features == 0,       \"_features should be zero at startup\");\n+  assert(_glibc_features == 0, \"_glibc_features should be zero at startup\");\n+  get_processor_features_hardware();\n+\n+  assert(!CPUFeatures == FLAG_IS_DEFAULT(CPUFeatures), \"CPUFeatures parsing\");\n+  uint64_t GLIBCFeatures_x64;\n+  uint64_t   CPUFeatures_x64 = CPUFeatures_parse(GLIBCFeatures_x64);\n+  uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+  uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  if (features_missing || glibc_features_missing) {\n+    static const char part1[] = \"Specified -XX:CPUFeatures=\";\n+    tty->print_raw(part1, sizeof(part1) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(CPUFeatures_x64, GLIBCFeatures_x64);\n+    static const char part2[] = \"; this machine's CPU features are \";\n+    tty->print_raw(part2, sizeof(part2) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    missing_features(features_missing, glibc_features_missing);\n+    vm_exit_during_initialization();\n+  }\n+\n+  uint64_t       features_saved =       _features;\n+  uint64_t glibc_features_saved = _glibc_features;\n+\n+        _features =   CPUFeatures_x64;\n+  _glibc_features = GLIBCFeatures_x64;\n+\n+  if (ShowCPUFeatures)\n+    print_using_features_cr();\n+\n+#ifdef LINUX\n+  if (!_ignore_glibc_not_using) {\n+    uint64_t       features_expected =   MAX_CPU - 1;\n+    uint64_t glibc_features_expected = MAX_GLIBC - 1;\n+    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+            features_expected =       features_saved;\n+      glibc_features_expected = glibc_features_saved;\n+    }\n+    glibc_not_using(      features_expected & ~      _features,\n+                    glibc_features_expected & ~_glibc_features);\n+  }\n+#endif\n+\n+  get_processor_features_hotspot();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":598,"deletions":6,"binary":false,"changes":604,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -85,1 +86,2 @@\n-                        : 2,\n+                        : 1,\n+               movbe    : 1,\n@@ -89,1 +91,1 @@\n-                        : 1,\n+               xsave    : 1,\n@@ -156,1 +158,3 @@\n-                            : 23;\n+                            : 7,\n+               fma4         : 1,\n+                            : 15;\n@@ -408,0 +412,1 @@\n+    MAX_CPU = CPU_AVX512_IFMA << 1\n@@ -410,0 +415,21 @@\n+  \/* Tracking of a CPU feature for glibc *\/ \\\n+  enum Glibc_Feature_Flag : uint64_t {\n+#define GLIBC_FEATURE_FLAGS(decl) \\\n+    decl(FMA4,              \"fma4\",               0) \\\n+    decl(MOVBE,             \"movbe\",              1) \\\n+    decl(OSXSAVE,           \"osxsave\",            2) \\\n+    decl(XSAVE,             \"xsave\",              3) \\\n+    decl(CMPXCHG16,         \"cmpxchg16\",          4) \/* Also known in cpuinfo as cx16 and in glibc as cmpxchg16b *\/ \\\n+    decl(LAHFSAHF,          \"lahfsahf\",           5) \/* Also known in cpuinfo as lahf_lm and in glibc as lahf64_sahf64 *\/ \\\n+    decl(F16C,              \"f16c\",               6) \\\n+    decl(HTT,               \"htt\",                7) \/* hotspot calls it 'ht' but it is affected by threads_per_core() *\/\n+\n+#define DECLARE_GLIBC_FEATURE_FLAG(id, name, bit) GLIBC_##id = (1ULL << bit),\n+    GLIBC_FEATURE_FLAGS(DECLARE_GLIBC_FEATURE_FLAG)\n+#undef DECLARE_GLIBC_FEATURE_FLAG\n+    MAX_GLIBC = GLIBC_HTT << 1\n+  };\n+\n+  \/\/ glibc feature flags.\n+  static uint64_t _glibc_features;\n+\n@@ -411,0 +437,1 @@\n+  static const char* _glibc_features_names[];\n@@ -542,0 +569,23 @@\n+#ifdef LINUX\n+    uint64_t glibc_flags() const {\n+      uint64_t result = 0;\n+      if (std_cpuid1_ecx.bits.movbe != 0)\n+        result |= GLIBC_MOVBE;\n+      if (std_cpuid1_ecx.bits.osxsave != 0)\n+        result |= GLIBC_OSXSAVE;\n+      if (std_cpuid1_ecx.bits.xsave != 0)\n+        result |= GLIBC_XSAVE;\n+      if (std_cpuid1_ecx.bits.cmpxchg16 != 0)\n+        result |= GLIBC_CMPXCHG16;\n+      if (std_cpuid1_ecx.bits.f16c != 0)\n+        result |= GLIBC_F16C;\n+      if (ext_cpuid1_ecx.bits.fma4 != 0)\n+        result |= GLIBC_FMA4;\n+      if (ext_cpuid1_ecx.bits.LahfSahf != 0)\n+        result |= GLIBC_LAHFSAHF;\n+      if (std_cpuid1_edx.bits.ht != 0)\n+        result |= GLIBC_HTT;\n+      return result;\n+    }\n+#endif \/\/LINUX\n+\n@@ -578,0 +628,20 @@\n+  static void get_processor_features_hardware();\n+  static void get_processor_features_hotspot();\n+\n+  static uint64_t CPUFeatures_parse(uint64_t &glibc_features);\n+#ifdef LINUX\n+  static void glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC);\n+  static bool glibc_env_set(char *disable_str);\n+  \/*[[noreturn]]*\/ static void glibc_reexec();\n+  \/\/ C++17: Make glibc_prefix and glibc_prefix_len constexpr.\n+  static const char glibc_prefix[];\n+  static const size_t glibc_prefix_len;\n+#endif \/\/LINUX\n+  \/\/ C++17: Make _ignore_glibc_not_using inline.\n+  static bool _ignore_glibc_not_using;\n+  static bool _crac_restore_missing_features;\n+  static void nonlibc_tty_print_uint64(uint64_t num);\n+  static void nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2);\n+  static void print_using_features_cr();\n+  \/*[[noreturn]]*\/ static void missing_features(uint64_t features_missing, uint64_t glibc_features_missing);\n+\n@@ -613,0 +683,7 @@\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _features_names, features);\n+  }\n+  static void insert_glibc_features_names(char* buf, size_t buflen, uint64_t glibc_features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _glibc_features_names, glibc_features);\n+  }\n+\n@@ -615,0 +692,2 @@\n+  static void crac_restore();\n+  static void crac_restore_finalize();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":82,"deletions":3,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+define_pd_global(ccstrlist, CRAllowedOpenFilePrefixes, nullptr);\n","filename":"src\/hotspot\/os\/aix\/globals_aix.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+define_pd_global(ccstrlist, CRAllowedOpenFilePrefixes, nullptr);\n","filename":"src\/hotspot\/os\/bsd\/globals_bsd.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,498 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include <string.h>\n+\n+#include \"jvm.h\"\n+#include \"perfMemory_linux.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+\n+#include <netinet\/in.h>\n+\n+class FdsInfo {\n+public:\n+\n+  enum state_t {\n+    INVALID = -3,\n+    CLOSED = -2,\n+    ROOT = -1,\n+    DUP_OF_0 = 0,\n+    \/\/ ...\n+  };\n+\n+  enum mark_t {\n+    M_CANT_RESTORE = 1 << 0,\n+  };\n+\n+private:\n+  struct fdinfo {\n+    int fd;\n+    struct stat stat;\n+    state_t state;\n+    unsigned mark;\n+\n+    int flags;\n+  };\n+\n+  \/\/ params are indices into _fdinfos\n+  bool same_fd(int i1, int i2);\n+\n+  bool _inited;\n+  GrowableArray<fdinfo> _fdinfos;\n+\n+  void assert_mark(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    assert(_fdinfos.at(i).state != CLOSED, \"\");\n+  }\n+\n+public:\n+  void initialize();\n+\n+  int len() { return _fdinfos.length(); }\n+\n+  state_t get_state(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).state;\n+  }\n+\n+  state_t find_state(int fd, state_t orstate) {\n+    for (int i = 0; i < _fdinfos.length(); ++i) {\n+      fdinfo *info = _fdinfos.adr_at(i);\n+      if (info->fd == fd) {\n+        return info->state;\n+      }\n+    }\n+    return orstate;\n+  }\n+\n+  int get_fd(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).fd;\n+  }\n+\n+  struct stat* get_stat(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return &_fdinfos.at(i).stat;\n+  }\n+\n+  FdsInfo(bool do_init = true) :\n+    _inited(false),\n+    _fdinfos(16, mtInternal)\n+  {\n+    if (do_init) {\n+      initialize();\n+    }\n+  }\n+};\n+\n+static FdsInfo _vm_inited_fds(false);\n+\n+\/* taken from criu, that took this from kernel *\/\n+#define NFS_PREF \".nfs\"\n+#define NFS_PREF_LEN ((unsigned)sizeof(NFS_PREF) - 1)\n+#define NFS_FILEID_LEN ((unsigned)sizeof(uint64_t) << 1)\n+#define NFS_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n+#define NFS_LEN (NFS_PREF_LEN + NFS_FILEID_LEN + NFS_COUNTER_LEN)\n+static bool nfs_silly_rename(char* path) {\n+  char *sep = strrchr(path, '\/');\n+  char *base = sep ? sep + 1 : path;\n+  if (strncmp(base, NFS_PREF, NFS_PREF_LEN)) {\n+    return false;\n+  }\n+  for (unsigned i = NFS_PREF_LEN; i < NFS_LEN; ++i) {\n+    if (!isxdigit(base[i])) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+static int readfdlink(int fd, char *link, size_t len) {\n+  char fdpath[64];\n+  snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+  int ret = readlink(fdpath, link, len);\n+  if (ret == -1) {\n+    return ret;\n+  }\n+  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n+  return ret;\n+}\n+\n+static bool same_stat(struct stat* st1, struct stat* st2) {\n+  return st1->st_dev == st2->st_dev &&\n+         st1->st_ino == st2->st_ino;\n+}\n+\n+bool FdsInfo::same_fd(int i1, int i2) {\n+  assert(i1 < _fdinfos.length(), \"\");\n+  assert(i2 < _fdinfos.length(), \"\");\n+  fdinfo *fi1 = _fdinfos.adr_at(i1);\n+  fdinfo *fi2 = _fdinfos.adr_at(i2);\n+  if (!same_stat(&fi1->stat, &fi2->stat)) {\n+    return false;\n+  }\n+\n+  int flags1 = fcntl(fi1->fd, F_GETFL);\n+  int flags2 = fcntl(fi2->fd, F_GETFL);\n+  if (flags1 != flags2) {\n+    return false;\n+  }\n+\n+  const int test_flag = O_NONBLOCK;\n+  const int new_flags1 = flags1 ^ test_flag;\n+  fcntl(fi1->fd, F_SETFL, new_flags1);\n+  if (fcntl(fi1->fd, F_GETFL) != new_flags1) {\n+    \/\/ flag write ignored or handled differently,\n+    \/\/ don't know what to do\n+    return false;\n+  }\n+\n+  const int new_flags2 = fcntl(fi2->fd, F_GETFL);\n+  const bool are_same = new_flags1 == new_flags2;\n+\n+  fcntl(fi2->fd, flags1);\n+\n+  return are_same;\n+}\n+\n+void FdsInfo::initialize() {\n+  assert(!_inited, \"should be called only once\");\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  int dfd = dirfd(dir);\n+  while ((dp = readdir(dir))) {\n+    if (dp->d_name[0] == '.') {\n+      \/\/ skip \".\" and \"..\"\n+      continue;\n+    }\n+    fdinfo info;\n+    info.fd = atoi(dp->d_name);\n+    if (info.fd == dfd) {\n+      continue;\n+    }\n+    int r = fstat(info.fd, &info.stat);\n+    if (r == -1) {\n+      info.state = CLOSED;\n+      continue;\n+    }\n+    info.state = ROOT; \/\/ can be changed to DUP_OF_0 + N below\n+    info.mark = 0;\n+    _fdinfos.append(info);\n+  }\n+  closedir(dir);\n+  _inited = true;\n+\n+  for (int i = 0; i < _fdinfos.length(); ++i) {\n+    fdinfo *info = _fdinfos.adr_at(i);\n+    for (int j = 0; j < i; ++j) {\n+      if (get_state(j) == ROOT && same_fd(i, j)) {\n+        info->state = (state_t)(DUP_OF_0 + j);\n+        break;\n+      }\n+    }\n+\n+    if (info->state == ROOT) {\n+      char fdpath[PATH_MAX];\n+      int r = readfdlink(info->fd, fdpath, sizeof(fdpath));\n+      guarantee(-1 != r, \"can't stat fd\");\n+      if (info->stat.st_nlink == 0 ||\n+          strstr(fdpath, \"(deleted)\") ||\n+          nfs_silly_rename(fdpath)) {\n+        info->mark |= FdsInfo::M_CANT_RESTORE;\n+      }\n+    }\n+  }\n+}\n+\n+static const char* stat2strtype(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK: return \"socket\";\n+  case S_IFLNK:  return \"symlink\";\n+  case S_IFREG:  return \"regular\";\n+  case S_IFBLK:  return \"block\";\n+  case S_IFDIR:  return \"directory\";\n+  case S_IFCHR:  return \"character\";\n+  case S_IFIFO:  return \"fifo\";\n+  default:       break;\n+  }\n+  return \"unknown\";\n+}\n+\n+static int stat2stfail(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK:\n+    return JVM_CR_FAIL_SOCK;\n+  case S_IFLNK:\n+  case S_IFREG:\n+  case S_IFBLK:\n+  case S_IFDIR:\n+  case S_IFCHR:\n+    return JVM_CR_FAIL_FILE;\n+  case S_IFIFO:\n+    return JVM_CR_FAIL_PIPE;\n+  default:\n+    break;\n+  }\n+  return JVM_CR_FAIL;\n+}\n+\n+\/\/ If checkpoint is called throught the API, jcmd operation and jcmd output doesn't exist.\n+bool VM_Crac::is_socket_from_jcmd(int sock) {\n+#if INCLUDE_SERVICES\n+  if (_attach_op == NULL)\n+    return false;\n+  int sock_fd = _attach_op->socket();\n+  return sock == sock_fd;\n+#else\n+  return false;\n+#endif\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+#if INCLUDE_SERVICES\n+  if (_attach_op == NULL)\n+    return;\n+  bufferedStream* buf = static_cast<bufferedStream*>(_ostream);\n+  _attach_op->effectively_complete_raw(JNI_OK, buf);\n+  \/\/ redirect any further output to console\n+  _ostream = tty;\n+#endif\n+}\n+\n+bool VM_Crac::check_fds() {\n+\n+  AttachListener::abort();\n+\n+  FdsInfo fds;\n+\n+  bool ok = true;\n+\n+  for (int i = 0; i < fds.len(); ++i) {\n+    if (fds.get_state(i) == FdsInfo::CLOSED) {\n+      continue;\n+    }\n+    int fd = fds.get_fd(i);\n+\n+    char detailsbuf[PATH_MAX];\n+    struct stat* st = fds.get_stat(i);\n+    const char* type = stat2strtype(st->st_mode);\n+    int linkret = readfdlink(fd, detailsbuf, sizeof(detailsbuf));\n+    const char* details = 0 < linkret ? detailsbuf : \"\";\n+    {\n+      sockaddr_in sa;\n+      socklen_t slen = sizeof(sa);\n+      if (S_ISSOCK(st->st_mode) && 0 == getsockname(fd, (sockaddr*)&sa, &slen)) {\n+        const size_t len = strlen(detailsbuf);\n+        snprintf(detailsbuf + len, sizeof(detailsbuf) - len, \",port=%d\", (int)ntohs(sa.sin_port));\n+      }\n+    }\n+    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\" \", fd, type, details);\n+\n+    if (is_claimed_fd(fd)) {\n+      print_resources(\"OK: claimed by java code\\n\");\n+      continue;\n+    }\n+\n+    if (_vm_inited_fds.find_state(fd, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n+      print_resources(\"OK: inherited from process env\\n\");\n+      continue;\n+    }\n+\n+    if (S_ISSOCK(st->st_mode)) {\n+      if (is_socket_from_jcmd(fd)){\n+        print_resources(\"OK: jcmd socket\\n\");\n+        continue;\n+      }\n+    }\n+\n+    if (CRAllowedOpenFilePrefixes != nullptr) {\n+      const char *prefix = CRAllowedOpenFilePrefixes;\n+      \/\/ JDK appends to ccstrlist using newline, on command line that would be comma\n+      size_t prefix_length = strcspn(prefix, \",\\n\");\n+      bool matched = false;\n+      while (prefix_length > 0) {\n+        if (!strncmp(details, prefix, prefix_length)) {\n+          matched = true;\n+          break;\n+        }\n+        if (prefix[prefix_length] == '\\0') {\n+          break;\n+        }\n+        prefix += prefix_length + 1;\n+        prefix_length = strcspn(prefix, \",\\n\");\n+      }\n+      if (matched) {\n+        print_resources(\"OK: allowed in -XX:CRAllowedOpenFilePrefixes\\n\");\n+        continue;\n+      }\n+    }\n+\n+    print_resources(\"BAD: opened by application\\n\");\n+    ok = false;\n+\n+    const int maxinfo = 64;\n+    size_t buflen = strlen(details) + maxinfo;\n+    char* msg = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n+    int len = snprintf(msg, buflen, \"FD fd=%d type=%s path=%s\", fd, type, detailsbuf);\n+    msg[len < 0 ? 0 : ((size_t) len >= buflen ? buflen - 1 : len)] = '\\0';\n+    _failures->append(CracFailDep(stat2stfail(st->st_mode & S_IFMT), msg));\n+  }\n+\n+  return ok;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return PerfMemoryLinux::checkpoint();\n+}\n+\n+void VM_Crac::memory_restore() {\n+  PerfMemoryLinux::restore();\n+}\n+\n+static char modules_path[JVM_MAXPATHLEN] = { '\\0' };\n+\n+static bool is_fd_ignored(int fd, const char *path) {\n+  const char *list = CRaCIgnoredFileDescriptors;\n+  while (list && *list) {\n+    const char *end = strchr(list, ',');\n+    if (!end) {\n+      end = list + strlen(list);\n+    }\n+    char *invalid;\n+    int ignored_fd = strtol(list, &invalid, 10);\n+    if (invalid == end) { \/\/ entry was integer -> file descriptor\n+      if (fd == ignored_fd) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    } else { \/\/ interpret entry as path\n+      int path_len = path ? strlen(path) : -1;\n+      if (path_len != -1 && path_len == end - list && !strncmp(path, list, end - list)) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    }\n+    if (*end) {\n+      list = end + 1;\n+    } else {\n+      break;\n+    }\n+  }\n+\n+  if (os::same_files(modules_path, path)) {\n+    \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+    \/\/ We can ignore this for purposes of CRaC.\n+    return true;\n+  }\n+\n+  if (LogConfiguration::is_fd_used(fd)) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+static void close_extra_descriptors() {\n+  \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+  \/\/ We can ignore this for purposes of CRaC.\n+  if (modules_path[0] == '\\0') {\n+    const char* fileSep = os::file_separator();\n+    jio_snprintf(modules_path, JVM_MAXPATHLEN, \"%s%slib%s\" MODULES_IMAGE_NAME, Arguments::get_java_home(), fileSep, fileSep);\n+  }\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  while ((dp = readdir(dir))) {\n+    int fd = atoi(dp->d_name);\n+    if (fd > 2 && fd != dirfd(dir)) {\n+      int r = readfdlink(fd, path, sizeof(path));\n+      if (!is_fd_ignored(fd, r != -1 ? path : nullptr)) {\n+        log_warning(os)(\"CRaC closing file descriptor %d: %s\", fd, path);\n+        close(fd);\n+      }\n+    }\n+  }\n+  closedir(dir);\n+}\n+\n+void crac::vm_create_start() {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  close_extra_descriptors();\n+  _vm_inited_fds.initialize();\n+}\n+\n+static bool read_all(int fd, char *dest, size_t n) {\n+  size_t rd = 0;\n+  do {\n+    ssize_t r = ::read(fd, dest + rd, n - rd);\n+    if (r == 0) {\n+      return false;\n+    } else if (r < 0) {\n+      if (errno == EINTR) {\n+        continue;\n+      }\n+      return false;\n+    }\n+    rd += r;\n+  } while (rd < n);\n+  return true;\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  int fd = ::open(\"\/proc\/sys\/kernel\/random\/boot_id\", O_RDONLY);\n+  if (fd < 0 || !read_all(fd, dest, UUID_LENGTH)) {\n+    perror(\"CRaC: Cannot read system boot ID\");\n+    return false;\n+  }\n+  char c;\n+  if (!read_all(fd, &c, 1) || c != '\\n') {\n+    perror(\"CRaC: system boot ID does not end with newline\");\n+    return false;\n+  }\n+  if (::read(fd, &c, 1) != 0) {\n+    perror(\"CRaC: Unexpected data\/error reading system boot ID\");\n+    return false;\n+  }\n+  if (::close(fd) != 0) {\n+    perror(\"CRaC: Cannot close system boot ID file\");\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/linux\/crac_linux.cpp","additions":498,"deletions":0,"binary":false,"changes":498,"status":"added"},{"patch":"@@ -72,0 +72,3 @@\n+  product(bool, CRaCCPUCountInit, false, \"Reinitialize number of CPUs \" \\\n+      \"during -XX:CRaCRestoreFrom\")                                     \\\n+                                                                        \\\n@@ -109,0 +112,5 @@\n+\/\/ On some systems using SSSD files in this directory are left open\n+\/\/ after calling getpwuid_r, getpwname_r, getgrgid_r, getgrname_r\n+\/\/ or other functions in this family.\n+define_pd_global(ccstrlist, CRAllowedOpenFilePrefixes, \"\/var\/lib\/sss\/mc\/\");\n+\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2017, 2022, Azul Systems, Inc. All rights reserved.\n@@ -27,0 +28,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -69,0 +71,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -88,0 +91,1 @@\n+# include <arpa\/inet.h>\n@@ -92,1 +96,0 @@\n-# include <sys\/stat.h>\n@@ -95,0 +98,1 @@\n+# include <sys\/sysmacros.h>\n@@ -112,1 +116,0 @@\n-# include <fcntl.h>\n@@ -121,0 +124,1 @@\n+# include <libgen.h>\n@@ -499,1 +503,1 @@\n-void os::Linux::initialize_system_info() {\n+void os::Linux::initialize_processor_count() {\n@@ -501,0 +505,5 @@\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n+void os::Linux::initialize_system_info() {\n+  initialize_processor_count();\n@@ -513,1 +522,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -63,0 +64,1 @@\n+  static void initialize_processor_count();\n@@ -279,0 +281,7 @@\n+  static void initialize_cpu_count() {\n+    initialize_processor_count();\n+    if (cpu_to_node() != NULL) {\n+      rebuild_cpu_to_node_map();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PERFMEMORY_LINUX_HPP\n+#define OS_LINUX_PERFMEMORY_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class PerfMemoryLinux : AllStatic {\n+\n+public:\n+  static bool checkpoint();\n+  static bool restore();\n+};\n+\n+#endif \/\/ OS_LINUX_PERFMEMORY_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/perfMemory_linux.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"attachListener_posix.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"posixAttachOperation.hpp\"\n@@ -65,67 +68,0 @@\n-\/\/ forward reference\n-class PosixAttachOperation;\n-\n-class PosixAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n-  \/\/ reads a request from the given connected socket\n-  static PosixAttachOperation* read_request(int s);\n-\n- public:\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n-  static void set_path(char* path) {\n-    if (path == nullptr) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, size_t len);\n-\n-  static PosixAttachOperation* dequeue();\n-};\n-\n-class PosixAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  int _socket;\n-\n- public:\n-  void complete(jint res, bufferedStream* st);\n-\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n-\n-  PosixAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n-  }\n-};\n-\n@@ -137,0 +73,1 @@\n+PosixAttachOperation* PosixAttachListener::_current_op = NULL;\n@@ -408,0 +345,1 @@\n+      _current_op = op;\n@@ -428,0 +366,12 @@\n+\/\/ An operation completion is splitted into two parts.\n+\/\/ For proper handling the jcmd connection at CRaC checkpoint action.\n+\/\/ An effectively_complete_raw is called in checkpoint processing, before criu engine calls, for properly closing the socket.\n+\/\/ The complete() gets called after restore for proper deletion the leftover object.\n+\n+void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n+  PosixAttachOperation::effectively_complete_raw(result, st);\n+  \/\/ reset the current op as late as possible, this happens on attach listener thread.\n+  PosixAttachListener::reset_current_op();\n+  delete this;\n+}\n+\n@@ -436,3 +386,5 @@\n-void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n+void PosixAttachOperation::effectively_complete_raw(jint result, bufferedStream* st) {\n+  if (_effectively_completed) {\n+    assert(st->size() == 0, \"no lost output\");\n+    return;\n+  }\n@@ -441,0 +393,11 @@\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    ThreadBlockInVM((JavaThread* )thread);\n+    write_operation_result(result, st);\n+  } else {\n+    write_operation_result(result, st);\n+  }\n+  _effectively_completed = true;\n+}\n+\n+void PosixAttachOperation::write_operation_result(jint result, bufferedStream* st) {\n@@ -448,1 +411,1 @@\n-    ::shutdown(this->socket(), 2);\n+    ::shutdown(this->socket(), SHUT_RDWR);\n@@ -453,0 +416,2 @@\n+  st->reset();\n+}\n@@ -454,1 +419,5 @@\n-  delete this;\n+static void assert_listener_thread() {\n+#ifdef ASSERT\n+  ResourceMark rm; \/\/ For retrieving the thread names\n+  assert(strcmp(\"Attach Listener\", Thread::current()->name()) == 0, \"should gets called from Attach Listener thread\");\n+#endif\n@@ -457,0 +426,9 @@\n+PosixAttachOperation* PosixAttachListener::get_current_op() {\n+  assert_listener_thread();\n+  return PosixAttachListener::_current_op;\n+}\n+\n+void PosixAttachListener::reset_current_op() {\n+  assert_listener_thread();\n+  PosixAttachListener::_current_op = NULL;\n+}\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":50,"deletions":72,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_ATTACHLISTENER_POSIX_HPP\n+#define OS_POSIX_ATTACHLISTENER_POSIX_HPP\n+\n+#include \"posixAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+\n+#if INCLUDE_SERVICES\n+\n+#include <sys\/un.h>\n+\n+#ifndef UNIX_PATH_MAX\n+#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n+#endif\n+\n+class PosixAttachListener: AllStatic {\n+ private:\n+  \/\/ the path to which we bind the UNIX domain socket\n+  static char _path[UNIX_PATH_MAX];\n+  static bool _has_path;\n+\n+  \/\/ the file descriptor for the listening socket\n+  static volatile int _listener;\n+\n+  static bool _atexit_registered;\n+\n+  \/\/ this is for proper reporting JDK.Chekpoint processing to jcmd peer\n+  static PosixAttachOperation* _current_op;\n+\n+  \/\/ reads a request from the given connected socket\n+  static PosixAttachOperation* read_request(int s);\n+\n+ public:\n+  enum {\n+    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n+  };\n+  enum {\n+    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n+  };\n+\n+  static void set_path(char* path) {\n+    if (path == nullptr) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n+  \/\/ initialize the listener, returns 0 if okay\n+  static int init();\n+\n+  static char* path()                   { return _path; }\n+  static bool has_path()                { return _has_path; }\n+  static int listener()                 { return _listener; }\n+\n+  \/\/ write the given buffer to a socket\n+  static int write_fully(int s, char* buf, size_t len);\n+\n+  static PosixAttachOperation* dequeue();\n+  static PosixAttachOperation* get_current_op();\n+  static void reset_current_op();\n+\n+};\n+\n+#endif \/\/ INCLUDE_SERVICES\n+\n+#endif \/\/ OS_POSIX_ATTACHLISTENER_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.hpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"jvm.h\"\n+#include \"os_posix.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+\n+#include <sys\/mman.h>\n+\n+int CracSHM::open(int mode) {\n+  int shmfd = shm_open(_path, mode, 0600);\n+  if (-1 == shmfd) {\n+    perror(\"shm_open\");\n+  }\n+  return shmfd;\n+}\n+\n+void CracSHM::unlink() {\n+  shm_unlink(_path);\n+}\n+\n+void crac::initialize_time_counters() {\n+  os::Posix::initialize_time_counters();\n+}\n+\n+#ifndef LINUX\n+void crac::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  return true;\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/os\/posix\/crac_posix.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -94,0 +94,5 @@\n+#if defined(LINUX)\n+\/\/ The signal is blocked by default; this should not break SunMiscSignalTest\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -781,0 +782,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -803,0 +808,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1273,0 +1286,4 @@\n+  initialize_time_counters();\n+}\n+\n+void os::Posix::initialize_time_counters(void) {\n@@ -1427,1 +1444,1 @@\n-  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec);\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + crac::monotonic_time_offset();\n@@ -1980,0 +1997,30 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  char** env = os::get_environ();\n+\n+  pid_t pid = fork();\n+  if (pid == -1) {\n+    perror(\"cannot fork for crengine\");\n+    return -1;\n+  }\n+  if (pid == 0) {\n+    execve(path, (char* const*)argv, env);\n+    perror(\"execve\");\n+    exit(1);\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return -1;\n+  }\n+  return WEXITSTATUS(status) == 0 ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return ::execv(path, (char * const *)argv);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  static void initialize_time_counters(void);\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -34,0 +35,1 @@\n+\/\/#include \"os_linux.inline.hpp\"\n@@ -44,0 +46,4 @@\n+#ifdef LINUX\n+#include \"perfMemory_linux.hpp\"\n+#endif \/\/LINUX\n+\n@@ -1342,0 +1348,77 @@\n+\n+#ifdef LINUX\n+bool PerfMemoryLinux::checkpoint() {\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  void *anon = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (anon == MAP_FAILED) {\n+    tty->print_cr(\"Cannot allocate new memory for perfdata: %s\", os::strerror(errno));\n+    return false;\n+  }\n+  \/\/ Note: we might be losing updates that happen between this copy and mremap\n+  \/\/ TODO: consider acquiring PeriodicTask_lock around this\n+  memcpy(anon, PerfMemory::start(), PerfMemory::used());\n+  if (mremap(anon, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap perfdata memory as anonymous: %s\", os::strerror(errno));\n+    if (munmap(anon, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap unused private perfdata memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  remove_file(backing_store_file_name);\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::restore() {\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  int vmid = os::current_process_id();\n+  char* user_name = get_user_name(geteuid());\n+  if (!user_name) {\n+    return false;\n+  }\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  if (!make_user_tmp_dir(dirname)) {\n+    return false;\n+  }\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"Cannot open shared perfdata file: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  if (::ftruncate(fd, PerfMemory::capacity())) {\n+    tty->print_cr(\"Cannot restore (ftruncate) perfdata file size: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  void* shared = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == shared) {\n+    tty->print_cr(\"cannot mmap shared perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+  ::close(fd);\n+\n+  \/\/ Here is another place where we might lose the update\n+  memcpy(shared, PerfMemory::start(), PerfMemory::used());\n+  if (::mremap(shared, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap shared perfdata: %s\", os::strerror(errno));\n+    if (munmap(shared, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap the shared memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  return true;\n+}\n+#endif \/\/LINUX\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_POSIXATTACHOPERATION_HPP\n+#define OS_POSIX_POSIXATTACHOPERATION_HPP\n+\n+#include \"services\/attachListener.hpp\"\n+\n+#if INCLUDE_SERVICES\n+\n+class PosixAttachOperation: public AttachOperation {\n+ private:\n+  \/\/ the connection to the client\n+  int _socket;\n+  bool _effectively_completed;\n+  void write_operation_result(jint result, bufferedStream* st);\n+\n+ public:\n+  void complete(jint res, bufferedStream* st);\n+  void effectively_complete_raw(jint res, bufferedStream* st);\n+  bool is_effectively_completed()                      { return _effectively_completed; }\n+\n+  void set_socket(int s)                                { _socket = s; }\n+  int socket() const                                    { return _socket; }\n+\n+  PosixAttachOperation(char* name) : AttachOperation(name) {\n+    set_socket(-1);\n+    _effectively_completed = false;\n+  }\n+};\n+\n+#endif \/\/ INCLUDE_SERVICES\n+\n+#endif \/\/ OS_POSIX_POSIXATTACHOPERATION_HPP\n","filename":"src\/hotspot\/os\/posix\/posixAttachOperation.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -145,1 +145,1 @@\n-static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n@@ -1541,0 +1541,7 @@\n+\n+  sigemptyset(&blocked_sigs);\n+\/\/ RESTORE_SIGNAL is used only on Linux, other platform don't send this\n+#ifdef LINUX\n+  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+#endif\n+\n@@ -1551,0 +1558,5 @@\n+static sigset_t* blocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &blocked_sigs;\n+}\n+\n@@ -1568,0 +1580,1 @@\n+  pthread_sigmask(SIG_BLOCK, blocked_signals(), nullptr);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"jvm.h\"\n+#include \"runtime\/crac_structs.hpp\"\n+\n+void crac::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+\n+int CracSHM::open(int mode) {\n+  return -1;\n+}\n+\n+void CracSHM::unlink() {\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  return true;\n+}\n+\n+void crac::initialize_time_counters() {\n+  os::win32::initialize_performance_counter();\n+}\n","filename":"src\/hotspot\/os\/windows\/crac_windows.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -54,0 +54,1 @@\n+define_pd_global(ccstrlist, CRAllowedOpenFilePrefixes, nullptr);\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1521,0 +1522,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -4838,0 +4866,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5805,0 +5858,9 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  const int status = _spawnv(_P_WAIT, path, argv); \/\/ env is inherited by a child process\n+  return 0 == status ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return _execv(path, argv);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  static void   initialize_performance_counter();\n@@ -112,1 +113,0 @@\n-  static void initialize_performance_counter();\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,0 +397,9 @@\n+  \/\/ VM_Version::crac_restore()->VM_Version::get_processor_features_hardware()\n+  \/\/ executes cpuinfo without a started Java thread.\n+  if (info != nullptr && uc != nullptr && thread == nullptr && sig == SIGSEGV) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n+      stub = VM_Version::cpuinfo_cont_addr();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -223,0 +223,9 @@\n+  \/\/ VM_Version::crac_restore()->VM_Version::get_processor_features_hardware()\n+  \/\/ executes cpuinfo without a started Java thread.\n+  if (info != nullptr && uc != nullptr && thread == nullptr && sig == SIGSEGV) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n+      stub = VM_Version::cpuinfo_cont_addr();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -486,4 +486,1 @@\n-            if (value != min_jint) {\n-              if (ao->op() == Bytecodes::_isub) {\n-                value = -value;\n-              }\n+            if (ao->op() == Bytecodes::_iadd) {\n@@ -491,2 +488,3 @@\n-              last_integer = base;\n-              last_instruction = other;\n+            } else {\n+              assert(ao->op() == Bytecodes::_isub, \"unexpected bytecode\");\n+              base = java_subtract(base, value);\n@@ -494,0 +492,2 @@\n+            last_integer = base;\n+            last_instruction = other;\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -244,3 +244,8 @@\n-\/\/ unloading can remove entries concurrently soon.\n-template <bool keep_alive = true>\n-class ClassLoaderDataGraphIteratorBase : public StackObj {\n+\/\/ unloading can remove entries concurrently.\n+\/\/ This iterator does not keep the CLD alive.\n+\/\/ Any CLD OopHandles (modules, mirrors, resolved refs)\n+\/\/ resolved must be treated as no keepalive. And requires\n+\/\/ that its CLD's holder is kept alive if they escape the\n+\/\/ caller's safepoint or ClassLoaderDataGraph_lock\n+\/\/ critical section.\n+class ClassLoaderDataGraph::ClassLoaderDataGraphIterator : public StackObj {\n@@ -254,6 +259,2 @@\n-  ClassLoaderDataGraphIteratorBase() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n-    if (keep_alive) {\n-      assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-    } else {\n-      assert_at_safepoint();\n-    }\n+  ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n+    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n@@ -269,4 +270,0 @@\n-      if (keep_alive) {\n-        \/\/ Keep cld that is being returned alive.\n-        Handle(_thread, cld->holder());\n-      }\n@@ -281,3 +278,0 @@\n-using ClassLoaderDataGraphIterator = ClassLoaderDataGraphIteratorBase<true \/* keep_alive *\/>;\n-using ClassLoaderDataGraphIteratorNoKeepAlive = ClassLoaderDataGraphIteratorBase<false \/* keep_alive *\/>;\n-\n@@ -291,7 +285,0 @@\n-void ClassLoaderDataGraph::loaded_cld_do_no_keepalive(CLDClosure* cl) {\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n-  while (ClassLoaderData* cld = iter.get_next()) {\n-    cl->do_cld(cld);\n-  }\n-}\n-\n@@ -321,0 +308,10 @@\n+void ClassLoaderDataGraph::modules_do_keepalive(void f(ModuleEntry*)) {\n+  assert_locked_or_safepoint(Module_lock);\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData* cld = iter.get_next()) {\n+    \/\/ Keep the holder alive.\n+    (void)cld->holder();\n+    cld->modules_do(f);\n+  }\n+}\n+\n@@ -337,1 +334,1 @@\n-void ClassLoaderDataGraph::loaded_classes_do(KlassClosure* klass_closure) {\n+void ClassLoaderDataGraph::loaded_classes_do_keepalive(KlassClosure* klass_closure) {\n@@ -340,0 +337,2 @@\n+    \/\/ Keep the holder alive.\n+    (void)cld->holder();\n@@ -349,1 +348,1 @@\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  ClassLoaderDataGraphIterator iter;\n@@ -357,4 +356,0 @@\n-#define FOR_ALL_DICTIONARY(X)   ClassLoaderDataGraphIterator iter; \\\n-                                while (ClassLoaderData* X = iter.get_next()) \\\n-                                  if (X->dictionary() != nullptr)\n-\n@@ -362,6 +357,9 @@\n-  FOR_ALL_DICTIONARY(cld) {\n-    st->print(\"Dictionary for \");\n-    cld->print_value_on(st);\n-    st->cr();\n-    cld->dictionary()->print_on(st);\n-    st->cr();\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData *cld = iter.get_next()) {\n+    if (cld->dictionary() != nullptr) {\n+      st->print(\"Dictionary for \");\n+      cld->print_value_on(st);\n+      st->cr();\n+      cld->dictionary()->print_on(st);\n+      st->cr();\n+    }\n@@ -372,5 +370,8 @@\n-  FOR_ALL_DICTIONARY(cld) {\n-    ResourceMark rm; \/\/ loader_name_and_id\n-    stringStream tempst;\n-    tempst.print(\"System Dictionary for %s class loader\", cld->loader_name_and_id());\n-    cld->dictionary()->print_table_statistics(st, tempst.freeze());\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData *cld = iter.get_next()) {\n+    if (cld->dictionary() != nullptr) {\n+      ResourceMark rm; \/\/ loader_name_and_id\n+      stringStream tempst;\n+      tempst.print(\"System Dictionary for %s class loader\", cld->loader_name_and_id());\n+      cld->dictionary()->print_table_statistics(st, tempst.freeze());\n+    }\n@@ -553,1 +554,1 @@\n-  ClassLoaderDataGraphIteratorNoKeepAlive iter;\n+  ClassLoaderDataGraphIterator iter;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":42,"deletions":41,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-  template <bool keep_alive>\n-  friend class ClassLoaderDataGraphIteratorBase;\n@@ -44,0 +42,2 @@\n+  class ClassLoaderDataGraphIterator;\n+\n@@ -74,0 +74,5 @@\n+  \/\/ All the do suffixed functions do not keep the CLD alive. Any CLD OopHandles\n+  \/\/ (modules, mirrors, resolved refs) resolved must be treated as no keepalive.\n+  \/\/ And requires that its CLD's holder is kept alive if they escape the\n+  \/\/ caller's safepoint or ClassLoaderDataGraph_lock critical section.\n+  \/\/ The do_keepalive suffixed functions will keep all CLDs alive.\n@@ -75,1 +80,0 @@\n-  static void loaded_cld_do_no_keepalive(CLDClosure* cl);\n@@ -84,0 +88,1 @@\n+  static void modules_do_keepalive(void f(ModuleEntry*));\n@@ -86,1 +91,1 @@\n-  static void loaded_classes_do(KlassClosure* klass_closure);\n+  static void loaded_classes_do_keepalive(KlassClosure* klass_closure);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  ClassLoaderDataGraph::loaded_cld_do_no_keepalive(&clsc);\n+  ClassLoaderDataGraph::loaded_cld_do(&clsc);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -791,0 +791,1 @@\n+int java_lang_Class::_init_lock_offset;\n@@ -914,0 +915,6 @@\n+  \/\/ Allocate a simple java object for a lock.\n+  \/\/ This needs to be a java object because during class initialization\n+  \/\/ it can be held across a java call.\n+  typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);\n+  set_init_lock(mirror(), r);\n+\n@@ -1135,0 +1142,4 @@\n+    \/\/ create the init_lock\n+    typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));\n+    set_init_lock(mirror(), r);\n+\n@@ -1199,0 +1210,9 @@\n+oop java_lang_Class::init_lock(oop java_class) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  return java_class->obj_field(_init_lock_offset);\n+}\n+void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_init_lock_offset, init_lock);\n+}\n+\n@@ -1418,0 +1438,5 @@\n+  \/\/ Init lock is a C union with component_mirror.  Only instanceKlass mirrors have\n+  \/\/ init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops\n+  \/\/ GC treats them the same.\n+  _init_lock_offset = _component_mirror_offset;\n+\n@@ -1424,0 +1449,1 @@\n+  f->do_u4((u4*)&_init_lock_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,0 +229,1 @@\n+  static int _init_lock_offset;\n@@ -243,0 +244,1 @@\n+  static void set_init_lock(oop java_class, oop init_lock);\n@@ -295,0 +297,4 @@\n+  static oop  init_lock(oop java_class);\n+  static void clear_init_lock(oop java_class) {\n+    set_init_lock(java_class, nullptr);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -347,0 +347,15 @@\n+\/\/ Symbols should represent entities from the constant pool that are\n+\/\/ limited to <64K in length, but usage errors creep in allowing Symbols\n+\/\/ to be used for arbitrary strings. For debug builds we will assert if\n+\/\/ a string is too long, whereas product builds will truncate it.\n+static int check_length(const char* name, int len) {\n+  assert(len <= Symbol::max_length(),\n+         \"String length %d exceeds the maximum Symbol length of %d\", len, Symbol::max_length());\n+  if (len > Symbol::max_length()) {\n+    warning(\"A string \\\"%.80s ... %.80s\\\" exceeds the maximum Symbol \"\n+            \"length of %d and has been truncated\", name, (name + len - 80), Symbol::max_length());\n+    len = Symbol::max_length();\n+  }\n+  return len;\n+}\n+\n@@ -348,1 +363,1 @@\n-  assert(len <= Symbol::max_length(), \"sanity\");\n+  len = check_length(name, len);\n@@ -488,0 +503,1 @@\n+    assert(len <= Symbol::max_length(), \"must be - these come from the constant pool\");\n@@ -497,0 +513,1 @@\n+  assert(len <= Symbol::max_length(), \"caller should have ensured this\");\n@@ -545,1 +562,1 @@\n-  int len = (int)strlen(name);\n+  int len = check_length(name, (int)strlen(name));\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-\n+  \/\/ Will not keep metadata alive. See ClassLoaderDataGraph::methods_do.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -532,2 +532,2 @@\n-  do_name(intPolyMult_name, \"mult\")                                                                                     \\\n-  do_signature(intPolyMult_signature, \"([J[J[J)I\")                                                                      \\\n+  do_name(intPolyMult_name, \"multImpl\")                                                                                     \\\n+  do_signature(intPolyMult_signature, \"([J[J[J)V\")                                                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -560,0 +560,1 @@\n+  template(int_array_signature,                       \"[I\")                                       \\\n@@ -742,0 +743,4 @@\n+  template(jdk_crac_Core,                          \"jdk\/crac\/Core\")                                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+  template(checkpointRestoreInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -764,1 +764,1 @@\n-        if (match->EnableOption) {\n+        if (match->EnableOption || dir->is_default_directive()) {\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"gc\/g1\/g1UncommitRegionTask.hpp\"\n@@ -1021,0 +1022,4 @@\n+  virtual void finish_collection() override {\n+    G1UncommitRegionTask::finish_collection();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -248,0 +248,7 @@\n+  \/\/ Handle do_cleanup_unused here to print correct capacity below.\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    \/\/ HeapRegionManager::shrink_by do not allow remove all regions.\n+    \/\/ Make sure at least one is there.\n+    maximum_desired_capacity = G1HeapRegion::GrainBytes;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -136,0 +136,8 @@\n+\n+void G1UncommitRegionTask::finish_collection() {\n+  \/\/ If _instance is NULL G1 GC is either not in use or its collection has not yet been executed.\n+  if (_instance) {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    g1h->uncommit_regions((uint)-1);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  static void finish_collection();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -1193,0 +1194,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1349,0 +1357,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -421,0 +422,6 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), (char*)eden()->end() - (char*)eden()->top());\n+    os::cleanup_memory((char*)from()->top(), (char*)from()->end() - (char*)from()->top());\n+    os::cleanup_memory((char*)to()->top(), (char*)to()->end() - (char*)to()->top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -175,5 +175,0 @@\n-  if (!bs_nm->is_armed(nm)) {\n-    return 0;\n-  }\n-\n-  assert(!nm->is_osr_method(), \"Should not reach here\");\n@@ -182,0 +177,1 @@\n+  assert(!nm->is_osr_method() || may_enter, \"OSR nmethods should always be entrant after migration\");\n@@ -191,1 +187,1 @@\n-  \/\/ Diagnostic option to force deoptimization 1 in 3 times. It is otherwise\n+  \/\/ Diagnostic option to force deoptimization 1 in 10 times. It is otherwise\n@@ -193,1 +189,1 @@\n-  if (DeoptimizeNMethodBarriersALot) {\n+  if (DeoptimizeNMethodBarriersALot && !nm->is_osr_method()) {\n@@ -195,1 +191,1 @@\n-    if (Atomic::add(&counter, 1u) % 3 == 0) {\n+    if (Atomic::add(&counter, 1u) % 10 == 0) {\n@@ -208,9 +204,0 @@\n-  \/\/ This check depends on the invariant that all nmethods that are deoptimized \/ made not entrant\n-  \/\/ are NOT disarmed.\n-  \/\/ This invariant is important because a method can be deoptimized after the method have been\n-  \/\/ resolved \/ looked up by OSR by another thread. By not deoptimizing them we guarantee that\n-  \/\/ a deoptimized method will always hit the barrier and come to the same conclusion - deoptimize\n-  if (!is_armed(nm)) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -247,0 +247,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -120,0 +120,2 @@\n+  bool _cleanup_unused;\n+\n@@ -378,0 +380,6 @@\n+  void set_cleanup_unused(bool value) { _cleanup_unused = value; }\n+  bool do_cleanup_unused() const { return _cleanup_unused; }\n+\n+  \/\/ G1UncommitRegionTask may be still pending after collect() has returned.\n+  virtual void finish_collection() {}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  OopMapCache::trigger_cleanup();\n+  OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  OopMapCache::trigger_cleanup();\n+  OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-    OopMapCache::trigger_cleanup();\n+    OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/x\/xDriver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -527,0 +527,4 @@\n+  if (!stats._old_stats._cycle._is_time_trustable) {\n+    return 1.0;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-    OopMapCache::trigger_cleanup();\n+    OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  JMM_JVM_RESTORE_START_TIME_MS      = 12,   \/* Time when the JVM started restore operation *\/\n+  JMM_JVM_UPTIME_SINCE_RESTORE_MS    = 13,   \/* The JVM uptime since restore *\/\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1196,0 +1196,15 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1813,1 +1813,1 @@\n-  \/\/ a lock to do the final serialization of updates\n+  \/\/ an ObjectLocker to do the final serialization of updates\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,3 +69,0 @@\n-#ifdef ASSERT\n-    _resource_allocate_bit_mask = false;\n-#endif\n@@ -180,3 +177,7 @@\n-#ifdef ASSERT\n-  _resource_allocate_bit_mask = true;\n-#endif\n+}\n+\n+InterpreterOopMap::~InterpreterOopMap() {\n+  if (has_valid_mask() && mask_size() > small_mask_limit) {\n+    assert(_bit_mask[0] != 0, \"should have pointer to C heap\");\n+    FREE_C_HEAP_ARRAY(uintptr_t, _bit_mask[0]);\n+  }\n@@ -402,5 +403,5 @@\n-void InterpreterOopMap::resource_copy(OopMapCacheEntry* from) {\n-  assert(_resource_allocate_bit_mask,\n-    \"Should not resource allocate the _bit_mask\");\n-  assert(from->has_valid_mask(),\n-    \"Cannot copy entry with an invalid mask\");\n+void InterpreterOopMap::copy_from(const OopMapCacheEntry* src) {\n+  \/\/ The expectation is that this InterpreterOopMap is recently created\n+  \/\/ and empty. It is used to get a copy of a cached entry.\n+  assert(!has_valid_mask(), \"InterpreterOopMap object can only be filled once\");\n+  assert(src->has_valid_mask(), \"Cannot copy entry with an invalid mask\");\n@@ -408,5 +409,5 @@\n-  set_method(from->method());\n-  set_bci(from->bci());\n-  set_mask_size(from->mask_size());\n-  set_expression_stack_size(from->expression_stack_size());\n-  _num_oops = from->num_oops();\n+  set_method(src->method());\n+  set_bci(src->bci());\n+  set_mask_size(src->mask_size());\n+  set_expression_stack_size(src->expression_stack_size());\n+  _num_oops = src->num_oops();\n@@ -415,3 +416,2 @@\n-  if (from->mask_size() <= small_mask_limit) {\n-    memcpy((void *)_bit_mask, (void *)from->_bit_mask,\n-      mask_word_size() * BytesPerWord);\n+  if (src->mask_size() <= small_mask_limit) {\n+    memcpy(_bit_mask, src->_bit_mask, mask_word_size() * BytesPerWord);\n@@ -419,14 +419,2 @@\n-    \/\/ The expectation is that this InterpreterOopMap is a recently created\n-    \/\/ and empty. It is used to get a copy of a cached entry.\n-    \/\/ If the bit mask has a value, it should be in the\n-    \/\/ resource area.\n-    assert(_bit_mask[0] == 0 ||\n-      Thread::current()->resource_area()->contains((void*)_bit_mask[0]),\n-      \"The bit mask should have been allocated from a resource area\");\n-    \/\/ Allocate the bit_mask from a Resource area for performance.  Allocating\n-    \/\/ from the C heap as is done for OopMapCache has a significant\n-    \/\/ performance impact.\n-    _bit_mask[0] = (uintptr_t) NEW_RESOURCE_ARRAY(uintptr_t, mask_word_size());\n-    assert(_bit_mask[0] != 0, \"bit mask was not allocated\");\n-    memcpy((void*) _bit_mask[0], (void*) from->_bit_mask[0],\n-      mask_word_size() * BytesPerWord);\n+    _bit_mask[0] = (uintptr_t) NEW_C_HEAP_ARRAY(uintptr_t, mask_word_size(), mtClass);\n+    memcpy((void*) _bit_mask[0], (void*) src->_bit_mask[0], mask_word_size() * BytesPerWord);\n@@ -519,1 +507,1 @@\n-        entry_for->resource_copy(entry);\n+        entry_for->copy_from(entry);\n@@ -533,1 +521,1 @@\n-  entry_for->resource_copy(tmp);\n+  entry_for->copy_from(tmp);\n@@ -595,3 +583,5 @@\n-void OopMapCache::trigger_cleanup() {\n-  if (has_cleanup_work()) {\n-    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+void OopMapCache::try_trigger_cleanup() {\n+  \/\/ See we can take the lock for the notification without blocking.\n+  \/\/ This allows triggering the cleanup from GC paths, that can hold\n+  \/\/ the service lock for e.g. oop iteration in service thread.\n+  if (has_cleanup_work() && Service_lock->try_lock_without_rank_check()) {\n@@ -599,0 +589,1 @@\n+    Service_lock->unlock();\n@@ -631,1 +622,1 @@\n-    entry->resource_copy(tmp);\n+    entry->copy_from(tmp);\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":30,"deletions":39,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-\/\/ bit_mask can fit into two words it is stored in\n+\/\/ bit_mask can fit into four words it is stored in\n@@ -43,3 +43,4 @@\n-\/\/ For InterpreterOopMap the bit_mask is allocated in\n-\/\/ a resource area for better performance.  InterpreterOopMap\n-\/\/ should only be created and deleted during same garbage collection.\n+\/\/ For InterpreterOopMap the bit_mask is allocated in the C heap\n+\/\/ to avoid issues with allocations from the resource area that have\n+\/\/ to live accross the oop closure. InterpreterOopMap should only be\n+\/\/ created and deleted during the same garbage collection.\n@@ -98,3 +99,0 @@\n-#ifdef ASSERT\n-  bool _resource_allocate_bit_mask;\n-#endif\n@@ -131,0 +129,1 @@\n+  ~InterpreterOopMap();\n@@ -132,5 +131,5 @@\n-  \/\/ Copy the OopMapCacheEntry in parameter \"from\" into this\n-  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"from\" points to\n-  \/\/ allocated space (i.e., the bit mask was to large to hold\n-  \/\/ in-line), allocate the space from a Resource area.\n-  void resource_copy(OopMapCacheEntry* from);\n+  \/\/ Copy the OopMapCacheEntry in parameter \"src\" into this\n+  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"src\" points to\n+  \/\/ allocated space (i.e., the bit mask was too large to hold\n+  \/\/ in-line), allocate the space from the C heap.\n+  void copy_from(const OopMapCacheEntry* src);\n@@ -186,2 +185,2 @@\n-  \/\/ Request cleanup if work is needed\n-  static void trigger_cleanup();\n+  \/\/ Request cleanup if work is needed and notification is currently possible\n+  static void try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"jfr\/recorder\/repository\/jfrChunk.hpp\"\n@@ -428,0 +429,4 @@\n+\n+NO_TRANSITION(jlong, jfr_nanos_now(JNIEnv* env, jclass jvm))\n+  return JfrChunk::nanos_now();\n+NO_TRANSITION_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -168,0 +168,2 @@\n+jlong JNICALL jfr_nanos_now(JNIEnv* env, jclass jvm);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-      (char*)\"unregisterStackFilter\", (char*)\"(J)V\", (void*)jfr_unregister_stack_filter\n+      (char*)\"unregisterStackFilter\", (char*)\"(J)V\", (void*)jfr_unregister_stack_filter,\n+      (char*)\"nanosNow\", (char*)\"()J\", (void*)jfr_nanos_now\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n@@ -275,0 +276,18 @@\n+\/\/ Resets the blob write states from the previous epoch.\n+static void reset_blob_write_state(const ObjectSampler* sampler, JavaThread* jt) {\n+  assert(sampler != nullptr, \"invariant\");\n+  const ObjectSample* sample = sampler->last_resolved();\n+  while (sample != nullptr) {\n+    if (sample->has_stacktrace()) {\n+      sample->stacktrace()->reset_write_state();\n+    }\n+    if (sample->has_thread()) {\n+      sample->thread()->reset_write_state();\n+    }\n+    if (sample->has_type_set()) {\n+      sample->type_set()->reset_write_state();\n+    }\n+    sample = sample->next();\n+  }\n+}\n+\n@@ -280,0 +299,1 @@\n+  reset_blob_write_state(sampler, thread);\n@@ -329,5 +349,1 @@\n-static void write_blob(const JfrBlobHandle& blob, JfrCheckpointWriter& writer, bool reset) {\n-  if (reset) {\n-    blob->reset_write_state();\n-    return;\n-  }\n+static void write_blob(const JfrBlobHandle& blob, JfrCheckpointWriter& writer) {\n@@ -337,1 +353,1 @@\n-static void write_type_set_blob(const ObjectSample* sample, JfrCheckpointWriter& writer, bool reset) {\n+static void write_type_set_blob(const ObjectSample* sample, JfrCheckpointWriter& writer) {\n@@ -339,1 +355,1 @@\n-    write_blob(sample->type_set(), writer, reset);\n+    write_blob(sample->type_set(), writer);\n@@ -343,1 +359,1 @@\n-static void write_thread_blob(const ObjectSample* sample, JfrCheckpointWriter& writer, bool reset) {\n+static void write_thread_blob(const ObjectSample* sample, JfrCheckpointWriter& writer) {\n@@ -346,1 +362,1 @@\n-    write_blob(sample->thread(), writer, reset);\n+    write_blob(sample->thread(), writer);\n@@ -350,1 +366,1 @@\n-static void write_stacktrace_blob(const ObjectSample* sample, JfrCheckpointWriter& writer, bool reset) {\n+static void write_stacktrace_blob(const ObjectSample* sample, JfrCheckpointWriter& writer) {\n@@ -352,1 +368,1 @@\n-    write_blob(sample->stacktrace(), writer, reset);\n+    write_blob(sample->stacktrace(), writer);\n@@ -356,1 +372,1 @@\n-static void write_blobs(const ObjectSample* sample, JfrCheckpointWriter& writer, bool reset) {\n+static void write_blobs(const ObjectSample* sample, JfrCheckpointWriter& writer) {\n@@ -358,3 +374,3 @@\n-  write_stacktrace_blob(sample, writer, reset);\n-  write_thread_blob(sample, writer, reset);\n-  write_type_set_blob(sample, writer, reset);\n+  write_stacktrace_blob(sample, writer);\n+  write_thread_blob(sample, writer);\n+  write_type_set_blob(sample, writer);\n@@ -368,1 +384,0 @@\n-  bool _reset;\n@@ -371,1 +386,1 @@\n-    _sampler(sampler), _writer(writer), _last_sweep(last_sweep), _reset(false)  {}\n+    _sampler(sampler), _writer(writer), _last_sweep(last_sweep) {}\n@@ -374,1 +389,1 @@\n-      write_blobs(sample, _writer, _reset);\n+      write_blobs(sample, _writer);\n@@ -377,3 +392,0 @@\n-  void set_reset() {\n-    _reset = true;\n-  }\n@@ -388,3 +400,0 @@\n-  \/\/ reset blob write states\n-  cbw.set_reset();\n-  iterate_samples(cbw, true);\n@@ -406,38 +415,0 @@\n-\/\/ A linked list of saved type set blobs for the epoch.\n-\/\/ The link consist of a reference counted handle.\n-static JfrBlobHandle saved_type_set_blobs;\n-\n-static void release_state_for_previous_epoch() {\n-  \/\/ decrements the reference count and the list is reinitialized\n-  saved_type_set_blobs = JfrBlobHandle();\n-}\n-\n-class BlobInstaller {\n- public:\n-  ~BlobInstaller() {\n-    release_state_for_previous_epoch();\n-  }\n-  void sample_do(ObjectSample* sample) {\n-    if (!sample->is_dead()) {\n-      sample->set_type_set(saved_type_set_blobs);\n-    }\n-  }\n-};\n-\n-static void install_type_set_blobs() {\n-  if (saved_type_set_blobs.valid()) {\n-    BlobInstaller installer;\n-    iterate_samples(installer);\n-  }\n-}\n-\n-static void save_type_set_blob(JfrCheckpointWriter& writer) {\n-  assert(writer.has_data(), \"invariant\");\n-  const JfrBlobHandle blob = writer.copy();\n-  if (saved_type_set_blobs.valid()) {\n-    saved_type_set_blobs->set_next(blob);\n-  } else {\n-    saved_type_set_blobs = blob;\n-  }\n-}\n-\n@@ -445,1 +416,1 @@\n-void ObjectSampleCheckpoint::on_type_set(JfrCheckpointWriter& writer) {\n+void ObjectSampleCheckpoint::on_type_set(JavaThread* jt) {\n@@ -452,1 +423,1 @@\n-  const ObjectSample* const last = ObjectSampler::sampler()->last();\n+  ObjectSample* const last = ObjectSampler::sampler()->last();\n@@ -455,4 +426,1 @@\n-  if (writer.has_data()) {\n-    save_type_set_blob(writer);\n-  }\n-  install_type_set_blobs();\n+  JfrReferenceCountedStorage::install(last, ObjectSampler::sampler()->last_resolved());\n@@ -461,9 +429,0 @@\n-\n-\/\/ This routine does NOT have exclusive access to the sampler instance on entry.\n-void ObjectSampleCheckpoint::on_type_set_unload(JfrCheckpointWriter& writer) {\n-  assert(LeakProfiler::is_running(), \"invariant\");\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  if (writer.has_data() && ObjectSampler::has_unresolved_entry()) {\n-    save_type_set_blob(writer);\n-  }\n-}\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":36,"deletions":77,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,1 @@\n-  static void on_type_set(JfrCheckpointWriter& writer);\n-  static void on_type_set_unload(JfrCheckpointWriter& writer);\n+  static void on_type_set(JavaThread* jt);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -236,1 +236,1 @@\n-  void set_type_set(const JfrBlobHandle& ref) {\n+  void install_type_set(const JfrBlobHandle& ref) {\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSample.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n@@ -592,6 +593,8 @@\n-  JfrDeprecationManager::on_type_set(leakp_writer, nullptr, thread);\n-  \/\/ We placed a blob in the Deprecated subsystem by moving the information\n-  \/\/ from the leakp writer. For the real writer, the data will not be\n-  \/\/ committed, because the JFR system is yet to be started.\n-  \/\/ Therefore, the writer is cancelled before its destructor is run,\n-  \/\/ to avoid writing unnecessary information into the checkpoint system.\n+  JfrAddRefCountedBlob add_blob(leakp_writer);\n+  JfrDeprecationManager::on_type_set(nullptr, thread);\n+  \/\/ We installed a blob in the JfrReferenceCountedStorage subsystem\n+  \/\/ by moving the information from the leakp writer.\n+  \/\/ For the real writer, the data will not be committed,\n+  \/\/ because the JFR system is yet to be started.\n+  \/\/ Therefore, we cancel the writer before its destructor is run\n+  \/\/ to avoid writing invalid information into the checkpoint system.\n@@ -616,0 +619,1 @@\n+    JfrAddRefCountedBlob add_blob(leakp_writer);\n@@ -617,1 +621,1 @@\n-      ObjectSampleCheckpoint::on_type_set(leakp_writer);\n+      ObjectSampleCheckpoint::on_type_set(thread);\n@@ -619,2 +623,1 @@\n-    \/\/ Place this call after ObjectSampleCheckpoint::on_type_set.\n-    JfrDeprecationManager::on_type_set(leakp_writer, _chunkwriter, thread);\n+    JfrDeprecationManager::on_type_set(_chunkwriter, thread);\n@@ -629,4 +632,1 @@\n-  if (LeakProfiler::is_running()) {\n-    ObjectSampleCheckpoint::on_type_set_unload(writer);\n-  }\n-  JfrDeprecationManager::on_type_set_unload(writer);\n+  JfrAddRefCountedBlob add_blob(writer, false \/* move *\/, false \/* reset *\/);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  friend class JfrAddRefCountedBlob;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+    case JVMFlagOrigin::CRAC_RESTORE: return \"CRaC restore\";\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -313,0 +313,1 @@\n+    assert(!IS_THIS_EPOCH_CLEARED_BIT_SET(ptr), \"invariant\");\n@@ -314,0 +315,1 @@\n+  assert(IS_PREVIOUS_EPOCH_CLEARED_BIT_SET(ptr), \"invariant\");\n@@ -932,0 +934,1 @@\n+    assert(!IS_THIS_EPOCH_METHOD_CLEARED_BIT_SET(method), \"invariant\");\n@@ -935,0 +938,1 @@\n+  assert(IS_PREVIOUS_EPOCH_METHOD_CLEARED_BIT_SET(method), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+    assert(IS_THIS_EPOCH_CLEARED_BIT_SET(value), \"invariant\");\n+    assert(IS_PREVIOUS_EPOCH_CLEARED_BIT_SET(value), \"invariant\");\n@@ -114,0 +116,2 @@\n+    assert(IS_THIS_EPOCH_METHOD_CLEARED_BIT_SET(method), \"invariant\");\n+    assert(IS_PREVIOUS_EPOCH_METHOD_CLEARED_BIT_SET(method), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-  return atomic_inc(&class_id_counter) << TRACE_ID_SHIFT;\n+  return (atomic_inc(&class_id_counter) << TRACE_ID_SHIFT) | EPOCH_CLEARED_BITS;\n@@ -58,1 +58,1 @@\n-  return atomic_inc(&module_id_counter) << TRACE_ID_SHIFT;\n+  return (atomic_inc(&module_id_counter) << TRACE_ID_SHIFT) | EPOCH_CLEARED_BITS;\n@@ -63,1 +63,1 @@\n-  return atomic_inc(&package_id_counter) << TRACE_ID_SHIFT;\n+  return (atomic_inc(&package_id_counter) << TRACE_ID_SHIFT) | EPOCH_CLEARED_BITS;\n@@ -68,1 +68,1 @@\n-  return atomic_inc(&cld_id_counter) << TRACE_ID_SHIFT;\n+  return (atomic_inc(&cld_id_counter) << TRACE_ID_SHIFT) | EPOCH_CLEARED_BITS;\n@@ -204,1 +204,1 @@\n-  \/\/ Mask off and store the event flags.\n+  \/\/ Mask off and store the event flags and epoch clear bits.\n@@ -208,1 +208,1 @@\n-  k->set_trace_id(EVENT_KLASS_MASK(k));\n+  k->set_trace_id(EPOCH_CLEARED_BITS | EVENT_KLASS_MASK(k));\n@@ -214,2 +214,2 @@\n-  \/\/ Clear all bits.\n-  method->set_trace_flags(0);\n+  \/\/ Clear tag bits and set epoch cleared bits.\n+  method->set_trace_flags(static_cast<uint16_t>(EPOCH_CLEARED_BITS));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -160,1 +160,0 @@\n-  assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), \"invariant\");\n@@ -163,0 +162,1 @@\n+  assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), \"invariant\");\n@@ -177,1 +177,0 @@\n-  assert(METHOD_AND_CLASS_USED_PREVIOUS_EPOCH(klass), \"invariant\");\n@@ -180,0 +179,1 @@\n+  assert(METHOD_AND_CLASS_USED_PREVIOUS_EPOCH(klass), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+#define EPOCH_CLEARED_BITS                        (EPOCH_1_CLEARED_BIT | EPOCH_0_CLEARED_BIT)\n@@ -139,0 +140,2 @@\n+#define IS_THIS_EPOCH_CLEARED_BIT_SET(ptr)        (TRACE_ID_PREDICATE(ptr, (THIS_EPOCH_BIT << META_SHIFT)))\n+#define IS_PREVIOUS_EPOCH_CLEARED_BIT_SET(ptr)    (TRACE_ID_PREDICATE(ptr, (PREVIOUS_EPOCH_BIT << META_SHIFT)))\n@@ -164,0 +167,2 @@\n+#define IS_THIS_EPOCH_METHOD_CLEARED_BIT_SET(ptr) (METHOD_FLAG_PREDICATE(ptr, (THIS_EPOCH_BIT << META_SHIFT)))\n+#define IS_PREVIOUS_EPOCH_METHOD_CLEARED_BIT_SET(ptr) (METHOD_FLAG_PREDICATE(ptr, (PREVIOUS_EPOCH_BIT << META_SHIFT)))\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jlong nanos_now() {\n+jlong JfrChunk::nanos_now() {\n@@ -50,2 +50,0 @@\n-  } else {\n-    ++last;\n@@ -150,1 +148,1 @@\n-  const jlong now = nanos_now();\n+  const jlong now = JfrChunk::nanos_now();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunk.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+ public:\n+   static jlong nanos_now();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunk.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/leakprofiler\/sampling\/objectSampler.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp\"\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n+#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n+\n+\/\/ Currently only two subsystems use type set blobs. Save a blob only if either has an unresolved entry.\n+static inline bool save_blob_predicate() {\n+  return JfrDeprecationManager::has_unresolved_entry() || ObjectSampler::has_unresolved_entry();\n+}\n+\n+JfrAddRefCountedBlob::JfrAddRefCountedBlob(JfrCheckpointWriter& writer, bool move \/* true *\/, bool reset \/* true *\/) : _reset(reset) {\n+  if (writer.has_data()) {\n+    if (save_blob_predicate()) {\n+      JfrReferenceCountedStorage::save_blob(writer, move);\n+    } else if (move) {\n+      writer.cancel();\n+    }\n+  }\n+  DEBUG_ONLY(if (reset) JfrReferenceCountedStorage::set_scope();)\n+}\n+\n+JfrAddRefCountedBlob::~JfrAddRefCountedBlob() {\n+  if (_reset) {\n+    JfrReferenceCountedStorage::reset();\n+  }\n+}\n+\n+JfrBlobHandle JfrReferenceCountedStorage::_type_sets = JfrBlobHandle();\n+DEBUG_ONLY(bool JfrReferenceCountedStorage::_scope = false;)\n+\n+void JfrReferenceCountedStorage::save_blob(JfrCheckpointWriter& writer, bool move \/* false *\/) {\n+  assert(writer.has_data(), \"invariant\");\n+  const JfrBlobHandle blob = move ? writer.move() : writer.copy();\n+  if (_type_sets.valid()) {\n+    _type_sets->set_next(blob);\n+    return;\n+  }\n+  _type_sets = blob;\n+}\n+\n+void JfrReferenceCountedStorage::reset() {\n+  assert(_scope, \"invariant\");\n+  if (_type_sets.valid()) {\n+    _type_sets = JfrBlobHandle();\n+  }\n+  DEBUG_ONLY(_scope = false;)\n+}\n+\n+#ifdef ASSERT\n+void JfrReferenceCountedStorage::set_scope() {\n+  assert(!_scope, \"invariant\");\n+  _scope = true;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrReferenceCountedStorage.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STORAGE_JFRREFERENCECOUNTEDSTORAGE_HPP\n+#define SHARE_JFR_RECORDER_STORAGE_JFRREFERENCECOUNTEDSTORAGE_HPP\n+\n+#include \"jfr\/utilities\/jfrBlob.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class JfrCheckpointWriter;\n+\n+\/\/ RAII helper class for adding blobs to the storage.\n+class JfrAddRefCountedBlob : public StackObj {\n+ private:\n+  bool _reset;\n+ public:\n+  JfrAddRefCountedBlob(JfrCheckpointWriter& writer, bool move = true, bool reset = true);\n+  ~JfrAddRefCountedBlob();\n+};\n+\n+\/\/ The debug aid 'scope' implies the proper RAII save construct is placed on stack.\n+\/\/ This is a necessary condition for installing reference counted storage to nodes.\n+class JfrReferenceCountedStorage : AllStatic {\n+  friend class JfrAddRefCountedBlob;\n+ private:\n+  static JfrBlobHandle _type_sets; \/\/ linked-list of blob handles saved during epoch.\n+  DEBUG_ONLY(static bool _scope;)\n+\n+  static void save_blob(JfrCheckpointWriter& writer, bool move = false);\n+  static void reset();\n+  DEBUG_ONLY(static void set_scope();)\n+\n+ public:\n+  template <typename T>\n+  static void install(T* node, const T* end) {\n+    assert(_scope, \"invariant\");\n+    if (_type_sets.valid()) {\n+      while (node != end) {\n+        node->install_type_set(_type_sets);\n+        node = node->next();\n+      }\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STORAGE_JFRREFERENCECOUNTEDSTORAGE_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,2 @@\n-JfrDeprecatedEventWriter::JfrDeprecatedEventWriter(JfrChunkWriter& cw, bool stacktrace) :\n-  _now(JfrTicks::now()),_cw(cw), _for_removal(only_for_removal()), _stacktrace(stacktrace), _did_write(false) {}\n+JfrDeprecatedEventWriter::JfrDeprecatedEventWriter(JfrChunkWriter& cw, JfrCheckpointWriter& tsw, bool stacktrace) :\n+  _now(JfrTicks::now()),_cw(cw), _tsw(tsw), _for_removal(only_for_removal()), _stacktrace(stacktrace) {}\n@@ -144,0 +144,7 @@\n+static void write_type_set(const JfrDeprecatedEdge* edge, JfrCheckpointWriter& tsw) {\n+  if (!edge->has_type_set()) {\n+    return;\n+  }\n+  edge->type_set()->exclusive_write(tsw);\n+}\n+\n@@ -149,3 +156,11 @@\n-  write_event(edge, _cw,_now, _stacktrace);\n-  if (!_did_write) {\n-    _did_write = true;\n+  write_event(edge, _cw, _now, _stacktrace);\n+  write_type_set(edge, _tsw);\n+  return true;\n+}\n+\n+JfrDeprecatedEventClear::JfrDeprecatedEventClear() {}\n+\n+bool JfrDeprecatedEventClear::process(const JfrDeprecatedEdge* edge) {\n+  assert(edge != nullptr, \"invariant\");\n+  if (!edge->has_type_set()) {\n+    return true;\n@@ -153,0 +168,1 @@\n+  edge->type_set()->reset_write_state();\n@@ -155,0 +171,1 @@\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.cpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+  JfrCheckpointWriter& _tsw;\n@@ -61,1 +62,0 @@\n-  bool _did_write;\n@@ -63,2 +63,7 @@\n-  JfrDeprecatedEventWriter(JfrChunkWriter& cw, bool stacktrace);\n-  bool did_write() const { return _did_write; }\n+  JfrDeprecatedEventWriter(JfrChunkWriter& cw, JfrCheckpointWriter& tsw, bool stacktrace);\n+  bool process(const JfrDeprecatedEdge* edge);\n+};\n+\n+class JfrDeprecatedEventClear : public StackObj {\n+ public:\n+  JfrDeprecatedEventClear();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"jfr\/recorder\/storage\/jfrReferenceCountedStorage.hpp\"\n@@ -69,0 +70,1 @@\n+  _type_set(),\n@@ -97,0 +99,14 @@\n+bool JfrDeprecatedEdge::has_type_set() const {\n+  return _type_set.valid();\n+}\n+\n+const JfrBlobHandle& JfrDeprecatedEdge::type_set() const {\n+  assert(has_type_set(), \"invariant\");\n+  return _type_set;\n+}\n+\n+void JfrDeprecatedEdge::install_type_set(const JfrBlobHandle& type_set) {\n+  assert(!has_type_set(), \"invariant\");\n+  _type_set = type_set;\n+}\n+\n@@ -101,1 +117,1 @@\n-static DeprecatedEdgeList _resolved_list; \/\/ Fully resolved edges (event and stacktrace blobs).\n+static DeprecatedEdgeList _resolved_list; \/\/ Fully resolved edges (event, stacktrace and typeset blobs).\n@@ -228,4 +244,0 @@\n-void JfrDeprecationManager::on_level_setting_update(int64_t new_level) {\n-  JfrDeprecatedEventWriterState::on_level_setting_update(new_level);\n-}\n-\n@@ -273,0 +285,17 @@\n+inline DeprecatedEdgeList::NodePtr pending_head() {\n+  return Atomic::load(&_pending_head);\n+}\n+\n+\/\/ The test for a pending head can be read concurrently from a thread doing class unloading.\n+inline static bool has_pending_head() {\n+  return pending_head() != nullptr;\n+}\n+\n+inline static bool no_pending_head() {\n+  return !has_pending_head();\n+}\n+\n+inline static void set_pending_head(DeprecatedEdgeList::NodePtr head) {\n+  Atomic::store(&_pending_head, head);\n+}\n+\n@@ -284,2 +313,2 @@\n-    if (_pending_head == nullptr) {\n-      _pending_head = edge;\n+    if (no_pending_head()) {\n+      set_pending_head(edge);\n@@ -292,2 +321,4 @@\n-void JfrDeprecationManager::prepare_type_set(JavaThread* jt) {\n-  _pending_head = nullptr;\n+\/\/ Resets the pending head and tail.\n+\/\/ Resets blob write states for nodes on the resolved list, dirtied in the previous epoch.\n+static void reset_type_set_blobs() {\n+  set_pending_head(nullptr);\n@@ -295,0 +326,8 @@\n+  if (_resolved_list.is_nonempty()) {\n+    JfrDeprecatedEventClear clear;\n+    _resolved_list.iterate(clear);\n+  }\n+}\n+\n+void JfrDeprecationManager::prepare_type_set(JavaThread* jt) {\n+  reset_type_set_blobs();\n@@ -300,1 +339,1 @@\n-    assert(_pending_head != nullptr, \"invariant\");\n+    assert(has_pending_head(), \"invariant\");\n@@ -306,1 +345,1 @@\n-    _resolved_list.add_list(_pending_head);\n+    _resolved_list.add_list(pending_head());\n@@ -312,21 +351,2 @@\n-\/\/ A linked-list of blob handles.\n-static JfrBlobHandle type_set_blobs;\n-\n-static inline void write_type_set_blobs(JfrCheckpointWriter& writer) {\n-  type_set_blobs->write(writer);\n-}\n-\n-static void save_type_set_blob(JfrCheckpointWriter& writer, bool copy = false) {\n-  assert(writer.has_data(), \"invariant\");\n-  const JfrBlobHandle blob = copy ? writer.copy() : writer.move();\n-  if (type_set_blobs.valid()) {\n-    type_set_blobs->set_next(blob);\n-  } else {\n-    type_set_blobs = blob;\n-  }\n-}\n-\n-void JfrDeprecationManager::on_type_set_unload(JfrCheckpointWriter& writer) {\n-  if (writer.has_data()) {\n-    save_type_set_blob(writer, true);\n-  }\n+bool JfrDeprecationManager::has_unresolved_entry() {\n+  return _list.is_nonempty() || has_pending_head() || _pending_list.is_nonempty();\n@@ -339,1 +359,1 @@\n-static inline bool write_events(JfrChunkWriter& cw) {\n+static inline void write_events(JfrChunkWriter& cw, Thread* thread, bool on_error) {\n@@ -341,1 +361,2 @@\n-  JfrDeprecatedEventWriter ebw(cw, has_stacktrace());\n+  JfrCheckpointWriter type_set_writer(!on_error, thread, false);\n+  JfrDeprecatedEventWriter ebw(cw, type_set_writer, has_stacktrace());\n@@ -343,1 +364,0 @@\n-  return ebw.did_write();\n@@ -352,9 +372,3 @@\n-static inline void write_type_sets(Thread* thread, bool on_error) {\n-  JfrCheckpointWriter writer(!on_error, thread, false);\n-  write_type_set_blobs(writer);\n-}\n-\n-\/\/ First, we consolidate all stacktrace blobs into a single TYPE_STACKTRACE checkpoint and serialize it to the chunk.\n-\/\/ Secondly, we serialize all events to the chunk.\n-\/\/ Thirdly, the type set blobs are written into the JfrCheckpoint system, to be serialized to the chunk\n-\/\/ just after we return from here.\n+\/\/ First, we consolidate all stack trace blobs into a single TYPE_STACKTRACE checkpoint\n+\/\/ and serialize it to the chunk. Then, all events are serialized, and unique type set blobs\n+\/\/ written into the JfrCheckpoint system to be serialized to the chunk upon return.\n@@ -366,3 +380,1 @@\n-    if (write_events(cw)) {\n-      write_type_sets(thread, on_error);\n-    }\n+    write_events(cw, thread, on_error);\n@@ -372,1 +384,1 @@\n-void JfrDeprecationManager::on_type_set(JfrCheckpointWriter& writer, JfrChunkWriter* cw, Thread* thread) {\n+void JfrDeprecationManager::on_type_set(JfrChunkWriter* cw, Thread* thread) {\n@@ -374,4 +386,4 @@\n-  if (_pending_head != nullptr) {\n-    save_type_set_blob(writer);\n-  } else {\n-    writer.cancel();\n+  if (has_pending_head()) {\n+    assert(_pending_tail != nullptr, \"invariant\");\n+    \/\/ Install type set blobs for the pending, i.e. unresolved nodes.\n+    JfrReferenceCountedStorage::install(pending_head(), _pending_tail->next());\n@@ -383,0 +395,4 @@\n+\n+void JfrDeprecationManager::on_level_setting_update(int64_t new_level) {\n+  JfrDeprecatedEventWriterState::on_level_setting_update(new_level);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":69,"deletions":53,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+  JfrBlobHandle _type_set;\n@@ -61,1 +62,1 @@\n-  const JfrDeprecatedEdge* next() const { return _next; }\n+  JfrDeprecatedEdge* next() const { return _next; }\n@@ -71,0 +72,4 @@\n+  bool has_type_set() const;\n+  const JfrBlobHandle& type_set() const;\n+  void install_type_set(const JfrBlobHandle& type_set);\n+\n@@ -92,2 +97,1 @@\n-  static void on_type_set(JfrCheckpointWriter& writer, JfrChunkWriter* cw, Thread* thread);\n-  static void on_type_set_unload(JfrCheckpointWriter& writer);\n+  static void on_type_set(JfrChunkWriter* cw, Thread* thread);\n@@ -97,0 +101,1 @@\n+  static bool has_unresolved_entry();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+  template(jdk_jfr_internal_HiddenWait,                               \"jdk\/jfr\/internal\/HiddenWait\")                 \\\n@@ -56,1 +57,0 @@\n-  template(jfr_chunk_rotation_monitor,                                \"jdk\/jfr\/internal\/JVM$ChunkRotationMonitor\")   \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+static constexpr const uint16_t cleared_epoch_bits = 512 | 256;\n+\n@@ -51,1 +53,1 @@\n-  JfrTraceFlag() : _flags(0) {}\n+  JfrTraceFlag() : _flags(cleared_epoch_bits) {}\n@@ -99,3 +101,2 @@\n-  void copy_trace_flags(uint8_t src_flags) const { \\\n-    uint8_t flags = *_trace_flags.flags_addr();    \\\n-    _trace_flags.set_flags(flags | src_flags);     \\\n+  void copy_trace_flags(uint16_t rhs_flags) const { \\\n+    _trace_flags.set_flags(_trace_flags.flags() | rhs_flags); \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTraceIdExtension.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  : _flush_sem(0), _lock(), _data_available(false),\n+  : _flush_sem(0), _lock(), _block_async(), _data_available(false),\n@@ -178,0 +178,3 @@\n+\n+    _block_async.lock();\n+    _block_async.unlock();\n@@ -226,0 +229,9 @@\n+void AsyncLogWriter::stop() {\n+  _block_async.lock();\n+  flush();\n+}\n+\n+void AsyncLogWriter::resume() {\n+  _block_async.unlock();\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -163,0 +163,2 @@\n+  \/\/ for asynchronous thread run()\n+  PlatformMonitor _block_async;\n@@ -205,0 +207,2 @@\n+  void stop();\n+  void resume();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -720,0 +720,22 @@\n+\n+bool LogConfiguration::is_fd_used(int fd) {\n+  assert(fd != -1, \"fd must be valid\");\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    if (fd == _outputs[i]->fd_get()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void LogConfiguration::close() {\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    _outputs[i]->close();\n+  }\n+}\n+\n+void LogConfiguration::reopen() {\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    _outputs[i]->reopen();\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -136,0 +136,5 @@\n+\n+  \/\/ Is this file descriptor in use?\n+  static bool is_fd_used(int fd);\n+  static void close();\n+  static void reopen();\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -469,0 +469,33 @@\n+\n+int LogFileOutput::fd_get() const {\n+  if (_stream == nullptr) {\n+    return -1;\n+  }\n+  return LogFileStreamOutput::fd_get();\n+}\n+\n+void LogFileOutput::close() {\n+  if (_stream == nullptr) {\n+    return;\n+  }\n+  if (fclose(_stream)) {\n+    jio_fprintf(defaultStream::error_stream(), \"Error closing log file '%s' (%s).\\n\",\n+                _file_name, os::strerror(errno));\n+  }\n+  _stream = nullptr;\n+}\n+\n+void LogFileOutput::reopen() {\n+  assert(_stream == nullptr, \"reopening an already opened log file\");\n+\n+  \/\/ Open the active log file using the same stream as before\n+  _stream = os::fopen(_file_name, FileOpenMode);\n+  if (_stream == nullptr) {\n+    jio_fprintf(defaultStream::error_stream(), \"Could not reopen log file '%s' (%s).\\n\",\n+                _file_name, os::strerror(errno));\n+    return;\n+  }\n+\n+  \/\/ _current_size still keeps how much data we wrote for the rotation purposes.\n+  \/\/ The log file may contain more data now.\n+}\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -86,7 +86,10 @@\n-  virtual bool initialize(const char* options, outputStream* errstream);\n-  virtual bool set_option(const char* key, const char* value, outputStream* errstream);\n-  virtual int write(const LogDecorations& decorations, const char* msg);\n-  virtual int write(LogMessageBuffer::Iterator msg_iterator);\n-  virtual int write_blocking(const LogDecorations& decorations, const char* msg);\n-  virtual void force_rotate();\n-  virtual void describe(outputStream* out);\n+  virtual bool initialize(const char* options, outputStream* errstream) override;\n+  virtual bool set_option(const char* key, const char* value, outputStream* errstream) override;\n+  virtual int write(const LogDecorations& decorations, const char* msg) override;\n+  virtual int write(LogMessageBuffer::Iterator msg_iterator) override;\n+  virtual int write_blocking(const LogDecorations& decorations, const char* msg) override;\n+  virtual void force_rotate() override;\n+  virtual void describe(outputStream* out) override;\n+  virtual int fd_get() const override;\n+  virtual void close() override;\n+  virtual void reopen() override;\n@@ -94,1 +97,1 @@\n-  virtual const char* name() const {\n+  virtual const char* name() const override {\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -56,3 +56,3 @@\n-  virtual bool set_option(const char* key, const char* value, outputStream* errstream);\n-  virtual int write(const LogDecorations& decorations, const char* msg);\n-  virtual int write(LogMessageBuffer::Iterator msg_iterator);\n+  virtual bool set_option(const char* key, const char* value, outputStream* errstream) override;\n+  virtual int write(const LogDecorations& decorations, const char* msg) override;\n+  virtual int write(LogMessageBuffer::Iterator msg_iterator) override;\n@@ -61,1 +61,2 @@\n-  virtual void describe(outputStream* out);\n+  virtual void describe(outputStream* out) override;\n+  virtual int fd_get() const override { return fileno(_stream); }\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+  virtual int fd_get() const { return -1; }\n+  virtual void close() {}\n+  virtual void reopen() {}\n","filename":"src\/hotspot\/share\/logging\/logOutput.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  LOG_TAG(crac) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -176,1 +177,1 @@\n-             method->method_holder()->is_init_thread(JavaThread::current()),\n+             method->method_holder()->is_reentrant_initialization(JavaThread::current()),\n@@ -271,0 +272,1 @@\n+\n@@ -273,2 +275,0 @@\n-  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n-  ResolvedMethodEntry* method_entry = resolved_method_entry_at(method_index);\n@@ -276,0 +276,10 @@\n+  JavaThread* current = JavaThread::current();\n+  objArrayHandle resolved_references(current, constant_pool()->resolved_references());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n+\n+  ResolvedMethodEntry* method_entry = resolved_method_entry_at(method_index);\n@@ -313,1 +323,0 @@\n-    objArrayOop resolved_references = constant_pool()->resolved_references();\n@@ -558,1 +567,8 @@\n-  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = THREAD;\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -581,1 +597,11 @@\n-  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n+\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = JavaThread::current();\n+  constantPoolHandle cp(current, constant_pool());\n+\n+  objArrayHandle resolved_references(current, cp->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -585,1 +611,1 @@\n-    return constant_pool()->resolved_reference_from_indy(index);\n+    return cp->resolved_reference_from_indy(index);\n@@ -593,3 +619,1 @@\n-    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-    constantPoolHandle cp(THREAD, constant_pool());\n-    ConstantPool::throw_resolution_error(cp, encoded_index, THREAD);\n+    ConstantPool::throw_resolution_error(cp, encoded_index, current);\n@@ -619,1 +643,0 @@\n-    objArrayOop resolved_references = constant_pool()->resolved_references();\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":34,"deletions":11,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -500,3 +501,0 @@\n-static Monitor* create_init_monitor(const char* name) {\n-  return new Monitor(Mutex::safepoint, name);\n-}\n@@ -520,1 +518,0 @@\n-  _init_monitor(create_init_monitor(\"InstanceKlassInitMonitor_lock\")),\n@@ -748,0 +745,22 @@\n+oop InstanceKlass::init_lock() const {\n+  \/\/ return the init lock from the mirror\n+  oop lock = java_lang_Class::init_lock(java_mirror());\n+  \/\/ Prevent reordering with any access of initialization state\n+  OrderAccess::loadload();\n+  assert(lock != nullptr || !is_not_initialized(), \/\/ initialized or in_error state\n+         \"only fully initialized state can have a null lock\");\n+  return lock;\n+}\n+\n+\/\/ Set the initialization lock to null so the object can be GC'ed.  Any racing\n+\/\/ threads to get this lock will see a null lock and will not lock.\n+\/\/ That's okay because they all check for initialized state after getting\n+\/\/ the lock and return.\n+void InstanceKlass::fence_and_clear_init_lock() {\n+  \/\/ make sure previous stores are all done, notably the init_state.\n+  OrderAccess::storestore();\n+  java_lang_Class::clear_init_lock(java_mirror());\n+  assert(!is_not_initialized(), \"class must be initialized now\");\n+}\n+\n+\n@@ -775,43 +794,0 @@\n-void InstanceKlass::check_link_state_and_wait(JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  bool debug_logging_enabled = log_is_enabled(Debug, class, init);\n-\n-  \/\/ Another thread is linking this class, wait.\n-  while (is_being_linked() && !is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" waiting for linking of %s by thread \\\"%s\\\"\",\n-                             current->name(), external_name(), init_thread_name());\n-    }\n-    ml.wait();\n-  }\n-\n-  \/\/ This thread is recursively linking this class, continue\n-  if (is_being_linked() && is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" recursively linking %s\",\n-                             current->name(), external_name());\n-    }\n-    return;\n-  }\n-\n-  \/\/ If this class wasn't linked already, set state to being_linked\n-  if (!is_linked()) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" linking %s\",\n-                             current->name(), external_name());\n-    }\n-    set_init_state(being_linked);\n-    set_init_thread(current);\n-  } else {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" found %s already linked\",\n-                             current->name(), external_name());\n-      }\n-  }\n-}\n-\n@@ -896,2 +872,3 @@\n-    LockLinkState init_lock(this, jt);\n-\n+    HandleMark hm(THREAD);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -955,1 +932,15 @@\n-      set_initialization_state_and_notify(linked, THREAD);\n+      if (UseVtableBasedCHA && Universe::is_fully_initialized()) {\n+        DeoptimizationScope deopt_scope;\n+        {\n+          \/\/ Now mark all code that assumes the class is not linked.\n+          \/\/ Set state under the Compile_lock also.\n+          MutexLocker ml(THREAD, Compile_lock);\n+\n+          set_init_state(linked);\n+          CodeCache::mark_dependents_on(&deopt_scope, this);\n+        }\n+        \/\/ Perform the deopt handshake outside Compile_lock.\n+        deopt_scope.deoptimize_marked();\n+      } else {\n+        set_init_state(linked);\n+      }\n@@ -1085,1 +1076,0 @@\n-  bool throw_error = false;\n@@ -1094,1 +1084,2 @@\n-    MonitorLocker ml(jt, _init_monitor);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1097,1 +1088,4 @@\n-    while (is_being_initialized() && !is_init_thread(jt)) {\n+    \/\/ If we were to use wait() instead of waitInterruptibly() then\n+    \/\/ we might end up throwing IE from link\/symbol resolution sites\n+    \/\/ that aren't expected to throw.  This would wreak havoc.  See 6320309.\n+    while (is_being_initialized() && !is_reentrant_initialization(jt)) {\n@@ -1103,1 +1097,0 @@\n-\n@@ -1106,1 +1099,1 @@\n-      ml.wait();\n+      ol.wait_uninterruptibly(jt);\n@@ -1111,1 +1104,1 @@\n-    if (is_being_initialized() && is_init_thread(jt)) {\n+    if (is_being_initialized() && is_reentrant_initialization(jt)) {\n@@ -1139,1 +1132,13 @@\n-      throw_error = true;\n+\n+      DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n+      ResourceMark rm(THREAD);\n+      Handle cause(THREAD, get_initialization_error(THREAD));\n+\n+      stringStream ss;\n+      ss.print(\"Could not initialize class %s\", external_name());\n+      if (cause.is_null()) {\n+        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n+      } else {\n+        THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n+                        ss.as_string(), cause);\n+      }\n@@ -1153,16 +1158,0 @@\n-  \/\/ Throw error outside lock\n-  if (throw_error) {\n-    DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n-    ResourceMark rm(THREAD);\n-    Handle cause(THREAD, get_initialization_error(THREAD));\n-\n-    stringStream ss;\n-    ss.print(\"Could not initialize class %s\", external_name());\n-    if (cause.is_null()) {\n-      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n-    } else {\n-      THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n-                      ss.as_string(), cause);\n-    }\n-  }\n-\n@@ -1226,1 +1215,1 @@\n-    set_initialization_state_and_notify(fully_initialized, THREAD);\n+    set_initialization_state_and_notify(fully_initialized, CHECK);\n@@ -1259,17 +1248,8 @@\n-void InstanceKlass::set_initialization_state_and_notify(ClassState state, JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  if (state == linked && UseVtableBasedCHA && Universe::is_fully_initialized()) {\n-    DeoptimizationScope deopt_scope;\n-    {\n-      \/\/ Now mark all code that assumes the class is not linked.\n-      \/\/ Set state under the Compile_lock also.\n-      MutexLocker ml(current, Compile_lock);\n-\n-      set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n-      set_init_state(state);\n-\n-      CodeCache::mark_dependents_on(&deopt_scope, this);\n-    }\n-    \/\/ Perform the deopt handshake outside Compile_lock.\n-    deopt_scope.deoptimize_marked();\n+void InstanceKlass::set_initialization_state_and_notify(ClassState state, TRAPS) {\n+  Handle h_init_lock(THREAD, init_lock());\n+  if (h_init_lock() != nullptr) {\n+    ObjectLocker ol(h_init_lock, THREAD);\n+    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n+    set_init_state(state);\n+    fence_and_clear_init_lock();\n+    ol.notify_all(CHECK);\n@@ -1277,0 +1257,1 @@\n+    assert(h_init_lock() != nullptr, \"The initialization state should never be set twice\");\n@@ -1280,1 +1261,0 @@\n-  ml.notify_all();\n@@ -1285,1 +1265,1 @@\n-void InstanceKlass::add_to_hierarchy(JavaThread* current) {\n+void InstanceKlass::add_to_hierarchy_impl(JavaThread* current) {\n@@ -1288,8 +1268,0 @@\n-  \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n-  \/\/ deopt is completed before anyone links this class.\n-  \/\/ Linking is done with _init_monitor held, by loading and deopting with it\n-  \/\/ held we make sure the deopt is completed before linking.\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->lock();\n-  }\n-\n@@ -1317,0 +1289,1 @@\n+}\n@@ -1318,2 +1291,14 @@\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->unlock();\n+void InstanceKlass::add_to_hierarchy(JavaThread* current) {\n+\n+  if (UseVtableBasedCHA || !Universe::is_fully_initialized()) {\n+    add_to_hierarchy_impl(current);\n+  } else {\n+    \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n+    \/\/ deopt is completed before anyone links this class.\n+    \/\/ Linking is done with init_lock held, by loading and deopting with it\n+    \/\/ held we make sure the deopt is completed before linking.\n+    Handle h_init_lock(current, init_lock());\n+    ObjectLocker ol(h_init_lock, current);\n+    add_to_hierarchy_impl(current);\n+\n+    \/\/ This doesn't need a notify because the wait is only on the class initialization path.\n@@ -1323,0 +1308,1 @@\n+\n@@ -2589,1 +2575,0 @@\n-  _init_monitor = nullptr;\n@@ -2693,3 +2678,0 @@\n-\n-  \/\/ restore the monitor\n-  _init_monitor = create_init_monitor(\"InstanceKlassInitMonitorRestored_lock\");\n@@ -2791,3 +2773,0 @@\n-  \/\/ Destroy the init_monitor\n-  delete _init_monitor;\n-\n@@ -3485,1 +3464,1 @@\n-  \"allocated\", \"loaded\", \"being_linked\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n+  \"allocated\", \"loaded\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n@@ -4135,3 +4114,0 @@\n-  if (state > loaded) {\n-    assert_lock_strong(_init_monitor);\n-  }\n@@ -4141,2 +4117,1 @@\n-  bool link_failed = _init_state == being_linked && state == loaded;\n-  assert(good_state || state == allocated || link_failed, \"illegal state transition\");\n+  assert(good_state || state == allocated, \"illegal state transition\");\n@@ -4145,1 +4120,1 @@\n-  Atomic::store(&_init_state, state);\n+  _init_state = state;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":92,"deletions":117,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -155,1 +155,0 @@\n-    being_linked,                       \/\/ currently running verifier and rewriter\n@@ -229,0 +228,7 @@\n+  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n+  \/\/ _misc_flags.\n+  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n+\n+  \/\/ Class states are defined as ClassState (see above).\n+  \/\/ Place the _init_state here to utilize the unused 2-byte after\n+  \/\/ _idnum_allocated_count.\n@@ -231,1 +237,1 @@\n-  u1              _reference_type;          \/\/ reference type\n+  u1              _reference_type;                \/\/ reference type\n@@ -236,1 +242,0 @@\n-  Monitor*             _init_monitor;       \/\/ mutual exclusion to _init_state and _init_thread.\n@@ -500,1 +505,0 @@\n-  \/\/ We can safely access the name as long as we hold the _init_monitor.\n@@ -502,1 +506,0 @@\n-    assert(_init_monitor->owned_by_self(), \"Must hold _init_monitor here\");\n@@ -508,9 +511,8 @@\n-  bool is_loaded() const                   { return init_state() >= loaded; }\n-  bool is_linked() const                   { return init_state() >= linked; }\n-  bool is_being_linked() const             { return init_state() == being_linked; }\n-  bool is_initialized() const              { return init_state() == fully_initialized; }\n-  bool is_not_initialized() const          { return init_state() <  being_initialized; }\n-  bool is_being_initialized() const        { return init_state() == being_initialized; }\n-  bool is_in_error_state() const           { return init_state() == initialization_error; }\n-  bool is_init_thread(JavaThread *thread)  { return thread == init_thread(); }\n-  ClassState  init_state() const           { return Atomic::load(&_init_state); }\n+  bool is_loaded() const                   { return _init_state >= loaded; }\n+  bool is_linked() const                   { return _init_state >= linked; }\n+  bool is_initialized() const              { return _init_state == fully_initialized; }\n+  bool is_not_initialized() const          { return _init_state <  being_initialized; }\n+  bool is_being_initialized() const        { return _init_state == being_initialized; }\n+  bool is_in_error_state() const           { return _init_state == initialization_error; }\n+  bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }\n+  ClassState  init_state() const           { return _init_state; }\n@@ -520,15 +522,0 @@\n-  class LockLinkState : public StackObj {\n-    InstanceKlass* _ik;\n-    JavaThread*    _current;\n-   public:\n-    LockLinkState(InstanceKlass* ik, JavaThread* current) : _ik(ik), _current(current) {\n-      ik->check_link_state_and_wait(current);\n-    }\n-    ~LockLinkState() {\n-      if (!_ik->is_linked()) {\n-        \/\/ Reset to loaded if linking failed.\n-        _ik->set_initialization_state_and_notify(loaded, _current);\n-      }\n-    }\n-  };\n-\n@@ -832,1 +819,1 @@\n-  void set_initialization_state_and_notify(ClassState state, JavaThread* current);\n+  void set_initialization_state_and_notify(ClassState state, TRAPS);\n@@ -844,0 +831,4 @@\n+ private:\n+  void add_to_hierarchy_impl(JavaThread* current);\n+\n+ public:\n@@ -1058,1 +1049,1 @@\n- private:\n+private:\n@@ -1075,0 +1066,6 @@\n+  \/\/ Lock for (1) initialization; (2) access to the ConstantPool of this class.\n+  \/\/ Must be one per class and it has to be a VM internal object so java code\n+  \/\/ cannot lock it (like the mirror).\n+  \/\/ It has to be an object not a Mutex because it's held through java calls.\n+  oop init_lock() const;\n+\n@@ -1084,2 +1081,0 @@\n-\n-  Monitor* init_monitor() const { return _init_monitor; }\n@@ -1087,1 +1082,2 @@\n-  void check_link_state_and_wait(JavaThread* current);\n+  void fence_and_clear_init_lock();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":30,"deletions":34,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  assert(length <= max_length(), \"SymbolTable should have caught this!\");\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,0 +133,1 @@\n+  \/\/ Constructor is private for use only by SymbolTable.\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1953,0 +1953,16 @@\n+\/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+bool AbstractLockNode::is_balanced() {\n+  Node* obj = obj_node();\n+  for (uint j = 0; j < obj->outcnt(); j++) {\n+    Node* n = obj->raw_out(j);\n+    if (n->is_AbstractLock() &&\n+        n->as_AbstractLock()->obj_node()->eqv_uncast(obj)) {\n+      BoxLockNode* n_box = n->as_AbstractLock()->box_node()->as_BoxLock();\n+      if (n_box->is_unbalanced()) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2059,0 +2075,2 @@\n+            tty->print(\"Obj: \");\n+            obj_node()->dump();\n@@ -2067,0 +2085,2 @@\n+              tty->print(\"Box %d: \", i);\n+              box_node()->dump();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1157,0 +1157,4 @@\n+  \/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+  \/\/ They can become unbalanced after coarsening optimization or on OSR entry.\n+  bool is_balanced();\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -577,1 +577,5 @@\n-          if (iff->Opcode() == Op_If && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp()) {\n+          \/\/ We may have Opaque4 node between If and Bool nodes.\n+          \/\/ Bail out in such case - we need to preserve Opaque4 for correct\n+          \/\/ processing predicates after loop opts.\n+          bool can_reduce = (iff->Opcode() == Op_If) && iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp();\n+          if (can_reduce) {\n@@ -580,1 +584,3 @@\n-            if ((opc == Op_CmpP || opc == Op_CmpN) && !can_reduce_cmp(n, iff_cmp)) {\n+            can_reduce = (opc == Op_CmpP || opc == Op_CmpN) && can_reduce_cmp(n, iff_cmp);\n+          }\n+          if (!can_reduce) {\n@@ -582,6 +588,3 @@\n-              if (TraceReduceAllocationMerges) {\n-                tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);\n-                n->dump(5);\n-              }\n-#endif\n-              return false;\n+            if (TraceReduceAllocationMerges) {\n+              tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);\n+              n->dump(5);\n@@ -589,0 +592,2 @@\n+#endif\n+            return false;\n@@ -654,1 +659,6 @@\n-    Node* curr_cmp = curr_ctrl->in(0)->in(1)->in(1); \/\/ true\/false -> if -> bool -> cmp\n+    \/\/ can_reduce_check_users() verified graph: true\/false -> if -> bool -> cmp\n+    assert(curr_ctrl->in(0)->Opcode() == Op_If, \"unexpected node %s\", curr_ctrl->in(0)->Name());\n+    Node* bol = curr_ctrl->in(0)->in(1);\n+    assert(bol->is_Bool(), \"unexpected node %s\", bol->Name());\n+    Node* curr_cmp = bol->in(1);\n+    assert(curr_cmp->Opcode() == Op_CmpP || curr_cmp->Opcode() == Op_CmpN, \"unexpected node %s\", curr_cmp->Name());\n@@ -3504,2 +3514,1 @@\n-  BoxLockNode* box = alock->box_node()->as_BoxLock();\n-  if (!box->is_unbalanced() && not_global_escape(alock->obj_node())) {\n+  if (alock->is_balanced() && not_global_escape(alock->obj_node())) {\n@@ -3509,1 +3518,1 @@\n-      box->set_local();\n+      alock->box_node()->as_BoxLock()->set_local();\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -758,0 +758,1 @@\n+    ctrl->outcnt() == 1 && \/\/ No side-effects\n@@ -1331,1 +1332,1 @@\n-    if (is_ctrl_folds(ctrl, igvn) && ctrl->outcnt() == 1) {\n+    if (is_ctrl_folds(ctrl, igvn)) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5466,0 +5466,32 @@\n+\/\/ Common checks for array sorting intrinsics arguments.\n+\/\/ Returns `true` if checks passed.\n+bool LibraryCallKit::check_array_sort_arguments(Node* elementType, Node* obj, BasicType& bt) {\n+  \/\/ check address of the class\n+  if (elementType == nullptr || elementType->is_top()) {\n+    return false;  \/\/ dead path\n+  }\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  if (elem_klass == nullptr) {\n+    return false;  \/\/ dead path\n+  }\n+  \/\/ java_mirror_type() returns non-null for compile-time Class constants only\n+  ciType* elem_type = elem_klass->java_mirror_type();\n+  if (elem_type == nullptr) {\n+    return false;\n+  }\n+  bt = elem_type->basic_type();\n+  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n+  if (!Matcher::supports_simd_sort(bt)) {\n+    return false;\n+  }\n+  \/\/ check address of the array\n+  if (obj == nullptr || obj->is_top()) {\n+    return false;  \/\/ dead path\n+  }\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM) {\n+    return false; \/\/ failed input validation\n+  }\n+  return true;\n+}\n+\n@@ -5468,0 +5500,5 @@\n+  address stubAddr = StubRoutines::select_array_partition_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 9, \"arrayPartition has 8 parameters (one long)\");\n@@ -5469,1 +5506,2 @@\n-  Node* elementType     = null_check(argument(0));\n+  \/\/ no receiver because it is a static method\n+  Node* elementType     = argument(0);\n@@ -5471,1 +5509,1 @@\n-  Node* offset          = argument(2);\n+  Node* offset          = argument(2); \/\/ long\n@@ -5476,0 +5514,1 @@\n+  \/\/ PartitionOperation:  argument(8) is ignored\n@@ -5478,0 +5517,1 @@\n+  BasicType bt = T_ILLEGAL;\n@@ -5479,0 +5519,8 @@\n+  if (!check_array_sort_arguments(elementType, obj, bt)) {\n+    return false;\n+  }\n+  null_check(obj);\n+  \/\/ If obj is dead, only null-path is taken.\n+  if (stopped()) {\n+    return true;\n+  }\n@@ -5484,18 +5532,0 @@\n-    const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-    ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-    BasicType bt = elem_type->basic_type();\n-    \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n-    if (!Matcher::supports_simd_sort(bt)) {\n-      return false;\n-    }\n-    address stubAddr = nullptr;\n-    stubAddr = StubRoutines::select_array_partition_function();\n-    \/\/ stub not loaded\n-    if (stubAddr == nullptr) {\n-      return false;\n-    }\n-    \/\/ get the address of the array\n-    const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-    if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-      return false; \/\/ failed input validation\n-    }\n@@ -5534,0 +5564,5 @@\n+  address stubAddr = StubRoutines::select_arraysort_function();\n+  if (stubAddr == nullptr) {\n+    return false; \/\/ Intrinsic's stub is not implemented on this platform\n+  }\n+  assert(callee()->signature()->size() == 7, \"arraySort has 6 parameters (one long)\");\n@@ -5535,1 +5570,2 @@\n-  Node* elementType     = null_check(argument(0));\n+  \/\/ no receiver because it is a static method\n+  Node* elementType     = argument(0);\n@@ -5537,1 +5573,1 @@\n-  Node* offset          = argument(2);\n+  Node* offset          = argument(2); \/\/ long\n@@ -5540,0 +5576,1 @@\n+  \/\/ SortOperation:       argument(6) is ignored\n@@ -5541,11 +5578,3 @@\n-  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType bt = elem_type->basic_type();\n-  \/\/ Disable the intrinsic if the CPU does not support SIMD sort\n-  if (!Matcher::supports_simd_sort(bt)) {\n-    return false;\n-  }\n-  address stubAddr = nullptr;\n-  stubAddr = StubRoutines::select_arraysort_function();\n-  \/\/stub not loaded\n-  if (stubAddr == nullptr) {\n+  BasicType bt = T_ILLEGAL;\n+\n+  if (!check_array_sort_arguments(elementType, obj, bt)) {\n@@ -5554,5 +5583,4 @@\n-\n-  \/\/ get address of the array\n-  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n-  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n-    return false; \/\/ failed input validation\n+  null_check(obj);\n+  \/\/ If obj is dead, only null-path is taken.\n+  if (stopped()) {\n+    return true;\n@@ -7557,2 +7585,0 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":66,"deletions":40,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -282,0 +282,1 @@\n+  bool check_array_sort_arguments(Node* elementType, Node* obj, BasicType& bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n@@ -127,1 +127,3 @@\n-  virtual void dump_spec(outputStream *st) const { st->print(\"  Lock %d\",_slot); }\n+  virtual void dump_spec(outputStream *st) const {\n+    st->print(\"  Lock slot: %d, Kind: %s\", _slot, _kind_name[(int)_kind]);\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -798,3 +798,11 @@\n-  \/\/ Ignore cost if CMOVE can be moved outside the loop.\n-  if (used_inside_loop && cost >= ConditionalMoveLimit) {\n-    return nullptr;\n+  float infrequent_prob = PROB_UNLIKELY_MAG(3);\n+  \/\/ Ignore cost and blocks frequency if CMOVE can be moved outside the loop.\n+  if (used_inside_loop) {\n+    if (cost >= ConditionalMoveLimit) return nullptr; \/\/ Too much goo\n+\n+    \/\/ BlockLayoutByFrequency optimization moves infrequent branch\n+    \/\/ from hot path. No point in CMOV'ing in such case (110 is used\n+    \/\/ instead of 100 to take into account not exactness of float value).\n+    if (BlockLayoutByFrequency) {\n+      infrequent_prob = MAX2(infrequent_prob, (float)BlockLayoutMinDiamondPercentage\/110.0f);\n+    }\n@@ -804,1 +812,0 @@\n-  constexpr float infrequent_prob = PROB_UNLIKELY_MAG(2);\n@@ -807,1 +814,2 @@\n-  } else if (iff->_prob < infrequent_prob || iff->_prob > (1.0f - infrequent_prob)) {\n+  } else if (iff->_prob < infrequent_prob ||\n+      iff->_prob > (1.0f - infrequent_prob))\n@@ -809,1 +817,0 @@\n-  }\n@@ -2990,6 +2997,7 @@\n-\/\/------------------------------ insert_cmpi_loop_exit -------------------------------------\n-\/\/ Clone a signed compare loop exit from an unsigned compare and\n-\/\/ insert it before the unsigned cmp on the stay-in-loop path.\n-\/\/ All new nodes inserted in the dominator tree between the original\n-\/\/ if and it's projections.  The original if test is replaced with\n-\/\/ a constant to force the stay-in-loop path.\n+\/\/ Idea\n+\/\/ ----\n+\/\/ Partial Peeling tries to rotate the loop in such a way that it can later be turned into a counted loop. Counted loops\n+\/\/ require a signed loop exit test. When calling this method, we've only found a suitable unsigned test to partial peel\n+\/\/ with. Therefore, we try to split off a signed loop exit test from the unsigned test such that it can be used as new\n+\/\/ loop exit while keeping the unsigned test unchanged and preserving the same behavior as if we've used the unsigned\n+\/\/ test alone instead:\n@@ -2997,4 +3005,8 @@\n-\/\/ This is done to make sure that the original if and it's projections\n-\/\/ still dominate the same set of control nodes, that the ctrl() relation\n-\/\/ from data nodes to them is preserved, and that their loop nesting is\n-\/\/ preserved.\n+\/\/ Before Partial Peeling:\n+\/\/   Loop:\n+\/\/     <peeled section>\n+\/\/     Split off signed loop exit test\n+\/\/     <-- CUT HERE -->\n+\/\/     Unchanged unsigned loop exit test\n+\/\/     <rest of unpeeled section>\n+\/\/     goto Loop\n@@ -3002,2 +3014,14 @@\n-\/\/ before\n-\/\/          if(i <u limit)    unsigned compare loop exit\n+\/\/ After Partial Peeling:\n+\/\/   <cloned peeled section>\n+\/\/   Cloned split off signed loop exit test\n+\/\/   Loop:\n+\/\/     Unchanged unsigned loop exit test\n+\/\/     <rest of unpeeled section>\n+\/\/     <peeled section>\n+\/\/     Split off signed loop exit test\n+\/\/     goto Loop\n+\/\/\n+\/\/ Details\n+\/\/ -------\n+\/\/ Before:\n+\/\/          if (i <u limit)    Unsigned loop exit condition\n@@ -3008,5 +3032,6 @@\n-\/\/ after\n-\/\/          if(stay-in-loop-const)  original if\n-\/\/         \/       |\n-\/\/        \/        v\n-\/\/       \/  if(i <  limit)    new signed test\n+\/\/ Split off a signed loop exit test (i.e. with CmpI) from an unsigned loop exit test (i.e. with CmpU) and insert it\n+\/\/ before the CmpU on the stay-in-loop path and keep both tests:\n+\/\/\n+\/\/          if (i <u limit)    Signed loop exit test\n+\/\/        \/        |\n+\/\/       \/  if (i <u limit)    Unsigned loop exit test\n@@ -3014,10 +3039,28 @@\n-\/\/     \/  \/        v\n-\/\/    \/  \/  if(i <u limit)    new cloned unsigned test\n-\/\/   \/  \/   \/      |\n-\/\/   v  v  v       |\n-\/\/    region       |\n-\/\/        |        |\n-\/\/      dum-if     |\n-\/\/     \/  |        |\n-\/\/ ether  |        |\n-\/\/        v        v\n+\/\/     v  v        v\n+\/\/  exit-region  stay-in-loop-proj\n+\/\/\n+\/\/ Implementation\n+\/\/ --------------\n+\/\/ We need to make sure that the new signed loop exit test is properly inserted into the graph such that the unsigned\n+\/\/ loop exit test still dominates the same set of control nodes, the ctrl() relation from data nodes to both loop\n+\/\/ exit tests is preserved, and their loop nesting is correct.\n+\/\/\n+\/\/ To achieve that, we clone the unsigned loop exit test completely (leave it unchanged), insert the signed loop exit\n+\/\/ test above it and kill the original unsigned loop exit test by setting it's condition to a constant\n+\/\/ (i.e. stay-in-loop-const in graph below) such that IGVN can fold it later:\n+\/\/\n+\/\/           if (stay-in-loop-const)  Killed original unsigned loop exit test\n+\/\/          \/       |\n+\/\/         \/        v\n+\/\/        \/  if (i <  limit)          Split off signed loop exit test\n+\/\/       \/  \/       |\n+\/\/      \/  \/        v\n+\/\/     \/  \/  if (i <u limit)          Cloned unsigned loop exit test\n+\/\/    \/  \/   \/      |\n+\/\/   v  v  v        |\n+\/\/  exit-region     |\n+\/\/        |         |\n+\/\/    dummy-if      |\n+\/\/     \/  |         |\n+\/\/ dead   |         |\n+\/\/        v         v\n@@ -3026,1 +3069,9 @@\n-IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree *loop) {\n+\/\/ Note: The dummy-if is inserted to create a region to merge the loop exits between the original to be killed unsigned\n+\/\/       loop exit test and its exit projection while keeping the exit projection (also see insert_region_before_proj()).\n+\/\/\n+\/\/ Requirements\n+\/\/ ------------\n+\/\/ Note that we can only split off a signed loop exit test from the unsigned loop exit test when the behavior is exactly\n+\/\/ the same as before with only a single unsigned test. This is only possible if certain requirements are met.\n+\/\/ Otherwise, we need to bail out (see comments in the code below).\n+IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree* loop) {\n@@ -3031,1 +3082,3 @@\n-  if (bol->_test._test != BoolTest::lt) return nullptr;\n+  if (bol->_test._test != BoolTest::lt) {\n+    return nullptr;\n+  }\n@@ -3033,1 +3086,2 @@\n-  if (cmpu->Opcode() != Op_CmpU) return nullptr;\n+  assert(cmpu->Opcode() == Op_CmpU, \"must be unsigned comparison\");\n+\n@@ -3035,1 +3089,3 @@\n-  if (stride == 0) return nullptr;\n+  if (stride == 0) {\n+    return nullptr;\n+  }\n@@ -3047,3 +3103,82 @@\n-  \/\/ The loop exit condition is !(i <u limit) ==> (i < 0 || i >= limit).\n-  \/\/ Split out the exit condition (i < 0) for stride < 0 or (i >= limit) for stride > 0.\n-  Node* limit = nullptr;\n+  \/\/ The unsigned loop exit condition is\n+  \/\/   !(i <u  limit)\n+  \/\/ =   i >=u limit\n+  \/\/\n+  \/\/ First, we note that for any x for which\n+  \/\/   0 <= x <= INT_MAX\n+  \/\/ we can convert x to an unsigned int and still get the same guarantee:\n+  \/\/   0 <=  (uint) x <=  INT_MAX = (uint) INT_MAX\n+  \/\/   0 <=u (uint) x <=u INT_MAX = (uint) INT_MAX   (LEMMA)\n+  \/\/\n+  \/\/ With that in mind, if\n+  \/\/   limit >= 0             (COND)\n+  \/\/ then the unsigned loop exit condition\n+  \/\/   i >=u limit            (ULE)\n+  \/\/ is equivalent to\n+  \/\/   i < 0 || i >= limit    (SLE-full)\n+  \/\/ because either i is negative and therefore always greater than MAX_INT when converting to unsigned\n+  \/\/   (uint) i >=u MAX_INT >= limit >= 0\n+  \/\/ or otherwise\n+  \/\/   i >= limit >= 0\n+  \/\/ holds due to (LEMMA).\n+  \/\/\n+  \/\/ For completeness, a counterexample with limit < 0:\n+  \/\/ Assume i = -3 and limit = -2:\n+  \/\/   i  < 0\n+  \/\/   -2 < 0\n+  \/\/ is true and thus also \"i < 0 || i >= limit\". But\n+  \/\/   i  >=u limit\n+  \/\/   -3 >=u -2\n+  \/\/ is false.\n+  Node* limit = cmpu->in(2);\n+  const TypeInt* type_limit = _igvn.type(limit)->is_int();\n+  if (type_limit->_lo < 0) {\n+    return nullptr;\n+  }\n+\n+  \/\/ We prove below that we can extract a single signed loop exit condition from (SLE-full), depending on the stride:\n+  \/\/   stride < 0:\n+  \/\/     i < 0        (SLE = SLE-negative)\n+  \/\/   stride > 0:\n+  \/\/     i >= limit   (SLE = SLE-positive)\n+  \/\/ such that we have the following graph before Partial Peeling with stride > 0 (similar for stride < 0):\n+  \/\/\n+  \/\/ Loop:\n+  \/\/   <peeled section>\n+  \/\/   i >= limit    (SLE-positive)\n+  \/\/   <-- CUT HERE -->\n+  \/\/   i >=u limit   (ULE)\n+  \/\/   <rest of unpeeled section>\n+  \/\/   goto Loop\n+  \/\/\n+  \/\/ We exit the loop if:\n+  \/\/   (SLE) is true OR (ULE) is true\n+  \/\/ However, if (SLE) is true then (ULE) also needs to be true to ensure the exact same behavior. Otherwise, we wrongly\n+  \/\/ exit a loop that should not have been exited if we did not apply Partial Peeling. More formally, we need to ensure:\n+  \/\/   (SLE) IMPLIES (ULE)\n+  \/\/ This indeed holds when (COND) is given:\n+  \/\/ - stride > 0:\n+  \/\/       i >=  limit             \/\/ (SLE = SLE-positive)\n+  \/\/       i >=  limit >= 0        \/\/ (COND)\n+  \/\/       i >=u limit >= 0        \/\/ (LEMMA)\n+  \/\/     which is the unsigned loop exit condition (ULE).\n+  \/\/ - stride < 0:\n+  \/\/       i        <  0           \/\/ (SLE = SLE-negative)\n+  \/\/       (uint) i >u MAX_INT     \/\/ (NEG) all negative values are greater than MAX_INT when converted to unsigned\n+  \/\/       MAX_INT >= limit >= 0   \/\/ (COND)\n+  \/\/       MAX_INT >=u limit >= 0  \/\/ (LEMMA)\n+  \/\/     and thus from (NEG) and (LEMMA):\n+  \/\/       i >=u limit\n+  \/\/     which is the unsigned loop exit condition (ULE).\n+  \/\/\n+  \/\/\n+  \/\/ After Partial Peeling, we have the following structure for stride > 0 (similar for stride < 0):\n+  \/\/   <cloned peeled section>\n+  \/\/   i >= limit (SLE-positive)\n+  \/\/   Loop:\n+  \/\/     i >=u limit (ULE)\n+  \/\/     <rest of unpeeled section>\n+  \/\/     <peeled section>\n+  \/\/     i >= limit (SLE-positive)\n+  \/\/     goto Loop\n+  Node* rhs_cmpi;\n@@ -3051,1 +3186,1 @@\n-    limit = cmpu->in(2);\n+    rhs_cmpi = limit; \/\/ For i >= limit\n@@ -3053,2 +3188,2 @@\n-    limit = _igvn.makecon(TypeInt::ZERO);\n-    set_ctrl(limit, C->root());\n+    rhs_cmpi = _igvn.makecon(TypeInt::ZERO); \/\/ For i < 0\n+    set_ctrl(rhs_cmpi, C->root());\n@@ -3062,1 +3197,1 @@\n-  ProjNode* cmpi_exit = insert_if_before_proj(cmpu->in(1), Signed, rel_i, limit, lp_continue);\n+  ProjNode* cmpi_exit = insert_if_before_proj(cmpu->in(1), Signed, rel_i, rhs_cmpi, lp_continue);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":179,"deletions":44,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -873,0 +873,4 @@\n+  Node* scalarized_obj(const JVMState* jvms, uint idx) const {\n+    assert(verify_jvms(jvms), \"jvms must match\");\n+    return in(_jvmadj + jvms->scloff() + idx);\n+  }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2048,1 +2048,1 @@\n-  if (alock->box_node()->as_BoxLock()->is_unbalanced()) {\n+  if (!alock->is_balanced()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2987,0 +2987,3 @@\n+  if (_store->is_unsafe_access()) {\n+    return nullptr;\n+  }\n@@ -3020,0 +3023,1 @@\n+  assert(!_store->is_unsafe_access(), \"no unsafe accesses\");\n@@ -3024,1 +3028,2 @@\n-      other_store->adr_type()->isa_aryptr() == nullptr) {\n+      other_store->adr_type()->isa_aryptr() == nullptr ||\n+      other_store->is_unsafe_access()) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -977,0 +977,21 @@\n+\/\/ Determine if there is a scalar replaced object description represented by 'ov'.\n+bool PhaseOutput::contains_as_scalarized_obj(JVMState* jvms, MachSafePointNode* sfn,\n+                                             GrowableArray<ScopeValue*>* objs,\n+                                             ObjectValue* ov) const {\n+  for (int i = 0; i < jvms->scl_size(); i++) {\n+    Node* n = sfn->scalarized_obj(jvms, i);\n+    \/\/ Other kinds of nodes that we may encounter here, for instance constants\n+    \/\/ representing values of fields of objects scalarized, aren't relevant for\n+    \/\/ us, since they don't map to ObjectValue.\n+    if (!n->is_SafePointScalarObject()) {\n+      continue;\n+    }\n+\n+    ObjectValue* other = (ObjectValue*) sv_for_node_id(objs, n->_idx);\n+    if (ov == other) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1140,1 +1161,4 @@\n-          bool is_root = locarray->contains(ov) || exparray->contains(ov) || contains_as_owner(monarray, ov);\n+          bool is_root = locarray->contains(ov) ||\n+                         exparray->contains(ov) ||\n+                         contains_as_owner(monarray, ov) ||\n+                         contains_as_scalarized_obj(jvms, sfn, objs, ov);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -212,0 +212,3 @@\n+  bool contains_as_scalarized_obj(JVMState* jvms, MachSafePointNode* sfn,\n+                                  GrowableArray<ScopeValue*>* objs,\n+                                  ObjectValue* ov) const;\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1417,2 +1417,2 @@\n-  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ carry bits in output\n-  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n@@ -1437,1 +1437,1 @@\n-  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  fields[TypeFunc::Parms + 0] = nullptr; \/\/ void\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3720,1 +3720,23 @@\n-  \/\/ 4: Compute (3a, b):\n+  \/\/ 4: The computation of the new pre-loop limit could overflow (for 3a) or\n+  \/\/    underflow (for 3b) the int range. This is problematic in combination\n+  \/\/    with Range Check Elimination (RCE), which determines a \"safe\" range\n+  \/\/    where a RangeCheck will always succeed. RCE adjusts the pre-loop limit\n+  \/\/    such that we only enter the main-loop once we have reached the \"safe\"\n+  \/\/    range, and adjusts the main-loop limit so that we exit the main-loop\n+  \/\/    before we leave the \"safe\" range. After RCE, the range of the main-loop\n+  \/\/    can only be safely narrowed, and should never be widened. Hence, the\n+  \/\/    pre-loop limit can only be increased (for stride > 0), but an add\n+  \/\/    overflow might decrease it, or decreased (for stride < 0), but a sub\n+  \/\/    underflow might increase it. To prevent that, we perform the Sub \/ Add\n+  \/\/    and Max \/ Min with long operations.\n+  old_limit       = new ConvI2LNode(old_limit);\n+  orig_limit      = new ConvI2LNode(orig_limit);\n+  adjust_pre_iter = new ConvI2LNode(adjust_pre_iter);\n+  phase()->register_new_node(old_limit, pre_ctrl);\n+  phase()->register_new_node(orig_limit, pre_ctrl);\n+  phase()->register_new_node(adjust_pre_iter, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(old_limit);\n+  TRACE_ALIGN_VECTOR_NODE(orig_limit);\n+  TRACE_ALIGN_VECTOR_NODE(adjust_pre_iter);\n+\n+  \/\/ 5: Compute (3a, b):\n@@ -3723,0 +3745,1 @@\n+  \/\/\n@@ -3725,1 +3748,1 @@\n-    new_limit = new SubINode(old_limit, adjust_pre_iter);\n+    new_limit = new SubLNode(old_limit, adjust_pre_iter);\n@@ -3727,1 +3750,1 @@\n-    new_limit = new AddINode(old_limit, adjust_pre_iter);\n+    new_limit = new AddLNode(old_limit, adjust_pre_iter);\n@@ -3732,1 +3755,1 @@\n-  \/\/ 5: Compute (15a, b):\n+  \/\/ 6: Compute (15a, b):\n@@ -3735,2 +3758,7 @@\n-    (stride > 0) ? (Node*) new MinINode(new_limit, orig_limit)\n-                 : (Node*) new MaxINode(new_limit, orig_limit);\n+    (stride > 0) ? (Node*) new MinLNode(phase()->C, new_limit, orig_limit)\n+                 : (Node*) new MaxLNode(phase()->C, new_limit, orig_limit);\n+  phase()->register_new_node(constrained_limit, pre_ctrl);\n+  TRACE_ALIGN_VECTOR_NODE(constrained_limit);\n+\n+  \/\/ 7: We know that the result is in the int range, there is never truncation\n+  constrained_limit = new ConvL2INode(constrained_limit);\n@@ -3740,1 +3768,1 @@\n-  \/\/ 6: Hack the pre-loop limit\n+  \/\/ 8: Hack the pre-loop limit\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":35,"deletions":7,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/crac.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3912,0 +3913,5 @@\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2342,1 +2342,1 @@\n-  ClassLoaderDataGraph::modules_do(&do_module);\n+  ClassLoaderDataGraph::modules_do_keepalive(&do_module);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    ClassLoaderDataGraph::loaded_classes_do(&closure);\n+    ClassLoaderDataGraph::loaded_classes_do_keepalive(&closure);\n","filename":"src\/hotspot\/share\/prims\/jvmtiGetLoadedClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1177,1 +1177,1 @@\n-      JFR_ONLY(k_new_method->copy_trace_flags(*k_old_method->trace_flags_addr());)\n+      JFR_ONLY(k_new_method->copy_trace_flags(k_old_method->trace_flags());)\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -307,2 +307,1 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n-  uint64_t features = _features;\n+void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features) {\n@@ -313,4 +312,10 @@\n-      int res = jio_snprintf(buf, buflen, \", %s\", features_names[features_names_index]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+      \/\/ Do not use any libc string functions. Our caller VM_Version::fatal_missing_features may have GNU_IFUNC-misconfigured glibc.\n+      if (buflen-- > 0)\n+        *buf++ = ',';\n+      if (buflen-- > 0)\n+        *buf++ = ' ';\n+      for (const char *src = features_names[features_names_index]; *src; ++src)\n+      if (buflen-- > 0)\n+        *buf++ = *src;\n+      assert(buflen > 0, \"not enough temporary space allocated\");\n+      *buf = 0;\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  static void insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features = _features);\n@@ -130,1 +131,0 @@\n-  static void insert_features_names(char* buf, size_t buflen, const char* features_names[]);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -52,0 +53,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1101,0 +1103,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == NULL) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1110,4 +1125,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1115,6 +1127,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == nullptr) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1251,1 +1259,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1253,2 +1263,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1258,1 +1266,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1266,1 +1275,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1268,1 +1277,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1270,0 +1279,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2158,0 +2174,65 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = NULL;\n+      const char* value = NULL;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.command\") == 0) {\n+        char *old_java_command = _java_command;\n+        _java_command = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != NULL) {\n+          os::free(old_java_command);\n+        }\n+      } else {\n+        add_property(tail);\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n+      \/\/ already been handled\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != NULL) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n+          return false;\n+        }\n+        build_jvm_flags(tail);\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2912,0 +2993,7 @@\n+  if (CRaCCheckpointTo && UseZGC) {\n+    \/\/ jdk.crac.impl.CheckpointOpenFileException: FD fd=3 type=regular path=\/memfd:java_heap (deleted)\n+    jio_fprintf(defaultStream::output_stream(),\n+      \"-XX:+UseZGC is currently unsupported for -XX:CRaCCheckpointTo.\\n\");\n+    return JNI_ERR;\n+  }\n+\n@@ -2969,0 +3057,4 @@\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":108,"deletions":16,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -281,0 +281,4 @@\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n+\n@@ -511,0 +515,4 @@\n+  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,634 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"classfile\/classLoader.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/heapDumper.hpp\"\n+#include \"services\/writeableFlags.hpp\"\n+#include \"utilities\/decoder.hpp\"\n+#include \"os.inline.hpp\"\n+\n+static const char* _crengine = NULL;\n+static char* _crengine_arg_str = NULL;\n+static unsigned int _crengine_argc = 0;\n+static const char* _crengine_args[32];\n+static jlong _restore_start_time;\n+static jlong _restore_start_nanos;\n+\n+\/\/ Timestamps recorded before checkpoint\n+jlong crac::checkpoint_millis;\n+jlong crac::checkpoint_nanos;\n+char crac::checkpoint_bootid[UUID_LENGTH];\n+\/\/ Value based on wall clock time difference that will guarantee monotonic\n+\/\/ System.nanoTime() close to actual wall-clock time difference.\n+jlong crac::javaTimeNanos_offset = 0;\n+\n+jlong crac::restore_start_time() {\n+  if (!_restore_start_time) {\n+    return -1;\n+  }\n+  return _restore_start_time;\n+}\n+\n+jlong crac::uptime_since_restore() {\n+  if (!_restore_start_nanos) {\n+    return -1;\n+  }\n+  return os::javaTimeNanos() - _restore_start_nanos;\n+}\n+\n+void VM_Crac::trace_cr(const char* msg, ...) {\n+  if (CRTrace) {\n+    va_list ap;\n+    va_start(ap, msg);\n+    _ostream->print(\"CR: \");\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    _ostream->vprint_cr(msg, ap);\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+    va_end(ap);\n+  }\n+}\n+\n+void VM_Crac::print_resources(const char* msg, ...) {\n+  if (CRPrintResourcesOnCheckpoint) {\n+    va_list ap;\n+    va_start(ap, msg);\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    _ostream->vprint(msg, ap);\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+    va_end(ap);\n+  }\n+}\n+\n+#if defined(__APPLE__) || defined(_WINDOWS)\n+static char * strchrnul(char * str, char c) {\n+  for (; *str && c != *str; ++str) {}\n+  return str;\n+}\n+#endif \/\/__APPLE__ || _WINDOWS\n+\n+static size_t cr_util_path(char* path, int len) {\n+  os::jvm_path(path, len);\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n+  assert(1 == strlen(os::file_separator()), \"file separator must be a single-char, not a string\");\n+  char *after_elem = NULL;\n+  for (int i = 0; i < 2; ++i) {\n+    after_elem = strrchr(path, *os::file_separator());\n+    *after_elem = '\\0';\n+  }\n+  return after_elem - path;\n+}\n+\n+static bool compute_crengine() {\n+  \/\/ release possible old copies\n+  os::free((char *) _crengine); \/\/ NULL is allowed\n+  _crengine = NULL;\n+  os::free((char *) _crengine_arg_str);\n+  _crengine_arg_str = NULL;\n+\n+  if (!CREngine) {\n+    return true;\n+  }\n+  char *exec = os::strdup_check_oom(CREngine);\n+  char *comma = strchr(exec, ',');\n+  if (comma != NULL) {\n+    *comma = '\\0';\n+    _crengine_arg_str = os::strdup_check_oom(comma + 1);\n+  }\n+  if (os::is_path_absolute(exec)) {\n+    _crengine = exec;\n+  } else {\n+    char path[JVM_MAXPATHLEN];\n+    size_t pathlen = cr_util_path(path, sizeof(path));\n+    strcat(path + pathlen, os::file_separator());\n+    strcat(path + pathlen, exec);\n+\n+    struct stat st;\n+    if (0 != os::stat(path, &st)) {\n+      warning(\"Could not find %s: %s\", path, os::strerror(errno));\n+      return false;\n+    }\n+    _crengine = os::strdup_check_oom(path);\n+    \/\/ we have read and duplicated args from exec, now we can release\n+    os::free(exec);\n+  }\n+  _crengine_args[0] = _crengine;\n+  _crengine_argc = 2;\n+\n+  if (_crengine_arg_str != NULL) {\n+    char *arg = _crengine_arg_str;\n+    char *target = _crengine_arg_str;\n+    bool escaped = false;\n+    for (char *c = arg; *c != '\\0'; ++c) {\n+      if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 2) {\n+        warning(\"Too many options to CREngine; cannot proceed with these: %s\", arg);\n+        return false;\n+      }\n+      if (!escaped) {\n+        switch(*c) {\n+        case '\\\\':\n+          escaped = true;\n+          continue; \/\/ for\n+        case ',':\n+          *target++ = '\\0';\n+          _crengine_args[_crengine_argc++] = arg;\n+          arg = target;\n+          continue; \/\/ for\n+        }\n+      }\n+      escaped = false;\n+      *target++ = *c;\n+    }\n+    *target = '\\0';\n+    _crengine_args[_crengine_argc++] = arg;\n+    _crengine_args[_crengine_argc] = NULL;\n+  }\n+  return true;\n+}\n+\n+static void add_crengine_arg(const char *arg) {\n+  if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 1) {\n+      warning(\"Too many options to CREngine; cannot add %s\", arg);\n+      return;\n+  }\n+  _crengine_args[_crengine_argc++] = arg;\n+  _crengine_args[_crengine_argc] = NULL;\n+}\n+\n+static int call_crengine() {\n+  if (!_crengine) {\n+    return -1;\n+  }\n+  _crengine_args[1] = \"checkpoint\";\n+  add_crengine_arg(CRaCCheckpointTo);\n+  return os::exec_child_process_and_wait(_crengine, _crengine_args);\n+}\n+\n+static int checkpoint_restore(int *shmid) {\n+  crac::record_time_before_checkpoint();\n+\n+  int cres = call_crengine();\n+  if (cres < 0) {\n+    tty->print_cr(\"CRaC error executing: %s\\n\", _crengine);\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+#ifdef LINUX\n+  sigset_t waitmask;\n+  sigemptyset(&waitmask);\n+  sigaddset(&waitmask, RESTORE_SIGNAL);\n+\n+  siginfo_t info;\n+  int sig;\n+  do {\n+    sig = sigwaitinfo(&waitmask, &info);\n+  } while (sig == -1 && errno == EINTR);\n+  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n+\n+  if (CRaCCPUCountInit) {\n+    os::Linux::initialize_cpu_count();\n+  }\n+#else\n+  \/\/ TODO add sync processing\n+#endif \/\/LINUX\n+\n+  crac::update_javaTimeNanos_offset();\n+\n+  if (CRTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n+  }\n+\n+#ifdef LINUX\n+  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n+    tty->print(\"JVM: invalid info for restore provided: %s\", info.si_code == SI_QUEUE ? \"queued\" : \"not queued\");\n+    if (info.si_code == SI_QUEUE) {\n+      tty->print(\" code %d\", info.si_int);\n+    }\n+    tty->cr();\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  if (0 < info.si_int) {\n+    *shmid = info.si_int;\n+  }\n+#else\n+  *shmid = 0;\n+#endif \/\/LINUX\n+  return JVM_CHECKPOINT_OK;\n+}\n+\n+bool VM_Crac::read_shm(int shmid) {\n+  CracSHM shm(shmid);\n+  int shmfd = shm.open(O_RDONLY);\n+  shm.unlink();\n+  if (shmfd < 0) {\n+    return false;\n+  }\n+  bool ret = _restore_parameters.read_from(shmfd);\n+  close(shmfd);\n+  return ret;\n+}\n+\n+bool VM_Crac::is_claimed_fd(int fd) {\n+  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n+  for (int j = 0; j < claimed_fds->length(); ++j) {\n+    jint cfd = claimed_fds->int_at(j);\n+    if (fd == cfd) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+class WakeupClosure: public ThreadClosure {\n+  void do_thread(Thread* thread) {\n+    JavaThread *jt = JavaThread::cast(thread);\n+    jt->wakeup_sleep();\n+    jt->parker()->unpark();\n+    jt->_ParkEvent->unpark();\n+  }\n+};\n+\n+\/\/ It requires Threads_lock to be held so it is being run as a part of VM_Operation.\n+static void wakeup_threads_in_timedwait_vm() {\n+  WakeupClosure wc;\n+  Threads::java_threads_do(&wc);\n+}\n+\n+\/\/ Run it after VM_Operation as it holds Threads_lock which would cause:\n+\/\/ Attempting to acquire lock PeriodicTask_lock\/safepoint out of order with lock Threads_lock\/safepoint-1 -- possible deadlock\n+static void wakeup_threads_in_timedwait() {\n+  MonitorLocker ml(PeriodicTask_lock, Mutex::_safepoint_check_flag);\n+  WatcherThread::watcher_thread()->unpark();\n+}\n+\n+void VM_Crac::doit() {\n+  \/\/ dry-run fails checkpoint\n+  bool ok = true;\n+\n+  Decoder::before_checkpoint();\n+  if (!check_fds()) {\n+    ok = false;\n+  }\n+\n+  if ((!ok || _dry_run) && CRHeapDumpOnCheckpointException) {\n+    HeapDumper::dump_heap();\n+  }\n+\n+  if (!ok && CRPauseOnCheckpointError) {\n+    os::message_box(\"Checkpoint failed\", \"Errors were found during checkpoint.\");\n+  }\n+\n+  if (!ok && CRDoThrowCheckpointException) {\n+    return;\n+  } else if (_dry_run) {\n+    _ok = ok;\n+    return;\n+  }\n+\n+  if (!memory_checkpoint()) {\n+    return;\n+  }\n+\n+  int shmid = 0;\n+  if (CRAllowToSkipCheckpoint) {\n+    trace_cr(\"Skip Checkpoint\");\n+  } else {\n+    trace_cr(\"Checkpoint ...\");\n+    report_ok_to_jcmd_if_any();\n+    int ret = checkpoint_restore(&shmid);\n+    if (ret == JVM_CHECKPOINT_ERROR) {\n+      memory_restore();\n+      return;\n+    }\n+  }\n+\n+  \/\/ It needs to check CPU features before any other code (such as VM_Crac::read_shm) depends on them.\n+  VM_Version::crac_restore();\n+\n+  if (shmid <= 0 || !VM_Crac::read_shm(shmid)) {\n+    _restore_start_time = os::javaTimeMillis();\n+    _restore_start_nanos = os::javaTimeNanos();\n+  } else {\n+    _restore_start_nanos += crac::monotonic_time_offset();\n+  }\n+\n+  if (CRaCResetStartTime) {\n+    crac::initialize_time_counters();\n+  }\n+\n+  \/\/ VM_Crac::read_shm needs to be already called to read RESTORE_SETTABLE parameters.\n+  VM_Version::crac_restore_finalize();\n+\n+  memory_restore();\n+\n+  wakeup_threads_in_timedwait_vm();\n+\n+  _ok = true;\n+}\n+\n+bool crac::prepare_checkpoint() {\n+  struct stat st;\n+\n+  if (0 == os::stat(CRaCCheckpointTo, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      warning(\"%s: not a directory\", CRaCCheckpointTo);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == os::mkdir(CRaCCheckpointTo)) {\n+      warning(\"cannot create %s: %s\", CRaCCheckpointTo, os::strerror(errno));\n+      return false;\n+    }\n+    if (-1 == os::rmdir(CRaCCheckpointTo)) {\n+      warning(\"cannot cleanup after check: %s\", os::strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+\n+  if (!compute_crengine()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n+  objArrayHandle bundle(THREAD, bundleObj);\n+  jvalue jval;\n+  jval.i = ret;\n+  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n+  bundle->obj_at_put(0, retObj);\n+  bundle->obj_at_put(1, new_args());\n+  bundle->obj_at_put(2, new_props());\n+  bundle->obj_at_put(3, err_codes());\n+  bundle->obj_at_put(4, err_msgs());\n+  return bundle;\n+}\n+\n+\/** Checkpoint main entry.\n+ *\/\n+Handle crac::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n+  if (!CRaCCheckpointTo) {\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+  if (-1 == os::mkdir(CRaCCheckpointTo) && errno != EEXIST) {\n+    warning(\"cannot create %s: %s\", CRaCCheckpointTo, os::strerror(errno));\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+  Universe::heap()->set_cleanup_unused(true);\n+  Universe::heap()->collect(GCCause::_full_gc_alot);\n+  Universe::heap()->set_cleanup_unused(false);\n+  Universe::heap()->finish_collection();\n+\n+  if (os::can_trim_native_heap()) {\n+    os::size_change_t sc;\n+    if (os::trim_native_heap(&sc)) {\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n+        log_info(crac)(\"Trim native heap before checkpoint: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \")\",\n+                        PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta));\n+      }\n+    }\n+  }\n+\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer) {\n+    aio_writer->stop();\n+  }\n+  LogConfiguration::close();\n+\n+  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    VMThread::execute(&cr);\n+  }\n+\n+  LogConfiguration::reopen();\n+  if (aio_writer) {\n+    aio_writer->resume();\n+  }\n+\n+  if (cr.ok()) {\n+    oop new_args = NULL;\n+    if (cr.new_args()) {\n+      new_args = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n+    }\n+    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n+    objArrayHandle props(THREAD, propsObj);\n+\n+    for (int i = 0; i < new_properties->length(); i++) {\n+      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n+      props->obj_at_put(i, propObj);\n+    }\n+\n+    wakeup_threads_in_timedwait();\n+\n+    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n+  }\n+\n+  GrowableArray<CracFailDep>* failures = cr.failures();\n+\n+  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n+  typeArrayHandle codes(THREAD, codesObj);\n+  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n+  objArrayHandle msgs(THREAD, msgsObj);\n+\n+  for (int i = 0; i < failures->length(); ++i) {\n+    codes->int_at_put(i, failures->at(i)._type);\n+    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n+    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n+    msgs->obj_at_put(i, msgObj);\n+  }\n+\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n+}\n+\n+void crac::restore() {\n+  jlong restore_time = os::javaTimeMillis();\n+  jlong restore_nanos = os::javaTimeNanos();\n+\n+  compute_crengine();\n+\n+  const int id = os::current_process_id();\n+\n+  CracSHM shm(id);\n+  int shmfd = shm.open(O_RDWR | O_CREAT);\n+  if (0 <= shmfd) {\n+    if (CracRestoreParameters::write_to(\n+          shmfd,\n+          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n+          Arguments::system_properties(),\n+          Arguments::java_command() ? Arguments::java_command() : \"\",\n+          restore_time,\n+          restore_nanos)) {\n+      char strid[32];\n+      snprintf(strid, sizeof(strid), \"%d\", id);\n+      LINUX_ONLY(setenv(\"CRAC_NEW_ARGS_ID\", strid, true));\n+    }\n+    close(shmfd);\n+  }\n+\n+  if (_crengine) {\n+    _crengine_args[1] = \"restore\";\n+    add_crengine_arg(CRaCRestoreFrom);\n+    os::execv(_crengine, _crengine_args);\n+    warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", _crengine, os::strerror(errno));\n+  }\n+}\n+\n+bool CracRestoreParameters::read_from(int fd) {\n+  struct stat st;\n+  if (fstat(fd, &st)) {\n+    perror(\"fstat (ignoring restore parameters)\");\n+    return false;\n+  }\n+\n+  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+  if (read(fd, contents, st.st_size) < 0) {\n+    perror(\"read (ignoring restore parameters)\");\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return false;\n+  }\n+\n+  _raw_content = contents;\n+\n+  \/\/ parse the contents to read new system properties and arguments\n+  header* hdr = (header*)_raw_content;\n+  char* cursor = _raw_content + sizeof(header);\n+\n+  ::_restore_start_time = hdr->_restore_time;\n+  ::_restore_start_nanos = hdr->_restore_nanos;\n+\n+  for (int i = 0; i < hdr->_nflags; i++) {\n+    FormatBuffer<80> err_msg(\"%s\", \"\");\n+    JVMFlag::Error result;\n+    const char *name = cursor;\n+    if (*cursor == '+' || *cursor == '-') {\n+      name = cursor + 1;\n+      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n+        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+      cursor += strlen(cursor) + 1;\n+    } else {\n+      char* eq = strchrnul(cursor, '=');\n+      if (*eq == '\\0') {\n+        result = JVMFlag::Error::MISSING_VALUE;\n+        cursor = eq + 1;\n+      } else {\n+        *eq = '\\0';\n+        char* value = eq + 1;\n+        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+        cursor = value + strlen(value) + 1;\n+      }\n+    }\n+    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %d\",\n+        name, result);\n+  }\n+\n+  for (int i = 0; i < hdr->_nprops; i++) {\n+    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+    int idx = _properties->append(cursor);\n+    size_t prop_len = strlen(cursor) + 1;\n+    cursor = cursor + prop_len;\n+  }\n+\n+  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n+  memcpy(env_mem, cursor, hdr->_env_memory_size);\n+\n+  const char* env_end = env_mem + hdr->_env_memory_size;\n+  while (env_mem < env_end) {\n+    const size_t s = strlen(env_mem) + 1;\n+    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n+    putenv(env_mem);\n+    env_mem += s;\n+  }\n+  cursor += hdr->_env_memory_size;\n+\n+  _args = cursor;\n+  return true;\n+}\n+\n+void crac::record_time_before_checkpoint() {\n+  checkpoint_millis = os::javaTimeMillis();\n+  checkpoint_nanos = os::javaTimeNanos();\n+  memset(checkpoint_bootid, 0, UUID_LENGTH);\n+  read_bootid(checkpoint_bootid);\n+}\n+\n+void crac::update_javaTimeNanos_offset() {\n+  char buf[UUID_LENGTH];\n+  \/\/ We will change the nanotime offset only if this is not the same boot\n+  \/\/ to prevent reducing the accuracy of System.nanoTime() unnecessarily.\n+  \/\/ It is possible that in a real-world case the boot_id does not change\n+  \/\/ (containers keep the boot_id) - but the monotonic time changes. We will\n+  \/\/ only guarantee that the nanotime does not go backwards in that case but\n+  \/\/ won't offset the time based on wall-clock time as this change in monotonic\n+  \/\/ time is likely intentional.\n+  if (!read_bootid(buf) || memcmp(buf, checkpoint_bootid, UUID_LENGTH) != 0) {\n+    assert(checkpoint_millis >= 0, \"Restore without a checkpoint?\");\n+    long diff_millis = os::javaTimeMillis() - checkpoint_millis;\n+    \/\/ If the wall clock has gone backwards we won't add it to the offset\n+    if (diff_millis < 0) {\n+      diff_millis = 0;\n+    }\n+    \/\/ javaTimeNanos() call on the second line below uses the *_offset, so we will zero\n+    \/\/ it to make the call return true monotonic time rather than the adjusted value.\n+    javaTimeNanos_offset = 0;\n+    javaTimeNanos_offset = checkpoint_nanos - os::javaTimeNanos() + diff_millis * 1000000L;\n+  } else {\n+    \/\/ ensure monotonicity even if this looks like the same boot\n+    jlong diff = os::javaTimeNanos() - checkpoint_nanos;\n+    if (diff < 0) {\n+      javaTimeNanos_offset -= diff;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":634,"deletions":0,"binary":false,"changes":634,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_HPP\n+#define SHARE_RUNTIME_CRAC_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n+#define UUID_LENGTH 36\n+\n+class crac: AllStatic {\n+public:\n+  static void vm_create_start();\n+  static bool prepare_checkpoint();\n+  static Handle checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS);\n+  static void restore();\n+\n+  static jlong restore_start_time();\n+  static jlong uptime_since_restore();\n+\n+  static void record_time_before_checkpoint();\n+  static void update_javaTimeNanos_offset();\n+\n+  static jlong monotonic_time_offset() {\n+    return javaTimeNanos_offset;\n+  }\n+\n+  static void initialize_time_counters();\n+\n+private:\n+  static bool read_bootid(char *dest);\n+\n+  static jlong checkpoint_millis;\n+  static jlong checkpoint_nanos;\n+  static char checkpoint_bootid[UUID_LENGTH];\n+  static jlong javaTimeNanos_offset;\n+};\n+\n+#endif \/\/SHARE_RUNTIME_CRAC_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+#define SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+\n+#include \"jvm.h\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+\n+#ifdef LINUX\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+#endif\n+\n+struct CracFailDep {\n+  int _type;\n+  char* _msg;\n+  CracFailDep(int type, char* msg) :\n+    _type(type),\n+    _msg(msg)\n+  { }\n+  CracFailDep() :\n+    _type(JVM_CR_FAIL),\n+    _msg(NULL)\n+  { }\n+};\n+\n+class CracRestoreParameters : public CHeapObj<mtInternal> {\n+  char* _raw_content;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  struct header {\n+    jlong _restore_time;\n+    jlong _restore_nanos;\n+    int _nflags;\n+    int _nprops;\n+    int _env_memory_size;\n+  };\n+\n+  static bool write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  static int system_props_length(const SystemProperty* props) {\n+    int len = 0;\n+    while (props != NULL) {\n+      ++len;\n+      props = props->next();\n+    }\n+    return len;\n+  }\n+\n+  static int env_vars_size(const char* const * env) {\n+    int len = 0;\n+    for (; *env; ++env) {\n+      len += (int)strlen(*env) + 1;\n+    }\n+    return len;\n+  }\n+\n+ public:\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  CracRestoreParameters() :\n+    _raw_content(NULL),\n+    _properties(new (mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(NULL)\n+  {}\n+\n+  ~CracRestoreParameters() {\n+    if (_raw_content) {\n+      FREE_C_HEAP_ARRAY(char, _raw_content);\n+    }\n+    delete _properties;\n+  }\n+\n+  static bool write_to(int fd,\n+      const char* const* flags, int num_flags,\n+      const SystemProperty* props,\n+      const char *args,\n+      jlong restore_time,\n+      jlong restore_nanos) {\n+    header hdr = {\n+      restore_time,\n+      restore_nanos,\n+      num_flags,\n+      system_props_length(props),\n+      env_vars_size(os::get_environ())\n+    };\n+\n+    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < num_flags; ++i) {\n+      if (!write_check_error(fd, flags[i], (int)strlen(flags[i]) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    const SystemProperty* p = props;\n+    while (p != NULL) {\n+      char prop[4096];\n+      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n+      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n+      if (!write_check_error(fd, prop, len+1)) {\n+        return false;\n+      }\n+      p = p->next();\n+    }\n+\n+    \/\/ Write env vars\n+    for (char** env = os::get_environ(); *env; ++env) {\n+      if (!write_check_error(fd, *env, (int)strlen(*env) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    return write_check_error(fd, args, (int)strlen(args)+1); \/\/ +1 for null char\n+  }\n+\n+  bool read_from(int fd);\n+\n+};\n+\n+class VM_Crac: public VM_Operation {\n+  jarray _fd_arr;\n+  const bool _dry_run;\n+  bool _ok;\n+  GrowableArray<CracFailDep>* _failures;\n+  CracRestoreParameters _restore_parameters;\n+  outputStream* _ostream;\n+#if defined(LINUX) && INCLUDE_SERVICES\n+  PosixAttachOperation* _attach_op;\n+#endif \/\/ LINUX && INCLUDE_SERVICES\n+\n+public:\n+  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n+    _fd_arr(fd_arr),\n+    _dry_run(dry_run),\n+    _ok(false),\n+    _failures(new (mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n+    _restore_parameters(),\n+    _ostream(jcmd_stream ? jcmd_stream : tty)\n+#if defined(LINUX) && INCLUDE_SERVICES\n+    , _attach_op(jcmd_stream ? PosixAttachListener::get_current_op() : NULL)\n+#endif \/\/ LINUX && INCLUDE_SERVICES\n+  { }\n+\n+  ~VM_Crac() {\n+    delete _failures;\n+  }\n+\n+  GrowableArray<CracFailDep>* failures() { return _failures; }\n+  bool ok() { return _ok; }\n+  const char* new_args() { return _restore_parameters.args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n+  virtual bool allow_nested_vm_operations() const  { return true; }\n+  VMOp_Type type() const { return VMOp_VM_Crac; }\n+  void doit();\n+  bool read_shm(int shmid);\n+\n+private:\n+  bool is_claimed_fd(int fd);\n+  bool is_socket_from_jcmd(int sock_fd);\n+  void report_ok_to_jcmd_if_any();\n+  void print_resources(const char* msg, ...);\n+  void trace_cr(const char* msg, ...);\n+  bool check_fds();\n+  bool memory_checkpoint();\n+  void memory_restore();\n+};\n+\n+class CracSHM {\n+  char _path[128];\n+public:\n+  CracSHM(int id) {\n+    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n+    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n+      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    }\n+  }\n+\n+  int open(int mode);\n+  void unlink();\n+};\n+\n+#endif \/\/SHARE_RUNTIME_CRAC_STRUCTS_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac_structs.hpp","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -401,0 +401,2 @@\n+    case JVMFlagOrigin::CRAC_RESTORE:\n+      st->print(\"crac restore\");\n@@ -508,3 +510,4 @@\n-const int DIAGNOSTIC   = JVMFlag::KIND_DIAGNOSTIC;\n-const int MANAGEABLE   = JVMFlag::KIND_MANAGEABLE;\n-const int EXPERIMENTAL = JVMFlag::KIND_EXPERIMENTAL;\n+const int DIAGNOSTIC       = JVMFlag::KIND_DIAGNOSTIC;\n+const int MANAGEABLE       = JVMFlag::KIND_MANAGEABLE;\n+const int EXPERIMENTAL     = JVMFlag::KIND_EXPERIMENTAL;\n+const int RESTORE_SETTABLE = JVMFlag::KIND_RESTORE_SETTABLE;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  CRAC_RESTORE     = 9,\n@@ -51,1 +52,1 @@\n-ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::JIMAGE_RESOURCE)\n+ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::CRAC_RESTORE)\n@@ -73,1 +74,1 @@\n-\n+    KIND_RESTORE_SETTABLE   = 1 << 15,\n@@ -250,0 +251,1 @@\n+  bool is_restore_settable() const { return (_flags & (KIND_RESTORE_SETTABLE | KIND_MANAGEABLE)) != 0; }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -950,1 +950,0 @@\n-  ResourceMark rm(thread);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n-\/\/ only with product\/product_pd flags.\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, MANAGEABLE or RESTORE_SETTABLE. Currently\n+\/\/ extra_attrs can be used only with product\/product_pd flags.\n@@ -100,0 +100,3 @@\n+\/\/ RESTORE_SETTABLE are flags that can be set during restore from a snapshot.\n+\/\/    All MANAGEABLE flags are implicitly RESTORE_SETTABLE but\n+\/\/    RESTORE_SETTABLE are not MANAGEABLE.\n@@ -173,1 +176,2 @@\n-  product(bool, UnlockDiagnosticVMOptions, trueInDebug, DIAGNOSTIC,         \\\n+  product(bool, UnlockDiagnosticVMOptions, trueInDebug,                     \\\n+          DIAGNOSTIC | RESTORE_SETTABLE,                                    \\\n@@ -176,1 +180,2 @@\n-  product(bool, UnlockExperimentalVMOptions, false, EXPERIMENTAL,           \\\n+  product(bool, UnlockExperimentalVMOptions, false,                         \\\n+          EXPERIMENTAL | RESTORE_SETTABLE,                                  \\\n@@ -1963,0 +1968,57 @@\n+  product(ccstr, CRaCCheckpointTo, NULL, RESTORE_SETTABLE,                  \\\n+        \"Path to checkpoint image directory\")                               \\\n+                                                                            \\\n+  product(ccstr, CRaCRestoreFrom, NULL, RESTORE_SETTABLE,                   \\\n+      \"Path to image for restore, replaces the initializing VM on success\") \\\n+                                                                            \\\n+  product(uint, CRaCMinPid, 128,                                            \\\n+      \"Mininal PID value for checkpoint'ed process\")                        \\\n+      range(1, UINT_MAX)                                                    \\\n+                                                                            \\\n+  product(bool, CRaCResetStartTime, true, DIAGNOSTIC | RESTORE_SETTABLE,    \\\n+      \"Reset JVM's start time and uptime on restore\")                       \\\n+                                                                            \\\n+  product(ccstr, CREngine, \"criuengine\", RESTORE_SETTABLE,                  \\\n+      \"Path or name of a program implementing checkpoint\/restore and \"      \\\n+      \"optional extra parameters as a comma-separated list: \"               \\\n+      \"-XX:CREngine=program,--key,value,--anotherkey results in calling \"   \\\n+      \"'program --key value --anotherkey'. Commas used as part of args \"    \\\n+      \"should be escaped with a backslash character ('\\\\').\")               \\\n+                                                                            \\\n+  product(bool, CRaCIgnoreRestoreIfUnavailable, false, RESTORE_SETTABLE,    \\\n+      \"Ignore -XX:CRaCRestoreFrom and continue initialization if restore \"  \\\n+      \"is unavailable\")                                                     \\\n+                                                                            \\\n+  product(ccstr, CRaCIgnoredFileDescriptors, NULL, RESTORE_SETTABLE,        \\\n+      \"Comma-separated list of file descriptor numbers or paths. \"          \\\n+      \"All file descriptors greater than 2 (stdin, stdout and stderr are \"  \\\n+      \"excluded automatically) not in this list are closed when the VM \"    \\\n+      \"is started.\")                                                        \\\n+                                                                            \\\n+  product_pd(ccstrlist, CRAllowedOpenFilePrefixes, \"List of path prefixes \" \\\n+      \"for files that can be open during checkpoint; CRaC won't error \"     \\\n+      \"upon detecting these and will leave the handling up to C\/R engine. \" \\\n+      \"This option applies only to files opened by native code; for files \" \\\n+      \"opened by Java code use -Djdk.crac.resource-policies=...\")           \\\n+                                                                            \\\n+  product(bool, CRAllowToSkipCheckpoint, false, DIAGNOSTIC,                 \\\n+          \"Allow implementation to not call Checkpoint if helper not found\")\\\n+                                                                            \\\n+  product(bool, CRHeapDumpOnCheckpointException, false, DIAGNOSTIC,         \\\n+      \"Dump heap on CheckpointException thrown because of CRaC \"            \\\n+      \"precondition failed\")                                                \\\n+                                                                            \\\n+  product(bool, CRPrintResourcesOnCheckpoint, false, DIAGNOSTIC,            \\\n+      \"Print resources to decide CheckpointException\")                      \\\n+                                                                            \\\n+  product(bool, CRTraceStartupTime, false, DIAGNOSTIC,                      \\\n+      \"Trace startup time\")                                                 \\\n+                                                                            \\\n+  product(bool, CRDoThrowCheckpointException, true, EXPERIMENTAL,           \\\n+      \"Throw CheckpointException if uncheckpointable resource handle found\")\\\n+                                                                            \\\n+  product(bool, CRTrace, true, RESTORE_SETTABLE, \"Minimal C\/R tracing\")     \\\n+                                                                            \\\n+  product(bool, CRPauseOnCheckpointError, false, DIAGNOSTIC,                \\\n+      \"Pauses the checkpoint when a problem is found on VM level.\")         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":66,"deletions":4,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1155,0 +1155,1 @@\n+  void wakeup_sleep() { _SleepEvent->unpark(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1445,1 +1445,1 @@\n-  JFR_ONLY(return vmSymbols::jfr_chunk_rotation_monitor() == monitor_klass->name();)\n+  JFR_ONLY(return vmSymbols::jdk_jfr_internal_HiddenWait() == monitor_klass->name();)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2148,0 +2148,7 @@\n+void os::cleanup_memory(char* addr, size_t bytes) {\n+  char* start = (char*)align_up(addr, os::vm_page_size());\n+  char* end = (char*)align_down(addr + bytes, os::vm_page_size());\n+  os::uncommit_memory(start, end - start);\n+  os::commit_memory(start, end - start, false);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -477,0 +477,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n@@ -632,0 +634,4 @@\n+  static int exec_child_process_and_wait(const char *path, const char *argv[]);\n+\n+  static int execv(const char *path, const char *argv[]);\n+\n@@ -684,0 +690,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -687,0 +696,2 @@\n+  static bool           is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1336,1 +1336,1 @@\n-           callee_method->method_holder()->is_init_thread(current),\n+           callee_method->method_holder()->is_reentrant_initialization(current),\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -824,0 +824,10 @@\n+void ObjectSynchronizer::waitUninterruptibly(Handle obj, jlong millis, TRAPS) {\n+  if (millis < 0) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n+  }\n+  ObjectSynchronizer::inflate(THREAD,\n+                              obj(),\n+                              inflate_cause_wait)->wait(millis, false, THREAD);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -122,0 +122,5 @@\n+  \/\/ Special internal-use-only method for use by JVM infrastructure\n+  \/\/ that needs to wait() on a java-level object but that can't risk\n+  \/\/ throwing unexpected InterruptedExecutionExceptions.\n+  static void waitUninterruptibly(Handle obj, jlong Millis, TRAPS);\n+\n@@ -228,0 +233,1 @@\n+  void wait_uninterruptibly(TRAPS)  { ObjectSynchronizer::waitUninterruptibly(_obj, 0, CHECK); } \/\/ wait forever\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -413,0 +414,15 @@\n+jint Threads::check_for_restore(JavaVMInitArgs* args) {\n+  if (Arguments::is_restore_option_set(args)) {\n+    if (!Arguments::parse_options_for_restore(args)) {\n+      return JNI_ERR;\n+    }\n+    crac::restore();\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -416,0 +432,2 @@\n+  if (check_for_restore(args) != JNI_OK) return JNI_ERR;\n+\n@@ -480,0 +498,2 @@\n+  crac::vm_create_start();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+  static jint check_for_restore(JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -208,2 +208,3 @@\n-    else if (thread()->osthread()->get_state() == CONDVAR_WAIT) {\n-      \/\/ We are waiting on the native class initialization monitor.\n+    else if (thread()->osthread()->get_state() == OBJECT_WAIT) {\n+      \/\/ We are waiting on an Object monitor but Object.wait() isn't the\n+      \/\/ top-frame, so we should be waiting on a Class initialization monitor.\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+  template(VM_Crac)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -249,0 +249,1 @@\n+  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -2166,1 +2167,0 @@\n-  declare_constant(InstanceKlass::being_linked)                           \\\n@@ -2471,0 +2471,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,16 @@\n+bool ClassLoadingService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose looks for a non-exact match for class+load,\n+    \/\/ so look for all tag sets that match class+load*\n+    if (ts->contains(LogTag::_class) &&\n+        ts->contains(LogTag::_load)) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l != LogLevel::Info && l != LogLevel::Debug && l != LogLevel::Trace) {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/classLoadingService.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+  static bool get_verbose() NOT_MANAGEMENT_RETURN_(false);\n@@ -66,1 +67,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n","filename":"src\/hotspot\/share\/services\/classLoadingService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,0 +67,4 @@\n+#ifdef LINUX\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#endif \/\/LINUX\n@@ -152,0 +156,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -1104,0 +1110,26 @@\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_crac_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::checkpointRestoreInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != NULL) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      outputStream* stream = output();\n+#if defined(LINUX) && INCLUDE_SERVICES\n+      assert(PosixAttachListener::get_current_op(), \"should exist\");\n+      if (PosixAttachListener::get_current_op()->is_effectively_completed()) {\n+        stream = tty;\n+      }\n+#endif \/\/LINUX\n+      stream->print_cr(\"An exception during a checkpoint operation:\");\n+      stream->print(\"%s\", out);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1025,0 +1025,14 @@\n+class CheckpointDCmd : public DCmd {\n+public:\n+  CheckpointDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"JDK.checkpoint\"; }\n+    static const char* description() {\n+      return \"Checkpoint via jdk.crac.checkpointRestore().\";\n+    }\n+    static const char* impact() {\n+      return \"High: JVM terminates\";\n+    }\n+    static int num_arguments() { return 0; }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1092,0 +1092,8 @@\n+  \/\/ Also provide a pointer to the init_lock if present, so there aren't unreferenced int[0]\n+  \/\/ arrays.\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    field_count++;\n+    size += sizeof(address);\n+  }\n+\n@@ -1129,0 +1137,8 @@\n+\n+  \/\/ Add init lock to the end if the class is not yet initialized\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    writer->write_symbolID(vmSymbols::init_lock_name());         \/\/ name\n+    writer->write_u1(sig2tag(vmSymbols::int_array_signature())); \/\/ type\n+    writer->write_objectID(init_lock);\n+  }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -983,0 +984,12 @@\n+  case JMM_JVM_RESTORE_START_TIME_MS:\n+    return crac::restore_start_time();\n+\n+  case JMM_JVM_UPTIME_SINCE_RESTORE_MS:\n+    {\n+      jlong ticks = crac::uptime_since_restore();\n+      if (ticks == -1) {\n+        return -1;\n+      }\n+      return Management::ticks_to_ms(ticks);\n+    }\n+\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,0 +205,15 @@\n+bool MemoryService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose only sets gc and not gc*, so check for an exact match\n+    const bool is_gc_exact_match = ts->contains(LogTag::_gc) && ts->ntags() == 1;\n+    if (is_gc_exact_match) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l == LogLevel::Info || l == LogLevel::Debug || l == LogLevel::Trace) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/memoryService.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, gc); }\n@@ -111,0 +110,1 @@\n+  static bool get_verbose();\n","filename":"src\/hotspot\/share\/services\/memoryService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-    \/\/ only writeable flags are allowed to be set\n-    if (f->is_writeable()) {\n+    \/\/ only writeable or restore_settable flags are allowed to be set\n+    if (f->is_writeable() || (f->is_restore_settable() && origin == JVMFlagOrigin::CRAC_RESTORE)) {\n","filename":"src\/hotspot\/share\/services\/writeableFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,0 +125,9 @@\n+void Decoder::before_checkpoint() {\n+  MutexLocker locker(shared_decoder_lock(), Mutex::_no_safepoint_check_flag);\n+  if (_shared_decoder != nullptr) {\n+    delete _shared_decoder;\n+    _shared_decoder = nullptr;\n+  }\n+  guarantee(_error_handler_decoder == nullptr, \"Error handler decoder should not be present\");\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/decoder.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -125,0 +125,5 @@\n+#ifdef _WINDOWS\n+  static void before_checkpoint() { \/* noop *\/ }\n+#else\n+  static void before_checkpoint();\n+\n@@ -143,1 +148,2 @@\n-  friend class DecoderLocker;\n+#endif \/\/ !_WINDOWS\n+\n","filename":"src\/hotspot\/share\/utilities\/decoder.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+\/\/ Limit exception message components to 64K (the same max as Symbols)\n+#define MAX_LEN 65535\n+\n@@ -119,1 +122,1 @@\n-    log_info(exceptions)(\"Thread cannot call Java so instead of throwing exception <%s%s%s> (\" PTR_FORMAT \") \\n\"\n+    log_info(exceptions)(\"Thread cannot call Java so instead of throwing exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n@@ -122,1 +125,2 @@\n-                        exc_value, message ? \": \" : \"\", message ? message : \"\",\n+                        MAX_LEN, exc_value, message ? \": \" : \"\",\n+                        MAX_LEN, message ? message : \"\",\n@@ -148,1 +152,1 @@\n-  log_info(exceptions)(\"Exception <%s%s%s> (\" PTR_FORMAT \") \\n\"\n+  log_info(exceptions)(\"Exception <%.*s%s%.*s> (\" PTR_FORMAT \") \\n\"\n@@ -150,2 +154,3 @@\n-                       h_exception->print_value_string(),\n-                       message ? \": \" : \"\", message ? message : \"\",\n+                       MAX_LEN, h_exception->print_value_string(),\n+                       message ? \": \" : \"\",\n+                       MAX_LEN, message ? message : \"\",\n@@ -571,4 +576,4 @@\n-    log_info(exceptions)(\"Exception <%s: %s>\\n thrown in %s\",\n-                         exception->print_value_string(),\n-                         detail_message,\n-                         message);\n+    log_info(exceptions)(\"Exception <%.*s: %.*s>\\n thrown in %.*s\",\n+                         MAX_LEN, exception->print_value_string(),\n+                         MAX_LEN, detail_message,\n+                         MAX_LEN, message);\n@@ -576,3 +581,3 @@\n-    log_info(exceptions)(\"Exception <%s>\\n thrown in %s\",\n-                         exception->print_value_string(),\n-                         message);\n+    log_info(exceptions)(\"Exception <%.*s>\\n thrown in %.*s\",\n+                         MAX_LEN, exception->print_value_string(),\n+                         MAX_LEN, message);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -254,0 +254,4 @@\n+#ifndef INCLUDE_CPU_FEATURE_ACTIVE\n+#define INCLUDE_CPU_FEATURE_ACTIVE 1\n+#endif \/\/ INCLUDE_CPU_FEATURE_ACTIVE\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -434,1 +435,1 @@\n-  int result = 0;\n+  size_t result = 0;\n@@ -437,1 +438,5 @@\n-    result += utf8_size(c);\n+    int sz = utf8_size(c);\n+    if (result + sz > INT_MAX-1) {\n+      break;\n+    }\n+    result += sz;\n@@ -439,1 +444,1 @@\n-  return result;\n+  return checked_cast<int>(result);\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -28,0 +29,8 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n+import java.io.FileDescriptor;\n@@ -30,0 +39,1 @@\n+import java.nio.channels.IllegalSelectorException;\n@@ -49,0 +59,3 @@\n+ *\n+ * @crac The file descriptor(s) used internally by this class are automatically\n+ * closed before checkpointing the process and opened after the restore.\n@@ -50,2 +63,1 @@\n-\n-class EPollSelectorImpl extends SelectorImpl {\n+class EPollSelectorImpl extends SelectorImpl implements JDKResource {\n@@ -56,0 +68,27 @@\n+    private static final JavaIOFileDescriptorAccess fdAccess\n+            = SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    private enum CheckpointRestoreState {\n+        NORMAL_OPERATION,\n+        CHECKPOINT_TRANSITION,\n+        CHECKPOINTED,\n+        CHECKPOINT_ERROR,\n+        RESTORE_TRANSITION,\n+    }\n+\n+    private static class MoveToCheckpointThread extends Thread {\n+        private Selector selector;\n+\n+        MoveToCheckpointThread(Selector selector) {\n+            this.selector = selector;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                selector.select(1);\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+\n@@ -57,1 +96,1 @@\n-    private final int epfd;\n+    private int epfd;\n@@ -60,1 +99,1 @@\n-    private final long pollArrayAddress;\n+    private long pollArrayAddress;\n@@ -63,1 +102,1 @@\n-    private final EventFD eventfd;\n+    private EventFD eventfd;\n@@ -76,2 +115,1 @@\n-    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n-        super(sp);\n+    private volatile CheckpointRestoreState checkpointState = CheckpointRestoreState.NORMAL_OPERATION;;\n@@ -79,2 +117,2 @@\n-        this.epfd = EPoll.create();\n-        this.pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+    private void initFDs() throws IOException {\n+        epfd = EPoll.create();\n@@ -84,1 +122,4 @@\n-            IOUtil.configureBlocking(IOUtil.newFD(eventfd.efd()), false);\n+            FileDescriptor fd = IOUtil.newFD(eventfd.efd());\n+            \/\/ This FileDescriptor is a one-time use, the actual FD will be closed from EventFD\n+            fdAccess.markClosed(fd);\n+            IOUtil.configureBlocking(fd, false);\n@@ -95,0 +136,9 @@\n+    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n+        super(sp);\n+        pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+        initFDs();\n+        \/\/ trigger FileDispatcherImpl initialization\n+        new FileDispatcherImpl();\n+        Core.Priority.EPOLLSELECTOR.getContext().register(this);\n+    }\n+\n@@ -100,0 +150,47 @@\n+    private boolean processCheckpointRestore() throws IOException {\n+        assert Thread.holdsLock(this);\n+\n+        if (checkpointState != CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+            return false;\n+        }\n+\n+        synchronized (interruptLock) {\n+\n+            CheckpointRestoreState thisState;\n+            if (fdToKey.size() == 0) {\n+                eventfd.close();\n+                eventfd = null;\n+                FileDispatcherImpl.closeIntFD(epfd);\n+                thisState = CheckpointRestoreState.CHECKPOINTED;\n+            } else {\n+                thisState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+            }\n+\n+            checkpointState = thisState;\n+            interruptLock.notifyAll();\n+            while (checkpointState == thisState) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+\n+            assert checkpointState == CheckpointRestoreState.RESTORE_TRANSITION;\n+            if (thisState == CheckpointRestoreState.CHECKPOINTED) {\n+                initFDs();\n+            }\n+            checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+            interruptLock.notifyAll();\n+\n+            if (interruptTriggered) {\n+                try {\n+                    eventfd.set();\n+                } catch (IOException ioe) {\n+                    throw new InternalError(ioe);\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n@@ -121,1 +218,3 @@\n-                    numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                    do {\n+                        numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                    } while (processCheckpointRestore());\n@@ -206,1 +305,1 @@\n-        if (interrupted) {\n+        if (interrupted && !(Thread.currentThread() instanceof MoveToCheckpointThread)) {\n@@ -273,0 +372,51 @@\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.CHECKPOINT_TRANSITION;\n+            eventfd.set();\n+            int tries = 5;\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION && 0 < tries--) {\n+                try {\n+                    interruptLock.wait(5);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                Thread thr = new MoveToCheckpointThread(this);\n+                thr.setDaemon(true);\n+                thr.start();\n+            }\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_ERROR) {\n+                throw new IllegalSelectorException();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.RESTORE_TRANSITION;\n+            interruptLock.notifyAll();\n+            while (checkpointState == CheckpointRestoreState.RESTORE_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":162,"deletions":12,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n+import java.util.*;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n@@ -32,0 +32,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n@@ -34,0 +36,1 @@\n+import jdk.internal.crac.*;\n@@ -59,0 +62,66 @@\n+    class Resource extends JDKFdResource {\n+        private boolean closedByNIO;\n+\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n+            if (!closedByNIO && valid()) {\n+                ClaimedFDs claimedFDs = Core.getClaimedFDs();\n+                FileDescriptor self = FileDescriptor.this;\n+                String nativeDescription = nativeDescription0();\n+\n+                OpenResourcePolicies.Policy policy = findPolicy(nativeDescription);\n+                String action = \"error\";\n+                Supplier<Exception> supplier = null;\n+                \/\/ Normally the claiming should be overridden by FileInputStream\/FileOutputStream\n+                \/\/ but in case these are collected we handle FDs 0..2 here as well.\n+                if (policy != null) {\n+                    action = policy.action;\n+                } else if (self == in || self == out || self == err) {\n+                    action = \"ignore\";\n+                }\n+                supplier = switch (action.toLowerCase()) {\n+                    case \"error\":\n+                        yield () -> new CheckpointOpenResourceException(\n+                            FileDescriptor.class.getSimpleName() + \" \" + fd + \": \" + nativeDescription,\n+                            getStackTraceHolder());\n+                    case \"close\":\n+                        close();\n+                    case \"ignore\":\n+                        warnOpenResource(policy, \"File descriptor \" + fd);\n+                        yield NO_EXCEPTION;\n+                    default: throw new IllegalArgumentException(\"Unknown policy action for file descriptor \" + fd + \": \" + action);\n+                };\n+                claimedFDs.claimFd(self, self, supplier);\n+            }\n+        }\n+\n+        private OpenResourcePolicies.Policy findPolicy(String nativeDescription) {\n+            return OpenResourcePolicies.find(false, \"filedescriptor\", params -> {\n+                String value = params.get(\"value\");\n+                if (value != null) {\n+                    try {\n+                        int expected = Integer.parseInt(value);\n+                        if (expected != fd) {\n+                            return false;\n+                        }\n+                    } catch (NumberFormatException e) {\n+                        throw new IllegalArgumentException(\"Cannot parse file descriptor value '\" + value + \"'\");\n+                    }\n+                }\n+                String regex = params.get(\"regex\");\n+                if (regex != null) {\n+                    return Pattern.compile(regex).matcher(nativeDescription).find();\n+                }\n+                return true;\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getName() + \"(FD \" + fd + \")\";\n+        }\n+    }\n+\n+    Resource resource = new Resource();\n+\n@@ -92,0 +161,5 @@\n+                    @Override\n+                    public void markClosed(FileDescriptor fdo) {\n+                        fdo.resource.closedByNIO = true;\n+                    }\n+\n@@ -307,0 +381,2 @@\n+    private native String nativeDescription0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":79,"deletions":3,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFileResource;\n@@ -602,0 +609,65 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (fd == FileDescriptor.in) {\n+                Core.getClaimedFDs().claimFd(fd, FileInputStream.this, NO_EXCEPTION, fd);\n+            } else {\n+                \/\/ When the stream is opened with file descriptor we don't have any extra\n+                \/\/ information we could use for policy (this is most often a pipe, but could\n+                \/\/ be a socket as well). Such cases need to be handled on a higher level.\n+                super.beforeCheckpoint(context);\n+            }\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            try {\n+                offset = position();\n+            } catch (IOException e) {\n+                \/\/ We might get IOException from native code when lseeking a named pipe.\n+                offset = 0;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path);\n+                if (offset > 0) {\n+                    skip(offset);\n+                }\n+                FileInputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -29,0 +29,8 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -31,0 +39,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -98,0 +107,10 @@\n+    \/**\n+     * When the file is opened in non-append mode we need to check position\n+     * through the {@link #channel} when handling the file descriptor policy;\n+     * this needs to be independent of the regular resource as we need to\n+     * ensure initialization of the channel before FD priority class.\n+     * This field being <code>null<\/code> means that the file is opened in\n+     * append-only mode and does not need to track the position.\n+     *\/\n+    private final EnsureChannelResource channelResource;\n+\n@@ -236,0 +255,5 @@\n+        if (append) {\n+            channelResource = null;\n+        } else {\n+            channelResource = new EnsureChannelResource();\n+        }\n@@ -276,0 +300,2 @@\n+        \/\/ We don't have path information and won't reopen the file\n+        this.channelResource = null;\n@@ -285,1 +311,1 @@\n-    private native void open0(String name, boolean append)\n+    private native void open0(String name, boolean append, boolean truncate)\n@@ -295,1 +321,1 @@\n-        open0(name, append);\n+        open0(name, append, !append);\n@@ -513,0 +539,77 @@\n+\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            if (channelResource != null) {\n+                FileChannel channel = getChannel();\n+                channelResource.position = channel.isOpen() ? channel.position() : -1;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            assert path != null; \/\/ won't be reopened if it was not closed, and won't be closed without path\n+            synchronized (closeLock) {\n+                \/\/ We have been writing to a file, but it disappeared during checkpoint\n+                if (!Files.exists(Path.of(path))) {\n+                    throw new IOException(\"File \" + path + \" is not present during restore\");\n+                }\n+                if (channelResource == null) {\n+                    open(path, true);\n+                } else {\n+                    open0(path, false, false);\n+                    \/\/noinspection resource\n+                    getChannel().position(channelResource.position);\n+                }\n+                FileOutputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n+    private class EnsureChannelResource implements JDKResource {\n+        public long position;\n+\n+        EnsureChannelResource() {\n+            \/\/ This must be before PRE_FILE_DESCRIPTORS as getChannel()\n+            \/\/ could clinit FileDispatcherImpl\n+            Core.Priority.NORMAL.getContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            \/\/ the channel is not used but we ensure its existence\n+            getChannel();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":105,"deletions":2,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -32,0 +33,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -83,0 +85,1 @@\n+    private final int imode;\n@@ -102,0 +105,31 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ We cannot synchronize this without making every other method call synchronized\n+            offset = getFilePointer();\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path, imode);\n+                seek(offset);\n+                RandomAccessFile.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n@@ -285,0 +319,1 @@\n+        this.imode = imode;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -240,0 +240,4 @@\n+     *\n+     * Satisfying this method's contract implies a non-{@code null}\n+     * result must be returned.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,7 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -39,0 +46,1 @@\n+import java.util.function.Supplier;\n@@ -817,0 +825,1 @@\n+        private final JDKFdResource resource;\n@@ -820,0 +829,1 @@\n+            resource = new PipeResource(this, fd);\n@@ -914,0 +924,31 @@\n+    static class PipeResource extends JDKFdResource {\n+        private final Closeable owner;\n+        private final FileDescriptor fd;\n+\n+        PipeResource(Closeable owner, FileDescriptor fd) {\n+            this.owner = owner;\n+            this.fd = fd;\n+        }\n+\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            OpenResourcePolicies.Policy policy = OpenResourcePolicies.find(false, OpenResourcePolicies.PIPE, null);\n+            String action = policy != null ? policy.action.toLowerCase() : \"error\";\n+            Supplier<Exception> exceptionSupplier = switch (action) {\n+                case \"error\":\n+                    yield  () -> new CheckpointOpenResourceException(owner.toString(), getStackTraceHolder());\n+                case \"close\":\n+                    owner.close();\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    warnOpenResource(policy, owner.toString());\n+                    yield NO_EXCEPTION;\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + owner, null);\n+            };\n+            \/\/ FileInputStream does not claim when path is null\n+            Core.getClaimedFDs().claimFd(fd, this, exceptionSupplier, fd);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -34,0 +34,8 @@\n+import java.util.*;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -715,0 +723,2 @@\n+            \/\/ This creates a file descriptor but does not need own resource,\n+            \/\/ see PipelineResource.\n@@ -1308,11 +1318,18 @@\n-        try {\n-            Redirect prevOutput = null;\n-            for (int index = 0; index < builders.size(); index++) {\n-                ProcessBuilder builder = builders.get(index);\n-                Redirect[] redirects = builder.redirects();\n-                if (index > 0) {\n-                    \/\/ check the current Builder to see if it can take input from the previous\n-                    if (builder.redirectInput() != Redirect.PIPE) {\n-                        throw new IllegalArgumentException(\"builder redirectInput()\" +\n-                                \" must be PIPE except for the first builder: \"\n-                                + builder.redirectInput());\n+        \/\/ This resource helps us block the checkpoint until all subprocesses\n+        \/\/ are created; after that we won't need the FileDescriptors and can safely\n+        \/\/ close these.\n+        PipelineResource pipelineResource = new PipelineResource();\n+        synchronized (pipelineResource) {\n+            try (pipelineResource) {\n+                Redirect prevOutput = null;\n+                for (int index = 0; index < builders.size(); index++) {\n+                    ProcessBuilder builder = builders.get(index);\n+                    Redirect[] redirects = builder.redirects();\n+                    if (index > 0) {\n+                        \/\/ check the current Builder to see if it can take input from the previous\n+                        if (builder.redirectInput() != Redirect.PIPE) {\n+                            throw new IllegalArgumentException(\"builder redirectInput()\" +\n+                                    \" must be PIPE except for the first builder: \"\n+                                    + builder.redirectInput());\n+                        }\n+                        redirects[0] = prevOutput;\n@@ -1320,8 +1337,10 @@\n-                    redirects[0] = prevOutput;\n-                }\n-                if (index < numBuilders - 1) {\n-                    \/\/ check all but the last stage has output = PIPE\n-                    if (builder.redirectOutput() != Redirect.PIPE) {\n-                        throw new IllegalArgumentException(\"builder redirectOutput()\" +\n-                                \" must be PIPE except for the last builder: \"\n-                                + builder.redirectOutput());\n+                    if (index < numBuilders - 1) {\n+                        \/\/ check all but the last stage has output = PIPE\n+                        if (builder.redirectOutput() != Redirect.PIPE) {\n+                            throw new IllegalArgumentException(\"builder redirectOutput()\" +\n+                                    \" must be PIPE except for the last builder: \"\n+                                    + builder.redirectOutput());\n+                        }\n+                        RedirectPipeImpl redirectPipe = new RedirectPipeImpl();\n+                        redirects[1] = redirectPipe;  \/\/ placeholder for new output\n+                        pipelineResource.addRedirect(redirectPipe);\n@@ -1329,6 +1348,6 @@\n-                    redirects[1] = new RedirectPipeImpl();  \/\/ placeholder for new output\n-                }\n-                processes.add(builder.start(redirects));\n-                if (prevOutput instanceof RedirectPipeImpl redir) {\n-                    \/\/ Wrap the fd so it can be closed\n-                    new Process.PipeInputStream(redir.getFd()).close();\n+                    processes.add(builder.start(redirects));\n+                    if (prevOutput instanceof RedirectPipeImpl redir) {\n+                        \/\/ Wrap the fd so it can be closed\n+                        new Process.PipeInputStream(redir.getFd()).close();\n+                    }\n+                    prevOutput = redirects[1];\n@@ -1336,1 +1355,12 @@\n-                prevOutput = redirects[1];\n+            } catch (Exception ex) {\n+                \/\/ Cleanup processes already started\n+                processes.forEach(Process::destroyForcibly);\n+                processes.forEach(p -> {\n+                    try {\n+                        p.waitFor();        \/\/ Wait for it to exit\n+                    } catch (InterruptedException ie) {\n+                        \/\/ If interrupted; continue with next Process\n+                        Thread.currentThread().interrupt();\n+                    }\n+                });\n+                throw ex;\n@@ -1338,12 +1368,0 @@\n-        } catch (Exception ex) {\n-            \/\/ Cleanup processes already started\n-            processes.forEach(Process::destroyForcibly);\n-            processes.forEach(p -> {\n-                try {\n-                    p.waitFor();        \/\/ Wait for it to exit\n-                } catch (InterruptedException ie) {\n-                    \/\/ If interrupted; continue with next Process\n-                    Thread.currentThread().interrupt();\n-                }\n-            });\n-            throw ex;\n@@ -1353,0 +1371,32 @@\n+\n+    private static class PipelineResource implements JDKResource, AutoCloseable {\n+        private static final JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+        private final List<RedirectPipeImpl> redirects = new ArrayList<>();\n+\n+        public PipelineResource() {\n+            Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+        }\n+\n+        @Override\n+        public synchronized void beforeCheckpoint(Context<? extends Resource> context) {\n+            \/\/ Noop, but this method is synchronized\n+            assert redirects.isEmpty();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+\n+        public void addRedirect(RedirectPipeImpl redirect) {\n+            this.redirects.add(redirect);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            \/\/ The file descriptors won't be used by this process\n+            for (RedirectPipeImpl r : redirects) {\n+                fdAccess.close(r.getFd());\n+            }\n+            redirects.clear();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":88,"deletions":38,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -566,0 +566,5 @@\n+     * @crac When the process is restored on another machine or if the machine\n+     * rebooted the value is updated based on wall-clock time difference,\n+     * resulting in a loss of accuracy when comparing timestamps obtained\n+     * before and after checkpoint.\n+     *\n@@ -828,0 +833,6 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload system properties in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -951,0 +962,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -987,0 +1001,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -1141,0 +1158,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload environment variables in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -1194,0 +1217,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload the environment variables in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-import jdk.internal.classfile.impl.TransformingCodeBuilder;\n+\n@@ -174,1 +174,1 @@\n-        handler.accept(new TransformingCodeBuilder(this, resolved.consumer()));\n+        handler.accept(new ChainedCodeBuilder(this, resolved.consumer()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-  <link rel=\"stylesheet\" type=\"text\/css\" href=\"..\/..\/..\/..\/stylesheet.css\" title=\"Style\">\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/ValueBased.html","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-  <link rel=\"stylesheet\" type=\"text\/css\" href=\"..\/..\/..\/..\/stylesheet.css\" title=\"Style\">\n","filename":"src\/java.base\/share\/classes\/java\/lang\/doc-files\/threadPrimitiveDeprecation.html","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n- *     MemoryLayout.paddingLayout(32),\n+ *     MemoryLayout.paddingLayout(4),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n- *     ... POINT_ARR_X.get(segment, 0L, (long)i) ...\n+ *     ... POINT_ARR_X.get(points, 0L, (long)i) ...\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -633,0 +633,6 @@\n+     * <p>\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n+     * The returned memory segment shares a region of backing memory with this segment.\n+     * Hence, no memory will be allocated or freed by this method.\n@@ -649,0 +655,6 @@\n+     * <p>\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n+     * The returned memory segment shares a region of backing memory with this segment.\n+     * Hence, no memory will be allocated or freed by this method.\n@@ -673,0 +685,6 @@\n+     * <p>\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n+     * The returned memory segment shares a region of backing memory with this segment.\n+     * Hence, no memory will be allocated or freed by this method.\n@@ -696,0 +714,6 @@\n+     * <p>\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n+     * The returned memory segment shares a region of backing memory with this segment.\n+     * Hence, no memory will be allocated or freed by this method.\n@@ -709,0 +733,6 @@\n+     * <p>\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n+     * The returned memory segment shares a region of backing memory with this segment.\n+     * Hence, no memory will be allocated or freed by this method.\n@@ -744,0 +774,6 @@\n+     * <p>\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n+     * The returned memory segment shares a region of backing memory with this segment.\n+     * Hence, no memory will be allocated or freed by this method.\n@@ -789,0 +825,6 @@\n+     * <p>\n+     * If this segment is {@linkplain MemorySegment#isReadOnly() read-only},\n+     * the returned segment is also {@linkplain MemorySegment#isReadOnly() read-only}.\n+     * <p>\n+     * The returned memory segment shares a region of backing memory with this segment.\n+     * Hence, no memory will be allocated or freed by this method.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.crac.Core;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -334,0 +338,10 @@\n+            @Override\n+            public <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException {\n+                return queue.poll(timeout);\n+            }\n+\n+            @Override\n+            public void wakeupReferenceQueue(ReferenceQueue<?> queue) {\n+                queue.wakeup();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -199,0 +199,23 @@\n+    Reference<? extends T> poll(long timeout) throws InterruptedException {\n+        lock.lock();\n+        try {\n+            Reference<? extends T> r = poll0();\n+            if (r != null) return r;\n+            \/\/ any wake (including spurious) ends the wait\n+            \/\/noinspection ResultOfMethodCallIgnored\n+            notEmpty.await(timeout, TimeUnit.MILLISECONDS);\n+            return poll0();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    void wakeup() {\n+        lock.lock();\n+        try {\n+            notEmpty.signalAll();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import jdk.internal.constant.ConstantUtils;\n@@ -50,1 +49,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -52,2 +50,0 @@\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.DynamicConstantDesc;\n@@ -68,0 +64,1 @@\n+            CD_ClassLoader = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n@@ -69,0 +66,2 @@\n+            CD_ClassNotFoundException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n+            CD_NoClassDefFoundError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n@@ -84,2 +83,3 @@\n-            MTD_Class_array = MethodTypeDescImpl.ofValidated(CD_Class_array),\n-            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, ConstantDescs.CD_String, CD_Class_array),\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDescImpl.ofValidated(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n+            MTD_ClassLoader = MethodTypeDescImpl.ofValidated(CD_ClassLoader),\n+            MTD_Method_String_Class_array = MethodTypeDescImpl.ofValidated(CD_Method, CD_String, CD_Class_array),\n@@ -110,3 +110,3 @@\n-    private static final ProxyMethod HASH_CODE_METHOD;\n-    private static final ProxyMethod EQUALS_METHOD;\n-    private static final ProxyMethod TO_STRING_METHOD;\n+    private static final Method OBJECT_HASH_CODE_METHOD;\n+    private static final Method OBJECT_EQUALS_METHOD;\n+    private static final Method OBJECT_TO_STRING_METHOD;\n@@ -116,3 +116,3 @@\n-            HASH_CODE_METHOD = new ProxyMethod(Object.class.getMethod(\"hashCode\"));\n-            EQUALS_METHOD = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class));\n-            TO_STRING_METHOD = new ProxyMethod(Object.class.getMethod(\"toString\"));\n+            OBJECT_HASH_CODE_METHOD = Object.class.getMethod(\"hashCode\");\n+            OBJECT_EQUALS_METHOD = Object.class.getMethod(\"equals\", Object.class);\n+            OBJECT_TO_STRING_METHOD = Object.class.getMethod(\"toString\");\n@@ -125,1 +125,1 @@\n-    private final List<StackMapFrameInfo.VerificationTypeInfo> throwableStack;\n+    private final List<StackMapFrameInfo.VerificationTypeInfo> classLoaderLocal, throwableStack;\n@@ -127,1 +127,1 @@\n-    private final ClassEntry object, proxy, ute;\n+    private final ClassEntry objectCE, proxyCE, uteCE, classCE;\n@@ -129,3 +129,2 @@\n-    private final InterfaceMethodRefEntry invoke;\n-    private final MethodRefEntry uteInit;\n-    private final DirectMethodHandleDesc bsm;\n+    private final InterfaceMethodRefEntry invocationHandlerInvoke;\n+    private final MethodRefEntry uteInit, classGetMethod, classForName, throwableGetMessage;\n@@ -135,1 +134,1 @@\n-     * Name of proxy class\n+     * ClassEntry for this proxy class\n@@ -137,1 +136,1 @@\n-    private ClassEntry classEntry;\n+    private final ClassEntry thisClassCE;\n@@ -156,0 +155,6 @@\n+    \/**\n+     * Ordinal of next ProxyMethod object added to proxyMethods.\n+     * Indexes are reserved for hashcode(0), equals(1), toString(2).\n+     *\/\n+    private int proxyMethodCount = 3;\n+\n@@ -166,1 +171,1 @@\n-        this.classEntry = cp.classEntry(ReferenceClassDescImpl.ofValidatedBinaryName(className));\n+        this.thisClassCE = cp.classEntry(ReferenceClassDescImpl.ofValidatedBinaryName(className));\n@@ -169,1 +174,3 @@\n-        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_Throwable)));\n+        var throwable = cp.classEntry(CD_Throwable);\n+        this.classLoaderLocal = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(cp.classEntry(CD_ClassLoader)));\n+        this.throwableStack = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(throwable));\n@@ -171,7 +178,10 @@\n-        this.object = cp.classEntry(CD_Object);\n-        this.proxy = cp.classEntry(CD_Proxy);\n-        this.handlerField = cp.fieldRefEntry(proxy, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n-        this.invoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n-        this.ute = cp.classEntry(CD_UndeclaredThrowableException);\n-        this.uteInit = cp.methodRefEntry(ute, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n-        this.bsm = ConstantDescs.ofConstantBootstrap(classEntry.asSymbol(), \"$getMethod\", CD_Method, CD_Class, CD_String, CD_MethodType);\n+        this.objectCE = cp.classEntry(CD_Object);\n+        this.proxyCE = cp.classEntry(CD_Proxy);\n+        this.classCE = cp.classEntry(CD_Class);\n+        this.handlerField = cp.fieldRefEntry(proxyCE, cp.nameAndTypeEntry(NAME_HANDLER_FIELD, CD_InvocationHandler));\n+        this.invocationHandlerInvoke = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n+        this.uteCE = cp.classEntry(CD_UndeclaredThrowableException);\n+        this.uteInit = cp.methodRefEntry(uteCE, cp.nameAndTypeEntry(INIT_NAME, MTD_void_Throwable));\n+        this.classGetMethod = cp.methodRefEntry(classCE, cp.nameAndTypeEntry(\"getMethod\", MTD_Method_String_Class_array));\n+        this.classForName = cp.methodRefEntry(classCE, cp.nameAndTypeEntry(\"forName\", MTD_Class_String_boolean_ClassLoader));\n+        this.throwableGetMessage = cp.methodRefEntry(throwable, cp.nameAndTypeEntry(\"getMessage\", MTD_String));\n@@ -444,3 +454,3 @@\n-        addProxyMethod(HASH_CODE_METHOD);\n-        addProxyMethod(EQUALS_METHOD);\n-        addProxyMethod(TO_STRING_METHOD);\n+        addProxyMethod(new ProxyMethod(OBJECT_HASH_CODE_METHOD, \"m0\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_EQUALS_METHOD, \"m1\"));\n+        addProxyMethod(new ProxyMethod(OBJECT_TO_STRING_METHOD, \"m2\"));\n@@ -467,2 +477,2 @@\n-        return CF_CONTEXT.build(classEntry, cp, clb -> {\n-            clb.withSuperclass(proxy);\n+        return CF_CONTEXT.build(thisClassCE, cp, clb -> {\n+            clb.withSuperclass(proxyCE);\n@@ -475,0 +485,3 @@\n+                    \/\/ add static field for the Method object\n+                    clb.withField(pm.methodFieldName, CD_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+\n@@ -476,1 +489,1 @@\n-                    pm.generateMethod(this, clb);\n+                    pm.generateMethod(clb);\n@@ -480,1 +493,1 @@\n-            generateBootstrapMethod(clb);\n+            generateStaticInitializer(clb);\n@@ -523,1 +536,1 @@\n-                exceptionTypes, fromClass));\n+                exceptionTypes, fromClass, \"m\" + proxyMethodCount++));\n@@ -545,1 +558,2 @@\n-               .invokespecial(cp.methodRefEntry(proxy, cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n+               .invokespecial(cp.methodRefEntry(proxyCE,\n+                   cp.nameAndTypeEntry(INIT_NAME, MTD_void_InvocationHandler)))\n@@ -550,1 +564,6 @@\n-     * Generate CONDY bootstrap method for the proxy class to retrieve {@link Method} instances.\n+     * Generate the class initializer.\n+     * Discussion: Currently, for Proxy to work with SecurityManager,\n+     * we rely on the parameter classes of the methods to be computed\n+     * from Proxy instead of via user code paths like bootstrap method\n+     * lazy evaluation. That might change if we can pass in the live\n+     * Method objects directly..\n@@ -552,12 +571,28 @@\n-    private void generateBootstrapMethod(ClassBuilder clb) {\n-        clb.withMethodBody(bsm.methodName(), bsm.invocationType(), ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC, cob -> {\n-            cob.aload(3) \/\/interface Class\n-               .aload(4) \/\/interface method name String\n-               .aload(5) \/\/interface MethodType\n-               .invokevirtual(CD_MethodType, \"parameterArray\", MTD_Class_array)\n-               .invokevirtual(ConstantDescs.CD_Class, \"getMethod\", MTD_Method_String_Class_array)\n-               .areturn();\n-            Label failLabel = cob.newBoundLabel();\n-            ClassEntry nsme = cp.classEntry(CD_NoSuchMethodError);\n-            cob.exceptionCatch(cob.startLabel(), failLabel, failLabel, CD_NoSuchMethodException)\n-               .new_(nsme)\n+    private void generateStaticInitializer(ClassBuilder clb) {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+            \/\/ Put ClassLoader at local variable index 0, used by\n+            \/\/ Class.forName(String, boolean, ClassLoader) calls\n+            cob.ldc(thisClassCE)\n+               .invokevirtual(cp.methodRefEntry(classCE,\n+                       cp.nameAndTypeEntry(\"getClassLoader\", MTD_ClassLoader)))\n+               .astore(0);\n+            var ts = cob.newBoundLabel();\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    pm.codeFieldInitialization(cob);\n+                }\n+            }\n+            cob.return_();\n+            var c1 = cob.newBoundLabel();\n+            var nsmError = cp.classEntry(CD_NoSuchMethodError);\n+            cob.exceptionCatch(ts, c1, c1, CD_NoSuchMethodException)\n+               .new_(nsmError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(throwableGetMessage)\n+               .invokespecial(cp.methodRefEntry(nsmError, exInit))\n+               .athrow();\n+            var c2 = cob.newBoundLabel();\n+            var ncdfError = cp.classEntry(CD_NoClassDefFoundError);\n+            cob.exceptionCatch(ts, c1, c2, CD_ClassNotFoundException)\n+               .new_(ncdfError)\n@@ -566,5 +601,7 @@\n-               .invokevirtual(cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String))\n-               .invokespecial(cp.methodRefEntry(nsme, exInit))\n-               .athrow()\n-               .with(StackMapTableAttribute.of(List.of(\n-                       StackMapFrameInfo.of(failLabel, List.of(), throwableStack))));\n+               .invokevirtual(throwableGetMessage)\n+               .invokespecial(cp.methodRefEntry(ncdfError, exInit))\n+               .athrow();\n+            cob.with(StackMapTableAttribute.of(List.of(\n+                       StackMapFrameInfo.of(c1, classLoaderLocal, throwableStack),\n+                       StackMapFrameInfo.of(c2, classLoaderLocal, throwableStack))));\n+\n@@ -590,1 +627,1 @@\n-                               .ldc(proxy)\n+                               .ldc(proxyCE)\n@@ -616,1 +653,1 @@\n-    private static class ProxyMethod {\n+    private class ProxyMethod {\n@@ -623,0 +660,1 @@\n+        private final String methodFieldName;\n@@ -624,0 +662,1 @@\n+        private final FieldRefEntry methodField;\n@@ -627,1 +666,1 @@\n-                            Class<?> fromClass) {\n+                            Class<?> fromClass, String methodFieldName) {\n@@ -634,0 +673,3 @@\n+            this.methodFieldName = methodFieldName;\n+            this.methodField = cp.fieldRefEntry(thisClassCE,\n+                cp.nameAndTypeEntry(methodFieldName, CD_Method));\n@@ -642,1 +684,1 @@\n-        private ProxyMethod(Method method) {\n+        private ProxyMethod(Method method, String methodFieldName) {\n@@ -645,1 +687,1 @@\n-                 method.getSharedExceptionTypes(), method.getDeclaringClass());\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n@@ -651,2 +693,1 @@\n-        private void generateMethod(ProxyGenerator pg, ClassBuilder clb) {\n-            var cp = pg.cp;\n+        private void generateMethod(ClassBuilder clb) {\n@@ -664,7 +705,4 @@\n-                        cob.aload(0)\n-                           .getfield(pg.handlerField)\n-                           .aload(0)\n-                           .ldc(DynamicConstantDesc.of(pg.bsm,\n-                                toClassDesc(fromClass),\n-                                method.getName(),\n-                                desc));\n+                        cob.aload(cob.receiverSlot())\n+                           .getfield(handlerField)\n+                           .aload(cob.receiverSlot())\n+                           .getstatic(methodField);\n@@ -674,1 +712,1 @@\n-                               .anewarray(pg.object);\n+                               .anewarray(objectCE);\n@@ -685,1 +723,1 @@\n-                        cob.invokeinterface(pg.invoke);\n+                        cob.invokeinterface(invocationHandlerInvoke);\n@@ -701,1 +739,1 @@\n-                               .new_(pg.ute)\n+                               .new_(uteCE)\n@@ -704,1 +742,1 @@\n-                               .invokespecial(pg.uteInit)\n+                               .invokespecial(uteInit)\n@@ -707,2 +745,2 @@\n-                                       StackMapFrameInfo.of(c1, List.of(), pg.throwableStack),\n-                                       StackMapFrameInfo.of(c2, List.of(), pg.throwableStack))));\n+                                    StackMapFrameInfo.of(c1, List.of(), throwableStack),\n+                                    StackMapFrameInfo.of(c2, List.of(), throwableStack))));\n@@ -723,1 +761,1 @@\n-                cob.invokestatic(prim.wrapperMethodRef(cob.constantPool()));\n+                cob.invokestatic(prim.wrapperMethodRef(cp));\n@@ -739,1 +777,1 @@\n-                   .invokevirtual(prim.unwrapMethodRef(cob.constantPool()))\n+                   .invokevirtual(prim.unwrapMethodRef(cp))\n@@ -747,0 +785,51 @@\n+        \/**\n+         * Generate code for initializing the static field that stores\n+         * the Method object for this proxy method. A class loader is\n+         * anticipated at local variable index 0.\n+         * The generated code must be run in an AccessController.doPrivileged\n+         * block if a SecurityManager is present, as otherwise the code\n+         * cannot pass {@code null} ClassLoader to forName.\n+         *\/\n+        private void codeFieldInitialization(CodeBuilder cob) {\n+            var cp = cob.constantPool();\n+            codeClassForName(cob, fromClass);\n+\n+            cob.ldc(method.getName())\n+               .loadConstant(parameterTypes.length)\n+               .anewarray(classCE);\n+\n+            \/\/ Construct an array with the parameter types mapping primitives to Wrapper types\n+            for (int i = 0; i < parameterTypes.length; i++) {\n+                cob.dup()\n+                   .loadConstant(i);\n+                if (parameterTypes[i].isPrimitive()) {\n+                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n+                    cob.getstatic(prim.typeFieldRef(cp));\n+                } else {\n+                    codeClassForName(cob, parameterTypes[i]);\n+                }\n+                cob.aastore();\n+            }\n+            \/\/ lookup the method\n+            cob.invokevirtual(classGetMethod)\n+               .putstatic(methodField);\n+        }\n+\n+        \/*\n+         * =============== Code Generation Utility Methods ===============\n+         *\/\n+\n+        \/**\n+         * Generate code to invoke the Class.forName with the name of the given\n+         * class to get its Class object at runtime.  The code is written to\n+         * the supplied stream.  Note that the code generated by this method\n+         * may cause the checked ClassNotFoundException to be thrown. A class\n+         * loader is anticipated at local variable index 0.\n+         *\/\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+            cob.ldc(cl.getName())\n+               .iconst_0() \/\/ false\n+               .aload(0)\/\/ classLoader\n+               .invokestatic(classForName);\n+        }\n+\n@@ -813,0 +902,4 @@\n+\n+        public FieldRefEntry typeFieldRef(ConstantPoolBuilder cp) {\n+            return cp.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":170,"deletions":77,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.crac.JDKSocketResource;\n+import sun.nio.ch.Net;\n+\n@@ -58,0 +61,23 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() {\n+            disconnect();\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n@@ -61,0 +63,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -239,0 +243,6 @@\n+ * @crac This class holds a cache of resolved hostname-address pairs;\n+ * this cache is wiped out before checkpoint. Therefore, lookups after restore\n+ * will cause name address resolution.\n+ * This ensures that the addresses are up-to-date in the environment where\n+ * the process is restored.\n+ *\n@@ -357,0 +367,3 @@\n+    \/* Resource registration uses weak references; we need to keep it locally. *\/\n+    private static final JDKResource checkpointListener;\n+\n@@ -393,0 +406,14 @@\n+        \/\/ DNS cache is cleared before the checkpoint; application restored at a later point\n+        \/\/ or in a different environment should query DNS again.\n+        checkpointListener = new JDKResource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                cache.clear();\n+                expirySet.clear();\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            }\n+        };\n+        Core.Priority.NORMAL.getContext().register(checkpointListener);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -32,0 +33,1 @@\n+import java.io.FileDescriptor;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -36,0 +37,1 @@\n+import sun.nio.ch.Net;\n@@ -75,0 +77,23 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return new InetSocketAddress(address, port);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.util.ArraysSupport;\n@@ -709,3 +708,0 @@\n-    public int hashCode() {\n-        return ArraysSupport.hashCode(hb, ix(position()), remaining(), 1);\n-    }\n@@ -740,3 +736,0 @@\n-    public int hashCode() {\n-        return ArraysSupport.hashCode(hb, ix(position()), remaining(), 1);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -212,0 +212,4 @@\n+     *\n+     * @crac Instances created by this constructor are automatically reseeded\n+     * after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n@@ -254,0 +258,4 @@\n+     * @crac Instances created by this constructor are <strong>not<\/strong>\n+     * reseeded after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n+     *\n@@ -355,0 +363,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -402,0 +412,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -446,0 +458,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -493,0 +507,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -550,0 +566,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -602,0 +620,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -324,0 +324,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n@@ -368,0 +373,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/Timer.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -150,0 +150,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n@@ -189,0 +194,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledExecutorService.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,1 +296,1 @@\n-     * @see Gatherer#finisher()\n+     * @see Gatherer#combiner()\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Gatherer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -66,0 +67,1 @@\n+import jdk.internal.crac.Core;\n@@ -836,0 +838,8 @@\n+\n+        public void beforeCheckpoint() {\n+            if (zsrc != null) {\n+                synchronized (zsrc) {\n+                    zsrc.beforeCheckpoint();\n+                }\n+            }\n+        }\n@@ -1132,0 +1142,4 @@\n+    private synchronized void beforeCheckpoint() {\n+        res.beforeCheckpoint();\n+    }\n+\n@@ -1175,2 +1189,5 @@\n-\n-             }\n+                @Override\n+                public void beforeCheckpoint(ZipFile zip) {\n+                    zip.beforeCheckpoint();\n+                }\n+            }\n@@ -2053,0 +2070,13 @@\n+\n+        public void beforeCheckpoint() {\n+            synchronized (zfile) {\n+                FileDescriptor fd = null;\n+                try {\n+                    fd = zfile.getFD();\n+                } catch (IOException e) {\n+                }\n+                if (fd != null) {\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+                }\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * This exception works as an aggregate for all errors found during checkpoint;\n+ * these are recorded as {@linkplain #getSuppressed() suppressed exceptions}.\n+ * The exception does not have any own message, cause nor collects stack trace.\n+ *\/\n+public final class CheckpointException extends Exception {\n+    private static final long serialVersionUID = 6859967688386143096L;\n+\n+    \/**\n+     * Creates a {@code CheckpointException}.\n+     *\/\n+    public CheckpointException() {\n+        super(null, null, true, false);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/CheckpointException.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * A {@code Resource} that allows other {@code Resource}s to be registered with it.\n+ *\n+ * <p>{@code Context} implementation overrides {@code beforeCheckpoint} and {@code afterRestore}, defining how the notification about checkpoint and restore will be distributed by the {@code Context} hierarchy.\n+ *\n+ * <p>A {@code Context} implementor is encouraged to respect properties of the global {@code Context}.\n+ *\n+ * @param <R> Resource\n+ *\/\n+public abstract class Context<R extends Resource> implements Resource {\n+\n+    \/** Creates a {@code Context}.\n+     *\/\n+    protected Context() {\n+    }\n+\n+    @Override\n+    public abstract void beforeCheckpoint(Context<? extends Resource> context)\n+            throws CheckpointException;\n+\n+    @Override\n+    public abstract void afterRestore(Context<? extends Resource> context)\n+            throws RestoreException;\n+\n+    \/**\n+     * Registers a {@code Resource} with this {@code Context}.\n+     *\n+     * @param resource {@code Resource} to be registered.\n+     * @throws NullPointerException if {@code resource} is {@code null}\n+     *\/\n+    public abstract void register(R resource);\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Context.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+class ContextWrapper extends Context<Resource> {\n+    private final jdk.crac.Context<jdk.crac.Resource> context;\n+\n+    public ContextWrapper(jdk.crac.Context<jdk.crac.Resource> context) {\n+        this.context = context;\n+    }\n+\n+    private static jdk.crac.Context<? extends jdk.crac.Resource> convertContext(\n+            Context<? extends Resource> context) {\n+        return context instanceof ContextWrapper ?\n+                ((ContextWrapper)context).context :\n+                null;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context)\n+            throws CheckpointException {\n+        try {\n+            this.context.beforeCheckpoint(convertContext(context));\n+        } catch (jdk.crac.CheckpointException e) {\n+            CheckpointException newException = new CheckpointException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context)\n+            throws RestoreException {\n+        try {\n+            this.context.afterRestore(convertContext(context));\n+        } catch (jdk.crac.RestoreException e) {\n+            RestoreException newException = new RestoreException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        }\n+    }\n+\n+    @Override\n+    public void register(Resource r) {\n+        ResourceWrapper wrapper = new ResourceWrapper(this, r);\n+        context.register(wrapper);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ContextWrapper[\" + context.toString() + \"]\";\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/ContextWrapper.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+import jdk.crac.impl.BlockingOrderedContext;\n+import jdk.crac.impl.OrderedContext;\n+\n+\/**\n+ * The coordination service.\n+ *\/\n+public class Core {\n+\n+    \/** This class is not instantiable. *\/\n+    private Core() {\n+    }\n+\n+    private static final Context<Resource> globalContext = new ContextWrapper(\n+        jdk.crac.impl.GlobalContext.createGlobalContextImpl());\n+\n+    static {\n+        jdk.crac.Core.getGlobalContext().register(new ResourceWrapper(null, globalContext));\n+    }\n+\n+    \/**\n+     * Gets the global {@code Context} for checkpoint\/restore notifications.\n+     *\n+     * @return the global {@code Context}\n+     *\/\n+    public static Context<Resource> getGlobalContext() {\n+        return globalContext;\n+    }\n+\n+    \/**\n+     * Requests checkpoint and returns upon a successful restore.\n+     * May throw an exception if the checkpoint or restore are unsuccessful.\n+     *\n+     * @throws CheckpointException if an exception occured during checkpoint\n+     * notification and the execution continues in the original Java instance.\n+     * @throws RestoreException if an exception occured during restore\n+     * notification and execution continues in a new Java instance.\n+     * @throws UnsupportedOperationException if checkpoint\/restore is not\n+     * supported, no notification performed and the execution continues in\n+     * the original Java instance.\n+     *\/\n+    public static void checkpointRestore() throws\n+            CheckpointException,\n+            RestoreException {\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (jdk.crac.CheckpointException e) {\n+            CheckpointException newException = new CheckpointException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        } catch (jdk.crac.RestoreException e) {\n+            RestoreException newException = new RestoreException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * An interface for receiving checkpoint\/restore notifications.\n+ *\n+ * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * implements this interface, and the object created with that class is\n+ * registered with a {@code Context}, using {@code register} method.\n+ *\/\n+public interface Resource {\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about checkpoint.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void beforeCheckpoint(Context<? extends Resource> context) throws Exception;\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about restore.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void afterRestore(Context<? extends Resource> context) throws Exception;\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Resource.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.WeakHashMap;\n+\n+class ResourceWrapper extends WeakReference<Resource> implements jdk.crac.Resource {\n+    private static WeakHashMap<Resource, ResourceWrapper> weakMap = new WeakHashMap<>();\n+\n+    \/\/ Create strong reference to avoid losing the Resource.\n+    \/\/ It's set unconditionally in beforeCheckpoint and cleaned in afterRestore\n+    \/\/ (latter is called regardless of beforeCheckpoint result).\n+    private Resource strongRef;\n+\n+    private final Context<Resource> context;\n+\n+    public ResourceWrapper(Context<Resource> context, Resource resource) {\n+        super(resource);\n+        weakMap.put(resource, this);\n+        strongRef = null;\n+        this.context = context;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ResourceWrapper[\" + get().toString() + \"]\";\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(jdk.crac.Context<? extends jdk.crac.Resource> context)\n+            throws Exception {\n+        Resource r = get();\n+        strongRef = r;\n+        if (r != null) {\n+            try {\n+                r.beforeCheckpoint(this.context);\n+            } catch (CheckpointException e) {\n+                Exception newException = new jdk.crac.CheckpointException();\n+                for (Throwable t : e.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                throw newException;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(jdk.crac.Context<? extends jdk.crac.Resource> context) throws Exception {\n+        Resource r = get();\n+        strongRef = null;\n+        if (r != null) {\n+            try {\n+                r.afterRestore(this.context);\n+            } catch (RestoreException e) {\n+                Exception newException = new jdk.crac.RestoreException();\n+                for (Throwable t : e.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                throw newException;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/ResourceWrapper.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * This exception works as an aggregate for all errors found during checkpoint;\n+ * these are recorded as {@linkplain #getSuppressed() suppressed exceptions}.\n+ * The exception does not have any own message, cause nor collects stack trace.\n+ *\/\n+public final class RestoreException extends Exception {\n+    private static final long serialVersionUID = -4091592505524280559L;\n+\n+    \/**\n+     * Creates a {@code RestoreException}.\n+     *\/\n+    public RestoreException() {\n+        super(null, null, true, false);\n+    }\n+}\n+\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/RestoreException.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides explicit coordination with a checkpoint\/restore mechanism.\n+ * A checkpoint\/restore implementation may capture process or application state images for later continuation.\n+ * Coordination allows application code to prepare for a checkpoint and to adapt to changes in the execution environment after a restore.\n+ * <p>\n+ * Successful checkpointing and restoration may require that no checkpointed state exist that might not be validly reproducible when\n+restoring instances from the image.\n+ * Coordination enables application to proactively discard problematic state ahead of checkpointing, and to reestablish needed state upon restoration.\n+ * A Java implementation may provide detection of some subsets of state that are known to prevent successful checkpoints.\n+ * <p>\n+ * For example, a state of opened file descriptors or socket may be impossible to store in the image.\n+ * The implementation may detect such resources and then prevent checkpoint.\n+ * The application must then close file descriptors and sockets to be successfully checkpointed.\n+ * Files and sockets may be opened back after restore, then the application is responsible for processing possible exceptions.\n+ * <p>\n+ * {@link Resource} is an interface for receiving checkpoint\/restore notifications.\n+ * In order to be notified, {@code Resource} needs to be registered in a {@link Context}.\n+ * {@link Core} is a core interface for coordination. It provides the global {@code Context} which can be used as default choice.\n+ * The global {@code Context} have properties listed below, one can define a custom {@code Context} and register it with the global one.\n+ * {@code Core} has also a method to request checkpoint.\n+ * <p>\n+ * Methods of {@code Resource} are invoked as a notification of checkpoint and restore.\n+ * If a {@code Resource} is incapable to process notification, corresponding method throws an exception.\n+ * The global {@code Context} ensures that exceptions are propagated to a requester of checkpoint\/restore.\n+ * <p>\n+ * {@code Context} is a {@code Resource}, that allows other {@code Resource}s to be registered with it.\n+ * {@code Context} defines how {@code Resource}s are notified and may provide different guarantees compared to the global {@code Context}, such as order of notification.\n+ * A class may extend {@code Context} and define custom rules of notification processing by overriding {@code Resource} method.\n+ * Since a {@code Context} may be registered with other {@code Context}, they form a {@code Context} hierarchy.\n+ * <p>\n+ * Checkpoint can requested by {@code Core.checkpointRestore} or by some other way.\n+ * Then checkpoint notification of the global {@code Context} is performed.\n+ * If the global {@code Context} have not thrown {@code CheckpointException}, the current Java instance is used to create the image in a platform dependent way.\n+ * The current instance is terminated.\n+ * Later, a new instance is created by some means, for example via Java launcher in a special mode.\n+ * The new instance is started at the point where the image was created, it is followed by the restore notification.\n+ * Exceptions from restore notification are provided as suppressed ones by a {@code RestoreException} (in a sense of {@link Throwable#addSuppressed}).\n+ * <p>\n+ * If the global {@code Context} throws an exception during checkpoint notification then restore notificaion starts immediately without the image creation.\n+ * In this case, exceptions from checkpoint and restore notifications are provided as suppressed ones by {@code CheckpointException}.\n+ * <p>\n+ * {@code UnsupportedOperationException} is thrown if the service is not supported.\n+ * No notification is performed in this case.\n+ * <h2>Global Context Properties<\/h2>\n+ * Java Runtime maintains the global {@code Context} with following properties.\n+ * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n+ * <ul>\n+ * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n+ * <\/li>\n+ * <li>Order of checkpoint notification is the reverse order of registration.\n+ * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n+ * <\/li>\n+ * <li>For single {@code Resource} registered in this {@code Context}:\n+ * <ul>\n+ *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n+ *   <\/li>\n+ *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n+ *   <\/li>\n+ *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ * <\/ul>\n+ * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * @since TBD\n+ *\/\n+\n+package javax.crac;\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/package-info.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * This exception works as an aggregate for all errors found during checkpoint;\n+ * these are recorded as {@linkplain #getSuppressed() suppressed exceptions}.\n+ * The exception does not have any own message, cause nor collects stack trace.\n+ *\/\n+public final class CheckpointException extends Exception {\n+    private static final long serialVersionUID = 8879167591426115859L;\n+\n+    \/**\n+     * Creates a {@code CheckpointException}.\n+     *\/\n+    public CheckpointException() {\n+        super(null, null, true, false);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/CheckpointException.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * A {@code Resource} that allows other {@code Resource}s to be registered with it.\n+ *\n+ * <p>{@code Context} implementation overrides {@code beforeCheckpoint} and {@code afterRestore}, defining how the notification about checkpoint and restore will be distributed by the {@code Context} hierarchy.\n+ *\n+ * <p>A {@code Context} implementor is encouraged to respect properties of the global {@code Context}.\n+ *\/\n+public abstract class Context<R extends Resource> implements Resource {\n+\n+    \/** Creates a {@code Context}.\n+     *\/\n+    protected Context() {\n+    }\n+\n+    @Override\n+    public abstract void beforeCheckpoint(Context<? extends Resource> context)\n+            throws CheckpointException;\n+\n+    @Override\n+    public abstract void afterRestore(Context<? extends Resource> context)\n+            throws RestoreException;\n+\n+    \/**\n+     * Registers a {@code Resource} with this {@code Context}.\n+     *\n+     * @param resource {@code Resource} to be registered.\n+     * @throws NullPointerException if {@code resource} is {@code null}\n+     *\/\n+    public abstract void register(R resource);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Context.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,324 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+import jdk.crac.impl.*;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.ClaimedFDs;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.LoggerContainer;\n+import sun.security.action.GetBooleanAction;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * The coordination service.\n+ *\/\n+public class Core {\n+    private static final int JVM_CHECKPOINT_OK    = 0;\n+    private static final int JVM_CHECKPOINT_ERROR = 1;\n+    private static final int JVM_CHECKPOINT_NONE  = 2;\n+\n+    private static final int JVM_CR_FAIL = 0;\n+    private static final int JVM_CR_FAIL_FILE = 1;\n+    private static final int JVM_CR_FAIL_SOCK = 2;\n+    private static final int JVM_CR_FAIL_PIPE = 3;\n+\n+    private static final long JCMD_STREAM_NULL = 0;\n+    private static native Object[] checkpointRestore0(int[] fdArr, Object[] objArr, boolean dryRun, long jcmdStream);\n+    private static final Object checkpointRestoreLock = new Object();\n+    private static boolean checkpointInProgress = false;\n+\n+    private static class FlagsHolder {\n+        private FlagsHolder() {}\n+        public static final boolean TRACE_STARTUP_TIME =\n+            GetBooleanAction.privilegedGetProperty(\"jdk.crac.trace-startup-time\");\n+    }\n+\n+    private static final Context<Resource> globalContext = GlobalContext.createGlobalContextImpl();\n+\n+    private static class ReferenceHandlerResource implements JDKResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            System.gc();\n+            \/\/ TODO ensure GC done processing all References\n+            while (SharedSecrets.getJavaLangRefAccess().waitForReferenceProcessing());\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+\n+        private static ReferenceHandlerResource resource = new ReferenceHandlerResource();\n+\n+        static {\n+            jdk.internal.crac.Core.Priority.REFERENCE_HANDLER.getContext().register(resource);\n+        }\n+\n+        \/**\n+         * Performs one-time registration of the Reference handling resource\n+         *\/\n+        public static void register() {\n+            \/\/ nothing to do: the resource registered in the static initializer\n+        }\n+    }\n+\n+    \/** This class is not instantiable. *\/\n+    private Core() {\n+    }\n+\n+    private static void translateJVMExceptions(int[] codes, String[] messages,\n+                                               ExceptionHolder<CheckpointException> exception) {\n+        assert codes.length == messages.length;\n+        \/\/ When the CR engine fails (e.g. due to permissions, missing binaries...)\n+        \/\/ there are no messages recorded, but the user would end up with an empty\n+        \/\/ CheckpointException without stack trace nor message.\n+        if (codes.length == 0) {\n+            exception.handle(new RuntimeException(\"Native checkpoint failed.\"));\n+        }\n+\n+        for (int i = 0; i < codes.length; ++i) {\n+            Exception ex = switch (codes[i]) {\n+                case JVM_CR_FAIL_FILE -> new CheckpointOpenFileException(messages[i], null);\n+                case JVM_CR_FAIL_SOCK -> new CheckpointOpenSocketException(messages[i], null);\n+                case JVM_CR_FAIL_PIPE -> new CheckpointOpenResourceException(messages[i], null);\n+                default -> new CheckpointOpenResourceException(messages[i], null);\n+            };\n+            exception.handle(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Gets the global {@code Context} for checkpoint\/restore notifications.\n+     *\n+     * @return the global {@code Context}\n+     *\/\n+    public static Context<Resource> getGlobalContext() {\n+        return globalContext;\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void checkpointRestore1(long jcmdStream) throws\n+            CheckpointException,\n+            RestoreException {\n+        final ExceptionHolder<CheckpointException> checkpointException = new ExceptionHolder<>(CheckpointException::new);\n+\n+        \/\/ Register the resource here late, to avoid early registration\n+        \/\/ during JDK initialization, e.g. if performed during j.l.r.Reference\n+        \/\/ initialization.\n+        ReferenceHandlerResource.register();\n+\n+        \/\/ FIXME: log something to complete logger initialization:\n+        \/\/ - call sites in logger formatters.\n+        \/\/ - FileDescriptors for resources (sun.util.calendar.ZoneInfoFile)\n+        LoggerContainer.info(\"Starting checkpoint\");\n+        LoggerContainer.debug(\"at epoch:{0}\", System.currentTimeMillis());\n+\n+        ClaimedFDs claimedFDs = new ClaimedFDs();\n+\n+        jdk.internal.crac.Core.setClaimedFDs(claimedFDs);\n+        try {\n+            globalContext.beforeCheckpoint(null);\n+        } catch (CheckpointException ce) {\n+            checkpointException.handle(ce);\n+        }\n+        jdk.internal.crac.Core.setClaimedFDs(null);\n+\n+        List<ClaimedFDs.Descriptor> claimedList = claimedFDs.getClaimedFds();\n+        int[] fdArr = new int[claimedList.size()];\n+        LoggerContainer.debug(\"Claimed open file descriptors:\");\n+        for (int i = 0; i < claimedList.size(); ++i) {\n+            ClaimedFDs.Descriptor desc = claimedList.get(i);\n+            LoggerContainer.debug(\"\\t{0} {1} {2}\", desc.getFd(), desc.getClaimer(), desc.getExceptionSupplier());\n+            fdArr[i] = desc.getFd();\n+\n+            Supplier<Exception> exceptionSupplier = desc.getExceptionSupplier();\n+            if (exceptionSupplier != null) {\n+                Exception e = exceptionSupplier.get();\n+                checkpointException.handle(e);\n+            }\n+        }\n+\n+        final Object[] bundle = checkpointRestore0(fdArr, null, checkpointException.hasException(), jcmdStream);\n+        final int retCode = (null == bundle) ? JVM_CHECKPOINT_NONE : (Integer)bundle[0];\n+        final String newArguments = (null == bundle) ? null : (String)bundle[1];\n+        final String[] newProperties = (null == bundle) ? null : (String[])bundle[2];\n+        final int[] codes = (null == bundle) ? null : (int[])bundle[3];\n+        final String[] messages = (null == bundle) ? null : (String[])bundle[4];\n+\n+        if (FlagsHolder.TRACE_STARTUP_TIME) {\n+            System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore\");\n+        }\n+\n+        if (retCode != JVM_CHECKPOINT_OK) {\n+            switch (retCode) {\n+                case JVM_CHECKPOINT_ERROR -> translateJVMExceptions(codes, messages, checkpointException);\n+                case JVM_CHECKPOINT_NONE -> checkpointException.handle(new RuntimeException(\"C\/R is not configured\"));\n+                default ->                  checkpointException.handle(new RuntimeException(\"Unknown C\/R result: \" + retCode));\n+            }\n+        }\n+\n+        if (newProperties != null && newProperties.length > 0) {\n+            \/\/ Do not use lambda here since lambda will introduce registration\n+            \/\/ during checkpoint, which may cause dead loop.\n+            Arrays.stream(newProperties).map(new Function<String, String[]>() {\n+                @Override\n+                public String[] apply(String propStr) {\n+                    return propStr.split(\"=\", 2);\n+                }\n+            }).forEach(new Consumer<String[]>() {\n+                @Override\n+                public void accept(String[] pair) {\n+                    AccessController.doPrivileged(\n+                            new PrivilegedAction<String>() {\n+                                @Override\n+                                public String run() {\n+                                    return System.setProperty(pair[0], pair.length == 2 ? pair[1] : \"\");\n+                                }\n+                            });\n+                }\n+            });\n+        }\n+\n+        ExceptionHolder<RestoreException> restoreException = new ExceptionHolder<>(RestoreException::new);\n+        try {\n+            globalContext.afterRestore(null);\n+        } catch (RestoreException re) {\n+            if (checkpointException.hasException()) {\n+                checkpointException.resuppress(re);\n+            } else {\n+                restoreException.handle(re);\n+            }\n+        }\n+\n+        if (newArguments != null && newArguments.length() > 0) {\n+            String[] args = newArguments.split(\" \");\n+            if (args.length > 0) {\n+                try {\n+                    Method newMain = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n+                       @Override\n+                       public Method run() throws Exception {\n+                           Class < ?> newMainClass = Class.forName(args[0], false,\n+                               ClassLoader.getSystemClassLoader());\n+                           Method newMain = newMainClass.getDeclaredMethod(\"main\",\n+                               String[].class);\n+                           newMain.setAccessible(true);\n+                           return newMain;\n+                       }\n+                    });\n+                    newMain.invoke(null,\n+                        (Object)Arrays.copyOfRange(args, 1, args.length));\n+                } catch (PrivilegedActionException |\n+                         InvocationTargetException |\n+                         IllegalAccessException e) {\n+                    assert !checkpointException.hasException() :\n+                        \"should not have new arguments\";\n+                    restoreException.handle(e);\n+                }\n+            }\n+        }\n+\n+        assert !checkpointException.hasException() || !restoreException.hasException();\n+        checkpointException.throwIfAny();\n+        restoreException.throwIfAny();\n+    }\n+\n+    \/**\n+     * Requests checkpoint and returns upon a successful restore.\n+     * May throw an exception if the checkpoint or restore are unsuccessful.\n+     *\n+     * @throws CheckpointException if an exception occured during checkpoint\n+     * notification and the execution continues in the original Java instance.\n+     * @throws RestoreException if an exception occured during restore\n+     * notification and execution continues in a new Java instance.\n+     * @throws UnsupportedOperationException if checkpoint\/restore is not\n+     * supported, no notification performed and the execution continues in\n+     * the original Java instance.\n+     *\/\n+    public static void checkpointRestore() throws\n+            CheckpointException,\n+            RestoreException {\n+        checkpointRestore(JCMD_STREAM_NULL);\n+    }\n+\n+    @SuppressWarnings(\"try\")\n+    private static void checkpointRestore(long jcmdStream) throws\n+            CheckpointException,\n+            RestoreException {\n+        \/\/ checkpointRestoreLock protects against the simultaneous\n+        \/\/ call of checkpointRestore from different threads.\n+        synchronized (checkpointRestoreLock) {\n+            \/\/ checkpointInProgress protects against recursive\n+            \/\/ checkpointRestore from resource's\n+            \/\/ beforeCheckpoint\/afterRestore methods\n+            if (checkpointInProgress) {\n+                CheckpointException ex = new CheckpointException();\n+                ex.addSuppressed(new IllegalStateException(\"Recursive checkpoint is not allowed\"));\n+                throw ex;\n+            }\n+\n+            try (@SuppressWarnings(\"unused\") var keepAlive = new KeepAlive()) {\n+                checkpointInProgress = true;\n+                checkpointRestore1(jcmdStream);\n+            } finally {\n+                if (FlagsHolder.TRACE_STARTUP_TIME) {\n+                    System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore-finish\");\n+                }\n+                checkpointInProgress = false;\n+            }\n+        }\n+    }\n+\n+    \/* called by VM *\/\n+    private static String checkpointRestoreInternal(long jcmdStream) {\n+        try {\n+            checkpointRestore(jcmdStream);\n+        } catch (CheckpointException e) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+            e.printStackTrace(pw);\n+            return sw.toString();\n+        } catch (RestoreException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":324,"deletions":0,"binary":false,"changes":324,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * An interface for receiving checkpoint\/restore notifications.\n+ *\n+ * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * implements this interface, and the object created with that class is\n+ * registered with a {@code Context}, using {@code register} method.\n+ *\/\n+public interface Resource {\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about checkpoint.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void beforeCheckpoint(Context<? extends Resource> context) throws Exception;\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about restore.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void afterRestore(Context<? extends Resource> context) throws Exception;\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Resource.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * This exception works as an aggregate for all errors found during restore;\n+ * these are recorded as {@linkplain #getSuppressed() suppressed exceptions}.\n+ * The exception does not have any own message, cause nor collects stack trace.\n+ *\/\n+public final class RestoreException extends Exception {\n+    private static final long serialVersionUID = 5235124335683732665L;\n+\n+    \/**\n+     * Creates a {@code RestoreException}.\n+     *\/\n+    public RestoreException() {\n+        super(null, null, true, false);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/RestoreException.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+import jdk.crac.*;\n+import jdk.internal.crac.LoggerContainer;\n+\n+import java.util.List;\n+\n+\/**\n+ * An abstract context with few utilities.\n+ * @param <R> Type of Resource managed by the context.\n+ *\/\n+public abstract class AbstractContext<R extends Resource> extends Context<R> {\n+    protected abstract List<R> checkpointSnapshot();\n+    protected abstract List<R> restoreSnapshot();\n+\n+    protected void invokeBeforeCheckpoint(Resource resource) throws Exception {\n+        LoggerContainer.debug(\"beforeCheckpoint {0}\", resource);\n+        resource.beforeCheckpoint(this);\n+    }\n+\n+    protected void invokeAfterRestore(Resource resource) throws Exception {\n+        LoggerContainer.debug(\"afterRestore {0}\", resource);\n+        resource.afterRestore(this);\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        ExceptionHolder<CheckpointException> checkpointException =\n+            new ExceptionHolder<>(CheckpointException::new);\n+        List<R> resources = checkpointSnapshot();\n+        for (R r : resources) {\n+            try {\n+                invokeBeforeCheckpoint(r);\n+            } catch (Exception e) {\n+                checkpointException.handle(e);\n+            }\n+        }\n+        checkpointException.throwIfAny();\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        ExceptionHolder<RestoreException> restoreException =\n+            new ExceptionHolder<>(RestoreException::new);\n+        List<R> resources = restoreSnapshot();\n+        for (R r : resources) {\n+            try {\n+                invokeAfterRestore(r);\n+            } catch (Exception e) {\n+                restoreException.handle(e);\n+            }\n+        }\n+        restoreException.throwIfAny();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContext.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+import jdk.internal.crac.LoggerContainer;\n+\n+public class BlockingOrderedContext<R extends Resource> extends OrderedContext<R> {\n+    private boolean checkpointing = false;\n+\n+    \/\/ This method has particularly verbose name to stick out in thread dumps\n+    \/\/ when the registration leads to a deadlock.\n+    private void waitWhileCheckpointIsInProgress(R resource) {\n+        if (Thread.currentThread().isInterrupted()) {\n+            \/\/ FIXME this block effectively translates interrupted status to RuntimeException\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" not waiting in \" + this +\n+                \" to register \" + resource + \"; the thread has already been interrupted.\");\n+            \/\/ We won't cause IllegalStateException because this is not an unexpected state\n+            \/\/ from the point of CRaC - it probably tried to register some code before.\n+            throw new RuntimeException(\"Interrupted thread tried to block in registration of \" + resource + \" in \" + this);\n+        }\n+        LoggerContainer.debug(Thread.currentThread().getName() + \" waiting in \" + this + \" to register \" + resource);\n+        try {\n+            wait();\n+        } catch (InterruptedException e) {\n+            \/\/ FIXME there should be no interrupt once we've got interrupted\n+            Thread.currentThread().interrupt();\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" interrupted waiting in \" + this +\n+                \" to register \" + resource);\n+            throw new RuntimeException(\"Interrupted while trying to register \" + resource + \" in \" + this, e);\n+        }\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        synchronized (this) {\n+            checkpointing = true;\n+        }\n+        super.beforeCheckpoint(context);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        \/\/ unblock all registrations before running afterRestore()'s\n+        synchronized (this) {\n+            checkpointing = false;\n+            notifyAll();\n+        }\n+        super.afterRestore(context);\n+    }\n+\n+    @Override\n+    public void register(R resource) {\n+        synchronized (this) {\n+            while (checkpointing) {\n+                waitWhileCheckpointIsInProgress(resource);\n+            }\n+            super.register(resource);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/BlockingOrderedContext.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+public class CheckpointOpenFileException extends\n+        CheckpointOpenResourceException {\n+    private static final long serialVersionUID = 4696394478625532246L;\n+\n+    public CheckpointOpenFileException(String details, Throwable cause) {\n+        super(details, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenFileException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+public class CheckpointOpenResourceException extends Exception {\n+    private static final long serialVersionUID = -3858375642480846931L;\n+\n+    public CheckpointOpenResourceException(String details, Throwable cause) {\n+        super(details, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenResourceException.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+public class CheckpointOpenSocketException extends\n+        CheckpointOpenResourceException {\n+    private static final long serialVersionUID = 4778540502218641776L;\n+\n+    public CheckpointOpenSocketException(String details, Throwable cause) {\n+        super(details, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenSocketException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+package jdk.crac.impl;\n+\n+import java.util.function.Supplier;\n+\n+public class ExceptionHolder<E extends Exception> {\n+    E exception = null;\n+    final Supplier<E> constructor;\n+\n+    public ExceptionHolder(Supplier<E> constructor) {\n+        this.constructor = constructor;\n+    }\n+\n+    public E get() {\n+        if (exception == null) {\n+            exception = constructor.get();\n+        }\n+        return exception;\n+    }\n+\n+    public void throwIfAny() throws E {\n+        if (exception != null) {\n+            throw exception;\n+        }\n+    }\n+\n+    public boolean hasException() {\n+        return exception != null;\n+    }\n+\n+    public void resuppress(Exception e) {\n+        E exception = get();\n+        for (Throwable t : e.getSuppressed()) {\n+            exception.addSuppressed(t);\n+        }\n+    }\n+\n+    public void handle(Exception e) throws RuntimeException {\n+        if (e == null) {\n+            return;\n+        }\n+\n+        E exception = get();\n+        if (exception.getClass() == e.getClass()) {\n+            resuppress(e);\n+        } else {\n+            if (e instanceof InterruptedException) {\n+                \/\/ FIXME interrupt re-set should be up to the Context implementation, as\n+                \/\/ some implementations may prefer to continue beforeCheckpoint\/afterRestore\n+                \/\/ notification, rather than exiting as soon as possible.\n+                Thread.currentThread().interrupt();\n+            }\n+            exception.addSuppressed(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/ExceptionHolder.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import sun.security.action.GetPropertyAction;\n+\n+public class GlobalContext {\n+    private static final String GLOBAL_CONTEXT_IMPL_PROP = \"jdk.crac.globalContext.impl\";\n+\n+    public static Context<Resource> createGlobalContextImpl() {\n+        String implName = GetPropertyAction.privilegedGetProperty(GLOBAL_CONTEXT_IMPL_PROP, \"\");\n+        return switch (implName) {\n+            case \"BlockingOrderedContext\" -> new BlockingOrderedContext<>();\n+            case \"OrderedContext\" -> new OrderedContext<>();\n+            default -> new OrderedContext<>(); \/\/ cannot report as System.out\/err are not initialized yet\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/GlobalContext.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.crac.impl;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * Keeps VM alive by at least one non-daemon thread.\n+ *\/\n+public class KeepAlive implements AutoCloseable {\n+    private final CountDownLatch start = new CountDownLatch(1);\n+    private final CountDownLatch finish = new CountDownLatch(1);\n+    private final Thread thread;\n+\n+    public KeepAlive() {\n+        \/\/ When the thread running notifications is not a daemon thread\n+        \/\/ it is unnecessary to create the keep-alive thread.\n+        if (!Thread.currentThread().isDaemon()) {\n+            thread = null;\n+            return;\n+        }\n+        thread = new Thread(() -> {\n+            start.countDown();\n+            try {\n+                finish.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, \"CRaC Keep-Alive\");\n+        thread.setDaemon(false);\n+        thread.start();\n+        try {\n+            start.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new RuntimeException(\"Interrupted waiting for the keep-alive thread to start.\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (thread == null) {\n+            return; \/\/ noop\n+        }\n+        finish.countDown();\n+        try {\n+            thread.join();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new RuntimeException(\"Interrupted waiting for the keep-alive thread to complete\", e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/KeepAlive.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+import jdk.crac.*;\n+\n+import java.util.*;\n+\n+\/**\n+ * Context performing Checkpoint notification in reverse order of registration.\n+ * Concurrent registration along notification is silently ignored.\n+ * @param <R>\n+ *\/\n+public class OrderedContext<R extends Resource> extends AbstractContext<R> {\n+    private final WeakHashMap<R, Long> resources = new WeakHashMap<>();\n+    private long order = 0;\n+    private List<R> restoreSnapshot = null;\n+\n+    protected List<R> checkpointSnapshot() {\n+        List<R> snapshot;\n+        synchronized (this) {\n+            snapshot = this.resources.entrySet().stream()\n+                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\n+                .map(Map.Entry::getKey)\n+                .toList();\n+        }\n+        restoreSnapshot = new ArrayList<>(snapshot);\n+        Collections.reverse(restoreSnapshot);\n+        return snapshot;\n+    }\n+\n+    \/\/ We won't synchronize access to restoreSnapshot because methods\n+    \/\/ beforeCheckpoint and afterRestore should be invoked only\n+    \/\/ by the single thread performing the C\/R and other threads should\n+    \/\/ not touch that.\n+    protected List<R> restoreSnapshot() {\n+        List<R> snapshot = restoreSnapshot;\n+        restoreSnapshot = null;\n+        return snapshot;\n+    }\n+\n+    @Override\n+    public synchronized void register(R resource) {\n+        resources.put(resource, order++);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides explicit coordination with a checkpoint\/restore mechanism.\n+ * A checkpoint\/restore implementation may capture process or application state images for later continuation.\n+ * Coordination allows application code to prepare for a checkpoint and to adapt to changes in the execution environment after a restore.\n+ * <p>\n+ * Successful checkpointing and restoration may require that no checkpointed state exist that might not be validly reproducible when\n+restoring instances from the image.\n+ * Coordination enables application to proactively discard problematic state ahead of checkpointing, and to reestablish needed state upon restoration.\n+ * A Java implementation may provide detection of some subsets of state that are known to prevent successful checkpoints.\n+ * <p>\n+ * For example, a state of opened file descriptors or socket may be impossible to store in the image.\n+ * The implementation may detect such resources and then prevent checkpoint.\n+ * The application must then close file descriptors and sockets to be successfully checkpointed.\n+ * Files and sockets may be opened back after restore, then the application is responsible for processing possible exceptions.\n+ * <p>\n+ * {@link Resource} is an interface for receiving checkpoint\/restore notifications.\n+ * In order to be notified, {@code Resource} needs to be registered in a {@link Context}.\n+ * {@link Core} is a core interface for coordination. It provides the global {@code Context} which can be used as default choice.\n+ * The global {@code Context} have properties listed below, one can define a custom {@code Context} and register it with the global one.\n+ * {@code Core} has also a method to request checkpoint.\n+ * <p>\n+ * Methods of {@code Resource} are invoked as a notification of checkpoint and restore.\n+ * If a {@code Resource} is incapable to process notification, corresponding method throws an exception.\n+ * The global {@code Context} ensures that exceptions are propagated to a requester of checkpoint\/restore.\n+ * <p>\n+ * {@code Context} is a {@code Resource}, that allows other {@code Resource}s to be registered with it.\n+ * {@code Context} defines how {@code Resource}s are notified and may provide different guarantees compared to the global {@code Context}, such as order of notification.\n+ * A class may extend {@code Context} and define custom rules of notification processing by overriding {@code Resource} method.\n+ * Since a {@code Context} may be registered with other {@code Context}, they form a {@code Context} hierarchy.\n+ * <p>\n+ * Checkpoint can requested by {@code Core.checkpointRestore} or by some other way.\n+ * Then checkpoint notification of the global {@code Context} is performed.\n+ * If the global {@code Context} have not thrown {@code CheckpointException}, the current Java instance is used to create the image in a platform dependent way.\n+ * The current instance is terminated.\n+ * Later, a new instance is created by some means, for example via Java launcher in a special mode.\n+ * The new instance is started at the point where the image was created, it is followed by the restore notification.\n+ * Exceptions from restore notification are provided as suppressed ones by a {@code RestoreException} (in a sense of {@link Throwable#addSuppressed}).\n+ * <p>\n+ * If the global {@code Context} throws an exception during checkpoint notification then restore notificaion starts immediately without the image creation.\n+ * In this case, exceptions from checkpoint and restore notifications are provided as suppressed ones by {@code CheckpointException}.\n+ * <p>\n+ * {@code UnsupportedOperationException} is thrown if the service is not supported.\n+ * No notification is performed in this case.\n+ * <h2>Global Context Properties<\/h2>\n+ * Java Runtime maintains the global {@code Context} with following properties.\n+ * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n+ * <ul>\n+ * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n+ * <\/li>\n+ * <li>Order of checkpoint notification is the reverse order of registration.\n+ * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n+ * <\/li>\n+ * <li>For single {@code Resource} registered in this {@code Context}:\n+ * <ul>\n+ *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n+ *   <\/li>\n+ *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n+ *   <\/li>\n+ *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ * <\/ul>\n+ * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * @since TBD\n+ *\/\n+\n+package jdk.crac;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/package-info.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+    public void markClosed(FileDescriptor fdo);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOFileDescriptorAccess.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+\n+import jdk.internal.crac.Core;\n+\n@@ -54,0 +59,10 @@\n+    \/**\n+     * Calls package-private {@link ReferenceQueue#poll(long)}.\n+     *\/\n+    <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException;\n+\n+    \/**\n+     * Calls package-private {@link ReferenceQueue#wakeup()}.\n+     *\/\n+    void wakeupReferenceQueue(ReferenceQueue<?> queue);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    public void beforeCheckpoint(ZipFile zip);\n@@ -48,1 +49,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilZipFileAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    private static final int INT_PHI = 0x9E3779B9;\n+    static final int NON_ZERO = 0x40000000;\n@@ -74,1 +74,1 @@\n-        return phiMix(tag * TAG_SMEAR + x1);\n+        return (tag * TAG_SMEAR + x1) | NON_ZERO;\n@@ -78,1 +78,1 @@\n-        return phiMix(tag * TAG_SMEAR + x1 + 31*x2);\n+        return (tag * TAG_SMEAR + x1 + 31 * x2) | NON_ZERO;\n@@ -83,6 +83,1 @@\n-        return phiMix(stringHash | (1 << 30));\n-    }\n-\n-    public static int phiMix(int x) {\n-        int h = x * INT_PHI;\n-        return h ^ (h >> 16);\n+        return stringHash | NON_ZERO;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-        terminalMaxLocals = topLocal(terminal);\n-        terminal.with((LabelTarget) startLabel);\n+        terminalMaxLocals = terminal.curTopLocal();\n+        parent.with((LabelTarget) startLabel);\n@@ -59,2 +59,2 @@\n-        terminal.with((LabelTarget) endLabel);\n-        if (terminalMaxLocals != topLocal(terminal)) {\n+        parent.with((LabelTarget) endLabel);\n+        if (terminalMaxLocals != terminal.curTopLocal()) {\n@@ -76,4 +76,2 @@\n-            case ChainedCodeBuilder b -> topLocal(b.terminal);\n-            case DirectCodeBuilder b -> b.curTopLocal();\n-            case BufferedCodeBuilder b -> b.curTopLocal();\n-            case TransformingCodeBuilder b -> topLocal(b.delegate);\n+            case ChainedCodeBuilder b -> b.terminal.curTopLocal();\n+            case TerminalCodeBuilder b -> b.curTopLocal();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,3 +79,1 @@\n-        int hash = handle.hashCode();\n-        hash = 31 * hash + arguments.hashCode();\n-        return AbstractPoolEntry.phiMix(hash);\n+        return (31 * handle.hashCode() + arguments.hashCode()) | AbstractPoolEntry.NON_ZERO;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-            case 0x78147009 ->\n+            case 0x46699ff2 ->\n@@ -993,1 +993,1 @@\n-            case 0x665e3a3a ->\n+            case 0x5208e184 ->\n@@ -995,1 +995,1 @@\n-            case 0xcb7e162 ->\n+            case 0xcb60907a ->\n@@ -997,1 +997,1 @@\n-            case 0x21e41e7e ->\n+            case 0x4020220d ->\n@@ -999,1 +999,1 @@\n-            case 0x5a306b41 ->\n+            case 0xc20dd1fe ->\n@@ -1001,1 +1001,1 @@\n-            case 0x3e191c7c ->\n+            case 0xcab1940d ->\n@@ -1003,1 +1003,1 @@\n-            case 0x5e88ed0c ->\n+            case 0x558641d3 ->\n@@ -1005,1 +1005,1 @@\n-            case 0x7284695e ->\n+            case 0x51d443cd ->\n@@ -1007,1 +1007,1 @@\n-            case 0x21df25db ->\n+            case 0x687c1624 ->\n@@ -1009,1 +1009,1 @@\n-            case 0x11392da9 ->\n+            case 0x7adb2910 ->\n@@ -1011,1 +1011,1 @@\n-            case 0x167536fc ->\n+            case 0x653f0551 ->\n@@ -1013,1 +1013,1 @@\n-            case 0x46939abc ->\n+            case 0x64c75927 ->\n@@ -1015,1 +1015,1 @@\n-            case 0x63ee67f4 ->\n+            case 0x6697f98d ->\n@@ -1017,1 +1017,1 @@\n-            case 0x2b597e15 ->\n+            case 0xdbb0cdcb ->\n@@ -1019,1 +1019,1 @@\n-            case 0x19f20ade ->\n+            case 0xc9b0928c ->\n@@ -1021,1 +1021,1 @@\n-            case 0x47f6395e ->\n+            case 0x41cd27e8 ->\n@@ -1023,1 +1023,1 @@\n-            case 0x54db809 ->\n+            case 0x7deb0a13 ->\n@@ -1025,1 +1025,1 @@\n-            case 0x1abd1c2c ->\n+            case 0x6706ff99 ->\n@@ -1027,1 +1027,1 @@\n-            case 0x6ba46dd ->\n+            case 0x60272858 ->\n@@ -1029,1 +1029,1 @@\n-            case 0x46f7d91d ->\n+            case 0x5646d73d ->\n@@ -1031,1 +1031,1 @@\n-            case 0x5137f53 ->\n+            case 0x50336c40 ->\n@@ -1033,1 +1033,1 @@\n-            case 0x4a8fa3b6 ->\n+            case 0x4735ab81 ->\n@@ -1035,1 +1035,1 @@\n-            case 0x55c73cb6 ->\n+            case 0x7100d9fe ->\n@@ -1037,1 +1037,1 @@\n-            case 0x3fe76d4e ->\n+            case 0xd1ab5871 ->\n@@ -1039,1 +1039,1 @@\n-            case 0x180d6925 ->\n+            case 0x7588550f ->\n@@ -1041,1 +1041,1 @@\n-            case 0x7be22752 ->\n+            case 0xcc74da30 ->\n@@ -1043,1 +1043,1 @@\n-            case 0x5299824 ->\n+            case 0xf67697f5 ->\n@@ -1045,1 +1045,1 @@\n-            case 0x3534786e ->\n+            case 0xe0837d2a ->\n@@ -1047,1 +1047,1 @@\n-            case 0xb4b4ac6 ->\n+            case 0xc945a075 ->\n@@ -1049,1 +1049,1 @@\n-            case 0x6926482 ->\n+            case 0x611a3a90 ->\n@@ -1051,1 +1051,1 @@\n-            case 0x16a42b7c ->\n+            case 0xf76fb898 ->\n@@ -1053,1 +1053,1 @@\n-            case 0x400ab245 ->\n+            case 0x6b41b047 ->\n@@ -1055,1 +1055,1 @@\n-            case 0x2af490d4 ->\n+            case 0x748c2857 ->\n@@ -1057,1 +1057,1 @@\n-            case 0x303e0c58 ->\n+            case 0x6bf13a96 ->\n@@ -1059,1 +1059,1 @@\n-            case 0x19c7d0cd ->\n+            case 0xfa85ee5a ->\n@@ -1061,1 +1061,1 @@\n-            case 0x3dc79b7a ->\n+            case 0xf2670725 ->\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        implements TerminalCodeBuilder, LabelContext {\n+        implements TerminalCodeBuilder {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-    private final ClassBuilder downstream;\n@@ -42,1 +41,0 @@\n-        this.downstream = downstream;\n@@ -63,1 +61,1 @@\n-        return downstream.with(new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n+        consumer.accept(new BufferedFieldBuilder(terminal.constantPool, terminal.context,\n@@ -67,0 +65,1 @@\n+        return this;\n@@ -75,1 +74,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n@@ -81,1 +81,1 @@\n-        return downstream.with(new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n+        consumer.accept(new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n@@ -85,0 +85,1 @@\n+        return this;\n@@ -92,1 +93,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-    final MethodBuilder downstream;\n@@ -45,1 +44,0 @@\n-        this.downstream = downstream;\n@@ -61,1 +59,1 @@\n-        return downstream.with(terminal.bufferedCodeBuilder(null)\n+        consumer.accept(terminal.bufferedCodeBuilder(null)\n@@ -64,0 +62,1 @@\n+        return this;\n@@ -70,1 +69,2 @@\n-        return downstream.with(builder.toModel());\n+        consumer.accept(builder.toModel());\n+        return this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedMethodBuilder.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-        implements TerminalCodeBuilder, LabelContext {\n+        implements TerminalCodeBuilder {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-        permits BufferedCodeBuilder, CodeImpl, DirectCodeBuilder {\n+        permits TerminalCodeBuilder, CodeImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LabelContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1050,1 +1050,1 @@\n-            checkLocal(methodDesc.parameterCount() + (isStatic ? 0 : -1));\n+            checkLocal(methodDesc.parameterCount() + (isStatic ? -1 : 0));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,3 @@\n-public sealed interface TerminalCodeBuilder extends CodeBuilder\n-        permits DirectCodeBuilder, BufferedCodeBuilder, TransformingCodeBuilder {\n-\n+public sealed interface TerminalCodeBuilder extends CodeBuilder, LabelContext\n+        permits DirectCodeBuilder, BufferedCodeBuilder {\n+    int curTopLocal();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TerminalCodeBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.classfile.impl;\n-\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeModel;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.TypeKind;\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-\n-public final class TransformingCodeBuilder implements TerminalCodeBuilder {\n-\n-    final CodeBuilder delegate;\n-    final Consumer<CodeElement> consumer;\n-\n-    public TransformingCodeBuilder(CodeBuilder delegate, Consumer<CodeElement> consumer) {\n-        this.delegate = delegate;\n-        this.consumer = consumer;\n-    }\n-\n-    @Override\n-    public CodeBuilder with(CodeElement e) {\n-        consumer.accept(e);\n-        return this;\n-    }\n-\n-    @Override\n-    public Optional<CodeModel> original() {\n-        return delegate.original();\n-    }\n-\n-    @Override\n-    public Label newLabel() {\n-        return delegate.newLabel();\n-    }\n-\n-    @Override\n-    public Label startLabel() {\n-        return delegate.startLabel();\n-    }\n-\n-    @Override\n-    public Label endLabel() {\n-        return delegate.endLabel();\n-    }\n-\n-    @Override\n-    public int receiverSlot() {\n-        return delegate.receiverSlot();\n-    }\n-\n-    @Override\n-    public int parameterSlot(int paramNo) {\n-        return delegate.parameterSlot(paramNo);\n-    }\n-\n-    @Override\n-    public int allocateLocal(TypeKind typeKind) {\n-        return delegate.allocateLocal(typeKind);\n-    }\n-\n-    @Override\n-    public ConstantPoolBuilder constantPool() {\n-        return delegate.constantPool();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformingCodeBuilder.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.io.FileDescriptor;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.WeakHashMap;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\n+public class ClaimedFDs {\n+    private final static JavaIOFileDescriptorAccess fileDescriptorAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    private WeakHashMap<FileDescriptor, Descriptor> fds = new WeakHashMap<>();\n+\n+    public static class Descriptor {\n+        private int fd;\n+        private final Object claimer;\n+        private final Supplier<Exception> exceptionSupplier;\n+\n+        public Descriptor(Object claimer, Supplier<Exception> exceptionSupplier) {\n+            this.fd = -1;\n+            this.claimer = claimer;\n+            this.exceptionSupplier = exceptionSupplier;\n+        }\n+\n+        void setFd(int fd) {\n+            assert this.fd == -1;\n+            this.fd = fd;\n+        }\n+\n+        public int getFd() {\n+            assert this.fd != -1;\n+            return fd;\n+        }\n+\n+        public Object getClaimer() {\n+            return claimer;\n+        }\n+\n+        public Supplier<Exception> getExceptionSupplier() {\n+            return exceptionSupplier;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"{fd=\" + fd + \", claimer=\" + claimer + '}';\n+        }\n+    }\n+\n+    public List<Descriptor> getClaimedFds() {\n+        List<Descriptor> list = fds.entrySet().stream()\n+            .filter((var e) -> e.getKey().valid())\n+            .map(entry -> {\n+                    Descriptor d = entry.getValue();\n+                    d.setFd(fileDescriptorAccess.get(entry.getKey()));\n+                    return d;\n+                })\n+            .collect(Collectors.toList());\n+        \/\/ destroy fds since we've modified Descriptors\n+        fds = null;\n+        return list;\n+    }\n+\n+    public void claimFd(FileDescriptor fd, Object claimer, Supplier<Exception> supplier, Object... suppressedClaimers) {\n+        if (fd == null) {\n+            return;\n+        }\n+\n+        Descriptor descriptor = fds.get(fd);\n+        LoggerContainer.debug(\"ClaimFD: fd {0} claimer {1} existing {2}\",\n+            fd, claimer, descriptor != null ? descriptor.claimer : \"NONE\");\n+        if (descriptor == null ||\n+                Stream.of(suppressedClaimers).anyMatch((supressed) -> supressed == descriptor.getClaimer())) {\n+            fds.put(fd, new Descriptor(claimer, supplier));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/ClaimedFDs.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.impl.BlockingOrderedContext;\n+\n+public class Core {\n+    private static ClaimedFDs claimedFDs;\n+\n+    \/**\n+     * Called by JDK FD resources\n+     * @return\n+     *\/\n+    public static ClaimedFDs getClaimedFDs() {\n+        return claimedFDs;\n+    }\n+\n+    \/**\n+     * Called by jdk.crac.Core to publish current ClaimedFDs\n+     *\/\n+    public static void setClaimedFDs(ClaimedFDs fds) {\n+        claimedFDs = fds;\n+    }\n+\n+    \/**\n+     * Priorities are defined in the order of registration to the global context.\n+     * Checkpoint notification will be processed in the order from the bottom to the top of the list.\n+     * Restore will be done in reverse order: from the top to the bottom.\n+     *\n+     * Resources of the same priority will be handled according the context supplied to the priority.\n+     *\n+     * Most resources should use priority NORMAL (the lowest priority).\n+     *\/\n+    public enum Priority {\n+        FILE_DESCRIPTORS(new BlockingOrderedContext<>()),\n+        PRE_FILE_DESCRIPTORS(new BlockingOrderedContext<>()),\n+        CLEANERS(new BlockingOrderedContext<>()),\n+        REFERENCE_HANDLER(new BlockingOrderedContext<>()),\n+        SEEDER_HOLDER(new BlockingOrderedContext<>()),\n+        SECURE_RANDOM(new BlockingOrderedContext<>()),\n+        NATIVE_PRNG(new BlockingOrderedContext<>()),\n+        EPOLLSELECTOR(new BlockingOrderedContext<>()),\n+        NORMAL(new BlockingOrderedContext<>());\n+\n+        private final Context<JDKResource> context;\n+        Priority(Context<JDKResource> context) {\n+            jdk.crac.Core.getGlobalContext().register(context);\n+            this.context = context;\n+        }\n+\n+        public Context<JDKResource> getContext() {\n+            return context;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.action.GetBooleanAction;\n+\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n+public class JDKContext implements JDKResource {\n+    public static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n+    public static final String COLLECT_FD_STACKTRACES_HINT = \"Use -D\" + COLLECT_FD_STACKTRACES_PROPERTY + \"=true to find the source.\";\n+\n+    \/\/ JDKContext by itself is initialized too early when system properties are not set yet\n+    public static class Properties {\n+        public static final boolean COLLECT_FD_STACKTRACES =\n+                GetBooleanAction.privilegedGetProperty(JDKContext.COLLECT_FD_STACKTRACES_PROPERTY);\n+    }\n+\n+    private WeakHashMap<FileDescriptor, Object> claimedFds;\n+\n+    public boolean matchClasspath(String path) {\n+        Path p = Path.of(path);\n+        String classpath = System.getProperty(\"java.class.path\");\n+        int index = 0;\n+        do {\n+            int end = classpath.indexOf(File.pathSeparatorChar, index);\n+            if (end < 0) {\n+                end = classpath.length();\n+            }\n+            try {\n+                if (Files.isSameFile(p, Path.of(classpath.substring(index, end)))) {\n+                    return true;\n+                }\n+            } catch (IOException e) {\n+                \/\/ ignore exception\n+                return false;\n+            }\n+            index = end + 1;\n+        } while (index < classpath.length());\n+        return false;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        claimedFds = new WeakHashMap<>();\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        claimedFds = null;\n+    }\n+\n+    public Map<Integer, Object> getClaimedFds() {\n+        JavaIOFileDescriptorAccess fileDescriptorAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+        \/\/ Using streams+lambdas here would create a new Cleaner, therefore registering a resource\n+        Map<Integer, Object> map = new HashMap<>();\n+        for (Map.Entry<FileDescriptor, Object> entry : claimedFds.entrySet()) {\n+            if (map.put(fileDescriptorAccess.get(entry.getKey()), entry.getValue()) != null) {\n+                throw new IllegalStateException(\"Duplicate key\");\n+            }\n+        }\n+        return map;\n+    }\n+\n+    public void claimFd(FileDescriptor fd, Object obj) {\n+        if (!fd.valid()) {\n+            return;\n+        }\n+        Object e = claimedFds.put(fd, obj);\n+        if (e != null) {\n+            throw new AssertionError(fd + \" was already claimed by \" + e);\n+        }\n+    }\n+\n+    public boolean claimFdWeak(FileDescriptor fd, Object obj) {\n+        if (!fd.valid()) {\n+            return false;\n+        }\n+        return claimedFds.putIfAbsent(fd, obj) == null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import sun.security.action.GetBooleanAction;\n+\n+import java.util.function.Supplier;\n+\n+public abstract class JDKFdResource implements JDKResource {\n+    public static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n+    private static final String COLLECT_FD_STACKTRACES_HINT =\n+        \"Use -D\" + COLLECT_FD_STACKTRACES_PROPERTY + \"=true to find the source.\";\n+\n+    private static final boolean COLLECT_FD_STACKTRACES =\n+        GetBooleanAction.privilegedGetProperty(COLLECT_FD_STACKTRACES_PROPERTY);\n+\n+    \/\/ No lambdas during clinit...\n+    protected static Supplier<Exception> NO_EXCEPTION = new Supplier<Exception>() {\n+        @Override\n+        public Exception get() {\n+            return null;\n+        }\n+    };\n+\n+    final Exception stackTraceHolder;\n+\n+    static volatile boolean stacktraceHintPrinted = false;\n+    static volatile boolean warningSuppressionHintPrinted = false;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public JDKFdResource() {\n+        stackTraceHolder = COLLECT_FD_STACKTRACES ?\n+            \/\/ About the timestamp: we cannot format it nicely since this\n+            \/\/ exception is sometimes created too early in the VM lifecycle\n+            \/\/ (but it's hard to detect when it would be safe to do).\n+            new Exception(\"This file descriptor was created by \" + Thread.currentThread().getName()\n+                + \" at epoch:\" + System.currentTimeMillis() + \" here\") :\n+            null;\n+\n+        Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+        OpenResourcePolicies.ensureRegistered();\n+    }\n+\n+    protected Exception getStackTraceHolder() {\n+        if (!stacktraceHintPrinted && stackTraceHolder == null) {\n+            stacktraceHintPrinted = true;\n+            LoggerContainer.info(COLLECT_FD_STACKTRACES_HINT);\n+        }\n+        return stackTraceHolder;\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+    }\n+\n+    protected void warnOpenResource(OpenResourcePolicies.Policy policy, String self) {\n+        \/\/ The warning is not printed for implicitly closed resource (without policy)\n+        \/\/ e.g. standard input\/output streams\n+        String warn = \"false\";\n+        if (policy != null) {\n+            warn = policy.params.getOrDefault(\"warn\", \"true\");\n+        }\n+        if (Boolean.parseBoolean(warn)) {\n+            LoggerContainer.warn(\"{0} was not closed by the application.\", self);\n+            if (!warningSuppressionHintPrinted) {\n+                LoggerContainer.info(\"To suppress the warning above use 'warn: false' in the resource policy.\");\n+                warningSuppressionHintPrinted = true;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFdResource.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+public abstract class JDKFileResource extends JDKFdResource {\n+    private static final Path[] CLASSPATH_ENTRIES;\n+\n+    static {\n+        String[] items = GetPropertyAction.privilegedGetProperty(\"java.class.path\")\n+                .split(File.pathSeparator);\n+        CLASSPATH_ENTRIES = new Path[items.length];\n+        for (int i = 0; i < items.length; i++) {\n+            \/\/ On Windows, path with forward slashes starting with '\/' is an accepted classpath\n+            \/\/ element, even though it might seem as invalid and parsing in Path.of(...) would fail.\n+            CLASSPATH_ENTRIES[i] = new File(items[i]).toPath();\n+        }\n+    }\n+\n+    boolean closed;\n+    boolean error;\n+\n+    public static OpenResourcePolicies.Policy findPolicy(boolean isRestore, String pathStr) {\n+        Path path = Path.of(pathStr);\n+        return OpenResourcePolicies.find(isRestore,\n+                OpenResourcePolicies.FILE, props -> {\n+                    String policyPath = props.get(\"path\");\n+                    if (policyPath == null) {\n+                        return true; \/\/ missing path matches all files\n+                    } else {\n+                        return FileSystems.getDefault().getPathMatcher(\"glob:\" + policyPath).matches(path);\n+                    }\n+                });\n+    }\n+\n+    protected abstract FileDescriptor getFD();\n+    protected abstract String getPath();\n+    protected abstract void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException;\n+    protected abstract void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException;\n+\n+    protected boolean matchClasspath(String path) {\n+        Path p = Path.of(path);\n+        for (Path entry : CLASSPATH_ENTRIES) {\n+            try {\n+                if (Files.isSameFile(p, entry)) {\n+                    return true;\n+                }\n+            } catch (IOException e) {\n+                \/\/ ignored\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        String path = getPath();\n+        if (path == null) {\n+            \/\/ let FileDescriptor claim everything\n+            return;\n+        }\n+\n+        OpenResourcePolicies.Policy policy = findPolicy(false, path);\n+        String action = \"error\";\n+        if (policy != null) {\n+            action = policy.action.toLowerCase();\n+        } else if (matchClasspath(path)) {\n+            \/\/ Files on the classpath are considered persistent, exception is not thrown\n+            action = \"ignore\";\n+        }\n+        Supplier<Exception> exceptionSupplier = switch (action) {\n+            case \"error\":\n+                error = true;\n+                yield () -> new CheckpointOpenFileException(path, getStackTraceHolder());\n+            case \"close\", \"reopen\":\n+                \/\/ Here we assume that the stream is idle; any concurrent access\n+                \/\/ will end with exceptions as the file-descriptors is invalidated\n+                try {\n+                    closeBeforeCheckpoint(policy);\n+                } catch (IOException e) {\n+                    throw new CheckpointOpenResourceException(\"Cannot close \" + path, e);\n+                }\n+                closed = true;\n+            case \"ignore\":\n+                warnOpenResource(policy, \"File \" + path);\n+                yield NO_EXCEPTION;\n+            default:\n+                throw new IllegalStateException(\"Unknown policy action for path \" + path + \": \" + policy.action);\n+        };\n+        FileDescriptor fd = getFD();\n+        Core.getClaimedFDs().claimFd(fd, this, exceptionSupplier, fd);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (!closed || error) {\n+            return;\n+        }\n+        OpenResourcePolicies.Policy policy = findPolicy(true, getPath());\n+        if (policy != null && \"reopen\".equalsIgnoreCase(policy.action)) {\n+            reopenAfterRestore(policy);\n+            closed = false;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFileResource.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+\n+public interface JDKResource extends Resource {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+\n+import java.io.IOException;\n+import java.net.*;\n+\n+public abstract class JDKSocketResource extends JDKSocketResourceBase {\n+\n+    private SocketAddress local;\n+    private SocketAddress remote;\n+\n+    public JDKSocketResource(Object owner) {\n+        super(owner);\n+    }\n+\n+    protected abstract SocketAddress localAddress() throws IOException;\n+    protected abstract SocketAddress remoteAddress() throws IOException;\n+\n+    @Override\n+    protected OpenResourcePolicies.Policy findPolicy(boolean isRestore) throws CheckpointOpenSocketException {\n+        if (!isRestore) {\n+            try {\n+                local = localAddress();\n+            } catch (IOException e) {\n+                throw new CheckpointOpenSocketException(\"Cannot find local address for \" + owner, e);\n+            }\n+            try {\n+                remote = remoteAddress();\n+            } catch (IOException e) {\n+                throw new CheckpointOpenSocketException(\"Cannot find remote address for \" + owner, e);\n+            }\n+        }\n+        var localMatcher = getMatcher(local, \"localAddress\", \"localPort\", \"localPath\");\n+        var remoteMatcher = getMatcher(remote, \"remoteAddress\", \"remotePort\", \"remotePath\");\n+        return OpenResourcePolicies.find(isRestore, OpenResourcePolicies.SOCKET,\n+                params -> localMatcher.test(params) && remoteMatcher.test(params));\n+    }\n+\n+    @Override\n+    protected void reset() {\n+        \/\/ Allow garbage collection\n+        local = null;\n+        remote = null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResource.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.file.FileSystems;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+public abstract class JDKSocketResourceBase extends JDKFdResource {\n+    protected final Object owner;\n+    private boolean valid;\n+    private boolean error;\n+\n+    public JDKSocketResourceBase(Object owner) {\n+        this.owner = owner;\n+    }\n+\n+    protected abstract FileDescriptor getFD();\n+    protected abstract void closeBeforeCheckpoint() throws IOException;\n+    protected abstract OpenResourcePolicies.Policy findPolicy(boolean isRestore) throws CheckpointOpenSocketException;\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        FileDescriptor fd = getFD();\n+        if (fd == null) {\n+            return;\n+        }\n+        synchronized (fd) {\n+            if (!(valid = fd.valid())) {\n+                return;\n+            }\n+            OpenResourcePolicies.Policy policy = findPolicy(false);\n+            String action = policy == null ? \"error\" : policy.action.toLowerCase();\n+            Supplier<Exception> exceptionSupplier = switch (action) {\n+                case \"error\":\n+                    error = true;\n+                    yield () -> new CheckpointOpenSocketException(owner.toString(), getStackTraceHolder());\n+                case \"close\", \"reopen\":\n+                    try {\n+                        closeBeforeCheckpoint();\n+                    } catch (IOException e) {\n+                        throw new CheckpointOpenSocketException(\"Cannot close \" + owner, e);\n+                    }\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    warnOpenResource(policy, \"Socket \" + owner);\n+                    yield NO_EXCEPTION;\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + owner, null);\n+            };\n+            Core.getClaimedFDs().claimFd(fd, owner, exceptionSupplier, fd);\n+        }\n+    }\n+\n+    protected Predicate<Map<String, String>> getMatcher(SocketAddress addr, String addressKey, String portKey, String pathKey) {\n+        return params -> {\n+            String family = params.get(\"family\");\n+            if (family != null && addr != null) {\n+                switch (family.toLowerCase()) {\n+                    case \"ipv6\", \"inet6\" -> {\n+                        if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                            return false;\n+                        } else if (!(inetAddr.getAddress() instanceof Inet6Address)) {\n+                            return false;\n+                        }\n+                    }\n+                    case \"ipv4\", \"inet4\" -> {\n+                        if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                            return false;\n+                        } else if (!(inetAddr.getAddress() instanceof Inet4Address)) {\n+                            return false;\n+                        }\n+                    }\n+                    case \"ip\", \"inet\" -> {\n+                        if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                            return false;\n+                        }\n+                    }\n+                    case \"unix\" -> {\n+                        if (!(addr instanceof UnixDomainSocketAddress)) {\n+                            return false;\n+                        }\n+                    }\n+                    default -> throw new IllegalArgumentException(\"Unknown family: \" + family);\n+                }\n+            }\n+            String cfgAddress = params.get(addressKey);\n+            String cfgPort = params.get(portKey);\n+            String cfgPath = params.get(pathKey);\n+            if (cfgAddress != null || cfgPort != null) {\n+                if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                    return false;\n+                }\n+                if (cfgAddress != null && !\"*\".equals(cfgAddress)) {\n+                    try {\n+                        if (!InetAddress.getByName(cfgAddress).equals(inetAddr.getAddress())) {\n+                            return false;\n+                        }\n+                    } catch (UnknownHostException e) {\n+                        return false;\n+                    }\n+                }\n+                if (cfgPort != null && !\"*\".equals(cfgPort)) {\n+                    return Integer.parseInt(cfgPort) == inetAddr.getPort();\n+                }\n+                return true;\n+            } else if (cfgPath != null) {\n+                if (!(addr instanceof UnixDomainSocketAddress unixAddr)) {\n+                    return false;\n+                }\n+                return FileSystems.getDefault().getPathMatcher(\"glob:\" + cfgPath)\n+                        .matches(unixAddr.getPath());\n+            } else {\n+                return true;\n+            }\n+        };\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        \/\/ Don't do anything when we've already failed\n+        if (!valid || error) {\n+            return;\n+        }\n+        FileDescriptor fd = getFD();\n+        if (fd == null) {\n+            return;\n+        }\n+        synchronized (fd) {\n+            OpenResourcePolicies.Policy policy = findPolicy(true);\n+            String action = policy == null ? \"error\" : policy.action;\n+            try {\n+                \/\/ FIXME: implement\n+                if (action.equals(\"reopen\")) {\n+                    throw new UnsupportedOperationException(\"Policy \" + policy.type + \" not implemented\");\n+                }\n+            } finally {\n+                reset();\n+            }\n+        }\n+    }\n+\n+    protected abstract void reset();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResourceBase.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+package jdk.internal.crac;\n+\n+\/**\n+ * Some classes that could use logging are initialized early during the boot\n+ * and keeping the logger in static final field there could cause problems\n+ * (e.g. recursion when service-loading logger implementation).\n+ * Therefore, we isolate the logger into a subclass and initialize lazily.\n+ *\/\n+public class LoggerContainer {\n+    public static final System.Logger logger = System.getLogger(\"jdk.crac\");\n+\n+    public static void info(String msg) {\n+        logger.log(System.Logger.Level.INFO, msg);\n+    }\n+\n+    public static void debug(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.DEBUG, fmt, params);\n+    }\n+\n+    private LoggerContainer() {}\n+\n+    public static void warn(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.WARNING, fmt, params);\n+    }\n+\n+    public static void error(String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg);\n+    }\n+\n+    public static void error(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.ERROR, fmt, params);\n+    }\n+\n+    public static void error(Throwable t, String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg, t);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.*;\n+import java.util.function.Predicate;\n+\n+public class OpenResourcePolicies {\n+    public static final String PROPERTY = \"jdk.crac.resource-policies\";\n+    public static final String FILE = \"file\";\n+    public static final String PIPE = \"pipe\";\n+    public static final String SOCKET = \"socket\";\n+\n+    private enum State {\n+        NOT_LOADED,\n+        LOADED_FOR_CHECKPOINT,\n+        LOADED_FOR_RESTORE\n+    }\n+\n+    private static final Map<String, List<Policy>> policies = new HashMap<>();\n+    private static State state = State.NOT_LOADED;\n+\n+    private static final JDKResource resource = new JDKResource() {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            \/\/ We cannot lazily wait until the FILE_DESCRIPTORS priority\n+            \/\/ because we need to open a file, too.\n+            loadPolicies(false);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+            policies.clear();\n+            state = State.NOT_LOADED;\n+        }\n+    };\n+\n+    static {\n+        Core.Priority.NORMAL.getContext().register(resource);\n+    }\n+\n+    static void ensureRegistered() {\n+        \/\/ noop\n+    }\n+\n+    private static synchronized void loadPolicies(boolean isRestore) {\n+        if (state == State.LOADED_FOR_RESTORE || (!isRestore && state == State.LOADED_FOR_CHECKPOINT)) {\n+            return;\n+        }\n+        \/\/ prevent loading recursively\n+        state = isRestore ? State.LOADED_FOR_RESTORE : State.LOADED_FOR_CHECKPOINT;\n+\n+        String file = GetPropertyAction.privilegedGetProperty(PROPERTY);\n+        if (file == null) {\n+            return;\n+        }\n+        \/\/ The newer policies have more priority; we'll copy the old ones and\n+        \/\/ append them later on\n+        Map<String, List<Policy>> old = Map.copyOf(policies);\n+        policies.clear();\n+\n+        File f = new File(file);\n+        if (!f.exists()) {\n+            throw new ConfigurationException(\"File \" + file + \" used in property \" + PROPERTY + \" does not exist\");\n+        } else if (!f.isFile() || !f.canRead()) {\n+            throw new ConfigurationException(\"File \" + file + \" used in property \" + PROPERTY + \" is not a regular file or cannot be read.\");\n+        }\n+        String type = null, action = null;\n+        Map<String, String> params = new HashMap<>();\n+        int currentLine = 1, policyStart = 1;\n+        try {\n+            for (String line : Files.readAllLines(f.toPath())) {\n+                line = line.trim();\n+                if (line.startsWith(\"#\")) {\n+                    continue;\n+                } else if (\"---\".equals(line)) {\n+                    if (type == null && action == null && params.isEmpty()) {\n+                        \/\/ ignore empty policies\n+                        policyStart = currentLine + 1;\n+                        continue;\n+                    }\n+                    addPolicy(type, action, params, file, policyStart, currentLine);\n+                    type = null;\n+                    action = null;\n+                    params = new HashMap<>();\n+                    policyStart = currentLine + 1;\n+                    continue;\n+                }\n+                int index = line.indexOf(\": \");\n+                if (index < 0) {\n+                    throw new ConfigurationException(invalid(file, policyStart, currentLine, \"cannot parse line \" + currentLine + \": \" + line));\n+                }\n+                String key = line.substring(0, index).trim();\n+                String value = line.substring(index + 2).trim();\n+                switch (key.toLowerCase()) {\n+                    case \"type\" -> type = value;\n+                    case \"action\" -> action = value;\n+                    default -> params.put(key, value);\n+                }\n+                ++currentLine;\n+            }\n+            if (type != null || action != null || !params.isEmpty()) {\n+                addPolicy(type, action, params, file, policyStart, currentLine);\n+            }\n+        } catch (IOException e) {\n+            throw new ConfigurationException(\"Cannot read file \" + file + \" used in property \" + PROPERTY, e);\n+        }\n+\n+        \/\/ Add the old policies after the newly loaded ones\n+        for (var entry : old.entrySet()) {\n+            List<Policy> newList = policies.get(entry.getKey());\n+            if (newList == null) {\n+                policies.put(entry.getKey(), entry.getValue());\n+            } else {\n+                newList.addAll(entry.getValue());\n+            }\n+        }\n+    }\n+\n+    private static void addPolicy(String type, String action, Map<String, String> params, String file, int from, int to) {\n+        if (type == null) {\n+            throw new ConfigurationException(invalid(file, from, to, \"no 'type'\"));\n+        } else if (action == null) {\n+            throw new ConfigurationException(invalid(file, from, to, \"no 'action'\"));\n+        }\n+        type = type.trim().toLowerCase();\n+        action = action.trim();\n+        policies.computeIfAbsent(type, t -> new ArrayList<>()).add(new Policy(type, action, params));\n+    }\n+\n+    private static String invalid(String file, int from, int to, String why) {\n+        return \"Invalid rule in policies file \" + file + \" on lines \" + from + \"-\" + to + \": \" + why;\n+    }\n+\n+    public static Policy find(boolean isRestore, String type, Predicate<Map<String, String>> filter) {\n+        loadPolicies(isRestore);\n+        List<Policy> list = policies.get(type);\n+        if (list == null) {\n+            return null;\n+        }\n+        if (filter == null) {\n+            return list.get(0);\n+        }\n+        return list.stream().filter(p -> filter.test(p.params)).findFirst().orElse(null);\n+    }\n+\n+    public static class Policy {\n+        \/\/ file, socket, pipe...\n+        public final String type;\n+        \/\/ The policy action\n+        public final String action;\n+        \/\/ Both filtering and action customization\n+        public final Map<String, String> params;\n+\n+        public Policy(String type, String action, Map<String, String> params) {\n+            this.type = type;\n+            this.action = action;\n+            this.params = Collections.unmodifiableMap(params);\n+        }\n+    }\n+\n+    private static class ConfigurationException extends RuntimeException {\n+        private static final long serialVersionUID = 6833568262773571378L;\n+\n+        public ConfigurationException(String message) {\n+            super(message);\n+        }\n+\n+        public ConfigurationException(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/OpenResourcePolicies.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -162,1 +162,1 @@\n-                (MemorySessionImpl)scope, action);\n+                (MemorySessionImpl)scope, readOnly, action);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,5 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(long min, long byteSize, MemorySessionImpl sessionImpl, Runnable action) {\n+    public static MemorySegment makeNativeSegmentUnchecked(long min,\n+                                                           long byteSize,\n+                                                           MemorySessionImpl sessionImpl,\n+                                                           boolean readOnly,\n+                                                           Runnable action) {\n@@ -67,1 +71,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, sessionImpl);\n+        return new NativeMemorySegmentImpl(min, byteSize, readOnly, sessionImpl);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.InvocationHandler;\n@@ -32,0 +33,1 @@\n+import java.lang.reflect.Proxy;\n@@ -75,1 +77,1 @@\n-    private final FileChannel channel;\n+    private FileChannel channel;\n@@ -84,0 +86,1 @@\n+    private Object cracResource;\n@@ -85,1 +88,1 @@\n-    @SuppressWarnings({ \"removal\", \"this-escape\" })\n+    @SuppressWarnings(\"this-escape\")\n@@ -106,24 +109,2 @@\n-            channel = FileChannel.open(imagePath, StandardOpenOption.READ);\n-            \/\/ No lambdas during bootstrap\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run() {\n-                    if (BasicImageReader.class.getClassLoader() == null) {\n-                        try {\n-                            Class<?> fileChannelImpl =\n-                                Class.forName(\"sun.nio.ch.FileChannelImpl\");\n-                            Method setUninterruptible =\n-                                    fileChannelImpl.getMethod(\"setUninterruptible\");\n-                            setUninterruptible.invoke(channel);\n-                        } catch (ClassNotFoundException |\n-                                 NoSuchMethodException |\n-                                 IllegalAccessException |\n-                                 InvocationTargetException ex) {\n-                            \/\/ fall thru - will only happen on JDK-8 systems where this code\n-                            \/\/ is only used by tools using jrt-fs (non-critical.)\n-                        }\n-                    }\n-\n-                    return null;\n-                }\n-            });\n+            channel = openFileChannel();\n+            registerIfCRaCPresent();\n@@ -178,0 +159,83 @@\n+    \/\/ Since this class must be compatible with JDK 8 and any non-CRaC JDK due to being part of jrtfs.jar\n+    \/\/ we must register this to CRaC via reflection.\n+    private void registerIfCRaCPresent() {\n+        try {\n+            Class<?> priorityClass = Class.forName(\"jdk.internal.crac.Core$Priority\");\n+            Class<?> jdkResourceClass = Class.forName(\"jdk.internal.crac.JDKResource\");\n+            Class<?> resourceClass = Class.forName(\"jdk.crac.Resource\");\n+            Object[] priorities = priorityClass.getEnumConstants();\n+            if (priorities == null) {\n+                return;\n+            }\n+            Object normalPriority = null;\n+            for (int i = 0; i < priorities.length; ++i) {\n+                if (\"NORMAL\".equals(priorities[i].toString())) {\n+                    normalPriority = priorities[i];\n+                }\n+            }\n+            if (normalPriority == null) {\n+                throw new IllegalStateException();\n+            }\n+            try {\n+                Method getContext = priorityClass.getMethod(\"getContext\");\n+                Object ctx = getContext.invoke(normalPriority);\n+                Method register = ctx.getClass().getMethod(\"register\", resourceClass);\n+                cracResource = Proxy.newProxyInstance(null, new Class<?>[] { jdkResourceClass }, new InvocationHandler() {\n+                    @Override\n+                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                        if (\"beforeCheckpoint\".equals(method.getName())) {\n+                            channel.close();\n+                        } else if (\"afterRestore\".equals(method.getName())) {\n+                            if (channel != null) {\n+                                channel = openFileChannel();\n+                            }\n+                        } else if (\"toString\".equals(method.getName())) {\n+                            return BasicImageReader.this.toString();\n+                        } else if (\"hashCode\".equals(method.getName())) {\n+                            return 0;\n+                        } else if (\"equals\".equals(method.getName())) {\n+                            return args[0] == cracResource;\n+                        } else {\n+                            throw new UnsupportedOperationException(method.toString());\n+                        }\n+                        return null;\n+                    }\n+                });\n+                register.invoke(ctx, cracResource);\n+            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        } catch (ClassNotFoundException e) {\n+            \/\/ ignored if class not present\n+        }\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private FileChannel openFileChannel() throws IOException {\n+        FileChannel channel = FileChannel.open(imagePath, StandardOpenOption.READ);\n+        \/\/ No lambdas during bootstrap\n+        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n+            @Override\n+            public Void run() {\n+                if (BasicImageReader.class.getClassLoader() == null) {\n+                    try {\n+                        Class<?> fileChannelImpl =\n+                            Class.forName(\"sun.nio.ch.FileChannelImpl\");\n+                        Method setUninterruptible =\n+                                fileChannelImpl.getMethod(\"setUninterruptible\");\n+                        setUninterruptible.invoke(channel);\n+                    } catch (ClassNotFoundException |\n+                             NoSuchMethodException |\n+                             IllegalAccessException |\n+                             InvocationTargetException ex) {\n+                        \/\/ fall thru - will only happen on JDK-8 systems where this code\n+                        \/\/ is only used by tools using jrt-fs (non-critical.)\n+                    }\n+                }\n+\n+                return null;\n+            }\n+        });\n+        return channel;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":90,"deletions":26,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.util.jar.PersistentJarFile;\n@@ -797,1 +798,1 @@\n-                return checkJar(new JarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n+                return checkJar(new PersistentJarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.internal.util.jar.PersistentJarFile;\n@@ -227,1 +228,1 @@\n-                return new JarFile(new File(path.toString()),\n+                return new PersistentJarFile(new File(path.toString()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleReferences.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -37,0 +35,6 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -43,1 +47,1 @@\n-public final class CleanerImpl implements Runnable {\n+public final class CleanerImpl implements Runnable, JDKResource {\n@@ -49,0 +53,1 @@\n+    private static JavaLangRefAccess javaLangRefAccess = SharedSecrets.getJavaLangRefAccess();\n@@ -58,0 +63,2 @@\n+    volatile boolean forceCleanup = false;\n+\n@@ -113,0 +120,1 @@\n+        Core.Priority.CLEANERS.getContext().register(this);\n@@ -137,0 +145,12 @@\n+            if (forceCleanup) {\n+                synchronized (phantomCleanableList) {\n+                    PhantomCleanable<?> next = phantomCleanableList;\n+                    do {\n+                        next = next.cleanIfNull();\n+                    } while (next != phantomCleanableList);\n+                }\n+                synchronized (this) {\n+                    forceCleanup = false;\n+                    notify();\n+                }\n+            }\n@@ -140,1 +160,1 @@\n-                Cleanable ref = (Cleanable) queue.remove(60 * 1000L);\n+                Cleanable ref = (Cleanable) javaLangRefAccess.pollReferenceQueue(queue, 60 * 1000L);\n@@ -149,0 +169,23 @@\n+        synchronized (this) {\n+            \/\/ wakeup the checkpoint thread when we this thread terminates before noticing\n+            \/\/ the forced cleanup\n+            forceCleanup = false;\n+            notify();\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (phantomCleanableList.isListEmpty()) {\n+            \/\/ The thread is already terminated; don't wait for anything\n+            return;\n+        }\n+        forceCleanup = true;\n+        javaLangRefAccess.wakeupReferenceQueue(queue);\n+        while (forceCleanup) {\n+            wait();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n@@ -200,0 +243,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"PhantomCleanableRef:\"  + action;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":52,"deletions":4,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -137,0 +137,20 @@\n+    PhantomCleanable<?> cleanIfNull() {\n+        if (this == list) {\n+            \/\/ The reference representing the list itself does not have\n+            \/\/ a referent, we will skip it.\n+            return next;\n+        }\n+        PhantomCleanable<?> oldNext = next;\n+        if (refersTo(null)) {\n+            try {\n+                clean();\n+            } catch (Throwable t) {\n+                \/\/ This method is called only from CleanerImpl and that one\n+                \/\/ ignores any exceptions thrown; we will do the same here.\n+                \/\/ The exception cannot be caught (and ignored) by the caller\n+                \/\/ since we want to continue traversing the list.\n+            }\n+        }\n+        return oldNext;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util.jar;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.JDKResource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.jar.JarFile;\n+\n+\/**\n+ * @crac It is assumed that JAR files opened through this class that are open\n+ * during checkpoint will be present on same path in the filesystem after\n+ * restore. Therefore, application does <strong>not<\/strong> have to close\n+ * these files before a checkpoint.\n+ *\/\n+public class PersistentJarFile extends JarFile implements JDKResource {\n+\n+    public PersistentJarFile(File file, boolean b, int openRead, Runtime.Version runtimeVersion) throws IOException {\n+        super(file, b, openRead, runtimeVersion);\n+        Core.Priority.NORMAL.getContext().register(this);\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        LoggerContainer.info(this.getName() + \" is recorded as always available on restore\");\n+        SharedSecrets.getJavaUtilZipFileAccess().beforeCheckpoint(this);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        \/\/ do nothing, no fixup required\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -138,0 +138,1 @@\n+    exports javax.crac;\n@@ -139,0 +140,1 @@\n+    exports jdk.crac;\n@@ -168,0 +170,1 @@\n+        java.management.rmi,\n@@ -177,0 +180,2 @@\n+    exports jdk.internal.crac to\n+        jdk.sctp;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-Gre kann auf ein Vielfaches der\\n                      Systemseitengre aufgerundet werden, wenn fr das Betriebssystem erforderlich.\\n    -Xverify          Legt den Modus der Bytecodeverifizierung fest\\n                      Beachten Sie, dass die Option -Xverify:none veraltet ist und\\n                      in einem zuknftigen Release entfernt werden kann.\\n    --add-reads <Modul>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, damit <Zielmodul> gelesen wird, ungeachtet\\n                      der Moduldeklaration. \\n                      <Zielmodul> kann ALL-UNNAMED sein, um alle unbenannten\\n                      Module zu lesen.\\n    --add-exports <Modul>\/<Package>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, um <Package> in <Zielmodul> zu exportieren,\\n                      ungeachtet der Moduldeklaration.\\n                      <Zielmodul> kann ALL-UNNAMED sein, um in alle\\n                      unbenannten Module zu exportieren.\\n    --add-opens <Modul>\/<Package>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, um <Package> in\\n                      <Zielmodul> zu ffnen, ungeachtet der Moduldeklaration.\\n    --limit-modules <Modulname>[,<Modulname>...]\\n                      Grenzt die Gesamtmenge der beobachtbaren Module ein\\n    --patch-module <Modul>=<Datei>({0}<Datei>)*\\n                      berschreibt oder erweitert ein Modul mit Klassen und Ressourcen\\n                      in JAR-Dateien oder Verzeichnissen.\\n    --source <Version>\\n                      Legt die Version der Quelle im Quelldateimodus fest.\\n    --finalization=<Wert>\\n                      Steuert, ob die JVM Objekte finalisiert.\\n                      Dabei ist <Wert> entweder \"enabled\" oder \"disabled\".\\n                      Die Finalisierung ist standardmig aktiviert.\\n\\nDiese zustzlichen Optionen knnen jederzeit ohne vorherige Ankndigung gendert werden.\\n\n+Gre kann auf ein Vielfaches der\\n                      Systemseitengre aufgerundet werden, wenn fr das Betriebssystem erforderlich.\\n    -Xverify          Legt den Modus der Bytecodeverifizierung fest\\n                      Beachten Sie, dass die Option -Xverify:none veraltet ist und\\n                      in einem zuknftigen Release entfernt werden kann.\\n    --add-reads <Modul>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, damit <Zielmodul> gelesen wird, ungeachtet\\n                      der Moduldeklaration. \\n                      <Zielmodul> kann ALL-UNNAMED sein, um alle unbenannten\\n                      Module zu lesen.\\n    --add-exports <Modul>\/<Package>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, um <Package> in <Zielmodul> zu exportieren,\\n                      ungeachtet der Moduldeklaration.\\n                      <Zielmodul> kann ALL-UNNAMED sein, um in alle\\n                      unbenannten Module zu exportieren.\\n    --add-opens <Modul>\/<Package>=<Zielmodul>(,<Zielmodul>)*\\n                      Aktualisiert <Modul>, um <Package> in\\n                      <Zielmodul> zu ffnen, ungeachtet der Moduldeklaration.\\n    --limit-modules <Modulname>[,<Modulname>...]\\n                      Grenzt die Gesamtmenge der beobachtbaren Module ein\\n    --patch-module <Modul>=<Datei>({0}<Datei>)*\\n                      berschreibt oder erweitert ein Modul mit Klassen und Ressourcen\\n                      in JAR-Dateien oder Verzeichnissen.\\n    --source <Version>\\n                      Legt die Version der Quelle im Quelldateimodus fest.\\n    --finalization=<Wert>\\n                      Steuert, ob die JVM Objekte finalisiert.\\n                      Dabei ist <Wert> entweder \"enabled\" oder \"disabled\".\\n                      Die Finalisierung ist standardmig aktiviert.\\n    --sun-misc-unsafe-memory-access=<value>\\n                      Verwendung der nicht untersttzten API sun.misc.Unsafe zulassen oder verweigern\\n                      <value> ist \"allow\", \"warn\", \"debug\" oder \"deny\".\\n                      Der Standardwert ist \"allow\".\\n\\nDiese zustzlichen Optionen knnen jederzeit ohne vorherige Ankndigung gendert werden.\\n\n@@ -55,0 +55,1 @@\n+java.launcher.jar.error5=Fehler: Beim Versuch, Datei {0} zu schlieen, ist ein unerwarteter Fehler aufgetreten\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher_de.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- \\n                      <target-module>ALL-UNNAMED\\n                      \\n    --add-exports <module>\/<package>=<target-module>(,<target-module>)*\\n                      <module><package><target-module>\\n                      \\n                      <target-module>ALL-UNNAMED\\n                      \\n    --add-opens <module>\/<package>=<target-module>(,<target-module>)*\\n                      <module><package>\\n                      <target-module>\\n    --limit-modules <module name>[,<module name>...]\\n                      \\n    --patch-module <module>=<file>({0}<file>)*\\n                      JAR\\n                      \\n    --source <version>\\n                      \\n    --finalization=<value>\\n                      JVM\\n                      <value>\"enabled\"\"disabled\"\\n                      \\n\\n\\n\n+ \\n                      <target-module>ALL-UNNAMED\\n                      \\n    --add-exports <module>\/<package>=<target-module>(,<target-module>)*\\n                      <module><package><target-module>\\n                      \\n                      <target-module>ALL-UNNAMED\\n                      \\n    --add-opens <module>\/<package>=<target-module>(,<target-module>)*\\n                      <module><package>\\n                      <target-module>\\n    --limit-modules <module name>[,<module name>...]\\n                      \\n    --patch-module <module>=<file>({0}<file>)*\\n                      JAR\\n                      \\n    --source <version>\\n                      \\n    --finalization=<value>\\n                      JVM\\n                      <value>\"enabled\"\"disabled\"\\n                      \\n    --sun-misc-unsafe-memory-access=<value>\\n                      API sun.misc.Unsafe\\n                      <value>\"allow\"\"warn\"\"debug\"\"deny\"\\n                      \"allow\"\\n\\n\\n\n@@ -57,0 +57,1 @@\n+java.launcher.jar.error5=: {0}\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher_ja.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- \\n    -XshowSettings:security:providers\\n                      \\n    -XshowSettings:security:tls\\n                       TLS \\n    -XshowSettings:system\\n                       Linux\\n                      \\n    -Xss<size>         Java \\n                      \\n                      \\n    -Xverify          \\n                       -Xverify:none \\n                      \\n    --add-reads <module>=<target-module>(,<target-module>)*\\n                       <module>  <target-module>\\n                       \\n                      <target-module>  ALL-UNNAMED\\n                      \\n    --add-exports <module>\/<package>=<target-module>(,<target-module>)*\\n                       <module>  <package>  <target-module>\\n                      \\n                      <target-module>  ALL-UNNAMED\\n                      \\n    --add-opens <module>\/<package>=<target-module>(,<target-module>)*\\n                       <module>  <target-module> \\n                      <package>\\n    --limit-modules <module name>[,<module name>...]\\n                      \\n    --patch-module <module>=<file>({0}<file>)*\\n                       JAR \\n                      \\n    --source <version>\\n                      \\n    --finalization=<value>\\n                       JVM \\n                       <value>  \"enabled\"  \"disabled\" \\n                      \\n\\n, \\n\n+ \\n    -XshowSettings:security:providers\\n                      \\n    -XshowSettings:security:tls\\n                       TLS \\n    -XshowSettings:system\\n                       Linux\\n                      \\n    -Xss<size>         Java \\n                      \\n                      \\n    -Xverify          \\n                       -Xverify:none \\n                      \\n    --add-reads <module>=<target-module>(,<target-module>)*\\n                       <module>  <target-module>\\n                       \\n                      <target-module>  ALL-UNNAMED\\n                      \\n    --add-exports <module>\/<package>=<target-module>(,<target-module>)*\\n                       <module>  <package>  <target-module>\\n                      \\n                      <target-module>  ALL-UNNAMED\\n                      \\n    --add-opens <module>\/<package>=<target-module>(,<target-module>)*\\n                       <module>  <target-module> \\n                      <package>\\n    --limit-modules <module name>[,<module name>...]\\n                      \\n    --patch-module <module>=<file>({0}<file>)*\\n                       JAR \\n                      \\n    --source <version>\\n                      \\n    --finalization=<value>\\n                       JVM \\n                       <value>  \"enabled\"  \"disabled\" \\n                      \\n    --sun-misc-unsafe-memory-access=<value>\\n                       API sun.misc.Unsafe\\n                      <value>  \"allow\"\"warn\"\"debug\"  \"deny\" \\n                       \"allow\"\\n\\n, \\n\n@@ -55,0 +55,1 @@\n+java.launcher.jar.error5= {0} \n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher_zh_CN.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.JDKFileResource;\n+\n@@ -49,0 +54,29 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fdObj;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            \/\/ TODO: we don't have information about the path without introspecting FD\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (isOpen()) {\n+                super.beforeCheckpoint(context);\n+            }\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousFileChannelImpl.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+\n+import jdk.internal.crac.JDKSocketResource;\n@@ -53,0 +55,1 @@\n+    private final JDKSocketResource resource;\n@@ -73,0 +76,21 @@\n+        this.resource = new JDKSocketResource(this) {\n+            @Override\n+            protected FileDescriptor getFD() {\n+                return fd;\n+            }\n+\n+            @Override\n+            protected SocketAddress localAddress() {\n+                return localAddress;\n+            }\n+\n+            @Override\n+            protected SocketAddress remoteAddress() {\n+                return null;\n+            }\n+\n+            @Override\n+            protected void closeBeforeCheckpoint() throws IOException {\n+                close();\n+            }\n+        };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+\n+import jdk.internal.crac.JDKSocketResource;\n@@ -54,0 +56,2 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new Resource();\n@@ -606,0 +610,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(AsynchronousSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -107,0 +108,1 @@\n+    private final JDKSocketResource resource = new Resource();\n@@ -809,0 +811,3 @@\n+    \/**\n+     * Receives a datagram into a direct buffer.\n+     *\/\n@@ -815,0 +820,1 @@\n+            long bufAddress = NIO_ACCESS.getBufferAddress(bb);\n@@ -816,1 +822,2 @@\n-                             ((DirectBuffer)bb).address() + pos, rem,\n+                             bufAddress + pos,\n+                             rem,\n@@ -994,0 +1001,3 @@\n+    \/**\n+     * Send a datagram contained in a direct buffer.\n+     *\/\n@@ -1006,0 +1016,1 @@\n+            long bufAddress = NIO_ACCESS.getBufferAddress(bb);\n@@ -1007,2 +1018,5 @@\n-            written = send0(fd, ((DirectBuffer)bb).address() + pos, rem,\n-                            targetSockAddr.address(), addressLen);\n+            written = send0(fd,\n+                            bufAddress + pos,\n+                            rem,\n+                            targetSockAddr.address(),\n+                            addressLen);\n@@ -1936,0 +1950,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n@@ -2077,0 +2096,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(DatagramChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -53,0 +56,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -83,0 +87,34 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (!isOpen() || path == null) {\n+                return;\n+            } else if (parent != null) {\n+                \/\/ This FileChannel is managed by a higher level object that\n+                \/\/ will handle the provided file descriptor on its own.\n+                return;\n+            }\n+            super.beforeCheckpoint(context);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ implementation is possible but non-trivial\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -129,0 +130,5 @@\n+    static {\n+        \/\/ trigger eager initialization\n+        new FileDispatcherImpl();\n+    }\n+\n@@ -1209,1 +1215,1 @@\n-    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+    private static Runnable closerFor0(FileDescriptor fd, boolean stream) {\n@@ -1232,0 +1238,14 @@\n+    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+\n+        \/\/ FIXME ensure FileDispatcherImpl's Resource is registered before the closer is used,\n+        \/\/ otherwise the closer during beforeCheckpoint may be the first one to access\n+        \/\/ FileDescriptor, and then Dispatcher Resource will be blocked for registration.\n+        try {\n+            MethodHandles.lookup().ensureInitialized(FileDispatcherImpl.class);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        return closerFor0(fd, stream);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -78,0 +79,1 @@\n+    private final Resource resource = new Resource();\n@@ -414,1 +416,0 @@\n-\n@@ -657,0 +658,3 @@\n+        \/\/ wait for any accept operation to complete before trying to close\n+        acceptLock.lock();\n+        acceptLock.unlock();\n@@ -758,0 +762,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(ServerSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -86,0 +87,1 @@\n+    private final Resource resource = new Resource();\n@@ -1219,0 +1221,5 @@\n+        \/\/ wait for any read\/write operations to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n+        writeLock.lock();\n+        writeLock.unlock();\n@@ -1630,0 +1637,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(SocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -145,2 +150,2 @@\n-    private static final class UnclosableInputStream extends FilterInputStream {\n-        UnclosableInputStream(InputStream in) {\n+    private static final class UnclosableInputStream extends FilterInputStream implements JDKResource {\n+        UnclosableInputStream(FileInputStream in) {\n@@ -148,0 +153,1 @@\n+            Core.Priority.NORMAL.getContext().register(this);\n@@ -158,0 +164,11 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            FileDescriptor fd = ((FileInputStream)in).getFD();\n+            Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/FileInputStreamPool.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+\n@@ -35,0 +39,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.Arrays;\n@@ -52,0 +58,10 @@\n+ * @crac If this class is created using the {@link #SecureRandom() no-arg constructor}\n+ * and never {@link #engineSetSeed(byte[]) reseeded} it is automatically reseeded\n+ * after restore from a checkpoint. Therefore, after restore the sequences produced\n+ * during different runs should differ (and the application will consume system entropy).\n+ * If a seed was provided externally the application might depend on the sequence\n+ * produced by this generator, therefore it is not reseeded.\n+ * If this behaviour is not desired the application should {@link javax.crac.Context#register(javax.crac.Resource) register}\n+ * a resource and in the {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method}\n+ * reseed it using the {@link #engineSetSeed(byte[])}.\n+ *\n@@ -58,1 +74,1 @@\n-implements java.io.Serializable {\n+implements java.io.Serializable, jdk.internal.crac.JDKResource {\n@@ -68,0 +84,2 @@\n+    private boolean clearStateOnCheckpoint = true;\n+    private ReentrantLock objLock = new ReentrantLock();\n@@ -85,0 +103,4 @@\n+     *\n+     * @crac Instances created using this constructor are automatically\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n@@ -94,0 +116,4 @@\n+     * @crac Instances created using this constructor are <strong>not<\/strong>\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n+     *\n@@ -124,0 +150,1 @@\n+        Core.Priority.SECURE_RANDOM.getContext().register(this);\n@@ -156,0 +183,4 @@\n+     * @crac After this method is called the instance is <strong>not<\/strong>\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n+     *\n@@ -159,1 +190,14 @@\n-    public synchronized void engineSetSeed(byte[] seed) {\n+    public void engineSetSeed(byte[] seed) {\n+        objLock.lock();\n+        try {\n+            \/\/ check if objLock has not been already acquired in beforeCheckpoint\n+            if(objLock.getHoldCount() > 1) {\n+                throw new IllegalStateException(\"SHA1PRNG object is invalidated\");\n+            }\n+            setSeedImpl(seed);\n+        } finally {\n+            objLock.unlock();\n+        }\n+    }\n+\n+    private void setSeedImpl(byte[] seed) {\n@@ -166,0 +210,1 @@\n+        clearStateOnCheckpoint = false;\n@@ -193,0 +238,26 @@\n+    private void invalidate() {\n+        assert objLock.isHeldByCurrentThread();\n+        if (state != null) {\n+            Arrays.fill(state, (byte)0);\n+        }\n+        state = null;\n+        if (remainder != null) {\n+            Arrays.fill(remainder, (byte)0);\n+        }\n+        remainder = null;\n+        remCount = 0;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        objLock.lock();\n+        if (clearStateOnCheckpoint) {\n+            invalidate();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        objLock.unlock();\n+    }\n+\n@@ -199,1 +270,3 @@\n-    private static class SeederHolder {\n+    private static class SeederHolder implements jdk.internal.crac.JDKResource {\n+        private static final SeederHolder seederHolder = new SeederHolder();\n+        private final SecureRandom seeder;\n@@ -201,3 +274,1 @@\n-        private static final SecureRandom seeder;\n-\n-        static {\n+        private SeederHolder() {\n@@ -209,1 +280,1 @@\n-            byte [] b = new byte[DIGEST_SIZE];\n+            byte[] b = new byte[DIGEST_SIZE];\n@@ -212,0 +283,17 @@\n+            Core.Priority.SEEDER_HOLDER.getContext().register(this);\n+        }\n+\n+        public static SecureRandom getSeeder() {\n+            return seederHolder.seeder;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            seeder.invalidate();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            byte[] b = new byte[DIGEST_SIZE];\n+            SeedGenerator.generateSeed(b);\n+            seeder.setSeedImpl(b);\n@@ -221,10 +309,10 @@\n-    public synchronized void engineNextBytes(byte[] result) {\n-        int index = 0;\n-        int todo;\n-        byte[] output = remainder;\n-\n-        if (state == null) {\n-            byte[] seed = new byte[DIGEST_SIZE];\n-            SeederHolder.seeder.engineNextBytes(seed);\n-            state = digest.digest(seed);\n-        }\n+    public void engineNextBytes(byte[] result) {\n+        objLock.lock();\n+        try {\n+            \/\/ verify if objLock is already acquired in beforeCheckpoint\n+            if(objLock.getHoldCount() > 1) {\n+                throw new IllegalStateException(\"SHA1PRNG object is invalidated\");\n+            }\n+            int index = 0;\n+            int todo;\n+            byte[] output = remainder;\n@@ -232,9 +320,4 @@\n-        \/\/ Use remainder from last time\n-        int r = remCount;\n-        if (r > 0) {\n-            \/\/ How many bytes?\n-            todo = Math.min(result.length - index, DIGEST_SIZE - r);\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[i] = output[r];\n-                output[r++] = 0;\n+            if (state == null) {\n+                byte[] seed = new byte[DIGEST_SIZE];\n+                SeederHolder.getSeeder().engineNextBytes(seed);\n+                state = digest.digest(seed);\n@@ -242,3 +325,0 @@\n-            remCount += todo;\n-            index += todo;\n-        }\n@@ -246,13 +326,12 @@\n-        \/\/ If we need more bytes, make them.\n-        while (index < result.length) {\n-            \/\/ Step the state\n-            digest.update(state);\n-            output = digest.digest();\n-            updateState(state, output);\n-\n-            \/\/ How many bytes?\n-            todo = Math.min((result.length - index), DIGEST_SIZE);\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[index++] = output[i];\n-                output[i] = 0;\n+            \/\/ Use remainder from last time\n+            int r = remCount;\n+            if (r > 0) {\n+                \/\/ How many bytes?\n+                todo = Math.min(result.length - index, DIGEST_SIZE - r);\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[i] = output[r];\n+                    output[r++] = 0;\n+                }\n+                remCount += todo;\n+                index += todo;\n@@ -260,2 +339,0 @@\n-            remCount += todo;\n-        }\n@@ -263,3 +340,23 @@\n-        \/\/ Store remainder for next time\n-        remainder = output;\n-        remCount %= DIGEST_SIZE;\n+            \/\/ If we need more bytes, make them.\n+            while (index < result.length) {\n+                \/\/ Step the state\n+                digest.update(state);\n+                output = digest.digest();\n+                updateState(state, output);\n+\n+                \/\/ How many bytes?\n+                todo = Math.min((result.length - index), DIGEST_SIZE);\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[index++] = output[i];\n+                    output[i] = 0;\n+                }\n+                remCount += todo;\n+            }\n+\n+            \/\/ Store remainder for next time\n+            remainder = output;\n+            remCount %= DIGEST_SIZE;\n+        } finally {\n+            objLock.unlock();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":144,"deletions":47,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    protected int multByInt(long[] a, long b) {\n+    protected void multByInt(long[] a, long b) {\n@@ -98,1 +98,0 @@\n-        return 0;\n@@ -107,1 +106,1 @@\n-    protected abstract int mult(long[] a, long[] b, long[] r);\n+    protected abstract void mult(long[] a, long[] b, long[] r);\n@@ -115,1 +114,1 @@\n-    protected abstract int square(long[] a, long[] r);\n+    protected abstract void square(long[] a, long[] r);\n@@ -625,2 +624,2 @@\n-            int numAdds = mult(limbs, b.limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, numAdds);\n+            mult(limbs, b.limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, 0);\n@@ -638,2 +637,2 @@\n-            int numAdds = IntegerPolynomial.this.square(limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, numAdds);\n+            IntegerPolynomial.this.square(limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, 0);\n@@ -754,1 +753,2 @@\n-            numAdds = mult(limbs, b.limbs, limbs);\n+            mult(limbs, b.limbs, limbs);\n+            numAdds = 0;\n@@ -767,1 +767,2 @@\n-            numAdds += multByInt(limbs, value);\n+            multByInt(limbs, value);\n+            numAdds = 0;\n@@ -827,1 +828,2 @@\n-            numAdds = IntegerPolynomial.this.square(limbs, limbs);\n+            IntegerPolynomial.this.square(limbs, limbs);\n+            numAdds = 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    protected void mult(long[] a, long[] b, long[] r) {\n@@ -76,1 +76,0 @@\n-        return 0;\n@@ -103,1 +102,1 @@\n-    protected int square(long[] a, long[] r) {\n+    protected void square(long[] a, long[] r) {\n@@ -126,1 +125,0 @@\n-        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial1305.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    protected void mult(long[] a, long[] b, long[] r) {\n@@ -139,1 +139,0 @@\n-        return 0;\n@@ -192,1 +191,1 @@\n-    protected int square(long[] a, long[] r) {\n+    protected void square(long[] a, long[] r) {\n@@ -203,1 +202,0 @@\n-        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialModBinP.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -106,2 +107,2 @@\n-        int numAdds = mult(vLimbs, h, montLimbs);\n-        return new ImmutableElement(montLimbs, numAdds);\n+        mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, 0);\n@@ -117,18 +118,0 @@\n-    \/*\n-     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to\n-     * multiply by a small constant (i.e. (int) 1,2,3,4). Instead of doing a\n-     * montgomery conversion followed by a montgomery multiplication, just use\n-     * the spare top (64-BITS_PER_LIMB) bits to multiply by a constant. (See [1]\n-     * Section 4 )\n-     *\n-     * Will return an unreduced value\n-     *\/\n-    @Override\n-    protected int multByInt(long[] a, long b) {\n-        assert (b < (1 << BITS_PER_LIMB));\n-        for (int i = 0; i < a.length; i++) {\n-            a[i] *= b;\n-        }\n-        return (int) (b - 1);\n-    }\n-\n@@ -166,2 +149,2 @@\n-    protected int square(long[] a, long[] r) {\n-        return mult(a, a, r);\n+    protected void square(long[] a, long[] r) {\n+        mult(a, a, r);\n@@ -170,0 +153,1 @@\n+\n@@ -177,0 +161,7 @@\n+    @Override\n+    protected void mult(long[] a, long[] b, long[] r) {\n+        multImpl(a, b, r);\n+        reducePositive(r);\n+    }\n+\n+    @ForceInline\n@@ -178,1 +169,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    private void multImpl(long[] a, long[] b, long[] r) {\n@@ -411,30 +402,10 @@\n-        c6 += d2 + dd1 + (c5 >>> BITS_PER_LIMB);\n-        c7 += d3 + dd2 + (c6 >>> BITS_PER_LIMB);\n-        c8 += d4 + dd3 + (c7 >>> BITS_PER_LIMB);\n-        c9 = dd4 + (c8 >>> BITS_PER_LIMB);\n-\n-        c5 &= LIMB_MASK;\n-        c6 &= LIMB_MASK;\n-        c7 &= LIMB_MASK;\n-        c8 &= LIMB_MASK;\n-\n-        \/\/ At this point, the result could overflow by one modulus.\n-        c0 = c5 - modulus[0];\n-        c1 = c6 - modulus[1] + (c0 >> BITS_PER_LIMB);\n-        c0 &= LIMB_MASK;\n-        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n-        c1 &= LIMB_MASK;\n-        c3 = c8 - modulus[3] + (c2 >> BITS_PER_LIMB);\n-        c2 &= LIMB_MASK;\n-        c4 = c9 - modulus[4] + (c3 >> BITS_PER_LIMB);\n-        c3 &= LIMB_MASK;\n-\n-        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n-\n-        r[0] = ((c5 & mask) | (c0 & ~mask));\n-        r[1] = ((c6 & mask) | (c1 & ~mask));\n-        r[2] = ((c7 & mask) | (c2 & ~mask));\n-        r[3] = ((c8 & mask) | (c3 & ~mask));\n-        r[4] = ((c9 & mask) | (c4 & ~mask));\n-\n-        return 0;\n+        c6 += d2 + dd1;\n+        c7 += d3 + dd2;\n+        c8 += d4 + dd3;\n+        c9 = dd4;\n+\n+        r[0] = c5;\n+        r[1] = c6;\n+        r[2] = c7;\n+        r[3] = c8;\n+        r[4] = c9;\n@@ -519,2 +490,2 @@\n-        int numAdds = mult(vLimbs, h, montLimbs);\n-        return new ImmutableElement(montLimbs, numAdds);\n+        mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, 0);\n@@ -559,0 +530,23 @@\n+\n+    \/\/ Used when limbs a could overflow by one modulus.\n+    @ForceInline\n+    protected void reducePositive(long[] a) {\n+        long aa0 = a[0];\n+        long aa1 = a[1] + (aa0>>BITS_PER_LIMB);\n+        long aa2 = a[2] + (aa1>>BITS_PER_LIMB);\n+        long aa3 = a[3] + (aa2>>BITS_PER_LIMB);\n+        long aa4 = a[4] + (aa3>>BITS_PER_LIMB);\n+\n+        long c0 = a[0] - modulus[0];\n+        long c1 = a[1] - modulus[1] + (c0 >> BITS_PER_LIMB);\n+        long c2 = a[2] - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        long c3 = a[3] - modulus[3] + (c2 >> BITS_PER_LIMB);\n+        long c4 = a[4] - modulus[4] + (c3 >> BITS_PER_LIMB);\n+        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        a[0] = ((aa0 & mask) | (c0 & ~mask)) & LIMB_MASK;\n+        a[1] = ((aa1 & mask) | (c1 & ~mask)) & LIMB_MASK;\n+        a[2] = ((aa2 & mask) | (c2 & ~mask)) & LIMB_MASK;\n+        a[3] = ((aa3 & mask) | (c3 & ~mask)) & LIMB_MASK;\n+        a[4] = ((aa4 & mask) | (c4 & ~mask));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":49,"deletions":55,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,0 +290,1 @@\n+ZWG=ZWG\n@@ -515,0 +516,1 @@\n+zwg=Zimbabwe Gold\n","filename":"src\/java.base\/share\/classes\/sun\/util\/resources\/CurrencyNames.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-dataVersion=176\n+dataVersion=177\n@@ -59,2 +59,2 @@\n-    XPT962-XSU994-XTS963-XUA965-XXX999-YER886-YUM891-ZAR710-ZMK894-ZMW967-ZWD716-ZWL932-\\\n-    ZWN942-ZWR935\n+    XPT962-XSU994-XTS963-XUA965-XXX999-YER886-YUM891-ZAR710-ZMK894-ZMW967-ZWD716-ZWG924-\\\n+    ZWL932-ZWN942-ZWR935\n@@ -585,1 +585,1 @@\n-ZW=ZWL\n+ZW=ZWG\n","filename":"src\/java.base\/share\/data\/currency\/CurrencyData.properties","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-File-Date: 2024-05-16\n+File-Date: 2024-06-14\n@@ -48012,0 +48012,1 @@\n+Deprecated: 2024-06-08\n@@ -48013,0 +48014,1 @@\n+Comments: Preferred tag is cls\n@@ -48388,0 +48390,1 @@\n+Deprecated: 2024-06-08\n@@ -48391,0 +48394,1 @@\n+Comments: Preferred tag is vsn\n","filename":"src\/java.base\/share\/data\/lsrdata\/language-subtag-registry.txt","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-.TH \"JAVA\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n@@ -1198,1 +1198,1 @@\n-\\f[V]--sun-misc-unsafe-memory-acces=\\f[R] \\f[I]value\\f[R]\n+\\f[V]--sun-misc-unsafe-memory-access=\\f[R] \\f[I]value\\f[R]\n@@ -1329,1 +1329,22 @@\n-\\f[V]-XX:ErrorFile=\\f[R]\\f[I]filename\\f[R]\n+\\f[V]-XX:CRaCCheckpointTo=\\f[R]\\f[I]directory\\f[R]\n+The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+a running Java program into an image directory. Restoring from the image should\n+solve some of the problematic start-up and warm-up times.\n+.PP\n+This option defines a path to the snapshot which is currently a directory. The\n+directory will be created if it does not exist, but no parent directories are\n+created.\n+.RS\n+.RE\n+.TP\n+\\f[V]-XX:CRaCRestoreFrom=\\f[R]\\f[I]directory\\f[R]\n+Restores a snapshot created by\n+\\f[V]-XX:CRaCCheckpointTo=\\f[R]\\f[I]directory\\f[R].\n+.RS\n+.RE\n+.TP\n+\\f[V]-XX:CRaCMinPid=\\f[R]value\\f[R]\n+A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+.RS\n+.RE\n+.TP\n@@ -1713,1 +1734,1 @@\n-\\f[V]-XX:StartFlightRecording=\\f[R]\\f[I]parameter\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R]\n+\\f[V]-XX:StartFlightRecording:\\f[R]\\f[I]parameter\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R]\n@@ -1717,0 +1738,2 @@\n+\\f[V]-XX:StartFlightRecording:help\\f[R] prints available options and\n+example command lines.\n@@ -1763,0 +1786,2 @@\n+The filename may also be a directory in which case, the filename is\n+generated from the PID and the current date in the specified directory.\n@@ -1843,0 +1868,3 @@\n+.PP\n+To only see warnings and errors from JFR during startup set\n+-Xlog:jfr+startup=warning.\n@@ -2291,0 +2319,9 @@\n+\\f[V]-XX:CPUFeatures=\\f[R]\\f[I]0xnumber\\f[R]\n+CPU feature set, use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when\n+you get an error during -XX:CRaCRestoreFrom on a different machine.\n+\\f[V]-XX:CPUFeatures=native\\f[R] is the default.\n+\\f[V]-XX:CPUFeatures=generic\\f[R] is compatible with any CPU but not as slow\n+as \\f[V]-XX:CPUFeatures=0\\f[R].\n+.RS\n+.RE\n+.TP\n@@ -2534,0 +2571,6 @@\n+\\f[V]-XX:+ShowCPUFeatures\\f[R]\n+Show features of this CPU to be possibly used for the\n+\\f[V]-XX:CPUFeatures=0xnumber\\f[R] option.\n+.RS\n+.RE\n+.TP\n@@ -3487,10 +3530,0 @@\n-\\f[V]-XX:+ScavengeBeforeFullGC\\f[R]\n-Enables GC of the young generation before each full GC.\n-This option is enabled by default.\n-It is recommended that you \\f[I]don\\[aq]t\\f[R] disable it, because\n-scavenging the young generation before a full GC can reduce the number\n-of objects reachable from the old generation space into the young\n-generation space.\n-To disable GC of the young generation before each full GC, specify the\n-option \\f[V]-XX:-ScavengeBeforeFullGC\\f[R].\n-.TP\n@@ -3751,39 +3784,0 @@\n-\\f[V]-XX:InitialRAMFraction=\\f[R]\\f[I]ratio\\f[R]\n-Sets the initial amount of memory that the JVM may use for the Java heap\n-before applying ergonomics heuristics as a ratio of the maximum amount\n-determined as described in the \\f[V]-XX:MaxRAM\\f[R] option.\n-The default value is 64.\n-.RS\n-.PP\n-Use the option \\f[V]-XX:InitialRAMPercentage\\f[R] instead.\n-.RE\n-.TP\n-\\f[V]-XX:MaxRAMFraction=\\f[R]\\f[I]ratio\\f[R]\n-Sets the maximum amount of memory that the JVM may use for the Java heap\n-before applying ergonomics heuristics as a fraction of the maximum\n-amount determined as described in the \\f[V]-XX:MaxRAM\\f[R] option.\n-The default value is 4.\n-.RS\n-.PP\n-Specifying this option disables automatic use of compressed oops if the\n-combined result of this and other options influencing the maximum amount\n-of memory is larger than the range of memory addressable by compressed\n-oops.\n-See \\f[V]-XX:UseCompressedOops\\f[R] for further information about\n-compressed oops.\n-.PP\n-Use the option \\f[V]-XX:MaxRAMPercentage\\f[R] instead.\n-.RE\n-.TP\n-\\f[V]-XX:MinRAMFraction=\\f[R]\\f[I]ratio\\f[R]\n-Sets the maximum amount of memory that the JVM may use for the Java heap\n-before applying ergonomics heuristics as a fraction of the maximum\n-amount determined as described in the \\f[V]-XX:MaxRAM\\f[R] option for\n-small heaps.\n-A small heap is a heap of approximately 125 MB.\n-The default value is 2.\n-.RS\n-.PP\n-Use the option \\f[V]-XX:MinRAMPercentage\\f[R] instead.\n-.RE\n-.TP\n@@ -3878,0 +3872,49 @@\n+.TP\n+\\f[V]-XX:+ScavengeBeforeFullGC\\f[R]\n+Enables GC of the young generation before each full GC.\n+This option is enabled by default.\n+It is recommended that you \\f[I]don\\[aq]t\\f[R] disable it, because\n+scavenging the young generation before a full GC can reduce the number\n+of objects reachable from the old generation space into the young\n+generation space.\n+To disable GC of the young generation before each full GC, specify the\n+option \\f[V]-XX:-ScavengeBeforeFullGC\\f[R].\n+.TP\n+\\f[V]-XX:InitialRAMFraction=\\f[R]\\f[I]ratio\\f[R]\n+Sets the initial amount of memory that the JVM may use for the Java heap\n+before applying ergonomics heuristics as a ratio of the maximum amount\n+determined as described in the \\f[V]-XX:MaxRAM\\f[R] option.\n+The default value is 64.\n+.RS\n+.PP\n+Use the option \\f[V]-XX:InitialRAMPercentage\\f[R] instead.\n+.RE\n+.TP\n+\\f[V]-XX:MaxRAMFraction=\\f[R]\\f[I]ratio\\f[R]\n+Sets the maximum amount of memory that the JVM may use for the Java heap\n+before applying ergonomics heuristics as a fraction of the maximum\n+amount determined as described in the \\f[V]-XX:MaxRAM\\f[R] option.\n+The default value is 4.\n+.RS\n+.PP\n+Specifying this option disables automatic use of compressed oops if the\n+combined result of this and other options influencing the maximum amount\n+of memory is larger than the range of memory addressable by compressed\n+oops.\n+See \\f[V]-XX:UseCompressedOops\\f[R] for further information about\n+compressed oops.\n+.PP\n+Use the option \\f[V]-XX:MaxRAMPercentage\\f[R] instead.\n+.RE\n+.TP\n+\\f[V]-XX:MinRAMFraction=\\f[R]\\f[I]ratio\\f[R]\n+Sets the maximum amount of memory that the JVM may use for the Java heap\n+before applying ergonomics heuristics as a fraction of the maximum\n+amount determined as described in the \\f[V]-XX:MaxRAM\\f[R] option for\n+small heaps.\n+A small heap is a heap of approximately 125 MB.\n+The default value is 2.\n+.RS\n+.PP\n+Use the option \\f[V]-XX:MinRAMPercentage\\f[R] instead.\n+.RE\n","filename":"src\/java.base\/share\/man\/java.1","additions":96,"deletions":53,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-.TH \"KEYTOOL\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"KEYTOOL\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n@@ -1750,1 +1750,1 @@\n-\\f[V]BC\\f[R] or \\f[V]BasicContraints\\f[R]\n+\\f[V]BC\\f[R] or \\f[V]BasicConstraints\\f[R]\n","filename":"src\/java.base\/share\/man\/keytool.1","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,7 @@\n+#ifndef WIN32\n+#include <errno.h>\n+#endif\n+#ifdef LINUX\n+#include <syscall.h>\n+#endif\n+\n@@ -56,0 +63,143 @@\n+\n+#ifndef _WIN32\n+#include <sys\/wait.h>\n+\n+static int is_checkpoint = 0;\n+static const int crac_min_pid_default = 128;\n+static int crac_min_pid = 0;\n+static int is_min_pid_set = 0;\n+\n+static void parse_checkpoint(const char *arg) {\n+    if (!is_checkpoint) {\n+        const char *checkpoint_arg = \"-XX:CRaCCheckpointTo\";\n+        const int len = strlen(checkpoint_arg);\n+        if (0 == strncmp(arg, checkpoint_arg, len)) {\n+            is_checkpoint = 1;\n+        }\n+    }\n+    if (!is_min_pid_set) {\n+        const char *checkpoint_arg = \"-XX:CRaCMinPid=\";\n+        const int len = strlen(checkpoint_arg);\n+        if (0 == strncmp(arg, checkpoint_arg, len)) {\n+            crac_min_pid = atoi(arg + len);\n+            is_min_pid_set = 1;\n+        }\n+    }\n+}\n+\n+static pid_t g_child_pid = -1;\n+\n+static int wait_for_children() {\n+    int status = -1;\n+    pid_t pid;\n+    do {\n+        int st = 0;\n+        pid = wait(&st);\n+        if (pid == g_child_pid) {\n+            status = st;\n+        }\n+    } while (-1 != pid || ECHILD != errno);\n+\n+    if (WIFEXITED(status)) {\n+        return WEXITSTATUS(status);\n+    }\n+\n+    if (WIFSIGNALED(status)) {\n+        \/\/ Try to terminate the current process with the same signal\n+        \/\/ as the child process was terminated\n+        const int sig = WTERMSIG(status);\n+        signal(sig, SIG_DFL);\n+        raise(sig);\n+        \/\/ Signal was ignored, return 128+n as bash does\n+        \/\/ see https:\/\/linux.die.net\/man\/1\/bash\n+        return 128+sig;\n+    }\n+\n+    return 1;\n+}\n+\n+static void sighandler(int sig, siginfo_t *info, void *param) {\n+    if (0 < g_child_pid) {\n+        kill(g_child_pid, sig);\n+    }\n+}\n+\n+static void setup_sighandler() {\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    const int MaxSignalValue = 31;\n+    for (int sig = 1; sig <= MaxSignalValue; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(\"sigprocmask\");\n+    }\n+}\n+\n+static int set_last_pid(int pid) {\n+#ifdef LINUX\n+    char buf[11]; \/\/ enough for int32\n+    const int len = snprintf(buf, sizeof(buf), \"%d\", pid);\n+    if (0 > len || sizeof(buf) < (size_t)len) {\n+        return EINVAL;\n+    }\n+    const char *last_pid_filename = \"\/proc\/sys\/kernel\/ns_last_pid\";\n+    const int last_pid_file = open(last_pid_filename, O_WRONLY|O_TRUNC, 0666);\n+    if (0 > last_pid_file) {\n+        return errno;\n+    }\n+    int res = 0;\n+    if (len > write(last_pid_file, buf, len)) {\n+        res = errno;\n+    }\n+    close(last_pid_file);\n+    return res;\n+#else\n+    return EPERM;\n+#endif\n+}\n+\n+static void spin_last_pid(int pid) {\n+    const int MaxSpinCount = pid < 1000 ? 1000 : pid;\n+    int cnt = MaxSpinCount;\n+    int child = 0;\n+    int prev = 0;\n+    do {\n+        child = fork();\n+        if (0 > child) {\n+            perror(\"spin_last_pid clone\");\n+            exit(1);\n+        }\n+        if (0 == child) {\n+            exit(0);\n+        }\n+        if (child < prev) {\n+            fprintf(stderr, \"%s: Invalid argument (%d)\\n\", __FUNCTION__, pid);\n+            exit(1);\n+        }\n+        if (0 >= cnt) {\n+            fprintf(stderr, \"%s: Can't reach pid %d, out of try count. Current pid=%d\\n\", __FUNCTION__, pid, child);\n+            exit(1);\n+        }\n+        prev = child;\n+        int status;\n+        if (0 > waitpid(child, &status, 0)) {\n+            perror(\"spin_last_pid waitpid\");\n+            exit(1);\n+        }\n+        --cnt;\n+    } while (child < pid);\n+}\n+#endif \/\/ _WIN32\n+\n@@ -146,0 +296,1 @@\n+            parse_checkpoint(argv[i]);\n@@ -165,0 +316,40 @@\n+\n+    const int is_init = 1 == getpid();\n+    if (is_init && !is_min_pid_set) {\n+        crac_min_pid = crac_min_pid_default;\n+    }\n+    const int needs_pid_adjust = getpid() < crac_min_pid;\n+    if (is_checkpoint && (is_init || needs_pid_adjust)) {\n+        \/\/ Move PID value for new processes to a desired value\n+        \/\/ to avoid PID conflicts on restore.\n+        if (needs_pid_adjust) {\n+            const int res = set_last_pid(crac_min_pid);\n+            if (EPERM == res || EACCES == res || EROFS == res) {\n+                spin_last_pid(crac_min_pid);\n+            } else if (0 != res) {\n+                fprintf(stderr, \"set_last_pid: %s\\n\", strerror(res));\n+                exit(1);\n+            }\n+        }\n+\n+        \/\/ Avoid unexpected process completion when checkpointing under docker container run\n+        \/\/ by creating the main process waiting for children before exit.\n+        g_child_pid = fork();\n+        if (0 == g_child_pid && needs_pid_adjust && getpid() < crac_min_pid) {\n+            if (is_min_pid_set) {\n+                fprintf(stderr, \"Error: Can't adjust PID to min PID %d, current PID %d\\n\", crac_min_pid, (int)getpid());\n+                exit(1);\n+            } else {\n+                fprintf(stderr,\n+                        \"Warning: Can't adjust PID to min PID %d, current PID %d.\\n\"\n+                        \"This message can be suppressed by '-XX:CRaCMinPid=1' option\\n\",\n+                        crac_min_pid, (int)getpid());\n+            }\n+        }\n+        if (0 < g_child_pid) {\n+            \/\/ The main process should forward signals to the child.\n+            setup_sighandler();\n+            const int status = wait_for_children();\n+            exit(status);\n+        }\n+    }\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":191,"deletions":0,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/** \\file *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+#include \"jni_util.h\"\n+#include \"io_util.h\"\n+#include \"io_util_md.h\"\n+\n+#include \"jdk_crac_Core.h\"\n+\n+JNIEXPORT jobjectArray JNICALL\n+Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jarray fdArr, jobjectArray objArr, jboolean dry_run, jlong jcmd_stream) {\n+    return JVM_Checkpoint(env, fdArr, objArr, dry_run, jcmd_stream);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n-                                    jstring path, jboolean append) {\n+                                    jstring path, jboolean append, jboolean truncate) {\n@@ -59,1 +59,1 @@\n-             O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC));\n+             O_WRONLY | O_CREAT | (append ? O_APPEND : 0) | (truncate ? O_TRUNC : 0));\n","filename":"src\/java.base\/share\/native\/libjava\/FileOutputStream.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+\n+#ifdef LINUX\n+#include <unistd.h>\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#else\n+typedef int pid_t;\n+#endif \/\/LINUX\n+\n+static int kickjvm(pid_t jvm, int code) {\n+#ifdef LINUX\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+#endif \/\/LINUX\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+    char* imagedir = argv[2];\n+\n+    char pidpath[1024];\n+    if (0 > snprintf(pidpath, sizeof(pidpath), \"%s\/pid\", imagedir)) {\n+        return 1;\n+    }\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+#ifdef LINUX\n+        pid_t jvm = getppid();\n+#else\n+        pid_t jvm = -1;\n+#endif \/\/LINUX\n+\n+        FILE *pidfile = fopen(pidpath, \"w\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            kickjvm(jvm, -1);\n+            return 1;\n+        }\n+\n+        fprintf(pidfile, \"%d\\n\", jvm);\n+        fclose(pidfile);\n+\n+    } else if (!strcmp(action, \"restore\")) {\n+        FILE *pidfile = fopen(pidpath, \"r\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            return 1;\n+        }\n+\n+        pid_t jvm;\n+        if (1 != fscanf(pidfile, \"%d\", &jvm)) {\n+            fclose(pidfile);\n+            fprintf(stderr, \"cannot read pid\\n\");\n+            return 1;\n+        }\n+        fclose(pidfile);\n+\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        if (kickjvm(jvm, strid ? atoi(strid) : 0)) {\n+            return 1;\n+        }\n+\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/share\/native\/pauseengine\/pauseengine.c","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+\n+#ifdef LINUX\n+#include <unistd.h>\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#else\n+typedef int pid_t;\n+#endif \/\/LINUX\n+\n+static int kickjvm(pid_t jvm, int code) {\n+#ifdef LINUX\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+#endif \/\/LINUX\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+        const char* argsidstr = getenv(\"SIM_CRAC_NEW_ARGS_ID\");\n+        int argsid = argsidstr ? atoi(argsidstr) : 0;\n+#ifdef LINUX\n+        pid_t jvm = getppid();\n+#else\n+        pid_t jvm = -1;\n+#endif \/\/LINUX\n+        kickjvm(jvm, argsid);\n+    } else if (!strcmp(action, \"restore\")) {\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        printf(\"SIM_CRAC_NEW_ARGS_ID=%s\\n\", strid ? strid : \"0\");\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/share\/native\/simengine\/simengine.c","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n@@ -57,0 +58,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+\n@@ -64,2 +69,20 @@\n-    private static final HashMap<Variable,Value> theEnvironment;\n-    private static final Map<String,String> theUnmodifiableEnvironment;\n+    private static class CracSubscriber\n+            implements jdk.internal.crac.JDKResource {\n+\n+        CracSubscriber() {\n+            Core.Priority.NORMAL.getContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            ProcessEnvironment.updateEnvironment();\n+        }\n+    }\n+\n+    private static HashMap<Variable,Value> theEnvironment;\n+    private static Map<String,String> theUnmodifiableEnvironment;\n+    private static final CracSubscriber theCracSubscriber;\n@@ -82,0 +105,2 @@\n+\n+        theCracSubscriber = new CracSubscriber();\n@@ -106,0 +131,14 @@\n+    static private void updateEnvironment() {\n+        byte[][] environ = environ();\n+        \/\/ Read environment variables back to front,\n+        \/\/ so that earlier variables override later ones.\n+        for (int i = environ.length-1; i > 0; i-=2) {\n+            theEnvironment.put(Variable.valueOf(environ[i-1]),\n+                               Value.valueOf(environ[i]));\n+        }\n+\n+        theUnmodifiableEnvironment\n+            = Collections.unmodifiableMap\n+            (new StringEnvironment(theEnvironment));\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessEnvironment.java","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import jdk.internal.crac.JDKFdResource;\n@@ -628,0 +629,2 @@\n+        private final JDKFdResource resource;\n+\n@@ -629,1 +632,6 @@\n-            super(new PipeOutputStream(newFileDescriptor(fd)));\n+            this(newFileDescriptor(fd));\n+        }\n+\n+        private ProcessPipeOutputStream(FileDescriptor fd) {\n+            super(new PipeOutputStream(fd));\n+            resource = new PipeResource(this, fd);\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.WeakHashMap;\n@@ -35,0 +36,2 @@\n+\n+import jdk.internal.crac.Core;\n@@ -36,0 +39,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n@@ -40,0 +45,3 @@\n+ * @crac All JarFile instances that are not referenced from elsewhere are\n+ * removed from the cache before a checkpoint.\n+ *\n@@ -43,1 +51,1 @@\n-class JarFileFactory implements URLJarFile.URLJarFileCloseController {\n+class JarFileFactory implements URLJarFile.URLJarFileCloseController, jdk.internal.crac.JDKResource {\n@@ -53,1 +61,3 @@\n-    private JarFileFactory() { }\n+    private JarFileFactory() {\n+        Core.Priority.NORMAL.getContext().register(this);\n+    }\n@@ -239,0 +249,26 @@\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        \/\/ Need to clear cached entries that are held by the factory only (e.g.\n+        \/\/ after JarURLInputStream.close with useCaches == true).  Creating a\n+        \/\/ temporary weak cache and triggering GC to get know JARs really in\n+        \/\/ use.\n+        synchronized (instance) {\n+            WeakHashMap<JarFile, URL> weakMap = new WeakHashMap<>(urlCache);\n+            fileCache.clear();\n+            urlCache.clear();\n+\n+            System.gc();\n+\n+            weakMap.forEach((JarFile jarFile, URL url) -> {\n+                String key = urlKey(url);\n+                urlCache.put(jarFile, url);\n+                fileCache.put(key, jarFile);\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        close0(fd);\n+        closeAndMark(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/DatagramDispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,8 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.LoggerContainer;\n+\n@@ -31,1 +39,2 @@\n-\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n@@ -38,2 +47,35 @@\n-    private final SourceChannel source;\n-    private final SinkChannel sink;\n+    private final SourceChannelImpl source;\n+    private final SinkChannelImpl sink;\n+    private final JDKFdResource resource = new JDKFdResource() {\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            OpenResourcePolicies.Policy policy = OpenResourcePolicies.find(false, OpenResourcePolicies.PIPE, null);\n+            String action = policy != null ? policy.action.toLowerCase() : \"error\";\n+            switch (action) {\n+                case \"error\":\n+                    \/\/ We will report the error only once\n+                    AtomicBoolean reported = new AtomicBoolean();\n+                    Supplier<Exception> supplier = () -> reported.getAndSet(true) ? null :\n+                            new CheckpointOpenResourceException(toString(), getStackTraceHolder());\n+                    Core.getClaimedFDs().claimFd(source.getFD(), this, supplier, source.getFD());\n+                    Core.getClaimedFDs().claimFd(sink.getFD(), this, supplier, sink.getFD());\n+                    break;\n+                case \"close\":\n+                    source.close();\n+                    sink.close();\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    warnOpenResource(policy, PipeImpl.this.toString());\n+                    Core.getClaimedFDs().claimFd(source.getFD(), this, NO_EXCEPTION, source.getFD());\n+                    Core.getClaimedFDs().claimFd(sink.getFD(), this, NO_EXCEPTION, sink.getFD());\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + PipeImpl.this, null);\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public String toString() {\n+        return \"Pipe \" + source.getFDVal() + \" -> \" + sink.getFDVal();\n+    }\n@@ -60,1 +102,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/PipeImpl.java","additions":45,"deletions":4,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -204,0 +204,3 @@\n+        \/\/ wait for any write operation to complete before trying to close\n+        writeLock.lock();\n+        writeLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        close0(fd);\n+        closeAndMark(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SocketDispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,0 +203,3 @@\n+        \/\/ wait for any read operation to complete before trying to close\n+        readLock.lock();\n+        readLock.unlock();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,7 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -33,0 +40,20 @@\n+    static class ResourceProxy implements JDKResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            UnixDispatcher.beforeCheckpoint();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context)\n+                throws IOException {\n+            UnixDispatcher.afterRestore();\n+        }\n+    }\n+\n+    static Object closeLock = new Object();\n+    static boolean forceNonDeferedClose;\n+    static int closeCnt;\n+\n+    static ResourceProxy resourceProxy = new ResourceProxy();\n+\n+\n@@ -38,1 +65,24 @@\n-        preClose0(fd);\n+        boolean doPreclose = true;\n+        synchronized (closeLock) {\n+            if (forceNonDeferedClose) {\n+                doPreclose = false;\n+            }\n+            if (doPreclose) {\n+                ++closeCnt;\n+            }\n+        }\n+\n+        if (!doPreclose) {\n+            return;\n+        }\n+\n+        try {\n+            preClose0(fd);\n+        } finally {\n+            synchronized (closeLock) {\n+                closeCnt--;\n+                if (forceNonDeferedClose && closeCnt == 0) {\n+                    closeLock.notifyAll();\n+                }\n+            }\n+        }\n@@ -41,1 +91,28 @@\n-    static native void close0(FileDescriptor fd) throws IOException;\n+    static void beforeCheckpoint() throws InterruptedException {\n+        synchronized (closeLock) {\n+            forceNonDeferedClose = true;\n+            while (closeCnt != 0) {\n+                closeLock.wait();\n+            }\n+            beforeCheckpoint0();\n+        }\n+    }\n+\n+    static void afterRestore() throws IOException {\n+        synchronized (closeLock) {\n+            afterRestore0();\n+            forceNonDeferedClose = false;\n+        }\n+    }\n+\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+        SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    static void closeAndMark(FileDescriptor fd) throws IOException {\n+        \/\/ Originally this used fdAccess.markClosed() and close0() but leaving\n+        \/\/ the FD value set breaks JDKSocketResource (we don't want the extra\n+        \/\/ test if the FD resource has been marked).\n+        fdAccess.close(fd);\n+    }\n+\n+    private static native void close0(FileDescriptor fd) throws IOException;\n@@ -47,0 +124,4 @@\n+    static native void beforeCheckpoint0();\n+\n+    static native void afterRestore0() throws IOException;\n+\n@@ -50,0 +131,4 @@\n+        \/\/ We cannot register using normal priority because other JDK resources\n+        \/\/ might read configuration files with this or later priority.\n+        \/\/ It's difficult to trigger static initialization outside the package.\n+        Core.Priority.PRE_FILE_DESCRIPTORS.getContext().register(resourceProxy);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDispatcher.java","additions":87,"deletions":2,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n@@ -33,0 +35,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixFileDispatcherImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n@@ -33,0 +34,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -73,0 +78,5 @@\n+ * @crac Before checkpoint the underlying random number generator is discarded\n+ * and after restore a new {@link sun.security.provider.SecureRandom} is\n+ * created, therefore this produces different sequences when restored multiple\n+ * times.\n+ *\n@@ -339,1 +349,1 @@\n-    private static class RandomIO {\n+    private static class RandomIO implements JDKResource {\n@@ -393,0 +403,4 @@\n+        \/\/ lock for checkpoint\/restore\n+        \/\/ allows clearing mixRandom and internal buffer before checkpoint\n+        private final ReentrantReadWriteLock crLock = new ReentrantReadWriteLock();\n+\n@@ -399,0 +413,1 @@\n+            Core.Priority.NATIVE_PRNG.getContext().register(this);\n@@ -485,1 +500,9 @@\n-                getMixRandom().engineSetSeed(seed);\n+                crLock.readLock().lock();\n+                try {\n+                    if(crLock.getWriteHoldCount() != 0) {\n+                        throw new IllegalStateException(\"PRNG object is invalidated\");\n+                    }\n+                    getMixRandom().engineSetSeed(seed);\n+                } finally {\n+                    crLock.readLock().unlock();\n+                }\n@@ -543,0 +566,1 @@\n+            crLock.readLock().lock();\n@@ -544,0 +568,3 @@\n+                    if(crLock.getWriteHoldCount() != 0) {\n+                        throw new IllegalStateException(\"PRNG object is invalidated\");\n+                    }\n@@ -576,0 +603,2 @@\n+                } finally {\n+                    crLock.readLock().unlock();\n@@ -578,0 +607,15 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            synchronized (LOCK_SET_SEED) {\n+                if (seedOut != null) {\n+                    FileDescriptor fd = ((FileOutputStream)seedOut).getFD();\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+                }\n+            }\n+\n+            crLock.writeLock().lock();\n+            mixRandom = null;\n+            buffered = 0;\n+            lastRead = 0;\n+            Arrays.fill(nextBuffer, (byte)0);\n@@ -579,0 +623,6 @@\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            crLock.writeLock().unlock();\n+        }\n+    }\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":52,"deletions":2,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,429 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdbool.h>\n+#include <libgen.h>\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <getopt.h>\n+#include <signal.h>\n+#include <sys\/wait.h>\n+#include <sys\/stat.h>\n+\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+#define PERFDATA_NAME \"perfdata\"\n+\n+#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(x[0]))\n+\n+#define SUPPRESS_ERROR_IN_PARENT 77\n+\n+static int g_pid;\n+\n+static char *verbosity = NULL; \/\/ default differs for checkpoint and restore\n+static char *log_file = NULL;\n+\n+static int kickjvm(pid_t jvm, int code) {\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+static void print_args_to_stderr(const char **args) {\n+    for (const char **argp = args; *argp != NULL; ++argp) {\n+        const char *s = *argp;\n+        if (argp != args) {\n+            fputc(' ', stderr);\n+        }\n+        \/\/ https:\/\/unix.stackexchange.com\/a\/357932\/296319\n+        if (!strpbrk(s, \" \\t\\n!\\\"#$&'()*,;<=>?[\\\\]^`{|}~\")) {\n+            fputs(s, stderr);\n+            continue;\n+        }\n+        fputc('\\'', stderr);\n+        for (; *s; ++s) {\n+            if (*s != '\\'') {\n+                fputc(*s, stderr);\n+            } else {\n+                fputs(\"'\\\\''\", stderr);\n+            }\n+        }\n+        fputc('\\'', stderr);\n+    }\n+}\n+\n+static void print_command_args_to_stderr(const char **args) {\n+  fprintf(stderr, \"Command: \");\n+  print_args_to_stderr(args);\n+  fputc('\\n', stderr);\n+}\n+\n+static const char *join_path(const char *path1, const char *path2) {\n+    char *retval;\n+    if (asprintf(&retval, \"%s\/%s\", path1, path2) == -1) {\n+        perror(\"asprintf\");\n+        exit(1);\n+    }\n+    return retval;\n+}\n+\n+static const char *path_abs(const char *rel) {\n+    if (rel[0] == '\/') {\n+        return rel;\n+    }\n+    char *cwd = get_current_dir_name();\n+    if (!cwd) {\n+        perror(\"get_current_dir_name\");\n+        exit(1);\n+    }\n+    return join_path(cwd, rel);\n+}\n+\n+static const char *path_abs2(const char *rel1, const char *rel2) {\n+    if (rel2[0] == '\/') {\n+        return rel2;\n+    }\n+    return join_path(path_abs(rel1), rel2);\n+}\n+\n+static int checkpoint(pid_t jvm,\n+        const char *basedir,\n+        const char *self,\n+        const char *criu,\n+        const char *imagedir) {\n+\n+    if (fork()) {\n+        \/\/ main process\n+        wait(NULL);\n+        return 0;\n+    }\n+\n+    pid_t parent_before = getpid();\n+\n+    \/\/ child\n+    if (fork()) {\n+        exit(0);\n+    }\n+\n+    \/\/ grand-child\n+    pid_t parent = getppid();\n+    int tries = 300;\n+    while (parent != 1 && 0 < tries--) {\n+        usleep(10);\n+        parent = getppid();\n+    }\n+\n+    if (parent == parent_before) {\n+        fprintf(stderr, \"can't move out of JVM process hierarchy\");\n+        kickjvm(jvm, -1);\n+        exit(0);\n+    }\n+\n+    char* leave_running = getenv(\"CRAC_CRIU_LEAVE_RUNNING\");\n+\n+    char jvmpidchar[32];\n+    snprintf(jvmpidchar, sizeof(jvmpidchar), \"%d\", jvm);\n+\n+    const char* args[32] = {\n+        criu,\n+        \"dump\",\n+        \"-t\", jvmpidchar,\n+        \"-D\", imagedir,\n+        \"--shell-job\",\n+    };\n+    const char** arg = args + 7;\n+\n+    *arg++ = verbosity != NULL ? verbosity : \"-v4\";\n+    *arg++ = \"-o\";\n+    \/\/ -D without -W makes criu cd to image dir for logs\n+    const char *log_local = log_file != NULL ? log_file : \"dump4.log\";\n+    *arg++ = log_local;\n+\n+    if (leave_running) {\n+        *arg++ = \"-R\";\n+    }\n+\n+    char *criuopts = getenv(\"CRAC_CRIU_OPTS\");\n+    if (criuopts) {\n+        char* criuopt = strtok(criuopts, \" \");\n+        while (criuopt && ARRAY_SIZE(args) >= (size_t)(arg - args) + 1\/* account for trailing NULL *\/) {\n+            *arg++ = criuopt;\n+            criuopt = strtok(NULL, \" \");\n+        }\n+        if (criuopt) {\n+            fprintf(stderr, \"Warning: too many arguments in CRAC_CRIU_OPTS (dropped from '%s')\\n\", criuopt);\n+        }\n+    }\n+    *arg++ = NULL;\n+\n+    pid_t child = fork();\n+    if (!child) {\n+        execv(criu, (char**)args);\n+        fprintf(stderr, \"Cannot execute CRIU \\\"\");\n+        print_args_to_stderr(args);\n+        fprintf(stderr, \"\\\": %s\\n\", strerror(errno));\n+        exit(SUPPRESS_ERROR_IN_PARENT);\n+    }\n+\n+    int status;\n+    if (child != wait(&status)) {\n+        fprintf(stderr, \"Error waiting for CRIU: %s\\n\", strerror(errno));\n+        print_command_args_to_stderr(args);\n+        kickjvm(jvm, -1);\n+    } else if (!WIFEXITED(status)) {\n+        fprintf(stderr, \"CRIU has not properly exited, waitpid status was %d - check %s\\n\", status, path_abs2(imagedir, log_local));\n+        print_command_args_to_stderr(args);\n+        kickjvm(jvm, -1);\n+    } else if (WEXITSTATUS(status)) {\n+        if (WEXITSTATUS(status) != SUPPRESS_ERROR_IN_PARENT) {\n+            fprintf(stderr, \"CRIU failed with exit code %d - check %s\\n\", WEXITSTATUS(status), path_abs2(imagedir, log_local));\n+            print_command_args_to_stderr(args);\n+        }\n+        kickjvm(jvm, -1);\n+    } else if (leave_running) {\n+        kickjvm(jvm, 0);\n+    }\n+\n+    exit(0);\n+}\n+\n+static int restore(const char *basedir,\n+        const char *self,\n+        const char *criu,\n+        const char *imagedir) {\n+    const char* args[32] = {\n+        criu,\n+        \"restore\",\n+        \"-W\", \".\",\n+        \"--shell-job\",\n+        \"--action-script\", self,\n+        \"-D\", imagedir,\n+    };\n+    const char** arg = args + 9;\n+\n+    *arg++ = verbosity != NULL ? verbosity : \"-v1\";\n+    if (log_file != NULL) {\n+        *arg++ = \"-o\";\n+        *arg++ = log_file;\n+    }\n+\n+    const char* tail[] = {\n+        \"--exec-cmd\", \"--\", self, \"restorewait\",\n+        NULL\n+    };\n+    char *criuopts = getenv(\"CRAC_CRIU_OPTS\");\n+    if (criuopts) {\n+        char* criuopt = strtok(criuopts, \" \");\n+        while (criuopt && ARRAY_SIZE(args) >= (size_t)(arg - args + ARRAY_SIZE(tail))) {\n+            *arg++ = criuopt;\n+            criuopt = strtok(NULL, \" \");\n+        }\n+        if (criuopt) {\n+            fprintf(stderr, \"Warning: too many arguments in CRAC_CRIU_OPTS (dropped from '%s')\\n\", criuopt);\n+        }\n+    }\n+\n+    memcpy(arg, tail, sizeof(tail));\n+\n+    fflush(stderr);\n+\n+    execv(criu, (char**)args);\n+    fprintf(stderr, \"Cannot execute CRIU \\\"\");\n+    print_args_to_stderr(args);\n+    fprintf(stderr, \"\\\": %s\\n\", strerror(errno));\n+    return 1;\n+}\n+\n+#define MSGPREFIX \"\"\n+\n+static int post_resume(void) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"cannot find CRTOOLS_INIT_PID env\\n\");\n+        return 1;\n+    }\n+    int pid = atoi(pidstr);\n+\n+    char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+    return kickjvm(pid, strid ? atoi(strid) : 0);\n+}\n+\n+static void sighandler(int sig, siginfo_t *info, void *uc) {\n+    if (0 <= g_pid) {\n+        kill(g_pid, sig);\n+    }\n+}\n+\n+static int restorewait(void) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"no CRTOOLS_INIT_PID: signals may not be delivered\\n\");\n+    }\n+    g_pid = pidstr ? atoi(pidstr) : -1;\n+\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    int sig;\n+    for (sig = 1; sig <= 31; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(MSGPREFIX \"sigprocmask\");\n+    }\n+\n+    int status;\n+    int ret;\n+    do {\n+        ret = waitpid(g_pid, &status, 0);\n+    } while (ret == -1 && errno == EINTR);\n+\n+    if (ret == -1) {\n+        perror(MSGPREFIX \"waitpid\");\n+        return 1;\n+    }\n+\n+    if (WIFEXITED(status)) {\n+        return WEXITSTATUS(status);\n+    }\n+\n+    if (WIFSIGNALED(status)) {\n+        \/\/ Try to terminate the current process with the same signal\n+        \/\/ as the child process was terminated\n+        const int sig = WTERMSIG(status);\n+        signal(sig, SIG_DFL);\n+        raise(sig);\n+        \/\/ Signal was ignored, return 128+n as bash does\n+        \/\/ see https:\/\/linux.die.net\/man\/1\/bash\n+        return 128+sig;\n+    }\n+\n+    return 1;\n+}\n+\n+\/\/ return value is one argument after options\n+static char *parse_options(int argc, char *argv[]) {\n+    optind = 2; \/\/ starting after action\n+    struct option opts[] = {{\n+        .name = \"verbosity\",\n+        .has_arg = 1,\n+        .flag = NULL,\n+        .val = 'v'\n+    }, {\n+        .name = \"log-file\",\n+        .has_arg = 1,\n+        .flag = NULL,\n+        .val = 'o',\n+    }, { NULL, 0, NULL, 0} };\n+    bool processing = true;\n+    do {\n+        switch (getopt_long(argc, argv, \"v:o:\", opts, NULL)) {\n+            case -1:\n+            case '?':\n+                processing = false;\n+                break;\n+            case 'v':\n+                if (asprintf(&verbosity, \"--verbosity=%s\", optarg) < 0) {\n+                    fprintf(stderr, \"Cannot set verbosity level\\n\");\n+                    verbosity = NULL;\n+                }\n+                break;\n+            case 'o':\n+                log_file = optarg;\n+                break;\n+        }\n+    } while (processing);\n+    return optind < argc ? argv[optind] : NULL;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action;\n+    if (argc >= 2 && (action = argv[1])) {\n+\n+        char* imagedir = parse_options(argc, argv);\n+\n+        char *basedir = dirname(strdup(argv[0]));\n+\n+        char *criu = getenv(\"CRAC_CRIU_PATH\");\n+        if (!criu) {\n+            if (-1 == asprintf(&criu, \"%s\/criu\", basedir)) {\n+                return 1;\n+            }\n+            struct stat st;\n+            if (stat(criu, &st)) {\n+                \/* some problem with the bundled criu *\/\n+                criu = \"\/usr\/sbin\/criu\";\n+                if (stat(criu, &st)) {\n+                    fprintf(stderr, \"cannot find CRIU to use\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+\n+\n+        if (!strcmp(action, \"checkpoint\")) {\n+            pid_t jvm = getppid();\n+            return checkpoint(jvm, basedir, argv[0], criu, imagedir);\n+        } else if (!strcmp(action, \"restore\")) {\n+            return restore(basedir, argv[0], criu, imagedir);\n+        } else if (!strcmp(action, \"restorewait\")) { \/\/ called by CRIU --exec-cmd\n+            return restorewait();\n+        } else {\n+            fprintf(stderr, \"unknown command-line action: %s\\n\", action);\n+            return 1;\n+        }\n+    } else if ((action = getenv(\"CRTOOLS_SCRIPT_ACTION\"))) { \/\/ called by CRIU --action-script\n+        if (!strcmp(action, \"post-resume\")) {\n+            return post_resume();\n+        } else {\n+            \/\/ ignore other notifications\n+            return 0;\n+        }\n+    } else {\n+        fprintf(stderr, \"unknown context\\n\");\n+    }\n+\n+    return 1;\n+}\n","filename":"src\/java.base\/unix\/native\/criuengine\/criuengine.c","additions":429,"deletions":0,"binary":false,"changes":429,"status":"added"},{"patch":"@@ -25,2 +25,0 @@\n-\n-#include <unistd.h>\n@@ -28,0 +26,3 @@\n+#include <inttypes.h>\n+#include <stdbool.h>\n+#include <unistd.h>\n@@ -36,0 +37,9 @@\n+#include <sys\/socket.h>\n+#include <netinet\/in.h>\n+\n+typedef union {\n+    struct sockaddr     sa;\n+    struct sockaddr_in  sa4;\n+    struct sockaddr_in6 sa6;\n+} socketaddress;\n+\n@@ -92,0 +102,116 @@\n+\n+static const char* stat2strtype(mode_t mode) {\n+    switch (mode & S_IFMT) {\n+        case S_IFSOCK: return \"socket\";\n+        case S_IFLNK:  return \"symlink\";\n+        case S_IFREG:  return \"regular\";\n+        case S_IFBLK:  return \"block\";\n+        case S_IFDIR:  return \"directory\";\n+        case S_IFCHR:  return \"character\";\n+        case S_IFIFO:  return \"fifo\";\n+        default:       break;\n+    }\n+    return \"unknown\";\n+}\n+\n+static const char* family2str(int family) {\n+    switch (family) {\n+        case AF_UNIX: return \"AF_UNIX\";\n+        case AF_INET: return \"AF_INET\";\n+        case AF_INET6: return \"AF_INET6\";\n+        default: break;\n+    }\n+    return \"UNKNOWN\";\n+}\n+\n+static const char* socktype2str(int socktype) {\n+    switch (socktype) {\n+        case SOCK_STREAM: return \"SOCK_STREAM\";\n+        case SOCK_DGRAM: return \"SOCK_DGRAM\";\n+        case SOCK_RAW: return \"SOCK_RAW\";\n+        default: break;\n+    }\n+    return \"SOCK_RAW\";\n+}\n+\n+static char* fmtaddr(char *buf, const char *end, unsigned char* addr, int len) {\n+    while (buf + 2 < end && 0 < len) {\n+        sprintf(buf, \"%02x\", *addr);\n+        buf += 2;\n+        len -= 1;\n+        addr += 1;\n+    }\n+    return buf;\n+}\n+\n+__attribute__((__format__ (__printf__, 3, 0)))\n+static jstring format_string(JNIEnv *env, struct stat *st, const char *fmt, ...) {\n+    char details[PATH_MAX];\n+    va_list va;\n+\n+    va_start(va, fmt);\n+    int len = vsnprintf(details, sizeof(details), fmt, va);\n+    va_end(va);\n+\n+    \/\/ ensure terminated string\n+    details[sizeof(details) - 1] = '\\0';\n+    return (*env)->NewStringUTF(env, details);\n+}\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_nativeDescription0(JNIEnv *env, jobject this) {\n+    FD fd = (*env)->GetIntField(env, this, IO_fd_fdID);\n+\n+    char fdpath[64];\n+    snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+    char link[PATH_MAX];\n+    int linklen = readlink(fdpath, link, PATH_MAX);\n+    if (linklen >= 0) {\n+        link[(unsigned)linklen < PATH_MAX ? linklen : PATH_MAX - 1] = '\\0';\n+    }\n+\n+    struct stat st;\n+    if (fstat(fd, &st) != 0) {\n+        \/\/ return just link value\n+        return (*env)->NewStringUTF(env, link);\n+    }\n+\n+    if ((st.st_mode & S_IFMT) != S_IFSOCK) {\n+        return format_string(env, &st, \"%s: %s\", stat2strtype(st.st_mode), link);\n+    }\n+\n+    struct sockaddr sa;\n+    socklen_t slen = sizeof(sa);\n+    if (getsockname(fd, &sa, &slen) != 0) {\n+        return format_string(env, &st, \"socket: %s\", link);\n+    }\n+\n+    const int family = sa.sa_family;\n+    int socktype;\n+    socklen_t typelen = sizeof(int);\n+    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &socktype, &typelen) != 0) {\n+        return format_string(env, &st, \"socket: family=%s\", family2str(family));\n+    }\n+\n+    socketaddress local;\n+    socklen_t llen = sizeof(socketaddress);\n+    if (getsockname(fd, &local.sa, &llen) != 0) {\n+        llen = 0;\n+    }\n+\n+    socketaddress remote;\n+    socklen_t rlen = sizeof(socketaddress);\n+    if (getpeername(fd, &remote.sa, &rlen) != 0) {\n+        rlen = 0;\n+    }\n+\n+    char details[PATH_MAX];\n+    int len = snprintf(details, sizeof(details),\n+            \"socket: family=%s type=%s localaddr=\", family2str(family), socktype2str(socktype));\n+    char *end = fmtaddr(details + len, details + sizeof(details), (unsigned char*)&local, llen);\n+    end += snprintf(end, details + sizeof(details) - end, \" remoteaddr=\");\n+    end = fmtaddr(end, details + sizeof(details), (unsigned char*)&remote, rlen);\n+    \/\/ ensure terminated string\n+    details[sizeof(details) - 1] = '\\0';\n+    return (*env)->NewStringUTF(env, details);\n+}\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":128,"deletions":2,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -682,0 +682,9 @@\n+    {\n+      const int restore_signal = SIGRTMIN + 2;\n+      \/\/ block restore_signal in launcher thread to allow JVM handle it\n+      sigset_t block_sig;\n+      sigemptyset(&block_sig);\n+      sigaddset(&block_sig, restore_signal);\n+      pthread_sigmask(SIG_BLOCK, &block_sig, NULL);\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,0 +70,22 @@\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDispatcher_beforeCheckpoint0(JNIEnv *env, jclass cl)\n+{\n+    \/* synchronized by closeLock *\/\n+    close(preCloseFD);\n+    preCloseFD = -1;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixDispatcher_afterRestore0(JNIEnv *env, jclass cl)\n+{\n+    \/* synchronized by closeLock *\/\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n+        return;\n+    }\n+    preCloseFD = sp[0];\n+    close(sp[1]);\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDispatcher.c","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -193,1 +193,0 @@\n-\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.WeakHashMap;\n@@ -37,0 +38,4 @@\n+import jdk.internal.crac.Core;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+\n@@ -43,1 +48,1 @@\n-class JarFileFactory implements URLJarFile.URLJarFileCloseController {\n+class JarFileFactory implements URLJarFile.URLJarFileCloseController, jdk.internal.crac.JDKResource {\n@@ -53,1 +58,3 @@\n-    private JarFileFactory() { }\n+    private JarFileFactory() {\n+        Core.Priority.NORMAL.getContext().register(this);\n+    }\n@@ -263,0 +270,25 @@\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        \/\/ Need to clear cached entries that are held by the factory only (e.g.\n+        \/\/ after JarURLInputStream.close with useCaches == true).  Creating a\n+        \/\/ temporary weak cache and triggering GC to get know JARs really in\n+        \/\/ use.\n+        synchronized (instance) {\n+            WeakHashMap<JarFile, URL> weakMap = new WeakHashMap<>(urlCache);\n+            fileCache.clear();\n+            urlCache.clear();\n+\n+            System.gc();\n+\n+            weakMap.forEach((JarFile jarFile, URL url) -> {\n+                String key = urlKey(url);\n+                urlCache.put(jarFile, url);\n+                fileCache.put(key, jarFile);\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+    }\n","filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+#include <windows.h>\n+#include <winternl.h>\n+\n@@ -95,0 +98,15 @@\n+\n+#define BufferSize 1024\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_nativeDescription0(JNIEnv* env, jobject this) {\n+    HANDLE handle = (HANDLE)(*env)->GetLongField(env, this, IO_handle_fdID);\n+    char lpszFilePath[BufferSize] = {'\\0'};\n+\n+    const DWORD dwFileType = GetFileType(handle);\n+    if (FILE_TYPE_DISK != dwFileType || !GetFinalPathNameByHandleA(handle, lpszFilePath, BufferSize, FILE_NAME_OPENED)) {\n+        snprintf(lpszFilePath, sizeof(lpszFilePath) - 1, \"Handle 0x%p, type %lu\", handle, dwFileType);\n+    }\n+\n+    return (*env)->NewStringUTF(env, lpszFilePath);\n+}\n","filename":"src\/java.base\/windows\/native\/libjava\/FileDescriptor_md.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+ *\n+ * @since 23\n","filename":"src\/java.desktop\/share\/classes\/javax\/print\/attribute\/standard\/OutputBin.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,0 +153,2 @@\n+     * @deprecated This constructor was exposed erroneously and will be removed in a future release.\n+     *             Use {@link #BasicSliderUI(JSlider)} instead.\n@@ -154,0 +156,1 @@\n+    @Deprecated(since = \"23\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSliderUI.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -847,0 +847,4 @@\n+        if (value.startsWith(\"none\")) {\n+            return null;\n+        }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSS.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2153,7 +2153,10 @@\n-        if (dy == 0 && dx > 0 && dx < w) {\n-            while (w > 0) {\n-                int partW = Math.min(w, dx);\n-                w -= partW;\n-                int sx = x + w;\n-                ob.Blit(theData, theData, comp, clip,\n-                        sx, y, sx+dx, y+dy, partW, h);\n+        try {\n+            if (dy == 0 && dx > 0 && dx < w) {\n+                while (w > 0) {\n+                    int partW = Math.min(w, dx);\n+                    w -= partW;\n+                    int sx = Math.addExact(x, w);\n+                    ob.Blit(theData, theData, comp, clip,\n+                            sx, y, sx+dx, y+dy, partW, h);\n+                }\n+                return;\n@@ -2161,9 +2164,9 @@\n-            return;\n-        }\n-        if (dy > 0 && dy < h && dx > -w && dx < w) {\n-            while (h > 0) {\n-                int partH = Math.min(h, dy);\n-                h -= partH;\n-                int sy = y + h;\n-                ob.Blit(theData, theData, comp, clip,\n-                        x, sy, x+dx, sy+dy, w, partH);\n+            if (dy > 0 && dy < h && dx > -w && dx < w) {\n+                while (h > 0) {\n+                    int partH = Math.min(h, dy);\n+                    h -= partH;\n+                    int sy = Math.addExact(y, h);\n+                    ob.Blit(theData, theData, comp, clip,\n+                            x, sy, Math.addExact(x, dx), sy+dy, w, partH);\n+                }\n+                return;\n@@ -2171,0 +2174,4 @@\n+            ob.Blit(theData, theData, comp, clip, x, y,\n+                Math.addExact(x, dx), Math.addExact(y, dy), w, h);\n+        } catch (ArithmeticException ex) {\n+            \/\/ We are hitting integer overflow in Math.addExact()\n@@ -2173,1 +2180,0 @@\n-            ob.Blit(theData, theData, comp, clip, x, y, x+dx, y+dy, w, h);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SunGraphics2D.java","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,0 +372,7 @@\n+            double[] mat = new double[6];\n+            itx.getMatrix(mat);\n+            for (double d : mat) {\n+                if (!Double.isFinite(d)) {\n+                    return;\n+                }\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/DrawImage.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-border.output=\n+border.output=\n@@ -66,1 +66,1 @@\n-label.outputbins=(&P):\n+label.outputbins=(&P):\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/resources\/serviceui_zh_CN.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include <limits.h>\n@@ -56,0 +57,8 @@\n+#define UNSAFE_TO_ADD(a, b) \\\n+    (((a >= 0) && (b >= 0) && (a > (INT_MAX - b))) || \\\n+     ((a < 0) && (b < 0) && (a < (INT_MIN - b)))) \\\n+\n+#define UNSAFE_TO_SUB(a, b) \\\n+    (((b >= 0) && (a < 0) && (a < (INT_MIN + b))) || \\\n+     ((b < 0) && (a >= 0) && (-b > (INT_MAX - a)))) \\\n+\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/SurfaceData.h","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,4 @@\n+    if (width <= 0 || height <= 0) {\n+        return;\n+    }\n+\n@@ -73,0 +77,6 @@\n+    if (UNSAFE_TO_ADD(srcx, width) ||\n+        UNSAFE_TO_ADD(srcy, height) ||\n+        UNSAFE_TO_ADD(dstx, width) ||\n+        UNSAFE_TO_ADD(dsty, height)) {\n+        return;\n+    }\n@@ -79,0 +89,4 @@\n+    if (UNSAFE_TO_SUB(srcx, dstx) ||\n+        UNSAFE_TO_SUB(srcy, dsty)) {\n+        return;\n+    }\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/MaskBlit.c","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -470,1 +470,1 @@\n-        if (xmid <= (CX2)) { \\\n+        if (xmid < (CX2)) { \\\n@@ -559,1 +559,1 @@\n-    jfloat localaccum[MASK_BUF_LEN + 1];\n+    jfloat localaccum[MASK_BUF_LEN + 2];\n@@ -571,1 +571,1 @@\n-              ? malloc((width + 1) * sizeof(jfloat))\n+              ? malloc((width + 2) * sizeof(jfloat))\n@@ -576,1 +576,1 @@\n-    memset(pAccum, 0, (width+1) * sizeof(jfloat));\n+    memset(pAccum, 0, (width + 2) * sizeof(jfloat));\n@@ -797,1 +797,1 @@\n-    jfloat localaccum[MASK_BUF_LEN + 1];\n+    jfloat localaccum[MASK_BUF_LEN + 2];\n@@ -818,1 +818,1 @@\n-              ? malloc((width + 1) * sizeof(jfloat))\n+              ? malloc((width + 2) * sizeof(jfloat))\n@@ -823,1 +823,1 @@\n-    memset(pAccum, 0, (width+1) * sizeof(jfloat));\n+    memset(pAccum, 0, (width + 2) * sizeof(jfloat));\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/MaskFill.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-#define TX_FIXED_UNSAFE(v)  (fabs(v) >= (1<<30))\n+#define TX_FIXED_UNSAFE(v)  (isinf(v) || isnan(v) || fabs(v) >= (1<<30))\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/TransformHelper.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -525,0 +525,1 @@\n+    jboolean doIt = JNI_FALSE;\n@@ -580,1 +581,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -608,1 +609,1 @@\n-        return JNI_FALSE;\n+        return doIt;\n@@ -622,1 +623,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -664,1 +665,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -673,1 +674,1 @@\n-            return JNI_FALSE;\n+            return doIt;\n@@ -687,1 +688,1 @@\n-                        return JNI_FALSE;\n+                        return doIt;\n@@ -693,0 +694,1 @@\n+        doIt = JNI_TRUE;\n@@ -711,1 +713,1 @@\n-    return JNI_TRUE;\n+    return doIt;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -111,1 +112,0 @@\n-\n@@ -113,0 +113,1 @@\n+\n@@ -118,1 +119,6 @@\n-            this.acc = JMXSubjectDomainCombiner.getContext(subject);\n+            if (SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+                \/\/ SM is allowed.  Will use ACC created with Subject:\n+                this.acc = JMXSubjectDomainCombiner.getContext(subject);\n+            } else {\n+                this.acc = null;\n+            }\n@@ -1295,4 +1301,15 @@\n-            if (acc == null)\n-                return action.run();\n-            else\n-                return AccessController.doPrivileged(action, acc);\n+            if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+                \/\/ Modern case\n+                if (subject == null) {\n+                    return action.run();\n+                } else {\n+                    return Subject.doAs(subject, action);\n+                }\n+            } else {\n+                \/\/ SM permitted\n+                if (acc == null) {\n+                    return action.run(); \/\/ No Subject or ACC\n+                } else {\n+                    return AccessController.doPrivileged(action, acc);\n+                }\n+            }\n@@ -1414,7 +1431,14 @@\n-            if (acc == null) {\n-                try {\n-                    return op.run();\n-                } catch (Exception e) {\n-                    if (e instanceof RuntimeException)\n-                        throw (RuntimeException) e;\n-                    throw new PrivilegedActionException(e);\n+            if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+                \/\/ Modern case\n+                if (subject == null) {\n+                    try {\n+                        return op.run();\n+                    } catch (Exception e) {\n+                        if (e instanceof RuntimeException) {\n+                            throw (RuntimeException) e;\n+                        } else {\n+                            throw new PrivilegedActionException(e);\n+                        }\n+                    }\n+                } else {\n+                    return Subject.doAs(subject, op);\n@@ -1423,1 +1447,14 @@\n-                return AccessController.doPrivileged(op, acc);\n+                \/\/ SM permitted\n+                if (acc == null) {\n+                    try {\n+                        return op.run();\n+                    } catch (Exception e) {\n+                        if (e instanceof RuntimeException) {\n+                            throw (RuntimeException) e;\n+                        } else {\n+                            throw new PrivilegedActionException(e);\n+                        }\n+                    }\n+                } else {\n+                    return AccessController.doPrivileged(op, acc);\n+                }\n@@ -1588,7 +1625,17 @@\n-            try{\n-                if (acc != null) {\n-                    return AccessController.doPrivileged(\n-                            (PrivilegedExceptionAction<T>) () ->\n-                                    wrappedClass.cast(mo.get()), acc);\n-                }else{\n-                    return wrappedClass.cast(mo.get());\n+            try {\n+                if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+                    \/\/ Modern case\n+                    if (subject != null) {\n+                        return Subject.doAs(subject, (PrivilegedExceptionAction<T>) () -> wrappedClass.cast(mo.get()));\n+                    } else {\n+                        return wrappedClass.cast(mo.get());\n+                    }\n+                } else {\n+                    \/\/ SM permitted\n+                    if (acc != null) {\n+                        return AccessController.doPrivileged(\n+                                (PrivilegedExceptionAction<T>) () ->\n+                                        wrappedClass.cast(mo.get()), acc);\n+                    } else {\n+                        return wrappedClass.cast(mo.get());\n+                    }\n@@ -1596,1 +1643,1 @@\n-            }finally{\n+            } finally {\n","filename":"src\/java.management.rmi\/share\/classes\/javax\/management\/remote\/rmi\/RMIConnectionImpl.java","additions":69,"deletions":22,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -346,1 +346,0 @@\n-\n@@ -349,1 +348,1 @@\n-        return Subject.getSubject(AccessController.getContext());\n+        return Subject.current();\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/internal\/ServerNotifForwarder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -303,0 +304,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -304,8 +306,9 @@\n-        @SuppressWarnings(\"removal\")\n-        final AccessControlContext acc = AccessController.getContext();\n-        @SuppressWarnings(\"removal\")\n-        final Subject s =\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                    public Subject run() {\n-                        return Subject.getSubject(acc);\n-                    }\n+        Subject s = null;\n+        if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+            s = Subject.current();\n+        } else {\n+            final AccessControlContext acc = AccessController.getContext();\n+            s = AccessController.doPrivileged(new PrivilegedAction<>() {\n+                        public Subject run() {\n+                            return Subject.getSubject(acc);\n+                        }\n@@ -313,0 +316,1 @@\n+        }\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/remote\/security\/MBeanServerFileAccessController.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,2 @@\n+import javax.security.auth.Subject;\n+import jdk.internal.access.SharedSecrets;\n@@ -172,1 +174,1 @@\n-     * AccessControlContext of the Monitor.start() caller.\n+     * Subject and possibly AccessControlContext of the Monitor.start() caller.\n@@ -174,0 +176,1 @@\n+    private volatile Subject subject;\n@@ -716,1 +719,1 @@\n-            \/\/ Cache the AccessControlContext of the Monitor.start() caller.\n+            \/\/ Cache the Subject or AccessControlContext of the Monitor.start() caller.\n@@ -719,1 +722,5 @@\n-            acc = AccessController.getContext();\n+            if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+                subject = Subject.current();\n+            } else {\n+                acc = AccessController.getContext();\n+            }\n@@ -750,1 +757,1 @@\n-            \/\/ Reset the AccessControlContext.\n+            \/\/ Reset the Subject and AccessControlContext.\n@@ -752,0 +759,1 @@\n+            subject = null;\n@@ -1515,0 +1523,1 @@\n+            final Subject s;\n@@ -1518,0 +1527,1 @@\n+                s  = Monitor.this.subject;\n@@ -1534,2 +1544,13 @@\n-            if (ac == null) {\n-                throw new SecurityException(\"AccessControlContext cannot be null\");\n+            if (!SharedSecrets.getJavaLangAccess().allowSecurityManager()) {\n+                \/\/ No SecurityManager permitted:\n+                if (s == null) {\n+                    action.run();\n+                } else {\n+                    Subject.doAs(s, action);\n+                }\n+            } else {\n+                if (ac == null) {\n+                    throw new SecurityException(\"AccessControlContext cannot be null\");\n+                }\n+                \/\/ ACC means SM is permitted.\n+                AccessController.doPrivileged(action, ac);\n@@ -1537,1 +1558,0 @@\n-            AccessController.doPrivileged(action, ac);\n","filename":"src\/java.management\/share\/classes\/javax\/management\/monitor\/Monitor.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -108,0 +108,4 @@\n+\n+    \/\/ CRaC support\n+    public long getRestoreTime();\n+    public long getUptimeSinceRestore();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagement.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,0 +285,12 @@\n+\n+    \/\/ CRaC support\n+    private native long getRestoreTime0();\n+    private native long getUptimeSinceRestore0();\n+\n+    public long getRestoreTime() {\n+        return getRestoreTime0();\n+    }\n+\n+    public long getUptimeSinceRestore() {\n+        return getUptimeSinceRestore0();\n+    }\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagementImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -325,0 +325,16 @@\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_VMManagementImpl_getRestoreTime0\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return jmm_interface->GetLongAttribute(env, NULL,\n+                                           JMM_JVM_RESTORE_START_TIME_MS);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_VMManagementImpl_getUptimeSinceRestore0\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return jmm_interface->GetLongAttribute(env, NULL,\n+                                           JMM_JVM_UPTIME_SINCE_RESTORE_MS);\n+}\n","filename":"src\/java.management\/share\/native\/libmanagement\/VMManagementImpl.c","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"RMIREGISTRY\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"RMIREGISTRY\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/java.rmi\/share\/man\/rmiregistry.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JRUNSCRIPT\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JRUNSCRIPT\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/java.scripting\/share\/man\/jrunscript.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-        ENTITYFailedInitializeGrammar =  ENTITYDatatype-Validator: Nicht erfolgreich. Initialisierungsmethode muss mit einer gltigen Grammatikreferenz aufgerufen werden. \\t\n+        ENTITYFailedInitializeGrammar =  ENTITYDatatype-Validator: Nicht erfolgreich. Initialisierungsmethode muss mit einer gltigen Grammatikreferenz aufgerufen werden.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-        ENTITYFailedInitializeGrammar =  ENTITYDatatype:  \\t\n+        ENTITYFailedInitializeGrammar =  ENTITYDatatype: \n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-        ENTITYFailedInitializeGrammar =  ENTITYDatatype : \\t\n+        ENTITYFailedInitializeGrammar =  ENTITYDatatype : \n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XMLMessages_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-MultipleShortHandPointers = MultipleShortHandPointers: XPointer-Ausdruck \"{0}\" ist ungltig. Mehrere ShortHand-Zeiger vorhanden.\n+MultipleShortHandPointers = MultipleShortHandPointers: Der XPointer-Ausdruck \"{0}\" ist ungltig. Er enthlt mehrere ShortHand-Zeiger.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/msg\/XPointerMessages_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+    Preview preview;\n@@ -138,1 +139,1 @@\n-        Preview preview = Preview.instance(context);\n+        preview = Preview.instance(context);\n@@ -1483,0 +1484,1 @@\n+     *  @param pos       The position to use for error reporting.\n@@ -1486,1 +1488,1 @@\n-    Symbol findVar(Env<AttrContext> env, Name name) {\n+    Symbol findVar(DiagnosticPosition pos, Env<AttrContext> env, Name name) {\n@@ -1511,1 +1513,1 @@\n-                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym))\n+                    if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym))\n@@ -2424,1 +2426,1 @@\n-        return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(env, name, kind), name));\n+        return checkNonExistentType(checkRestrictedType(pos, findIdentInternal(pos, env, name, kind), name));\n@@ -2427,1 +2429,1 @@\n-    Symbol findIdentInternal(Env<AttrContext> env, Name name, KindSelector kind) {\n+    Symbol findIdentInternal(DiagnosticPosition pos, Env<AttrContext> env, Name name, KindSelector kind) {\n@@ -2432,1 +2434,1 @@\n-            sym = findVar(env, name);\n+            sym = findVar(pos, env, name);\n@@ -3779,1 +3781,1 @@\n-                    else if (env1.info.ctorPrologue && !isAllowedEarlyReference(env1, (VarSymbol)sym))\n+                    else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym))\n@@ -3848,1 +3850,1 @@\n-    private boolean isAllowedEarlyReference(Env<AttrContext> env, VarSymbol v) {\n+    private boolean isAllowedEarlyReference(DiagnosticPosition pos, Env<AttrContext> env, VarSymbol v) {\n@@ -3864,1 +3866,14 @@\n-        JCExpression base = lhs instanceof JCFieldAccess select ? select.selected : null;\n+        JCExpression base;\n+        switch (lhs.getTag()) {\n+        case IDENT:\n+            base = null;\n+            break;\n+        case SELECT:\n+            JCFieldAccess select = (JCFieldAccess)lhs;\n+            base = select.selected;\n+            if (!TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base))\n+                return false;\n+            break;\n+        default:\n+            return false;\n+        }\n@@ -3870,0 +3885,3 @@\n+        \/\/ The flexible constructors feature must be enabled\n+        preview.checkSourceLevel(pos, Feature.FLEXIBLE_CONSTRUCTORS);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,1 @@\n+import static com.sun.tools.javac.code.TypeTag.VOID;\n@@ -1263,1 +1264,5 @@\n-                        tree.body = make.Block(0, List.of(make.Return(value)));\n+                        if (value.type.hasTag(VOID)) {\n+                            tree.body = make.Block(0, List.of(make.Exec(value)));\n+                        } else {\n+                            tree.body = make.Block(0, List.of(make.Return(value)));\n+                        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3439,1 +3439,9 @@\n-                case RPAREN: parenDepth--; break;\n+                case RPAREN:\n+                    parenDepth--;\n+                    if (parenDepth == 0 &&\n+                        typeDepth == 0 &&\n+                        peekToken(lookahead, TokenKind.IDENTIFIER) &&\n+                        S.token(lookahead + 1).name() == names.when) {\n+                        return PatternResult.PATTERN;\n+                    }\n+                    break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,0 +297,3 @@\n+# 0: symbol or name\n+compiler.err.cant.assign.initialized.before.ctor.called=Initialisiertes Feld \"{0}\" kann nicht zugewiesen werden, bevor der Supertypkonstruktor aufgerufen wurde\n+\n@@ -406,0 +409,4 @@\n+compiler.err.unconditional.pattern.and.both.boolean.values=Switch umfasst sowohl boolesche Werte als auch ein nicht bedingtes Muster\n+\n+compiler.err.default.and.both.boolean.values=Switch umfasst sowohl boolesche Werte als auch ein Standardlabel\n+\n@@ -416,4 +423,1 @@\n-# 0: type\n-compiler.err.selector.type.not.allowed=Selektortyp {0} ist nicht zulssig\n-\n-compiler.err.flows.through.to.pattern=Ungltiger Fallthrough zu einem Muster\n+compiler.err.flows.through.to.pattern=Unzulssiger Fallthrough auf ein Muster\\n(im vorherigen CASE-Label fehlt ein Break)\n@@ -421,1 +425,1 @@\n-compiler.err.flows.through.from.pattern=Ungltiger Fallthrough von einem Muster\n+compiler.err.flows.through.from.pattern=Unzulssiger Fallthrough von einem Muster\\n(im aktuellen CASE-Label fehlt ein Break)\n@@ -536,0 +540,4 @@\n+compiler.err.illegal.digit.in.binary.literal=Unzulssige Ziffer in einem binren Literal\n+\n+compiler.err.illegal.digit.in.octal.literal=Unzulssige Ziffer in einem oktalen Literal\n+\n@@ -964,9 +972,0 @@\n-compiler.err.string.template.is.not.well.formed=Zeichenfolgenvorlage ist nicht wohlgeformt\n-\n-compiler.err.text.block.template.is.not.well.formed=Textblockvorlage ist nicht wohlgeformt\n-\n-compiler.err.processor.missing.from.string.template.expression=Prozessor fehlt in Zeichenfolgenvorlagen-Ausdruck\n-\n-# 0: symbol\n-compiler.err.not.a.processor.type=Kein Prozessortyp: {0}\n-\n@@ -1342,0 +1341,2 @@\n+compiler.warn.dangling.doc.comment=Dokumentationskommentar ist an keine Deklaration angehngt\n+\n@@ -1904,3 +1905,0 @@\n-# 0: type, 1: type\n-compiler.misc.not.applicable.types=Muster des Typs {1} ist bei {0} nicht anwendbar\n-\n@@ -2273,0 +2271,2 @@\n+compiler.misc.feature.primitive.patterns=Primitive Muster\n+\n@@ -2281,2 +2281,0 @@\n-compiler.misc.feature.string.templates=Zeichenfolgenvorlagen\n-\n@@ -2287,1 +2285,3 @@\n-compiler.misc.feature.super.init=Anweisungen vor super()\n+compiler.misc.feature.flexible.constructors=Flexible Konstruktoren\n+\n+compiler.misc.feature.module.imports=Modulimporte\n@@ -2308,1 +2308,3 @@\n-# TODO 308: make a better error message\n+# 0: fragment, 1: symbol, 2: annotated-type\n+compiler.err.type.annotation.inadmissible={0} wurde hier nicht erwartet\\n(Um einen qualifizierten Typ zu annotieren, schreiben Sie {1}.{2})\n+\n@@ -2310,1 +2312,1 @@\n-compiler.err.cant.type.annotate.scoping.1=Scoping-Konstrukt kann nicht mit type-use-Annotation versehen werden: {0}\n+compiler.misc.type.annotation.1=Typannotation {0} ist\n@@ -2312,1 +2314,0 @@\n-# TODO 308: make a better error message\n@@ -2314,1 +2315,1 @@\n-compiler.err.cant.type.annotate.scoping=Scoping-Konstrukt kann nicht mit type-use-Annotationen versehen werden: {0}\n+compiler.misc.type.annotation=Typannotationen {0} sind\n@@ -2505,0 +2506,9 @@\n+# 0: name\n+compiler.err.import.module.not.found=Importiertes Modul nicht gefunden: {0}\n+\n+# 0: symbol\n+compiler.err.import.module.does.not.read.unnamed=Unbenanntes Modul kann Folgendes nicht lesen: {0}\n+\n+# 0: symbol, 1: symbol\n+compiler.err.import.module.does.not.read=Modul {0} kann Folgendes nicht lesen: {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_de.properties","additions":35,"deletions":25,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,0 +297,3 @@\n+# 0: symbol or name\n+compiler.err.cant.assign.initialized.before.ctor.called=''{0}''\n+\n@@ -406,0 +409,4 @@\n+compiler.err.unconditional.pattern.and.both.boolean.values=switch\n+\n+compiler.err.default.and.both.boolean.values=switchdefault\n+\n@@ -416,4 +423,1 @@\n-# 0: type\n-compiler.err.selector.type.not.allowed={0}\n-\n-compiler.err.flows.through.to.pattern=fall-through\n+compiler.err.flows.through.to.pattern=fall-through\\n(casebreak)\n@@ -421,1 +425,1 @@\n-compiler.err.flows.through.from.pattern=fall-through\n+compiler.err.flows.through.from.pattern=fall-through\\n(casebreak)\n@@ -536,0 +540,4 @@\n+compiler.err.illegal.digit.in.binary.literal=2\n+\n+compiler.err.illegal.digit.in.octal.literal=8\n+\n@@ -964,9 +972,0 @@\n-compiler.err.string.template.is.not.well.formed=\n-\n-compiler.err.text.block.template.is.not.well.formed=\n-\n-compiler.err.processor.missing.from.string.template.expression=\n-\n-# 0: symbol\n-compiler.err.not.a.processor.type=: {0}\n-\n@@ -1342,0 +1341,2 @@\n+compiler.warn.dangling.doc.comment=\n+\n@@ -1904,3 +1905,0 @@\n-# 0: type, 1: type\n-compiler.misc.not.applicable.types={1}{0}\n-\n@@ -2273,0 +2271,2 @@\n+compiler.misc.feature.primitive.patterns=\n+\n@@ -2281,2 +2281,0 @@\n-compiler.misc.feature.string.templates=\n-\n@@ -2287,1 +2285,3 @@\n-compiler.misc.feature.super.init=super()\n+compiler.misc.feature.flexible.constructors=\n+\n+compiler.misc.feature.module.imports=\n@@ -2308,1 +2308,3 @@\n-# TODO 308: make a better error message\n+# 0: fragment, 1: symbol, 2: annotated-type\n+compiler.err.type.annotation.inadmissible={0}\\n({1}.{2})\n+\n@@ -2310,1 +2312,1 @@\n-compiler.err.cant.type.annotate.scoping.1=: {0}\n+compiler.misc.type.annotation.1={0}\n@@ -2312,1 +2314,0 @@\n-# TODO 308: make a better error message\n@@ -2314,1 +2315,1 @@\n-compiler.err.cant.type.annotate.scoping=: {0}\n+compiler.misc.type.annotation={0}\n@@ -2505,0 +2506,9 @@\n+# 0: name\n+compiler.err.import.module.not.found=: {0}\n+\n+# 0: symbol\n+compiler.err.import.module.does.not.read.unnamed=: {0}\n+\n+# 0: symbol, 1: symbol\n+compiler.err.import.module.does.not.read={0}: {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_ja.properties","additions":35,"deletions":25,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-compiler.err.already.annotated={0} {1}\n+compiler.err.already.annotated={0} {1} \n@@ -297,0 +297,3 @@\n+# 0: symbol or name\n+compiler.err.cant.assign.initialized.before.ctor.called= ''{0}''\n+\n@@ -406,0 +409,4 @@\n+compiler.err.unconditional.pattern.and.both.boolean.values=switch \n+\n+compiler.err.default.and.both.boolean.values=switch  default \n+\n@@ -416,4 +423,1 @@\n-# 0: type\n-compiler.err.selector.type.not.allowed= {0}\n-\n-compiler.err.flows.through.to.pattern= (fall-through) \n+compiler.err.flows.through.to.pattern= (fall-through) \\n case \n@@ -421,1 +425,1 @@\n-compiler.err.flows.through.from.pattern= (fall-through) \n+compiler.err.flows.through.from.pattern= (fall-through) \\n case \n@@ -425,1 +429,1 @@\n-compiler.err.default.label.not.allowed=\n+compiler.err.default.label.not.allowed= default \n@@ -536,0 +540,4 @@\n+compiler.err.illegal.digit.in.binary.literal=\n+\n+compiler.err.illegal.digit.in.octal.literal=\n+\n@@ -637,1 +645,1 @@\n-compiler.err.static.methods.cannot.be.annotated.with.override= @Override \n+compiler.err.static.methods.cannot.be.annotated.with.override= @Override \n@@ -964,9 +972,0 @@\n-compiler.err.string.template.is.not.well.formed=\n-\n-compiler.err.text.block.template.is.not.well.formed=\n-\n-compiler.err.processor.missing.from.string.template.expression=\n-\n-# 0: symbol\n-compiler.err.not.a.processor.type={0}\n-\n@@ -1342,0 +1341,2 @@\n+compiler.warn.dangling.doc.comment=\n+\n@@ -1640,1 +1641,1 @@\n-compiler.warn.missing.deprecated.annotation= @Deprecated \n+compiler.warn.missing.deprecated.annotation= @Deprecated \n@@ -1904,3 +1905,0 @@\n-# 0: type, 1: type\n-compiler.misc.not.applicable.types= {1}  {0}\n-\n@@ -2273,0 +2271,2 @@\n+compiler.misc.feature.primitive.patterns=\n+\n@@ -2281,2 +2281,0 @@\n-compiler.misc.feature.string.templates=\n-\n@@ -2287,1 +2285,3 @@\n-compiler.misc.feature.super.init=super() \n+compiler.misc.feature.flexible.constructors=\n+\n+compiler.misc.feature.module.imports=\n@@ -2308,1 +2308,3 @@\n-# TODO 308: make a better error message\n+# 0: fragment, 1: symbol, 2: annotated-type\n+compiler.err.type.annotation.inadmissible={0} \\n {1}.{2}\n+\n@@ -2310,1 +2312,1 @@\n-compiler.err.cant.type.annotate.scoping.1= type-use  {0} \n+compiler.misc.type.annotation.1= {0} \n@@ -2312,1 +2314,0 @@\n-# TODO 308: make a better error message\n@@ -2314,1 +2315,1 @@\n-compiler.err.cant.type.annotate.scoping= type-use  {0} \n+compiler.misc.type.annotation= {0} \n@@ -2505,0 +2506,9 @@\n+# 0: name\n+compiler.err.import.module.not.found={0}\n+\n+# 0: symbol\n+compiler.err.import.module.does.not.read.unnamed={0}\n+\n+# 0: symbol, 1: symbol\n+compiler.err.import.module.does.not.read= {0} {1}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_zh_CN.properties","additions":39,"deletions":29,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,2 @@\n+javac.opt.Xlint.desc.dangling-doc-comments=Warnt vor Dokumentationskommentaren, die an keine Deklaration angehngt sind.\n+\n@@ -217,0 +219,1 @@\n+javac.opt.lineDocComments=Untersttzung fr Dokumentationskommentare mit Zeilen, die mit \"\/\/\/\" beginnen, deaktivieren\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac_de.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,2 @@\n+javac.opt.Xlint.desc.dangling-doc-comments=\n+\n@@ -217,0 +219,1 @@\n+javac.opt.lineDocComments='\/\/\/'\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac_ja.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,2 @@\n+javac.opt.Xlint.desc.dangling-doc-comments=\n+\n@@ -217,0 +219,1 @@\n+javac.opt.lineDocComments= '\/\/\/' \n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac_zh_CN.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,2 +125,0 @@\n-launcher.err.enable.preview.requires.source=--enable-preview muss mit --source verwendet werden\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher_de.properties","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,2 +125,0 @@\n-launcher.err.enable.preview.requires.source=--enable-preview--source\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher_ja.properties","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,3 +123,1 @@\n-launcher.err.invalid.value.for.source=--source {0}\\n\n-\n-launcher.err.enable.preview.requires.source=--enable-preview  --source \n+launcher.err.invalid.value.for.source=--source {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/launcher_zh_CN.properties","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -187,0 +187,3 @@\n+        else if (arg instanceof JCDiagnostic.AnnotatedType type) {\n+            preprocessType(type.type());\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-.TH \"JAVAC\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JAVAC\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.compiler\/share\/man\/javac.1","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"SERIALVER\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"SERIALVER\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.compiler\/share\/man\/serialver.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  private static int CLASS_STATE_BEING_LINKED;\n@@ -104,1 +103,0 @@\n-    CLASS_STATE_BEING_LINKED = db.lookupIntConstant(\"InstanceKlass::being_linked\").intValue();\n@@ -161,1 +159,0 @@\n-     public static final ClassState BEING_LINKED = new ClassState(\"beingLinked\");\n@@ -185,2 +182,0 @@\n-     } else if (state == CLASS_STATE_BEING_LINKED) {\n-        return ClassState.BEING_LINKED;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JHSDB\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JHSDB\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.hotspot.agent\/share\/man\/jhsdb.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JWEBSERVER\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JWEBSERVER\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.httpserver\/share\/man\/jwebserver.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                    mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);\n+                    mh$.invokeExact(hConsoleOutput, lpScrollRectangle.seg, lpClipRectangle.seg, dwDestinationOrigin.seg, lpFill.seg);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/ffm\/Kernel32.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        String path = System.getenv(\"PATH\");\n+        String path = \"\/usr\/bin\" + File.pathSeparator + \"\/bin\";\/\/was: System.getenv(\"PATH\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/OSUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JAR\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JAR\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jartool\/share\/man\/jar.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-.TH \"JARSIGNER\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JARSIGNER\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jartool\/share\/man\/jarsigner.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.lang.model.element.ModuleElement;\n@@ -598,0 +599,31 @@\n+\n+    \/**\n+     * Returns an id for a snippet.\n+     *\n+     * @param e the element in whose documentation the snippet appears\n+     * @param snippetIds the set of snippet ids already generated\n+     * @return a unique id for the snippet\n+     *\/\n+    public HtmlId forSnippet(Element e, Set<String> snippetIds) {\n+        String id = \"snippet-\";\n+        ElementKind kind = e.getKind();\n+        if (kind == ElementKind.PACKAGE) {\n+            id += forPackage((PackageElement) e).name();\n+        } else if (kind.isDeclaredType()) {\n+            id += forClass((TypeElement) e).name();\n+        } else if (kind.isExecutable()) {\n+            id += forMember((ExecutableElement) e).getFirst().name();\n+        } else if (kind.isField()) {\n+            id += forMember((VariableElement) e).name();\n+        } else if (kind == ElementKind.MODULE) {\n+            id += ((ModuleElement) e).getQualifiedName();\n+        } else {\n+            \/\/ while utterly unexpected, we shouldn't fail\n+            id += \"unknown-element\";\n+        }\n+        int counter = 1;\n+        while (!snippetIds.add(id + counter)) {\n+            counter++;\n+        }\n+        return HtmlId.of(id + counter);\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,1 @@\n+doclet.Deprecated_API_Checkbox_All_Releases=Alle\n@@ -125,0 +126,1 @@\n+doclet.New_API_Checkbox_All_Releases=Alle\n@@ -130,0 +132,1 @@\n+doclet.Preview_API_Checkbox_Toggle_All=Alle umschalten\n@@ -232,1 +235,1 @@\n-doclet.help.use.body=Fr jedes dokumentierte Package sowie jede Klasse und jede Schnittstelle ist eine eigene Verwendungsseite vorhanden. Auf dieser Seite wird beschrieben, welche Packages, Klassen, Methoden, Konstruktoren und Felder einen Teil der angegebenen Klasse oder des angegebenen Packages verwenden. Bei der Klasse oder Schnittstelle A enthlt die Verwendungsseite die Unterklassen von A, als A deklarierte Felder, Methoden, die A zurckgeben, sowie Methoden und Konstruktoren mit Parametern des Typs A. Sie knnen diese Seite aufrufen, indem Sie zunchst das Package, die Klasse oder die Schnittstelle aufrufen und anschlieend in der Navigationsleiste auf den Link \"Verwendung\" klicken.\n+doclet.help.use.body=Fr jedes dokumentierte Package sowie jede Klasse oder Schnittstelle ist eine eigene Verwendungsseite vorhanden. Auf dieser Seite werden die Packages, Klassen, Schnittstellen, Methoden, Konstruktoren und Felder aufgelistet, die einen Teil der angegebenen Klasse oder Schnittstelle oder des angegebenen Packages verwenden. Bei der Klasse oder Schnittstelle A enthlt die Verwendungsseite die Unterklassen oder Unterschnittstellen von A, als A deklarierte Felder, Methoden, die A zurckgeben, Methoden und Konstruktoren mit Parametern des Typs A und Unterklassen oder Unterschnittstellen mit Parametern des Typs A. Sie knnen auf diese Seite zugreifen, indem Sie zunchst das Package, die Klasse oder die Schnittstelle aufrufen und anschlieend in der Navigationsleiste auf den Link \"Verwendung\" klicken.\n@@ -287,0 +290,3 @@\n+doclet.ClassUse_SubclassTypeParameter=Unterklassen mit Typargumenten vom Typ {0} in {1}\n+doclet.ClassUse_SubinterfaceTypeParameter=Unterschnittstellen mit Typargumenten vom Typ {0} in {1}\n+doclet.ClassUse_ImplementsTypeParameter=Klassen in {1}, die Schnittstellen mit Typargumenten vom Typ {0} implementieren\n@@ -415,0 +421,2 @@\n+doclet.usage.no-fonts.description=Keine Standardwebschriftarten in generierte Dokumentation aufnehmen\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_de.properties","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,1 @@\n+doclet.Deprecated_API_Checkbox_All_Releases=\n@@ -125,0 +126,1 @@\n+doclet.New_API_Checkbox_All_Releases=\n@@ -130,0 +132,1 @@\n+doclet.Preview_API_Checkbox_Toggle_All=\n@@ -232,1 +235,1 @@\n-doclet.help.use.body=AAAAAA\n+doclet.help.use.body=AAAAAAA\n@@ -287,0 +290,3 @@\n+doclet.ClassUse_SubclassTypeParameter={0}{1}\n+doclet.ClassUse_SubinterfaceTypeParameter={0}{1}\n+doclet.ClassUse_ImplementsTypeParameter={0}{1}\n@@ -415,0 +421,2 @@\n+doclet.usage.no-fonts.description=web\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_ja.properties","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,1 @@\n+doclet.Deprecated_API_Checkbox_All_Releases=\n@@ -125,0 +126,1 @@\n+doclet.New_API_Checkbox_All_Releases=\n@@ -130,0 +132,1 @@\n+doclet.Preview_API_Checkbox_Toggle_All=\n@@ -232,1 +235,1 @@\n-doclet.help.use.body= A A  A  A  A \n+doclet.help.use.body= A A  A  A  A  A \n@@ -287,0 +290,3 @@\n+doclet.ClassUse_SubclassTypeParameter={1}  {0} \n+doclet.ClassUse_SubinterfaceTypeParameter={1}  {0} \n+doclet.ClassUse_ImplementsTypeParameter={1}  {0} \n@@ -415,0 +421,2 @@\n+doclet.usage.no-fonts.description= Web \n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_zh_CN.properties","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -151,0 +151,2 @@\n+        } else {\n+            pre.put(HtmlAttr.ID, config.htmlIds.forSnippet(element, ids).name());\n@@ -235,0 +237,2 @@\n+    private final Set<String> ids = new HashSet<>();\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SnippetTaglet.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -322,1 +322,2 @@\n- primitive components are compared with '=='.\n+ primitive components are compared with the <code>compare<\/code> method from \\\n+ their corresponding wrapper classes.\n@@ -325,1 +326,2 @@\n- All components in this record class are compared with '=='.\n+ All components in this record class are compared with the <code>compare<\/code> \\\n+ method from their corresponding wrapper classes.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -252,0 +252,1 @@\n+doclet.contains.diagnostic.markers=Die generierte Dokumentation enthlt Diagnosemarker fr eine ungltige Eingabe.\n@@ -280,1 +281,1 @@\n-doclet.record_equals_doc.fullbody.tail.both=Referenzkomponenten werden verglichen mit {@link java.util.Objects#equals(Object,Object) Objects::equals(Object,Object)}; primitive Komponenten werden verglichen mit \"==\".\n+doclet.record_equals_doc.fullbody.tail.both=Referenzkomponenten werden verglichen mit {@link java.util.Objects#equals(Object,Object) Objects::equals(Object,Object)}. Primitive Komponenten werden mit der <code>compare<\/code>-Methode aus den entsprechenden Wrapper-Klassen verglichen.\n@@ -282,1 +283,1 @@\n-doclet.record_equals_doc.fullbody.tail.primitive=Alle Komponenten in dieser Datensatzklasse werden verglichen mit \"==\".\n+doclet.record_equals_doc.fullbody.tail.primitive=Alle Komponenten dieser Datensatzklasse werden mit der <code>compare<\/code>-Methode aus den entsprechenden Wrapper-Klassen verglichen.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_de.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -252,0 +252,1 @@\n+doclet.contains.diagnostic.markers=\n@@ -280,1 +281,1 @@\n-doclet.record_equals_doc.fullbody.tail.both={@link java.util.Objects#equals(Object,Object) Objects::equals(Object,Object)}'=='\n+doclet.record_equals_doc.fullbody.tail.both={@link java.util.Objects#equals(Object,Object) Objects::equals(Object,Object)}<code>compare<\/code>\n@@ -282,1 +283,1 @@\n-doclet.record_equals_doc.fullbody.tail.primitive='=='\n+doclet.record_equals_doc.fullbody.tail.primitive=<code>compare<\/code>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_ja.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -252,0 +252,1 @@\n+doclet.contains.diagnostic.markers=\n@@ -280,1 +281,1 @@\n-doclet.record_equals_doc.fullbody.tail.both= {@link java.util.Objects#equals(Object,Object) Objects::equals(Object,Object)}  '==' \n+doclet.record_equals_doc.fullbody.tail.both= {@link java.util.Objects#equals(Object,Object) Objects::equals(Object,Object)}  <code>compare<\/code> \n@@ -282,1 +283,1 @@\n-doclet.record_equals_doc.fullbody.tail.primitive= '==' \n+doclet.record_equals_doc.fullbody.tail.primitive= <code>compare<\/code> \n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_zh_CN.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -162,0 +162,2 @@\n+main.opt.disable.line.doc.comments.desc=Untersttzung fr Dokumentationskommentare mit Zeilen,\\ndie mit \"\/\/\/\" beginnen, deaktivieren\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_de.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,0 +162,2 @@\n+main.opt.disable.line.doc.comments.desc='\/\/\/'\\n\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_ja.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,0 +162,2 @@\n+main.opt.disable.line.doc.comments.desc= '\/\/\/' \\n\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_zh_CN.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JAVADOC\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JAVADOC\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n@@ -221,1 +221,1 @@\n-\\[ga]{\\[at]return ...} tag.\n+\\f[V]{\\[at]return ...}\\f[R] tag.\n@@ -525,1 +525,2 @@\n-Includes the \\f[V]\\[at]author\\f[R] text in the generated docs.\n+Includes the text of any \\f[V]author\\f[R] tags in the generated\n+documentation.\n@@ -989,2 +990,2 @@\n-Omits from the generated documents the \\f[V]Since\\f[R] sections\n-associated with the \\f[V]\\[at]since\\f[R] tags.\n+Omits from the generated documentation the \\f[V]Since\\f[R] sections\n+derived from any \\f[V]since\\f[R] tags.\n@@ -1023,3 +1024,0 @@\n-.PD 0\n-.P\n-.PD\n@@ -1216,1 +1214,2 @@\n-Includes the version text in the generated docs.\n+Includes the text of any \\f[V]version\\f[R] tags in the generated\n+documentation.\n@@ -1218,2 +1217,2 @@\n-To find out what version of the \\f[V]javadoc\\f[R] tool you are using,\n-use the \\f[V]--version\\f[R] option (with two hyphens).\n+Note: To find out what version of the \\f[V]javadoc\\f[R] tool you are\n+using, use the \\f[V]--version\\f[R] option (with two hyphens).\n","filename":"src\/jdk.javadoc\/share\/man\/javadoc.1","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JCMD\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JCMD\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n@@ -531,1 +531,1 @@\n-\\f[V]path-to-gc-root\\f[R]: (Optional) Flag for saving the path to\n+\\f[V]path-to-gc-roots\\f[R]: (Optional) Flag for saving the path to\n@@ -609,1 +609,1 @@\n-\\f[V]path-to-gc-root\\f[R]: (Optional) Flag for saving the path to\n+\\f[V]path-to-gc-roots\\f[R]: (Optional) Flag for saving the path to\n@@ -684,0 +684,49 @@\n+\\f[V]JFR.view\\f[R] [\\f[I]options\\f[R]]\n+Display event data in predefined views.\n+.RS\n+.PP\n+Impact: Medium\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The \\f[I]options\\f[R] must be specified using either \\f[I]key\\f[R] or\n+\\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n+If no parameters are entered, then a list of available views are\n+displayed.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]cell-height\\f[R]: (Optional) Maximum number of rows in a table\n+cell.\n+(INT, default value depends on the view)\n+.IP \\[bu] 2\n+\\f[V]maxage\\f[R]: (Optional) Length of time for the view to span.\n+(INT followed by \\[aq]s\\[aq] for seconds \\[aq]m\\[aq] for minutes or\n+\\[aq]h\\[aq] for hours, default value is 10m)\n+.IP \\[bu] 2\n+\\f[V]maxsize\\f[R]: (Optional) Maximum size for the view to span in bytes\n+if one of the following suffixes is not used: \\[aq]m\\[aq] or \\[aq]M\\[aq]\n+for megabytes OR \\[aq]g\\[aq] or \\[aq]G\\[aq] for gigabytes.\n+(STRING, default value is 32MB)\n+.IP \\[bu] 2\n+\\f[V]truncate\\f[R]: (Optional) Maximum number of rows in a table cell.\n+(INT, default value depends on the view)\n+.IP \\[bu] 2\n+\\f[V]verbose\\f[R]: (Optional) Displays the query that makes up the view.\n+(BOOLEAN, default value is false)\n+.IP \\[bu] 2\n+\\f[V]width\\f[R]: (Optional) The width of the view in characters.\n+(INT, default value depends on the view)\n+.PP\n+\\f[I]arguments\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]view\\f[R]: Name of the view or event type to display.\n+Use \\f[V]help JFR.view\\f[R] to see a list of available views.\n+(STRING, no default value)\n+.PP\n+The view parameter can be an event type name.\n+Use \\f[V]JFR.view types\\f[R] to see a list.\n+To display all views, use \\f[V]JFR.view all-views\\f[R].\n+To display all events, use \\f[V]JFR.view all-events\\f[R].\n+.RE\n+.TP\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":52,"deletions":3,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JINFO\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JINFO\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jinfo.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JMAP\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JMAP\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jmap.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JPS\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JPS\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jps.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JSTACK\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JSTACK\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jstack.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JSTAT\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JSTAT\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jstat.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-VMINTERNAL_FRAME_ACCESSIBLE_DESCRIPTION=Innerer Frame fr die berwachung einer Java Virtual Machine\n+VMINTERNAL_FRAME_ACCESSIBLE_DESCRIPTION=Innerer Frame fr das Monitoring einer Java Virtual Machine\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/resources\/messages_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JCONSOLE\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JCONSOLE\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jconsole\/share\/man\/jconsole.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-                        for (var flag : info.flags()) {\n+                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,6 @@\n+import java.lang.classfile.AccessFlags;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.Modifier;\n+import java.util.EnumMap;\n+import java.util.Map;\n+import java.util.Set;\n@@ -41,0 +47,20 @@\n+    private static final Map<AccessFlag.Location, Integer> LOCATION_MASKS;\n+\n+    static {\n+        var map = new EnumMap<AccessFlag.Location, Integer>(AccessFlag.Location.class);\n+        for (var loc : AccessFlag.Location.values()) {\n+            map.put(loc, 0);\n+        }\n+\n+        for (var flag : AccessFlag.values()) {\n+            for (var loc : flag.locations()) {\n+                map.compute(loc, (_, v) -> v | flag.mask());\n+            }\n+        }\n+\n+        \/\/ Peculiarities from AccessFlag.maskToAccessFlag\n+        map.compute(AccessFlag.Location.METHOD, (_, v) -> v | Modifier.STRICT);\n+\n+        LOCATION_MASKS = map;\n+    }\n+\n@@ -49,0 +75,14 @@\n+    protected Set<AccessFlag> flagsReportUnknown(AccessFlags flags) {\n+        return maskToAccessFlagsReportUnknown(flags.flagsMask(), flags.location());\n+    }\n+\n+    protected Set<AccessFlag> maskToAccessFlagsReportUnknown(int mask, AccessFlag.Location location) {\n+        try {\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        } catch (IllegalArgumentException ex) {\n+            mask &= LOCATION_MASKS.get(location);\n+            report(\"Access Flags: \" + ex.getMessage());\n+            return AccessFlag.maskToAccessFlags(mask, location);\n+        }\n+    }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/BasicWriter.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-        writeModifiers(flags.flags().stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsReportUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n@@ -449,1 +449,1 @@\n-                    flags.flags().stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    flagsReportUnknown(flags).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n@@ -481,1 +481,1 @@\n-        for (var f : AccessFlags.ofMethod(flags).flags())\n+        for (var f : flagsReportUnknown(m.flags()))\n@@ -564,1 +564,1 @@\n-            for (var f : AccessFlags.ofMethod(flags).flags()) {\n+            for (var f : flagsReportUnknown(m.flags())) {\n@@ -797,11 +797,3 @@\n-    private static Set<String> getClassModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n-                ? mask & ~ACC_ABSTRACT : mask).flags());\n-    }\n-\n-    private static Set<String> getMethodModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofMethod(mask).flags());\n-    }\n-\n-    private static Set<String> getFieldModifiers(int mask) {\n-        return getModifiers(AccessFlags.ofField(mask).flags());\n+    private Set<String> getClassModifiers(int mask) {\n+        return getModifiers(flagsReportUnknown(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+                ? mask & ~ACC_ABSTRACT : mask)));\n@@ -817,2 +809,2 @@\n-    private static Set<String> getClassFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofClass(mask).flags());\n+    private Set<String> getClassFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofClass(mask)));\n@@ -821,2 +813,2 @@\n-    private static Set<String> getMethodFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofMethod(mask).flags());\n+    private Set<String> getMethodFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofMethod(mask)));\n@@ -825,2 +817,2 @@\n-    private static Set<String> getFieldFlags(int mask) {\n-        return getFlags(mask, AccessFlags.ofField(mask).flags());\n+    private Set<String> getFieldFlags(int mask) {\n+        return getFlags(mask, flagsReportUnknown(AccessFlags.ofField(mask)));\n@@ -843,36 +835,0 @@\n-    public static enum AccessFlag {\n-        ACC_PUBLIC      (ClassFile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n-        ACC_PRIVATE     (ClassFile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n-        ACC_PROTECTED   (ClassFile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n-        ACC_STATIC      (ClassFile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n-        ACC_FINAL       (ClassFile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n-        ACC_SUPER       (ClassFile.ACC_SUPER,        null,           true,  false, false, false),\n-        ACC_SYNCHRONIZED(ClassFile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n-        ACC_VOLATILE    (ClassFile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n-        ACC_BRIDGE      (ClassFile.ACC_BRIDGE,       null,           false, false, false, true ),\n-        ACC_TRANSIENT   (ClassFile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n-        ACC_VARARGS     (ClassFile.ACC_VARARGS,      null,           false, false, false, true ),\n-        ACC_NATIVE      (ClassFile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n-        ACC_INTERFACE   (ClassFile.ACC_INTERFACE,    null,           true,   true, false, false),\n-        ACC_ABSTRACT    (ClassFile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n-        ACC_STRICT      (ClassFile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n-        ACC_SYNTHETIC   (ClassFile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n-        ACC_ANNOTATION  (ClassFile.ACC_ANNOTATION,   null,           true,   true, false, false),\n-        ACC_ENUM        (ClassFile.ACC_ENUM,         null,           true,   true, true,  false),\n-        ACC_MODULE      (ClassFile.ACC_MODULE,       null,           true,  false, false, false);\n-\n-        public final int flag;\n-        public final String modifier;\n-        public final boolean isClass, isInnerClass, isField, isMethod;\n-\n-        AccessFlag(int flag, String modifier, boolean isClass,\n-                boolean isInnerClass, boolean isField, boolean isMethod) {\n-            this.flag = flag;\n-            this.modifier = modifier;\n-            this.isClass = isClass;\n-            this.isInnerClass = isInnerClass;\n-            this.isField = isField;\n-            this.isMethod = isMethod;\n-        }\n-    }\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":13,"deletions":57,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+main.opt.verify=\\  -verify                          Gibt zustzliche Klassenverifizierungsinformationen aus\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/resources\/javap_de.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+main.opt.verify=\\  -verify                          \n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/resources\/javap_ja.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+main.opt.verify=\\  -verify                          \n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/resources\/javap_zh_CN.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JAVAP\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JAVAP\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jdeps\/share\/man\/javap.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JDEPRSCAN\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JDEPRSCAN\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jdeps\/share\/man\/jdeprscan.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JDEPS\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JDEPS\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jdeps\/share\/man\/jdeps.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-        {\"Unmonitoring\", \"\\u00DCberwachung von {0} aufheben\"},\n+        {\"Unmonitoring\", \"Monitoring von {0} aufheben\"},\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources_de.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JDB\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JDB\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jdi\/share\/man\/jdb.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal;\n+\n+\/**\n+ * The HiddenWait class is used to exclude jdk.JavaMonitorWait events\n+ * from being generated when Object.wait() is called on an object of this type.\n+ *\/\n+public final class HiddenWait {\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/HiddenWait.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,0 @@\n-    private static class ChunkRotationMonitor {}\n-\n@@ -48,2 +46,0 @@\n-     * The monitor type is used to exclude jdk.JavaMonitorWait events from being generated\n-     * when Object.wait() is called on this monitor.\n@@ -51,1 +47,1 @@\n-    public static final Object CHUNK_ROTATION_MONITOR = new ChunkRotationMonitor();\n+    public static final Object CHUNK_ROTATION_MONITOR = new HiddenWait();\n@@ -177,0 +173,5 @@\n+    \/**\n+     * Returns the same clock that sets the start time of a chunk (in nanos).\n+     *\/\n+    public static native long nanosNow();\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,0 @@\n-        \/\/ JVM::getChunkStartNanos() may return a bumped timestamp, +1 ns or +2 ns.\n@@ -122,5 +121,1 @@\n-            try {\n-                Thread.sleep(0, 100);\n-            } catch (InterruptedException iex) {\n-                \/\/ ignore\n-            }\n+            Utils.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+    private long lastMillis;\n+\n@@ -316,0 +318,5 @@\n+        \/\/ Each chunk needs a unique timestamp. If two chunks get the same\n+        \/\/ timestamp, the parser may stop prematurely at an earlier chunk.\n+        \/\/ The resolution needs to be measured in milliseconds as this\n+        \/\/ is what RecordingInfo:getStopTime() returns.\n+        awaitEpochMilliShift();\n@@ -317,4 +324,0 @@\n-        \/\/ Each chunk needs a unique start timestamp and\n-        \/\/ if the clock resolution is low, two chunks may\n-        \/\/ get the same timestamp. Utils.getChunkStartNanos()\n-        \/\/ ensures the timestamp is unique for the next chunk\n@@ -335,0 +338,12 @@\n+    private void awaitEpochMilliShift() {\n+        while (true) {\n+            long nanos = JVM.nanosNow();\n+            long millis = Utils.epochNanosToInstant(nanos).toEpochMilli();\n+            if (millis != lastMillis) {\n+                lastMillis = millis;\n+                return;\n+            }\n+            Utils.takeNap(1);\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,1 +208,1 @@\n-    protected abstract boolean isRecording();\n+    protected abstract boolean isRecordingStream();\n@@ -252,1 +252,1 @@\n-            if (isRecording() && streamConfiguration.startTime == null) {\n+            if (isRecordingStream() && streamConfiguration.startTime == null) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -39,0 +40,1 @@\n+import jdk.jfr.RecordingState;\n@@ -62,0 +64,1 @@\n+    private final AtomicLong streamId = new AtomicLong();\n@@ -83,0 +86,2 @@\n+        this.streamId.incrementAndGet();\n+        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Stream \" + streamId + \" started.\");\n@@ -140,1 +145,1 @@\n-        boolean validStartTime = isRecording() || disp.startTime != null;\n+        boolean validStartTime = isRecordingStream() || disp.startTime != null;\n@@ -147,0 +152,1 @@\n+            logStreamEnd(\"no first chunk file found.\");\n@@ -171,1 +177,4 @@\n-                    if (currentParser.getLastFlush() > filterEnd) {\n+                    long lastFlush = currentParser.getLastFlush();\n+                    if (lastFlush  > filterEnd) {\n+                        logStreamEnd(\"end time at \" + filterEnd +\n+                                     \"ns (epoch), parser at \" + lastFlush + \"ns (epoch).\");\n@@ -180,0 +189,3 @@\n+                    String msg = \"stopped at \" + barrier.getStreamEnd() + \"ms (epoch), \";\n+                    msg += \"parser at \" + endMillis + \"ms (epoch), \" + endNanos + \"ns (epoch)\";\n+                    logStreamEnd(msg);\n@@ -183,3 +195,5 @@\n-                if (!barrier.hasStreamEnd() && isLastChunk()) {\n-                    \/\/ Recording was stopped\/closed externally, and no more data to process.\n-                    return;\n+                if (isRecordingStream()) {\n+                    if (recording.getState() == RecordingState.STOPPED && !barrier.used()) {\n+                        logStreamEnd(\"recording stopped externally.\");\n+                        return;\n+                    }\n@@ -189,1 +203,1 @@\n-                    \/\/ JVM process exited\/crashed, or repository migrated to an unknown location\n+                    logStreamEnd(\"JVM process exited\/crashed, or repository migrated to an unknown location.\");\n@@ -193,1 +207,1 @@\n-                    \/\/ Stream was closed\n+                    logStreamEnd(\"stream closed.\");\n@@ -208,1 +222,2 @@\n-                    return; \/\/ stream closed\n+                    logStreamEnd(\"no more chunk files found.\");\n+                    return;\n@@ -220,6 +235,3 @@\n-\n-    private boolean isLastChunk() {\n-        if (!isRecording()) {\n-            return false;\n-        }\n-        return recording.getFinalChunkStartNanos() >= currentParser.getStartNanos();\n+    private void logStreamEnd(String text) {\n+        String msg = \"Stream \" + streamId + \" ended, \" + text;\n+        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, msg);\n@@ -228,1 +240,1 @@\n-    protected boolean isRecording() {\n+    protected boolean isRecordingStream() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":28,"deletions":16,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    protected boolean isRecording() {\n+    protected boolean isRecordingStream() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventFileStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+    private boolean used = false;\n@@ -65,4 +66,0 @@\n-    public synchronized boolean hasStreamEnd() {\n-        return end != Long.MAX_VALUE;\n-    }\n-\n@@ -71,0 +68,1 @@\n+        used = true;\n@@ -78,0 +76,7 @@\n+\n+    \/**\n+     * Returns {@code true) if barrier is, or has been, in active state, {@code false) otherwise.\n+     *\/\n+    public synchronized boolean used() {\n+        return used;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamBarrier.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import jdk.jfr.internal.HiddenWait;\n@@ -354,0 +355,1 @@\n+        HiddenWait hiddenWait = new HiddenWait();\n@@ -355,1 +357,3 @@\n-            Thread.sleep(millis);\n+            synchronized(hiddenWait) {\n+                hiddenWait.wait(millis);\n+            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JFR\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JFR\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jfr\/share\/man\/jfr.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,3 +214,8 @@\n-                        (path, attrs) -> path.getFileName().toString().equals(\"jspawnhelper\")\n-                                      || path.getFileName().toString().equals(\"jexec\"),\n-                        this::setExecutable);\n+                        (path, attrs) -> {\n+                            String fileName = path.getFileName().toString();\n+                            return fileName.equals(\"jspawnhelper\")\n+                                || fileName.equals(\"jexec\")\n+                                || fileName.equals(\"criuengine\")\n+                                || fileName.equals(\"pauseengine\")\n+                                || fileName.equals(\"simengine\");\n+                        }, this::setExecutable);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JLINK\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JLINK\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jlink\/share\/man\/jlink.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JMOD\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JMOD\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jlink\/share\/man\/jmod.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-message.codesign.failed.reason.app.content=\"codesign\" failed and additional application content was supplied via the \"--app-content\" parameter. Probably the additional content broke the integrity of the application bundle and caused the failure. Ensure content supplied via the \"--app-content\" parameter does not break the integrity of the application bundle, or add it in the post-processing step.\n+message.codesign.failed.reason.app.content=\"codesign\" war nicht erfolgreich, und zustzlicher Anwendungsinhalt wurde ber den Parameter \"--app-content\" angegeben. Wahrscheinlich hat der zustzliche Inhalt die Integritt des Anwendungs-Bundles beeintrchtigt und den Fehler verursacht. Stellen Sie sicher, das der ber den Parameter \"--app-content\" angegebene Inhalt nicht die Integritt des Anwendungs-Bundles beeintrchtigt, oder fgen Sie ihn im Nachverarbeitungsschritt hinzu.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-message.codesign.failed.reason.app.content=\"codesign\" failed and additional application content was supplied via the \"--app-content\" parameter. Probably the additional content broke the integrity of the application bundle and caused the failure. Ensure content supplied via the \"--app-content\" parameter does not break the integrity of the application bundle, or add it in the post-processing step.\n+message.codesign.failed.reason.app.content=\"codesign\"\"--app-content\"\"--app-content\"\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_ja.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-message.codesign.failed.reason.app.content=\"codesign\" failed and additional application content was supplied via the \"--app-content\" parameter. Probably the additional content broke the integrity of the application bundle and caused the failure. Ensure content supplied via the \"--app-content\" parameter does not break the integrity of the application bundle, or add it in the post-processing step.\n+message.codesign.failed.reason.app.content=\"codesign\"  \"--app-content\"  \"--app-content\" \n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources_zh_CN.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JPACKAGE\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JPACKAGE\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jpackage\/share\/man\/jpackage.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-message.potential.windows.defender.issue=Warnung: Windows Defender verhindert eventuell die korrekte Ausfhrung von jpackage. Wenn ein Problem auftritt, deaktivieren Sie die Echtzeitberwachung, oder fgen Sie einen Ausschluss fr das Verzeichnis \"{0}\" hinzu.\n+message.potential.windows.defender.issue=Warnung: Windows Defender verhindert eventuell die korrekte Ausfhrung von jpackage. Wenn ein Problem auftritt, deaktivieren Sie das Echtzeitmonitoring, oder fgen Sie einen Ausschluss fr das Verzeichnis \"{0}\" hinzu.\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_de.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,1 +158,6 @@\n-            terminal = TerminalBuilder.builder().inputStreamWrapper(in -> {\n+            \/\/on platforms which are known to be fully supported by\n+            \/\/the FFMTerminalProvider, do not permit the ExecTerminalProvider:\n+            boolean allowExecTerminal = !OSUtils.IS_WINDOWS &&\n+                                        !OSUtils.IS_LINUX &&\n+                                        !OSUtils.IS_OSX;\n+            terminal = TerminalBuilder.builder().exec(allowExecTerminal).inputStreamWrapper(in -> {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+\n@@ -182,1 +183,1 @@\n-help.usage = Verwendung:   jshell <Option>... <Ladedatei>...\\nMgliche Optionen:\\n    --class-path <Pfad>   Gibt an, wo die Benutzerklassendateien gespeichert sind\\n    --module-path <Pfad>  Gibt an, wo die Anwendungsmodule gespeichert sind\\n    --add-modules <Modul>(,<Modul>)*\\n                          Gibt aufzulsende Module oder alle Module im\\n                            Modulpfad an, wenn <Modul> ALL-MODULE-PATHs lautet\\n    --enable-native-access\\n                          Ermglicht Ausfhrung eingeschrnkter nativer Methoden durch Code\\n    --enable-preview      Code kann Vorschaufeatures in diesem Release nutzen\\n    --startup <Datei>      Ersetzung der Startdefinitionen mit einer Ausfhrung\\n    --no-startup          Startdefinitionen werden nicht ausgefhrt\\n    --feedback <Modus>     Gibt den anfnglichen Feedbackmodus an. Der Modus kann\\n                            vordefiniert (Silent, Concise, Normal oder Verbose) oder\\n                            vorab benutzerdefiniert sein\\n    -q                    Stilles Feedback. Identisch mit: --feedback concise\\n    -s                    uerst stilles Feedback. Identisch mit: --feedback silent\\n    -v                    Verbose-Feedback. Identisch mit: --feedback verbose\\n    -J<Kennzeichen>              bergibt <Kennzeichen> direkt an das Laufzeitsystem.\\n                            Verwenden Sie ein -J pro Laufzeitkennzeichen oder Kennzeichenargument\\n    -R<Kennzeichen>              bergibt <Kennzeichen> an das Remotelaufzeitsystem.\\n                            Verwenden Sie ein -R pro Remotekennzeichen oder Kennzeichenargument\\n    -C<Kennzeichen>              bergibt <Kennzeichen> an den Compiler.\\n                            Verwenden Sie ein -C pro Compiler-Kennzeichen oder Kennzeichenargument\\n    --version             Gibt Versionsinformationen aus und beendet den Vorgang\\n    --show-version        Gibt Versionsinformationen aus und setzt den Vorgang fort\\n    --help, -?, -h        Gibt diese Zusammenfassung der Standardoptionen aus und beendet den Vorgang\\n    --help-extra, -X      Gibt Hilfetext zu Nicht-Standardoptionen aus und beendet den Vorgang\\n\\nEin Dateiargument kann ein Dateiname oder einer der vordefinierten Dateinamen sein: DEFAULT,\\nPRINTING, TOOLING oder JAVASE.\\nEine Ladedatei kann auch \"-\" zur Angabe einer Standardeingabe ohne interaktiven I\/O sein.\\n\\nWeitere Informationen zu den Auswertungskontextoptionen (--class-path,\\n--module-path und --add-modules) finden Sie unter:\\n\\t\/help context\\n\\nEin Pfad listet die zu durchsuchenden Verzeichnisse und Archive auf. Verwenden Sie unter Windows ein\\nSemikolon (;), um Elemente im Pfad zu trennen. Verwenden Sie auf anderen Plattformen einen\\nDoppelpunkt (:), um Elemente zu trennen.\\n\n+help.usage = Verwendung:   jshell <Option>... <Ladedatei>...\\nMgliche Optionen:\\n    --class-path <Pfad>   Gibt an, wo die Benutzerklassendateien gespeichert sind\\n    --module-path <Pfad>  Gibt an, wo die Anwendungsmodule gespeichert sind\\n    --add-modules <Modul>(,<Modul>)*\\n                         Gibt aufzulsende Module oder alle Module im\\n                            Modulpfad an, wenn <Modul> ALL-MODULE-PATHs lautet\\n    --enable-native-access\\n                          Ermglicht Ausfhrung eingeschrnkter nativer Methoden durch Code\\n    --enable-preview      Code kann Vorschaufeatures in diesem Release nutzen\\n    --startup <Datei>      Ersetzung der Startdefinitionen mit einer Ausfhrung\\n    --no-startup          Startdefinitionen werden nicht ausgefhrt\\n    --feedback <Modus>     Gibt den anfnglichen Feedbackmodus an. Der Modus kann\\n                            vordefiniert (Silent, Concise, Normal oder Verbose) oder\\n                            vorab benutzerdefiniert sein\\n    -q                    Stilles Feedback. Identisch mit: --feedback concise\\n    -s                    uerst stilles Feedback. Identisch mit: --feedback silent\\n    -v                    Verbose-Feedback. Identisch mit: --feedback verbose\\n    -J<Kennzeichen>              bergibt <Kennzeichen> an das Laufzeitsystem, hat aber keine Auswirkungen\\n                            auf die Ausfhrung von Code-Snippets. Um Kennzeichen anzugeben,\\n                            die die Ausfhrung von Code-Snippets beeinflussen, verwenden Sie\\n                            -R<Kennzeichen>. Verwenden Sie alternativ dazu -J<Kennzeichen> mit\\n                            --execution local.\\n    -R<Kennzeichen>              bergibt <Kennzeichen> nur dann an das Laufzeitsystem, wenn\\n                            Code-Snippets ausgefhrt werden. Beispiel: -R-Dfoo=bar\\n                            bedeutet, dass die Ausfhrung des Snippets\\n                            System.getProperty(\"foo\") \"bar\" zurckgibt.\\n    -C<flag>              bergibt <Kennzeichen> an den Java-Compiler in JShell.\\n                            Beispiel: -C-Xlint aktiviert alle empfohlenen\\n                            LINT-Warnungen, und -C--release=<N> kompiliert fr\\n                            Java SE N, wie wenn --release N angegeben wird.\\n                            Verwenden Sie ein -C pro Compiler-Kennzeichen oder Kennzeichenargument\\n    --version             Gibt Versionsinformationen aus und beendet den Vorgang\\n    --show-version        Gibt Versionsinformationen aus und setzt den Vorgang fort\\n    --help, -?, -h        Gibt diese Zusammenfassung der Standardoptionen aus und beendet den Vorgang\\n    --help-extra, -X      Gibt Hilfetext zu Nicht-Standardoptionen aus und beendet den Vorgang\\n\\nEin Dateiargument kann ein Dateiname oder einer der vordefinierten Dateinamen sein: DEFAULT,\\nPRINTING, TOOLING oder JAVASE.\\nEine Ladedatei kann auch \"-\" zur Angabe einer Standardeingabe ohne interaktiven I\/O sein.\\n\\nWeitere Informationen zu den Auswertungskontextoptionen (--class-path,\\n--module-path und --add-modules) finden Sie unter:\\n\\t\/help context\\n\\nEin Pfad listet die zu durchsuchenden Verzeichnisse und Archive auf. Verwenden Sie unter Windows ein\\nSemikolon (;), um Elemente im Pfad zu trennen. Verwenden Sie auf anderen Plattformen einen\\nDoppelpunkt (:), um Elemente zu trennen.\\n\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n_de.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+\n@@ -182,2 +183,2 @@\n-help.usage = :   jshell <option>... <load-file>...\\n:\\n    --class-path <path>   \\n    --module-path <path>  \\n    --add-modules <module>(,<module>)*\\n                          <module>ALL-MODULE-PATH\\n                            \\n    --enable-native-access\\n                          \\n    --enable-preview      \\n    --startup <file>      \\n    --no-startup          \\n    --feedback <mode>     \\n                            (silentconcisenormalverbose)\\n                            \\n    -q                    --feedback concise\\n    -s                    --feedback silent\\n    -v                    --feedback verbose\\n    -J<flag>              <flag>\\n                            1-J\\n    -R<flag>              <flag>\\n                            1-R\\n    -C<flag>              <flag>\\n                            1-C\\n    --version             \\n    --show-version        \\n    --help, -?, -h        \\n    --help-extra, -X      \\\n-\\n\\n(DEFAULT\\nPRINTINGTOOLINGJAVASE)1\\nload-fileI\/O\"-\"\\n\\n(--class-path--module-path\\n--add-modules):\\n\\t\/help context\\n\\nWindows\\n(;)\\n(:)\\n\n+help.usage = :   jshell <option>... <load-file>...\\n:\\n    --class-path <path>   \\n    --module-path <path>  \\n    --add-modules <module>(,<module>)*\\n                          <module>ALL-MODULE-PATH\\n                            \\n    --enable-native-access\\n                          \\n    --enable-preview      \\n    --startup <file>      \\n    --no-startup          \\n    --feedback <mode>     \\n                            (silentconcisenormalverbose)\\n                            \\n    -q                    --feedback concise\\n    -s                    --feedback silent\\n    -v                    --feedback verbose\\n    -J<flag>              <flag>\\n                            \\n                            -R<flag>\\n                            --execution\\n                            -J<flag>\\n    -R<flag>              \\n                            <flag>\\n                            -R-Dfoo=barSystem.getProperty(\"foo\")\\n                            bar\\n    -C<flag>              JShellJava<flag>\\n                            \\\n+-C-Xlintlint\\n                            -C--release=<N>--release N\\n                            Java SE N\\n                            1-C\\n    --version             \\n    --show-version        \\n    --help, -?, -h        \\n    --help-extra, -X      \\n\\n(DEFAULT\\nPRINTINGTOOLINGJAVASE)1\\nload-fileI\/O\"-\"\\n\\n(--class-path--module-path\\n--add-modules):\\n\\t\/help context\\n\\nWindows\\n(;)\\n(:)\\n\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n_ja.properties","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+\n@@ -182,1 +183,2 @@\n-help.usage =    jshell <option>... <load-file>...\\n\\n    --class-path <path>   \\n    --module-path <path>  \\n    --add-modules <module>(,<module>)*\\n                           <module>  \\n                            ALL-MODULE-PATHs\\n    --enable-native-access\\n                          \\n    --enable-preview      \\n    --startup <file>      \\n    --no-startup          \\n    --feedback <mode>     \\n                            silentconcisenormal  verbose\\n                            \\n    -q                    --feedback concise\\n    -s                    --feedback silent\\n    -v                    --feedback verbose\\n    -J<flag>               <flag> \\n                             -J\\n    -R<flag>               <flag> \\n                             -R\\n    -C<flag>               <flag> \\n                             -C\\n    --version             \\n    --show-version        \\n    --help, -?, -h        \\n    --help-extra, -X      \\n\\nDEFAULT\\nPRINTINGTOOLING  JAVASE\\n \"-\" I\/O\\n\\n--class-path--module-path \\n --add-modules\\n\\t\/help context\\n\\n Windows\\n (;) \\n (:) \\n\n+help.usage =    jshell <option>... <load-file>...\\n\\n    --class-path <path>   \\n    --module-path <path>  \\n    --add-modules <module>(,<module>)*\\n                           <module>  \\n                            ALL-MODULE-PATHs\\n    --enable-native-access\\n                          \\n    --enable-preview      \\n    --startup <file>      \\n    --no-startup          \\n    --feedback <mode>     \\n                            silentconcisenormal  verbose\\n                            \\n    -q                    --feedback concise\\n    -s                    --feedback silent\\n    -v                    --feedback verbose\\n    -J<flag>               <flag> \\n                            \\n                            \\n                            -R<flag> -J<flag> \\n                            --execution local \\n    -R<flag>               <flag>\\n                            -R-Dfoo=bar\\n                            \\n                            System.getProperty(\"foo\")  \"bar\"\\n    -C<flag>               <flag>  JShell  Java \\n                            -C-Xlint \\n                            lint  -C--release=<N> \\n                            Java SE N  --release N\\n                             -C\\n    --version             \\n    --show-version        \\n    --help, -?, -h        \\n    --help-extra, -X      \\n\\nDEFAULT\\nPRINTINGTOOLING  JAVASE\\n \"-\" I\/O\\n\\n--class-path--module-path \\n \\\n+--add-modules\\n\\t\/help context\\n\\n Windows\\n (;) \\n (:) \\n\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n_zh_CN.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-.TH \"JSHELL\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JSHELL\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jshell\/share\/man\/jshell.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-.TH \"JSTATD\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JSTATD\" \"1\" \"2024\" \"JDK 23\" \"JDK Commands\"\n","filename":"src\/jdk.jstatd\/share\/man\/jstatd.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.crac.management.CRaCMXBean;\n@@ -44,0 +45,2 @@\n+\n+import jdk.crac.management.internal.CRaCImpl;\n@@ -56,0 +59,5 @@\n+    \/\/ CRaC\n+    private static CRaCMXBean cracMXBean = null;\n+    public static final String CRAC_MXBEAN_NAME =\n+        \"jdk.management:type=CRaC\";\n+\n@@ -267,0 +275,30 @@\n+        \/**\n+         * CRaC MXBean\n+         *\/\n+        initMBeanList.add(new PlatformComponent<CRaCMXBean>() {\n+            private final Set<String> cracMXBeanInterfaceNames =\n+                Collections.singleton(\"jdk.crac.management.CRaCMXBean\");\n+\n+            @Override\n+            public Set<Class<? extends CRaCMXBean>> mbeanInterfaces() {\n+                return Collections.singleton(CRaCMXBean.class);\n+            }\n+\n+            @Override\n+            public Set<String> mbeanInterfaceNames() {\n+                return cracMXBeanInterfaceNames;\n+            }\n+\n+            @Override\n+            public String getObjectNamePattern() {\n+                return CRAC_MXBEAN_NAME;\n+            }\n+\n+            @Override\n+            public Map<String, CRaCMXBean> nameToMBeanMap() {\n+                return Collections.<String, CRaCMXBean>singletonMap(\n+                    CRAC_MXBEAN_NAME,\n+                    getCRaCMXBean());\n+            }\n+        });\n+\n@@ -284,0 +322,7 @@\n+\n+    private static synchronized CRaCMXBean getCRaCMXBean() {\n+        if (cracMXBean == null) {\n+            cracMXBean = new CRaCImpl(ManagementFactoryHelper.getVMManagement());\n+        }\n+        return cracMXBean;\n+    }\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.management;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.PlatformManagedObject;\n+import java.lang.management.RuntimeMXBean;\n+\n+\/**\n+ * Management interface for the CRaC functionality of the Java virtual machine.\n+ *\/\n+public interface CRaCMXBean extends PlatformManagedObject {\n+\n+    \/**\n+     * Returns the time since the Java virtual machine restore was initiated.\n+     * If the machine was not restored, returns -1.\n+     *\n+     * @see RuntimeMXBean#getStartTime()\n+     * @return uptime of the Java virtual machine in milliseconds.\n+     *\/\n+    public long getUptimeSinceRestore();\n+\n+    \/**\n+     * Returns the time when the Java virtual machine restore was initiated.\n+     * The value is the number of milliseconds since the start of the epoch.\n+     * If the machine was not restored, returns -1.\n+     *\n+     * @see RuntimeMXBean#getUptime()\n+     * @return start time of the Java virtual machine in milliseconds.\n+     *\/\n+    public long getRestoreTime();\n+\n+    \/**\n+     * Returns the implementation of the MXBean.\n+     *\n+     * @return implementation of the MXBean.\n+     *\/\n+    public static CRaCMXBean getCRaCMXBean() {\n+        return ManagementFactory.getPlatformMXBean(CRaCMXBean.class);\n+    }\n+\n+}\n","filename":"src\/jdk.management\/share\/classes\/jdk\/crac\/management\/CRaCMXBean.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.management.internal;\n+\n+import com.sun.management.internal.PlatformMBeanProviderImpl;\n+import jdk.crac.management.CRaCMXBean;\n+import sun.management.Util;\n+import sun.management.VMManagement;\n+\n+import javax.management.ObjectName;\n+\n+public class CRaCImpl implements CRaCMXBean {\n+    private final VMManagement vm;\n+\n+    public CRaCImpl(VMManagement vm) {\n+        this.vm = vm;\n+    }\n+\n+    @Override\n+    public long getUptimeSinceRestore() {\n+        return vm.getUptimeSinceRestore();\n+    }\n+\n+    @Override\n+    public long getRestoreTime() {\n+        return vm.getRestoreTime();\n+    }\n+\n+    @Override\n+    public ObjectName getObjectName() {\n+        return Util.newObjectName(PlatformMBeanProviderImpl.CRAC_MXBEAN_NAME);\n+    }\n+}\n","filename":"src\/jdk.management\/share\/classes\/jdk\/crac\/management\/internal\/CRaCImpl.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This package contains management interfaces for CRaC.\n+ *\/\n+\n+package jdk.crac.management;\n","filename":"src\/jdk.management\/share\/classes\/jdk\/crac\/management\/package-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+    exports jdk.crac.management;\n@@ -40,1 +41,0 @@\n-\n","filename":"src\/jdk.management\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,25 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(remoteAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import java.util.stream.Collectors;\n+\n@@ -82,0 +84,34 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            synchronized (stateLock) {\n+                if (!isOpen() || !isBound()) {\n+                    return Collections.emptySet();\n+                }\n+                return associationMap.keySet().stream().flatMap(a -> {\n+                    try {\n+                        return SctpMultiChannelImpl.this.getRemoteAddresses(a).stream();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }).collect(Collectors.toSet());\n+            }\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+package sun.nio.ch.sctp;\n+\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.JDKSocketResourceBase;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.channels.spi.AbstractSelectableChannel;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+abstract class SctpResource extends JDKSocketResourceBase {\n+    private Set<InetSocketAddress> localCopy;\n+    private Set<SocketAddress> remoteCopy;\n+\n+    public SctpResource(AbstractSelectableChannel sctpChannel) {\n+        super(sctpChannel);\n+    }\n+\n+    @Override\n+    protected OpenResourcePolicies.Policy findPolicy(boolean isRestore) {\n+        if (!isRestore) {\n+            localCopy = Set.copyOf(getLocalAddresses());\n+            remoteCopy = Set.copyOf(getRemoteAddresses());\n+        }\n+        List<Predicate<Map<String, String>>> localMatchers = localCopy.stream()\n+                .map(addr -> getMatcher(addr, \"localAddress\", \"localPort\", null)).toList();\n+        List<Predicate<Map<String, String>>> remoteMatchers = remoteCopy.stream()\n+                .map(addr -> getMatcher(addr, \"remoteAddress\", \"remotePort\", null)).toList();\n+        return OpenResourcePolicies.find(false, OpenResourcePolicies.SOCKET,\n+                params -> localMatchers.stream().anyMatch(matcher -> matcher.test(params)) &&\n+                        remoteMatchers.stream().anyMatch(matcher -> matcher.test(params)));\n+    }\n+\n+    @Override\n+    protected void reset() {\n+        localCopy = null;\n+        remoteCopy = null;\n+    }\n+\n+    @Override\n+    protected abstract void closeBeforeCheckpoint() throws IOException;\n+\n+    protected abstract Set<SocketAddress> getRemoteAddresses();\n+\n+    protected abstract HashSet<InetSocketAddress> getLocalAddresses();\n+}\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpResource.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.net.StandardProtocolFamily;\n@@ -44,0 +45,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -58,1 +60,0 @@\n-\n@@ -60,0 +61,23 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            return Collections.emptySet();\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -215,12 +215,0 @@\n-\/\/ If NewSize has been ergonomically set, the collector policy\n-\/\/ should use it for min\n-\/\/ This test doesn't work with 64k pages. See JDK-8331675.\n-#if !defined(PPC)\n-TEST_VM(CollectorPolicy, young_min_ergo) {\n-  TestGenCollectorPolicy::SetNewSizeErgo setter(20 * M);\n-  TestGenCollectorPolicy::CheckYoungMin checker(20 * M);\n-\n-  TestGenCollectorPolicy::TestWrapper::test(&setter, &checker);\n-}\n-#endif\n-\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+compiler\/c2\/TestMergeStores.java#id0 8331311 generic-ppc64,linux-s390x\n+compiler\/c2\/TestMergeStores.java#id1 8331311 generic-ppc64,linux-s390x\n@@ -68,0 +70,1 @@\n+compiler\/c2\/irTests\/TestIfMinMax.java 8334816 generic-all\n@@ -94,1 +97,0 @@\n-gc\/parallel\/TestAlwaysPreTouchBehavior.java 8325218 linux-all\n@@ -119,6 +121,0 @@\n-runtime\/Thread\/TestAlwaysPreTouchStacks.java 8324781 linux-all\n-\n-applications\/jcstress\/accessAtomic.java 8325984 generic-all\n-applications\/jcstress\/acqrel.java 8325984 generic-all\n-applications\/jcstress\/atomicity.java 8325984 generic-all\n-applications\/jcstress\/coherence.java 8325984 generic-all\n@@ -128,0 +124,1 @@\n+containers\/cgroup\/PlainRead.java 8333967,8261242 linux-all\n@@ -142,0 +139,1 @@\n+serviceability\/jvmti\/vthread\/CarrierThreadEventNotification\/CarrierThreadEventNotification.java 8333681 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -512,2 +512,3 @@\n-    @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n-        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    \/\/ Disabled by JDK-8335390, to be enabled again by JDK-8335392.\n+    \/\/ @IR(counts = {IRNode.STORE_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+    \/\/     applyIf = {\"UseUnalignedAccesses\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335390\n+ * @summary Test merge stores for some Unsafe store address patterns.\n+ * @modules java.base\/jdk.internal.misc\n+ * @requires vm.bits == 64\n+ * @requires os.maxMemory > 8G\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.c2.TestMergeStoresUnsafeArrayPointer::test*\n+ *                   -Xbatch\n+ *                   -Xmx8g\n+ *                   compiler.c2.TestMergeStoresUnsafeArrayPointer\n+ * @run main\/othervm -Xmx8g\n+ *                   compiler.c2.TestMergeStoresUnsafeArrayPointer\n+ *\/\n+\n+package compiler.c2;\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestMergeStoresUnsafeArrayPointer {\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ We allocate a big int array of length:\n+    static final int SIZE = (1 << 30) + 100;\n+\n+    \/\/ This gives us a memory region of 4x as many bytes:\n+    static final long BYTE_SIZE = 4L * SIZE; \/\/ = 1L << 32 + 400L\n+\n+    \/\/ We set an \"anchor\" in the middle of this memory region, in bytes:\n+    static final long ANCHOR = BYTE_SIZE \/ 2;\n+\n+    static int four = 4;\n+\n+    public static void main(String[] args) {\n+        System.out.println(\"Allocate big array of SIZE = \" + SIZE);\n+        int[] big = new int[SIZE];\n+\n+        \/\/ Each test is executed a few times, so that we can see the difference between\n+        \/\/ interpreter and compiler.\n+        int errors = 0;\n+\n+        long val = 0;\n+        System.out.println(\"test1\");\n+        for (int i = 0; i < 100_000; i++) {\n+            testClear(big);\n+            test1(big, ANCHOR);\n+            long sum = testSum(big);\n+            if (i == 0) {\n+                val = sum;\n+            } else {\n+                if (sum != val) {\n+                    System.out.println(\"ERROR: test1 had wrong value: \" + val + \" != \" + sum);\n+                    errors++;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        val = 0;\n+        System.out.println(\"test2\");\n+        for (int i = 0; i < 100_000; i++) {\n+            testClear(big);\n+            test2(big, ANCHOR);\n+            long sum = testSum(big);\n+            if (i == 0) {\n+                val = sum;\n+            } else {\n+                if (sum != val) {\n+                    System.out.println(\"ERROR: test2 had wrong value: \" + val + \" != \" + sum);\n+                    errors++;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (errors > 0) {\n+            throw new RuntimeException(\"ERRORS: \" + errors);\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+\n+    \/\/ Only clear and sum over relevant parts of array to make the test fast.\n+    static void testClear(int[] a) {\n+        for (int j = 0               ; j <              100; j++) { a[j] = j; }\n+        for (int j = a.length\/2 - 100; j < a.length\/2 + 100; j++) { a[j] = j; }\n+        for (int j = a.length   - 100; j < a.length   +   0; j++) { a[j] = j; }\n+    }\n+\n+    static long testSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0               ; j <              100; j++) { sum += a[j]; }\n+        for (int j = a.length\/2 - 100; j < a.length\/2 + 100; j++) { sum += a[j]; }\n+        for (int j = a.length   - 100; j < a.length   +   0; j++) { sum += a[j]; }\n+        return sum;\n+    }\n+\n+    \/\/ Reference: expected to merge.\n+    static void test1(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + anchor;\n+        UNSAFE.putInt(a, base + 0, 0x42424242);\n+        UNSAFE.putInt(a, base + 4, 0x66666666);\n+    }\n+\n+    \/\/ Test: if MergeStores is applied this can lead to wrong results\n+    static void test2(int[] a, long anchor) {\n+        long base = UNSAFE.ARRAY_INT_BASE_OFFSET + ANCHOR;\n+        UNSAFE.putInt(a, base + 0                 + (long)(four + Integer.MAX_VALUE), 0x42424242);\n+        UNSAFE.putInt(a, base + Integer.MAX_VALUE + (long)(four + 4                ), 0x66666666);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStoresUnsafeArrayPointer.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331194\n+ * @summary Check that Reduce Allocation Merges doesn't crash when an input\n+ *          of the Phi is not the _current_ output of the Phi but said input\n+ *          needs to be rematerialized because it's used regardless of the\n+ *          Phi output.\n+ * @run main\/othervm -XX:CompileCommand=dontinline,*TestReduceAllocationAndNestedScalarized*::test\n+ *                   -XX:CompileCommand=compileonly,*TestReduceAllocationAndNestedScalarized*::test\n+ *                   -XX:CompileCommand=compileonly,*Picture*::*init*\n+ *                   -XX:CompileCommand=compileonly,*Point*::*init*\n+ *                   -XX:CompileCommand=exclude,*Unloaded*::*\n+ *                   -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:-TieredCompilation\n+ *                   -XX:-UseCompressedOops\n+ *                   -Xcomp\n+ *                   -server\n+ *                   compiler.escapeAnalysis.TestReduceAllocationAndNestedScalarized\n+ * @run main compiler.escapeAnalysis.TestReduceAllocationAndNestedScalarized\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+public class TestReduceAllocationAndNestedScalarized {\n+    static class Picture {\n+        public Point first;\n+        public Point second;\n+    }\n+\n+    static class Point {\n+        int x;\n+    }\n+\n+    static class Unloaded {\n+    }\n+\n+    static int test(boolean cond) {\n+        Picture p = new Picture();\n+        p.first = new Point();\n+        Point p2 = p.first;\n+\n+        if (cond) p2 = new Point();\n+\n+        p.second = p2;\n+\n+        new Unloaded();\n+\n+        return p.first.x;\n+    }\n+\n+    public static void main(String[] args) {\n+        Picture pic = new Picture();\n+        Point pnt   = new Point();\n+        int res     = test(true);\n+        System.out.println(\"Result is: \" + res);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestReduceAllocationAndNestedScalarized.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334421\n+ * @summary C2 incorrectly marks not-escaped locks for elimination after\n+ *          coarsened locks were eliminated and created unbalanced regions.\n+ * @requires vm.compMode != \"Xint\"\n+ * @run main\/othervm -XX:-TieredCompilation TestCoarsenedAndNotEscapedLocksElimination\n+ * @run main TestCoarsenedAndNotEscapedLocksElimination\n+ *\/\n+\n+import java.util.Vector;\n+\n+class TestVector extends Vector<Object> {\n+\n+    TestVector() {\n+        super();\n+    }\n+\n+    TestVector(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    TestVector(int initialCapacity, int capacityIncrement) {\n+        super(initialCapacity, capacityIncrement);\n+    }\n+\n+    Object[] getElementData () {\n+        return elementData; \/\/ access protected field\n+    }\n+}\n+\n+public class TestCoarsenedAndNotEscapedLocksElimination {\n+\n+    public static void main(String[] strArr) {\n+        TestCoarsenedAndNotEscapedLocksElimination tc = new TestCoarsenedAndNotEscapedLocksElimination();\n+        String result = null;\n+        for (int i = 0; i < 12000; ++i) {\n+            result = tc.test();\n+            if (result != null) break;\n+        }\n+        System.out.println(result == null? \"passed\" : result);\n+    }\n+\n+    int [][] vector_types = {\n+       {-1, -1},\n+       {0, -1},\n+       {1, -1},\n+       {2, -1},\n+       {1025, -1},\n+       {0, -2},\n+       {1, -2},\n+       {2, -2},\n+       {1025, -2},\n+       {0, 0},\n+       {1, 0},\n+       {2, 0},\n+       {1025, 0},\n+       {0, 1},\n+       {1, 1},\n+       {2, 1},\n+       {1025, 1},\n+       {0, 1025 },\n+       {1, 1025 },\n+       {2, 1025 },\n+       {1025, 1025 }\n+    };\n+\n+    Object [] elems = {\n+        null,\n+        new Object(),\n+        new Vector(),\n+        new Object[0]\n+    };\n+\n+    int cntr = 0, mode = 0;\n+\n+    void reset() {\n+        cntr = 0;\n+        mode = 0;\n+    }\n+\n+    TestVector nextVector() {\n+        if (cntr == vector_types.length) {\n+            return null;\n+        } else {\n+            TestVector vect;\n+            if (vector_types[cntr][0] < 0) {\n+                vect = new TestVector();\n+            } else if (vector_types[cntr][1] == -2) {\n+                vect = new TestVector(vector_types[cntr][0]);\n+            } else {\n+                vect = new TestVector(vector_types[cntr][0], vector_types[cntr][1]);\n+            }\n+            if (mode == 1) {\n+                vect.addElement(null);\n+                vect.addElement(new Object());\n+                vect.addElement(new Vector());\n+                vect.addElement(new Object[0]);\n+            } else if (mode == 2) {\n+                int cap = vect.capacity();\n+                vect.addElement(null);\n+                for (int i = 0; i < cap; i++) {\n+                    vect.addElement(new Object());\n+                }\n+            }\n+            if (++mode == 3) {\n+                mode = 0;\n+                cntr++;\n+            }\n+            return vect;\n+        }\n+    }\n+\n+    public String test() {\n+        reset();\n+        TestVector vect = (TestVector)nextVector();\n+        while (vect != null) {\n+            Object [] backup_array = new Object[vect.size()];\n+            System.arraycopy(vect.getElementData(),0,backup_array,0,vect.size());\n+\n+            int old_size = vect.size();\n+            vect.setSize(vect.size());\n+            if (vect.size() != old_size) {\n+                return \"Vector: \"+vect+\" size changed after setSize(size())\";\n+            }\n+            for (int i = 0; i < vect.size(); i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size())\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            vect.setSize(vect.size()*2);\n+            if (vect.size() != old_size*2) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(size()*2)\";\n+            }\n+            for (int i = 0; i < old_size; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size()*2)\";\n+                }\n+            }\n+            for (int i = old_size; i < old_size*2; i++) {\n+                if (vect.elementAt(i) != null) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element not null after setSize(size()*2)\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            int old_cap = vect.capacity();\n+            vect.setSize(vect.capacity()+1);\n+            if (vect.size() != old_cap+1) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(capacity()+1)\";\n+            }\n+            for (int i = 0; i < old_size && i < backup_array.length; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(capacity()+1)\";\n+                }\n+            }\n+            for (int i = old_size; i < old_cap + 1; i++) {\n+                if (vect.elementAt(i) != null) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element not null after setSize(capacity()+1)\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            vect.setSize(vect.size()\/2);\n+            if (vect.size() != old_size\/2) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(size()\/2)\";\n+            }\n+            for (int i = 0; i < old_size\/2 && i < backup_array.length; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size()\/2)\";\n+                }\n+            }\n+\n+            vect = nextVector();\n+        }\n+        return null;\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestCoarsenedAndNotEscapedLocksElimination.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,327 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Xbatch\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-run-inline\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::run*,*TestPartialPeel*::test*\n+ *                   -XX:CompileCommand=inline,*TestPartialPeelAtUnsignedTestsNegativeLimit::test*\n+ *                   -XX:CompileCommand=dontinline,*TestPartialPeelAtUnsignedTestsNegativeLimit::check\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-compile-test\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8332920\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ *          Only run this test with C2 since it is time-consuming and only tests a C2 issue.\n+ * @run main compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import java.util.Random;\n+\n+import static java.lang.Integer.*;\n+\n+public class TestPartialPeelAtUnsignedTestsNegativeLimit {\n+    static int iFld = 10000;\n+    static int iterations = 0;\n+    static int iFld2;\n+    static boolean flag;\n+    final static Random RANDOM = new Random();\n+\n+    public static void main(String[] args) {\n+        compareUnsigned(3, 3); \/\/ Load Integer class for -Xcomp\n+        for (int i = 0; i < 2; i++) {\n+            if (!originalTest()) {\n+                throw new RuntimeException(\"originalTest() failed\");\n+            }\n+        }\n+\n+        for (int i = 0; i < 2000; i++) {\n+            \/\/ For profiling\n+            iFld = -1;\n+            originalTestVariation1();\n+\n+            \/\/ Actual run\n+            iFld = MAX_VALUE - 100_000;\n+            if (!originalTestVariation1()) {\n+                throw new RuntimeException(\"originalTestVariation1() failed\");\n+            }\n+        }\n+\n+        for (int i = 0; i < 2000; ++i) {\n+            \/\/ For profiling\n+            iFld = MAX_VALUE;\n+            originalTestVariation2();\n+\n+            \/\/ Actual run\n+            iFld = MIN_VALUE + 100000;\n+            if (!originalTestVariation2()) {\n+                throw new RuntimeException(\"originalTestVariation2() failed\");\n+            }\n+        }\n+\n+        runWhileLTIncr();\n+        runWhileLTDecr();\n+    }\n+\n+    \/\/ Originally reported simplified regression test with 2 variations (see below).\n+    public static boolean originalTest() {\n+        for (int i = MAX_VALUE - 50_000; compareUnsigned(i, -1) < 0; i++) {\n+            if (compareUnsigned(MIN_VALUE, i) < 0) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static boolean originalTestVariation1() {\n+        int a = 0;\n+        for (int i = iFld; compareUnsigned(i, -1) < 0; ++i) { \/\/ i <u -1\n+\n+            if (i >= Integer.MIN_VALUE + 1 && i <= 100) { \/\/ Transformed to unsigned test.\n+                return true;\n+            }\n+            a *= 23;\n+        }\n+        return false;\n+    }\n+\n+    public static boolean originalTestVariation2() {\n+        int a = 0;\n+        for (int i = iFld; compareUnsigned(i, -1000) < 0; i--) { \/\/ i <u -1\n+            if (compareUnsigned(MAX_VALUE - 20, i) > 0) {\n+                return true;\n+            }\n+            a = i;\n+        }\n+        System.out.println(a);\n+        return false;\n+    }\n+\n+\n+    public static void testWhileLTIncr(int init, int limit) {\n+        int i = init;\n+        while (true) {\n+            \/\/ <Peeled Section>\n+\n+            \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+            \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+            \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+            if (flag) {\n+            }\n+\n+            iFld2++;\n+\n+            \/\/ Loop exit test i >=u limit (i.e. \"while (i <u limit)\") to partial peel with.\n+            \/\/ insert_cmpi_loop_exit() changes this exit condition into a signed and an unsigned test:\n+            \/\/   i >= limit && i >=u limit\n+            \/\/ where the signed condition can be used as proper loop exit condition for a counted loop\n+            \/\/ (we cannot use an unsigned counted loop exit condition).\n+            \/\/\n+            \/\/ After Partial Peeling, we have:\n+            \/\/   if (i >= limit) goto Exit\n+            \/\/ Loop:\n+            \/\/   if (i >=u limit) goto Exit\n+            \/\/   ...\n+            \/\/   i++;\n+            \/\/   if (i >= limit) goto Exit\n+            \/\/   goto Loop\n+            \/\/ Exit:\n+            \/\/   ...\n+            \/\/\n+            \/\/ If init = MAX_VALUE and limit = MIN_VALUE:\n+            \/\/   i >= limit\n+            \/\/   MAX_VALUE >= MIN_VALUE\n+            \/\/ which is true where\n+            \/\/   i >=u limit\n+            \/\/   MAX_VALUE >=u MIN_VALUE\n+            \/\/   MAX_VALUE >=u (uint)(MAX_INT + 1)\n+            \/\/ is false and we wrongly never enter the loop even though we should have.\n+            \/\/ This results in a wrong execution.\n+            if (compareUnsigned(i, limit) >= 0) {\n+                return;\n+            }\n+            \/\/ <-- Partial Peeling CUT -->\n+            \/\/ Safepoint\n+            \/\/ <Unpeeled Section>\n+            iterations++;\n+            i++;\n+        }\n+    }\n+\n+    \/\/ Same as testWhileLTIncr() but with decrement instead.\n+    public static void testWhileLTDecr(int init, int limit) {\n+        int i = init;\n+        while (true) {\n+            if (flag) {\n+            }\n+\n+            \/\/ Loop exit test.\n+            if (compareUnsigned(i, limit) >= 0) { \/\/ While (i <u limit)\n+                return;\n+            }\n+\n+            iterations++;\n+            i--;\n+        }\n+    }\n+\n+    public static void runWhileLTIncr() {\n+        \/\/ Currently works:\n+        testWhileLTIncr(MAX_VALUE, -1);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTIncr(-1, 1);\n+        check(0);\n+        testWhileLTIncr(0, 0);\n+        check(0);\n+        checkIncrWithRandom(0, 0); \/\/ Sanity check this method.\n+        flag = !flag; \/\/ Change profiling\n+        testWhileLTIncr(MAX_VALUE - 2000, MAX_VALUE);\n+        check(2000);\n+        testWhileLTIncr(MAX_VALUE - 1990, MAX_VALUE);\n+        check(1990);\n+        testWhileLTIncr(MAX_VALUE - 1, MAX_VALUE);\n+        check(1);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 2000);\n+        check(2000);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 1990);\n+        check(1990);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 1);\n+        check(1);\n+\n+        flag = !flag;\n+        \/\/ Overflow currently does not work with negative limit and is fixed with patch:\n+        testWhileLTIncr(MAX_VALUE, MIN_VALUE);\n+        check(1);\n+        testWhileLTIncr(MAX_VALUE - 2000, MIN_VALUE);\n+        check(2001);\n+        testWhileLTIncr(MAX_VALUE, MIN_VALUE + 2000);\n+        check(2001);\n+        testWhileLTIncr(MAX_VALUE - 2000, MIN_VALUE + 2000);\n+        check(4001);\n+\n+        \/\/ Random values\n+        int init = RANDOM.nextInt(0, MAX_VALUE);\n+        int limit = RANDOM.nextInt(MIN_VALUE, 0);\n+        testWhileLTIncr(init, limit);\n+        checkIncrWithRandom(init, limit);\n+    }\n+\n+    public static void runWhileLTDecr() {\n+        \/\/ Currently works:\n+        testWhileLTDecr(1, -1);\n+        check(2);\n+        testWhileLTDecr(-1, 1);\n+        check(0);\n+        testWhileLTDecr(0, 0);\n+        check(0);\n+        checkDecrWithRandom(0, 0); \/\/ Sanity check this method.\n+        flag = !flag;\n+        testWhileLTDecr(MAX_VALUE, MIN_VALUE);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MAX_VALUE, -1);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MAX_VALUE, MIN_VALUE);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MIN_VALUE, 0);\n+        check(0);\n+        testWhileLTDecr(MIN_VALUE, 1);\n+        check(0);\n+        flag = !flag;\n+\n+        \/\/ Underflow currently does not work with negative limit and is fixed with patch:\n+        testWhileLTDecr(MIN_VALUE, -1);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE, -2000);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE, MIN_VALUE + 1);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, -1);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, -2000);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, MIN_VALUE + 2001);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+\n+        \/\/ Random values\n+        int r1 = RANDOM.nextInt(MIN_VALUE, 0);\n+        int r2 = RANDOM.nextInt(MIN_VALUE, 0);\n+        int init = Math.min(r1, r2);\n+        int limit = Math.max(r1, r2);\n+        testWhileLTDecr(init, limit);\n+        checkDecrWithRandom(init, limit);\n+    }\n+\n+    static void check(int expectedIterations) {\n+        if (expectedIterations != iterations) {\n+            throw new RuntimeException(\"Expected \" + expectedIterations + \" iterations but only got \" + iterations);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+\n+    static void checkIncrWithRandom(long init, long limit) {\n+        long expectedIterations = ((long)(MAX_VALUE) - init) + (limit - (long)MIN_VALUE) + 1;\n+        if ((int)expectedIterations != iterations) {\n+            String error = \"Expected %d iterations but only got %d, init: %d, limit: %d\"\n+                            .formatted(expectedIterations, iterations, init, limit);\n+            throw new RuntimeException(error);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+\n+    static void checkDecrWithRandom(long init, long limit) {\n+        long expectedIterations = init + MIN_VALUE + MAX_VALUE + 2;\n+        if (init == limit) {\n+            expectedIterations = 0;\n+        }\n+        if ((int)expectedIterations != iterations) {\n+            String error = \"Expected %d iterations but only got %d, init: %d, limit: %d\"\n+                    .formatted(expectedIterations, iterations, init, limit);\n+            throw new RuntimeException(error);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPartialPeelAtUnsignedTestsNegativeLimit.java","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMinInitialErgonomics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UseParallelGC -XX:+AlwaysPreTouch gc.parallel.TestAlwaysPreTouchBehavior\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UseParallelGC -XX:+AlwaysPreTouch -XX:+UnlockDiagnosticVMOptions -XX:-UseMadvPopulateWrite gc.parallel.TestAlwaysPreTouchBehavior\n@@ -80,1 +80,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/parallel\/TestAlwaysPreTouchBehavior.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Collections;\n@@ -92,2 +93,2 @@\n-\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            ArrayList<String> vmArgs = new ArrayList<>();\n+            Collections.addAll(vmArgs,\n@@ -97,3 +98,6 @@\n-                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\",\n-                    \"TestAlwaysPreTouchStacks\",\n-                    \"test\");\n+                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\");\n+            if (System.getProperty(\"os.name\").contains(\"Linux\")) {\n+                vmArgs.add(\"-XX:-UseMadvPopulateWrite\");\n+            }\n+            Collections.addAll(vmArgs, \"TestAlwaysPreTouchStacks\", \"test\");\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(vmArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n-    \/\/ final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n-    final static String IN_CONVAR_WAIT = \"waiting on condition\";\n+    final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n@@ -143,1 +142,1 @@\n-                    if (!line.contains(IN_CONVAR_WAIT)) {\n+                    if (!line.contains(IN_OBJECT_WAIT)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestThreadDumpClassInitMonitor.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-java\/lang\/instrument\/NativeMethodPrefixAgent.java 8307169 generic-all\n-\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -489,1 +489,0 @@\n-java\/lang\/ProcessHandle\/InfoTest.java                           8211847 aix-ppc64\n@@ -555,2 +554,0 @@\n-java\/net\/ServerSocket\/AcceptInheritHandle.java                  8211854 aix-ppc64\n-\n@@ -622,1 +619,0 @@\n-javax\/net\/ssl\/SSLSession\/CertMsgCheck.java                      8326705 generic-all\n@@ -624,1 +620,1 @@\n-sun\/security\/pkcs11\/sslecc\/ClientJSSEServerJSSE.java            8316183 linux-ppc64le\n+sun\/security\/pkcs11\/sslecc\/ClientJSSEServerJSSE.java            8316183,8333317 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -254,0 +254,2 @@\n+# Tests in this group are manual as they depend on external infra\n+# and may fail with external reasons, for instance - change in CA test portal.\n@@ -621,0 +623,1 @@\n+    :jdk_security_infra \\\n@@ -664,1 +667,1 @@\n-   -:jdk_security\n\\ No newline at end of file\n+   -:jdk_security\n","filename":"test\/jdk\/TEST.groups","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8333542\n+ * @summary Missed breakpoint due to JVM not blocking other threads while\n+ *          delivering a ClassPrepareEvent.\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g BreakpointOnClassPrepare.java\n+ * @run driver BreakpointOnClassPrepare SUSPEND_NONE\n+ * @run driver BreakpointOnClassPrepare SUSPEND_EVENT_THREAD\n+ * @run driver BreakpointOnClassPrepare SUSPEND_ALL\n+ *\/\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+\n+\/\/ The debuggee spawns 50 threads that call LoadedClass.foo(). The debugger enables\n+\/\/ ClassPrepareEvent for LoadedClass, and sets a breakpoint on LoadedClass.foo() when\n+\/\/ the ClassPrepareEvent arrives. The debugger expects 50 breakpoints to be hit.\n+\/\/ This verifies that the thread that causes the generation of the ClassPrepareEvent\n+\/\/ has properly blocked all other threads from executing LoadedClass.foo() until the\n+\/\/ ClassPrepareEvent has been delivered.\n+\n+class LoadedClass {\n+    static void foo(int k) {\n+        System.out.println(\"HIT = \" + k); \/\/ set breakpoint here\n+    }\n+}\n+\n+class BreakpointOnClassPrepareTarg {\n+    public static void main(String[] args) throws InterruptedException {\n+        System.out.println(\"Start\");\n+        Thread threads[] = new Thread[BreakpointOnClassPrepare.NUM_BREAKPOINTS];\n+        for (int i = 0; i < BreakpointOnClassPrepare.NUM_BREAKPOINTS; i++) {\n+            int k = i;\n+            Thread t = DebuggeeWrapper.newThread(() -> {\n+                System.out.println(\"k = \" + k);\n+                LoadedClass.foo(k);\n+            });\n+            threads[i] = t;\n+            t.setDaemon(true);\n+            t.setName(\"MyThread-\" + k);\n+            t.start();\n+        }\n+\n+        for (int i = 0; i < BreakpointOnClassPrepare.NUM_BREAKPOINTS; i++) {\n+            try {\n+                Thread t = threads[i];\n+                t.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        System.out.println(\"Finish\");\n+    }\n+}\n+\n+    \/********** test program **********\/\n+\n+public class BreakpointOnClassPrepare extends TestScaffold {\n+    ClassType targetClass;\n+    ThreadReference mainThread;\n+\n+    BreakpointOnClassPrepare(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new BreakpointOnClassPrepare(args).startTests();\n+    }\n+\n+    \/********** event handlers **********\/\n+\n+    static final int NUM_BREAKPOINTS = 50;\n+    int bkptCount;\n+    BreakpointRequest bkptRequest;\n+\n+    public void breakpointReached(BreakpointEvent event) {\n+        bkptCount++;\n+        String threadInfo;\n+        try {\n+            threadInfo = event.thread().toString();\n+        } catch (ObjectCollectedException e) {\n+            \/\/ It's possible the Thread already terminated and was collected\n+            \/\/ if the SUSPEND_NONE policy was used.\n+            threadInfo = \"(thread collected)\";\n+        }\n+        System.out.println(\"Got BreakpointEvent: \" + bkptCount + \" for thread \" + threadInfo);\n+    }\n+\n+    public void vmDisconnected(VMDisconnectEvent event) {\n+        println(\"Got VMDisconnectEvent\");\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        \/* Determine which suspend policy to use. *\/\n+        int policy;\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Invalid number of args: \" + args.length);\n+        }\n+        String policyString = args[0];\n+        if (policyString.equals(\"SUSPEND_NONE\")) {\n+            policy = EventRequest.SUSPEND_NONE;\n+        } else if (policyString.equals(\"SUSPEND_ALL\")) {\n+            policy = EventRequest.SUSPEND_ALL;\n+        } else if (policyString.equals(\"SUSPEND_EVENT_THREAD\")) {\n+            policy = EventRequest.SUSPEND_EVENT_THREAD;\n+        } else {\n+            throw new RuntimeException(\"Invalid suspend policy: \" + policyString);\n+        }\n+\n+        \/* Stop when the target is loaded. *\/\n+        BreakpointEvent bpe = startToMain(\"BreakpointOnClassPrepareTarg\");\n+\n+        \/* Stop when \"LoadedClass\" is loaded. *\/\n+        EventRequestManager erm = vm().eventRequestManager();\n+        ClassPrepareEvent cpe = resumeToPrepareOf(\"LoadedClass\");\n+        println(\"Got ClassPrepareEvent: \" + cpe);\n+\n+        \/* Set a breakpoint for each time LoadedClass.foo() is called. *\/\n+        ClassType loadedClass = (ClassType)cpe.referenceType() ;\n+        Location loc1 = findMethodLocation(loadedClass,  \"foo\", \"(I)V\", 1);\n+        bkptRequest = erm.createBreakpointRequest(loc1);\n+        bkptRequest.setSuspendPolicy(policy);\n+        bkptRequest.enable();\n+\n+        listenUntilVMDisconnect();\n+\n+        if (!testFailed && bkptCount == NUM_BREAKPOINTS) {\n+            println(\"BreakpointOnClassPrepare: passed\");\n+        } else {\n+            throw new Exception(\"BreakpointOnClassPrepare: failed. bkptCount == \" + bkptCount);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/BreakpointOnClassPrepare.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -78,1 +78,0 @@\n-\n@@ -225,0 +224,2 @@\n+        \/\/ Account for threads using CPU for a few millis after their WAITING state is visible:\n+        goSleep(500);\n","filename":"test\/jdk\/com\/sun\/management\/ThreadMXBean\/ThreadCpuTimeArray.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334366\n+ * @key headful printer\n+ * @summary Verifies original pageobject is returned unmodified\n+ *          on cancelling pagedialog\n+ * @requires (os.family == \"windows\")\n+ * @run main PageDialogCancelTest\n+ *\/\n+\n+import java.awt.Robot;\n+import java.awt.event.KeyEvent;\n+import java.awt.print.PageFormat;\n+import java.awt.print.PrinterJob;\n+\n+public class PageDialogCancelTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        PrinterJob pj = PrinterJob.getPrinterJob();\n+        PageFormat oldFormat = new PageFormat();\n+        Robot robot = new Robot();\n+        Thread t1 = new Thread(() -> {\n+            robot.delay(2000);\n+            robot.keyPress(KeyEvent.VK_ESCAPE);\n+            robot.keyRelease(KeyEvent.VK_ESCAPE);\n+            robot.waitForIdle();\n+        });\n+        t1.start();\n+        PageFormat newFormat = pj.pageDialog(oldFormat);\n+        if (!newFormat.equals(oldFormat)) {\n+            throw new RuntimeException(\"Original PageFormat not returned on cancelling PageDialog\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PageDialogCancelTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -386,1 +385,6 @@\n-            assertEquals(MemorySegment.ofAddress(42).reinterpret(arena, s -> counter.incrementAndGet()).scope(), arena.scope());\n+            assertEquals(MemorySegment.ofAddress(42).reinterpret(arena, _ -> counter.incrementAndGet()).scope(), arena.scope());\n+            \/\/ check read-only state\n+            assertFalse(MemorySegment.ofAddress(42).reinterpret(100).isReadOnly());\n+            assertTrue(MemorySegment.ofAddress(42).asReadOnly().reinterpret(100).isReadOnly());\n+            assertTrue(MemorySegment.ofAddress(42).asReadOnly().reinterpret(100, Arena.ofAuto(), null).isReadOnly());\n+            assertTrue(MemorySegment.ofAddress(42).asReadOnly().reinterpret(arena, _ -> counter.incrementAndGet()).isReadOnly());\n@@ -388,1 +392,1 @@\n-        assertEquals(counter.get(), 2);\n+        assertEquals(counter.get(), 3);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.lang.reflect.Method;\n@@ -37,0 +38,4 @@\n+import org.junit.jupiter.api.extension.AfterTestExecutionCallback;\n+import org.junit.jupiter.api.extension.BeforeTestExecutionCallback;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n@@ -51,0 +56,1 @@\n+@ExtendWith(IO.TimingExtension.class)\n@@ -65,0 +71,5 @@\n+            try {\n+                var outputAnalyzer = ProcessTools.executeProcess(\n+                        expect.toAbsolutePath().toString(), \"-version\");\n+                outputAnalyzer.reportDiagnosticSummary();\n+            } catch (Exception _) { }\n@@ -177,0 +188,37 @@\n+\n+\n+    \/\/ adapted from https:\/\/junit.org\/junit5\/docs\/current\/user-guide\/#extensions-lifecycle-callbacks-timing-extension\n+    \/\/ remove after CODETOOLS-7903752 propagates to jtreg that this test is routinely run by\n+\n+    public static class TimingExtension implements BeforeTestExecutionCallback,\n+            AfterTestExecutionCallback {\n+\n+        private static final System.Logger logger = System.getLogger(\n+                TimingExtension.class.getName());\n+\n+        private static final String START_TIME = \"start time\";\n+\n+        @Override\n+        public void beforeTestExecution(ExtensionContext context) {\n+            getStore(context).put(START_TIME, time());\n+        }\n+\n+        @Override\n+        public void afterTestExecution(ExtensionContext context) {\n+            Method testMethod = context.getRequiredTestMethod();\n+            long startTime = getStore(context).remove(START_TIME, long.class);\n+            long duration = time() - startTime;\n+\n+            logger.log(System.Logger.Level.INFO, () ->\n+                    String.format(\"Method [%s] took %s ms.\", testMethod.getName(), duration));\n+        }\n+\n+        private ExtensionContext.Store getStore(ExtensionContext context) {\n+            return context.getStore(ExtensionContext.Namespace.create(getClass(),\n+                    context.getRequiredTestMethod()));\n+        }\n+\n+        private long time() {\n+            return System.nanoTime() \/ 1_000_000;\n+        }\n+    }\n","filename":"test\/jdk\/java\/io\/IO\/IO.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+set timeout -1\n@@ -33,1 +34,2 @@\n-        puts \"timeout\"; exit 1\n+        puts \"timeout\"\n+        exit 1\n","filename":"test\/jdk\/java\/io\/IO\/input.exp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,3 +24,1 @@\n-################################################################################\n-# This script does not expect\/verify anything and is only used to simulate tty #\n-################################################################################\n+# This script doesn't verify any output strings, it's only used to simulate tty\n@@ -28,1 +26,4 @@\n-# Use `noecho` below, otherwise, expect will output the expanded \"spawn ...\"\n+set stty_init \"rows 24 cols 80\"\n+set timeout -1\n+\n+# Use `-noecho` below, otherwise, expect will output the expanded \"spawn ...\"\n@@ -30,0 +31,1 @@\n+# counterpart\n@@ -32,1 +34,10 @@\n-expect eof\n+\n+expect {\n+    eof {\n+        exit 0\n+    }\n+    timeout {\n+        puts \"timeout\"\n+        exit 1\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/IO\/output.exp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -54,1 +55,1 @@\n-    Object barrier;\n+    final CountDownLatch lookupLatch;\n@@ -57,1 +58,1 @@\n-    SuccessfulLookup(Class<?> cl, long suid, Object barrier) {\n+    SuccessfulLookup(Class<?> cl, long suid, CountDownLatch lookupLatch) {\n@@ -60,1 +61,1 @@\n-        this.barrier = barrier;\n+        this.lookupLatch = lookupLatch;\n@@ -64,3 +65,4 @@\n-        synchronized (barrier) {\n-            try { barrier.wait(); } catch (InterruptedException ex) {}\n-        }\n+        lookupLatch.countDown(); \/\/ let others know we are ready\n+        try {\n+            lookupLatch.await(); \/\/ await for others\n+        } catch (InterruptedException ex) {}\n@@ -78,1 +80,1 @@\n-    final Object barrier;\n+    final CountDownLatch lookupLatch;\n@@ -81,1 +83,1 @@\n-    FailingLookup(Class<?> cl, Object barrier) {\n+    FailingLookup(Class<?> cl, CountDownLatch lookupLatch) {\n@@ -83,1 +85,1 @@\n-        this.barrier = barrier;\n+        this.lookupLatch = lookupLatch;\n@@ -87,3 +89,4 @@\n-        synchronized (barrier) {\n-            try { barrier.wait(); } catch (InterruptedException ex) {}\n-        }\n+        lookupLatch.countDown(); \/\/ let others know we are ready\n+        try {\n+            lookupLatch.await(); \/\/ await for others\n+        } catch (InterruptedException ex) {}\n@@ -105,2 +108,3 @@\n-        Object barrier = new Object();\n-        SuccessfulLookup[] slookups = new SuccessfulLookup[50];\n+        int numSuccessfulLookups = 50;\n+        CountDownLatch sLookupLatch = new CountDownLatch(numSuccessfulLookups);\n+        SuccessfulLookup[] slookups = new SuccessfulLookup[numSuccessfulLookups];\n@@ -108,2 +112,1 @@\n-            slookups[i] =\n-                new SuccessfulLookup(cl, 6319710844400051132L, barrier);\n+            slookups[i] = new SuccessfulLookup(cl, 6319710844400051132L, sLookupLatch);\n@@ -112,4 +115,1 @@\n-        Thread.sleep(1000);\n-        synchronized (barrier) {\n-            barrier.notifyAll();\n-        }\n+        System.out.println(\"awaiting completion of \" + slookups.length + \" SuccessfulLookup\");\n@@ -122,1 +122,1 @@\n-\n+        System.out.println(\"all \" + slookups.length + \" SuccessfulLookup completed\");\n@@ -124,1 +124,3 @@\n-        FailingLookup[] flookups = new FailingLookup[50];\n+        int numFailingLookups = 50;\n+        CountDownLatch fLookupLatch = new CountDownLatch(numFailingLookups);\n+        FailingLookup[] flookups = new FailingLookup[numFailingLookups];\n@@ -126,1 +128,1 @@\n-            flookups[i] = new FailingLookup(cl, barrier);\n+            flookups[i] = new FailingLookup(cl, fLookupLatch);\n@@ -129,5 +131,2 @@\n-        Thread.sleep(1000);\n-        synchronized (barrier) {\n-            barrier.notifyAll();\n-        }\n-        for (int i = 0; i < slookups.length; i++) {\n+        System.out.println(\"awaiting completion of \" + flookups.length + \" FailingLookup\");\n+        for (int i = 0; i < flookups.length; i++) {\n@@ -139,0 +138,1 @@\n+        System.out.println(\"all \" + flookups.length + \" FailingLookup completed\");\n","filename":"test\/jdk\/java\/io\/Serializable\/concurrentClassDescLookup\/ConcurrentClassDescLookup.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    private static Throwable agentError;\n+    private static Throwable agentError; \/\/ to be accessed\/updated in a synchronized block\n@@ -40,1 +40,3 @@\n-    public static void checkErrors() {\n+    private static final String CLASS_TO_TRANSFORM = \"NativeMethodPrefixApp$Dummy\";\n+\n+    public static synchronized void checkErrors() {\n@@ -46,0 +48,10 @@\n+    private static synchronized void trackError(final Throwable t) {\n+        if (agentError == null) {\n+            agentError = t;\n+            return;\n+        }\n+        if (agentError != t) {\n+            agentError.addSuppressed(t);\n+        }\n+    }\n+\n@@ -51,0 +63,1 @@\n+        private final String nativeMethodPrefix;\n@@ -55,0 +68,1 @@\n+            this.nativeMethodPrefix = \"wrapped_\" + trname + \"_\";\n@@ -57,31 +71,3 @@\n-        public byte[]\n-        transform(\n-            ClassLoader loader,\n-            String className,\n-            Class<?> classBeingRedefined,\n-            ProtectionDomain    protectionDomain,\n-            byte[] classfileBuffer) {\n-            boolean redef = classBeingRedefined != null;\n-            System.out.println(trname + \": \" +\n-                               (redef? \"Retransforming \" : \"Loading \") + className);\n-            if (className != null) {\n-                try {\n-                    byte[] newcf = Instrumentor.instrFor(classfileBuffer)\n-                                   .addNativeMethodTrackingInjection(\n-                                        \"wrapped_\" + trname + \"_\", (name, h) -> {\n-                                            h.loadConstant(name);\n-                                            h.loadConstant(transformId);\n-                                            h.invokestatic(\n-                                                    CD_StringIdCallbackReporter,\n-                                                    \"tracker\",\n-                                                    MTD_void_String_int);\n-                                        })\n-                                   .apply();\n-                    \/*** debugging ...\n-                    if (newcf != null) {\n-                        String fname = trname + (redef?\"_redef\" : \"\") + \"\/\" + className;\n-                        System.err.println(\"dumping to: \" + fname);\n-                        write_buffer(fname + \"_before.class\", classfileBuffer);\n-                        write_buffer(fname + \"_instr.class\", newcf);\n-                    }\n-                    ***\/\n+        @Override\n+        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n+                                ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n@@ -89,7 +75,6 @@\n-                    return redef? null : newcf;\n-                } catch (Throwable ex) {\n-                    if (agentError == null) {\n-                        agentError = ex;\n-                    }\n-                    System.err.println(\"ERROR: Injection failure: \" + ex);\n-                    ex.printStackTrace();\n+            try {\n+                \/\/ we only transform a specific application class\n+                if (!className.equals(CLASS_TO_TRANSFORM)) {\n+                    return null;\n+                }\n+                if (classBeingRedefined != null) {\n@@ -98,0 +83,16 @@\n+                \/\/ use a byte code generator which creates wrapper methods,\n+                \/\/ with a configured native method prefix, for each native method on the\n+                \/\/ class being transformed\n+                final Instrumentor byteCodeGenerator = Instrumentor.instrFor(classfileBuffer)\n+                        .addNativeMethodTrackingInjection(nativeMethodPrefix,\n+                                (name, cb) -> {\n+                                    cb.loadConstant(name);\n+                                    cb.loadConstant(transformId);\n+                                    cb.invokestatic(CD_StringIdCallbackReporter,\n+                                            \"tracker\", MTD_void_String_int);\n+                                });\n+                \/\/ generate the bytecode\n+                return byteCodeGenerator.apply();\n+            } catch (Throwable t) {\n+                trackError(t);\n+                return null;\n@@ -99,1 +100,0 @@\n-            return null;\n@@ -101,1 +101,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixAgent.java","additions":41,"deletions":42,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.File;\n@@ -27,1 +26,0 @@\n-import java.lang.management.*;\n@@ -36,1 +34,1 @@\n- * @bug 6263319\n+ * @bug 6263319 8334167\n@@ -39,2 +37,1 @@\n- * @modules java.management\n- *          java.instrument\n+ * @modules java.instrument\n@@ -46,2 +43,1 @@\n- * @run driver\/timeout=240 NativeMethodPrefixApp roleDriver\n- * @comment The test uses a higher timeout to prevent test timeouts noted in JDK-6528548\n+ * @run main\/native NativeMethodPrefixApp roleDriver\n@@ -51,5 +47,3 @@\n-    \/\/ This test is fragile like a golden file test.\n-    \/\/ It assumes that a specific non-native library method will call a specific\n-    \/\/ native method.  The below may need to be updated based on library changes.\n-    static String goldenNativeMethodName = \"getStartupTime\";\n-\n+    \/\/ we expect this native method, which is part of this test's application,\n+    \/\/ to be instrumented and invoked\n+    static String goldenNativeMethodName = \"fooBarNativeMethod\";\n@@ -57,0 +51,1 @@\n+    private static final String testLibraryPath = System.getProperty(\"test.nativepath\");\n@@ -71,0 +66,1 @@\n+            System.loadLibrary(\"NativeMethodPrefix\"); \/\/ load the native library\n@@ -76,1 +72,0 @@\n-        final String testClassesDir = System.getProperty(\"test.classes\");\n@@ -83,3 +78,1 @@\n-                \"\"\"\n-                + \"Boot-Class-Path: \" + testClassesDir.replace(File.separatorChar, '\/') + \"\/\"\n-                + \"\\n\";\n+                \"\"\";\n@@ -99,0 +92,1 @@\n+                \"-Djava.library.path=\" + testLibraryPath,\n@@ -108,4 +102,5 @@\n-\n-        java.lang.reflect.Array.getLength(new short[5]);\n-        RuntimeMXBean mxbean = ManagementFactory.getRuntimeMXBean();\n-        System.err.println(mxbean.getVmVendor());\n+        final long val = new Dummy().callSomeNativeMethod();\n+        if (val != 42) {\n+            throw new RuntimeException(\"unexpected return value \" + val\n+                    + \" from native method, expected 42\");\n+        }\n@@ -131,0 +126,9 @@\n+\n+    private static class Dummy {\n+\n+        private long callSomeNativeMethod() {\n+            return fooBarNativeMethod();\n+        }\n+\n+        private native long fooBarNativeMethod();\n+    }\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixApp.java","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jni.h\"\n+\n+JNIEXPORT jlong JNICALL\n+Java_NativeMethodPrefixApp_00024Dummy_fooBarNativeMethod(JNIEnv *env, jclass clazz)\n+{\n+    fprintf(stderr, \"native method called\\n\");\n+    return 42;\n+}\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved)\n+{\n+    fprintf(stderr, \"native library loaded\\n\");\n+    return JNI_VERSION_1_1; \/\/ this native library needs the very basic JNI support\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/libNativeMethodPrefix.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of ClassLoadingMXBean.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info:file=vm.log TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseClassLoading false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ClassLoadingMXBean;\n+\n+public class TestVerboseClassLoading {\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassLoadingMXBean mxBean = ManagementFactory.getClassLoadingMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/ClassLoadingMXBean\/TestVerboseClassLoading.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of TestVerboseMemory.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:gc=trace:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=debug:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=info:file=vm.log TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=off TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=error TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=warning TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=trace TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=debug TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc*=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=debug TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=trace TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc=info,gc+init=off TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=off,gc+init=info TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc,gc+init TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseMemory false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+public class TestVerboseMemory {\n+\n+    public static void main(String[] args) throws Exception {\n+        MemoryMXBean mxBean = ManagementFactory.getMemoryMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/TestVerboseMemory.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333854\n+ * @summary Test invoking a method in a proxy interface with package-private\n+ *          classes or interfaces in its method type\n+ * @run junit NonPublicMethodTypeTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.reflect.Proxy;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+\n+public final class NonPublicMethodTypeTest {\n+    interface NonPublicWorker {\n+        void work();\n+    }\n+\n+    public interface PublicWorkable {\n+        void accept(NonPublicWorker worker);\n+    }\n+\n+    @Test\n+    public void test() {\n+        PublicWorkable proxy = (PublicWorkable) Proxy.newProxyInstance(\n+               NonPublicMethodTypeTest.class.getClassLoader(),\n+               new Class[] {PublicWorkable.class},\n+               (_, _, _) -> null);\n+        assertNotSame(NonPublicWorker.class.getPackage(),\n+                proxy.getClass().getPackage(),\n+                \"Proxy class should not be able to access method parameter \" +\n+                        \"NonPublic type's package\");\n+        proxy.accept(() -> {}); \/\/ Call should not fail\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/NonPublicMethodTypeTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+        \/\/ retains only network interface whose bound addresses match\n@@ -67,2 +68,17 @@\n-                                      .map(nif -> new Object[] { new InetSocketAddress(a, 0), nif })\n-                                      .forEach(list::add) );\n+                .filter(nif -> nif.inetAddresses().toList().contains(a))\n+                .map(nif -> new Object[] { new InetSocketAddress(a, 0), nif })\n+                .forEach(list::add) );\n+        \/\/ any network interface should work with the wildcard address\n+        nc.multicastInterfaces(true)\n+                .map(nif -> new Object[] {new InetSocketAddress(0), nif})\n+                .forEach(list::add);\n+        return list.stream().toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"interfaces\")\n+    public Object[][] interfaces() throws Exception {\n+        List<Object[]> list = new ArrayList<>();\n+        NetworkConfiguration nc = NetworkConfiguration.probe();\n+        nc.multicastInterfaces(true)\n+                .map(nif -> new Object[] {nif})\n+                .forEach(list::add);\n@@ -85,2 +101,2 @@\n-    @Test(dataProvider = \"scenarios\")\n-    public void testSetGetInterfaceUnbound(InetSocketAddress ignore, NetworkInterface nif)\n+    @Test(dataProvider = \"interfaces\")\n+    public void testSetGetInterfaceUnbound(NetworkInterface nif)\n@@ -109,2 +125,2 @@\n-    @Test(dataProvider = \"scenarios\")\n-    public void testSetGetOptionUnbound(InetSocketAddress ignore, NetworkInterface nif)\n+    @Test(dataProvider = \"interfaces\")\n+    public void testSetGetOptionUnbound(NetworkInterface nif)\n@@ -142,2 +158,2 @@\n-    public void testGettInterfaceUnbound() throws Exception {\n-        out.println(\"\\n\\n--- testGettInterfaceUnbound \");\n+    public void testGetInterfaceUnbound() throws Exception {\n+        out.println(\"\\n\\n--- testGetInterfaceUnbound \");\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/IPMulticastIF.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(1500);\n","filename":"test\/jdk\/java\/net\/httpclient\/ForbiddenHeadTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+            InetAddress loopback = InetAddress.getLoopbackAddress();\n@@ -90,1 +91,1 @@\n-            serv.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            serv.bind(new InetSocketAddress(loopback, 0));\n@@ -97,1 +98,1 @@\n-            clientSock = new Socket(\"localhost\", serverPort);\n+            clientSock = new Socket(loopback, serverPort);\n@@ -110,0 +111,1 @@\n+            System.out.println(\"Starting: server listening at: \" + serverSock.getLocalSocketAddress());\n@@ -147,0 +149,1 @@\n+                System.out.println(\"clientReader got exception: \" + e);\n@@ -179,0 +182,1 @@\n+                System.out.println(\"clientWriter got exception: \" + e);\n@@ -215,0 +219,1 @@\n+                        System.out.println(\"serverLoopback exiting normally\");\n@@ -222,0 +227,1 @@\n+                System.out.println(\"serverLoopback got exception: \" + e);\n@@ -223,0 +229,2 @@\n+            } finally {\n+                System.out.println(\"serverLoopback exiting at count: \" + loopCount.get());\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/SSLTubeTest.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -39,0 +40,1 @@\n+import java.nio.MappedByteBuffer;\n@@ -40,0 +42,3 @@\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -42,0 +47,1 @@\n+import java.util.Set;\n@@ -46,0 +52,3 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.nio.file.StandardOpenOption.*;\n+\n@@ -716,0 +725,13 @@\n+\n+    @Test\n+    void testHashCode() throws IOException {\n+        byte[] bytes = \"hello world\".getBytes(UTF_8);\n+        Path path = Files.createTempFile(\"\", \"\");\n+        Files.write(path, bytes);\n+        try (FileChannel fc = FileChannel.open(path, READ, DELETE_ON_CLOSE)) {\n+            MappedByteBuffer one = fc.map(FileChannel.MapMode.READ_ONLY, 0, bytes.length);\n+            ByteBuffer two = ByteBuffer.wrap(bytes);\n+            Assert.assertEquals(one, two);\n+            Assert.assertEquals(one.hashCode(), two.hashCode());\n+        }\n+    }\n","filename":"test\/jdk\/java\/nio\/Buffer\/EqualsCompareTest.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,2 @@\n-            ByteBuffer src = ByteBuffer.wrap(\"hello\".getBytes(\"UTF-8\"));\n+            String str = \"hello \" + System.nanoTime();\n+            ByteBuffer src = ByteBuffer.wrap(str.getBytes(\"UTF-8\"));\n@@ -145,0 +146,1 @@\n+            src.flip();\n@@ -160,0 +162,5 @@\n+                        if (src.mismatch(dst) != -1) {\n+                            System.out.println(\"src: \" + src + \"not equal to dst: \" + dst);\n+                            dst.clear();\n+                            continue;\n+                        }\n@@ -163,1 +170,2 @@\n-                            assertTrue(senderPort != localPort, \"Unexpected message\");\n+                            assertTrue(senderPort != localPort,\n+                                    \"Unexpected message: localPort=\" + localPort);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Loopback.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.Pipe;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8334719\n+ * @summary verifies that if a registered channel has in-progress operations, then\n+ *          the Selector during its deferred close implementation won't prematurely release\n+ *          the channel's resources\n+ *\n+ * @comment we use a patched java.net.InetSocketAddress to allow the test to intentionally\n+ *          craft some delays at specific locations in the implementation of InetSocketAddress\n+ *          to trigger race conditions\n+ * @compile\/module=java.base java\/net\/InetSocketAddress.java\n+ * @run junit\/othervm DeferredCloseTest\n+ *\/\n+public class DeferredCloseTest {\n+\n+    private static final int NUM_ITERATIONS = 10;\n+    private static final InetSocketAddress BIND_ADDR = new InetSocketAddress(\n+            InetAddress.getLoopbackAddress(), 0);\n+\n+    @BeforeAll\n+    public static void beforeAll() throws Exception {\n+        \/\/ configure our patched java.net.InetSocketAddress implementation\n+        \/\/ to introduce delay in certain methods which get invoked\n+        \/\/ internally from the DC.send() implementation\n+        InetSocketAddress.enableDelay();\n+    }\n+\n+    @AfterAll\n+    public static void afterAll() throws Exception {\n+        \/\/ delays in patched InetSocketAddress are no longer needed\n+        InetSocketAddress.disableDelay();\n+    }\n+\n+    private static Stream<Arguments> dcOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.send() till there's a ClosedChannelException\n+                        \"DC.send()\",\n+                        null,\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                \/\/ We send to ourselves. Target, content and\n+                                \/\/ receipt of the Datagram isn't of importance\n+                                \/\/ in this test.\n+                                SocketAddress target = dc.getLocalAddress();\n+                                System.out.println(\"DC: \" + dc + \" sending to \" + target);\n+                                while (true) {\n+                                    bb.clear();\n+                                    dc.send(bb, target);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do DC.receive() till there's a ClosedChannelException\n+                        \"DC.receive()\",\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                SocketAddress target = dc.getLocalAddress();\n+                                ByteBuffer sendBB = ByteBuffer.allocate(100);\n+                                \/\/ first send() a few datagrams so that subsequent\n+                                \/\/ receive() does receive them and thus triggers\n+                                \/\/ the potential race with the deferred close\n+                                for (int i = 0; i < 5; i++) {\n+                                    sendBB.clear();\n+                                    dc.send(sendBB, target);\n+                                }\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        },\n+                        (Function<DatagramChannel, Void>) (dc) -> {\n+                            try {\n+                                ByteBuffer rcvBB = ByteBuffer.allocate(10);\n+                                while (true) {\n+                                    rcvBB.clear();\n+                                    dc.receive(rcvBB);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (Exception e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for DatagramChannel.\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"dcOperations\")\n+    public void testDatagramChannel(String opName, Function<DatagramChannel, Void> preOp,\n+                                    Function<DatagramChannel, Void> dcOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s DatagramChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     DatagramChannel dc = DatagramChannel.open()) {\n+                    \/\/ create a non-blocking bound DatagramChannel\n+                    dc.bind(BIND_ADDR);\n+                    dc.configureBlocking(false);\n+                    \/\/ register the DatagramChannel with a selector\n+                    \/\/ (doesn't matter the interestOps)\n+                    SelectionKey key = dc.register(sel, SelectionKey.OP_READ);\n+                    if (preOp != null) {\n+                        preOp.apply(dc);\n+                    }\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start operation on the DC\n+                        opStartLatch.countDown();\n+                        return dcOperation.apply(dc);\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    private static Stream<Arguments> scOperations() {\n+        return Stream.of(\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        \"SC.write()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" writing\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.write(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                ),\n+                Arguments.of(\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        \"SC.read()\", (Function<SocketChannel, Void>) (sc) -> {\n+                            ByteBuffer bb = ByteBuffer.allocate(100);\n+                            try {\n+                                System.out.println(\"SC: \" + sc + \" reading\");\n+                                while (true) {\n+                                    bb.clear();\n+                                    sc.read(bb);\n+                                }\n+                            } catch (ClosedChannelException _) {\n+                            } catch (IOException ioe) {\n+                                throw new UncheckedIOException(ioe);\n+                            }\n+                            return null;\n+                        }\n+                )\n+        );\n+    }\n+\n+    \/**\n+     * Runs the test for SocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"scOperations\")\n+    public void testSocketChannel(String opName, Function<SocketChannel, Void> scOperation)\n+            throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(3)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     SocketChannel sc = SocketChannel.open()) {\n+                    \/\/ create and bind a SocketChannel\n+                    sc.bind(BIND_ADDR);\n+                    \/\/ stay in blocking mode till the SocketChannel is connected\n+                    sc.configureBlocking(true);\n+                    Future<SocketChannel> acceptedChannel;\n+                    SocketChannel conn;\n+                    \/\/ create a remote server and connect to it\n+                    try (ServerSocketChannel server = ServerSocketChannel.open()) {\n+                        server.bind(BIND_ADDR);\n+                        SocketAddress remoteAddr = server.getLocalAddress();\n+                        acceptedChannel = executor.submit(new ConnAcceptor(server));\n+                        System.out.println(\"connecting to \" + remoteAddr);\n+                        sc.connect(remoteAddr);\n+                        conn = acceptedChannel.get();\n+                    }\n+                    try (conn) {\n+                        \/\/ switch to non-blocking\n+                        sc.configureBlocking(false);\n+                        System.out.println(\"switched to non-blocking: \" + sc);\n+                        \/\/ register the SocketChannel with a selector\n+                        \/\/ (doesn't matter the interestOps)\n+                        SelectionKey key = sc.register(sel, SelectionKey.OP_READ);\n+                        CountDownLatch opStartLatch = new CountDownLatch(1);\n+                        runTest(executor, key, () -> {\n+                            \/\/ notify that we will now start operation on the SC\n+                            opStartLatch.countDown();\n+                            return scOperation.apply(sc);\n+                        }, opStartLatch);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for ServerSocketChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testServerSocketChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s ServerSocketChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                try (Selector sel = Selector.open();\n+                     ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+                    \/\/ create and bind a ServerSocketChannel\n+                    ssc.bind(BIND_ADDR);\n+                    ssc.configureBlocking(false);\n+                    \/\/ register the ServerSocketChannel with a selector\n+                    SelectionKey key = ssc.register(sel, SelectionKey.OP_ACCEPT);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start accept()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SSC.accept() till there's a ClosedChannelException\n+                        try {\n+                            while (true) {\n+                                ssc.accept();\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SinkChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSinkChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SinkChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SinkChannel sink = pipe.sink()) {\n+                    sink.configureBlocking(false);\n+                    SelectionKey key = sink.register(sel, SelectionKey.OP_WRITE);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start write()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.write() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                sink.write(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Runs the test for SourceChannel\n+     *\n+     * @see #runTest(ExecutorService, SelectionKey, Callable, CountDownLatch)\n+     *\/\n+    @Test\n+    public void testSourceChannel() throws Exception {\n+        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {\n+            for (int i = 1; i <= NUM_ITERATIONS; i++) {\n+                System.out.format(\"%s SourceChannel - %d of %d ...%n\",\n+                        Instant.now(), i, NUM_ITERATIONS);\n+                Pipe pipe = Pipe.open();\n+                try (Selector sel = Selector.open();\n+                     Pipe.SourceChannel source = pipe.source()) {\n+                    source.configureBlocking(false);\n+                    SelectionKey key = source.register(sel, SelectionKey.OP_READ);\n+                    CountDownLatch opStartLatch = new CountDownLatch(1);\n+                    runTest(executor, key, () -> {\n+                        \/\/ notify that we will now start read()ing\n+                        opStartLatch.countDown();\n+                        \/\/ repeatedly do SC.read() till there's a ClosedChannelException\n+                        ByteBuffer bb = ByteBuffer.allocate(100);\n+                        try {\n+                            while (true) {\n+                                bb.clear();\n+                                source.read(bb);\n+                            }\n+                        } catch (ClosedChannelException _) {\n+                        }\n+                        return null;\n+                    }, opStartLatch);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * SelectableChannel implementations internally have a deferred close implementation. When a\n+     * channel is registered with a Selector and close() is invoked on the channel from a certain\n+     * thread, then the implementation of close() defers the actual close if the channel has\n+     * in-progress operations (for example, read\/write\/send\/receive and such) in some other thread.\n+     * A subsequent operation through the Selector (like Selector.select()) then completes the\n+     * deferred close (waiting for any in-progress operations to complete). This test method\n+     * verifies that the deferred close implementation doesn't prematurely close and release\n+     * the resources used by the channel, while there are in-progress operations.\n+     * <p>\n+     * Launches 2 threads, T1 and T2. When T1 and T2 are in progress, this method closes the\n+     * channel that is registered with the Selector.\n+     * T1 is running the channelOperation (which keeps running operations on the channel).\n+     * T2 is running a task which keeps invoking Selector.select(), until the channel is closed.\n+     * When T2 notices that the channel is closed, it cancels the selectionKey and then\n+     * invokes one last Selector.select() operation to finish the deferred close of the channel.\n+     *\/\n+    private static void runTest(ExecutorService executor, SelectionKey selectionKey,\n+                                Callable<Void> channelOperation, CountDownLatch chanOpStartLatch)\n+            throws Exception {\n+\n+        SelectableChannel channel = selectionKey.channel();\n+        assertFalse(channel.isBlocking(), \"channel isn't non-blocking: \" + channel);\n+        selectionKey.selector().selectNow();\n+        \/\/ run the channel operations\n+        Future<?> channelOpResult = executor.submit(channelOperation);\n+        CountDownLatch selectorTaskStartLatch = new CountDownLatch(1);\n+        \/\/ run the Selector.select() task\n+        Future<?> selectorTaskResult = executor.submit(\n+                new SelectorTask(selectionKey, selectorTaskStartLatch));\n+        \/\/ await for the channel operation task and the selector task to start\n+        chanOpStartLatch.await();\n+        selectorTaskStartLatch.await();\n+        \/\/ close the channel while it's still registered with the Selector,\n+        \/\/ so that the close is deferred by the channel implementations.\n+        System.out.println(\"closing channel: \" + channel);\n+        assertTrue(channel.isOpen(), \"channel already closed: \" + channel);\n+        assertTrue(channel.isRegistered(), \"channel isn't registered: \" + channel);\n+        channel.close();\n+        \/\/ wait for the operation on the channel and the selector task to complete\n+        channelOpResult.get();\n+        selectorTaskResult.get();\n+    }\n+\n+    \/*\n+     * Keeps invoking Selector.select() until the channel is closed, after which\n+     * it cancels the SelectionKey and does one last Selector.select() to finish\n+     * the deferred close.\n+     *\/\n+    private static final class SelectorTask implements Callable<Void> {\n+        private final SelectionKey selectionKey;\n+        private final CountDownLatch startedLatch;\n+\n+        private SelectorTask(SelectionKey selectionKey, CountDownLatch startedLatch) {\n+            this.selectionKey = Objects.requireNonNull(selectionKey);\n+            this.startedLatch = startedLatch;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            try {\n+                Selector selector = selectionKey.selector();\n+                SelectableChannel channel = selectionKey.channel();\n+                \/\/ notify that the task has started\n+                startedLatch.countDown();\n+                while (true) {\n+                    selector.select(10);\n+                    if (!channel.isOpen()) {\n+                        \/\/ the channel is (defer) closed, cancel the registration and then\n+                        \/\/ issue a select() so that the Selector finishes the deferred\n+                        \/\/ close of the channel.\n+                        System.out.println(\"channel: \" + channel + \" isn't open,\" +\n+                                \" now cancelling key: \" + selectionKey);\n+                        selectionKey.cancel();\n+                        System.out.println(\"initiating select after key cancelled: \" + selectionKey);\n+                        selector.select(5);\n+                        break;\n+                    }\n+                }\n+            } catch (ClosedSelectorException _) {\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class ConnAcceptor implements Callable<SocketChannel> {\n+        private final ServerSocketChannel serverSocketChannel;\n+\n+        private ConnAcceptor(ServerSocketChannel serverSocketChannel) {\n+            this.serverSocketChannel = serverSocketChannel;\n+        }\n+\n+        @Override\n+        public SocketChannel call() throws Exception {\n+            SocketChannel accepted = serverSocketChannel.accept();\n+            System.out.println(\"Accepted connection: \" + accepted);\n+            return accepted;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/DeferredCloseTest.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.net;\n+\n+\n+import java.util.Locale;\n+\n+\/\/ Patched implementation only meant to be used in certain tests\n+public class InetSocketAddress extends SocketAddress {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 5076001401234631237L;\n+\n+    private static boolean enableDelay;\n+\n+    static {\n+        System.out.println(\"patched InetSocketAddress class in use\");\n+    }\n+\n+    private final String hostname;\n+    private final InetAddress addr;\n+    private final int port;\n+\n+    public InetSocketAddress(int port) {\n+        this(InetAddress.anyLocalAddress(), port);\n+    }\n+\n+    public InetSocketAddress(InetAddress addr, int port) {\n+        this(null,\n+                addr == null ? InetAddress.anyLocalAddress() : addr,\n+                checkPort(port));\n+    }\n+\n+    public InetSocketAddress(String hostname, int port) {\n+        checkHost(hostname);\n+        InetAddress addr = null;\n+        String host = null;\n+        try {\n+            addr = InetAddress.getByName(hostname);\n+        } catch (UnknownHostException e) {\n+            host = hostname;\n+        }\n+        this.hostname = host;\n+        this.addr = addr;\n+        this.port = checkPort(port);\n+    }\n+\n+    public static InetSocketAddress createUnresolved(String host, int port) {\n+        return new InetSocketAddress(checkHost(host), null, checkPort(port));\n+    }\n+\n+    public static void enableDelay() {\n+        enableDelay = true;\n+    }\n+\n+    public static void disableDelay() {\n+        enableDelay = false;\n+    }\n+\n+    private InetSocketAddress(String hostname, InetAddress addr, int port) {\n+        this.hostname = hostname;\n+        this.addr = addr;\n+        this.port = port;\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+    }\n+\n+    \/**\n+     * Gets the port number.\n+     *\n+     * @return the port number.\n+     *\/\n+    public final int getPort() {\n+        if (enableDelay) {\n+            doDelay();\n+        }\n+        return this.port;\n+    }\n+\n+    \/**\n+     * Gets the {@code InetAddress}.\n+     *\n+     * @return the InetAddress or {@code null} if it is unresolved.\n+     *\/\n+    public final InetAddress getAddress() {\n+        return this.addr;\n+    }\n+\n+    public final String getHostName() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            return addr.getHostName();\n+        }\n+        return null;\n+    }\n+\n+    public final String getHostString() {\n+        if (hostname != null) {\n+            return hostname;\n+        }\n+        if (addr != null) {\n+            if (addr.holder().getHostName() != null) {\n+                return addr.holder().getHostName();\n+            } else {\n+                return addr.getHostAddress();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public final boolean isUnresolved() {\n+        return addr == null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String formatted;\n+        if (isUnresolved()) {\n+            formatted = hostname + \"\/<unresolved>\";\n+        } else {\n+            formatted = addr.toString();\n+            if (addr instanceof Inet6Address) {\n+                int i = formatted.lastIndexOf(\"\/\");\n+                formatted = formatted.substring(0, i + 1)\n+                        + \"[\" + formatted.substring(i + 1) + \"]\";\n+            }\n+        }\n+        return formatted + \":\" + port;\n+    }\n+\n+    @Override\n+    public final boolean equals(Object other) {\n+        if (!(other instanceof InetSocketAddress that)) {\n+            return false;\n+        }\n+        boolean sameIP;\n+        if (addr != null) {\n+            sameIP = addr.equals(that.addr);\n+        } else if (hostname != null) {\n+            sameIP = (that.addr == null) &&\n+                    hostname.equalsIgnoreCase(that.hostname);\n+        } else {\n+            sameIP = (that.addr == null) && (that.hostname == null);\n+        }\n+        return sameIP && (port == that.port);\n+    }\n+\n+    @Override\n+    public final int hashCode() {\n+        if (addr != null) {\n+            return addr.hashCode() + port;\n+        }\n+        if (hostname != null) {\n+            return hostname.toLowerCase(Locale.ROOT).hashCode() + port;\n+        }\n+        return port;\n+    }\n+\n+    private static int checkPort(int port) {\n+        if (port < 0 || port > 0xFFFF)\n+            throw new IllegalArgumentException(\"port out of range:\" + port);\n+        return port;\n+    }\n+\n+    private static String checkHost(String hostname) {\n+        if (hostname == null)\n+            throw new IllegalArgumentException(\"hostname can't be null\");\n+        return hostname;\n+    }\n+\n+    private static void doDelay() {\n+        System.out.println(\"intentional delay injected in InetSocketAddress\");\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/DeferredClose\/java.base\/java\/net\/InetSocketAddress.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires vm.flagless\n@@ -29,1 +30,1 @@\n- * @run main\/othervm -Djava.security.manager=allow OpenLeak\n+ * @run junit\/othervm OpenLeak\n@@ -32,0 +33,2 @@\n+import java.io.IOException;\n+import java.net.ConnectException;\n@@ -34,0 +37,1 @@\n+import java.net.SocketAddress;\n@@ -35,0 +39,10 @@\n+import java.nio.channels.UnresolvedAddressException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n@@ -38,3 +52,9 @@\n-    public static void main(String[] args) throws Exception {\n-        InetAddress lh = InetAddress.getLocalHost();\n-        InetSocketAddress isa = new InetSocketAddress(lh, 12345);\n+    static final String OS_NAME = System.getProperty(\"os.name\").toLowerCase(Locale.ROOT);\n+    static final boolean IS_WINDOWS_2016 = OS_NAME.contains(\"windows\") && OS_NAME.contains(\"2016\");\n+\n+    \/\/ On Windows Server 2016 trying to connect to port 47 consumes the\n+    \/\/ whole connect timeout - which makes the test fail in timeout.\n+    \/\/ We skip this part of the test on Windows Server 2016\n+    static final boolean TEST_WITH_RESERVED_PORT = !IS_WINDOWS_2016;\n+\n+    private static final int MAX_LOOP = 250000;\n@@ -42,6 +62,22 @@\n-        System.setSecurityManager( new SecurityManager() );\n-        for (int i=0; i<100000; i++) {\n-            try {\n-                SocketChannel.open(isa);\n-                throw new RuntimeException(\"This should not happen\");\n-            } catch (SecurityException x) { }\n+\n+    \/\/ Try to find a suitable port to provoke a \"Connection Refused\"\n+    \/\/ error.\n+    private static InetSocketAddress findSuitableRefusedAddress(InetSocketAddress isa)\n+            throws IOException {\n+        if (!TEST_WITH_RESERVED_PORT) return null;\n+        var addr = isa.getAddress();\n+        try (SocketChannel sc1 = SocketChannel.open(isa)) {\n+            \/\/ If we manage to connect, let's try to use some other\n+            \/\/ port.\n+            \/\/ port 51 is reserved too - there should be nothing there...\n+            isa = new InetSocketAddress(addr, 51);\n+            try (SocketChannel sc2 = SocketChannel.open(isa)) {\n+            }\n+            \/\/ OK, last attempt...\n+            \/\/ port 61 is reserved too - there should be nothing there...\n+            isa = new InetSocketAddress(addr, 61);\n+            try (SocketChannel sc3 = SocketChannel.open(isa)) {\n+            }\n+            System.err.println(\"Could not find a suitable port\");\n+            return null;\n+        } catch (ConnectException x) {\n@@ -49,0 +85,7 @@\n+        return isa;\n+    }\n+\n+    private static InetSocketAddress createUnresolved(InetSocketAddress isa, InetSocketAddress def) {\n+       var sa = isa == null ? def : isa;\n+       return InetSocketAddress.createUnresolved(sa.getHostString(), sa.getPort());\n+    }\n@@ -50,0 +93,39 @@\n+\n+    \/\/ Builds a list of test cases\n+    static List<Object[]> testCases() throws Exception {\n+        InetAddress lo = InetAddress.getLoopbackAddress();\n+\n+        \/\/ Try to find a suitable port that will cause a\n+        \/\/ Connection Refused exception\n+        \/\/ port 47 is reserved - there should be nothing there...\n+        InetSocketAddress def = new InetSocketAddress(lo, 47);\n+        InetSocketAddress isa = findSuitableRefusedAddress(def);\n+        InetSocketAddress sa  = createUnresolved(isa, def);\n+\n+        final List<Object[]> cases = new ArrayList<>();\n+        cases.add(new Object[]{sa, UnresolvedAddressException.class});\n+        if (isa != null) {\n+            cases.add(new Object[]{isa, ConnectException.class});\n+        }\n+        return cases;\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    public void test(SocketAddress sa, Class<? extends Throwable> expectedException) throws Exception {\n+        System.err.printf(\"%nExpecting %s for %s%n\", expectedException, sa);\n+\n+        int i = 0;\n+        try {\n+            for (i = 0; i < MAX_LOOP; i++) {\n+                Throwable x =\n+                        assertThrows(expectedException, () -> SocketChannel.open(sa));\n+                if (i < 5 || i >= MAX_LOOP - 5) {\n+                    \/\/ print a message for the first five and last 5 exceptions\n+                    System.err.println(x);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            System.err.println(\"Failed at \" + i + \" with \" + t);\n+            throw t;\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/OpenLeak.java","additions":93,"deletions":11,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -0,0 +1,494 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333849\n+ * @summary Test ByteChannel implementations of read and write with ByteBuffers that are\n+ *    backed by MemorySegments allocated from an Arena\n+ * @run junit MemorySegments\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Random;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import static java.nio.file.StandardOpenOption.*;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MemorySegments {\n+    private static final int SIZE = 100;   \/\/ buffer size used by tests\n+\n+    \/**\n+     * Return a stream of suppliers for each Arena type. A supplier is used to avoid JUnit\n+     * closing the Arena and failing (as some Arenas are not closable).\n+     *\/\n+    static Stream<Supplier<Arena>> arenaSuppliers() {\n+        return Stream.of(Arena::global, Arena::ofAuto, Arena::ofConfined, Arena::ofShared);\n+    }\n+\n+    \/**\n+     * SocketChannel read\/write(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testSocketChannelReadWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            try (SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n+                 SocketChannel sc2 = ssc.accept()) {\n+\n+                \/\/ write\n+                ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                fillRandom(src);\n+                int nwritten = sc1.write(src);\n+                assertTrue(nwritten > 0);\n+                assertTrue(nwritten <= SIZE);\n+                assertEquals(nwritten, src.position());\n+\n+                \/\/ read\n+                ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+                int nread = sc2.read(dst);\n+                assertTrue(nread > 0);\n+                assertTrue(nread <= nwritten);\n+                assertEquals(nread, dst.position());\n+\n+                \/\/ check contents\n+                dst.flip();\n+                assertEquals(src.slice(0, nread), dst);\n+            }\n+\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * SocketChannel write(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testSocketChannelGatheringWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            try (SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n+                 SocketChannel sc2 = ssc.accept()) {\n+\n+                \/\/ gathering write\n+                ByteBuffer src = arena.allocate(SIZE * 2).asByteBuffer();\n+                fillRandom(src);\n+                ByteBuffer src1 = src.slice(0, SIZE);\n+                ByteBuffer src2 = src.slice(SIZE, SIZE);\n+                var srcs = new ByteBuffer[] { src1, src2 };\n+                int nwritten = (int) sc1.write(srcs);\n+                assertTrue(nwritten > 0);\n+                assertEquals(Math.min(nwritten, SIZE), src1.position());\n+                assertEquals(nwritten, src1.position() + src2.position());\n+\n+                \/\/ read\n+                ByteBuffer dst = arena.allocate(SIZE * 2 + 50).asByteBuffer();\n+                int nread = sc2.read(dst);\n+                assertTrue(nread > 0);\n+                assertTrue(nread <= nwritten);\n+                assertEquals(nread, dst.position());\n+\n+                \/\/ check contents\n+                dst.flip();\n+                assertEquals(src.slice(0, nread), dst);\n+            }\n+\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * SocketChannel read(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testSocketChannelScatteringRead(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (ServerSocketChannel ssc = ServerSocketChannel.open()) {\n+            ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+\n+            try (SocketChannel sc1 = SocketChannel.open(ssc.getLocalAddress());\n+                 SocketChannel sc2 = ssc.accept()) {\n+\n+                \/\/ write\n+                ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+                fillRandom(src);\n+                int nwritten = sc1.write(src);\n+                assertTrue(nwritten > 0);\n+                assertTrue(nwritten <= SIZE);\n+                assertEquals(nwritten, src.position());\n+\n+                \/\/ scattering read\n+                ByteBuffer dst = arena.allocate(SIZE + 50).asByteBuffer();\n+                ByteBuffer dst1 = dst.slice(0, 50);\n+                ByteBuffer dst2 = dst.slice(50, dst.capacity() - 50);\n+                var dsts = new ByteBuffer[]{ dst1, dst2 };\n+                int nread = (int) sc2.read(dsts);\n+                assertTrue(nread > 0);\n+                assertTrue(nread <= nwritten);\n+                assertTrue(dst1.position() > 0);\n+                assertEquals(nread, dst1.position() + dst2.position());\n+\n+                \/\/ check contents\n+                src.flip();\n+                assertEquals(src, dst.slice(0, nread));\n+            }\n+\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * DatagramChannel send\/receive(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testDatagramChannelSendReceive(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            SocketAddress target = dc.getLocalAddress();\n+\n+            \/\/ send\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+            int n = dc.send(src, target);\n+            assertEquals(SIZE, n);\n+            assertFalse(src.hasRemaining());\n+\n+            \/\/ receive\n+            ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+            SocketAddress remote = dc.receive(dst);\n+            assertEquals(remote, target);\n+            assertEquals(SIZE, dst.position());\n+\n+            \/\/ check contents\n+            src.clear();\n+            dst.flip();\n+            assertEquals(src, dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * DatagramChannel read\/write(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testDatagramChannelReadWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            SocketAddress target = dc.getLocalAddress();\n+            dc.connect(target);\n+\n+            \/\/ write\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+            int n = dc.write(src);\n+            assertEquals(SIZE, n);\n+            assertFalse(src.hasRemaining());\n+\n+            \/\/ read\n+            ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+            n = dc.read(dst);\n+            assertEquals(SIZE, n);\n+            assertEquals(SIZE, dst.position());\n+\n+            \/\/ check contents\n+            src.clear();\n+            dst.flip();\n+            assertEquals(src, dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * DatagramChannel write(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testDatagramChannelGatheringWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            SocketAddress target = dc.getLocalAddress();\n+            dc.connect(target);\n+\n+            \/\/ gathering write\n+            ByteBuffer src1 = arena.allocate(SIZE).asByteBuffer();\n+            ByteBuffer src2 = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src1);\n+            fillRandom(src2);\n+            var srcs = new ByteBuffer[] { src1, src2 };\n+            int nwritten = (int) dc.write(srcs);\n+            assertEquals(SIZE*2, nwritten);\n+            assertFalse(src1.hasRemaining());\n+            assertFalse(src2.hasRemaining());\n+\n+            \/\/ read\n+            ByteBuffer dst = arena.allocate(SIZE*2 + 50).asByteBuffer();\n+            int nread = dc.read(dst);\n+            assertEquals(SIZE*2, nread);\n+            assertEquals(SIZE*2, dst.position());\n+\n+            \/\/ check contents\n+            src1.flip();\n+            src2.flip();\n+            assertEquals(src1, dst.slice(0, SIZE));\n+            assertEquals(src2, dst.slice(SIZE, SIZE));\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * DatagramChannel read(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testDatagramChannelScatteringRead(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            dc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            SocketAddress target = dc.getLocalAddress();\n+            dc.connect(target);\n+\n+            \/\/ write\n+            ByteBuffer src = arena.allocate(SIZE*2).asByteBuffer();\n+            fillRandom(src);\n+            int nwritten = dc.write(src);\n+            assertEquals(SIZE*2, nwritten);\n+            assertEquals(nwritten, src.position());\n+\n+            \/\/ scattering read\n+            ByteBuffer dst1 = arena.allocate(SIZE).asByteBuffer();\n+            ByteBuffer dst2 = arena.allocate(SIZE + 50).asByteBuffer();\n+            var dsts = new ByteBuffer[] { dst1, dst2 };\n+            int nread = (int) dc.read(dsts);\n+            assertEquals(SIZE*2, nread);\n+            assertEquals(nread, dst1.position() + dst2.position());\n+\n+            \/\/ check contents\n+            dst1.flip();\n+            assertEquals(src.slice(0, SIZE), dst1);\n+            dst2.flip();\n+            assertEquals(src.slice(SIZE, SIZE), dst2);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * FileChannel read\/write(ByteBuffer).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testFileChannelReadWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        Path file = Files.createTempFile(Path.of(\".\"), \"test\", \"dat\");\n+        try (FileChannel fc = FileChannel.open(file, READ, WRITE)) {\n+\n+            \/\/ write\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+            int nwritten = fc.write(src);\n+            assertTrue(nwritten > 0);\n+            assertTrue(nwritten <= SIZE);\n+            assertEquals(nwritten, src.position());\n+            assertEquals(nwritten, (int) fc.position());\n+            assertEquals(nwritten, (int) fc.size());\n+\n+            \/\/ read\n+            ByteBuffer dst = arena.allocate(SIZE + 100).asByteBuffer();\n+            fc.position(0);\n+            int nread = fc.read(dst);\n+            assertTrue(nread > 0);\n+            assertTrue(nread <= nwritten);\n+            assertEquals(nread, dst.position());\n+            assertEquals(nread, (int) fc.position());\n+\n+            \/\/ check contents\n+            dst.flip();\n+            assertEquals(src.slice(0, nread), dst);\n+\n+            \/\/ reset\n+            fc.truncate(0L);\n+            src.clear();\n+            dst.clear();\n+\n+            \/\/ write with position\n+            nwritten = fc.write(src, 10L);\n+            assertTrue(nwritten > 0);\n+            assertTrue(nwritten <= SIZE);\n+            assertEquals(nwritten, src.position());\n+            assertEquals(0, (int) fc.position());\n+            assertEquals(nwritten + 10, (int) fc.size());\n+\n+            \/\/ read with position\n+            nread = fc.read(dst, 10L);\n+            assertTrue(nread > 0);\n+            assertTrue(nread <= nwritten);\n+            assertEquals(nread, dst.position());\n+            assertEquals(0, (int)fc.position());\n+\n+            \/\/ check contents\n+            dst.flip();\n+            assertEquals(src.slice(0, nread), dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * FileChannel write(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testFileChannelGatheringWrite(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        Path file = Files.createTempFile(Path.of(\"\"), \"test\", \"dat\");\n+        try (FileChannel fc = FileChannel.open(file, READ, WRITE)) {\n+\n+            \/\/ gathering write\n+            ByteBuffer src = arena.allocate(SIZE * 2).asByteBuffer();\n+            fillRandom(src);\n+            ByteBuffer src1 = src.slice(0, SIZE);\n+            ByteBuffer src2 = src.slice(SIZE, SIZE);\n+            var srcs = new ByteBuffer[] { src1, src2 };\n+            int nwritten = (int) fc.write(srcs);\n+            assertTrue(nwritten > 0);\n+            assertEquals(Math.min(nwritten, SIZE), src1.position());\n+            assertEquals(nwritten, src1.position() + src2.position());\n+            assertEquals(nwritten, (int) fc.position());\n+            assertEquals(nwritten, (int) fc.size());\n+\n+            \/\/ read\n+            ByteBuffer dst = arena.allocate(SIZE*2 + 50).asByteBuffer();\n+            fc.position(0);\n+            int nread = fc.read(dst);\n+            assertTrue(nread > 0);\n+            assertTrue(nread <= nwritten);\n+            assertEquals(nread, dst.position());\n+            assertEquals(nread, (int) fc.position());\n+\n+            \/\/ check contents\n+            dst.flip();\n+            assertEquals(src.slice(0, nread), dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * FileChannel read(ByteBuffer[]).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arenaSuppliers\")\n+    void testFileChannelScatteringRead(Supplier<Arena> arenaSupplier) throws IOException {\n+        Arena arena = arenaSupplier.get();\n+        Path file = Files.createTempFile(Path.of(\"\"), \"test\", \"dat\");\n+        try (FileChannel fc = FileChannel.open(file, READ, WRITE)) {\n+\n+            \/\/ write\n+            ByteBuffer src = arena.allocate(SIZE).asByteBuffer();\n+            fillRandom(src);\n+            int nwritten = fc.write(src);\n+            assertTrue(nwritten > 0);\n+            assertTrue(nwritten <= SIZE);\n+            assertEquals(nwritten, src.position());\n+            assertEquals(nwritten, (int) fc.position());\n+            assertEquals(nwritten, (int) fc.size());\n+\n+            \/\/ scattering read\n+            ByteBuffer dst = arena.allocate(SIZE + 50).asByteBuffer();\n+            ByteBuffer dst1 = dst.slice(0, 50);\n+            ByteBuffer dst2 = dst.slice(50, dst.capacity() - 50);\n+            var dsts = new ByteBuffer[] { dst1, dst2 };\n+            fc.position(0);\n+            int nread = (int) fc.read(dsts);\n+            assertTrue(nread > 0);\n+            assertTrue(nread <= nwritten);\n+            assertTrue(dst1.position() > 0);\n+            assertEquals(nread, dst1.position() + dst2.position());\n+            assertEquals(nread, (int) fc.position());\n+\n+            \/\/ check contents\n+            dst.limit(nread);\n+            assertEquals(src.slice(0, nread), dst);\n+        } finally {\n+            tryClose(arena);\n+        }\n+    }\n+\n+    \/**\n+     * Fill the buffer with random bytes.\n+     *\/\n+    private void fillRandom(ByteBuffer bb) {\n+        Random r = new Random();\n+        int pos = bb.position();\n+        while (bb.hasRemaining()) {\n+            bb.put((byte) r.nextInt(256));\n+        }\n+        bb.position(pos);\n+    }\n+\n+    \/**\n+     * Attempt to close the given Arena.\n+     *\/\n+    private boolean tryClose(Arena arena) {\n+        try {\n+            arena.close();\n+            return true;\n+        } catch (UnsupportedOperationException e) {\n+            return false;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/etc\/MemorySegments.java","additions":494,"deletions":0,"binary":false,"changes":494,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,2 @@\n-\/* @test\n- * @bug 8011536 8151430 8316304\n+\/* @test id=tmp\n+ * @bug 8011536 8151430 8316304 8334339\n@@ -27,1 +27,1 @@\n- *     that support it.\n+ *     that support it, tests using \/tmp directory.\n@@ -33,0 +33,9 @@\n+\/* @test id=cwd\n+ * @summary Basic test for creationTime attribute on platforms\/file systems\n+ *     that support it, tests using the test scratch directory, the test\n+ *     scratch directory maybe at diff disk partition to \/tmp on linux.\n+ * @library  ..\/.. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main CreationTime .\n+ *\/\n+\n@@ -41,0 +50,1 @@\n+import jtreg.SkippedException;\n@@ -71,2 +81,8 @@\n-            err.println(\"File creation time reported as: \" + creationTime);\n-            throw new RuntimeException(\"Expected to be close to: \" + now);\n+            System.out.println(\"creationTime.toMillis() == \" + creationTime.toMillis());\n+            \/\/ If the file system doesn't support birth time, then skip this test\n+            if (creationTime.toMillis() == 0) {\n+                throw new SkippedException(\"birth time not support for: \" + file);\n+            } else {\n+                err.println(\"File creation time reported as: \" + creationTime);\n+                throw new RuntimeException(\"Expected to be close to: \" + now);\n+            }\n@@ -98,1 +114,1 @@\n-        System.out.println(\"supportsCreationTimeRead == \" + supportsCreationTimeRead);\n+        System.out.println(top + \" supportsCreationTimeRead == \" + supportsCreationTimeRead);\n@@ -130,1 +146,6 @@\n-        Path dir = TestUtil.createTemporaryDirectory();\n+        Path dir;\n+        if (args.length == 0) {\n+            dir = TestUtil.createTemporaryDirectory();\n+        } else {\n+            dir = TestUtil.createTemporaryDirectory(args[0]);\n+        }\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/CreationTime.java","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    static final String datafile = \"tablea1.txt\";\n+    static final String datafile = \"ISO4217-list-one.txt\";\n","filename":"test\/jdk\/java\/util\/Currency\/CheckDataVersion.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *      8264792\n+ *      8264792 8334653\n@@ -62,1 +62,1 @@\n-    \/\/ 'tablea1.txt' should be up-to-date before testing\n+    \/\/ 'ISO4217-list-one.txt' should be up-to-date before testing\n","filename":"test\/jdk\/java\/util\/Currency\/CurrencyTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-# Amendments up until ISO 4217 AMENDMENT NUMBER 176\n-#   (As of 06 December 2023)\n+# Amendments up until ISO 4217 AMENDMENT NUMBER 177\n+#   (As of 20 June 2024)\n@@ -9,1 +9,1 @@\n-DATAVERSION=176\n+DATAVERSION=177\n@@ -279,1 +279,1 @@\n-ZW\tZWL\t932\t2\n+ZW\tZWG\t924\t2\n","filename":"test\/jdk\/java\/util\/Currency\/ISO4217-list-one.txt","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/util\/Currency\/tablea1.txt","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *      8208746 8209775 8264792 8274658 8283277 8296239 8321480\n+ *      8208746 8209775 8264792 8274658 8283277 8296239 8321480 8334653\n@@ -63,1 +63,2 @@\n- * based on ISO 4217. The golden-data file (ISO 4217 data) 'tablea1.txt' has the following\n+ * based on ISO 4217. The golden-data file, 'ISO4217-list-one.txt', based on the\n+ * List one: Currency, fund and precious metal codes has the following\n@@ -71,1 +72,1 @@\n-            \"test.src\", \".\"), \"tablea1.txt\");\n+            \"test.src\", \".\"), \"ISO4217-list-one.txt\");\n@@ -92,1 +93,1 @@\n-                    + \"YUM-ZMK-ZWD-ZWN-ZWR\";\n+                    + \"YUM-ZMK-ZWD-ZWL-ZWN-ZWR\";\n","filename":"test\/jdk\/java\/util\/Currency\/ValidateISO4217.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *      8327631 8332424\n+ *      8327631 8332424 8334418\n@@ -30,1 +30,1 @@\n- *          (LSR Revision: 2024-05-16) with Locale and Locale.LanguageRange\n+ *          (LSR Revision: 2024-06-14) with Locale and Locale.LanguageRange\n","filename":"test\/jdk\/java\/util\/Locale\/LanguageSubtagRegistryTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4354216 8213127\n+ * @bug 4354216 8213127 8334333\n@@ -35,0 +35,1 @@\n+ *        jdk.test.lib.Platform\n@@ -53,0 +54,2 @@\n+import jdk.test.lib.Platform;\n+import jtreg.SkippedException;\n@@ -56,0 +59,3 @@\n+        if (Platform.isRoot() && !Platform.isWindows()) {\n+            throw new SkippedException(\"Unable to create an unreadable properties file.\");\n+        }\n@@ -101,1 +107,1 @@\n-        if(path.toFile().exists()) {\n+        if (path.toFile().exists()) {\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/MissingResourceCauseTestRun.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+ *\n@@ -38,0 +39,7 @@\n+ * @run main\/othervm\/timeout=300 -Djava.security.manager=allow StartStopTest 1\n+ * @run main\/othervm\/timeout=300 -Djava.security.manager=allow StartStopTest 2\n+ * @run main\/othervm\/timeout=300 -Djava.security.manager=allow StartStopTest 3\n+ * @run main\/othervm\/timeout=300\/policy=all.policy StartStopTest 1\n+ * @run main\/othervm\/timeout=300\/policy=all.policy StartStopTest 2\n+ * @run main\/othervm\/timeout=300\/policy=all.policy StartStopTest 3\n+ *\n","filename":"test\/jdk\/javax\/management\/monitor\/StartStopTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+ *\n+ * @run main\/othervm ThreadPoolAccTest\n@@ -34,0 +36,3 @@\n+ * @run main\/othervm -Djava.security.manager=allow -DThreadPoolAccTest.useGetSubjectACC=true ThreadPoolAccTest\n+ * @run main\/othervm\/policy=all.policy ThreadPoolAccTest\n+ * @run main\/othervm\/policy=all.policy -DThreadPoolAccTest.useGetSubjectACC=true ThreadPoolAccTest\n@@ -40,0 +45,1 @@\n+import java.util.concurrent.Callable;\n@@ -70,1 +76,3 @@\n-            Subject subject = Subject.getSubject(AccessController.getContext());\n+            \/\/ Use Subject.current() unless test Property is set.\n+            Subject subject = Boolean.getBoolean(\"ThreadPoolAccTest.useGetSubjectACC\") ?\n+                              Subject.getSubject(AccessController.getContext()) : Subject.current();\n@@ -139,1 +147,3 @@\n-                Subject.doAs(subject, action);\n+                \/\/ Subject.doAs(subject, action);\n+                Callable<Void> c = (Callable<Void>) () -> action.run();\n+                Subject.callAs(subject, c);\n","filename":"test\/jdk\/javax\/management\/monitor\/ThreadPoolAccTest.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"","filename":"test\/jdk\/javax\/management\/monitor\/all.policy","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/security\/Policy\/Root\/Root.policy","status":"copied"},{"patch":"@@ -33,0 +33,2 @@\n+ *\n+ * @run main\/othervm NotificationAccessControllerTest\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/NotificationAccessControllerTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+ *\n@@ -35,0 +36,1 @@\n+ * @run main\/othervm -Djava.security.manager=allow NotificationEmissionTest 1\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/NotificationEmissionTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @run main\/othervm NonJMXPrincipalsTest\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAccessFile\/NonJMXPrincipalsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+ *\n+ * @run main\/othervm PasswordAccessFileTest\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAccessFile\/PasswordAccessFileTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+ *\n+ * @run main\/othervm RMIAltAuthTest\n@@ -34,0 +36,1 @@\n+ * @run main\/othervm -Djava.security.manager=allow -DSimpleStandard.useGetSubjectACC=true RMIAltAuthTest\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAuthenticator\/RMIAltAuthTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+ *\n+ * @run main\/othervm RMIPasswdAuthTest\n@@ -34,0 +36,1 @@\n+ * @run main\/othervm -Djava.security.manager=allow -DSimpleStandard.useGetSubjectACC=true RMIPasswdAuthTest\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAuthenticator\/RMIPasswdAuthTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,2 +155,2 @@\n-        AccessControlContext acc = AccessController.getContext();\n-        Subject subject = Subject.getSubject(acc);\n+        Subject subject = Boolean.getBoolean(\"SimpleStandard.useGetSubjectACC\") ?\n+                          Subject.getSubject(AccessController.getContext()) : Subject.current();\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/passwordAuthenticator\/SimpleStandard.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+ *\n+ * @run main\/othervm\/timeout=300 -DDEBUG_STANDARD -Dusername=username1 -Dpassword=password1 AuthorizationTest -server -mapType x.access.file;x.password.file -populate -client -mapType credentials\n+ * @run main\/othervm\/timeout=300 -DDEBUG_STANDARD -Dusername=username2 -Dpassword=password2 AuthorizationTest -server -mapType x.access.file;x.password.file -populate -client -mapType credentials -expectedCreateException -expectedSetException -expectedInvokeException\n+ * @run main\/othervm\/timeout=300 -DDEBUG_STANDARD -Dusername=username6 -Dpassword=password6 AuthorizationTest -server -mapType x.access.file;x.password.file -populate -client -mapType credentials -expectedCreateException -expectedGetException -expectedSetException -expectedInvokeException\n+ *\n@@ -35,0 +40,1 @@\n+ *\n","filename":"test\/jdk\/javax\/management\/security\/AuthorizationTest.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,6 +43,12 @@\n-        if (server.getSession(client1).getSessionContext() == null) {\n-            for (Exception e : server.getExceptionList()) {\n-                System.out.println(\"Looking at \" + e.getClass() + \" \" +\n-                    e.getMessage());\n-                if (e.getMessage().contains(args[0])) {\n-                    System.out.println(\"Found correct exception: \" + args[0] +\n+\n+        server.getSession(client1).getSessionContext();\n+        server.done();\n+\n+        var eList = server.getExceptionList();\n+        System.out.println(\"Exception list size is \" + eList.size());\n+\n+        for (Exception e : eList) {\n+            System.out.println(\"Looking at \" + e.getClass() + \" \" +\n+                e.getMessage());\n+            if (e.getMessage().contains(args[0])) {\n+                System.out.println(\"Found correct exception: \" + args[0] +\n@@ -50,4 +56,3 @@\n-                    return;\n-                } else {\n-                    System.out.println(\"No \\\"\" + args[0] + \"\\\" found.\");\n-                }\n+                return;\n+            } else {\n+                System.out.println(\"No \\\"\" + args[0] + \"\\\" found.\");\n@@ -55,2 +60,0 @@\n-\n-            throw new Exception(\"Failed to find expected alert: \" + args[0]);\n@@ -58,0 +61,2 @@\n+\n+        throw new Exception(\"Failed to find expected alert: \" + args[0]);\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CertMsgCheck.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile);\n+            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+                \"\/\" + pathToStores + \"\/\" + keyStoreFile);\n@@ -116,2 +116,2 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile);\n+            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+                \"\/\" + pathToStores + \"\/\" + trustStoreFile);\n@@ -151,1 +151,0 @@\n-        boolean exit = false;\n@@ -160,1 +159,2 @@\n-                sslContext.init(TLSBase.getKeyManager(builder.km), TLSBase.getTrustManager(builder.tm), null);\n+                sslContext.init(TLSBase.getKeyManager(builder.km),\n+                    TLSBase.getTrustManager(builder.tm), null);\n@@ -166,1 +166,1 @@\n-                System.err.println(e.getMessage());\n+                System.err.println(\"Failure during server initialization\");\n@@ -181,0 +181,1 @@\n+                            System.out.println(\"Caught \" + e.getMessage());\n@@ -206,1 +207,2 @@\n-                sslContext.init(TLSBase.getKeyManager(km), TLSBase.getTrustManager(tm), null);\n+                sslContext.init(TLSBase.getKeyManager(km),\n+                    TLSBase.getTrustManager(tm), null);\n@@ -212,1 +214,1 @@\n-                System.err.println(e.getMessage());\n+                System.err.println(\"Failure during server initialization\");\n@@ -227,0 +229,1 @@\n+                                System.out.println(\"Caught \" + e.getMessage());\n@@ -228,0 +231,1 @@\n+                                exceptionList.add(e);\n@@ -242,1 +246,1 @@\n-                t.interrupt();\n+                t.join(5000);\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JEditorPane;\n+import javax.swing.text.View;\n+import javax.swing.text.html.CSS;\n+\n+\/*\n+ * @test\n+ * @bug 8335967\n+ * @summary Tests 'text-decoration: none' is respected\n+ * @run main HTMLTextDecorationNone\n+ *\/\n+public final class HTMLTextDecorationNone {\n+    private static final String HTML = \"\"\"\n+            <!DOCTYPE html>\n+            <html lang=\"en\">\n+            <head>\n+                <meta charset=\"UTF-8\">\n+                <title>text-decoration: none (&lt;a&gt;)<\/title>\n+                <style>\n+                    a.none { text-decoration: none }\n+                <\/style>\n+            <\/head>\n+            <body>\n+            <p><a href=\"https:\/\/openjdk.org\/\">underlined<\/a><\/p>\n+            <p><a href=\"https:\/\/openjdk.org\/\" style=\"text-decoration: none\">not underlined<\/a><\/p>\n+            <p><a href=\"https:\/\/openjdk.org\/\" class=\"none\">not underlined<\/a><\/p>\n+            <p style=\"text-decoration: underline\"><a\n+                   href=\"https:\/\/openjdk.org\/\" style=\"text-decoration: none\">underlined?<\/a><\/p>\n+            <p style=\"text-decoration: underline\"><a\n+                   href=\"https:\/\/openjdk.org\/\" class=\"none\">underlined?<\/a><\/p>\n+            <\/body>\n+            <\/html>\n+            \"\"\";\n+\n+    private static final boolean[] underlined = {true, false, false, true, true};\n+\n+    public static void main(String[] args) {\n+        final JEditorPane html = new JEditorPane(\"text\/html\", HTML);\n+        html.setEditable(false);\n+\n+        final Dimension size = html.getPreferredSize();\n+        html.setSize(size);\n+\n+        BufferedImage image = new BufferedImage(size.width, size.height,\n+                                                BufferedImage.TYPE_INT_RGB);\n+        Graphics g = image.createGraphics();\n+        \/\/ Paint the editor pane to ensure all views are created\n+        html.paint(g);\n+        g.dispose();\n+\n+        int errorCount = 0;\n+        String firstError = null;\n+\n+        System.out.println(\"----- Views -----\");\n+        final View bodyView = html.getUI()\n+                                  .getRootView(html)\n+                                  .getView(1)\n+                                  .getView(1);\n+        for (int i = 0; i < bodyView.getViewCount(); i++) {\n+            View pView = bodyView.getView(i);\n+            View contentView = getContentView(pView);\n+\n+            Object decorationAttr =\n+                    contentView.getAttributes()\n+                               .getAttribute(CSS.Attribute.TEXT_DECORATION);\n+            String decoration = decorationAttr == null\n+                                ? \"none\" : decorationAttr.toString();\n+\n+            System.out.println(i + \": \" + decoration);\n+            if (decoration.contains(\"underline\") != underlined[i]) {\n+                errorCount++;\n+                if (firstError == null) {\n+                    firstError = \"Line \" + i + \": \" + decoration + \" vs \"\n+                                 + (underlined[i] ? \"underline\" : \"none\");\n+                }\n+            }\n+        }\n+\n+        if (errorCount > 0) {\n+            saveImage(image);\n+            throw new RuntimeException(errorCount + \" error(s) found, \"\n+                                       + \"the first one: \" + firstError);\n+        }\n+    }\n+\n+    private static View getContentView(View parent) {\n+        View view = parent.getView(0);\n+        return view.getViewCount() > 0\n+               ? getContentView(view)\n+               : view;\n+    }\n+\n+    private static void saveImage(BufferedImage image) {\n+        try {\n+            ImageIO.write(image, \"png\",\n+                          new File(\"html.png\"));\n+        } catch (IOException ignored) { }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/HTMLDocument\/HTMLTextDecorationNone.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8320360 8330684 8331320 8331655 8331940 8332486\n+ * @bug 8320360 8330684 8331320 8331655 8331940 8332486 8335820\n@@ -42,0 +42,1 @@\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -193,0 +194,6 @@\n+\n+    @Test\n+    void testZeroHashCPEntry() {\n+        var cpb = ConstantPoolBuilder.of();\n+        cpb.intEntry(-cpb.intEntry(0).hashCode());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8305990 8320222 8320618\n+ * @bug 8305990 8320222 8320618 8335475\n@@ -39,0 +39,4 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -241,1 +245,1 @@\n-                -> clb.withMethodBody(\"test\", ConstantDescs.MTD_void, 0, cob\n+                -> clb.withMethodBody(\"test\", MTD_void, 0, cob\n@@ -315,0 +319,24 @@\n+\n+    @ParameterizedTest\n+    @EnumSource(ClassFile.StackMapsOption.class)\n+    void testEmptyCounters(ClassFile.StackMapsOption option) {\n+        var cf = ClassFile.of(option);\n+        var bytes = cf.build(ClassDesc.of(\"Test\"), clb -> clb\n+            .withMethodBody(\"a\", MTD_void, ACC_STATIC, CodeBuilder::return_)\n+            .withMethodBody(\"b\", MTD_void, 0, CodeBuilder::return_)\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        for (var method : cm.methods()) {\n+            var name = method.methodName();\n+            var code = method.code().orElseThrow();\n+            if (name.equalsString(\"a\")) {\n+                assertEquals(0, code.maxLocals()); \/\/ static method\n+                assertEquals(0, code.maxStack());\n+            } else {\n+                assertTrue(name.equalsString(\"b\"));\n+                assertEquals(1, code.maxLocals()); \/\/ instance method\n+                assertEquals(0, code.maxStack());\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8336010\n@@ -29,0 +30,12 @@\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.FieldTransform;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.LabelTarget;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -42,0 +55,3 @@\n+import java.util.HashSet;\n+import java.util.Set;\n+\n@@ -44,0 +60,2 @@\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -129,0 +147,145 @@\n+    \/**\n+     * Test to ensure class elements, such as field and\n+     * methods defined with transform\/with, are visible\n+     * to next transforms.\n+     *\/\n+    @Test\n+    void testClassChaining() throws Exception {\n+        var bytes = Files.readAllBytes(testClassPath);\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(bytes);\n+        var otherCm = cf.parse(cf.build(ClassDesc.of(\"Temp\"), clb -> clb\n+            .withMethodBody(\"baz\", MTD_void, ACC_STATIC, CodeBuilder::return_)\n+            .withField(\"baz\", CD_long, ACC_STATIC)));\n+\n+        var methodBaz = otherCm.methods().getFirst();\n+        var fieldBaz = otherCm.fields().getFirst();\n+\n+        ClassTransform transform1 = ClassTransform.endHandler(cb -> {\n+            ClassBuilder ret;\n+            ret = cb.withMethodBody(\"bar\", MTD_void, ACC_STATIC, CodeBuilder::return_);\n+            assertSame(cb, ret);\n+            ret = cb.transformMethod(methodBaz, MethodTransform.ACCEPT_ALL);\n+            assertSame(cb, ret);\n+            ret = cb.withField(\"bar\", CD_int, ACC_STATIC);\n+            assertSame(cb, ret);\n+            ret = cb.transformField(fieldBaz, FieldTransform.ACCEPT_ALL);\n+            assertSame(cb, ret);\n+        });\n+\n+        Set<String> methodNames = new HashSet<>();\n+        Set<String> fieldNames = new HashSet<>();\n+        ClassTransform transform2 = (cb, ce) -> {\n+            if (ce instanceof MethodModel mm) {\n+                methodNames.add(mm.methodName().stringValue());\n+            }\n+            if (ce instanceof FieldModel fm) {\n+                fieldNames.add(fm.fieldName().stringValue());\n+            }\n+            cb.with(ce);\n+        };\n+\n+        cf.transform(cm, transform1.andThen(transform2));\n+\n+        assertEquals(Set.of(INIT_NAME, \"foo\", \"bar\", \"baz\"), methodNames);\n+        assertEquals(Set.of(\"bar\", \"baz\"), fieldNames);\n+    }\n+\n+    \/**\n+     * Test to ensure method elements, such as generated\n+     * or transformed code, are visible to transforms.\n+     *\/\n+    @Test\n+    void testMethodChaining() throws Exception {\n+        var mtd = MethodTypeDesc.of(CD_String);\n+\n+        var cf = ClassFile.of();\n+\n+        \/\/ withCode\n+        var cm = cf.parse(cf.build(ClassDesc.of(\"Temp\"), clb -> clb\n+            .withMethod(\"baz\", mtd, ACC_STATIC | ACC_NATIVE, _ -> {})));\n+\n+        MethodTransform transform1 = MethodTransform.endHandler(mb -> {\n+            var ret = mb.withCode(cob -> cob.loadConstant(\"foo\").areturn());\n+            assertSame(mb, ret);\n+        });\n+\n+        boolean[] sawWithCode = { false };\n+        MethodTransform transform2 = (mb, me) -> {\n+            if (me instanceof CodeModel) {\n+                sawWithCode[0] = true;\n+            }\n+            mb.with(me);\n+        };\n+\n+        cf.transform(cm, ClassTransform.transformingMethods(transform1.andThen(transform2)));\n+\n+        assertTrue(sawWithCode[0], \"Code attribute generated not visible\");\n+\n+        \/\/ transformCode\n+        var outerCm = cf.parse(testClassPath);\n+        var foo = outerCm.methods().stream()\n+            .filter(m -> m.flags().has(AccessFlag.STATIC))\n+            .findFirst().orElseThrow();\n+\n+        MethodTransform transform3 = MethodTransform.endHandler(mb -> {\n+            var ret = mb.transformCode(foo.code().orElseThrow(), CodeTransform.ACCEPT_ALL);\n+            assertSame(mb, ret);\n+        });\n+\n+        boolean[] sawTransformCode = { false };\n+        MethodTransform transform4 = (mb, me) -> {\n+            if (me instanceof CodeModel) {\n+                sawTransformCode[0] = true;\n+            }\n+            mb.with(me);\n+        };\n+\n+        cf.transform(cm, ClassTransform.transformingMethods(transform3.andThen(transform4)));\n+\n+        assertTrue(sawTransformCode[0], \"Code attribute transformed not visible\");\n+    }\n+\n+    \/**\n+     * Test to ensure code elements, such as code block\n+     * begin and end labels, are visible to transforms.\n+     *\/\n+    @Test\n+    void testCodeChaining() throws Exception {\n+        var bytes = Files.readAllBytes(testClassPath);\n+        var cf = ClassFile.of();\n+        var cm = cf.parse(bytes);\n+\n+        CodeTransform transform1 = new CodeTransform() {\n+            @Override\n+            public void atStart(CodeBuilder builder) {\n+                builder.block(bcb -> {\n+                    bcb.loadConstant(9876L);\n+                    bcb.goto_(bcb.endLabel());\n+                });\n+            }\n+\n+            @Override\n+            public void accept(CodeBuilder builder, CodeElement element) {\n+                builder.with(element);\n+            }\n+        };\n+        Set<Label> leaveLabels = new HashSet<>();\n+        Set<Label> targetedLabels = new HashSet<>();\n+        CodeTransform transform2 = (cb, ce) -> {\n+            if (ce instanceof BranchInstruction bi) {\n+                leaveLabels.add(bi.target());\n+            }\n+            if (ce instanceof LabelTarget lt) {\n+                targetedLabels.add(lt.label());\n+            }\n+            cb.with(ce);\n+        };\n+\n+        cf.transform(cm, ClassTransform.transformingMethods(MethodTransform\n+            .transformingCode(transform1.andThen(transform2))));\n+\n+        leaveLabels.removeIf(targetedLabels::contains);\n+        assertTrue(leaveLabels.isEmpty(), () -> \"Some labels are not bounded: \" + leaveLabels);\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertLessThan;\n+\n+import java.util.Arrays;\n+\n+\/*\n+ * @test ContainerPidAdjustmentTest\n+ * @summary The test checks that process PID is adjusted with the specified value, when checkpointing in a container. Default min PID value is 128.\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build ContainerPidAdjustmentTest\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  true   false  INF     true   128\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  true   true   1       false  1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  true   true   100     true   100\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  false  INF     false  1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   1       false  1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   1       true   1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   200     true   200\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   1000    false  1000\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   2000    true   2000   1000\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   0       true   -1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   -10     true   -1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   blabla  true   -1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   5000000 true   -1\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   5000000 true   -1     4194200\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest  false  true   4194303 true   -1\n+\n+ *\/\n+public class ContainerPidAdjustmentTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean runDirectly;\n+\n+    @CracTestArg(1)\n+    boolean needSetMinPid;\n+\n+    @CracTestArg(2)\n+    String lastPid;\n+\n+    @CracTestArg(3)\n+    boolean usePrivilegedContainer;\n+\n+    @CracTestArg(4)\n+    long expectedLastPid;\n+\n+    @CracTestArg(value = 5, optional = true)\n+    String lastPidSetup;\n+\n+    final private String CURRENT_PID_MESSAGE = \"Current PID = \";\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+        CracBuilder builder = new CracBuilder()\n+            .inDockerImage(\"pid-adjustment\")\n+            .runContainerDirectly(runDirectly)\n+            .containerUsePrivileged(usePrivilegedContainer);\n+        if (needSetMinPid) {\n+            builder.vmOption(\"-XX:CRaCMinPid=\" + lastPid);\n+        }\n+        if (0 > expectedLastPid) {\n+            builder.captureOutput(true);\n+        }\n+        if (null != lastPidSetup) {\n+            \/\/ Set up the initial last pid,\n+            \/\/ create a non-privileged user,\n+            \/\/ and force spinning the last pid running checkpoint under the user.\n+            builder\n+                .containerSetup(Arrays.asList(\"bash\", \"-c\", \"useradd the_user && echo \" + lastPidSetup + \" >\/proc\/sys\/kernel\/ns_last_pid\"))\n+                .dockerCheckpointOptions(Arrays.asList(\"-u\", \"the_user\"));\n+        }\n+\n+        if (0 < expectedLastPid) {\n+            builder.startCheckpoint().waitForSuccess();\n+        } else {\n+            final int expectedExitValue = (int)java.lang.Math.abs(expectedLastPid);\n+            CracProcess process = builder.startCheckpoint();\n+            final int exitValue = process.waitFor();\n+            assertEquals(expectedExitValue, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+            OutputAnalyzer oa = process.outputAnalyzer();\n+            oa.shouldNotContain(CURRENT_PID_MESSAGE);\n+            if (null != lastPidSetup) {\n+                oa.shouldContain(\"spin_last_pid: Invalid argument (\" + lastPid + \")\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(CURRENT_PID_MESSAGE + ProcessHandle.current().pid());\n+        assertLessThan((long)0, expectedLastPid, \"Shouldn't happen\");\n+        assertLessThan(expectedLastPid, ProcessHandle.current().pid());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContainerPidAdjustmentTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.impl.BlockingOrderedContext;\n+import jdk.crac.impl.OrderedContext;\n+import jdk.internal.crac.JDKResource;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static jdk.crac.Core.getGlobalContext;\n+import static jdk.internal.crac.Core.*;\n+import static jdk.internal.crac.Core.Priority.*;\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test ContextOrderTest\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testOrder\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testRegisterBlocks\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testThrowing\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testRegisterToCompleted\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testRegisterFromOtherThread\n+ *\/\n+public class ContextOrderTest {\n+    \/\/ prevents GC releasing the resources\n+    private static final List<Resource> rememberMe = new ArrayList<>();\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"java.util.logging.config.file\", Utils.TEST_SRC + \"\/logging.properties\");\n+\n+        Method m = ContextOrderTest.class.getDeclaredMethod(args[0]);\n+        m.invoke(null);\n+    }\n+\n+    private static void testOrder() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, \"regular1\"));\n+        NORMAL.getContext().register(new MockResource(recorder, \"jdk-normal\"));\n+        SECURE_RANDOM.getContext().register(new MockResource(recorder, \"jdk-later\"));\n+        getGlobalContext().register(new CreatingResource<>(recorder, \"regular2\", NORMAL.getContext()));\n+        \/\/ this child should run as it has higher priority\n+        NORMAL.getContext().register(new CreatingResource<>(recorder, \"jdk-create\", SEEDER_HOLDER.getContext()));\n+\n+        Core.checkpointRestore();\n+\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+\n+        assertEquals(\"regular2-child1-before\", recorder.poll());\n+        assertEquals(\"jdk-create-before\", recorder.poll());\n+        assertEquals(\"jdk-normal-before\", recorder.poll());\n+\n+        assertEquals(\"jdk-later-before\", recorder.poll());\n+        assertEquals(\"jdk-create-child1-before\", recorder.poll());\n+        \/\/ restore\n+        assertEquals(\"jdk-create-child1-after\", recorder.poll());\n+        assertEquals(\"jdk-later-after\", recorder.poll());\n+\n+        assertEquals(\"jdk-normal-after\", recorder.poll());\n+        assertEquals(\"jdk-create-after\", recorder.poll());\n+        assertEquals(\"regular2-child1-after\", recorder.poll());\n+\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+\n+        \/\/ second checkpoint - whatever was registered in first afterRestore is now notified\n+        Core.checkpointRestore();\n+        assertTrue(recorder.stream().anyMatch(\"jdk-create-child2-before\"::equals));\n+        assertTrue(recorder.stream().anyMatch(\"regular2-child2-before\"::equals));\n+    }\n+\n+    private static void testRegisterBlocks() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        BlockingOrderedContext<Resource> blockingCtx = new BlockingOrderedContext();\n+        getGlobalContext().register(blockingCtx);\n+        \/\/ blocks register into the same OrderedContext\n+        blockingCtx.register(new CreatingResource<>(recorder, \"regular\", blockingCtx));\n+        testWaiting();\n+\n+        BlockingOrderedContext<Resource> blockingCtx1 = new BlockingOrderedContext();\n+        getGlobalContext().register(blockingCtx1);\n+        BlockingOrderedContext<Resource> blockingCtx2 = new BlockingOrderedContext();\n+        getGlobalContext().register(blockingCtx2);\n+        \/\/ blocks registering to the context done notifications\n+        blockingCtx1.register(new CreatingResource<>(recorder, \"jdk-lower\", blockingCtx2));\n+        testWaiting();\n+\n+        \/\/ blocks registering with the same priority\n+        NORMAL.getContext().register(new CreatingResource<>(recorder, \"jdk-same\", NORMAL.getContext()));\n+        testWaiting();\n+    }\n+\n+    private static void testWaiting() throws InterruptedException {\n+        AtomicReference<Throwable> exceptionHolder = new AtomicReference<>();\n+        assertWaits(() -> {\n+            try {\n+                Core.checkpointRestore();\n+            } catch (Exception e) {\n+                exceptionHolder.set(e);\n+            }\n+        }, null, \"waitWhileCheckpointIsInProgress\");\n+        assertNotNull(exceptionHolder.get());\n+        exceptionHolder.get().printStackTrace();\n+    }\n+\n+    private static void assertWaits(Runnable runnable, String cls, String method) throws InterruptedException {\n+        Thread thread = new Thread(runnable);\n+        thread.start();\n+        long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(10);\n+        for (;;) {\n+            if (thread.getState() == Thread.State.WAITING) {\n+                for (var ste : thread.getStackTrace()) {\n+                    if ((cls == null || cls.equals(ste.getClassName()) || ste.getClassName().endsWith(\".\" + cls)) &&\n+                            (method == null || method.equals(ste.getMethodName()))) {\n+                        \/\/ It should be sufficient to interrupt the code once; if any Resource\n+                        \/\/ clears the flag without rethrowing it is a bug.\n+                        thread.interrupt();\n+                        thread.join(TimeUnit.NANOSECONDS.toMillis(deadline - System.nanoTime()));\n+                        if (thread.getState() == Thread.State.WAITING) {\n+                            for (var ste2 : thread.getStackTrace()) {\n+                                System.out.println(ste2);\n+                            }\n+                        }\n+                        assertFalse(thread.isAlive());\n+                        return;\n+                    }\n+                }\n+            } else if (thread.getState() == Thread.State.TERMINATED) {\n+                fail(\"Thread completed without waiting\");\n+            }\n+            if (System.nanoTime() < deadline) {\n+                \/\/noinspection BusyWait\n+                Thread.sleep(50);\n+            } else {\n+                fail(\"Timed out waiting for thread to get waiting in \" + cls + \".\" + method);\n+            }\n+        }\n+    }\n+\n+    private static void testThrowing() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, \"regular1\"));\n+        getGlobalContext().register(new ThrowingResource(recorder, \"throwing1\"));\n+        getGlobalContext().register(new MockResource(recorder, \"regular2\"));\n+        NORMAL.getContext().register(new MockResource(recorder, \"jdk1\"));\n+        EPOLLSELECTOR.getContext().register(new ThrowingResource(recorder, \"throwing2\"));\n+        SECURE_RANDOM.getContext().register(new MockResource(recorder, \"jdk2\"));\n+\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Expected to throw CheckpointException\");\n+        } catch (CheckpointException e) {\n+            assertEquals(4, e.getSuppressed().length);\n+        }\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"throwing1-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+        assertEquals(\"jdk1-before\", recorder.poll());\n+        assertEquals(\"throwing2-before\", recorder.poll());\n+        assertEquals(\"jdk2-before\", recorder.poll());\n+\n+        assertEquals(\"jdk2-after\", recorder.poll());\n+        assertEquals(\"throwing2-after\", recorder.poll());\n+        assertEquals(\"jdk1-after\", recorder.poll());\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"throwing1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+    }\n+\n+    static class NamedOrderedContext<R extends Resource> extends BlockingOrderedContext {\n+        private final String name;\n+        NamedOrderedContext(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    \/\/ Similar to the test above but registers in context that is already done\n+    \/\/ rather than iterating through now.\n+    private static void testRegisterToCompleted() throws Exception {\n+        var recorder = new LinkedList<String>();\n+\n+        OrderedContext<Resource> c1 = new NamedOrderedContext<>(\"C1\");\n+        OrderedContext<Resource> c2 = new NamedOrderedContext<>(\"C2\");\n+        getGlobalContext().register(c1);\n+        getGlobalContext().register(c2);\n+        c2.register(new MockResource(recorder, \"first\"));\n+        \/\/ Logically there's nothing that prevents to register into C2 during C1.<resource>.afterRestore\n+        \/\/ but the implementation of C1 does not know that we're already after C\/R and still blocks\n+        \/\/ any registrations.\n+        c1.register(new CreatingResource<>(recorder, \"second\", c2));\n+\n+        \/\/ This is supposed to end up with a deadlock. Even though it would block first\n+        \/\/ for -child1 and then for -child2 the first time we interrupt the thread it will\n+        \/\/ unblock and won't block any further.\n+        testWaiting();\n+\n+        \/\/ Since we have interrupted the registration no other resource was registered\n+        \/\/ so there's no point in testing anything here.\n+    }\n+\n+    \/\/ registering from lower priority resource to higher priority shouldn't block\n+    \/\/ even in another thread\n+    private static void testRegisterFromOtherThread() throws RestoreException, CheckpointException {\n+        var recorder = new LinkedList<String>();\n+        NORMAL.getContext().register(new MockResource(recorder, \"normal\") {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                super.beforeCheckpoint(context);\n+                Thread thread = new Thread(() -> {\n+                    CLEANERS.getContext().register(new MockResource(recorder, \"child\"));\n+                }, \"registrar\");\n+                thread.start();\n+                thread.join();\n+            }\n+        });\n+\n+        Core.checkpointRestore();\n+        assertEquals(\"normal-before\", recorder.poll());\n+        assertEquals(\"child-before\", recorder.poll());\n+        assertEquals(\"child-after\", recorder.poll());\n+        assertEquals(\"normal-after\", recorder.poll());\n+    }\n+\n+    private static class MockResource implements JDKResource {\n+        protected final List<String> recorder;\n+        protected final String id;\n+\n+        private MockResource(List<String> recorder, String id) {\n+            rememberMe.add(this);\n+            this.recorder = recorder;\n+            this.id = id;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            recorder.add(id + \"-before\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            recorder.add(id + \"-after\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \":\" + id;\n+        }\n+    }\n+\n+    \/\/ While normally resources should not directly register other resources it is possible\n+    \/\/ that running it will trigger (static) initialization of a class and that registers\n+    \/\/ a new resource. It is not legal to register a user resource, but for JDK resources\n+    \/\/ we can make an exception since it does not conflict with the general order (JDK resources\n+    \/\/ are notified after user resources).\n+    private static class CreatingResource<R extends Resource> extends MockResource {\n+        private final Context<R> childContext;\n+        private boolean first = true;\n+\n+        private CreatingResource(List<String> recorder, String id, Context<R> childContext) {\n+            super(recorder, id);\n+            this.childContext = childContext;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            super.beforeCheckpoint(context);\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, id + \"-child1\"));\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            super.afterRestore(context);\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, id + \"-child2\"));\n+            }\n+            first = false;\n+        }\n+    }\n+\n+    private static class ThrowingResource extends MockResource {\n+        private ThrowingResource(List<String> recorder, String id) {\n+            super(recorder, id);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            super.beforeCheckpoint(context);\n+            throw new RuntimeException(id + \"-before\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            super.afterRestore(context);\n+            throw new RuntimeException(id + \"-after\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.crac.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.channels.Pipe;\n+import java.nio.file.*;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * @test CracOptionTest\n+ * @library \/test\/lib\n+ * @build CracOptionTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+\n+public class CracOptionTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.javaOption(\"k\",\"v\");\n+        builder.doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/CracOptionTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+\n+\/**\n+ * @test\n+ * @summary All afterRestore's should complete, even if there are only daemon threads (in case one of the afterRestore's finally creates non-daemon thread that will be responsible to keep VM alive)\n+ * @library \/test\/lib\n+ * @build DaemonAfterRestore\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class DaemonAfterRestore implements CracTest {\n+    static final String MAIN_THREAD_FINISH = \"main thread finish\";\n+    static final String AFTER_RESTORE_MESSAGE = \"after restore finish\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().captureOutput(true);\n+\n+        CompletableFuture<?> firstOutputFuture = new CompletableFuture<Void>();\n+        CracProcess checkpointProcess = builder.startCheckpoint().watch(\n+            outline -> {\n+                System.out.println(outline);\n+                if (outline.equals(MAIN_THREAD_FINISH)) {\n+                    firstOutputFuture.complete(null);\n+                }\n+            },\n+            errline -> {\n+                System.err.println(\"ERROR: \" + errline);\n+                firstOutputFuture.cancel(false);\n+            });\n+        firstOutputFuture.get(10, TimeUnit.SECONDS);\n+        builder.checkpointViaJcmd();\n+        checkpointProcess.waitForCheckpointed();\n+\n+        builder.startRestore().waitForSuccess()\n+            .outputAnalyzer().shouldContain(AFTER_RESTORE_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws RestoreException, CheckpointException {\n+        CountDownLatch start = new CountDownLatch(1);\n+        CountDownLatch finish = new CountDownLatch(1);\n+        Thread workerThread = new Thread(() -> {\n+            System.out.println(\"worker thread start\");\n+            start.countDown();\n+            try {\n+                finish.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            System.out.println(\"worker thread finish\");\n+        });\n+        assertFalse(workerThread.isDaemon());\n+        workerThread.start();\n+\n+        try {\n+            start.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        Resource resource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                assert Thread.currentThread().isDaemon() : \"beforeCheckpoint is expected to be called from daemon thread\";\n+                finish.countDown();\n+            }\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                Thread.sleep(3000);\n+                System.out.println(AFTER_RESTORE_MESSAGE);\n+            }\n+        };\n+\n+        Core.getGlobalContext().register(resource);\n+\n+        System.out.println(MAIN_THREAD_FINISH);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/DaemonAfterRestore.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test DryRunTest\n+ * @library \/test\/lib\n+ * @build DryRunTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class DryRunTest implements CracTest {\n+    static class CRResource implements Resource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            throw new RuntimeException(\"should not pass\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE).printResources(true)\n+                .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Resource resource = new CRResource();\n+        Core.getGlobalContext().register(resource);\n+\n+        File tempFile = File.createTempFile(\"jtreg-DryRunTest\", null);\n+        FileOutputStream stream = new FileOutputStream(tempFile);\n+        stream.write('j');\n+\n+        int exceptions = 0;\n+\n+        try {\n+            Core.checkpointRestore();\n+        } catch (CheckpointException ce) {\n+\n+            ce.printStackTrace();\n+\n+            for (Throwable e : ce.getSuppressed()) {\n+                String name = e.getClass().getName();\n+                switch (name) {\n+                    case \"java.lang.RuntimeException\":                exceptions |= 0x1; break;\n+                    case \"jdk.crac.impl.CheckpointOpenFileException\": exceptions |= 0x2; break;\n+                }\n+            }\n+        }\n+\n+        stream.close();\n+        tempFile.delete();\n+\n+        if (exceptions != 0x3) {\n+            throw new RuntimeException(\"fail \" + exceptions);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/DryRunTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test FailedResourceTest\n+ * @library \/test\/lib\n+ * @build FailedResourceTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+\n+public class FailedResourceTest implements CracTest {\n+    public static final String EXCEPTION_MESSAGE = \"Resource failed\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        AtomicBoolean ranAfter = new AtomicBoolean();\n+        Resource resource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                throw new Exception(EXCEPTION_MESSAGE);\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                ranAfter.set(true);\n+            }\n+        };\n+        Core.getGlobalContext().register(resource);\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Was supposed to throw\");\n+        } catch (CheckpointException e) {\n+            assertEquals(1, e.getSuppressed().length, Arrays.toString(e.getSuppressed()));\n+            assertEquals(EXCEPTION_MESSAGE, e.getSuppressed()[0].getMessage());\n+        } catch (RestoreException e) {\n+            fail(\"Shouldn't error in restore\", e);\n+        }\n+        assertTrue(ranAfter.get());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/FailedResourceTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2022-2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/**\n+ * @test JarFileFactoryCacheTest\n+ * @library \/test\/lib\n+ * @build JarFileFactoryCacheTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class JarFileFactoryCacheTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE).printResources(true)\n+                .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Path temp = Files.createTempDirectory(JarFileFactoryCacheTest.class.getName());\n+        Path testFilePath = temp.resolve(\"test.txt\");\n+        try {\n+            Files.writeString(testFilePath, \"test\\n\");\n+            jdk.test.lib.util.JarUtils.createJarFile(\n+                    Path.of(\"test.jar\"), temp, \"test.txt\");\n+        } finally {\n+            File testTxt = testFilePath.toFile();\n+            if (testTxt.exists()) {\n+                assert testTxt.delete();\n+            }\n+            assert temp.toFile().delete();\n+        }\n+\n+        URL url = new URL(\"jar:file:test.jar!\/test.txt\");\n+        InputStream inputStream = url.openStream();\n+        byte[] content = inputStream.readAllBytes();\n+        if (content.length != 5) {\n+            throw new AssertionError(\"wrong content: \" + new String(content));\n+        }\n+        inputStream.close();\n+        \/\/ Nulling the variables is actually necessary!\n+        inputStream = null;\n+        url = null;\n+\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/JarFileFactoryCacheTest\/JarFileFactoryCacheTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build LeaveRunning\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class LeaveRunning implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().env(\"CRAC_CRIU_LEAVE_RUNNING\", \"\")\n+                .captureOutput(true);\n+        builder.startCheckpoint().waitForSuccess().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+        builder.doRestore().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/LeaveRunning.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.management.*;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+\n+import static jdk.test.lib.Asserts.assertLT;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build MXBean\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class MXBean implements CracTest {\n+    static final long TIME_TOLERANCE = 10_000; \/\/ ms\n+\n+    @Override\n+    public void exec() throws CheckpointException, RestoreException {\n+        CRaCMXBean cracMXBean = CRaCMXBean.getCRaCMXBean();\n+\n+        Core.checkpointRestore();\n+\n+        System.out.println(\"UptimeSinceRestore \" + cracMXBean.getUptimeSinceRestore());\n+\n+        long restoreTime = cracMXBean.getRestoreTime();\n+        System.out.println(\"RestoreTime \" + restoreTime + \" \" +\n+            DateTimeFormatter.ofPattern(\"E dd LLL yyyy HH:mm:ss.n\").format(\n+                Instant.ofEpochMilli(restoreTime)\n+                    .atZone(ZoneId.systemDefault())));\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        long start = System.currentTimeMillis();\n+\n+        OutputAnalyzer output = new CracBuilder().engine(CracEngine.SIMULATE)\n+                .captureOutput(true)\n+                .startCheckpoint().waitForSuccess().outputAnalyzer();\n+\n+        long restoreUptime = Long.parseLong(output.firstMatch(\"UptimeSinceRestore ([0-9-]+)\", 1));\n+        if (restoreUptime < 0 || TIME_TOLERANCE < restoreUptime) {\n+            throw new Error(\"bad UptimeSinceRestore: \" + restoreUptime);\n+        }\n+\n+        long restoreTime = Long.parseLong(output.firstMatch(\"RestoreTime ([0-9-]+)\", 1));\n+        restoreTime -= start;\n+\n+        assertLT(Math.abs(restoreTime), TIME_TOLERANCE, \"bad RestoreTime: \" + restoreTime);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/MXBean.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test ContextOrderTest\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @build PerfMemoryRestoreTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true\n+ *\/\n+\n+public class PerfMemoryRestoreTest implements CracTest {\n+    private static final int PERFDATA_CREATE_DELAY_MS = 100;\n+\n+    @CracTestArg(0)\n+    boolean perfDisableSharedMem;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.captureOutput(true);\n+        if (perfDisableSharedMem) {\n+            builder.vmOption(\"-XX:+PerfDisableSharedMem\");\n+        } else {\n+            builder.vmOption(\"-XX:-PerfDisableSharedMem\");\n+        }\n+        CracProcess checkpoint = builder.startCheckpoint();\n+        String pid = String.valueOf(checkpoint.pid());\n+        \/\/ This test is run only on Linux where the path is hardcoded\n+        \/\/ in os::get_temp_directory() to \/tmp rather than using System.getProperty(\"java.io.tmpdir\")\n+        Path perfdata = Path.of(\"\/tmp\", \"hsperfdata_\" + System.getProperty(\"user.name\"), pid);\n+        if (perfDisableSharedMem) {\n+            Thread.sleep(PERFDATA_CREATE_DELAY_MS);\n+            assertFalse(perfdata.toFile().exists(), \"Perf data file exists although we run with -XX:+PerfDisableSharedMem\");\n+        } else {\n+            waitForFile(perfdata);\n+            checkMapped(pid, perfdata.toString());\n+        }\n+\n+        checkpoint.input().write('\\n');\n+        checkpoint.input().flush();\n+        checkpoint.waitForCheckpointed();\n+        assertFalse(perfdata.toFile().exists());\n+\n+        builder.clearVmOptions();\n+        CracProcess restored = builder.startRestore();\n+        \/\/ Note: we need to check the checkpoint.pid(), which should be restored (when using CRIU),\n+        \/\/ as restored.pid() would be the criuengine restorewait process\n+        String pidString = String.valueOf(checkpoint.pid());\n+        if (perfDisableSharedMem) {\n+            Thread.sleep(PERFDATA_CREATE_DELAY_MS);\n+            assertFalse(perfdata.toFile().exists(), \"Perf data file exists although we run with -XX:+PerfDisableSharedMem\");\n+        } else {\n+            waitForFile(perfdata);\n+            checkMapped(pidString, perfdata.toString());\n+            builder.runJcmd(pidString, \"PerfCounter.print\")\n+                    .shouldHaveExitValue(0)\n+                    .shouldContain(\"sun.perfdata.size=\");\n+        }\n+        restored.input().write('\\n');\n+        restored.input().flush();\n+        restored.waitForSuccess();\n+        OutputAnalyzer out = restored.outputAnalyzer();\n+        out.stderrShouldBeEmpty();\n+        out.stdoutShouldBeEmpty();\n+    }\n+\n+    private static void waitForFile(Path perfdata) throws InterruptedException {\n+        long start = System.nanoTime();\n+        while (!perfdata.toFile().exists()) {\n+            if (System.nanoTime() - start > TimeUnit.SECONDS.toNanos(10)) {\n+                throw new IllegalStateException(\"Perf data file did not appear within time limit in the checkpointed process: \" + perfdata);\n+            }\n+            \/\/noinspection BusyWait\n+            Thread.sleep(10);\n+        }\n+    }\n+\n+    private static void checkMapped(String pid, String perfdata) throws IOException {\n+        String perfdataLine = Files.readAllLines(Path.of(\"\/proc\", pid, \"maps\")).stream()\n+                .filter(line -> line.contains(perfdata))\n+                .findFirst().orElseThrow(() -> new AssertionError(\"Missing \" + perfdata + \" in process maps\"));\n+        assertTrue(perfdataLine.contains(\"rw-s 00000000\"), perfdataLine);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        assertEquals(System.in.read(), (int) '\\n');\n+        Core.checkpointRestore();\n+        assertEquals(System.in.read(), (int) '\\n');\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/PerfMemoryRestoreTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.lang.ref.Cleaner;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build RefQueueTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class RefQueueTest implements CracTest {\n+    private static final Cleaner cleaner = Cleaner.create();\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE)\n+                .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        File badFile = File.createTempFile(\"jtreg-RefQueueTest\", null);\n+        OutputStream badStream = new FileOutputStream(badFile);\n+        badStream.write('j');\n+        badFile.delete();\n+\n+        \/\/ the cleaner would be able to run right away\n+        cleaner.register(new Object(), () -> {\n+            try {\n+                badStream.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        \/\/ should close the file and only then go to the native checkpoint\n+        Core.checkpointRestore();\n+\n+        \/\/ ensure that the cleaner starts working eventually\n+        CountDownLatch latch = new CountDownLatch(1);\n+        cleaner.register(new Object(), () -> {\n+            latch.countDown();\n+        });\n+        System.gc();\n+        assertTrue(latch.await(10, TimeUnit.SECONDS));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.management.ManagementFactory;\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+import static jdk.test.lib.Asserts.assertLT;\n+import static jdk.test.lib.Asserts.assertLTE;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build ResetStartTimeTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest false\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest true\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class ResetStartTimeTest implements CracTest {\n+\n+    @CracTestArg(0)\n+    boolean resetUptime;\n+\n+    static private final long WAIT_TIMEOUT = 2 * 1000; \/\/ msecs\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.startCheckpoint().waitForCheckpointed();\n+        if (!resetUptime) {\n+            builder.vmOption(\"-XX:+UnlockDiagnosticVMOptions\");\n+            builder.vmOption(\"-XX:-CRaCResetStartTime\");\n+        }\n+        builder.captureOutput(true).doRestore().waitForSuccess()\n+                .outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Thread.sleep(WAIT_TIMEOUT);\n+        final long uptime0 = ManagementFactory.getRuntimeMXBean().getUptime();\n+\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+        final long uptime1 = ManagementFactory.getRuntimeMXBean().getUptime();\n+\n+        if (resetUptime) {\n+            assertLT(uptime1, uptime0);\n+            assertLT(uptime1, WAIT_TIMEOUT);\n+        } else {\n+            assertLTE(uptime0, uptime1);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ResetStartTimeTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+\n+\/*\n+ * @test RestoreEnvironmentTest\n+ * @summary the test checks that actual environment variables are propagated into a restored process.\n+ * @library \/test\/lib\n+ * @build RestoreEnvironmentTest\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class RestoreEnvironmentTest implements CracTest {\n+    static final String TEST_VAR_NAME = \"RESTORE_ENVIRONMENT_TEST_VAR\";\n+    static final String BEFORE_CHECKPOINT = \"BeforeCheckpoint\";\n+    static final String AFTER_RESTORE = \"AfterRestore\";\n+    static final String NEW_VALUE = \"NewValue\";\n+    public static final String PREFIX = \"(after restore) \";\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().captureOutput(true)\n+                .env(TEST_VAR_NAME + 0, BEFORE_CHECKPOINT)\n+                .env(TEST_VAR_NAME + 1, BEFORE_CHECKPOINT);\n+        builder.doCheckpoint();\n+        builder.env(TEST_VAR_NAME + 1, AFTER_RESTORE);\n+        builder.env(TEST_VAR_NAME + 2, NEW_VALUE);\n+        builder.doRestore().outputAnalyzer()\n+                .shouldContain(PREFIX + TEST_VAR_NAME + \"0=\" + BEFORE_CHECKPOINT)\n+                .shouldContain(PREFIX + TEST_VAR_NAME + \"1=\" + AFTER_RESTORE)\n+                .shouldContain(PREFIX + TEST_VAR_NAME + \"2=\" + NEW_VALUE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        for (int i = 0; i < 3; ++i) {\n+            var testVar = java.lang.System.getenv(TEST_VAR_NAME + i);\n+            System.out.println(\"(before checkpoint) \" + TEST_VAR_NAME + i + \"=\" + testVar);\n+        }\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        for (int i = 0; i < 3; ++i) {\n+            var testVar = java.lang.System.getenv(TEST_VAR_NAME + i);\n+            System.out.println(PREFIX + TEST_VAR_NAME + i + \"=\" + testVar + \"\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RestoreEnvironmentTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.IOException;\n+import java.security.SecureRandom;\n+\n+\/*\n+ * @test\n+ * @summary Verify that secure random is not interlocked during checkpoint\/restore.\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build InterlockTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest SHA1PRNG 100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest NativePRNGNonBlocking 100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest NativePRNG 100\n+ *\/\n+\n+\/* NativePRNGBlocking is exluded as on some machines \/dev\/random is exhausted\n+ * too soon, making the test running too long. *\/\n+\n+public class InterlockTest implements Resource, CracTest {\n+    private static final long MIN_TIMEOUT = 100;\n+    private static final long MAX_TIMEOUT = 1000;\n+\n+    private boolean stop = false;\n+    private SecureRandom sr;\n+\n+    @CracTestArg(0)\n+    String algName;\n+\n+    @CracTestArg(1)\n+    int numThreads;\n+\n+    private class TestThread1 extends Thread {\n+        @Override\n+        public void run() {\n+            while (!stop) {\n+                set();\n+            }\n+        }\n+    };\n+\n+    private class TestThread2 extends Thread implements Resource {\n+        private final SecureRandom sr;\n+\n+        synchronized void set() {\n+            sr.nextInt();\n+        }\n+        synchronized void clean() {\n+            sr.nextInt();\n+        }\n+\n+        TestThread2() throws Exception {\n+            sr = SecureRandom.getInstance(algName);\n+            Core.getGlobalContext().register(this);\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!stop) {\n+                set();\n+            }\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            clean();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            set();\n+        }\n+    };\n+\n+    synchronized void clean() {\n+        sr.nextInt();\n+    }\n+\n+    synchronized void set() {\n+        sr.nextInt();\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        try {\n+            clean();\n+        } catch(Exception e) {\n+            e.printStackTrace(System.out);\n+        };\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        set();\n+        stop = true;\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        sr = SecureRandom.getInstance(algName);\n+        Core.getGlobalContext().register(this);\n+\n+        Thread[] threads = new Thread[numThreads];\n+        for(int i = 0; i < numThreads; i++) {\n+            threads[i] = (i % 2 == 0) ?\n+                    new TestThread1():\n+                    new TestThread2();\n+            threads[i].start();\n+        };\n+        Thread.sleep(MIN_TIMEOUT);\n+        set();\n+        Thread.sleep(MIN_TIMEOUT);\n+\n+        Object checkpointLock = new Object();\n+        Thread checkpointThread = new Thread(\"checkpointThread\") {\n+            public void run() {\n+                synchronized (checkpointLock) {\n+                    try {\n+                        jdk.crac.Core.checkpointRestore();\n+                    } catch (CheckpointException e) {\n+                        throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+                    } catch (RestoreException e) {\n+                        throw new RuntimeException(\"Restore ERROR \" + e);\n+                    }\n+                    checkpointLock.notify();\n+                }\n+            }\n+        };\n+        synchronized (checkpointLock) {\n+            try {\n+                checkpointThread.start();\n+                checkpointLock.wait(MAX_TIMEOUT * 2);\n+            } catch(Exception e){\n+                throw new RuntimeException(\"Checkpoint\/Restore ERROR \" + e);\n+            }\n+        }\n+        Thread.sleep(MAX_TIMEOUT);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/InterlockTest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.security.SecureRandom;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertNotEquals;\n+\n+\/*\n+ * @test\n+ * @summary Verify that SHA1PRNG secure random is reseeded after restore if initialized with default seed.\n+ * @library \/test\/lib\n+ * @build ReseedTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest true\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest false\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class ReseedTest implements CracTest {\n+    @CracTestArg\n+    boolean reseed;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.doCheckpoint();\n+        builder.captureOutput(true);\n+        String e1 = builder.doRestore().outputAnalyzer().getStdout();\n+        String e2 = builder.doRestore().outputAnalyzer().getStdout();\n+        if (reseed) {\n+            assertEquals(e1, e2);\n+        } else {\n+            assertNotEquals(e1, e2);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n+        if (reseed) {\n+            sr.setSeed(sr.generateSeed(10));\n+        }\n+        sr.nextInt();\n+\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            e.printStackTrace(System.out);\n+            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+        } catch (RestoreException e) {\n+            throw new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+\n+        System.out.println(sr.nextInt());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/ReseedTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+\n+import java.io.IOException;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.SocketChannel;\n+\n+class ChannelResource implements Resource {\n+\n+    public enum SelectionType {\n+        SELECT,\n+        SELECT_TIMEOUT,\n+        SELECT_NOW\n+    };\n+\n+    private SocketChannel channel;\n+    private SelectionKey key;\n+    private Selector selector;\n+\n+    private final SelectionType selType;\n+\n+    public ChannelResource(SelectionType selType) {\n+        this.selType = selType;\n+        Core.getGlobalContext().register(this);\n+    }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_READ);\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+        channel.socket().close();\n+\n+        \/\/ causes the channel deregistration\n+        if (selType == SelectionType.SELECT_NOW) {\n+            selector.selectNow();\n+        } else if (selType == SelectionType.SELECT_TIMEOUT) {\n+            selector.select(500);\n+        } else {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        Thread.sleep(1000);\n+                        selector.wakeup();\n+                    } catch (InterruptedException ie) {\n+                        throw new RuntimeException(ie);\n+                    }\n+                }\n+            }).start();\n+\n+            selector.select();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/ChannelResource.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+\/*\n+ * @test Selector\/Test970\n+ * @summary a regression test for ZE-970 (\"a channel deregistration\n+ *          is locked depending on mutual order of selector and channel creation\")\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build ChannelResource\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW false\n+ * @run driver jdk.test.lib.crac.CracTest SELECT true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT false\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT false\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg(0)\n+    ChannelResource.SelectionType selType;\n+\n+    @CracTestArg(1)\n+    boolean openSelectorAtFirst;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        if (openSelectorAtFirst) {\n+\n+            Selector selector = Selector.open();\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            ch.register(selector);\n+\n+            Core.checkpointRestore();\n+\n+            selector.close();\n+\n+        } else { \/\/ try in other order (see ZE-970)\n+\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            Selector selector = Selector.open();\n+            ch.register(selector);\n+\n+            Core.checkpointRestore();\n+\n+            selector.close();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+\/*\n+ * @test Selector\/interruptedSelection\n+ * @summary check that the thread blocked by Selector.select() could be properly woken up by an interruption\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  false false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false false false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  true\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg(0)\n+    boolean setTimeout;\n+\n+    @CracTestArg(1)\n+    boolean interruptBeforeCheckpoint;\n+\n+    @CracTestArg(2)\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    \/\/ select(): interrupt before the checkpoint\n+    @Override\n+    public void exec() throws Exception {\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {  try {\n+                if (setTimeout) { selector.select(3600_000); }\n+                else { selector.select(); }\n+            } catch (IOException e) { throw new RuntimeException(e); }   }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+\n+        Thread.sleep(1000);\n+\n+        if (interruptBeforeCheckpoint) {\n+            t.interrupt();\n+            t.join();\n+            System.out.println(\">> interrupt before checkpoint\");\n+        }\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        if (!interruptBeforeCheckpoint) {\n+            t.interrupt();\n+            t.join();\n+            System.out.println(\">>> interrupt after restore\");\n+        }\n+\n+        \/\/ just in case, check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/Selector\/interruptedSelection\/Test.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+\n+import java.io.IOException;\n+import java.nio.channels.CancelledKeyException;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.SocketChannel;\n+\n+class ChannelResource implements Resource {\n+\n+    private SocketChannel channel;\n+    private SelectionKey key;\n+    private Selector selector;\n+\n+    private Object att = new Integer(123);\n+\n+    public ChannelResource() {\n+        Core.getGlobalContext().register(this);\n+    }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_CONNECT);\n+        key.attach(att);\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+        channel.socket().close(); \/\/ close the channel => cancel the key\n+        check(!channel.isOpen(), \"the channel should not be open\");\n+        selector.select(100); \/\/ causes the channel deregistration\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        \/\/ the key is cancelled\n+        check(!key.isValid(), \"expected: key.isValid() == false\");\n+\n+        boolean caught = false;\n+        try {\n+            key.readyOps();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.interestOps();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.interestOps(SelectionKey.OP_CONNECT);\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.readyOps();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isReadable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isWritable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isConnectable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isAcceptable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        check(att.equals(key.attachment()), \"invalid key.attachment()\");\n+\n+        key.cancel(); \/\/ try just in case\n+\n+        \/\/ register again\n+        try {\n+            channel = SocketChannel.open();\n+            channel.configureBlocking(false);\n+            key = channel.register(selector, SelectionKey.OP_READ);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ to check after restore\n+    public void checkKey() {\n+\n+        check(key.isValid(), \"key must be valid\");\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        key.isReadable(); \/\/ just call, cannot set \"ready\" state manually\n+        check(!key.isWritable(), \"invalid key.isWritable()\");\n+        check(!key.isConnectable(), \"invalid key.isConnectable()\");\n+        check(!key.isAcceptable(), \"invalid key.isAcceptable()\");\n+\n+        check(key.interestOps() == SelectionKey.OP_READ, \"invalid key.interestOps()\");\n+\n+        System.out.println(\">> ready >> \" + key.readyOps());\n+\n+        check(key.attachment() == null, \"key.attachment() expected to be null\");\n+\n+        key.cancel(); \/\/ try just in case\n+    }\n+\n+    private void check(boolean b, String msg) {\n+        if (!b) {\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/ChannelResource.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+\/*\n+ * @test Selector\/keyAfterRestore\n+ * @summary a trivial test for SelectionKey's state after restore\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build ChannelResource\n+ * @build Test\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg\n+    boolean openSelectorAtFirst;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ChannelResource ch;\n+        Selector selector = null;\n+\n+        \/\/ check various order (see ZE-970)\n+        if (openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch = new ChannelResource();\n+        ch.open();\n+\n+        if (!openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch.register(selector);\n+\n+        try {\n+            Core.checkpointRestore();\n+        } catch (CheckpointException | RestoreException e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+\n+        Thread.sleep(200);\n+\n+        ch.checkKey();\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+import java.util.Random;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test Selector\/multipleSelect\n+ * @summary check work of multiple select() + wakeup() + C\/R\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED true\n+ *\/\n+public class Test implements CracTest {\n+\n+    private final static Random RND = new Random();\n+\n+    private final static long LONG_TIMEOUT = 3600_000;\n+    private final static long SHORT_TIMEOUT = 3_000;\n+\n+    public enum TestType {\n+        NO_TIMEOUTS,    \/\/ test only select(), wakeup\n+        ONLY_TIMEOUTS,  \/\/ test only select(timeout), do not call wakeup()\n+        MIXED};\n+\n+    @CracTestArg(0)\n+    TestType type;\n+\n+    @CracTestArg(1)\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        long dt = (type == TestType.ONLY_TIMEOUTS) ? SHORT_TIMEOUT : LONG_TIMEOUT;\n+\n+        int nThreads = (type == TestType.ONLY_TIMEOUTS) ? 5 : 20;\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        Thread selectThreads[] = new Thread[nThreads];\n+\n+        boolean setTimeout[] = new boolean[nThreads];\n+        for (int i = 0; i < nThreads; ++i) {\n+            boolean t = false; \/\/ NO_TIMEOUTS\n+            if (type == TestType.ONLY_TIMEOUTS) { t = true; }\n+            else if (type == TestType.MIXED) { t = RND.nextBoolean(); }\n+            setTimeout[i] = t;\n+        }\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < nThreads; ++i) {\n+\n+                    boolean timeout = setTimeout[i];\n+\n+                    selectThreads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                int n = nSelected.incrementAndGet();\n+                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                                if (timeout) { selector.select(dt); }\n+                                else { selector.select(); }\n+                                nSelected.decrementAndGet();\n+                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    selectThreads[i].start();\n+                    try { Thread.sleep(200); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread t = new Thread(rStart);\n+        t.start();\n+        Thread.sleep(500);\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        t.join();\n+        Thread.sleep(1000);\n+\n+        if (type == TestType.ONLY_TIMEOUTS) { \/\/ do not wake threads up, the timeouts must work\n+\n+            while (nSelected.get() > 0) { Thread.sleep(1000); }\n+\n+        } else {\n+\n+            int nWakeups = 0;\n+            while (true) {\n+\n+                int nBefore = nSelected.get();\n+                if (nBefore == 0) { break; }\n+\n+                System.out.println(\">> wakeup() #\" + (nWakeups + 1));\n+                ++nWakeups;\n+\n+                selector.wakeup();\n+                while (nSelected.get() == nBefore) { \/\/ wait until any select() would be woken up\n+                    Thread.sleep(500);\n+                }\n+            }\n+\n+            if (nWakeups > nThreads) {\n+                selector.close();\n+                throw new RuntimeException(\"invalid number of wakeups\");\n+            }\n+        }\n+\n+        \/\/ just in case...\n+        for (Thread st: selectThreads) { st.join(); }\n+\n+        \/\/ === check that the selector works as expected ===\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelect\/Test.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test Selector\/multipleSelectNow\n+ * @summary check work of multiple selectNow() + C\/R peaceful coexistence\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ *\/\n+public class Test implements CracTest {\n+\n+    @CracTestArg\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        int nThreads = skipCR ? 30 : 150; \/\/ some selectNow() calls should occur at the same time with C\/R\n+        Thread threads[] = new Thread[nThreads];\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < threads.length; ++i) {\n+\n+                    threads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                System.out.println(\"selectNow\");\n+                                nSelected.incrementAndGet();\n+                                selector.selectNow();\n+                                System.out.println(\"done\");\n+                                nSelected.decrementAndGet();\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    threads[i].start();\n+                    try { Thread.sleep(5); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread tStart = new Thread(rStart);\n+        tStart.start();\n+        Thread.sleep(500);\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        tStart.join();\n+\n+        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n+        for (Thread t: threads) { t.join(); } \/\/ just in case...\n+\n+        \/\/ === check that the selector works as expected ===\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectNow\/Test.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.nio.channels.ClosedSelectorException;\n+import java.io.IOException;\n+import java.util.Random;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test Selector\/multipleSelectSingleClose\n+ * @summary check a coexistence of multiple select() + C\/R in case when the selector is finally closed\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ * @run driver jdk.test.lib.crac.CracTest true  true\n+ *\/\n+public class Test implements CracTest {\n+    private final static Random RND = new Random();\n+\n+    @CracTestArg(0)\n+    boolean skipCR;\n+\n+    @CracTestArg(1)\n+    boolean closeBeforeCheckpoint;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        int nThreads = 20;\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        Thread selectThreads[] = new Thread[nThreads];\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < nThreads; ++i) {\n+\n+                    selectThreads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                boolean timeout = RND.nextBoolean();\n+                                int n = nSelected.incrementAndGet();\n+                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                                if (timeout) { selector.select(10 + RND.nextInt(7_000)); }\n+                                else { selector.select(); }\n+                                nSelected.decrementAndGet();\n+                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                            } catch (ClosedSelectorException e) {\n+                                System.out.println(\">> ClosedSelectorException\"); \/\/ expected when the selector is closed\n+                                nSelected.decrementAndGet();\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    selectThreads[i].start();\n+                    try { Thread.sleep(50); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread tStart = new Thread(rStart);\n+        tStart.start();\n+        Thread.sleep(500);\n+\n+        if (closeBeforeCheckpoint) {\n+            tStart.join();\n+            Thread.sleep(1000);\n+            selector.close();\n+        }\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        if (!closeBeforeCheckpoint) {\n+            tStart.join();\n+            Thread.sleep(1000);\n+            selector.close();\n+        }\n+\n+        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n+\n+        if (nSelected.get() < 0) { throw new RuntimeException(\"negative nSelected??\"); }\n+\n+        \/\/ just in case...\n+        for (Thread t: selectThreads) { t.join(); }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectSingleClose\/Test.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.IOException;\n+import java.nio.channels.Selector;\n+\n+\/*\n+ * @test Selector\/selectAfterWakeup\n+ * @summary check that the Selector's wakeup() makes the subsequent select() call to return immediately\n+ *          (see also jdk\/test\/java\/nio\/channels\/Selector\/WakeupSpeed.java);\n+ *          covers ZE-983\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest true  false false\n+ * @run driver jdk.test.lib.crac.CracTest true  false true\n+ * @run driver jdk.test.lib.crac.CracTest true  true  false\n+ * @run driver jdk.test.lib.crac.CracTest true  true  true\n+ * @run driver jdk.test.lib.crac.CracTest false true  false\n+ * @run driver jdk.test.lib.crac.CracTest false true  true\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg(0)\n+    boolean wakeupBeforeCheckpoint;\n+\n+    @CracTestArg(1)\n+    boolean wakeupAfterRestore;\n+\n+    @CracTestArg(2)\n+    boolean setSelectTimeout;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        Selector selector = Selector.open();\n+\n+        \/\/ do this just in case\n+        selector.wakeup();\n+        selector.select();\n+\n+        if (wakeupBeforeCheckpoint) {\n+            selector.wakeup();\n+        }\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        if (wakeupAfterRestore) {\n+            selector.wakeup();\n+        }\n+        if (setSelectTimeout) { selector.select(3600_000); }\n+        else { selector.select(); }\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAfterWakeup\/Test.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.channels.Selector;\n+\n+\/*\n+ * @test Selector\/selectAndWakeupAfterRestore\n+ * @summary a trivial check that Selector.wakeup() after restore behaves as expected\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class Test implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    private static void selectAndWakeup(Selector selector) throws java.io.IOException {\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    Thread.sleep(7000);\n+                    System.out.println(\">> waking up\");\n+                    selector.wakeup();\n+                } catch (InterruptedException ie) { throw new RuntimeException(ie); }\n+            }\n+        }).start();\n+\n+        System.out.println(\">> selecting\");\n+        selector.select();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        Selector selector = Selector.open();\n+\n+        selectAndWakeup(selector); \/\/ just in case\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        selectAndWakeup(selector);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAndWakeupAfterRestore\/Test.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+\/*\n+ * @test Selector\/wakeupAfterRestore\n+ * @summary check that the thread blocked by Selector.select() on checkpoint could be properly woken up after restore\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ *\/\n+public class Test implements CracTest {\n+\n+    private final static long TIMEOUT = 3600_000; \/\/ looong timeout\n+\n+    static boolean awakened;\n+\n+    @CracTestArg\n+    boolean setTimeout;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                System.out.println(\">> select, setTimeout = \" + setTimeout);\n+                try {\n+                    awakened = false;\n+                    if (setTimeout) { selector.select(TIMEOUT); }\n+                    else { selector.select(); }\n+                    awakened = true;\n+                } catch (IOException e) { throw new RuntimeException(e); }\n+            }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+        Thread.sleep(1000);\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        System.out.print(\">> waking up: \");\n+        selector.wakeup();\n+        t.join();\n+        System.out.println(\"done\");\n+\n+        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n+\n+        \/\/ check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupAfterRestore\/Test.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+\/*\n+ * @test Selector\/wakeupByClose\n+ * @summary check that the Selector's close() wakes it up after restore\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest true  false\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ * @run driver jdk.test.lib.crac.CracTest true  true\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ *\/\n+public class Test implements CracTest {\n+\n+    static boolean awakened, closed;\n+\n+    @CracTestArg(0)\n+    boolean setTimeout;\n+\n+    @CracTestArg(1)\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Selector selector = Selector.open();\n+\n+        Thread tSelect = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        awakened = false;\n+                        if (setTimeout) { selector.select(3600_000); }\n+                        else { selector.select(); }\n+                        awakened = true;\n+                    } catch (IOException e) { throw new RuntimeException(e); }\n+                }\n+            });\n+        tSelect.start();\n+\n+        Thread.sleep(3000);\n+\n+        if (!skipCR) { jdk.crac.Core.checkpointRestore(); }\n+\n+        \/\/ close() must wakeup the selector\n+        Thread tClose = new Thread(new Runnable() {\n+\n+                @Override\n+                public void run() {\n+                    try {\n+                        closed = false;\n+                        selector.close();\n+                        closed = true;\n+                    } catch (IOException e) { throw new RuntimeException(e); }\n+                }\n+            });\n+        tClose.start();\n+        tClose.join();\n+        tSelect.join();\n+\n+        if (!awakened) {\n+            selector.wakeup();\n+            throw new RuntimeException(\"selector did not wake up\");\n+        }\n+\n+        if (!closed) {\n+            selector.close();\n+            throw new RuntimeException(\"selector did not close\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByClose\/Test.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+\/*\n+ * @test Selector\/wakeupByTimeoutAfterRestore\n+ * @summary check that the Selector selected before the checkpoint,\n+ *          will wake up by timeout after the restore\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class Test implements CracTest {\n+\n+    private final static long TIMEOUT = 40_000; \/\/ 40 seconds\n+\n+    static boolean awakened = false;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    selector.select(TIMEOUT);\n+                    awakened = true;\n+                } catch (IOException e) { throw new RuntimeException(e); }\n+            }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+        Thread.sleep(1000);\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        t.join();\n+        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n+\n+        \/\/ check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByTimeoutAfterRestore\/Test.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import com.sun.management.VMOption;\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.lang.management.ManagementFactory;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build VMOptionsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class VMOptionsTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        \/\/ this is here just to test passing CREngine params\n+        builder.engine(CracEngine.CRIU, \"--verbosity=4\", \"--log-file=\/dev\/null\");\n+        builder.vmOption(\"-XX:NativeMemoryTracking=off\");\n+        builder.doCheckpoint();\n+        builder.clearVmOptions();\n+        builder.vmOption(\"-XX:CRaCCheckpointTo=another\"); \/\/ manageable\n+        builder.vmOption(\"-XX:CRaCIgnoredFileDescriptors=42,43\"); \/\/ restore_settable\n+        builder.doRestore();\n+        \/\/ Setting non-manageable option\n+        builder.vmOption(\"-XX:NativeMemoryTracking=summary\");\n+        assertEquals(1, builder.startRestore().waitFor());\n+    }\n+\n+    @Override\n+    public void exec() throws RestoreException, CheckpointException {\n+        {\n+            HotSpotDiagnosticMXBean bean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+            VMOption checkpointTo1 = bean.getVMOption(\"CRaCCheckpointTo\");\n+            assertEquals(\"cr\", checkpointTo1.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, checkpointTo1.getOrigin());\n+            VMOption nmt1 = bean.getVMOption(\"NativeMemoryTracking\");\n+            assertEquals(\"off\", nmt1.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, nmt1.getOrigin());\n+        }\n+\n+        Core.checkpointRestore();\n+\n+        {\n+            HotSpotDiagnosticMXBean bean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+            VMOption checkpointTo2 = bean.getVMOption(\"CRaCCheckpointTo\");\n+            assertEquals(\"another\", checkpointTo2.getValue());\n+            assertEquals(VMOption.Origin.OTHER, checkpointTo2.getOrigin());\n+            VMOption ignoredFileDescriptors = bean.getVMOption(\"CRaCIgnoredFileDescriptors\");\n+            assertEquals(\"42,43\", ignoredFileDescriptors.getValue());\n+            assertEquals(VMOption.Origin.OTHER, ignoredFileDescriptors.getOrigin());\n+            VMOption nmt = bean.getVMOption(\"NativeMemoryTracking\");\n+            assertEquals(\"off\", nmt.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, nmt.getOrigin());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/VMOptionsTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+import java.io.RandomAccessFile;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * This test includes two behaviours:\n+ * 1) inheriting open FD from parent process: this is achieved using EXTRA_FD_WRAPPER\n+ *    - any excess inherited FDs should be closed when JVM starts.\n+ * 2) open files on classpath: these files are ignored, handling is left to CREngine\n+ *\n+ * @test\n+ * @library \/test\/lib\n+ * @build CheckpointWithOpenFdsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class CheckpointWithOpenFdsTest implements CracTest {\n+    private static final String EXTRA_FD_WRAPPER = Path.of(Utils.TEST_SRC, \"extra_fd_wrapper.sh\").toString();\n+\n+    @CracTestArg(optional = true, value = 0)\n+    String relativePathToSomeJar;\n+\n+    @CracTestArg(optional = true, value = 1)\n+    String absolutePathToSomeJar;\n+\n+    @Override\n+    public void test() throws Exception {\n+        List<Path> jars = Arrays.stream(System.getProperty(\"java.class.path\").split(File.pathSeparator))\n+                .filter(p -> p.endsWith(\".jar\")).map(Path::of).toList();\n+        assertGreaterThanOrEqual(jars.size(), 2); \/\/ usually we have at least javatest.jar and jtreg.jar\n+        assertTrue(jars.stream().allMatch(jar -> jar.toFile().exists()));\n+        Path firstJar = jars.get(0);\n+        Path secondJar = jars.get(1);\n+        assertTrue(secondJar.isAbsolute());\n+        Path cwd = Path.of(System.getProperty(\"user.dir\"));\n+        String relative = cwd.relativize(firstJar).toString();\n+        String absolute = secondJar.toString();\n+\n+        CracBuilder builder = new CracBuilder();\n+        builder.classpathEntry(relative).classpathEntry(absolute).args(CracTest.args(relative, absolute));\n+        builder.startCheckpoint(Arrays.asList(EXTRA_FD_WRAPPER, CracBuilder.JAVA)).waitForCheckpointed();\n+        builder.captureOutput(true).doRestore().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        String absolute = Path.of(relativePathToSomeJar).toAbsolutePath().toString();\n+\n+        Path cwd = Path.of(System.getProperty(\"user.dir\"));\n+        String relative = cwd.relativize(Path.of(absolutePathToSomeJar)).toString();\n+        try (var file1 = new RandomAccessFile(absolute, \"r\");\n+             var file2 = new RandomAccessFile(relative, \"r\")) {\n+            Core.checkpointRestore();\n+            System.out.println(RESTORED_MESSAGE);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CheckpointWithOpenFdsTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+import java.io.IOException;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @run driver ClasspathParseTest\n+ *\/\n+public class ClasspathParseTest {\n+    public static final String JAVA = Utils.TEST_JDK + \"\/bin\/java\";\n+\n+    public static void main(String[] args) throws IOException, InterruptedException {\n+        if (args.length == 0) {\n+            String classpath = ClasspathParseTest.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n+            int exit = new ProcessBuilder().command(JAVA, \"-cp\", classpath, ClasspathParseTest.class.getName(), \"ignored\")\n+                    .inheritIO().start().waitFor();\n+            assertEquals(0, exit);\n+        } else {\n+            \/\/ assert that code source path started with \"\/\" as we expect (even on Windows)\n+            if (!System.getProperty(\"java.class.path\").startsWith(\"\/\")) {\n+                System.exit(2);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ClasspathParseTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build CloseProcessPipeTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseProcessPipeTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: pipe\n+                action: close\n+                \"\"\");\n+        try {\n+            CracBuilder builder = new CracBuilder()\n+                    .javaOption(JDKFdResource.COLLECT_FD_STACKTRACES_PROPERTY, \"true\")\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString());\n+            builder.doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Process process = new ProcessBuilder().command(\"cat\", \"\/dev\/zero\").start();\n+        byte[] buffer = new byte[1024];\n+        int read1 = process.getInputStream().read(buffer);\n+        assertGreaterThan(read1, 0);\n+        Core.checkpointRestore();\n+        int read2, total = read1;\n+        \/\/ Some data might got buffered from \/dev\/zero, we will still read those.\n+        try {\n+            while ((read2 = process.getInputStream().read(buffer)) >= 0) {\n+                total += read2;\n+            }\n+            fail(\"Should have failed\");\n+        } catch (IOException e) {\n+            \/\/ the exception comes from native method\n+        }\n+        System.err.printf(\"Read total %d bytes%n\", total);\n+        \/\/ The process will end with SIGPIPE\n+        assertEquals(141, process.waitFor());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseProcessPipeTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build CloseTcpSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseTcpSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+        Path config = writeConfig(\"\"\"\n+                type: SOCKET\n+                family: ip\n+                localAddress: $loopback\n+                action: close\n+                \"\"\".replace(\"$loopback\", loopback));\n+        try {\n+            new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseTcpSocketTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build CloseUdpSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseUdpSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+        Path config = writeConfig(\"\"\"\n+                type: socket\n+                localAddress: $loopback\n+                action: close\n+                \"\"\".replace(\"$loopback\", loopback));\n+        try {\n+            new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (DatagramSocket serverSocket = new DatagramSocket(0, InetAddress.getLoopbackAddress())) {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            Thread serverThread = new Thread(() -> {\n+                try {\n+                    byte[] buf = new byte[1024];\n+                    DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+                    serverSocket.receive(packet);\n+                    latch.countDown();\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            serverThread.setDaemon(true);\n+            serverThread.start();\n+            try (DatagramSocket clientSocket = new DatagramSocket()) {\n+                clientSocket.connect(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+                byte[] buf = \"Hello\".getBytes();\n+                clientSocket.send(new DatagramPacket(buf, buf.length));\n+                latch.await();\n+                Core.checkpointRestore();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseUdpSocketTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build CloseUnixSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseUnixSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: SoCkEt\n+                action: close\n+                family: unix\n+                \"\"\");\n+        try {\n+            new CracBuilder()\n+                    .javaOption(JDKFdResource.COLLECT_FD_STACKTRACES_PROPERTY, \"true\")\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Path socketFile = Files.createTempFile(CloseUnixSocketTest.class.getSimpleName(), \".socket\");\n+        Files.deleteIfExists(socketFile);\n+        UnixDomainSocketAddress address = UnixDomainSocketAddress.of(socketFile);\n+\n+        ServerSocketChannel serverChannel = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        serverChannel.bind(address);\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                SocketChannel socket = serverChannel.accept();\n+                latch1.countDown();\n+                \/\/ We need to prevent SocketChannel getting out of scope and being\n+                \/\/ garbage collected. When this happens the file descriptor leaks.\n+                \/\/ It is not up to CRaC to handle leaked descriptors.\n+                latch2.await();\n+            } catch (IOException | InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        SocketChannel clientChannel = SocketChannel.open(StandardProtocolFamily.UNIX);\n+        assertTrue(clientChannel.connect(address));\n+        latch1.await();\n+        Core.checkpointRestore();\n+        latch2.countDown();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseUnixSocketTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+\n+public abstract class FDPolicyTestBase {\n+\n+    protected void writeBigFile(Path path, String prefix, String suffix) throws IOException {\n+        StringBuilder sb = new StringBuilder().append(prefix);\n+        \/\/ Let's use 8+ MB file to avoid hidden buffering in FileInputStream or native parts\n+        for (int i = 0; i < 1024 * 1024; ++i) {\n+            sb.append(String.format(\"%08X\", 8 * i));\n+        }\n+        sb.append(suffix);\n+        Files.writeString(path, sb.toString());\n+    }\n+\n+    protected void readContents(FileReader reader) throws IOException {\n+        char[] bigbuf = new char[1024 * 1024];\n+        for (int count = 0; count < 8 * 1024 * 1024; ) {\n+            int r = reader.read(bigbuf);\n+            assertGreaterThan(r, 8);\n+            assertEquals(String.format(\"%08X\", count), new String(bigbuf, 0, 8));\n+            count += r;\n+        }\n+    }\n+\n+    protected Path writeConfig(String content) throws IOException {\n+        Path config = Files.createTempFile(getClass().getName(), \".yaml\");\n+        Files.writeString(config, content);\n+        return config;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FDPolicyTestBase.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build IgnoredFileDescriptorsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class IgnoredFileDescriptorsTest implements CracTest {\n+    private static final String EXTRA_FD_WRAPPER = Path.of(Utils.TEST_SRC, \"extra_fd_wrapper.sh\").toString();\n+\n+    @Override\n+    public void test() throws Exception {\n+        List<String> prefix = new ArrayList<>();\n+        prefix.add(EXTRA_FD_WRAPPER);\n+        prefix.addAll(Arrays.asList(\"-o\", \"43\", \"\/dev\/stdout\"));\n+        prefix.addAll(Arrays.asList(\"-o\", \"45\", \"\/dev\/urandom\"));\n+        prefix.add(CracBuilder.JAVA);\n+        prefix.add(\"-XX:CRaCIgnoredFileDescriptors=43,\/dev\/null,44,\/dev\/urandom\");\n+\n+        CracBuilder builder = new CracBuilder();\n+        builder.startCheckpoint(prefix).waitForCheckpointed();\n+        builder.captureOutput(true).doRestore().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var stream = Files.list(Path.of(\"\/proc\/self\/fd\"))) {\n+            Map<Integer, String> fds = stream.filter(Files::isSymbolicLink)\n+                    .collect(Collectors.toMap(\n+                            f -> Integer.parseInt(f.toFile().getName()),\n+                            f -> {\n+                                try {\n+                                    return Files.readSymbolicLink(f).toFile().getAbsoluteFile().toString();\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            }));\n+            if (fds.containsKey(42)) {\n+                throw new IllegalStateException(\"Oh no, 42 was not supposed to be ignored\");\n+            } else if (!fds.containsKey(0) || !fds.containsKey(1) || !fds.containsKey(2)) {\n+                throw new IllegalStateException(\"Missing standard I\/O? Available: \" + fds);\n+            } else if (!fds.containsKey(43)) {\n+                throw new IllegalStateException(\"Missing FD 43\");\n+            } else if (!fds.containsValue(\"\/dev\/urandom\")) {\n+                throw new IllegalStateException(\"Missing \/dev\/urandom\");\n+            }\n+        }\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/IgnoredFileDescriptorsTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build LoggingFileOpenTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class LoggingFileOpenTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        Path gcPath = Files.createTempFile(getClass().getName(), \"-gc.txt\");\n+        try {\n+            CracBuilder builder = new CracBuilder()\n+                    .vmOption(\"-Xlog:gc:\" + gcPath);\n+            builder.startCheckpoint().waitForCheckpointed();\n+            var oa =builder.captureOutput(true).doRestore().outputAnalyzer()\n+                    .shouldNotContain(\"CRaC closing file descriptor\")\n+                    .shouldNotContain(\"Could not flush log\")\n+                    .shouldNotContain(\"Could not close log file\")\n+                    .shouldNotContain(\"Bad file descriptor\")\n+                    .shouldContain(RESTORED_MESSAGE);\n+        } finally {\n+            Files.deleteIfExists(gcPath);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/LoggingFileOpenTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.RandomAccessFile;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build OpenFileDetectionTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class OpenFileDetectionTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder().engine(CracEngine.SIMULATE).captureOutput(true)\n+                .javaOption(\"jdk.crac.collect-fd-stacktraces\", \"true\")\n+                .startCheckpoint();\n+        cp.outputAnalyzer()\n+                .shouldHaveExitValue(1)\n+                .shouldMatch(\"CheckpointOpenFileException: filename1.txt\") \/\/ RandomAccessFile should have the expected format\n+                .shouldMatch(\"filename2.txt\") \/\/ others are allowed to specify the path in some format\n+                .shouldContain(\"This file descriptor was created by \"); \/\/ <thread> at <time> here\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        new File(\"filename1.txt\").createNewFile();\n+        new File(\"filename2.txt\").createNewFile();\n+\n+        try (var file1 = new RandomAccessFile(\"filename1.txt\", \"r\");\n+             var file2 = new FileInputStream(\"filename2.txt\")) {\n+            Core.checkpointRestore();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenFileDetectionTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build OpenSocketDetectionTest\n+ * @run driver\/timeout=10 jdk.test.lib.crac.CracTest\n+ *\/\n+public class OpenSocketDetectionTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder().engine(CracEngine.SIMULATE).captureOutput(true)\n+                .startCheckpoint();\n+        cp.outputAnalyzer()\n+                .shouldHaveExitValue(1)\n+                .shouldMatch(\"CheckpointOpenSocketException: [A-Za-z0-9.$]+\\\\[addr=[A-Za-z0-9\/:.]+,port=[0-9]+,localport=[0-9]+\\\\]\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenSocketDetectionTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build ProcessPipelineTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ProcessPipelineTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        List<ProcessBuilder> pipeline = IntStream.range(0, 3)\n+                .mapToObj(ignored -> new ProcessBuilder().command(\"cat\")\n+                        .redirectError(ProcessBuilder.Redirect.DISCARD)).toList();\n+        \/\/ The pipeline creates several FDs to connect the subprocesses,\n+        \/\/ but all of them should be closed (in this process) when the method returns.\n+        List<Process> processes = ProcessBuilder.startPipeline(pipeline);\n+        try (\n+                var writer = new OutputStreamWriter(processes.get(0).getOutputStream());\n+                var reader = new BufferedReader(new InputStreamReader(processes.get(2).getInputStream()))\n+        ) {\n+            writer.write(\"Hello world\\n\");\n+            writer.flush();\n+            assertEquals(\"Hello world\", reader.readLine());\n+            try {\n+                Core.checkpointRestore();\n+                fail(\"Should have failed\");\n+            } catch (CheckpointException e) {\n+                \/\/ One for pipe to the first process, another for pipe from the last\n+                assertEquals(2, e.getSuppressed().length);\n+            }\n+        }\n+        \/\/ This time it should succeed\n+        Core.checkpointRestore();\n+        assertEquals(0, processes.get(0).waitFor());\n+        assertEquals(0, processes.get(1).waitFor());\n+        assertEquals(0, processes.get(2).waitFor());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ProcessPipelineTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.RestoreException;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.fail;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenFailureTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFailureTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String log1;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String log2;\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: file\n+                action: reopen\n+                \"\"\");\n+        Path path1 = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path path2 = Files.createTempFile(getClass().getName(), \".txt\");\n+        log1 = path1.toString();\n+        log2 = path2.toString();\n+        try {\n+            CracBuilder builder = new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .args(CracTest.args(log1, log2));\n+            builder.doCheckpoint();\n+            Files.delete(path1);\n+            Files.setPosixFilePermissions(path2, Collections.emptySet());\n+            builder.doRestore();\n+        } finally {\n+            Files.deleteIfExists(path1);\n+            Files.deleteIfExists(path2);\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var writer1 = new FileWriter(log1);\n+             var writer2 = new FileWriter(log2, true)) {\n+            writer1.write(\"Hello!\");\n+            writer1.flush();\n+            writer2.write(\"Hello!\");\n+            writer2.flush();\n+            try {\n+                Core.checkpointRestore();\n+                fail(\"Should throw\");\n+            } catch (RestoreException ex) {\n+                \/\/ When running this as root we get only one exception for the missing file\n+                if (Files.isWritable(Path.of(log2))) {\n+                    assertEquals(1, ex.getSuppressed().length);\n+                } else {\n+                    assertEquals(2, ex.getSuppressed().length);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFailureTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenFileReadingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileReadingTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(optional = true)\n+    String tempFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        tempFile = Files.createTempFile(getClass().getName(), \".txt\").toString();\n+        Path configFile = writeConfig(\"\"\"\n+                # These first two rules are just to test parsing\n+                type: FILE\n+                path: \/some\/other\/file\n+                action: error\n+                ---\n+                type: FILE\n+                path: **\/*.globpattern.test\n+                action: CLOSE\n+                ---\n+                type: FILE\n+                path: $tempFile\n+                # action is case-insensitive\n+                action: ReOpeN\n+                ---\n+                \"\"\".replace(\"$tempFile\", tempFile));\n+        Path tempPath = Path.of(tempFile);\n+        try {\n+            writeBigFile(tempPath, \"Hello \", \"world!\");\n+            new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, configFile.toString())\n+                    .args(CracTest.args(tempFile)).doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(tempPath);\n+            Files.deleteIfExists(configFile);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(tempFile);\n+             var fis = new FileInputStream(tempFile)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+\n+            FileChannel channel = fis.getChannel();\n+            byte[] buf2 = new byte[3];\n+            ByteBuffer byteBuffer = ByteBuffer.wrap(buf2);\n+            readFully(channel, byteBuffer);\n+            assertEquals(\"Hel\", new String(buf2, StandardCharsets.UTF_8));\n+\n+            Core.checkpointRestore();\n+            readContents(reader);\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+\n+            readFully(channel, byteBuffer);\n+            assertEquals(\"lo \", new String(buf2, StandardCharsets.UTF_8));\n+\n+            channel.position(8 * 1024 * 1024 + 6);\n+            readFully(channel, byteBuffer);\n+            assertEquals(\"wor\", new String(buf2, StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    private static void readFully(FileChannel channel, ByteBuffer byteBuffer) throws IOException {\n+        byteBuffer.clear();\n+        while (byteBuffer.position() < byteBuffer.capacity()) {\n+            channel.read(byteBuffer);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileReadingTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenFileWritingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileWritingTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String fileNoAppend;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String fileAppend;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String fileAppendExtended;\n+\n+    @CracTestArg(value = 3, optional = true)\n+    String fileAppendTruncated;\n+\n+    @CracTestArg(value = 4, optional = true)\n+    String fileUseChannel;\n+\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path noAppendPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path appendPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path appendExtendedPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path appendTruncatedPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path useChannelPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        fileNoAppend = noAppendPath.toString();\n+        fileAppend = appendPath.toString();\n+        fileAppendExtended = appendExtendedPath.toString();\n+        fileAppendTruncated = appendTruncatedPath.toString();\n+        fileUseChannel = useChannelPath.toString();\n+        Path config = writeConfig(\"\"\"\n+                type: FILE\n+                action: reopen\n+                \"\"\");\n+        try {\n+            CracBuilder builder = new CracBuilder();\n+            builder\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .args(CracTest.args(fileNoAppend, fileAppend, fileAppendExtended, fileAppendTruncated, fileUseChannel));\n+            builder.doCheckpoint();\n+            assertEquals(\"Hello \", Files.readString(noAppendPath));\n+            assertEquals(\"Hello \", Files.readString(appendPath));\n+            assertEquals(\"Hello \", Files.readString(appendExtendedPath));\n+            assertEquals(\"Hello \", Files.readString(appendTruncatedPath));\n+            assertEquals(\"Hello \", Files.readString(useChannelPath));\n+            Files.writeString(noAppendPath, \"1234567890\");\n+            Files.writeString(appendPath, \"123456\");\n+            Files.writeString(appendExtendedPath, \"1234567890\");\n+            Files.writeString(appendTruncatedPath, \"\");\n+            Files.writeString(useChannelPath, \"123456\");\n+            builder.doRestore();\n+            assertEquals(\"123456world!\", Files.readString(noAppendPath));\n+            assertEquals(\"123456world!\", Files.readString(appendPath));\n+            assertEquals(\"1234567890world!\", Files.readString(appendExtendedPath));\n+            assertEquals(\"world!\", Files.readString(appendTruncatedPath));\n+            assertEquals(\"123world!\", Files.readString(useChannelPath));\n+        } finally {\n+            Files.deleteIfExists(noAppendPath);\n+            Files.deleteIfExists(appendPath);\n+            Files.deleteIfExists(appendExtendedPath);\n+            Files.deleteIfExists(appendTruncatedPath);\n+            Files.deleteIfExists(useChannelPath);\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var w1 = new FileWriter(fileNoAppend);\n+             var w2 = new FileWriter(fileAppend, true);\n+             var w3 = new FileWriter(fileAppendExtended, true);\n+             var w4 = new FileWriter(fileAppendTruncated, true);\n+             var fos5 = new FileOutputStream(fileUseChannel)) {\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"Hello \");\n+                    w.flush();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            FileChannel ch5 = fos5.getChannel();\n+            ch5.write(ByteBuffer.wrap(\"Hello \".getBytes(StandardCharsets.UTF_8)));\n+            Core.checkpointRestore();\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"world!\");\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            ch5.position(3);\n+            ch5.write(ByteBuffer.wrap(\"world!\".getBytes(StandardCharsets.UTF_8)));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileWritingTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenNamedFifoTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenNamedFifoTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(optional = true)\n+    String fifo;\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path tempDirectory = Files.createTempDirectory(getClass().getName());\n+        Path pipePath = tempDirectory.resolve(\"pipe\");\n+        fifo = pipePath.toString();\n+        assertEquals(0, new ProcessBuilder().inheritIO().command(\"mkfifo\", fifo).start().waitFor());\n+        \/\/ From Java POV this has a path, therefore is treated as a file and not as a named pipe\n+        Path config = writeConfig(\"\"\"\n+                type: file\n+                action: reopen\n+                \"\"\");\n+        CracBuilder builder = new CracBuilder()\n+                .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                .args(CracTest.args(fifo));\n+        CracProcess cp = builder.startCheckpoint();\n+\n+        try (var writer = new FileWriter(fifo)) {\n+            writer.write(\"Hello \");\n+            writer.flush();\n+            cp.waitForCheckpointed();\n+            CracProcess rp = builder.captureOutput(true).startRestore();\n+            CountDownLatch latch = new CountDownLatch(1);\n+            rp.watch(output -> {\n+                if (output.contains(\"RESTORED\")) {\n+                    latch.countDown();\n+                }\n+            }, error -> {\n+                System.err.println(error);\n+                latch.countDown();\n+            });\n+            latch.await();\n+            writer.write(\"world!\");\n+            writer.flush();\n+            rp.waitForSuccess();\n+        } finally {\n+            Files.deleteIfExists(pipePath);\n+            Files.deleteIfExists(tempDirectory);\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(fifo)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            System.out.println(\"RESTORED\");\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenNamedFifoTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @requires (os.family == \"linux\")\n+ * @build SharedLibraryTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class SharedLibraryTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder()\n+                .javaOption(\"test.jdk\", Utils.TEST_JDK);\n+        builder.copy().vmOption(\"-XX:NativeMemoryTracking=detail\").doCheckpoint();\n+        builder.doRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        checkNativeMemory();\n+        Core.checkpointRestore();\n+        checkNativeMemory();\n+    }\n+\n+    private static void checkNativeMemory() throws InterruptedException, IOException {\n+        String jcmd = Path.of(Utils.TEST_JDK, \"bin\", \"jcmd\").toString();\n+        assertEquals(0, new ProcessBuilder().inheritIO().redirectOutput(ProcessBuilder.Redirect.DISCARD).command(\n+                jcmd, String.valueOf(ProcessHandle.current().pid()), \"VM.native_memory\", \"detail\"\n+        ).start().waitFor());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/SharedLibraryTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+#!\/bin\/bash\n+# Java opens all files with O_CLOEXEC (or calls fcntl(FD_CLOEXEC)) so we cannot trigger this behaviour from Java code;\n+# this opens a file descriptor and executes subprocess based on its arguments.\n+FILE=$(mktemp -p \/dev\/shm)\n+exec 42<>$FILE\n+# criu uses DEFAULT_GHOST_LIMIT 1M - let's create a file bigger than that\n+dd if=\/dev\/urandom bs=4096 count=257 >&42 2>\/dev\/null\n+rm $FILE\n+# Open some extra files\n+while [ $1 = \"-o\" ]; do\n+  eval \"exec $2<>$3\"\n+  shift 3\n+done\n+exec \"$@\"\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/extra_fd_wrapper.sh","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.management.CRaCMXBean;\n+import jdk.test.lib.Container;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.RuntimeMXBean;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test NanoTimeTest\n+ * @requires (os.family == \"linux\")\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build NanoTimeTest\n+ * @run driver jdk.test.lib.crac.CracTest      0 true\n+ * @run driver jdk.test.lib.crac.CracTest  86400 true\n+ * @run driver jdk.test.lib.crac.CracTest -86400 true\n+ * @run driver jdk.test.lib.crac.CracTest  86400 false\n+ * @run driver jdk.test.lib.crac.CracTest -86400 false\n+ *\/\n+public class NanoTimeTest implements CracTest {\n+    @CracTestArg(0)\n+    long monotonicOffset;\n+\n+    @CracTestArg(1)\n+    boolean changeBootId;\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+        CracBuilder builder = new CracBuilder();\n+        Path bootIdFile = Files.createTempFile(\"NanoTimeTest-\", \"-boot_id\");\n+\n+        String imageName = Common.imageName(\"system-nanotime\");\n+\n+        try {\n+            \/\/ TODO: use more official image\n+            builder.withBaseImage(\"ghcr.io\/crac\/test-base\", \"latest\")\n+                    .dockerOptions(\"-v\", bootIdFile + \":\/fake_boot_id\")\n+                    .inDockerImage(imageName);\n+\n+            Files.writeString(bootIdFile, \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\n\");\n+            \/\/ We need to preload the library before checkpoint\n+            builder.doCheckpoint(Container.ENGINE_COMMAND, \"exec\",\n+                    \"-e\", \"LD_PRELOAD=\/opt\/path-mapping-quiet.so\",\n+                    \"-e\", \"PATH_MAPPING=\/proc\/sys\/kernel\/random\/boot_id:\/fake_boot_id\",\n+                    CracBuilder.CONTAINER_NAME,\n+                    \/\/ In case we are trying to use negative monotonic offset we could\n+                    \/\/ run into situation where we'd set it to negative value (prohibited).\n+                    \/\/ Therefore, we'll rather offset it to the future before checkpoint\n+                    \/\/ and set to 0 for restore.\n+                    \"unshare\", \"--fork\", \"--time\", \"--monotonic\", String.valueOf(Math.max(-monotonicOffset, 0)),\n+                    CracBuilder.DOCKER_JAVA);\n+\n+            if (changeBootId) {\n+                Files.writeString(bootIdFile, \"yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\\n\");\n+            }\n+\n+            builder.doRestore(Container.ENGINE_COMMAND, \"exec\", CracBuilder.CONTAINER_NAME,\n+                    \"unshare\", \"--fork\", \"--time\", \"--boottime\", \"86400\", \"--monotonic\", String.valueOf(Math.max(monotonicOffset, 0)),\n+                    CracBuilder.DOCKER_JAVA);\n+        } finally {\n+            builder.ensureContainerKilled();\n+            assertTrue(bootIdFile.toFile().delete());\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(\"Expected offset: \" + monotonicOffset);\n+        \/\/ We use uptime to assert that changing the clock worked\n+        long boottimeBefore = readSystemUptime();\n+\n+        long before = System.nanoTime();\n+        Core.checkpointRestore();\n+        long after = System.nanoTime();\n+        System.out.println(\"Before: \" + before);\n+        System.out.println(\"After: \" + after);\n+        assertLTE(before, after, \"After < Before\");\n+        if (changeBootId || monotonicOffset <= 0) {\n+            \/\/ Even though we have shifted the monotic offset by a day the difference\n+            \/\/ is adjusted by difference between wall clock time before and after;\n+            \/\/ the difference in monotonic time is considered \"random\"\n+            assertLT(after, before + TimeUnit.HOURS.toNanos(1), \"After too late\");\n+        } else {\n+            assertGT(after, before + TimeUnit.HOURS.toNanos(1), \"After too early\");\n+            assertLT(after, before + TimeUnit.HOURS.toNanos(25), \"After too late\");\n+        }\n+        long boottimeAfter = readSystemUptime();\n+        assertGTE(boottimeAfter, boottimeBefore + 86_400_000, \"Boottime was not changed\");\n+        RuntimeMXBean runtimeMX = ManagementFactory.getRuntimeMXBean();\n+        assertGTE(runtimeMX.getUptime(), 0L, \"VM Uptime is negative!\");\n+        CRaCMXBean cracBean = CRaCMXBean.getCRaCMXBean();\n+        assertLT(cracBean.getUptimeSinceRestore(), 60_000L);\n+        assertGTE(cracBean.getUptimeSinceRestore(), 0L);\n+    }\n+\n+    private long readSystemUptime() throws IOException {\n+        String uptimeStr = Files.readString(Path.of(\"\/proc\/uptime\"));\n+        String[] parts = uptimeStr.split(\" \");\n+        return (long)(Double.parseDouble(parts[0]) * 1000);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/System\/NanoTimeTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test TimedWaitingTest checks whether timed waiting does not block when monotonic time runs backwards\n+ * @requires (os.family == \"linux\")\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build TimedWaitingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class TimedWaitingTest implements CracTest {\n+    public static final String WAITING = \"WAITING\";\n+    public static final int WAIT_TIME_MILLIS = 1000;\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        String imageName = Common.imageName(\"timed-waiting\");\n+\n+        CracBuilder builder = new CracBuilder();\n+        Path bootIdFile = Files.createTempFile(\"NanoTimeTest-\", \"-boot_id\");\n+        try {\n+            builder.withBaseImage(\"ghcr.io\/crac\/test-base\", \"latest\")\n+                    .dockerOptions(\"-v\", bootIdFile + \":\/fake_boot_id\")\n+                    .inDockerImage(imageName);\n+            builder.captureOutput(true);\n+\n+            Files.writeString(bootIdFile, \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\n\");\n+            \/\/ We need to preload the library before checkpoint\n+            CracProcess checkpointed = builder.startCheckpoint(Container.ENGINE_COMMAND, \"exec\",\n+                    \"-e\", \"LD_PRELOAD=\/opt\/path-mapping-quiet.so\",\n+                    \"-e\", \"PATH_MAPPING=\/proc\/sys\/kernel\/random\/boot_id:\/fake_boot_id\",\n+                    CracBuilder.CONTAINER_NAME,\n+                    \"unshare\", \"--fork\", \"--time\", \"--monotonic\", \"86400\", \"--boottime\", \"86400\",\n+                    CracBuilder.DOCKER_JAVA);\n+            CountDownLatch latch = new CountDownLatch(1);\n+            checkpointed.watch(out -> {\n+                System.out.println(out);\n+                if (WAITING.equals(out)) {\n+                    latch.countDown();\n+                }\n+            }, System.err::println);\n+            latch.await();\n+            builder.checkpointViaJcmd();\n+            checkpointed.waitForCheckpointed();\n+\n+            Files.writeString(bootIdFile, \"yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\\n\");\n+\n+            CracProcess restore = builder.startRestore();\n+            CompletableFuture<Void> future = new CompletableFuture<>();\n+            new Thread(() -> {\n+                try {\n+                    restore.waitForSuccess();\n+                    System.err.print(restore.outputAnalyzer().getStderr());\n+                    future.complete(null);\n+                } catch (Throwable t) {\n+                    future.completeExceptionally(t);\n+                }\n+            }).start();\n+            future.get(10, TimeUnit.SECONDS);\n+        } finally {\n+            builder.ensureContainerKilled();\n+            assertTrue(bootIdFile.toFile().delete());\n+        }\n+    }\n+\n+    private interface Task {\n+        void run() throws InterruptedException;\n+    }\n+\n+    private static void timedWait(Task task, List<Throwable> exceptions, boolean canReturnEarly) {\n+        try {\n+            long before = System.currentTimeMillis();\n+            task.run();\n+            long after = System.currentTimeMillis();\n+            if (after - before < WAIT_TIME_MILLIS) {\n+                if (canReturnEarly) {\n+                    \/\/ Non-critical\n+                    System.err.println(Thread.currentThread().getName() + \" took: \" + (after - before) + \" ms\");\n+                } else {\n+                    exceptions.add(new IllegalStateException(\n+                            Thread.currentThread().getName() + \" was too short: \" + (after - before) + \" ms\"));\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            exceptions.add(unexpectedInterrupt(e));\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        List<Throwable> exceptions = Collections.synchronizedList(new ArrayList<>());\n+        List<Thread> threads = new ArrayList<>();\n+        CountDownLatch latch = new CountDownLatch(6);\n+\n+        startThread(\"Thread.sleep\", threads, latch, () -> {\n+            timedWait(() -> Thread.sleep(WAIT_TIME_MILLIS), exceptions, false);\n+        });\n+\n+        startThread(\"Thread.join\", threads, latch, () -> {\n+            Thread daemon = new Thread(() -> {\n+                try {\n+                    Thread.sleep(86_400_000);\n+                } catch (InterruptedException e) {\n+                    exceptions.add(unexpectedInterrupt(e));\n+                }\n+            }, \"inifinite daemon\");\n+            daemon.setDaemon(true);\n+            daemon.start();\n+            timedWait(() -> daemon.join(WAIT_TIME_MILLIS), exceptions, false);\n+        });\n+\n+        startThread(\"Object.wait\", threads, latch, () -> {\n+            synchronized (this) {\n+                timedWait(() -> this.wait(WAIT_TIME_MILLIS), exceptions, true);\n+            }\n+        });\n+\n+        ReentrantLock lock = new ReentrantLock();\n+        lock.lock();\n+        startThread(\"ReentrantLock.tryLock\", threads, latch, () -> {\n+            timedWait(() -> {\n+                if (lock.tryLock(WAIT_TIME_MILLIS, TimeUnit.MILLISECONDS)) {\n+                    exceptions.add(new AssertionError(\"Should not be able to lock\"));\n+                }\n+            }, exceptions, false);\n+        });\n+\n+        startThread(\"Condition.await\", threads, latch, () -> {\n+            ReentrantLock lock2 = new ReentrantLock();\n+            Condition condition = lock2.newCondition();\n+            lock2.lock();\n+            \/\/noinspection ResultOfMethodCallIgnored\n+            timedWait(() -> condition.await(WAIT_TIME_MILLIS, TimeUnit.MILLISECONDS), exceptions, true);\n+        });\n+\n+        startThread(\"LockSupport.parkUntil\", threads, latch, () -> {\n+            timedWait(() -> LockSupport.parkUntil(System.currentTimeMillis() + WAIT_TIME_MILLIS),\n+                    exceptions, true);\n+        });\n+\n+        assertEquals(latch.getCount(), (long) threads.size());\n+        do {\n+            Thread.yield();\n+            threads.stream().forEach(t -> {\n+                System.out.printf(\"%s: %s%n\", t.getName(), t.getState());\n+            });\n+        } while (!threads.stream().map(Thread::getState).allMatch(Thread.State.TIMED_WAITING::equals));\n+        System.out.println(WAITING);\n+        \/\/ Make sure none of the threads completed yet\n+        assertEquals(latch.getCount(), (long) threads.size());\n+        try {\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            fail(\"Should not get interrupted\", e);\n+        }\n+        assertEquals(Collections.emptyList(), exceptions);\n+    }\n+\n+    private static void startThread(String name, List<Thread> threads, CountDownLatch latch, Runnable runnable) {\n+        Thread thread = new Thread(() -> {\n+            try {\n+                runnable.run();\n+            } finally {\n+                latch.countDown();\n+            }\n+        }, name);\n+        threads.add(thread);\n+        thread.start();\n+    }\n+\n+    private static AssertionError unexpectedInterrupt(InterruptedException e) {\n+        return new AssertionError(Thread.currentThread().getName() + \" interrupted\", e);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/System\/TimedWaitingTest.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.util.concurrent.CountDownLatch;\n+\/*\n+ * @test JoinSleepWaitOnCRPauseTest.java\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @summary check if Thread.join(timeout), Thread.sleep(timeout)\n+ *          and Object.wait(timeout)\n+ *          will be completed on restore immediately\n+ *          if their end time fell on the CRaC pause period\n+ *          (i.e. between the checkpoint and restore)\n+ *\n+ * @build JoinSleepWaitOnCRPauseTest\n+ * @run driver jdk.test.lib.crac.CracTest join_ms\n+ * @run driver jdk.test.lib.crac.CracTest join_ns\n+ * @run driver jdk.test.lib.crac.CracTest sleep_ms\n+ * @run driver jdk.test.lib.crac.CracTest sleep_ns\n+ * @run driver jdk.test.lib.crac.CracTest wait_ms\n+ * @run driver jdk.test.lib.crac.CracTest wait_ns\n+ *\/\n+public class JoinSleepWaitOnCRPauseTest implements CracTest {\n+    private enum TestType {\n+        join_ms, join_ns, sleep_ms, sleep_ns, wait_ms, wait_ns\n+    }\n+\n+    @CracTestArg\n+    private TestType testType;\n+\n+    private final static long EPS_NS = Long.parseLong(System.getProperty(\n+        \"test.jdk.jdk.crac.java.lang.Thread.crac.JoinSleepWaitOnCRPauseTest.eps\", getEnv(\"crac_JoinSleepWaitOnCRPauseTest_eps\", \"500000000\"))); \/\/ default: 500ms\n+\n+    private static final long CRPAUSE_MS = 40 * EPS_NS \/ 1_000_000;\n+\n+    private static final long T_MS = CRPAUSE_MS \/ 2;\n+    private static final  int T_NS = 100;\n+\n+    private volatile long tDone = -1;\n+\n+    private final CountDownLatch checkpointLatch = new CountDownLatch(1);\n+\n+    private static String getEnv(String name, String defaultValue) {\n+        String val = System.getenv(name);\n+        return val == null ?\n+                defaultValue :\n+                val;\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        String op = testType.name();\n+        op = op.substring(0, op.length() - 3); \/\/ remove suffix\n+\n+        Thread mainThread = Thread.currentThread();\n+\n+        Runnable r = () -> {\n+\n+            try {\n+\n+                checkpointLatch.countDown();\n+\n+                switch (testType) {\n+\n+                    case join_ms:\n+                        mainThread.join(T_MS);\n+                        break;\n+\n+                    case join_ns:\n+                        mainThread.join(T_MS, T_NS);\n+                        break;\n+\n+                    case sleep_ms:\n+                        Thread.sleep(T_MS);\n+                        break;\n+\n+                    case sleep_ns:\n+                        Thread.sleep(T_MS, T_NS);\n+                        break;\n+\n+                    case wait_ms:\n+                        synchronized(this) { wait(T_MS);  }\n+                        break;\n+\n+                    case wait_ns:\n+                        synchronized(this) { wait(T_MS, T_NS);  }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(\"unknown test type\");\n+                }\n+\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(ie);\n+            }\n+\n+            tDone = System.nanoTime();\n+        };\n+\n+        Thread t = new Thread(r);\n+        long tStart = System.nanoTime();\n+        t.start();\n+\n+        \/\/ this additional synchronization is probably redundant;\n+        \/\/ adding it to ensure we get the expected TIMED_WAITING state\n+        \/\/ from \"our\" join or sleep\n+        checkpointLatch.await();\n+\n+        \/\/ it is expected that EPS_NS is enough to complete the join\/sleep on restore\n+        \/\/ so we are expecting that it should be enough to enter them\n+        Thread.sleep(EPS_NS \/ 1_000_000);\n+\n+        if (t.getState() != Thread.State.TIMED_WAITING) {\n+            throw new AssertionError(String.format(\"The created thread was not able to enter %s in %s ns\", op, EPS_NS));\n+        }\n+\n+        long tBeforeCheckpoint = System.nanoTime();\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        long tAfterRestore = System.nanoTime();\n+\n+        t.join();\n+\n+        System.out.println(String.format(\"The test started at %s\", tStart));\n+\n+        long pause = (tAfterRestore - tBeforeCheckpoint)\/1_000_000;\n+        if (pause < CRPAUSE_MS) {\n+            throw new AssertionError(String.format(\"the CR pause %s ms was less than the expected pause %s ms\", pause, CRPAUSE_MS));\n+        }\n+\n+        if (tDone < tBeforeCheckpoint) {\n+            throw new AssertionError(String.format(\"%s has finished before the checkpoint at %s ms\", op, tDone\/1_000_000));\n+        }\n+\n+        long eps = Math.abs(tAfterRestore - tDone);\n+\n+        if (eps > EPS_NS) {\n+            throw new RuntimeException(String.format(\n+                \"The %sing thread has finished at %s in %s ns \"\n+                + \"before\/after the restore (expected was: %s ns)\", op, tDone, eps, EPS_NS));\n+        }\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder()\n+                .imageDir(\"cr_\" + testType.name());\n+        builder.doCheckpoint();\n+\n+        \/\/ sleep a few seconds to ensure the task execution time\n+        \/\/ falls within this pause period\n+        Thread.sleep(CRPAUSE_MS);\n+\n+        builder.doRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/Thread\/JoinSleepWaitOnCRPauseTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.*;\n+\n+\/*\n+ * @test\n+ * @summary Test if InetAddress cache is flushed after checkpoint\/restore\n+ * @requires (os.family == \"linux\")\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build ResolveTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ResolveTest implements CracTest {\n+    public static final String TEST_HOSTNAME = \"some.test.hostname.example.com\";\n+\n+    @CracTestArg(value = 0, optional = true)\n+    String ip;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String checkFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        String imageName = Common.imageName(\"inet-address\");\n+\n+        CracBuilder builder = new CracBuilder()\n+                .inDockerImage(imageName).dockerOptions(\"--add-host\", TEST_HOSTNAME + \":192.168.12.34\")\n+                .captureOutput(true)\n+                .args(CracTest.args(TEST_HOSTNAME, \"\/second-run\"));\n+\n+        try {\n+            CompletableFuture<?> firstOutputFuture = new CompletableFuture<Void>();\n+            builder.vmOption(\"-XX:CRaCMinPid=100\");\n+            CracProcess checkpointed = builder.startCheckpoint().watch(line -> {\n+                System.out.println(\"OUTPUT: \" + line);\n+                if (line.equals(\"192.168.12.34\")) {\n+                    firstOutputFuture.complete(null);\n+                }\n+            }, error -> {\n+                System.err.println(\"ERROR: \" + error);\n+                firstOutputFuture.cancel(false);\n+            });\n+            firstOutputFuture.get(10, TimeUnit.SECONDS);\n+            builder.checkpointViaJcmd();\n+            checkpointed.waitForCheckpointed();\n+\n+            builder.clearVmOptions();\n+            builder.recreateContainer(imageName,\n+                    \"--add-host\", TEST_HOSTNAME + \":192.168.56.78\",\n+                    \"--volume\", Utils.TEST_CLASSES + \":\/second-run\"); \/\/ any file\/dir suffices\n+\n+\n+            builder.startRestore().outputAnalyzer()\n+                    .shouldHaveExitValue(0)\n+                    .shouldContain(\"192.168.56.78\");\n+        } finally {\n+            builder.ensureContainerKilled();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (ip == null || checkFile == null) {\n+            System.err.println(\"Args: <ip address> <check file path>\");\n+            return;\n+        }\n+        printAddress(ip);\n+        while (!Files.exists(Path.of(checkFile))) {\n+            try {\n+                \/\/noinspection BusyWait\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                System.err.println(\"Interrupted!\");\n+                return;\n+            }\n+        }\n+        printAddress(ip);\n+    }\n+\n+    private static void printAddress(String hostname) {\n+        try {\n+            InetAddress address = InetAddress.getByName(hostname);\n+            \/\/ we will assume IPv4 address\n+            byte[] bytes = address.getAddress();\n+            System.out.print(bytes[0] & 0xFF);\n+            for (int i = 1; i < bytes.length; ++i) {\n+                System.out.print('.');\n+                System.out.print(bytes[i] & 0xFF);\n+            }\n+            System.out.println();\n+        } catch (UnknownHostException e) {\n+            System.out.println();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+handlers = java.util.logging.ConsoleHandler\n+.level = ALL\n+java.util.logging.ConsoleHandler.level = FINE\n+java.util.logging.SimpleFormatter.format=%1$tH:%1$tM:%1$tS %4$s [%3$s] %5$s%6$s%n\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/crac\/logging.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.*;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test\n+ * @summary check that the recursive checkpoint is not allowed\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest 10\n+ *\/\n+public class Test implements Resource, CracTest {\n+    private static final AtomicInteger counter = new AtomicInteger(0);\n+    private static Exception exception = null;\n+\n+    @CracTestArg\n+    int numThreads;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.PAUSE);\n+        CracProcess process = builder.startCheckpoint();\n+        process.waitForPausePid();\n+        for (int i = 1; i <= numThreads + 1; ++i) {\n+            System.err.printf(\"Restore #%d%n\", i);\n+            builder.doRestore();\n+        }\n+        process.waitForSuccess();\n+    }\n+\n+    private static class TestThread extends Thread {\n+\n+        @Override\n+        public void run() {\n+            try {\n+                jdk.crac.Core.checkpointRestore();\n+            } catch (CheckpointException e) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Checkpoint in thread ERROR \" + e);\n+            } catch (RestoreException e) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Restore in thread ERROR \" + e);\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        try {\n+            int c = counter.incrementAndGet();\n+            if (c > 1) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Parallel checkpoint\");\n+            }\n+            Thread.sleep(100);\n+            jdk.crac.Core.checkpointRestore();\n+            if (exception != null)\n+                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n+        } catch (CheckpointException e) {\n+            \/\/ Expected Exception\n+        } catch (RestoreException e) {\n+            if (exception == null)\n+                exception = new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        try {\n+            int c = counter.get();\n+            if (c > 1) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Parallel checkpoint\");\n+            }\n+            Thread.sleep(100);\n+            jdk.crac.Core.checkpointRestore();\n+            if (exception == null)\n+                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n+        } catch (CheckpointException e) {\n+            \/\/ Expected Exception\n+        } catch (RestoreException e) {\n+            if (exception == null)\n+                exception = new RuntimeException(\"Restore ERROR \" + e);\n+        } finally {\n+            counter.decrementAndGet();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.getGlobalContext().register(new Test());\n+\n+        TestThread[] threads = new TestThread[numThreads];\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i] = new TestThread();\n+            threads[i].start();\n+        };\n+\n+        Thread.sleep(100);\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+        } catch (RestoreException e) {\n+            throw new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i].join();\n+        };\n+\n+        long ccounter = counter.get();\n+        if (ccounter != 0)\n+            throw new RuntimeException(\"Incorrect counter after restore: \" + ccounter + \" instead of 0\");\n+        if (exception != null) {\n+            throw exception;\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -146,17 +147,27 @@\n-        CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n-\n-        try (Recording r = new Recording()) {\n-            r.start();\n-            List<Emitter> emitters = new ArrayList<>();\n-            for (int i = 0; i < THREAD_COUNT; i++) {\n-                Emitter e = new Emitter(barrier);\n-                e.start();\n-                emitters.add(e);\n-            }\n-            \/\/ Thread buffers should now have one event each\n-            barrier.await();\n-            \/\/ Add another event to each thread buffer, so\n-            \/\/ events are bound to come out of order when they\n-            \/\/ are flushed\n-            for (Emitter e : emitters) {\n-                e.join();\n+        while (true) {\n+            CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT + 1);\n+            try (Recording r = new Recording()) {\n+                r.start();\n+                List<Emitter> emitters = new ArrayList<>();\n+                for (int i = 0; i < THREAD_COUNT; i++) {\n+                    Emitter e = new Emitter(barrier);\n+                    e.start();\n+                    emitters.add(e);\n+                }\n+                \/\/ Thread buffers should now have one event each\n+                barrier.await();\n+                \/\/ Add another event to each thread buffer, so\n+                \/\/ events are bound to come out of order when they\n+                \/\/ are flushed\n+                for (Emitter e : emitters) {\n+                    e.join();\n+                }\n+                r.stop();\n+                Path p = Utils.createTempFile(\"recording\", \".jfr\");\n+                r.dump(p);\n+                \/\/ Order is only guaranteed within a segment.\n+                int segments = countSegments(p);\n+                if (segments < 2) {\n+                    return p;\n+                }\n+                System.out.println(\"File contains more than one segment (\" + segments + \"). Retrying.\");\n@@ -164,4 +175,9 @@\n-            r.stop();\n-            Path p = Utils.createTempFile(\"recording\", \".jfr\");\n-            r.dump(p);\n-            return p;\n+        }\n+    }\n+\n+    private static int countSegments(Path file) throws Exception {\n+        AtomicInteger segments = new AtomicInteger();\n+        try (EventStream es = EventStream.openFile(file)) {\n+            es.onFlush(segments::incrementAndGet);\n+            es.start();\n+            return segments.get();\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/filestream\/TestOrdered.java","additions":37,"deletions":21,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm jdk.jfr.api.consumer.recordingstream.TestStop\n+ * @run main\/othervm -Xlog:system+parser+jfr=info jdk.jfr.api.consumer.recordingstream.TestStop\n@@ -142,1 +142,0 @@\n-                System.out.println(\"Outer dump:\");\n@@ -144,4 +143,0 @@\n-                for (RecordedEvent e : dumpOuter) {\n-                    System.out.println(eventToText(e));\n-                }\n-                System.out.println(\"Inner dump:\");\n@@ -149,12 +144,1 @@\n-                for (RecordedEvent e : dumpInner) {\n-                    System.out.println(eventToText(e));\n-                }\n-                System.out.println();\n-                System.out.println(\"Outer stream:\");\n-                for (String s : outerStream) {\n-                    System.out.println(s);\n-                }\n-                System.out.println(\"Inner stream:\");\n-                for (String s : innerStream) {\n-                    System.out.println(s);\n-                }\n+\n@@ -162,0 +146,1 @@\n+                    log(outerStream, innerStream, dumpOuter, dumpInner);\n@@ -165,0 +150,1 @@\n+                    log(outerStream, innerStream, dumpOuter, dumpInner);\n@@ -168,0 +154,1 @@\n+                    log(outerStream, innerStream, dumpOuter, dumpInner);\n@@ -171,0 +158,1 @@\n+                    log(outerStream, innerStream, dumpOuter, dumpInner);\n@@ -177,0 +165,21 @@\n+    private static void log(List<String> outerStream, List<String> innerStream, List<RecordedEvent> dumpOuter,\n+            List<RecordedEvent> dumpInner) {\n+        System.out.println(\"Outer dump:\");\n+        for (RecordedEvent e : dumpOuter) {\n+            System.out.println(eventToText(e));\n+        }\n+        System.out.println(\"Inner dump:\");\n+        for (RecordedEvent e : dumpInner) {\n+            System.out.println(eventToText(e));\n+        }\n+        System.out.println();\n+        System.out.println(\"Outer stream:\");\n+        for (String s : outerStream) {\n+            System.out.println(s);\n+        }\n+        System.out.println(\"Inner stream:\");\n+        for (String s : innerStream) {\n+            System.out.println(s);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestStop.java","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n@@ -32,1 +32,1 @@\n- * @run main\/othervm\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n@@ -45,3 +45,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca1 CRL\n@@ -56,3 +56,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca2 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca2 CRL\n@@ -67,3 +67,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca3 CRL\n@@ -78,3 +78,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop amazonrootca4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop amazonrootca4 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop amazonrootca4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop amazonrootca4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop amazonrootca4 CRL\n@@ -89,3 +89,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass2ca CRL\n@@ -100,3 +100,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass3ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop buypassclass3ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop buypassclass3ca CRL\n@@ -111,3 +111,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop comodorsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodorsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop comodorsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop comodorsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodorsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop comodorsaca CRL\n@@ -122,3 +122,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop comodoeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodoeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop comodoeccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop comodoeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop comodoeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop comodoeccca CRL\n@@ -133,3 +133,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop usertrustrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrustrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop usertrustrsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop usertrustrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrustrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop usertrustrsaca CRL\n@@ -144,3 +144,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop usertrusteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrusteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop usertrusteccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop usertrusteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop usertrusteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop usertrusteccca CRL\n@@ -155,2 +155,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx1 DEFAULT\n@@ -165,2 +165,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx2 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop letsencryptisrgx2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop letsencryptisrgx2 DEFAULT\n@@ -175,3 +175,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsignrootcar6 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignrootcar6 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsignrootcar6 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsignrootcar6 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignrootcar6 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop globalsignrootcar6 CRL\n@@ -186,3 +186,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop entrustrootcaec1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcaec1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop entrustrootcaec1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop entrustrootcaec1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcaec1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop entrustrootcaec1 CRL\n@@ -197,3 +197,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop entrustrootcag4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcag4 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop entrustrootcag4 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop entrustrootcag4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop entrustrootcag4 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop entrustrootcag4 CRL\n@@ -208,3 +208,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop godaddyrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop godaddyrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop godaddyrootg2ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop godaddyrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop godaddyrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop godaddyrootg2ca CRL\n@@ -219,3 +219,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop starfieldrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop starfieldrootg2ca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop starfieldrootg2ca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop starfieldrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop starfieldrootg2ca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop starfieldrootg2ca CRL\n@@ -230,2 +230,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigneccrootcar4 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigneccrootcar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsigneccrootcar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigneccrootcar4 DEFAULT\n@@ -240,2 +240,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar1 DEFAULT\n@@ -250,2 +250,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar2 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootcar2 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootcar2 DEFAULT\n@@ -260,2 +260,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar3 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar3 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar3 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar3 DEFAULT\n@@ -270,2 +270,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar4 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop gtsrootecccar4 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop gtsrootecccar4 DEFAULT\n@@ -280,3 +280,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop microsoftecc2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftecc2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop microsoftecc2017 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop microsoftecc2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftecc2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop microsoftecc2017 CRL\n@@ -291,3 +291,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop microsoftrsa2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftrsa2017 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop microsoftrsa2017 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop microsoftrsa2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop microsoftrsa2017 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop microsoftrsa2017 CRL\n@@ -302,3 +302,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca1g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca1g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop quovadisrootca1g3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca1g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca1g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop quovadisrootca1g3 CRL\n@@ -313,3 +313,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca2g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca2g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop quovadisrootca2g3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca2g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca2g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop quovadisrootca2g3 CRL\n@@ -324,3 +324,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca3g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca3g3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop quovadisrootca3g3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop quovadisrootca3g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop quovadisrootca3g3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop quovadisrootca3g3 CRL\n@@ -335,3 +335,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop digicerttlseccrootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlseccrootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop digicerttlseccrootg5 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop digicerttlseccrootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlseccrootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop digicerttlseccrootg5 CRL\n@@ -346,3 +346,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop digicerttlsrsarootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlsrsarootg5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop digicerttlsrsarootg5 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop digicerttlsrsarootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop digicerttlsrsarootg5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop digicerttlsrsarootg5 CRL\n@@ -357,3 +357,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop sslrootrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop sslrootrsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop sslrootrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop sslrootrsaca CRL\n@@ -368,3 +368,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop sslrootevrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootevrsaca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop sslrootevrsaca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop sslrootevrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrootevrsaca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop sslrootevrsaca CRL\n@@ -379,3 +379,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop sslrooteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrooteccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop sslrooteccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop sslrooteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop sslrooteccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop sslrooteccca CRL\n@@ -390,3 +390,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop teliasonerarootcav1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliasonerarootcav1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop teliasonerarootcav1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop teliasonerarootcav1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliasonerarootcav1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop teliasonerarootcav1 CRL\n@@ -401,3 +401,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop twcaglobalrootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop twcaglobalrootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop twcaglobalrootca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop twcaglobalrootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop twcaglobalrootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop twcaglobalrootca CRL\n@@ -412,3 +412,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop certignarootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certignarootca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop certignarootca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop certignarootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certignarootca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop certignarootca CRL\n@@ -423,3 +423,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustcommercialca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustcommercialca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustcommercialca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustcommercialca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustcommercialca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustcommercialca CRL\n@@ -434,3 +434,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustnetworkingca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustnetworkingca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustnetworkingca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustnetworkingca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustnetworkingca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustnetworkingca CRL\n@@ -445,3 +445,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustpremiumca CRL\n@@ -456,3 +456,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumeccca OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop affirmtrustpremiumeccca CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop affirmtrustpremiumeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop affirmtrustpremiumeccca OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop affirmtrustpremiumeccca CRL\n@@ -467,3 +467,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop teliarootcav2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliarootcav2 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop teliarootcav2 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop teliarootcav2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop teliarootcav2 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop teliarootcav2 CRL\n@@ -478,3 +478,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop emsignrootcag1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsignrootcag1 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop emsignrootcag1 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop emsignrootcag1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsignrootcag1 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop emsignrootcag1 CRL\n@@ -489,3 +489,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop emsigneccrootcag3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsigneccrootcag3 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop emsigneccrootcag3 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop emsigneccrootcag3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop emsigneccrootcag3 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop emsigneccrootcag3 CRL\n@@ -500,2 +500,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop certainlyrootr1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyrootr1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop certainlyrootr1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyrootr1 DEFAULT\n@@ -510,2 +510,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop certainlyroote1 DEFAULT\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyroote1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop certainlyroote1 DEFAULT\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop certainlyroote1 DEFAULT\n@@ -520,3 +520,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsignr46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignr46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsignr46 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsignr46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsignr46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop globalsignr46 CRL\n@@ -531,3 +531,3 @@\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp CAInterop globalsigne46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigne46 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CAInterop globalsigne46 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp CAInterop globalsigne46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp -Dcom.sun.security.ocsp.useget=false CAInterop globalsigne46 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CAInterop globalsigne46 CRL\n@@ -537,1 +537,3 @@\n- * Collection of certificate validation tests for interoperability with external CAs\n+ * Collection of certificate validation tests for interoperability with external CAs.\n+ * These tests are marked as manual as they depend on external infrastructure and may fail\n+ * with external reasons, for instance - change in CA test portal.\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":135,"deletions":133,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath CertignaCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath CertignaCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CertignaCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath CertignaCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CertignaCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath DTrustCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath DTrustCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath DTrustCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath DTrustCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/DTrustCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=ocsp,certpath DigicertCSRootG5 OCSP\n- * @run main\/othervm -Djava.security.debug=certpath DigicertCSRootG5 CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=ocsp,certpath DigicertCSRootG5 OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath DigicertCSRootG5 CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/DigicertCSRootG5.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath EmSignRootG2CA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath EmSignRootG2CA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath EmSignRootG2CA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath EmSignRootG2CA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/EmSignRootG2CA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath HaricaCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath HaricaCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath HaricaCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath HaricaCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/HaricaCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.security.debug=certpath LuxTrustCA OCSP\n- * @run main\/othervm -Djava.security.debug=certpath LuxTrustCA CRL\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath LuxTrustCA OCSP\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath LuxTrustCA CRL\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/LuxTrustCA.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm HttpsURLConnectionTest https:\/\/github.com KeychainStore-Root\n+ * @run main\/othervm\/manual HttpsURLConnectionTest https:\/\/github.com KeychainStore-Root\n","filename":"test\/jdk\/security\/infra\/javax\/net\/ssl\/HttpsURLConnectionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+ * @run main\/othervm\/timeout=300 RmiBootstrapTest .*_test.*.in\n@@ -75,0 +76,1 @@\n+ * @run main\/othervm\/timeout=300 RmiBootstrapTest .*_ssltest.*.in\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/RmiBootstrapTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -794,2 +794,2 @@\n-                        .orElseThrow(() -> new SkippedException(\n-                        \"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n+                        .orElseThrow(() ->\n+                            new RuntimeException(\"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8164130\n+ * @bug 8164130 8334332\n@@ -28,1 +28,1 @@\n- * @library ..\/..\/lib\n+ * @library ..\/..\/lib \/test\/lib\n@@ -42,0 +42,1 @@\n+import jtreg.SkippedException;\n@@ -64,1 +65,1 @@\n-            throw error(outDir, \"Cannot create directory\");\n+            throw skip(outDir, \"Cannot create directory\");\n@@ -67,4 +68,1 @@\n-            if (skip(outDir)) {\n-                return;\n-            }\n-            throw error(outDir, \"could not set directory read-only\");\n+            throw skip(outDir, \"could not set directory read-only\");\n@@ -73,1 +71,1 @@\n-            throw error(outDir, \"directory is writable\");\n+            throw skip(outDir, \"directory is writable\");\n@@ -96,1 +94,1 @@\n-            throw error(outDir, \"Cannot create directory\");\n+            throw skip(outDir, \"Cannot create directory\");\n@@ -101,1 +99,1 @@\n-            throw error(index, \"could not set index read-only\");\n+            throw skip(index, \"could not set index read-only\");\n@@ -104,1 +102,1 @@\n-            throw error(index, \"index is writable\");\n+            throw skip(index, \"index is writable\");\n@@ -142,1 +140,1 @@\n-            throw error(pkgOutDir, \"Cannot create directory\");\n+            throw skip(pkgOutDir, \"Cannot create directory\");\n@@ -145,4 +143,1 @@\n-            if (skip(pkgOutDir)) {\n-                return;\n-            }\n-            throw error(pkgOutDir, \"could not set directory read-only\");\n+            throw skip(pkgOutDir, \"could not set directory read-only\");\n@@ -151,1 +146,1 @@\n-            throw error(pkgOutDir, \"directory is writable\");\n+            throw skip(pkgOutDir, \"directory is writable\");\n@@ -195,1 +190,1 @@\n-            throw error(docFilesOutDir, \"Cannot create directory\");\n+            throw skip(docFilesOutDir, \"Cannot create directory\");\n@@ -198,4 +193,1 @@\n-            if (skip(docFilesOutDir)) {\n-                return;\n-            }\n-            throw error(docFilesOutDir, \"could not set directory read-only\");\n+            throw skip(docFilesOutDir, \"could not set directory read-only\");\n@@ -204,1 +196,1 @@\n-            throw error(docFilesOutDir, \"directory is writable\");\n+            throw skip(docFilesOutDir, \"directory is writable\");\n@@ -222,1 +214,2 @@\n-    private Error error(File f, String message) {\n+    private Error skip(File f, String message) {\n+        out.print(System.getProperty(\"user.name\"));\n@@ -225,1 +218,1 @@\n-        throw new Error(f + \": \" + message);\n+        throw new SkippedException(f + \": \" + message);\n@@ -245,15 +238,0 @@\n-\n-    private boolean skip(File dir) {\n-        if (isWindows()) {\n-            showAllAttributes(dir.toPath());\n-            out.println(\"Windows: cannot set directory read only:\" + dir);\n-            out.println(\"TEST CASE SKIPPED\");\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    private boolean isWindows() {\n-        return System.getProperty(\"os.name\").toLowerCase(Locale.US).startsWith(\"windows\");\n-    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testIOException\/TestIOException.java","additions":19,"deletions":41,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-                    <pre class=\"snippet\"><code>   this is snippet_standalone\n+                    <pre class=\"snippet\" id=\"snippet-snippet_standalone()1\"><code>   this is snippet_standalone\n@@ -134,1 +134,1 @@\n-                    <pre class=\"snippet\"><code>   this is a snippet_wrapped\n+                    <pre class=\"snippet\" id=\"snippet-snippet_wrapped()1\"><code>   this is a snippet_wrapped\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownTaglets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,1 +240,2 @@\n-                    equal. All components in this record class are compared with '=='.\"\"\",\n+                    equal. All components in this record class are compared with the <code>compare<\/\\\n+                    code> method from their corresponding wrapper classes.\"\"\",\n@@ -303,1 +304,2 @@\n-                    equal. All components in this record class are compared with '=='.\"\"\",\n+                    equal. All components in this record class are compared with the <code>compare<\/\\\n+                    code> method from their corresponding wrapper classes.\"\"\",\n@@ -314,1 +316,2 @@\n-             \"All components in this record class are compared with '=='.\");\n+             \"All components in this record class are compared with the <code>compare<\/code> method \" +\n+                     \"from their corresponding wrapper classes.\");\n@@ -327,1 +330,2 @@\n-             + \"primitive components are compared with '=='.\");\n+             + \"primitive components are compared with the <code>compare<\/code> method from their \"\n+             + \"corresponding wrapper classes.\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,1 +182,1 @@\n-                    t.expectedOutput(), Optional.of(\"properties\")));\n+                    t.expectedOutput(), Optional.of(\"properties\"), Optional.of(\"snippet-case\" + index + \"()2\")));\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestLangProperties.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import java.util.Optional;\n@@ -368,1 +369,1 @@\n-                        <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\", t.expectedOutput()));\n+                        <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\", t.expectedOutput(), Optional.empty(), Optional.of(\"snippet-case\" + index + \"()2\")));\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetMarkup.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,0 +223,1 @@\n+            Optional<String> id = (attr.id() != null ? Optional.of(attr.id()) : Optional.of(\"snippet-case\" + j + \"()1\"));\n@@ -224,1 +225,1 @@\n-                    Optional.ofNullable(attr.lang()), Optional.ofNullable(attr.id()));\n+                    Optional.ofNullable(attr.lang()), id);\n@@ -882,1 +883,2 @@\n-                        %s\"\"\".formatted(id, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n+                        %s\"\"\".formatted(id, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput(), Optional.empty(),\n+                                Optional.of(\"snippet-case\" + id + \"()2\"))));\n@@ -974,1 +976,2 @@\n-                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", expectedOutput)));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", expectedOutput, Optional.empty(),\n+                                Optional.of(\"snippet-case\" + index + \"()2\"))));\n@@ -1552,1 +1555,2 @@\n-                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput(), Optional.empty(),\n+                                Optional.of(\"snippet-case\" + index + \"()2\"))));\n@@ -1665,1 +1669,2 @@\n-                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\", Optional.empty(),\n+                            Optional.of(\"snippet-case0()2\")));\n@@ -1670,1 +1675,2 @@\n-                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\", Optional.empty(),\n+                            Optional.of(\"snippet-case1()2\")));\n@@ -1768,1 +1774,2 @@\n-                        \"\"\".formatted(j, getSnippetHtmlRepresentation(\"pkg\/A.html\", \"2\")));\n+                        \"\"\".formatted(j, getSnippetHtmlRepresentation(\"pkg\/A.html\", \"2\", Optional.empty(),\n+                                Optional.of(\"snippet-case\" + j + \"()2\"))));\n@@ -1847,1 +1854,2 @@\n-                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput(), Optional.empty(),\n+                                Optional.of(\"snippet-case\" + index + \"()2\"))));\n@@ -2305,1 +2313,2 @@\n-                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput(), Optional.empty(),\n+                                Optional.of(\"snippet-case\" + index + \"()2\"))));\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-                        \"public class S { }\", Optional.of(\"java\"))));\n+                        \"public class S { }\", Optional.of(\"java\"), Optional.of(\"snippet-C1\"))));\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetUnnamedPackage.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334433\n+ * @summary Verify that when running JShell on platforms that support FFMTerminalProvider,\n+ *          no new processes are spawned.\n+ * @requires os.family == \"windows\" | os.family == \"mac\" | os.family == \"linux\"\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavaTask TerminalNoExecTest\n+ * @run main TerminalNoExecTest\n+ *\/\n+\n+import java.io.Writer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jshell.tool.JavaShellToolBuilder;\n+\n+import toolbox.ToolBox;\n+\n+public class TerminalNoExecTest {\n+\n+    public static void main(String... args) throws Exception {\n+        if (args.length > 0) {\n+            AtomicBoolean spawnedNewProcess = new AtomicBoolean();\n+            try (var rs = new RecordingStream()) {\n+                rs.enable(\"jdk.ProcessStart\").withoutThreshold();\n+                rs.onEvent(evt -> {\n+                    System.err.println(\"evt: \" + evt);\n+                    spawnedNewProcess.set(true);\n+                });\n+                rs.startAsync();\n+                JavaShellToolBuilder.builder().run(\"--execution=local\", \"--no-startup\");\n+                rs.stop();\n+            }\n+            if (spawnedNewProcess.get()) {\n+                System.err.println(\"Spawned a new process!\");\n+                System.exit(1);\n+            }\n+            System.exit(0);\n+        } else {\n+            Path testScript = Paths.get(\"do-exit\");\n+            try (Writer w = Files.newBufferedWriter(testScript)) {\n+                w.append(\"\/exit\\n\");\n+            }\n+\n+            ToolBox tb = new ToolBox();\n+            Process target =\n+                new ProcessBuilder(tb.getJDKTool(\"java\").toString(),\n+                                   \"-classpath\", System.getProperty(\"java.class.path\"),\n+                                   TerminalNoExecTest.class.getName(),\n+                                   \"run-test\")\n+                        .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectInput(testScript.toFile())\n+                        .start();\n+\n+            target.waitFor();\n+\n+            int exitCode = target.exitValue();\n+\n+            if (exitCode != 0) {\n+                throw new AssertionError(\"Incorrect exit value, expected 0, got: \" + exitCode);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/TerminalNoExecTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8334258\n+ * @summary Disallow early assignment if FLEXIBLE_CONSTRUCTORS preview feature is not enabled\n+ * @compile\/fail\/ref=EarlyAssignmentNoPreview1.out -XDrawDiagnostics EarlyAssignmentNoPreview1.java\n+ *\/\n+public class EarlyAssignmentNoPreview1 {\n+\n+    Runnable r;\n+\n+    public EarlyAssignmentNoPreview1() {\n+        this(r = () -> System.out.println(\"hello\"));\n+    }\n+\n+    public EarlyAssignmentNoPreview1(Runnable r) {\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyAssignmentNoPreview1();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview1.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+EarlyAssignmentNoPreview1.java:12:14: compiler.err.preview.feature.disabled: (compiler.misc.feature.flexible.constructors)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview1.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8334258\n+ * @summary Disallow early assignment if FLEXIBLE_CONSTRUCTORS preview feature is not enabled\n+ * @compile\/fail\/ref=EarlyAssignmentNoPreview2.out -XDrawDiagnostics EarlyAssignmentNoPreview2.java\n+ *\/\n+public class EarlyAssignmentNoPreview2 {\n+\n+    Runnable r;\n+\n+    public EarlyAssignmentNoPreview2() {\n+        this(this.r = () -> System.out.println(\"hello\"));\n+    }\n+\n+    public EarlyAssignmentNoPreview2(Runnable r) {\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyAssignmentNoPreview2();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview2.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+EarlyAssignmentNoPreview2.java:12:14: compiler.err.preview.feature.disabled: (compiler.misc.feature.flexible.constructors)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8334258\n+ * @summary Disallow early assignment if FLEXIBLE_CONSTRUCTORS preview feature is not enabled\n+ * @compile\/fail\/ref=EarlyAssignmentNoPreview3.out -XDrawDiagnostics EarlyAssignmentNoPreview3.java\n+ *\/\n+public class EarlyAssignmentNoPreview3 {\n+\n+    Runnable r;\n+\n+    public EarlyAssignmentNoPreview3() {\n+        this(EarlyAssignmentNoPreview3.this.r = () -> System.out.println(\"hello\"));\n+    }\n+\n+    public EarlyAssignmentNoPreview3(Runnable r) {\n+    }\n+\n+    public static void main(String[] args) {\n+        new EarlyAssignmentNoPreview3();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview3.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+EarlyAssignmentNoPreview3.java:12:39: compiler.err.preview.feature.disabled: (compiler.misc.feature.flexible.constructors)\n+1 error\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignmentNoPreview3.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -161,0 +161,11 @@\n+\n+    public static class Inner8 {\n+        class Inner8a {\n+            int x;\n+        }\n+\n+        public Inner8() {\n+            this.new Inner8a().x = 1;           \/\/ FAIL - illegal early access\n+            super();\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+EarlyAssignments.java:168:13: compiler.err.cant.ref.before.ctor.called: this\n@@ -28,1 +29,1 @@\n-25 errors\n+26 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/EarlyAssignments.out","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8334757\n+ * @compile\/fail\/ref=CantAnnotateClassWithTypeVariable.out -XDrawDiagnostics CantAnnotateClassWithTypeVariable.java\n+ *\/\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+public class CantAnnotateClassWithTypeVariable {\n+  @Target(ElementType.TYPE_USE)\n+  @interface TA {}\n+\n+  static class A {\n+    static class B<T> {}\n+  }\n+\n+  <T> @TA A.B<T> f() {}\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateClassWithTypeVariable.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CantAnnotateClassWithTypeVariable.java:18:14: compiler.err.type.annotation.inadmissible: (compiler.misc.type.annotation.1: @CantAnnotateClassWithTypeVariable.TA), CantAnnotateClassWithTypeVariable.A, @CantAnnotateClassWithTypeVariable.TA CantAnnotateClassWithTypeVariable.A.B<T>\n+1 error\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/failures\/CantAnnotateClassWithTypeVariable.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,4 @@\n+        test.disambiguationTest(\"R r when (x > 0)\",\n+                                 ExpressionType.PATTERN);\n+        test.disambiguationTest(\"R(int x) when (x > 0)\",\n+                                 ExpressionType.PATTERN);\n","filename":"test\/langtools\/tools\/javac\/patterns\/DisambiguatePatterns.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8335817\n+ * @summary Verify synthetic catches for deconstruction patterns work properly in expression lambdas\n+ * @compile MatchExceptionLambdaExpression.java\n+ * @run main MatchExceptionLambdaExpression\n+ *\/\n+public class MatchExceptionLambdaExpression {\n+\n+    public static void main(String[] args) {\n+        try {\n+            doRunPrimitiveVoid(new A(\"\", true), o -> checkPrimitiveVoid(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunPrimitiveVoid(new A(\"\", true), o -> checkVoidBox(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunPrimitiveVoid(new A(\"\", true), o -> checkNonVoid(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunVoidBox(new A(\"\", true), o -> checkVoidBox(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunNonVoid(new A(\"\", true), o -> checkVoidBox(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+        try {\n+            doRunNonVoid(new A(\"\", true), o -> checkNonVoid(o instanceof A(String s, _), true));\n+            throw new AssertionError(\"Didn't gete the expected exception!\");\n+        } catch (MatchException ex) {\n+            if (ex.getCause() instanceof RequestedException) {\n+                \/\/correct\n+            } else {\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    static void doRunPrimitiveVoid(Object inp, PrimitiveVoidFI toRun) {\n+       toRun.run(inp);\n+    }\n+\n+    static void doRunVoidBox(Object inp, VoidBoxFI toRun) {\n+       toRun.run(inp);\n+    }\n+\n+    static void doRunNonVoid(Object inp, NonVoidFI toRun) {\n+       toRun.run(inp);\n+    }\n+\n+    static void checkPrimitiveVoid(boolean a, boolean shouldNotBeCalled) {\n+        if (shouldNotBeCalled) {\n+            throw new AssertionError(\"Should not be called.\");\n+        }\n+    }\n+\n+    static Void checkVoidBox(boolean a, boolean shouldNotBeCalled) {\n+        if (shouldNotBeCalled) {\n+            throw new AssertionError(\"Should not be called.\");\n+        }\n+        return null;\n+    }\n+\n+    static Object checkNonVoid(boolean a, boolean shouldNotBeCalled) {\n+        if (shouldNotBeCalled) {\n+            throw new AssertionError(\"Should not be called.\");\n+        }\n+        return null;\n+    }\n+\n+    interface PrimitiveVoidFI {\n+        public void run(Object o);\n+    }\n+\n+    interface VoidBoxFI {\n+        public Void run(Object o);\n+    }\n+\n+    interface NonVoidFI {\n+        public Object run(Object o);\n+    }\n+\n+    record A(String s, boolean fail) {\n+        public String s() {\n+            if (fail) {\n+                throw new RequestedException();\n+            }\n+            return s;\n+        }\n+    }\n+\n+    static class RequestedException extends RuntimeException {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/MatchExceptionLambdaExpression.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8333748\n+ * @summary javap should not fail if reserved access flag bits are set to 1\n+ * @library \/tools\/lib\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n+ * @enablePreview\n+ * @run junit UndefinedAccessFlagTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import toolbox.JavapTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.InnerClassesAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class UndefinedAccessFlagTest {\n+\n+    final ToolBox toolBox = new ToolBox();\n+\n+    enum TestLocation {\n+        NONE(false), CLASS, FIELD, METHOD, INNER_CLASS(false);\n+\n+        final boolean fails;\n+        TestLocation() { this(true); }\n+        TestLocation(boolean fails) { this.fails = fails; }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(TestLocation.class)\n+    void test(TestLocation location) throws Throwable {\n+        var cf = of();\n+        ClassModel cm;\n+        try (var is = UndefinedAccessFlagTest.class.getResourceAsStream(\n+            \"\/UndefinedAccessFlagTest$SampleInnerClass.class\"\n+        )) {\n+            cm = cf.parse(is.readAllBytes());\n+        }\n+        var bytes = cf.transform(cm, (cb, ce) -> {\n+            switch (ce) {\n+                case AccessFlags flags when location == TestLocation.CLASS -> cb\n+                    .withFlags(flags.flagsMask() | ACC_PRIVATE);\n+                case FieldModel f when location == TestLocation.FIELD -> cb\n+                    .transformField(f, (fb, fe) -> {\n+                        if (fe instanceof AccessFlags flags) {\n+                            fb.withFlags(flags.flagsMask() | ACC_SYNCHRONIZED);\n+                        } else {\n+                            fb.with(fe);\n+                        }\n+                    });\n+                case MethodModel m when location == TestLocation.METHOD -> cb\n+                    .transformMethod(m, (mb, me) -> {\n+                        if (me instanceof AccessFlags flags) {\n+                            mb.withFlags(flags.flagsMask() | ACC_INTERFACE);\n+                        } else {\n+                            mb.with(me);\n+                        }\n+                    });\n+                case InnerClassesAttribute attr when location == TestLocation.INNER_CLASS -> cb\n+                    .with(InnerClassesAttribute.of(attr.classes().stream()\n+                        .map(ic -> InnerClassInfo.of(ic.innerClass(), ic.outerClass(), ic.innerName(), ic.flagsMask() | 0x0020))\n+                        .toList()));\n+                default -> cb.with(ce);\n+            }\n+        });\n+\n+        Files.write(Path.of(\"transformed.class\"), bytes);\n+\n+        var lines = new JavapTask(toolBox)\n+            .classes(\"transformed.class\")\n+            .options(\"-c\", \"-p\", \"-v\")\n+            .run(location.fails ? Task.Expect.FAIL : Task.Expect.SUCCESS)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        \/\/ No termination when access flag error happens\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"java.lang.String field;\")));\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"UndefinedAccessFlagTest$SampleInnerClass();\")));\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"void method();\")));\n+        assertTrue(lines.stream().anyMatch(l -> l.contains(\"SampleInnerClass=class UndefinedAccessFlagTest$SampleInnerClass of class UndefinedAccessFlagTest\")));\n+\n+        \/\/ Remove non-error lines\n+        assertTrue(lines.removeIf(st -> !st.startsWith(\"Error:\")));\n+        \/\/ Desired locations has errors\n+        assertTrue(location == TestLocation.NONE || !lines.isEmpty());\n+        \/\/ Access Flag errors only\n+        assertTrue(lines.stream().allMatch(l -> l.contains(\"Access Flags:\")), () -> String.join(\"\\n\", lines));\n+    }\n+\n+    static class SampleInnerClass {\n+        String field;\n+        void method() {}\n+    }\n+}\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -62,1 +62,1 @@\n-        this.addJavaOpts(javaOpts);\n+        Collections.addAll(this.javaOpts, javaOpts);\n@@ -65,1 +65,1 @@\n-        this.addJavaOpts(\"-XX:+ErrorFileToStderr\");\n+        Collections.addAll(this.javaOpts, \"-XX:+ErrorFileToStderr\");\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerRunOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+    public static final String BASE_IMAGE_NAME = \"jdk.test.docker.image.name\";\n+    public static final String BASE_IMAGE_VERSION = \"jdk.test.docker.image.version\";\n+\n@@ -41,1 +44,1 @@\n-        String name = System.getProperty(\"jdk.test.docker.image.name\");\n+        String name = System.getProperty(BASE_IMAGE_NAME);\n@@ -60,1 +63,1 @@\n-        String version = System.getProperty(\"jdk.test.docker.image.version\");\n+        String version = System.getProperty(BASE_IMAGE_VERSION);\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,500 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.containers.docker.DockerfileConfig;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.FileUtils;\n+\n+import javax.imageio.IIOException;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+public class CracBuilder {\n+    private static final String DEFAULT_IMAGE_DIR = \"cr\";\n+    \/\/ Make it unique so that tests running in parallel do not conflict with:\n+    \/\/ docker: Error response from daemon: Conflict. The container name \"\/crac-test\" is already in use by container \"<hash>\". You have to remove (or rename) that container to be able to reuse that name.\n+    public static final String CONTAINER_NAME = \"crac-test\" + ProcessHandle.current().pid();\n+    public static final String JAVA = Utils.TEST_JDK + \"\/bin\/java\";\n+    public static final String DOCKER_JAVA = \"\/jdk\/bin\/java\";\n+    private static final List<String> CRIU_CANDIDATES = Arrays.asList(Utils.TEST_JDK + \"\/lib\/criu\", \"\/usr\/sbin\/criu\", \"\/sbin\/criu\");\n+    private static final String CRIU_PATH;\n+\n+    \/\/ This dummy field is here as workaround for (possibly) a JTReg bug;\n+    \/\/ some tests don't build CracTestArg into their Test.d\/ directory\n+    \/\/ (not all classes from \/test\/lib are built!) and the tests would fail.\n+    \/\/ This does not always happen when the test is run individually but breaks\n+    \/\/ when the whole suite is executed.\n+    private static final Class<CracTestArg> dummyWorkaround = CracTestArg.class;\n+\n+    boolean verbose = true;\n+    boolean debug = false;\n+    final List<String> classpathEntries = new ArrayList<>();\n+    final Map<String, String> env = new HashMap<>();\n+    final List<String> vmOptions = new ArrayList<>();\n+    final Map<String, String> javaOptions = new HashMap<>();\n+    String imageDir = DEFAULT_IMAGE_DIR;\n+    CracEngine engine;\n+    String[] engineArgs;\n+    boolean printResources;\n+    Class<?> main;\n+    String[] args;\n+    boolean captureOutput;\n+    String dockerImageBaseName;\n+    String dockerImageBaseVersion;\n+    String dockerImageName;\n+    private String[] dockerOptions;\n+    private List<String> dockerCheckpointOptions;\n+    boolean containerUsePrivileged = true;\n+    private List<String> containerSetupCommand;\n+    boolean runContainerDirectly = false;\n+    \/\/ make sure to update copy() when adding another field here\n+\n+    boolean containerStarted;\n+\n+    static {\n+        String path = System.getenv(\"CRAC_CRIU_PATH\");\n+        if (path == null) {\n+            for (String candidate : CRIU_CANDIDATES) {\n+                if (new File(candidate).exists()) {\n+                    path = candidate;\n+                    break;\n+                }\n+            }\n+        }\n+        CRIU_PATH = path;\n+    }\n+\n+    public CracBuilder() {\n+    }\n+\n+    public CracBuilder copy() {\n+        CracBuilder other = new CracBuilder();\n+        other.verbose = verbose;\n+        other.debug = debug;\n+        other.classpathEntries.addAll(classpathEntries);\n+        other.env.putAll(env);\n+        other.vmOptions.addAll(vmOptions);\n+        other.javaOptions.putAll(javaOptions);\n+        other.imageDir = imageDir;\n+        other.engine = engine;\n+        other.engineArgs = engineArgs == null ? null : Arrays.copyOf(engineArgs, engineArgs.length);\n+        other.printResources = printResources;\n+        other.main = main;\n+        other.args = args == null ? null : Arrays.copyOf(args, args.length);\n+        other.captureOutput = captureOutput;\n+        other.dockerImageName = dockerImageName;\n+        other.dockerOptions = dockerOptions == null ? null : Arrays.copyOf(dockerOptions, dockerOptions.length);\n+        other.dockerCheckpointOptions = dockerCheckpointOptions;\n+        other.containerUsePrivileged = containerUsePrivileged;\n+        other.containerSetupCommand = containerSetupCommand;\n+        other.runContainerDirectly = runContainerDirectly;\n+        return other;\n+    }\n+\n+    public CracBuilder verbose(boolean verbose) {\n+        this.verbose = verbose;\n+        return this;\n+    }\n+\n+    public CracBuilder debug(boolean debug) {\n+        this.debug = debug;\n+        return this;\n+    }\n+\n+    public CracBuilder dockerCheckpointOptions(List<String> options) {\n+        this.dockerCheckpointOptions = options;\n+        return this;\n+    }\n+\n+    public CracBuilder containerSetup(List<String> cmd) {\n+        this.containerSetupCommand = cmd;\n+        return this;\n+    }\n+\n+    public CracBuilder containerUsePrivileged(boolean usePrivileged) {\n+        this.containerUsePrivileged = usePrivileged;\n+        return this;\n+    }\n+\n+    public CracBuilder runContainerDirectly(boolean runDirectly) {\n+        this.runContainerDirectly = runDirectly;\n+        return this;\n+    }\n+\n+    public CracBuilder classpathEntry(String cp) {\n+        classpathEntries.add(cp);\n+        return this;\n+    }\n+\n+    public CracBuilder engine(CracEngine engine, String... args) {\n+        assertTrue(this.engine == null || this.engine.equals(engine)); \/\/ allow overwriting args\n+        this.engine = engine;\n+        this.engineArgs = args;\n+        return this;\n+    }\n+\n+    public Path imageDir() {\n+        return Path.of(imageDir);\n+    }\n+\n+    public CracBuilder imageDir(String imageDir) {\n+        assertEquals(DEFAULT_IMAGE_DIR, this.imageDir); \/\/ set once\n+        this.imageDir = imageDir;\n+        return this;\n+    }\n+\n+    public CracBuilder vmOption(String option) {\n+        vmOptions.add(option);\n+        return this;\n+    }\n+\n+    public void clearVmOptions() {\n+        vmOptions.clear();\n+    }\n+\n+    public CracBuilder printResources(boolean print) {\n+        this.printResources = print;\n+        return this;\n+    }\n+\n+    public CracBuilder env(String name, String value) {\n+        env.put(name, value);\n+        return this;\n+    }\n+\n+    public CracBuilder javaOption(String name, String value) {\n+        javaOptions.put(name, value);\n+        return this;\n+    }\n+\n+    public CracBuilder main(Class<?> mainClass) {\n+        assertNull(this.main); \/\/ set once\n+        this.main = mainClass;\n+        return this;\n+    }\n+\n+    public Class<?> main() {\n+        return main != null ? main : CracTest.class;\n+    }\n+\n+    public CracBuilder args(String... args) {\n+        assertNull(this.args); \/\/ set once\n+        this.args = args;\n+        return this;\n+    }\n+\n+    public String[] args() {\n+        return args != null ? args : CracTest.args();\n+    }\n+\n+    public CracBuilder captureOutput(boolean captureOutput) {\n+        this.captureOutput = captureOutput;\n+        return this;\n+    }\n+\n+    public CracBuilder withBaseImage(String name, String tag) {\n+        assertNull(dockerImageBaseName);\n+        assertNull(dockerImageBaseVersion);\n+        this.dockerImageBaseName = name;\n+        this.dockerImageBaseVersion = tag;\n+        return this;\n+    }\n+\n+    public CracBuilder inDockerImage(String imageName) {\n+        assertNull(dockerImageName);\n+        this.dockerImageName = imageName;\n+        return this;\n+    }\n+\n+    public CracBuilder dockerOptions(String... options) {\n+        assertNull(dockerOptions);\n+        this.dockerOptions = options;\n+        return this;\n+    }\n+\n+    public void doCheckpoint(String... javaPrefix) throws Exception {\n+        startCheckpoint(javaPrefix).waitForCheckpointed();\n+    }\n+\n+    public CracProcess startCheckpoint(String... javaPrefix) throws Exception {\n+        List<String> list = javaPrefix.length == 0 ? null : Arrays.asList(javaPrefix);\n+        return startCheckpoint(list);\n+    }\n+\n+    public CracProcess startCheckpoint(List<String> javaPrefix) throws Exception {\n+        if (runContainerDirectly) {\n+            prepareContainer();\n+        } else {\n+            ensureContainerStarted();\n+        }\n+        List<String> cmd = prepareCommand(javaPrefix, false);\n+        cmd.add(\"-XX:CRaCCheckpointTo=\" + imageDir);\n+        cmd.add(main().getName());\n+        cmd.addAll(Arrays.asList(args()));\n+        log(\"Starting process to be checkpointed:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    void log(String fmt, Object... args) {\n+        if (verbose) {\n+            if (args.length == 0) {\n+                System.err.println(fmt);\n+            } else {\n+                System.err.printf(fmt, args);\n+            }\n+        }\n+    }\n+\n+    public void ensureContainerStarted() throws Exception {\n+        if (dockerImageName == null) {\n+            return;\n+        }\n+        if (CRIU_PATH == null) {\n+            fail(\"CRAC_CRIU_PATH is not set and cannot find criu executable in any of: \" + CRIU_CANDIDATES);\n+        }\n+        if (!containerStarted) {\n+            prepareContainer();\n+            List<String> cmd = prepareContainerCommand(dockerImageName, dockerOptions);\n+            log(\"Starting docker container:\\n\" + String.join(\" \", cmd));\n+            assertEquals(0, new ProcessBuilder().inheritIO().command(cmd).start().waitFor());\n+            containerSetup();\n+            containerStarted = true;\n+        }\n+    }\n+\n+    private void prepareContainer() throws Exception {\n+        if (runContainerDirectly && null != containerSetupCommand) {\n+            fail(\"runContainerDirectly and containerSetupCommand cannot be used together.\");\n+        }\n+        ensureContainerKilled();\n+\n+        \/\/ FIXME cooperate better with DockerTestUtils\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(Path.of(\".\", dockerImageName.replace(\":\", \"-\")));\n+        } catch (NoSuchFileException ignore) {\n+        }\n+\n+        buildDockerImage();\n+        \/\/ Make sure we start with a clean image directory\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"volume\", \"rm\", \"cr\");\n+    }\n+\n+    private void containerSetup() throws Exception {\n+        if (null != containerSetupCommand && 0 < containerSetupCommand.size()) {\n+            List<String> cmd = new ArrayList<>();\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+            cmd.addAll(containerSetupCommand);\n+            log(\"Container set up:\\n\" + String.join(\" \", cmd));\n+            DockerTestUtils.execute(cmd).shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    private void buildDockerImage() throws Exception {\n+        String previousBaseImageName = null;\n+        String previousBaseImageVersion = null;\n+        try {\n+            previousBaseImageName = System.getProperty(DockerfileConfig.BASE_IMAGE_NAME);\n+            previousBaseImageVersion = System.getProperty(DockerfileConfig.BASE_IMAGE_VERSION);\n+            if (dockerImageBaseName != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_NAME, dockerImageBaseName);\n+            }\n+            if (dockerImageBaseVersion != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_VERSION, dockerImageBaseVersion);\n+            }\n+            DockerTestUtils.buildJdkContainerImage(dockerImageName);\n+        } finally {\n+            if (previousBaseImageName != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_NAME, previousBaseImageName);\n+            } else {\n+                System.clearProperty(DockerfileConfig.BASE_IMAGE_NAME);\n+            }\n+            if (previousBaseImageVersion != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_VERSION, previousBaseImageVersion);\n+            } else {\n+                System.clearProperty(DockerfileConfig.BASE_IMAGE_VERSION);\n+            }\n+        }\n+    }\n+\n+    private List<String> prepareContainerCommandBase(String imageName, String[] options) {\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(Container.ENGINE_COMMAND);\n+        cmd.addAll(Arrays.asList(\"run\", \"--rm\"));\n+        if (!runContainerDirectly) {\n+            cmd.add(\"-d\");\n+            cmd.add(\"--init\"); \/\/ otherwise the checkpointed process would not be reaped (by sleep with PID 1)\n+        }\n+        if (containerUsePrivileged) {\n+            cmd.add(\"--privileged\"); \/\/ required to give CRIU sufficient permissions\n+        }\n+        int entryCounter = 0;\n+        for (var entry : Utils.TEST_CLASS_PATH.split(File.pathSeparator)) {\n+            cmd.addAll(Arrays.asList(\"--volume\", entry + \":\/cp\/\" + (entryCounter++)));\n+        }\n+        cmd.addAll(Arrays.asList(\"--volume\", \"cr:\/cr\"));\n+        cmd.addAll(Arrays.asList(\"--volume\", CRIU_PATH + \":\/criu\"));\n+        cmd.addAll(Arrays.asList(\"--env\", \"CRAC_CRIU_PATH=\/criu\"));\n+        cmd.addAll(Arrays.asList(\"--name\", CONTAINER_NAME));\n+        if (debug) {\n+            cmd.addAll(Arrays.asList(\"--publish\", \"5005:5005\"));\n+        }\n+        if (options != null) {\n+            cmd.addAll(Arrays.asList(options));\n+        }\n+        cmd.add(imageName);\n+        return cmd;\n+    }\n+\n+    private List<String> prepareContainerCommand(String imageName, String[] options) {\n+        List<String> cmd = prepareContainerCommandBase(imageName, options);\n+        cmd.addAll(Arrays.asList(\"sleep\", \"3600\"));\n+        return cmd;\n+    }\n+\n+    public void ensureContainerKilled() throws Exception {\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"kill\", CONTAINER_NAME).getExitValue();\n+        DockerTestUtils.removeDockerImage(dockerImageName);\n+    }\n+\n+    public void recreateContainer(String imageName, String... options) throws Exception {\n+        assertTrue(containerStarted);\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"kill\", CONTAINER_NAME).getExitValue();\n+        List<String> cmd = prepareContainerCommand(imageName, options);\n+        log(\"Recreating docker container:\\n\" + String.join(\" \", cmd));\n+        assertEquals(0, new ProcessBuilder().inheritIO().command(cmd).start().waitFor());\n+    }\n+\n+    public CracProcess doRestore(String... javaPrefix) throws Exception {\n+        return startRestore(javaPrefix).waitForSuccess();\n+    }\n+\n+    public CracProcess startRestore(String... javaPrefix) throws Exception {\n+         List<String> list = javaPrefix.length == 0 ? null : Arrays.asList(javaPrefix);\n+         return startRestore(list);\n+    }\n+\n+    public CracProcess startRestore(List<String> javaPrefix) throws Exception {\n+        ensureContainerStarted();\n+        List<String> cmd = prepareCommand(javaPrefix, true);\n+        cmd.add(\"-XX:CRaCRestoreFrom=\" + imageDir);\n+        log(\"Starting restored process:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    public CracProcess startPlain() throws IOException {\n+        List<String> cmd = new ArrayList<>();\n+        if (dockerImageName != null) {\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+        }\n+        cmd.add(JAVA);\n+        cmd.add(\"-ea\");\n+        cmd.add(\"-cp\");\n+        cmd.add(getClassPath());\n+        if (debug) {\n+            cmd.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=0.0.0.0:5005\");\n+        }\n+        cmd.add(main().getName());\n+        cmd.addAll(Arrays.asList(args()));\n+        log(\"Starting process without CRaC:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    private String getClassPath() {\n+        String classPath = classpathEntries.isEmpty() ? \"\" : String.join(File.pathSeparator, classpathEntries) + File.pathSeparator;\n+        if (dockerImageName == null) {\n+            classPath += Utils.TEST_CLASS_PATH;\n+        } else {\n+            int numEntries = Utils.TEST_CLASS_PATH.split(File.pathSeparator).length;\n+            for (int i = 0; i < numEntries; ++i) {\n+                classPath += \"\/cp\/\" + i + File.pathSeparator;\n+            }\n+        }\n+        return classPath;\n+    }\n+\n+    public CracProcess doPlain() throws IOException, InterruptedException {\n+        return startPlain().waitForSuccess();\n+    }\n+\n+    private List<String> prepareCommand(List<String> javaPrefix, boolean isRestore) {\n+        List<String> cmd = new ArrayList<>();\n+        if (javaPrefix != null) {\n+            cmd.addAll(javaPrefix);\n+        } else if (dockerImageName != null) {\n+            if (runContainerDirectly) {\n+                cmd = prepareContainerCommandBase(dockerImageName, dockerOptions);\n+            } else {\n+                cmd.add(Container.ENGINE_COMMAND);\n+                cmd.add(\"exec\");\n+                if (null != dockerCheckpointOptions) {\n+                    cmd.addAll(dockerCheckpointOptions);\n+                }\n+                cmd.add(CONTAINER_NAME);\n+            }\n+            cmd.add(DOCKER_JAVA);\n+        } else {\n+            cmd.add(JAVA);\n+        }\n+        cmd.add(\"-ea\");\n+        if (engine != null) {\n+            String engArgs = engineArgs == null || engineArgs.length == 0 ? \"\" :\n+                    \",\" + Arrays.stream(engineArgs)\n+                            .map(str -> str.replace(\",\", \"\\\\,\"))\n+                            .collect(Collectors.joining(\",\"));\n+            cmd.add(\"-XX:CREngine=\" + engine.engine + engArgs);\n+        }\n+        if (!isRestore) {\n+            cmd.add(\"-cp\");\n+            cmd.add(getClassPath());\n+            if (printResources) {\n+                cmd.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+                cmd.add(\"-XX:+CRPrintResourcesOnCheckpoint\");\n+            }\n+        }\n+        if (debug) {\n+            cmd.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=0.0.0.0:5005\");\n+            if (!isRestore) {\n+                cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n+                cmd.add(\"-XX:-CRDoThrowCheckpointException\");\n+            }\n+        }\n+        cmd.addAll(vmOptions);\n+        for (var entry : javaOptions.entrySet()) {\n+            cmd.add(\"-D\" + entry.getKey() + \"=\" + entry.getValue());\n+        }\n+        return cmd;\n+    }\n+\n+    public void doCheckpointAndRestore() throws Exception {\n+        doCheckpoint();\n+        doRestore();\n+    }\n+\n+    public void checkpointViaJcmd() throws Exception {\n+        runJcmd(main().getName(), \"JDK.checkpoint\").shouldHaveExitValue(0);\n+    }\n+\n+    public OutputAnalyzer runJcmd(String id, String... command) throws Exception {\n+        List<String> cmd = new ArrayList<>();\n+        if (dockerImageName != null) {\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME, \"\/jdk\/bin\/jcmd\"));\n+        } else {\n+            cmd.add(Utils.TEST_JDK + \"\/bin\/jcmd\");\n+        }\n+        cmd.add(id);\n+        cmd.addAll(Arrays.asList(command));\n+        \/\/ This works for non-docker commands, too\n+        return DockerTestUtils.execute(cmd);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":500,"deletions":0,"binary":false,"changes":500,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+package jdk.test.lib.crac;\n+\n+public enum CracEngine {\n+    CRIU(\"criuengine\"),\n+    PAUSE(System.getProperty(\"os.name\").contains(\"Windows\") ? \"pauseengine.exe\" : \"pauseengine\"),\n+    SIMULATE(System.getProperty(\"os.name\").contains(\"Windows\") ? \"simengine.exe\" : \"simengine\");\n+\n+    public final String engine;\n+\n+    CracEngine(String engine) {\n+        this.engine = engine;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracEngine.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.StreamPumper;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+public class CracProcess {\n+    private final CracBuilder builder;\n+    private final Process process;\n+\n+    public CracProcess(CracBuilder builder, List<String> cmd) throws IOException {\n+        this.builder = builder;\n+        ProcessBuilder pb = new ProcessBuilder().inheritIO().redirectInput(ProcessBuilder.Redirect.PIPE);\n+        if (builder.captureOutput) {\n+            pb.redirectOutput(ProcessBuilder.Redirect.PIPE);\n+            pb.redirectError(ProcessBuilder.Redirect.PIPE);\n+        }\n+        pb.environment().putAll(builder.env);\n+        this.process = pb.command(cmd).start();\n+    }\n+\n+    public int waitFor() throws InterruptedException {\n+        return process.waitFor();\n+    }\n+\n+    public void waitForCheckpointed() throws InterruptedException {\n+        if (builder.engine == null || builder.engine == CracEngine.CRIU) {\n+            assertEquals(137, process.waitFor(), \"Checkpointed process was not killed as expected.\");\n+            \/\/ TODO: we could check that \"CR: Checkpoint\" was written out\n+        } else {\n+            fail(\"With engine \" + builder.engine.engine + \" use the async version.\");\n+        }\n+    }\n+\n+    public void waitForPausePid() throws IOException, InterruptedException {\n+        assertEquals(CracEngine.PAUSE, builder.engine, \"Pause PID file created only with pauseengine\");\n+\n+        \/\/ (at least on Windows) we need to wait to avoid os::prepare_checkpoint() interference with mkdir\/rmdir calls\n+        Thread.sleep(500);\n+\n+        try (WatchService watcher = FileSystems.getDefault().newWatchService()) {\n+            Path imageDir = builder.imageDir().toAbsolutePath();\n+            waitForFileCreated(watcher, imageDir.getParent(), path -> \"cr\".equals(path.toFile().getName()));\n+            waitForFileCreated(watcher, imageDir, path -> \"pid\".equals(path.toFile().getName()));\n+        }\n+    }\n+\n+    private void waitForFileCreated(WatchService watcher, Path dir, Predicate<Path> predicate) throws IOException, InterruptedException {\n+        WatchKey key = dir.register(watcher, StandardWatchEventKinds.ENTRY_CREATE);\n+        assertTrue(key.isValid());\n+        try {\n+            try (Stream<Path> dirContents = Files.list(dir)) {\n+                if (dirContents.anyMatch(predicate)) {\n+                    \/\/ file already present\n+                    return;\n+                }\n+            }\n+            int timeoutCounter = 10;\n+            for (; ; ) {\n+                WatchKey key2 = watcher.poll(1, TimeUnit.SECONDS);\n+                if (null == key2) {\n+                    if (!process.isAlive() && 0 < --timeoutCounter) {\n+                        \/\/ At least on macOS, it seems like WatchService's event may be delayed up to 10 secs,\n+                        \/\/ so we need to keep waiting some time for the event, even the process is completed.\n+                        continue;\n+                    }\n+                    assertTrue(process.isAlive(), \"Process should exist\");\n+                    continue;\n+                }\n+                for (WatchEvent<?> event : key2.pollEvents()) {\n+                    if (event.kind() != StandardWatchEventKinds.ENTRY_CREATE) {\n+                        continue;\n+                    }\n+                    if (predicate.test((Path) event.context())) {\n+                        return;\n+                    }\n+                }\n+                key2.reset();\n+            }\n+        } finally {\n+            key.cancel();\n+        }\n+    }\n+\n+    public CracProcess waitForSuccess() throws InterruptedException {\n+        int exitValue = process.waitFor();\n+        if (exitValue != 0 && builder.captureOutput) {\n+            try {\n+                OutputAnalyzer oa = outputAnalyzer();\n+                System.err.print(oa.getStderr());\n+                System.out.print(oa.getStdout());\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        assertEquals(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+        builder.log(\"Process %d completed with exit value %d%n\", process.pid(), exitValue);\n+        return this;\n+    }\n+\n+    public OutputAnalyzer outputAnalyzer() throws IOException {\n+        assertTrue(builder.captureOutput, \"Output must be captured with .captureOutput(true)\");\n+        return new OutputAnalyzer(process);\n+    }\n+\n+    public CracProcess watch(Consumer<String> outputConsumer, Consumer<String> errorConsumer) {\n+        assertTrue(builder.captureOutput, \"Output must be captured with .captureOutput(true)\");\n+        pump(process.getInputStream(), outputConsumer);\n+        pump(process.getErrorStream(), errorConsumer);\n+        return this;\n+    }\n+\n+    private static void pump(InputStream stream, Consumer<String> consumer) {\n+        new StreamPumper(stream).addPump(new StreamPumper.LinePump() {\n+            @Override\n+            protected void processLine(String line) {\n+                consumer.accept(line);\n+            }\n+        }).process();\n+    }\n+\n+    public long pid() {\n+        return process.pid();\n+    }\n+\n+    public OutputStream input() {\n+        return process.getOutputStream();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.crac.Core;\n+\n+import java.lang.reflect.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * CRaC tests usually consists of two parts; the test started by JTreg through the 'run' tag\n+ * and subprocesses started by the test with various VM options. These are represented by the\n+ * {@link #test()} and {@link #exec()} methods.\n+ * CracTest use '@run driver jdk.test.crac.lib.CracTest' as the executable command; the main\n+ * method in this class discovers the executed class from system properties passed by JTReg,\n+ * instantiates the test (public no-arg constructor is needed), populates fields annotated\n+ * with {@link CracTestArg} and executes the {@link #test()} method.\n+ * The test method is expected to use {@link CracBuilder} to start another process. By default,\n+ * CracBuilder invokes the test with arguments that will again instantiate and fill the instance\n+ * and invoke the {@link #exec()} method.\n+ *\/\n+public interface CracTest {\n+\n+    String RESTORED_MESSAGE = \"Restored\";\n+\n+    \/**\n+     * This method is called when JTReg invokes the test; it is supposed to start\n+     * another process (most often using CRaC VM options) and validate its behaviour.\n+     *\n+     * @throws Exception\n+     *\/\n+    void test() throws Exception;\n+\n+    \/**\n+     * This method is invoked in the subprocess; this is where you're likely to call\n+     * {@link Core#checkpointRestore()}.\n+     *\n+     * @throws Exception\n+     *\/\n+    void exec() throws Exception;\n+\n+    class ArgsHolder {\n+        private static final String RUN_TEST = \"__run_test__\";\n+        private static Class<? extends CracTest> testClass;\n+        private static String[] args;\n+        \/\/ This field is present as workaround for @build <test> somehow missing\n+        \/\/ the annotation when\n+        private static final Class<CracTestArg> dummyField = CracTestArg.class;\n+    }\n+\n+    \/**\n+     * Main method for orchestrating the test. This should be called directly by JTReg.\n+     *\/\n+    static void main(String[] args) throws Exception {\n+        String testClassName;\n+        if (args.length == 0 || !ArgsHolder.RUN_TEST.equals(args[0])) {\n+            \/\/ We will look up the class name (and package) to avoid boilerplate in any @run invocation\n+            String testFile = System.getProperty(\"test.file\");\n+            String source = Files.readString(Path.of(testFile)).replace('\\n', ' ');\n+            Matcher clsMatcher = Pattern.compile(\"class\\\\s+(\\\\S+)\\\\s+(extends\\\\s+\\\\S+\\\\s+)?implements\\\\s+(\\\\S+\\\\s*,\\\\s*)*CracTest\").matcher(source);\n+            if (!clsMatcher.find()) {\n+                fail(\"Cannot find test class in \" + testFile + \", does it look like class <test> implements CracTest?\");\n+            }\n+            testClassName = clsMatcher.group(1);\n+            Matcher pkgMatcher = Pattern.compile(\"package\\\\s+([^;]+);\").matcher(source);\n+            if (pkgMatcher.find()) {\n+                testClassName = pkgMatcher.group(1) + \".\" + testClassName;\n+            }\n+        } else {\n+            testClassName = args[1];\n+        }\n+\n+        \/\/ When we use CracTest as driver the file with test is not compiled without a @build tag.\n+        \/\/ We could compile the class here and load it from a new classloader but since the test library\n+        \/\/ is not compiled completely we could be missing some dependencies - this would be just too fragile.\n+        Class<?> testClass;\n+        try {\n+            testClass = Class.forName(testClassName);\n+        } catch (ClassNotFoundException e) {\n+            throw new ClassNotFoundException(\"Test class \" + testClassName + \" not found, add jtreg tag @build \" + testClassName, e);\n+        }\n+        if (CracTest.class.isAssignableFrom(testClass)) {\n+            \/\/noinspection unchecked\n+            run((Class<? extends CracTest>) testClass, args);\n+        } else {\n+            throw new IllegalArgumentException(\"Class \" + testClass.getName() + \" does not implement CracTest!\");\n+        }\n+    }\n+\n+    \/**\n+     * This method should be invoked from the public static void main(String[]) method.\n+     *\n+     * @param testClass Class implementing the test.\n+     * @param args Arguments received in the main method.\n+     * @throws Exception\n+     *\/\n+    static void run(Class<? extends CracTest> testClass, String[] args) throws Exception {\n+        assertNotNull(args);\n+        ArgsHolder.testClass = testClass;\n+        int argsOffset = 0;\n+        if (args.length == 0 || !args[0].equals(ArgsHolder.RUN_TEST)) {\n+            String[] newArgs = new String[args.length + 2];\n+            newArgs[0] = ArgsHolder.RUN_TEST;\n+            newArgs[1] = testClass.getName();\n+            System.arraycopy(args, 0, newArgs, 2, args.length);\n+            ArgsHolder.args = newArgs;\n+        } else {\n+            argsOffset = 2;\n+        }\n+\n+        try {\n+            Constructor<? extends CracTest> ctor = testClass.getConstructor();\n+            CracTest testInstance = ctor.newInstance();\n+            Field[] argFields = getArgFields(testClass);\n+            for (int index = 0; index < argFields.length; index++) {\n+                Field f = argFields[index];\n+                assertFalse(Modifier.isFinal(f.getModifiers()), \"@CracTestArg fields must not be final!\");\n+                Class<?> t = f.getType();\n+                if (index + argsOffset >= args.length) {\n+                    if (f.getAnnotation(CracTestArg.class).optional()) {\n+                        break;\n+                    } else {\n+                        fail(\"Not enough args for field \" + f.getName() + \"(\" + index + \"): have \" + (args.length - argsOffset));\n+                    }\n+                }\n+                String arg = args[index + argsOffset];\n+                Object value = arg;\n+                if (t == boolean.class || t == Boolean.class) {\n+                    assertTrue(\"true\".equals(arg) || \"false\".equals(arg), \"Argument \" + index + \"Boolean arg should be either 'true' or 'false', was: \" + arg);\n+                    value = Boolean.parseBoolean(arg);\n+                } else if (t == int.class || t == Integer.class) {\n+                    try {\n+                        value = Integer.parseInt(arg);\n+                    } catch (NumberFormatException e) {\n+                        fail(\"Cannot parse argument '\" + arg + \"' as integer for @CracTestArg(\" + index + \") \" + f.getName());\n+                    }\n+                } else if (t == long.class || t == Long.class) {\n+                    try {\n+                        value = Long.parseLong(arg);\n+                    } catch (NumberFormatException e) {\n+                        fail(\"Cannot parse argument '\" + arg + \"' as long for @CracTestArg(\" + index + \") \" + f.getName());\n+                    }\n+                } else if (t.isEnum()) {\n+                    value = Enum.valueOf((Class<Enum>) t, arg);\n+                }\n+                f.setAccessible(true);\n+                f.set(testInstance, value);\n+            }\n+            if (argsOffset == 0) {\n+                testInstance.test();\n+            } else {\n+                testInstance.exec();\n+            }\n+        } catch (NoSuchMethodException e) {\n+            fail(\"Test class \" + testClass.getName() + \" is expected to have a public no-arg constructor\");\n+        }\n+    }\n+\n+    private static Field[] getArgFields(Class<? extends CracTest> testClass) {\n+        \/\/ TODO: check superclasses\n+        Field[] sortedFields = Stream.of(testClass.getDeclaredFields()).filter(f -> f.isAnnotationPresent(CracTestArg.class))\n+                .sorted(Comparator.comparingInt(f -> f.getAnnotation(CracTestArg.class).value()))\n+                .toArray(Field[]::new);\n+        if (sortedFields.length == 0) {\n+            return sortedFields;\n+        }\n+        int firstOptional = -1;\n+        for (int i = 0; i < sortedFields.length; ++i) {\n+            CracTestArg annotation = sortedFields[i].getAnnotation(CracTestArg.class);\n+            int index = annotation.value();\n+            assertGreaterThanOrEqual(index, 0);\n+            if (i == 0) {\n+                assertEquals(0, index, \"@CracTestArg numbers should start with 0\");\n+            }\n+            if (index < i) {\n+                fail(\"Duplicate @CracTestArg(\" + index + \"): both fields \" + sortedFields[i - 1].getName() + \" and \" + sortedFields[i].getName());\n+            } else if (index > i) {\n+                fail(\"Gap in @CracTestArg indices: missing \" + i + \", next is \" + index);\n+            }\n+            if (annotation.optional()) {\n+                firstOptional = index;\n+            } else if (firstOptional >= 0) {\n+                fail(\"Argument \" + firstOptional + \" is optional; all subsequent arguments must be optional, too.\");\n+            }\n+        }\n+        return sortedFields;\n+    }\n+\n+    \/**\n+     * Used as argument for {@link CracBuilder#args(String...)}.\n+     *\/\n+    static String[] args(String... extraArgs) {\n+        assertNotNull(ArgsHolder.args, \"Args are null; are you trying to access them from test method?\");\n+        if (extraArgs == null || extraArgs.length == 0) {\n+            return ArgsHolder.args;\n+        } else {\n+            return Stream.concat(Stream.of(ArgsHolder.args), Stream.of(extraArgs)).toArray(String[]::new);\n+        }\n+    }\n+\n+    static Class<? extends CracTest> testClass() {\n+        return ArgsHolder.testClass;\n+    }\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+package jdk.test.lib.crac;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Used to mark fields in {@link CracTest} that should be populated from main method arguments.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+public @interface CracTestArg {\n+    \/**\n+     * @return The (zero-based) index of the argument used as source of the data.\n+     *\/\n+    int value() default 0;\n+\n+    \/**\n+     * @return Can this argument be omitted?\n+     *\/\n+    boolean optional() default false;\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTestArg.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -926,5 +926,0 @@\n-\n-    @Benchmark\n-    public int testHeapHashCode() {\n-        return heapByteBuffer.hashCode();\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/ByteBuffers.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.vm.compiler;\n-\n-import java.util.concurrent.TimeUnit;\n-import java.util.random.RandomGeneratorFactory;\n-import org.openjdk.jmh.annotations.*;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@State(Scope.Thread)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@Fork(value = 1)\n-public class CMove {\n-    static final int SIZE = 1000000;\n-\n-    @Param({\"0.003\", \"0.006\", \"0.01\", \"0.02\", \"0.03\", \"0.06\", \"0.1\", \"0.2\", \"0.3\", \"0.6\"})\n-    double freq;\n-\n-    boolean[] conds;\n-\n-    @Setup(Level.Iteration)\n-    public void setup() {\n-        var r = RandomGeneratorFactory.getDefault().create(1);\n-        conds = new boolean[SIZE];\n-        for (int i = 0; i < SIZE; i++) {\n-            conds[i] = r.nextDouble() < freq;\n-        }\n-    }\n-\n-    @Benchmark\n-    public void run(Blackhole bh) {\n-        for (int i = 0; i < conds.length; i++) {\n-            bh.consume(conds[i] ? 2 : 1);\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/CMove.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"}]}