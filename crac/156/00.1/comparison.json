{"files":[{"patch":"@@ -55,3 +55,3 @@\n-          - s390x\n-          - ppc64le\n-          - riscv64\n+          # - s390x\n+          # - ppc64le\n+          # - riscv64\n@@ -72,18 +72,18 @@\n-          - target-cpu: s390x\n-            gnu-arch: s390x\n-            debian-arch: s390x\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: bullseye\n-            tolerate-sysroot-errors: false\n-          - target-cpu: ppc64le\n-            gnu-arch: powerpc64le\n-            debian-arch: ppc64el\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: bullseye\n-            tolerate-sysroot-errors: false\n-          - target-cpu: riscv64\n-            gnu-arch: riscv64\n-            debian-arch: riscv64\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: sid\n-            tolerate-sysroot-errors: true\n+#          - target-cpu: s390x\n+#            gnu-arch: s390x\n+#            debian-arch: s390x\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: bullseye\n+#            tolerate-sysroot-errors: false\n+#          - target-cpu: ppc64le\n+#            gnu-arch: powerpc64le\n+#            debian-arch: ppc64el\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: bullseye\n+#            tolerate-sysroot-errors: false\n+#          - target-cpu: riscv64\n+#            gnu-arch: riscv64\n+#            debian-arch: riscv64\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: sid\n+#            tolerate-sysroot-errors: true\n","filename":".github\/workflows\/build-cross-compile.yml","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+          - 'jdk\/crac'\n@@ -73,0 +74,3 @@\n+          - test-name: 'jdk\/crac'\n+            test-suite: 'test\/jdk\/jdk\/crac\/'\n+\n@@ -166,0 +170,6 @@\n+      - name: 'Setup CRIU'\n+        uses: .\/.github\/actions\/setup-criu\n+        with:\n+          jdk-path: ${{ steps.bundles.outputs.jdk-path }}\n+        if: runner.os == 'Linux' && matrix.test-name == 'jdk\/crac'\n+\n","filename":".github\/workflows\/test.yml","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=crac\n@@ -7,2 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n-warning=issuestitle\n+error=whitespace\n@@ -10,3 +9,3 @@\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=.*\n+[checks \"reviewers\"]\n+committers=1\n+ignore=duke\n@@ -17,20 +16,0 @@\n-\n-[checks \"whitespace\"]\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.S|.*\\.md|.*\\.properties|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n-ignore-tabs=.*\\.gmk|Makefile\n-\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n-[checks \"committer\"]\n-role=committer\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":5,"deletions":26,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -229,0 +229,4 @@\n+$(eval $(call SetupBuildDemo, JavaCompilerCRaC, \\\n+    DEMO_SUBDIR := crac, \\\n+))\n+\n","filename":"make\/CompileDemos.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+    -tag crac:cmopt:'CRaC:' \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,4 +24,13 @@\n-# This Makefile was generated by configure @DATE_WHEN_CONFIGURED@\n-# GENERATED FILE, DO NOT EDIT\n-SPEC:=@OUTPUTDIR@\/spec.gmk\n-include @WORKSPACE_ROOT@\/Makefile\n+AsyncGetCallTrace\n+jio_fprintf\n+jio_printf\n+jio_snprintf\n+jio_vfprintf\n+jio_vsnprintf\n+JNI_CreateJavaVM\n+JNI_GetCreatedJavaVMs\n+JNI_GetDefaultJavaVMInitArgs\n+JVM_IsForeignLinkerSupported\n+JVM_FindClassFromBootLoader\n+JVM_InitAgentProperties\n+JVM_Checkpoint\n","filename":"make\/autoconf\/Makefile.template","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    cpu_feature_active \\\n@@ -368,0 +369,22 @@\n+###############################################################################\n+# Check if glibc CPU_FEATURE_ACTIVE is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(cpu_feature_active, [\n+    AC_MSG_CHECKING([if glibc CPU_FEATURE_ACTIVE is supported])\n+    AC_COMPILE_IFELSE(\n+      [AC_LANG_PROGRAM([[#include <sys\/platform\/x86.h>]],\n+        [[int x = CPU_FEATURE_ACTIVE(SSE2);]])\n+      ],\n+      [\n+        AC_MSG_RESULT([yes])\n+      ],\n+      [\n+        AC_MSG_RESULT([no])\n+        AVAILABLE=false\n+      ]\n+    )\n+  ])\n+])\n+\n@@ -382,0 +405,1 @@\n+  JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE\n","filename":"make\/autoconf\/jvm-features.m4","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+LINUX_X64_CRIU_FILENAME=criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_URL=https:\/\/github.com\/CRaC\/criu\/releases\/download\/release-1.3\/criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_SHA256=82a014bf342c957305b98a71867c0994ebf6e7379f01f083121884793768d966\n+\n","filename":"make\/conf\/github-actions.conf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,0 +151,4 @@\n+ifneq ($(call check-jvm-feature, cpu_feature_active), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_CPU_FEATURE_ACTIVE=0\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,0 +103,49 @@\n+\n+################################################################################\n+\n+ifeq ($(OPENJDK_TARGET_OS), linux)\n+  $(eval $(call SetupJdkExecutable, BUILD_CRIUENGINE, \\\n+      NAME := criuengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criuengine, \\\n+      INCLUDE_FILES := criuengine.c, \\\n+      OPTIMIZATION := HIGH, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_CRIUENGINE)\n+\n+endif\n+\n+ifeq ($(call isTargetOs, macosx linux windows), true)\n+  ifeq ($(OPENJDK_TARGET_OS), windows)\n+    CRAC_ENGINE_DIR = modules_cmds\n+  else\n+    CRAC_ENGINE_DIR = modules_libs\n+  endif\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n+      NAME := pauseengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/pauseengine, \\\n+      INCLUDE_FILES := pauseengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_PAUSEENGINE)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_SIMENGINE, \\\n+      NAME := simengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/simengine, \\\n+      INCLUDE_FILES := simengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_SIMENGINE)\n+\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    EXCLUDES := jdk\/test\/lib\/containers jdk\/test\/lib\/security, \\\n+    EXCLUDES := jdk\/test\/lib\/containers\/cgroup jdk\/test\/lib\/security, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -189,0 +191,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -127,0 +129,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -275,0 +275,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -409,0 +409,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -569,0 +571,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, unsigned long features[] = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -239,0 +239,15 @@\n+                                                                            \\\n+  product(ccstr, CPUFeatures, NULL, \"CPU feature set, \"                     \\\n+      \"use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when you \"    \\\n+      \"get an error during -XX:CRaCRestoreFrom on a different machine; \"    \\\n+      \"-XX:CPUFeatures=native is the default; \"                             \\\n+      \"-XX:CPUFeatures=ignore will disable the CPU features check; \"        \\\n+      \"-XX:CPUFeatures=generic is compatible but not as slow as 0\")         \\\n+                                                                            \\\n+  product(bool, ShowCPUFeatures, false, \"Show features of this CPU \"        \\\n+      \"to be possibly used for the -XX:CPUFeatures=0xnumber option\")        \\\n+                                                                            \\\n+  product(bool, IgnoreCPUFeatures, false, RESTORE_SETTABLE | EXPERIMENTAL,  \\\n+      \"Do not refuse to run after -XX:CRaCRestoreFrom finds out some \"      \\\n+      \"CPU features are missing\")\n+\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -44,0 +45,3 @@\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# include <sys\/platform\/x86.h>\n+#endif\n@@ -50,0 +54,1 @@\n+uint64_t VM_Version::_glibc_features;\n@@ -52,1 +57,2 @@\n-const char* VM_Version::_features_names[] = { CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::      _features_names[] = {   CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::_glibc_features_names[] = { GLIBC_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n@@ -82,2 +88,11 @@\n-  assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), \"clflush should be available\");\n-  return true;\n+  if (!Universe::is_fully_initialized()) {\n+    return true;\n+  }\n+  if ((_features & CPU_FLUSH) != 0) {\n+    return true;\n+  }\n+  if (FLAG_IS_DEFAULT(CPUFeatures)) {\n+    vm_exit_during_initialization(\"clflush should be available\");\n+  }\n+  vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: \" UINT64_FORMAT_X, CPU_FLUSH));\n+  return false;\n@@ -799,1 +814,446 @@\n-void VM_Version::get_processor_features() {\n+uint64_t VM_Version::CPUFeatures_parse(uint64_t &glibc_features) {\n+  glibc_features = _glibc_features;\n+#ifndef LINUX\n+  _ignore_glibc_not_using = true;\n+  return _features;\n+#endif\n+  if (CPUFeatures == NULL || strcmp(CPUFeatures, \"native\") == 0) {\n+    return _features;\n+  }\n+  if (strcmp(CPUFeatures, \"ignore\") == 0) {\n+    _ignore_glibc_not_using = true;\n+    return _features;\n+  }\n+  glibc_features = 0;\n+  if (strcmp(CPUFeatures, \"generic\") == 0) {\n+    \/\/ 32-bit x86 cannot rely on anything.\n+    return 0\n+#ifdef AMD64\n+      \/\/ The following options are all in \/proc\/cpuinfo of one of the first 64-bit CPUs - Atom D2700 (and Opteron 1352): https:\/\/superuser.com\/q\/1572306\/1015048\n+      | CPU_SSE \/\/ enabled in 'gcc -Q --help=target', used by OpenJDK\n+      | CPU_SSE2 \/\/ enabled in 'gcc -Q --help=target', required by OpenJDK\n+      | CPU_FXSR \/\/ enabled in 'gcc -Q --help=target', not used by OpenJDK\n+      | CPU_MMX \/\/ enabled in 'gcc -Q --help=target', used only by 32-bit x86 OpenJDK\n+      | CPU_TSC \/\/ not used by gcc, used by OpenJDK\n+      | CPU_CX8 \/\/ gcc detects it to set cpu \"pentium\" (=32-bit only), used by OpenJDK\n+      | CPU_CMOV \/\/ gcc detects it to set cpu \"pentiumpro\" (=32-bit only), used by OpenJDK\n+      | CPU_FLUSH \/\/ =\"clflush\" in cpuinfo, not used by gcc, required by OpenJDK\n+      \/\/ GLIBC_MOVBE is disabled in 'gcc -Q --help=target' and some CPUs do not support it: https:\/\/stackoverflow.com\/a\/5246553\/2995591\n+      \/\/ GLIBC_LAHFSAHF is disabled in 'gcc -Q --help=target' and \"Early Intel Pentium 4 CPUs with Intel 64 support ... lacked the LAHF and SAHF instructions\"\n+#endif\n+    ;\n+  }\n+  char *endptr;\n+  errno = 0;\n+  uint64_t retval;\n+  unsigned long long ull = strtoull(CPUFeatures, &endptr, 0);\n+  retval = ull;\n+  if (!errno && *endptr == ',' && retval == ull) {\n+    ull = strtoull(endptr + 1, &endptr, 0);\n+    glibc_features = ull;\n+    if (!errno && !*endptr && glibc_features == ull) {\n+      return retval;\n+    }\n+  }\n+  vm_exit_during_initialization(err_msg(\"VM option 'CPUFeatures=%s' must be of the form: 0xnum,0xnum\", CPUFeatures));\n+  return -1;\n+}\n+\n+bool VM_Version::_ignore_glibc_not_using = false;\n+bool VM_Version::_crac_restore_missing_features;\n+#ifdef LINUX\n+const char VM_Version::glibc_prefix[] = \":glibc.cpu.hwcaps=\";\n+const size_t VM_Version::glibc_prefix_len = strlen(glibc_prefix);\n+\n+bool VM_Version::glibc_env_set(char *disable_str) {\n+#define TUNABLES_NAME \"GLIBC_TUNABLES\"\n+  char *env_val = disable_str;\n+  const char *env = getenv(TUNABLES_NAME);\n+  if (env && strcmp(env, env_val) == 0) {\n+    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Environment variable already set, glibc CPU_FEATURE_ACTIVE is unavailable - re-exec suppressed: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      return true;\n+    }\n+  }\n+  char env_buf[strlen(disable_str) + (!env ? 0 : strlen(env) + 100)];\n+  if (env) {\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+    }\n+    const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n+    if (!hwcaps) {\n+      strcpy(env_buf, env);\n+      strcat(env_buf, disable_str);\n+    } else {\n+      const char *colon = strchr(hwcaps, ':');\n+      if (!colon) {\n+        strcpy(env_buf, env);\n+        strcat(env_buf, disable_str + glibc_prefix_len);\n+      } else {\n+        int err = jio_snprintf(env_buf, sizeof(env_buf), \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n+        assert(err >= 0 && (unsigned)err < sizeof(env_buf), \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+      }\n+    }\n+    env_val = env_buf;\n+  }\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+  }\n+  int err = setenv(TUNABLES_NAME, env_val, 1);\n+  if (err)\n+    vm_exit_during_initialization(err_msg(\"setenv \" TUNABLES_NAME \" error: %m\"));\n+\n+#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n+  if (getenv(REEXEC_NAME))\n+    vm_exit_during_initialization(err_msg(\"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str));\n+  if (setenv(REEXEC_NAME, \"1\", 1))\n+    vm_exit_during_initialization(err_msg(\"setenv \" REEXEC_NAME \" error: %m\"));\n+#undef REEXEC_NAME\n+#undef TUNABLES_NAME\n+  return false;\n+}\n+\n+void VM_Version::glibc_reexec() {\n+  char *buf = NULL;\n+  size_t buf_allocated = 0;\n+  size_t buf_used = 0;\n+#define CMDLINE \"\/proc\/self\/cmdline\"\n+  int fd = open(CMDLINE, O_RDONLY);\n+  if (fd == -1)\n+    vm_exit_during_initialization(err_msg(\"Cannot open \" CMDLINE \": %m\"));\n+  ssize_t got;\n+  do {\n+    if (buf_used == buf_allocated) {\n+      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n+      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n+      if (buf == NULL)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu bytes\", buf_allocated));\n+    }\n+    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n+    if (got == -1)\n+      vm_exit_during_initialization(err_msg(\"Cannot read \" CMDLINE \": %m\"));\n+    buf_used += got;\n+  } while (got);\n+  if (close(fd))\n+    vm_exit_during_initialization(err_msg(\"Cannot close \" CMDLINE \": %m\"));\n+  char **argv = NULL;\n+  size_t argv_allocated = 0;\n+  size_t argv_used = 0;\n+  char *s = buf;\n+  while (s <= buf + buf_used) {\n+    if (argv_used == argv_allocated) {\n+      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n+      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n+      if (argv == NULL)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu pointers\", argv_allocated));\n+    }\n+    if (s == buf + buf_used) {\n+      break;\n+    }\n+    argv[argv_used++] = s;\n+    s += strnlen(s, buf + buf_used - s);\n+    if (s == buf + buf_used)\n+      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n+    ++s;\n+  }\n+  argv[argv_used] = NULL;\n+#undef CMDLINE\n+\n+#define EXEC \"\/proc\/self\/exe\"\n+  execv(EXEC, argv);\n+  vm_exit_during_initialization(err_msg(\"Cannot re-execute \" EXEC \": %m\"));\n+#undef EXEC\n+}\n+\n+void VM_Version::glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC) {\n+#ifndef ASSERT\n+  if (!excessive_CPU && !excessive_GLIBC)\n+    return;\n+#endif\n+\n+  \/\/ glibc: sysdeps\/x86\/get-isa-level.h:\n+  \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMOV)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, CX8)\n+  \/\/ glibc:     && CPU_FEATURE_CPU_P (cpu_features, FPU)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FXSR)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MMX)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE2))\n+  \/\/ glibc:     isa_level = GNU_PROPERTY_X86_ISA_1_BASELINE;\n+  if ((_features & CPU_CMOV) &&\n+      (_features & CPU_CX8) &&\n+      \/\/ FPU is always present on i686+: (_features & CPU_FPU) &&\n+      (_features & CPU_SSE2)) {\n+    \/\/ These cannot be disabled by GLIBC_TUNABLES.\n+    if (excessive_CPU & (CPU_FXSR | CPU_MMX | CPU_SSE)) {\n+      assert(!(excessive_CPU & CPU_SSE2), \"CPU_SSE2 in both _features and excessive_CPU cannot happen\");\n+      \/\/ FIXME: The choice should be based on glibc impact, not the feature age.\n+      \/\/ CX8 is i586+, CMOV is i686+ 1995+, SSE2 is 2000+\n+      excessive_CPU |= CPU_SSE2;\n+    }\n+    if ((_features & CPU_FXSR) &&\n+        (_features & CPU_MMX) &&\n+        (_features & CPU_SSE)) {\n+      \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMPXCHG16B)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LAHF64_SAHF64)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, POPCNT)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_1)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_2))\n+      \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V2;\n+      if ((_features & CPU_POPCNT) &&\n+          (_features & CPU_SSSE3) &&\n+          (_features & CPU_SSE4_1) &&\n+          (_features & CPU_SSE4_2)) {\n+        if ((excessive_CPU & CPU_SSE3) ||\n+            (excessive_GLIBC & (GLIBC_CMPXCHG16 | GLIBC_LAHFSAHF))) {\n+          assert(!(excessive_CPU & CPU_SSE4_2), \"CPU_SSE4_2 in both _features and excessive_CPU cannot happen\");\n+          \/\/ POPCNT is 2007+, SSSE3 is 2006+, SSE4_1 is 2007+, SSE4_2 is 2008+.\n+          excessive_CPU |= CPU_SSE4_2;\n+        }\n+        if ((_features & CPU_SSE3) &&\n+            (_glibc_features & GLIBC_CMPXCHG16) &&\n+            (_glibc_features & GLIBC_LAHFSAHF)) {\n+          \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI1)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, F16C)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FMA)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LZCNT)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MOVBE))\n+          \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V3;\n+          if ((_features & CPU_AVX) &&\n+              (_features & CPU_AVX2) &&\n+              (_features & CPU_BMI1) &&\n+              (_features & CPU_BMI2) &&\n+              (_features & CPU_FMA) &&\n+              (_features & CPU_LZCNT) &&\n+              (_glibc_features & GLIBC_MOVBE)) {\n+            if (excessive_GLIBC & GLIBC_F16C) {\n+              assert(!(excessive_GLIBC & GLIBC_MOVBE), \"GLIBC_MOVBE in both _glibc_features and excessive_GLIBC cannot happen\");\n+              \/\/ FMA is 2012+, AVX2+BMI1+BMI2+LZCNT are 2013+, MOVBE is 2015+\n+              excessive_GLIBC |= GLIBC_MOVBE;\n+            }\n+            if (_glibc_features & GLIBC_F16C) {\n+              \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX512F)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512BW)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512CD)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512DQ)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512VL))\n+              \/\/ glibc:   isa_level |= GNU_PROPERTY_X86_ISA_1_V4;\n+              \/\/ All these flags are supported by GLIBC_DISABLE below.\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  uint64_t disable_CPU   = 0;\n+  uint64_t disable_GLIBC = 0;\n+#define PASTE_TOKENS3(x, y, z) PASTE_TOKENS(x, PASTE_TOKENS(y, z))\n+#ifdef ASSERT\n+  uint64_t excessive_handled_CPU   = 0;\n+  uint64_t excessive_handled_GLIBC = 0;\n+  uint64_t disable_handled_CPU   = 0;\n+  uint64_t disable_handled_GLIBC = 0;\n+#endif\n+#define EXCESSIVE_HANDLED(kind, hotspot) do {                                                                                         \\\n+    assert(!(PASTE_TOKENS(excessive_handled_, kind) & PASTE_TOKENS3(kind, _, hotspot)), \"already used \" STR(kind) \"_\" STR(hotspot) ); \\\n+    DEBUG_ONLY(PASTE_TOKENS(excessive_handled_, kind) |= PASTE_TOKENS3(kind, _, hotspot));                                            \\\n+  } while (0)\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# define FEATURE_ACTIVE(glibc) CPU_FEATURE_ACTIVE(glibc)\n+#else\n+# define FEATURE_ACTIVE(glibc) true\n+#endif\n+#define EXCESSIVE3(kind, hotspot, glibc) do {                                                        \\\n+    EXCESSIVE_HANDLED(kind, hotspot);                                                                \\\n+    if (PASTE_TOKENS(excessive_, kind) & PASTE_TOKENS3(kind, _, hotspot) && FEATURE_ACTIVE(glibc)) { \\\n+      PASTE_TOKENS(disable_, kind) |= PASTE_TOKENS3(kind, _, hotspot);                               \\\n+    }                                                                                                \\\n+  } while (0)\n+#define EXCESSIVE(kind, hotspotglibc) EXCESSIVE3(kind, hotspotglibc, hotspotglibc)\n+  EXCESSIVE(CPU  , AVX     );\n+  EXCESSIVE(CPU  , CX8     );\n+  EXCESSIVE(CPU  , FMA     );\n+  EXCESSIVE(CPU  , RTM     );\n+  EXCESSIVE(CPU  , AVX2    );\n+  EXCESSIVE(CPU  , BMI1    );\n+  EXCESSIVE(CPU  , BMI2    );\n+  EXCESSIVE(CPU  , CMOV    );\n+  EXCESSIVE(CPU  , ERMS    );\n+  EXCESSIVE(CPU  , SSE2    );\n+  EXCESSIVE(CPU  , LZCNT   );\n+  EXCESSIVE(CPU  , SSSE3   );\n+  EXCESSIVE(CPU  , POPCNT  );\n+  EXCESSIVE(CPU  , SSE4_1  );\n+  EXCESSIVE(CPU  , SSE4_2  );\n+  EXCESSIVE(CPU  , AVX512F );\n+  EXCESSIVE(CPU  , AVX512CD);\n+  EXCESSIVE(CPU  , AVX512BW);\n+  EXCESSIVE(CPU  , AVX512DQ);\n+  EXCESSIVE(CPU  , AVX512ER);\n+  EXCESSIVE(CPU  , AVX512PF);\n+  EXCESSIVE(CPU  , AVX512VL);\n+  EXCESSIVE3(CPU , CET_IBT , IBT  );\n+  EXCESSIVE3(CPU , CET_SS  , SHSTK);\n+  EXCESSIVE(GLIBC, FMA4    );\n+  EXCESSIVE(GLIBC, MOVBE   );\n+  EXCESSIVE(GLIBC, XSAVE   );\n+  EXCESSIVE(GLIBC, OSXSAVE );\n+  EXCESSIVE(GLIBC, HTT     );\n+#undef EXCESSIVE\n+#undef EXCESSIVE3\n+\n+  char disable_str[64 * (10 + 3) + 1];\n+  strcpy(disable_str, glibc_prefix);\n+  char *disable_end = disable_str + glibc_prefix_len;\n+#define GLIBC_DISABLE2(kind, hotspot, glibc) do {                                                                                   \\\n+    assert(!(PASTE_TOKENS(disable_handled_, kind) & PASTE_TOKENS3(kind, _, hotspot)), \"already used \" STR(kind) \"_\" STR(hotspot) ); \\\n+    DEBUG_ONLY(PASTE_TOKENS(disable_handled_, kind) |= PASTE_TOKENS3(kind, _, hotspot));                                            \\\n+    if (PASTE_TOKENS(disable_, kind) & PASTE_TOKENS3(kind, _, hotspot)) {                                                           \\\n+      const char str[] = \",-\" STR(glibc);                                                                                           \\\n+      size_t remains = disable_str + sizeof(disable_str) - disable_end;                                                             \\\n+      strncpy(disable_end, str, remains);                                                                                           \\\n+      size_t len = strnlen(disable_end, remains);                                                                                   \\\n+      remains -= len;                                                                                                               \\\n+      assert(remains > 0, \"internal error: disable_str overflow\");                                                                  \\\n+      disable_end += len;                                                                                                           \\\n+    }                                                                                                                               \\\n+  } while (0);\n+#define GLIBC_DISABLE(kind, hotspot_glibc) GLIBC_DISABLE2(kind, hotspot_glibc, hotspot_glibc)\n+  GLIBC_DISABLE(CPU  , AVX)\n+  GLIBC_DISABLE(CPU  , CX8)\n+  GLIBC_DISABLE(CPU  , FMA)\n+  GLIBC_DISABLE(CPU  , RTM)\n+  GLIBC_DISABLE(CPU  , AVX2)\n+  GLIBC_DISABLE(CPU  , BMI1)\n+  GLIBC_DISABLE(CPU  , BMI2)\n+  GLIBC_DISABLE(CPU  , CMOV)\n+  GLIBC_DISABLE(CPU  , ERMS)\n+  GLIBC_DISABLE(CPU  , SSE2)\n+  GLIBC_DISABLE(CPU  , LZCNT)\n+  GLIBC_DISABLE(CPU  , SSSE3)\n+  GLIBC_DISABLE(CPU  , POPCNT)\n+  GLIBC_DISABLE(CPU  , SSE4_1)\n+  GLIBC_DISABLE(CPU  , SSE4_2)\n+  GLIBC_DISABLE(CPU  , AVX512F)\n+  GLIBC_DISABLE(CPU  , AVX512CD)\n+  GLIBC_DISABLE(CPU  , AVX512BW)\n+  GLIBC_DISABLE(CPU  , AVX512DQ)\n+  GLIBC_DISABLE(CPU  , AVX512ER)\n+  GLIBC_DISABLE(CPU  , AVX512PF)\n+  GLIBC_DISABLE(CPU  , AVX512VL)\n+  GLIBC_DISABLE2(CPU , CET_IBT, IBT)\n+  GLIBC_DISABLE2(CPU , CET_SS , SHSTK)\n+  GLIBC_DISABLE(GLIBC, FMA4)\n+  GLIBC_DISABLE(GLIBC, MOVBE)\n+  GLIBC_DISABLE(GLIBC, XSAVE)\n+  GLIBC_DISABLE(GLIBC, OSXSAVE)\n+  GLIBC_DISABLE(GLIBC, HTT)\n+#undef GLIBC_DISABLE\n+#undef GLIBC_DISABLE2\n+  *disable_end = 0;\n+\n+#ifdef ASSERT\n+#define CHECK_KIND(kind) do {                                                                                                            \\\n+    if (PASTE_TOKENS(disable_handled_, kind) != PASTE_TOKENS(excessive_handled_, kind))                                                  \\\n+      vm_exit_during_initialization(err_msg(\"internal error: Unsupported disabling of \" STR(kind) \"_* 0x%\" PRIx64 \" != used 0x%\" PRIx64, \\\n+                                            PASTE_TOKENS(disable_handled_, kind), PASTE_TOKENS(excessive_handled_, kind)));              \\\n+  } while (0)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+\n+  \/\/ These cannot be disabled by GLIBC_TUNABLES interface.\n+#define GLIBC_UNSUPPORTED(kind, hotspot) EXCESSIVE_HANDLED(kind, hotspot)\n+  GLIBC_UNSUPPORTED(CPU  , 3DNOW_PREFETCH   );\n+  GLIBC_UNSUPPORTED(CPU  , SSE4A            );\n+  GLIBC_UNSUPPORTED(CPU  , TSC              );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV_BIT       );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV           );\n+  GLIBC_UNSUPPORTED(CPU  , AES              );\n+  GLIBC_UNSUPPORTED(CPU  , CLMUL            );\n+  GLIBC_UNSUPPORTED(CPU  , ADX              );\n+  GLIBC_UNSUPPORTED(CPU  , SHA              );\n+  GLIBC_UNSUPPORTED(CPU  , VZEROUPPER       );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPOPCNTDQ );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPCLMULQDQ);\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VAES      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VNNI      );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSH            );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSHOPT         );\n+  GLIBC_UNSUPPORTED(CPU  , CLWB             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI2     );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI      );\n+  GLIBC_UNSUPPORTED(CPU  , HV               );\n+  GLIBC_UNSUPPORTED(CPU  , SSE3             );\n+  GLIBC_UNSUPPORTED(CPU  , SERIALIZE        );\n+  GLIBC_UNSUPPORTED(CPU  , RDTSCP           );\n+  GLIBC_UNSUPPORTED(CPU  , RDPID            );\n+  GLIBC_UNSUPPORTED(CPU  , FSRM             );\n+  GLIBC_UNSUPPORTED(CPU  , GFNI             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_BITALG    );\n+  GLIBC_UNSUPPORTED(CPU  , F16C             );\n+  GLIBC_UNSUPPORTED(CPU  , PKU              );\n+  GLIBC_UNSUPPORTED(CPU  , OSPKE            );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_IFMA      );\n+  \/\/ These are handled as an exception above.\n+  GLIBC_UNSUPPORTED(CPU  , FXSR             );\n+  GLIBC_UNSUPPORTED(CPU  , MMX              );\n+  GLIBC_UNSUPPORTED(CPU  , SSE              );\n+  GLIBC_UNSUPPORTED(CPU  , HT               );\n+  GLIBC_UNSUPPORTED(GLIBC, CMPXCHG16        );\n+  GLIBC_UNSUPPORTED(GLIBC, LAHFSAHF         );\n+  GLIBC_UNSUPPORTED(GLIBC, F16C             );\n+#undef GLIBC_UNSUPPORTED\n+#define CHECK_KIND(kind) do {                                                                                                                 \\\n+    if (PASTE_TOKENS(excessive_handled_, kind) != PASTE_TOKENS(MAX_, kind) - 1)                                                               \\\n+      vm_exit_during_initialization(err_msg(\"internal error: Unsupported disabling of some \" STR(kind) \"_* 0x%\" PRIx64 \" != full 0x%\" PRIx64, \\\n+                                            PASTE_TOKENS(excessive_handled_, kind), PASTE_TOKENS(MAX_, kind) - 1));                           \\\n+  } while (0)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+#endif \/\/ ASSERT\n+\n+  if (disable_end == disable_str + glibc_prefix_len)\n+    return;\n+  if (glibc_env_set(disable_str))\n+    return;\n+  glibc_reexec();\n+}\n+#endif \/\/LINUX\n+\n+void VM_Version::nonlibc_tty_print_uint64(uint64_t num) {\n+  static const char prefix[] = \"0x\";\n+  tty->write(prefix, sizeof(prefix) - 1);\n+  bool first = true;\n+  for (int pos = 64 - 4; pos >= 0; pos -= 4) {\n+    unsigned nibble = (num >> pos) & 0xf;\n+    if (first && nibble == 0 && pos)\n+      continue;\n+    first = false;\n+    char c = nibble >= 0xa ? 'a' + nibble - 0xa : '0' + nibble;\n+    tty->write(&c, sizeof(c));\n+  }\n+}\n+\n+void VM_Version::nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2) {\n+  nonlibc_tty_print_uint64(num1);\n+  static const char comma = ',';\n+  tty->print_raw(&comma, sizeof(comma));\n+  nonlibc_tty_print_uint64(num2);\n+}\n+\n+void VM_Version::print_using_features_cr() {\n+  if (_ignore_glibc_not_using) {\n+    tty->print_cr(\"CPU features are being kept intact as requested by -XX:CPUFeatures=ignore\");\n+  } else {\n+    tty->print_cr(\"CPU features being used are: -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, _features, _glibc_features);\n+  }\n+}\n@@ -801,0 +1261,1 @@\n+void VM_Version::get_processor_features_hardware() {\n@@ -805,0 +1266,1 @@\n+  _glibc_features = 0;\n@@ -821,0 +1283,1 @@\n+    LINUX_ONLY(_glibc_features = _cpuid_info.glibc_flags();)\n@@ -833,0 +1296,9 @@\n+  if (ShowCPUFeatures) {\n+    static const char prefix[] = \"This machine's CPU features are: -XX:CPUFeatures=\";\n+    tty->print_raw(prefix, sizeof(prefix) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    tty->cr();\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hotspot() {\n@@ -836,0 +1308,2 @@\n+    if (!FLAG_IS_DEFAULT(CPUFeatures))\n+      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, CPU_SSE2, (uint64_t)0));\n@@ -1026,1 +1500,1 @@\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  insert_features_names(buf + res, sizeof(buf) - res);\n@@ -2121,0 +2595,72 @@\n+\/\/ Print the feature names as \" = feat1, ..., featN\\n\";\n+void VM_Version::missing_features(uint64_t features_missing, uint64_t glibc_features_missing) {\n+  static const char part1[] = \"; missing features of this CPU are \";\n+  tty->print_raw(part1, sizeof(part1) - 1);\n+  nonlibc_tty_print_uint64_comma_uint64(features_missing, glibc_features_missing);\n+  static const char part2[] = \" =\";\n+  tty->print_raw(part2, sizeof(part2) - 1);\n+  char buf[512] = \"\";\n+  \/\/ insert_features_names() does crash for undefined too high-numbered features.\n+  insert_features_names(buf, sizeof(buf)          ,       features_missing & (  MAX_CPU - 1));\n+  char *s = buf;\n+  while (*s)\n+    ++s;\n+  insert_features_names(s  , buf + sizeof(buf) - s, glibc_features_missing & (MAX_GLIBC - 1));\n+  while (*s)\n+    ++s;\n+  \/* +1 to skip the first ','. *\/\n+  tty->print_raw(buf + 1, s - (buf + 1));\n+  tty->cr();\n+  static const char line2[] = \"If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures .\";\n+  tty->print_raw(line2, sizeof(line2) - 1);\n+  tty->cr();\n+}\n+\n+void VM_Version::crac_restore() {\n+  assert(CRaCCheckpointTo != NULL, \"\");\n+\n+  if (ShowCPUFeatures) {\n+    static const char prefix[] = \"This snapshot's stored CPU features are: -XX:CPUFeatures=\";\n+    tty->print_raw(prefix, sizeof(prefix) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    tty->cr();\n+  }\n+\n+  VM_Version::CpuidInfo cpuid_info = { 0, };\n+  get_cpu_info_stub(&cpuid_info);\n+  cpuid_info.assert_is_initialized();\n+\n+  uint64_t       new_cpu_features = 0;\n+  uint64_t new_cpu_glibc_features = 0;\n+  if (cpuid_info.extended_cpu_family() > 4) { \/\/ it supports CPUID\n+    new_cpu_features = cpuid_info.feature_flags();\n+    LINUX_ONLY(new_cpu_glibc_features = cpuid_info.glibc_flags();)\n+  }\n+\n+  uint64_t       features_missing =       _features & ~      new_cpu_features;\n+  uint64_t glibc_features_missing = _glibc_features & ~new_cpu_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  _crac_restore_missing_features = features_missing || glibc_features_missing;\n+  if (_crac_restore_missing_features) {\n+    static const char part1[] = \"You have to specify -XX:CPUFeatures=\";\n+    tty->print_raw(part1, sizeof(part1) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(new_cpu_features & _features, new_cpu_glibc_features & _glibc_features);\n+    static const char part2[] = \" together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features \";\n+    tty->print_raw(part2, sizeof(part2) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    missing_features(features_missing, glibc_features_missing);\n+  }\n+\n+  if (ShowCPUFeatures)\n+    print_using_features_cr();\n+}\n+\n+void VM_Version::crac_restore_finalize() {\n+  if (_crac_restore_missing_features && !IgnoreCPUFeatures) {\n+    vm_exit_during_initialization();\n+  }\n+}\n+\n@@ -2163,1 +2709,47 @@\n-  get_processor_features();\n+  assert(      _features == 0,       \"_features should be zero at startup\");\n+  assert(_glibc_features == 0, \"_glibc_features should be zero at startup\");\n+  get_processor_features_hardware();\n+\n+  assert(!CPUFeatures == FLAG_IS_DEFAULT(CPUFeatures), \"CPUFeatures parsing\");\n+  uint64_t GLIBCFeatures_x64;\n+  uint64_t   CPUFeatures_x64 = CPUFeatures_parse(GLIBCFeatures_x64);\n+  uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+  uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  if (features_missing || glibc_features_missing) {\n+    static const char part1[] = \"Specified -XX:CPUFeatures=\";\n+    tty->print_raw(part1, sizeof(part1) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(CPUFeatures_x64, GLIBCFeatures_x64);\n+    static const char part2[] = \"; this machine's CPU features are \";\n+    tty->print_raw(part2, sizeof(part2) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    missing_features(features_missing, glibc_features_missing);\n+    vm_exit_during_initialization();\n+  }\n+\n+  uint64_t       features_saved =       _features;\n+  uint64_t glibc_features_saved = _glibc_features;\n+\n+        _features =   CPUFeatures_x64;\n+  _glibc_features = GLIBCFeatures_x64;\n+\n+  if (ShowCPUFeatures)\n+    print_using_features_cr();\n+\n+#ifdef LINUX\n+  if (!_ignore_glibc_not_using) {\n+    uint64_t       features_expected =   MAX_CPU - 1;\n+    uint64_t glibc_features_expected = MAX_GLIBC - 1;\n+    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+            features_expected =       features_saved;\n+      glibc_features_expected = glibc_features_saved;\n+    }\n+    glibc_not_using(      features_expected & ~      _features,\n+                    glibc_features_expected & ~_glibc_features);\n+  }\n+#endif\n+\n+  get_processor_features_hotspot();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":598,"deletions":6,"binary":false,"changes":604,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -85,1 +86,2 @@\n-                        : 2,\n+                        : 1,\n+               movbe    : 1,\n@@ -89,1 +91,1 @@\n-                        : 1,\n+               xsave    : 1,\n@@ -156,1 +158,3 @@\n-                            : 23;\n+                            : 7,\n+               fma4         : 1,\n+                            : 15;\n@@ -408,0 +412,1 @@\n+    MAX_CPU = CPU_AVX512_IFMA << 1\n@@ -410,0 +415,21 @@\n+  \/* Tracking of a CPU feature for glibc *\/ \\\n+  enum Glibc_Feature_Flag : uint64_t {\n+#define GLIBC_FEATURE_FLAGS(decl) \\\n+    decl(FMA4,              \"fma4\",               0) \\\n+    decl(MOVBE,             \"movbe\",              1) \\\n+    decl(OSXSAVE,           \"osxsave\",            2) \\\n+    decl(XSAVE,             \"xsave\",              3) \\\n+    decl(CMPXCHG16,         \"cmpxchg16\",          4) \/* Also known in cpuinfo as cx16 and in glibc as cmpxchg16b *\/ \\\n+    decl(LAHFSAHF,          \"lahfsahf\",           5) \/* Also known in cpuinfo as lahf_lm and in glibc as lahf64_sahf64 *\/ \\\n+    decl(F16C,              \"f16c\",               6) \\\n+    decl(HTT,               \"htt\",                7) \/* hotspot calls it 'ht' but it is affected by threads_per_core() *\/\n+\n+#define DECLARE_GLIBC_FEATURE_FLAG(id, name, bit) GLIBC_##id = (1ULL << bit),\n+    GLIBC_FEATURE_FLAGS(DECLARE_GLIBC_FEATURE_FLAG)\n+#undef DECLARE_GLIBC_FEATURE_FLAG\n+    MAX_GLIBC = GLIBC_HTT << 1\n+  };\n+\n+  \/\/ glibc feature flags.\n+  static uint64_t _glibc_features;\n+\n@@ -411,0 +437,1 @@\n+  static const char* _glibc_features_names[];\n@@ -542,0 +569,23 @@\n+#ifdef LINUX\n+    uint64_t glibc_flags() const {\n+      uint64_t result = 0;\n+      if (std_cpuid1_ecx.bits.movbe != 0)\n+        result |= GLIBC_MOVBE;\n+      if (std_cpuid1_ecx.bits.osxsave != 0)\n+        result |= GLIBC_OSXSAVE;\n+      if (std_cpuid1_ecx.bits.xsave != 0)\n+        result |= GLIBC_XSAVE;\n+      if (std_cpuid1_ecx.bits.cmpxchg16 != 0)\n+        result |= GLIBC_CMPXCHG16;\n+      if (std_cpuid1_ecx.bits.f16c != 0)\n+        result |= GLIBC_F16C;\n+      if (ext_cpuid1_ecx.bits.fma4 != 0)\n+        result |= GLIBC_FMA4;\n+      if (ext_cpuid1_ecx.bits.LahfSahf != 0)\n+        result |= GLIBC_LAHFSAHF;\n+      if (std_cpuid1_edx.bits.ht != 0)\n+        result |= GLIBC_HTT;\n+      return result;\n+    }\n+#endif \/\/LINUX\n+\n@@ -578,0 +628,20 @@\n+  static void get_processor_features_hardware();\n+  static void get_processor_features_hotspot();\n+\n+  static uint64_t CPUFeatures_parse(uint64_t &glibc_features);\n+#ifdef LINUX\n+  static void glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC);\n+  static bool glibc_env_set(char *disable_str);\n+  \/*[[noreturn]]*\/ static void glibc_reexec();\n+  \/\/ C++17: Make glibc_prefix and glibc_prefix_len constexpr.\n+  static const char glibc_prefix[];\n+  static const size_t glibc_prefix_len;\n+#endif \/\/LINUX\n+  \/\/ C++17: Make _ignore_glibc_not_using inline.\n+  static bool _ignore_glibc_not_using;\n+  static bool _crac_restore_missing_features;\n+  static void nonlibc_tty_print_uint64(uint64_t num);\n+  static void nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2);\n+  static void print_using_features_cr();\n+  \/*[[noreturn]]*\/ static void missing_features(uint64_t features_missing, uint64_t glibc_features_missing);\n+\n@@ -613,0 +683,7 @@\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _features_names, features);\n+  }\n+  static void insert_glibc_features_names(char* buf, size_t buflen, uint64_t glibc_features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _glibc_features_names, glibc_features);\n+  }\n+\n@@ -615,0 +692,2 @@\n+  static void crac_restore();\n+  static void crac_restore_finalize();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":82,"deletions":3,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+define_pd_global(ccstrlist, CRAllowedOpenFilePrefixes, nullptr);\n","filename":"src\/hotspot\/os\/aix\/globals_aix.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+define_pd_global(ccstrlist, CRAllowedOpenFilePrefixes, nullptr);\n","filename":"src\/hotspot\/os\/bsd\/globals_bsd.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+  product(bool, CRaCCPUCountInit, false, \"Reinitialize number of CPUs \" \\\n+      \"during -XX:CRaCRestoreFrom\")                                     \\\n+                                                                        \\\n@@ -109,0 +112,5 @@\n+\/\/ On some systems using SSSD files in this directory are left open\n+\/\/ after calling getpwuid_r, getpwname_r, getgrgid_r, getgrname_r\n+\/\/ or other functions in this family.\n+define_pd_global(ccstrlist, CRAllowedOpenFilePrefixes, \"\/var\/lib\/sss\/mc\/\");\n+\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2017, 2022, Azul Systems, Inc. All rights reserved.\n@@ -27,0 +28,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -67,0 +69,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -88,0 +91,1 @@\n+# include <arpa\/inet.h>\n@@ -92,1 +96,0 @@\n-# include <sys\/stat.h>\n@@ -94,0 +97,1 @@\n+# include <sys\/sysmacros.h>\n@@ -112,1 +116,0 @@\n-# include <fcntl.h>\n@@ -121,0 +124,1 @@\n+# include <libgen.h>\n@@ -499,1 +503,1 @@\n-void os::Linux::initialize_system_info() {\n+void os::Linux::initialize_processor_count() {\n@@ -501,0 +505,5 @@\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n+void os::Linux::initialize_system_info() {\n+  initialize_processor_count();\n@@ -513,1 +522,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -63,0 +64,1 @@\n+  static void initialize_processor_count();\n@@ -279,0 +281,7 @@\n+  static void initialize_cpu_count() {\n+    initialize_processor_count();\n+    if (cpu_to_node() != NULL) {\n+      rebuild_cpu_to_node_map();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"attachListener_posix.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"posixAttachOperation.hpp\"\n@@ -65,67 +68,0 @@\n-\/\/ forward reference\n-class PosixAttachOperation;\n-\n-class PosixAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n-  \/\/ reads a request from the given connected socket\n-  static PosixAttachOperation* read_request(int s);\n-\n- public:\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n-  static void set_path(char* path) {\n-    if (path == nullptr) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, size_t len);\n-\n-  static PosixAttachOperation* dequeue();\n-};\n-\n-class PosixAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  int _socket;\n-\n- public:\n-  void complete(jint res, bufferedStream* st);\n-\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n-\n-  PosixAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n-  }\n-};\n-\n@@ -137,0 +73,1 @@\n+PosixAttachOperation* PosixAttachListener::_current_op = NULL;\n@@ -408,0 +345,1 @@\n+      _current_op = op;\n@@ -428,0 +366,12 @@\n+\/\/ An operation completion is splitted into two parts.\n+\/\/ For proper handling the jcmd connection at CRaC checkpoint action.\n+\/\/ An effectively_complete_raw is called in checkpoint processing, before criu engine calls, for properly closing the socket.\n+\/\/ The complete() gets called after restore for proper deletion the leftover object.\n+\n+void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n+  PosixAttachOperation::effectively_complete_raw(result, st);\n+  \/\/ reset the current op as late as possible, this happens on attach listener thread.\n+  PosixAttachListener::reset_current_op();\n+  delete this;\n+}\n+\n@@ -436,3 +386,5 @@\n-void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n+void PosixAttachOperation::effectively_complete_raw(jint result, bufferedStream* st) {\n+  if (_effectively_completed) {\n+    assert(st->size() == 0, \"no lost output\");\n+    return;\n+  }\n@@ -441,0 +393,11 @@\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    ThreadBlockInVM((JavaThread* )thread);\n+    write_operation_result(result, st);\n+  } else {\n+    write_operation_result(result, st);\n+  }\n+  _effectively_completed = true;\n+}\n+\n+void PosixAttachOperation::write_operation_result(jint result, bufferedStream* st) {\n@@ -448,1 +411,1 @@\n-    ::shutdown(this->socket(), 2);\n+    ::shutdown(this->socket(), SHUT_RDWR);\n@@ -453,0 +416,2 @@\n+  st->reset();\n+}\n@@ -454,1 +419,5 @@\n-  delete this;\n+static void assert_listener_thread() {\n+#ifdef ASSERT\n+  ResourceMark rm; \/\/ For retrieving the thread names\n+  assert(strcmp(\"Attach Listener\", Thread::current()->name()) == 0, \"should gets called from Attach Listener thread\");\n+#endif\n@@ -457,0 +426,9 @@\n+PosixAttachOperation* PosixAttachListener::get_current_op() {\n+  assert_listener_thread();\n+  return PosixAttachListener::_current_op;\n+}\n+\n+void PosixAttachListener::reset_current_op() {\n+  assert_listener_thread();\n+  PosixAttachListener::_current_op = NULL;\n+}\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":50,"deletions":72,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_ATTACHLISTENER_POSIX_HPP\n+#define OS_POSIX_ATTACHLISTENER_POSIX_HPP\n+\n+#include \"posixAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+\n+#if INCLUDE_SERVICES\n+\n+#include <sys\/un.h>\n+\n+#ifndef UNIX_PATH_MAX\n+#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n+#endif\n+\n+class PosixAttachListener: AllStatic {\n+ private:\n+  \/\/ the path to which we bind the UNIX domain socket\n+  static char _path[UNIX_PATH_MAX];\n+  static bool _has_path;\n+\n+  \/\/ the file descriptor for the listening socket\n+  static volatile int _listener;\n+\n+  static bool _atexit_registered;\n+\n+  \/\/ this is for proper reporting JDK.Chekpoint processing to jcmd peer\n+  static PosixAttachOperation* _current_op;\n+\n+  \/\/ reads a request from the given connected socket\n+  static PosixAttachOperation* read_request(int s);\n+\n+ public:\n+  enum {\n+    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n+  };\n+  enum {\n+    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n+  };\n+\n+  static void set_path(char* path) {\n+    if (path == nullptr) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n+  \/\/ initialize the listener, returns 0 if okay\n+  static int init();\n+\n+  static char* path()                   { return _path; }\n+  static bool has_path()                { return _has_path; }\n+  static int listener()                 { return _listener; }\n+\n+  \/\/ write the given buffer to a socket\n+  static int write_fully(int s, char* buf, size_t len);\n+\n+  static PosixAttachOperation* dequeue();\n+  static PosixAttachOperation* get_current_op();\n+  static void reset_current_op();\n+\n+};\n+\n+#endif \/\/ INCLUDE_SERVICES\n+\n+#endif \/\/ OS_POSIX_ATTACHLISTENER_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.hpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -781,0 +782,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -803,0 +808,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1273,0 +1286,4 @@\n+  initialize_time_counters();\n+}\n+\n+void os::Posix::initialize_time_counters(void) {\n@@ -1427,1 +1444,1 @@\n-  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec);\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + crac::monotonic_time_offset();\n@@ -1980,0 +1997,30 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  char** env = os::get_environ();\n+\n+  pid_t pid = fork();\n+  if (pid == -1) {\n+    perror(\"cannot fork for crengine\");\n+    return -1;\n+  }\n+  if (pid == 0) {\n+    execve(path, (char* const*)argv, env);\n+    perror(\"execve\");\n+    exit(1);\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return -1;\n+  }\n+  return WEXITSTATUS(status) == 0 ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return ::execv(path, (char * const *)argv);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  static void initialize_time_counters(void);\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -34,0 +35,1 @@\n+\/\/#include \"os_linux.inline.hpp\"\n@@ -44,0 +46,4 @@\n+#ifdef LINUX\n+#include \"perfMemory_linux.hpp\"\n+#endif \/\/LINUX\n+\n@@ -1342,0 +1348,77 @@\n+\n+#ifdef LINUX\n+bool PerfMemoryLinux::checkpoint() {\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  void *anon = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (anon == MAP_FAILED) {\n+    tty->print_cr(\"Cannot allocate new memory for perfdata: %s\", os::strerror(errno));\n+    return false;\n+  }\n+  \/\/ Note: we might be losing updates that happen between this copy and mremap\n+  \/\/ TODO: consider acquiring PeriodicTask_lock around this\n+  memcpy(anon, PerfMemory::start(), PerfMemory::used());\n+  if (mremap(anon, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap perfdata memory as anonymous: %s\", os::strerror(errno));\n+    if (munmap(anon, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap unused private perfdata memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  remove_file(backing_store_file_name);\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::restore() {\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  int vmid = os::current_process_id();\n+  char* user_name = get_user_name(geteuid());\n+  if (!user_name) {\n+    return false;\n+  }\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  if (!make_user_tmp_dir(dirname)) {\n+    return false;\n+  }\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"Cannot open shared perfdata file: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  if (::ftruncate(fd, PerfMemory::capacity())) {\n+    tty->print_cr(\"Cannot restore (ftruncate) perfdata file size: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  void* shared = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == shared) {\n+    tty->print_cr(\"cannot mmap shared perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+  ::close(fd);\n+\n+  \/\/ Here is another place where we might lose the update\n+  memcpy(shared, PerfMemory::start(), PerfMemory::used());\n+  if (::mremap(shared, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap shared perfdata: %s\", os::strerror(errno));\n+    if (munmap(shared, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap the shared memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  return true;\n+}\n+#endif \/\/LINUX\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_POSIXATTACHOPERATION_HPP\n+#define OS_POSIX_POSIXATTACHOPERATION_HPP\n+\n+#include \"services\/attachListener.hpp\"\n+\n+#if INCLUDE_SERVICES\n+\n+class PosixAttachOperation: public AttachOperation {\n+ private:\n+  \/\/ the connection to the client\n+  int _socket;\n+  bool _effectively_completed;\n+  void write_operation_result(jint result, bufferedStream* st);\n+\n+ public:\n+  void complete(jint res, bufferedStream* st);\n+  void effectively_complete_raw(jint res, bufferedStream* st);\n+  bool is_effectively_completed()                      { return _effectively_completed; }\n+\n+  void set_socket(int s)                                { _socket = s; }\n+  int socket() const                                    { return _socket; }\n+\n+  PosixAttachOperation(char* name) : AttachOperation(name) {\n+    set_socket(-1);\n+    _effectively_completed = false;\n+  }\n+};\n+\n+#endif \/\/ INCLUDE_SERVICES\n+\n+#endif \/\/ OS_POSIX_POSIXATTACHOPERATION_HPP\n","filename":"src\/hotspot\/os\/posix\/posixAttachOperation.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -145,1 +145,1 @@\n-static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n@@ -1541,0 +1541,7 @@\n+\n+  sigemptyset(&blocked_sigs);\n+\/\/ RESTORE_SIGNAL is used only on Linux, other platform don't send this\n+#ifdef LINUX\n+  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+#endif\n+\n@@ -1551,0 +1558,5 @@\n+static sigset_t* blocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &blocked_sigs;\n+}\n+\n@@ -1568,0 +1580,1 @@\n+  pthread_sigmask(SIG_BLOCK, blocked_signals(), nullptr);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+define_pd_global(ccstrlist, CRAllowedOpenFilePrefixes, nullptr);\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1521,0 +1522,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -4838,0 +4866,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5805,0 +5858,9 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  const int status = _spawnv(_P_WAIT, path, argv); \/\/ env is inherited by a child process\n+  return 0 == status ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return _execv(path, argv);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  static void   initialize_performance_counter();\n@@ -111,1 +112,0 @@\n-  static void initialize_performance_counter();\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,0 +397,9 @@\n+  \/\/ VM_Version::crac_restore()->VM_Version::get_processor_features_hardware()\n+  \/\/ executes cpuinfo without a started Java thread.\n+  if (info != nullptr && uc != nullptr && thread == nullptr && sig == SIGSEGV) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n+      stub = VM_Version::cpuinfo_cont_addr();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -223,0 +223,9 @@\n+  \/\/ VM_Version::crac_restore()->VM_Version::get_processor_features_hardware()\n+  \/\/ executes cpuinfo without a started Java thread.\n+  if (info != nullptr && uc != nullptr && thread == nullptr && sig == SIGSEGV) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n+      stub = VM_Version::cpuinfo_cont_addr();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -743,0 +743,4 @@\n+  template(jdk_crac_Core,                          \"jdk\/crac\/Core\")                                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+  template(checkpointRestoreInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"gc\/g1\/g1UncommitRegionTask.hpp\"\n@@ -1021,0 +1022,4 @@\n+  virtual void finish_collection() override {\n+    G1UncommitRegionTask::finish_collection();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -248,0 +248,7 @@\n+  \/\/ Handle do_cleanup_unused here to print correct capacity below.\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    \/\/ HeapRegionManager::shrink_by do not allow remove all regions.\n+    \/\/ Make sure at least one is there.\n+    maximum_desired_capacity = G1HeapRegion::GrainBytes;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -136,0 +136,8 @@\n+\n+void G1UncommitRegionTask::finish_collection() {\n+  \/\/ If _instance is NULL G1 GC is either not in use or its collection has not yet been executed.\n+  if (_instance) {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    g1h->uncommit_regions((uint)-1);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -1193,0 +1194,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1349,0 +1357,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -421,0 +422,6 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), (char*)eden()->end() - (char*)eden()->top());\n+    os::cleanup_memory((char*)from()->top(), (char*)from()->end() - (char*)from()->top());\n+    os::cleanup_memory((char*)to()->top(), (char*)to()->end() - (char*)to()->top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -247,0 +247,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -120,0 +120,2 @@\n+  bool _cleanup_unused;\n+\n@@ -378,0 +380,6 @@\n+  void set_cleanup_unused(bool value) { _cleanup_unused = value; }\n+  bool do_cleanup_unused() const { return _cleanup_unused; }\n+\n+  \/\/ G1UncommitRegionTask may be still pending after collect() has returned.\n+  virtual void finish_collection() {}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1196,0 +1196,15 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+    case JVMFlagOrigin::CRAC_RESTORE: return \"CRaC restore\";\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  : _flush_sem(0), _lock(), _data_available(false),\n+  : _flush_sem(0), _lock(), _block_async(), _data_available(false),\n@@ -178,0 +178,3 @@\n+\n+    _block_async.lock();\n+    _block_async.unlock();\n@@ -226,0 +229,9 @@\n+void AsyncLogWriter::stop() {\n+  _block_async.lock();\n+  flush();\n+}\n+\n+void AsyncLogWriter::resume() {\n+  _block_async.unlock();\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -163,0 +163,2 @@\n+  \/\/ for asynchronous thread run()\n+  PlatformMonitor _block_async;\n@@ -205,0 +207,2 @@\n+  void stop();\n+  void resume();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -720,0 +720,22 @@\n+\n+bool LogConfiguration::is_fd_used(int fd) {\n+  assert(fd != -1, \"fd must be valid\");\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    if (fd == _outputs[i]->fd_get()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void LogConfiguration::close() {\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    _outputs[i]->close();\n+  }\n+}\n+\n+void LogConfiguration::reopen() {\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    _outputs[i]->reopen();\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -469,0 +469,33 @@\n+\n+int LogFileOutput::fd_get() const {\n+  if (_stream == nullptr) {\n+    return -1;\n+  }\n+  return LogFileStreamOutput::fd_get();\n+}\n+\n+void LogFileOutput::close() {\n+  if (_stream == nullptr) {\n+    return;\n+  }\n+  if (fclose(_stream)) {\n+    jio_fprintf(defaultStream::error_stream(), \"Error closing log file '%s' (%s).\\n\",\n+                _file_name, os::strerror(errno));\n+  }\n+  _stream = nullptr;\n+}\n+\n+void LogFileOutput::reopen() {\n+  assert(_stream == nullptr, \"reopening an already opened log file\");\n+\n+  \/\/ Open the active log file using the same stream as before\n+  _stream = os::fopen(_file_name, FileOpenMode);\n+  if (_stream == nullptr) {\n+    jio_fprintf(defaultStream::error_stream(), \"Could not reopen log file '%s' (%s).\\n\",\n+                _file_name, os::strerror(errno));\n+    return;\n+  }\n+\n+  \/\/ _current_size still keeps how much data we wrote for the rotation purposes.\n+  \/\/ The log file may contain more data now.\n+}\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -86,7 +86,10 @@\n-  virtual bool initialize(const char* options, outputStream* errstream);\n-  virtual bool set_option(const char* key, const char* value, outputStream* errstream);\n-  virtual int write(const LogDecorations& decorations, const char* msg);\n-  virtual int write(LogMessageBuffer::Iterator msg_iterator);\n-  virtual int write_blocking(const LogDecorations& decorations, const char* msg);\n-  virtual void force_rotate();\n-  virtual void describe(outputStream* out);\n+  virtual bool initialize(const char* options, outputStream* errstream) override;\n+  virtual bool set_option(const char* key, const char* value, outputStream* errstream) override;\n+  virtual int write(const LogDecorations& decorations, const char* msg) override;\n+  virtual int write(LogMessageBuffer::Iterator msg_iterator) override;\n+  virtual int write_blocking(const LogDecorations& decorations, const char* msg) override;\n+  virtual void force_rotate() override;\n+  virtual void describe(outputStream* out) override;\n+  virtual int fd_get() const override;\n+  virtual void close() override;\n+  virtual void reopen() override;\n@@ -94,1 +97,1 @@\n-  virtual const char* name() const {\n+  virtual const char* name() const override {\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  LOG_TAG(crac) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/crac.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3912,0 +3913,5 @@\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -307,2 +307,1 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n-  uint64_t features = _features;\n+void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features) {\n@@ -313,4 +312,10 @@\n-      int res = jio_snprintf(buf, buflen, \", %s\", features_names[features_names_index]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+      \/\/ Do not use any libc string functions. Our caller VM_Version::fatal_missing_features may have GNU_IFUNC-misconfigured glibc.\n+      if (buflen-- > 0)\n+        *buf++ = ',';\n+      if (buflen-- > 0)\n+        *buf++ = ' ';\n+      for (const char *src = features_names[features_names_index]; *src; ++src)\n+      if (buflen-- > 0)\n+        *buf++ = *src;\n+      assert(buflen > 0, \"not enough temporary space allocated\");\n+      *buf = 0;\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  static void insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features = _features);\n@@ -130,1 +131,0 @@\n-  static void insert_features_names(char* buf, size_t buflen, const char* features_names[]);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -52,0 +53,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1101,0 +1103,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == NULL) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1110,4 +1125,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1115,6 +1127,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == nullptr) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1251,1 +1259,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1253,2 +1263,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1258,1 +1266,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1266,1 +1275,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1268,1 +1277,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1270,0 +1279,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2158,0 +2174,65 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = NULL;\n+      const char* value = NULL;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.command\") == 0) {\n+        char *old_java_command = _java_command;\n+        _java_command = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != NULL) {\n+          os::free(old_java_command);\n+        }\n+      } else {\n+        add_property(tail);\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n+      \/\/ already been handled\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != NULL) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n+          return false;\n+        }\n+        build_jvm_flags(tail);\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2912,0 +2993,7 @@\n+  if (CRaCCheckpointTo && UseZGC) {\n+    \/\/ jdk.crac.impl.CheckpointOpenFileException: FD fd=3 type=regular path=\/memfd:java_heap (deleted)\n+    jio_fprintf(defaultStream::output_stream(),\n+      \"-XX:+UseZGC is currently unsupported for -XX:CRaCCheckpointTo.\\n\");\n+    return JNI_ERR;\n+  }\n+\n@@ -2969,0 +3057,4 @@\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":108,"deletions":16,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -281,0 +281,4 @@\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n+\n@@ -511,0 +515,4 @@\n+  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+#define SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+\n+#include \"jvm.h\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+\n+#ifdef LINUX\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+#endif\n+\n+struct CracFailDep {\n+  int _type;\n+  char* _msg;\n+  CracFailDep(int type, char* msg) :\n+    _type(type),\n+    _msg(msg)\n+  { }\n+  CracFailDep() :\n+    _type(JVM_CR_FAIL),\n+    _msg(NULL)\n+  { }\n+};\n+\n+class CracRestoreParameters : public CHeapObj<mtInternal> {\n+  char* _raw_content;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  struct header {\n+    jlong _restore_time;\n+    jlong _restore_nanos;\n+    int _nflags;\n+    int _nprops;\n+    int _env_memory_size;\n+  };\n+\n+  static bool write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  static int system_props_length(const SystemProperty* props) {\n+    int len = 0;\n+    while (props != NULL) {\n+      ++len;\n+      props = props->next();\n+    }\n+    return len;\n+  }\n+\n+  static int env_vars_size(const char* const * env) {\n+    int len = 0;\n+    for (; *env; ++env) {\n+      len += (int)strlen(*env) + 1;\n+    }\n+    return len;\n+  }\n+\n+ public:\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  CracRestoreParameters() :\n+    _raw_content(NULL),\n+    _properties(new (mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(NULL)\n+  {}\n+\n+  ~CracRestoreParameters() {\n+    if (_raw_content) {\n+      FREE_C_HEAP_ARRAY(char, _raw_content);\n+    }\n+    delete _properties;\n+  }\n+\n+  static bool write_to(int fd,\n+      const char* const* flags, int num_flags,\n+      const SystemProperty* props,\n+      const char *args,\n+      jlong restore_time,\n+      jlong restore_nanos) {\n+    header hdr = {\n+      restore_time,\n+      restore_nanos,\n+      num_flags,\n+      system_props_length(props),\n+      env_vars_size(os::get_environ())\n+    };\n+\n+    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < num_flags; ++i) {\n+      if (!write_check_error(fd, flags[i], (int)strlen(flags[i]) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    const SystemProperty* p = props;\n+    while (p != NULL) {\n+      char prop[4096];\n+      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n+      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n+      if (!write_check_error(fd, prop, len+1)) {\n+        return false;\n+      }\n+      p = p->next();\n+    }\n+\n+    \/\/ Write env vars\n+    for (char** env = os::get_environ(); *env; ++env) {\n+      if (!write_check_error(fd, *env, (int)strlen(*env) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    return write_check_error(fd, args, (int)strlen(args)+1); \/\/ +1 for null char\n+  }\n+\n+  bool read_from(int fd);\n+\n+};\n+\n+class VM_Crac: public VM_Operation {\n+  jarray _fd_arr;\n+  const bool _dry_run;\n+  bool _ok;\n+  GrowableArray<CracFailDep>* _failures;\n+  CracRestoreParameters _restore_parameters;\n+  outputStream* _ostream;\n+#if defined(LINUX) && INCLUDE_SERVICES\n+  PosixAttachOperation* _attach_op;\n+#endif \/\/ LINUX && INCLUDE_SERVICES\n+\n+public:\n+  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n+    _fd_arr(fd_arr),\n+    _dry_run(dry_run),\n+    _ok(false),\n+    _failures(new (mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n+    _restore_parameters(),\n+    _ostream(jcmd_stream ? jcmd_stream : tty)\n+#if defined(LINUX) && INCLUDE_SERVICES\n+    , _attach_op(jcmd_stream ? PosixAttachListener::get_current_op() : NULL)\n+#endif \/\/ LINUX && INCLUDE_SERVICES\n+  { }\n+\n+  ~VM_Crac() {\n+    delete _failures;\n+  }\n+\n+  GrowableArray<CracFailDep>* failures() { return _failures; }\n+  bool ok() { return _ok; }\n+  const char* new_args() { return _restore_parameters.args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n+  virtual bool allow_nested_vm_operations() const  { return true; }\n+  VMOp_Type type() const { return VMOp_VM_Crac; }\n+  void doit();\n+  bool read_shm(int shmid);\n+\n+private:\n+  bool is_claimed_fd(int fd);\n+  bool is_socket_from_jcmd(int sock_fd);\n+  void report_ok_to_jcmd_if_any();\n+  void print_resources(const char* msg, ...);\n+  void trace_cr(const char* msg, ...);\n+  bool check_fds();\n+  bool memory_checkpoint();\n+  void memory_restore();\n+};\n+\n+class CracSHM {\n+  char _path[128];\n+public:\n+  CracSHM(int id) {\n+    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n+    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n+      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    }\n+  }\n+\n+  int open(int mode);\n+  void unlink();\n+};\n+\n+#endif \/\/SHARE_RUNTIME_CRAC_STRUCTS_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac_structs.hpp","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -401,0 +401,2 @@\n+    case JVMFlagOrigin::CRAC_RESTORE:\n+      st->print(\"crac restore\");\n@@ -508,3 +510,4 @@\n-const int DIAGNOSTIC   = JVMFlag::KIND_DIAGNOSTIC;\n-const int MANAGEABLE   = JVMFlag::KIND_MANAGEABLE;\n-const int EXPERIMENTAL = JVMFlag::KIND_EXPERIMENTAL;\n+const int DIAGNOSTIC       = JVMFlag::KIND_DIAGNOSTIC;\n+const int MANAGEABLE       = JVMFlag::KIND_MANAGEABLE;\n+const int EXPERIMENTAL     = JVMFlag::KIND_EXPERIMENTAL;\n+const int RESTORE_SETTABLE = JVMFlag::KIND_RESTORE_SETTABLE;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  CRAC_RESTORE     = 9,\n@@ -51,1 +52,1 @@\n-ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::JIMAGE_RESOURCE)\n+ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::CRAC_RESTORE)\n@@ -73,1 +74,1 @@\n-\n+    KIND_RESTORE_SETTABLE   = 1 << 15,\n@@ -249,0 +250,1 @@\n+  bool is_restore_settable() const { return (_flags & (KIND_RESTORE_SETTABLE | KIND_MANAGEABLE)) != 0; }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n-\/\/ only with product\/product_pd flags.\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, MANAGEABLE or RESTORE_SETTABLE. Currently\n+\/\/ extra_attrs can be used only with product\/product_pd flags.\n@@ -100,0 +100,3 @@\n+\/\/ RESTORE_SETTABLE are flags that can be set during restore from a snapshot.\n+\/\/    All MANAGEABLE flags are implicitly RESTORE_SETTABLE but\n+\/\/    RESTORE_SETTABLE are not MANAGEABLE.\n@@ -173,1 +176,2 @@\n-  product(bool, UnlockDiagnosticVMOptions, trueInDebug, DIAGNOSTIC,         \\\n+  product(bool, UnlockDiagnosticVMOptions, trueInDebug,                     \\\n+          DIAGNOSTIC | RESTORE_SETTABLE,                                    \\\n@@ -176,1 +180,2 @@\n-  product(bool, UnlockExperimentalVMOptions, false, EXPERIMENTAL,           \\\n+  product(bool, UnlockExperimentalVMOptions, false,                         \\\n+          EXPERIMENTAL | RESTORE_SETTABLE,                                  \\\n@@ -1963,0 +1968,57 @@\n+  product(ccstr, CRaCCheckpointTo, NULL, RESTORE_SETTABLE,                  \\\n+        \"Path to checkpoint image directory\")                               \\\n+                                                                            \\\n+  product(ccstr, CRaCRestoreFrom, NULL, RESTORE_SETTABLE,                   \\\n+      \"Path to image for restore, replaces the initializing VM on success\") \\\n+                                                                            \\\n+  product(uint, CRaCMinPid, 128,                                            \\\n+      \"Mininal PID value for checkpoint'ed process\")                        \\\n+      range(1, UINT_MAX)                                                    \\\n+                                                                            \\\n+  product(bool, CRaCResetStartTime, true, DIAGNOSTIC | RESTORE_SETTABLE,    \\\n+      \"Reset JVM's start time and uptime on restore\")                       \\\n+                                                                            \\\n+  product(ccstr, CREngine, \"criuengine\", RESTORE_SETTABLE,                  \\\n+      \"Path or name of a program implementing checkpoint\/restore and \"      \\\n+      \"optional extra parameters as a comma-separated list: \"               \\\n+      \"-XX:CREngine=program,--key,value,--anotherkey results in calling \"   \\\n+      \"'program --key value --anotherkey'. Commas used as part of args \"    \\\n+      \"should be escaped with a backslash character ('\\\\').\")               \\\n+                                                                            \\\n+  product(bool, CRaCIgnoreRestoreIfUnavailable, false, RESTORE_SETTABLE,    \\\n+      \"Ignore -XX:CRaCRestoreFrom and continue initialization if restore \"  \\\n+      \"is unavailable\")                                                     \\\n+                                                                            \\\n+  product(ccstr, CRaCIgnoredFileDescriptors, NULL, RESTORE_SETTABLE,        \\\n+      \"Comma-separated list of file descriptor numbers or paths. \"          \\\n+      \"All file descriptors greater than 2 (stdin, stdout and stderr are \"  \\\n+      \"excluded automatically) not in this list are closed when the VM \"    \\\n+      \"is started.\")                                                        \\\n+                                                                            \\\n+  product_pd(ccstrlist, CRAllowedOpenFilePrefixes, \"List of path prefixes \" \\\n+      \"for files that can be open during checkpoint; CRaC won't error \"     \\\n+      \"upon detecting these and will leave the handling up to C\/R engine. \" \\\n+      \"This option applies only to files opened by native code; for files \" \\\n+      \"opened by Java code use -Djdk.crac.resource-policies=...\")           \\\n+                                                                            \\\n+  product(bool, CRAllowToSkipCheckpoint, false, DIAGNOSTIC,                 \\\n+          \"Allow implementation to not call Checkpoint if helper not found\")\\\n+                                                                            \\\n+  product(bool, CRHeapDumpOnCheckpointException, false, DIAGNOSTIC,         \\\n+      \"Dump heap on CheckpointException thrown because of CRaC \"            \\\n+      \"precondition failed\")                                                \\\n+                                                                            \\\n+  product(bool, CRPrintResourcesOnCheckpoint, false, DIAGNOSTIC,            \\\n+      \"Print resources to decide CheckpointException\")                      \\\n+                                                                            \\\n+  product(bool, CRTraceStartupTime, false, DIAGNOSTIC,                      \\\n+      \"Trace startup time\")                                                 \\\n+                                                                            \\\n+  product(bool, CRDoThrowCheckpointException, true, EXPERIMENTAL,           \\\n+      \"Throw CheckpointException if uncheckpointable resource handle found\")\\\n+                                                                            \\\n+  product(bool, CRTrace, true, RESTORE_SETTABLE, \"Minimal C\/R tracing\")     \\\n+                                                                            \\\n+  product(bool, CRPauseOnCheckpointError, false, DIAGNOSTIC,                \\\n+      \"Pauses the checkpoint when a problem is found on VM level.\")         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":66,"deletions":4,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1155,0 +1155,1 @@\n+  void wakeup_sleep() { _SleepEvent->unpark(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2148,0 +2148,7 @@\n+void os::cleanup_memory(char* addr, size_t bytes) {\n+  char* start = (char*)align_up(addr, os::vm_page_size());\n+  char* end = (char*)align_down(addr + bytes, os::vm_page_size());\n+  os::uncommit_memory(start, end - start);\n+  os::commit_memory(start, end - start, false);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -477,0 +477,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n@@ -632,0 +634,4 @@\n+  static int exec_child_process_and_wait(const char *path, const char *argv[]);\n+\n+  static int execv(const char *path, const char *argv[]);\n+\n@@ -684,0 +690,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -687,0 +696,2 @@\n+  static bool           is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -413,0 +414,15 @@\n+jint Threads::check_for_restore(JavaVMInitArgs* args) {\n+  if (Arguments::is_restore_option_set(args)) {\n+    if (!Arguments::parse_options_for_restore(args)) {\n+      return JNI_ERR;\n+    }\n+    crac::restore();\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -416,0 +432,2 @@\n+  if (check_for_restore(args) != JNI_OK) return JNI_ERR;\n+\n@@ -480,0 +498,2 @@\n+  crac::vm_create_start();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+  static jint check_for_restore(JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+  template(VM_Crac)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2471,0 +2471,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+#ifdef LINUX\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#endif \/\/LINUX\n@@ -152,0 +156,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -1104,0 +1110,26 @@\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_crac_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::checkpointRestoreInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != NULL) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      outputStream* stream = output();\n+#if defined(LINUX) && INCLUDE_SERVICES\n+      assert(PosixAttachListener::get_current_op(), \"should exist\");\n+      if (PosixAttachListener::get_current_op()->is_effectively_completed()) {\n+        stream = tty;\n+      }\n+#endif \/\/LINUX\n+      stream->print_cr(\"An exception during a checkpoint operation:\");\n+      stream->print(\"%s\", out);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1025,0 +1025,14 @@\n+class CheckpointDCmd : public DCmd {\n+public:\n+  CheckpointDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"JDK.checkpoint\"; }\n+    static const char* description() {\n+      return \"Checkpoint via jdk.crac.checkpointRestore().\";\n+    }\n+    static const char* impact() {\n+      return \"High: JVM terminates\";\n+    }\n+    static int num_arguments() { return 0; }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -983,0 +984,12 @@\n+  case JMM_JVM_RESTORE_START_TIME_MS:\n+    return crac::restore_start_time();\n+\n+  case JMM_JVM_UPTIME_SINCE_RESTORE_MS:\n+    {\n+      jlong ticks = crac::uptime_since_restore();\n+      if (ticks == -1) {\n+        return -1;\n+      }\n+      return Management::ticks_to_ms(ticks);\n+    }\n+\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -254,0 +254,4 @@\n+#ifndef INCLUDE_CPU_FEATURE_ACTIVE\n+#define INCLUDE_CPU_FEATURE_ACTIVE 1\n+#endif \/\/ INCLUDE_CPU_FEATURE_ACTIVE\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -28,0 +29,8 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n+import java.io.FileDescriptor;\n@@ -30,0 +39,1 @@\n+import java.nio.channels.IllegalSelectorException;\n@@ -49,0 +59,3 @@\n+ *\n+ * @crac The file descriptor(s) used internally by this class are automatically\n+ * closed before checkpointing the process and opened after the restore.\n@@ -50,2 +63,1 @@\n-\n-class EPollSelectorImpl extends SelectorImpl {\n+class EPollSelectorImpl extends SelectorImpl implements JDKResource {\n@@ -56,0 +68,27 @@\n+    private static final JavaIOFileDescriptorAccess fdAccess\n+            = SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    private enum CheckpointRestoreState {\n+        NORMAL_OPERATION,\n+        CHECKPOINT_TRANSITION,\n+        CHECKPOINTED,\n+        CHECKPOINT_ERROR,\n+        RESTORE_TRANSITION,\n+    }\n+\n+    private static class MoveToCheckpointThread extends Thread {\n+        private Selector selector;\n+\n+        MoveToCheckpointThread(Selector selector) {\n+            this.selector = selector;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                selector.select(1);\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+\n@@ -57,1 +96,1 @@\n-    private final int epfd;\n+    private int epfd;\n@@ -60,1 +99,1 @@\n-    private final long pollArrayAddress;\n+    private long pollArrayAddress;\n@@ -63,1 +102,1 @@\n-    private final EventFD eventfd;\n+    private EventFD eventfd;\n@@ -76,2 +115,1 @@\n-    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n-        super(sp);\n+    private volatile CheckpointRestoreState checkpointState = CheckpointRestoreState.NORMAL_OPERATION;;\n@@ -79,2 +117,2 @@\n-        this.epfd = EPoll.create();\n-        this.pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+    private void initFDs() throws IOException {\n+        epfd = EPoll.create();\n@@ -84,1 +122,4 @@\n-            IOUtil.configureBlocking(IOUtil.newFD(eventfd.efd()), false);\n+            FileDescriptor fd = IOUtil.newFD(eventfd.efd());\n+            \/\/ This FileDescriptor is a one-time use, the actual FD will be closed from EventFD\n+            fdAccess.markClosed(fd);\n+            IOUtil.configureBlocking(fd, false);\n@@ -95,0 +136,9 @@\n+    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n+        super(sp);\n+        pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+        initFDs();\n+        \/\/ trigger FileDispatcherImpl initialization\n+        new FileDispatcherImpl();\n+        Core.Priority.EPOLLSELECTOR.getContext().register(this);\n+    }\n+\n@@ -100,0 +150,47 @@\n+    private boolean processCheckpointRestore() throws IOException {\n+        assert Thread.holdsLock(this);\n+\n+        if (checkpointState != CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+            return false;\n+        }\n+\n+        synchronized (interruptLock) {\n+\n+            CheckpointRestoreState thisState;\n+            if (fdToKey.size() == 0) {\n+                eventfd.close();\n+                eventfd = null;\n+                FileDispatcherImpl.closeIntFD(epfd);\n+                thisState = CheckpointRestoreState.CHECKPOINTED;\n+            } else {\n+                thisState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+            }\n+\n+            checkpointState = thisState;\n+            interruptLock.notifyAll();\n+            while (checkpointState == thisState) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+\n+            assert checkpointState == CheckpointRestoreState.RESTORE_TRANSITION;\n+            if (thisState == CheckpointRestoreState.CHECKPOINTED) {\n+                initFDs();\n+            }\n+            checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+            interruptLock.notifyAll();\n+\n+            if (interruptTriggered) {\n+                try {\n+                    eventfd.set();\n+                } catch (IOException ioe) {\n+                    throw new InternalError(ioe);\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n@@ -121,1 +218,3 @@\n-                    numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                    do {\n+                        numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                    } while (processCheckpointRestore());\n@@ -206,1 +305,1 @@\n-        if (interrupted) {\n+        if (interrupted && !(Thread.currentThread() instanceof MoveToCheckpointThread)) {\n@@ -273,0 +372,51 @@\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.CHECKPOINT_TRANSITION;\n+            eventfd.set();\n+            int tries = 5;\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION && 0 < tries--) {\n+                try {\n+                    interruptLock.wait(5);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                Thread thr = new MoveToCheckpointThread(this);\n+                thr.setDaemon(true);\n+                thr.start();\n+            }\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_ERROR) {\n+                throw new IllegalSelectorException();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.RESTORE_TRANSITION;\n+            interruptLock.notifyAll();\n+            while (checkpointState == CheckpointRestoreState.RESTORE_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":162,"deletions":12,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n+import java.util.*;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n@@ -32,0 +32,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n@@ -34,0 +36,1 @@\n+import jdk.internal.crac.*;\n@@ -59,0 +62,66 @@\n+    class Resource extends JDKFdResource {\n+        private boolean closedByNIO;\n+\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n+            if (!closedByNIO && valid()) {\n+                ClaimedFDs claimedFDs = Core.getClaimedFDs();\n+                FileDescriptor self = FileDescriptor.this;\n+                String nativeDescription = nativeDescription0();\n+\n+                OpenResourcePolicies.Policy policy = findPolicy(nativeDescription);\n+                String action = \"error\";\n+                Supplier<Exception> supplier = null;\n+                \/\/ Normally the claiming should be overridden by FileInputStream\/FileOutputStream\n+                \/\/ but in case these are collected we handle FDs 0..2 here as well.\n+                if (policy != null) {\n+                    action = policy.action;\n+                } else if (self == in || self == out || self == err) {\n+                    action = \"ignore\";\n+                }\n+                supplier = switch (action.toLowerCase()) {\n+                    case \"error\":\n+                        yield () -> new CheckpointOpenResourceException(\n+                            FileDescriptor.class.getSimpleName() + \" \" + fd + \": \" + nativeDescription,\n+                            getStackTraceHolder());\n+                    case \"close\":\n+                        close();\n+                    case \"ignore\":\n+                        warnOpenResource(policy, \"File descriptor \" + fd);\n+                        yield NO_EXCEPTION;\n+                    default: throw new IllegalArgumentException(\"Unknown policy action for file descriptor \" + fd + \": \" + action);\n+                };\n+                claimedFDs.claimFd(self, self, supplier);\n+            }\n+        }\n+\n+        private OpenResourcePolicies.Policy findPolicy(String nativeDescription) {\n+            return OpenResourcePolicies.find(false, \"filedescriptor\", params -> {\n+                String value = params.get(\"value\");\n+                if (value != null) {\n+                    try {\n+                        int expected = Integer.parseInt(value);\n+                        if (expected != fd) {\n+                            return false;\n+                        }\n+                    } catch (NumberFormatException e) {\n+                        throw new IllegalArgumentException(\"Cannot parse file descriptor value '\" + value + \"'\");\n+                    }\n+                }\n+                String regex = params.get(\"regex\");\n+                if (regex != null) {\n+                    return Pattern.compile(regex).matcher(nativeDescription).find();\n+                }\n+                return true;\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getName() + \"(FD \" + fd + \")\";\n+        }\n+    }\n+\n+    Resource resource = new Resource();\n+\n@@ -92,0 +161,5 @@\n+                    @Override\n+                    public void markClosed(FileDescriptor fdo) {\n+                        fdo.resource.closedByNIO = true;\n+                    }\n+\n@@ -307,0 +381,2 @@\n+    private native String nativeDescription0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":79,"deletions":3,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFileResource;\n@@ -602,0 +609,65 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (fd == FileDescriptor.in) {\n+                Core.getClaimedFDs().claimFd(fd, FileInputStream.this, NO_EXCEPTION, fd);\n+            } else {\n+                \/\/ When the stream is opened with file descriptor we don't have any extra\n+                \/\/ information we could use for policy (this is most often a pipe, but could\n+                \/\/ be a socket as well). Such cases need to be handled on a higher level.\n+                super.beforeCheckpoint(context);\n+            }\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            try {\n+                offset = position();\n+            } catch (IOException e) {\n+                \/\/ We might get IOException from native code when lseeking a named pipe.\n+                offset = 0;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path);\n+                if (offset > 0) {\n+                    skip(offset);\n+                }\n+                FileInputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -29,0 +29,8 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -31,0 +39,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -98,0 +107,10 @@\n+    \/**\n+     * When the file is opened in non-append mode we need to check position\n+     * through the {@link #channel} when handling the file descriptor policy;\n+     * this needs to be independent of the regular resource as we need to\n+     * ensure initialization of the channel before FD priority class.\n+     * This field being <code>null<\/code> means that the file is opened in\n+     * append-only mode and does not need to track the position.\n+     *\/\n+    private final EnsureChannelResource channelResource;\n+\n@@ -236,0 +255,5 @@\n+        if (append) {\n+            channelResource = null;\n+        } else {\n+            channelResource = new EnsureChannelResource();\n+        }\n@@ -276,0 +300,2 @@\n+        \/\/ We don't have path information and won't reopen the file\n+        this.channelResource = null;\n@@ -285,1 +311,1 @@\n-    private native void open0(String name, boolean append)\n+    private native void open0(String name, boolean append, boolean truncate)\n@@ -295,1 +321,1 @@\n-        open0(name, append);\n+        open0(name, append, !append);\n@@ -513,0 +539,77 @@\n+\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            if (channelResource != null) {\n+                FileChannel channel = getChannel();\n+                channelResource.position = channel.isOpen() ? channel.position() : -1;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            assert path != null; \/\/ won't be reopened if it was not closed, and won't be closed without path\n+            synchronized (closeLock) {\n+                \/\/ We have been writing to a file, but it disappeared during checkpoint\n+                if (!Files.exists(Path.of(path))) {\n+                    throw new IOException(\"File \" + path + \" is not present during restore\");\n+                }\n+                if (channelResource == null) {\n+                    open(path, true);\n+                } else {\n+                    open0(path, false, false);\n+                    \/\/noinspection resource\n+                    getChannel().position(channelResource.position);\n+                }\n+                FileOutputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n+    private class EnsureChannelResource implements JDKResource {\n+        public long position;\n+\n+        EnsureChannelResource() {\n+            \/\/ This must be before PRE_FILE_DESCRIPTORS as getChannel()\n+            \/\/ could clinit FileDispatcherImpl\n+            Core.Priority.NORMAL.getContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            \/\/ the channel is not used but we ensure its existence\n+            getChannel();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":105,"deletions":2,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -32,0 +33,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -83,0 +85,1 @@\n+    private final int imode;\n@@ -102,0 +105,31 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ We cannot synchronize this without making every other method call synchronized\n+            offset = getFilePointer();\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path, imode);\n+                seek(offset);\n+                RandomAccessFile.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n@@ -285,0 +319,1 @@\n+        this.imode = imode;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,7 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -39,0 +46,1 @@\n+import java.util.function.Supplier;\n@@ -817,0 +825,1 @@\n+        private final JDKFdResource resource;\n@@ -820,0 +829,1 @@\n+            resource = new PipeResource(this, fd);\n@@ -914,0 +924,31 @@\n+    static class PipeResource extends JDKFdResource {\n+        private final Closeable owner;\n+        private final FileDescriptor fd;\n+\n+        PipeResource(Closeable owner, FileDescriptor fd) {\n+            this.owner = owner;\n+            this.fd = fd;\n+        }\n+\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            OpenResourcePolicies.Policy policy = OpenResourcePolicies.find(false, OpenResourcePolicies.PIPE, null);\n+            String action = policy != null ? policy.action.toLowerCase() : \"error\";\n+            Supplier<Exception> exceptionSupplier = switch (action) {\n+                case \"error\":\n+                    yield  () -> new CheckpointOpenResourceException(owner.toString(), getStackTraceHolder());\n+                case \"close\":\n+                    owner.close();\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    warnOpenResource(policy, owner.toString());\n+                    yield NO_EXCEPTION;\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + owner, null);\n+            };\n+            \/\/ FileInputStream does not claim when path is null\n+            Core.getClaimedFDs().claimFd(fd, this, exceptionSupplier, fd);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -566,0 +566,5 @@\n+     * @crac When the process is restored on another machine or if the machine\n+     * rebooted the value is updated based on wall-clock time difference,\n+     * resulting in a loss of accuracy when comparing timestamps obtained\n+     * before and after checkpoint.\n+     *\n@@ -828,0 +833,6 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload system properties in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -951,0 +962,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -987,0 +1001,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -1141,0 +1158,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload environment variables in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -1194,0 +1217,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload the environment variables in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.crac.Core;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -334,0 +338,10 @@\n+            @Override\n+            public <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException {\n+                return queue.poll(timeout);\n+            }\n+\n+            @Override\n+            public void wakeupReferenceQueue(ReferenceQueue<?> queue) {\n+                queue.wakeup();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -199,0 +199,23 @@\n+    Reference<? extends T> poll(long timeout) throws InterruptedException {\n+        lock.lock();\n+        try {\n+            Reference<? extends T> r = poll0();\n+            if (r != null) return r;\n+            \/\/ any wake (including spurious) ends the wait\n+            \/\/noinspection ResultOfMethodCallIgnored\n+            notEmpty.await(timeout, TimeUnit.MILLISECONDS);\n+            return poll0();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    void wakeup() {\n+        lock.lock();\n+        try {\n+            notEmpty.signalAll();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.crac.JDKSocketResource;\n+import sun.nio.ch.Net;\n+\n@@ -58,0 +61,23 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() {\n+            disconnect();\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n@@ -61,0 +63,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -239,0 +243,6 @@\n+ * @crac This class holds a cache of resolved hostname-address pairs;\n+ * this cache is wiped out before checkpoint. Therefore, lookups after restore\n+ * will cause name address resolution.\n+ * This ensures that the addresses are up-to-date in the environment where\n+ * the process is restored.\n+ *\n@@ -357,0 +367,3 @@\n+    \/* Resource registration uses weak references; we need to keep it locally. *\/\n+    private static final JDKResource checkpointListener;\n+\n@@ -393,0 +406,14 @@\n+        \/\/ DNS cache is cleared before the checkpoint; application restored at a later point\n+        \/\/ or in a different environment should query DNS again.\n+        checkpointListener = new JDKResource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                cache.clear();\n+                expirySet.clear();\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            }\n+        };\n+        Core.Priority.NORMAL.getContext().register(checkpointListener);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -32,0 +33,1 @@\n+import java.io.FileDescriptor;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -36,0 +37,1 @@\n+import sun.nio.ch.Net;\n@@ -75,0 +77,23 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return new InetSocketAddress(address, port);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -212,0 +212,4 @@\n+     *\n+     * @crac Instances created by this constructor are automatically reseeded\n+     * after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n@@ -254,0 +258,4 @@\n+     * @crac Instances created by this constructor are <strong>not<\/strong>\n+     * reseeded after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n+     *\n@@ -355,0 +363,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -402,0 +412,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -446,0 +458,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -493,0 +507,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -550,0 +566,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -602,0 +620,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -324,0 +324,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n@@ -368,0 +373,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/Timer.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -66,0 +67,1 @@\n+import jdk.internal.crac.Core;\n@@ -836,0 +838,8 @@\n+\n+        public void beforeCheckpoint() {\n+            if (zsrc != null) {\n+                synchronized (zsrc) {\n+                    zsrc.beforeCheckpoint();\n+                }\n+            }\n+        }\n@@ -1132,0 +1142,4 @@\n+    private synchronized void beforeCheckpoint() {\n+        res.beforeCheckpoint();\n+    }\n+\n@@ -1175,2 +1189,5 @@\n-\n-             }\n+                @Override\n+                public void beforeCheckpoint(ZipFile zip) {\n+                    zip.beforeCheckpoint();\n+                }\n+            }\n@@ -2053,0 +2070,13 @@\n+\n+        public void beforeCheckpoint() {\n+            synchronized (zfile) {\n+                FileDescriptor fd = null;\n+                try {\n+                    fd = zfile.getFD();\n+                } catch (IOException e) {\n+                }\n+                if (fd != null) {\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+                }\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import sun.security.action.GetBooleanAction;\n+\n+import java.util.function.Supplier;\n+\n+public abstract class JDKFdResource implements JDKResource {\n+    public static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n+    private static final String COLLECT_FD_STACKTRACES_HINT =\n+        \"Use -D\" + COLLECT_FD_STACKTRACES_PROPERTY + \"=true to find the source.\";\n+\n+    private static final boolean COLLECT_FD_STACKTRACES =\n+        GetBooleanAction.privilegedGetProperty(COLLECT_FD_STACKTRACES_PROPERTY);\n+\n+    \/\/ No lambdas during clinit...\n+    protected static Supplier<Exception> NO_EXCEPTION = new Supplier<Exception>() {\n+        @Override\n+        public Exception get() {\n+            return null;\n+        }\n+    };\n+\n+    final Exception stackTraceHolder;\n+\n+    static volatile boolean stacktraceHintPrinted = false;\n+    static volatile boolean warningSuppressionHintPrinted = false;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public JDKFdResource() {\n+        stackTraceHolder = COLLECT_FD_STACKTRACES ?\n+            \/\/ About the timestamp: we cannot format it nicely since this\n+            \/\/ exception is sometimes created too early in the VM lifecycle\n+            \/\/ (but it's hard to detect when it would be safe to do).\n+            new Exception(\"This file descriptor was created by \" + Thread.currentThread().getName()\n+                + \" at epoch:\" + System.currentTimeMillis() + \" here\") :\n+            null;\n+\n+        Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+        OpenResourcePolicies.ensureRegistered();\n+    }\n+\n+    protected Exception getStackTraceHolder() {\n+        if (!stacktraceHintPrinted && stackTraceHolder == null) {\n+            stacktraceHintPrinted = true;\n+            LoggerContainer.info(COLLECT_FD_STACKTRACES_HINT);\n+        }\n+        return stackTraceHolder;\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+    }\n+\n+    protected void warnOpenResource(OpenResourcePolicies.Policy policy, String self) {\n+        \/\/ The warning is not printed for implicitly closed resource (without policy)\n+        \/\/ e.g. standard input\/output streams\n+        String warn = \"false\";\n+        if (policy != null) {\n+            warn = policy.params.getOrDefault(\"warn\", \"true\");\n+        }\n+        if (Boolean.parseBoolean(warn)) {\n+            LoggerContainer.warn(\"{0} was not closed by the application.\", self);\n+            if (!warningSuppressionHintPrinted) {\n+                LoggerContainer.info(\"To suppress the warning above use 'warn: false' in the resource policy.\");\n+                warningSuppressionHintPrinted = true;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFdResource.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.util.jar.PersistentJarFile;\n@@ -797,1 +798,1 @@\n-                return checkJar(new JarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n+                return checkJar(new PersistentJarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+    exports javax.crac;\n@@ -139,0 +140,1 @@\n+    exports jdk.crac;\n@@ -178,0 +180,2 @@\n+    exports jdk.internal.crac to\n+        jdk.sctp;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+\n+import jdk.internal.crac.JDKSocketResource;\n@@ -53,0 +55,1 @@\n+    private final JDKSocketResource resource;\n@@ -73,0 +76,21 @@\n+        this.resource = new JDKSocketResource(this) {\n+            @Override\n+            protected FileDescriptor getFD() {\n+                return fd;\n+            }\n+\n+            @Override\n+            protected SocketAddress localAddress() {\n+                return localAddress;\n+            }\n+\n+            @Override\n+            protected SocketAddress remoteAddress() {\n+                return null;\n+            }\n+\n+            @Override\n+            protected void closeBeforeCheckpoint() throws IOException {\n+                close();\n+            }\n+        };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -107,0 +108,1 @@\n+    private final JDKSocketResource resource = new Resource();\n@@ -2094,0 +2096,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(DatagramChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -53,0 +56,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -83,0 +87,34 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (!isOpen() || path == null) {\n+                return;\n+            } else if (parent != null) {\n+                \/\/ This FileChannel is managed by a higher level object that\n+                \/\/ will handle the provided file descriptor on its own.\n+                return;\n+            }\n+            super.beforeCheckpoint(context);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ implementation is possible but non-trivial\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -78,0 +79,1 @@\n+    private final Resource resource = new Resource();\n@@ -414,1 +416,0 @@\n-\n@@ -761,0 +762,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(ServerSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -86,0 +87,1 @@\n+    private final Resource resource = new Resource();\n@@ -1635,0 +1637,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(SocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+\n@@ -35,0 +39,2 @@\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.Arrays;\n@@ -52,0 +58,10 @@\n+ * @crac If this class is created using the {@link #SecureRandom() no-arg constructor}\n+ * and never {@link #engineSetSeed(byte[]) reseeded} it is automatically reseeded\n+ * after restore from a checkpoint. Therefore, after restore the sequences produced\n+ * during different runs should differ (and the application will consume system entropy).\n+ * If a seed was provided externally the application might depend on the sequence\n+ * produced by this generator, therefore it is not reseeded.\n+ * If this behaviour is not desired the application should {@link javax.crac.Context#register(javax.crac.Resource) register}\n+ * a resource and in the {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method}\n+ * reseed it using the {@link #engineSetSeed(byte[])}.\n+ *\n@@ -58,1 +74,1 @@\n-implements java.io.Serializable {\n+implements java.io.Serializable, jdk.internal.crac.JDKResource {\n@@ -68,0 +84,2 @@\n+    private boolean clearStateOnCheckpoint = true;\n+    private ReentrantLock objLock = new ReentrantLock();\n@@ -85,0 +103,4 @@\n+     *\n+     * @crac Instances created using this constructor are automatically\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n@@ -94,0 +116,4 @@\n+     * @crac Instances created using this constructor are <strong>not<\/strong>\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n+     *\n@@ -124,0 +150,1 @@\n+        Core.Priority.SECURE_RANDOM.getContext().register(this);\n@@ -156,0 +183,4 @@\n+     * @crac After this method is called the instance is <strong>not<\/strong>\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n+     *\n@@ -159,1 +190,14 @@\n-    public synchronized void engineSetSeed(byte[] seed) {\n+    public void engineSetSeed(byte[] seed) {\n+        objLock.lock();\n+        try {\n+            \/\/ check if objLock has not been already acquired in beforeCheckpoint\n+            if(objLock.getHoldCount() > 1) {\n+                throw new IllegalStateException(\"SHA1PRNG object is invalidated\");\n+            }\n+            setSeedImpl(seed);\n+        } finally {\n+            objLock.unlock();\n+        }\n+    }\n+\n+    private void setSeedImpl(byte[] seed) {\n@@ -166,0 +210,1 @@\n+        clearStateOnCheckpoint = false;\n@@ -193,0 +238,26 @@\n+    private void invalidate() {\n+        assert objLock.isHeldByCurrentThread();\n+        if (state != null) {\n+            Arrays.fill(state, (byte)0);\n+        }\n+        state = null;\n+        if (remainder != null) {\n+            Arrays.fill(remainder, (byte)0);\n+        }\n+        remainder = null;\n+        remCount = 0;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        objLock.lock();\n+        if (clearStateOnCheckpoint) {\n+            invalidate();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        objLock.unlock();\n+    }\n+\n@@ -199,1 +270,3 @@\n-    private static class SeederHolder {\n+    private static class SeederHolder implements jdk.internal.crac.JDKResource {\n+        private static final SeederHolder seederHolder = new SeederHolder();\n+        private final SecureRandom seeder;\n@@ -201,3 +274,1 @@\n-        private static final SecureRandom seeder;\n-\n-        static {\n+        private SeederHolder() {\n@@ -209,1 +280,1 @@\n-            byte [] b = new byte[DIGEST_SIZE];\n+            byte[] b = new byte[DIGEST_SIZE];\n@@ -212,0 +283,17 @@\n+            Core.Priority.SEEDER_HOLDER.getContext().register(this);\n+        }\n+\n+        public static SecureRandom getSeeder() {\n+            return seederHolder.seeder;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            seeder.invalidate();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            byte[] b = new byte[DIGEST_SIZE];\n+            SeedGenerator.generateSeed(b);\n+            seeder.setSeedImpl(b);\n@@ -221,10 +309,10 @@\n-    public synchronized void engineNextBytes(byte[] result) {\n-        int index = 0;\n-        int todo;\n-        byte[] output = remainder;\n-\n-        if (state == null) {\n-            byte[] seed = new byte[DIGEST_SIZE];\n-            SeederHolder.seeder.engineNextBytes(seed);\n-            state = digest.digest(seed);\n-        }\n+    public void engineNextBytes(byte[] result) {\n+        objLock.lock();\n+        try {\n+            \/\/ verify if objLock is already acquired in beforeCheckpoint\n+            if(objLock.getHoldCount() > 1) {\n+                throw new IllegalStateException(\"SHA1PRNG object is invalidated\");\n+            }\n+            int index = 0;\n+            int todo;\n+            byte[] output = remainder;\n@@ -232,9 +320,4 @@\n-        \/\/ Use remainder from last time\n-        int r = remCount;\n-        if (r > 0) {\n-            \/\/ How many bytes?\n-            todo = Math.min(result.length - index, DIGEST_SIZE - r);\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[i] = output[r];\n-                output[r++] = 0;\n+            if (state == null) {\n+                byte[] seed = new byte[DIGEST_SIZE];\n+                SeederHolder.getSeeder().engineNextBytes(seed);\n+                state = digest.digest(seed);\n@@ -242,16 +325,12 @@\n-            remCount += todo;\n-            index += todo;\n-        }\n-        \/\/ If we need more bytes, make them.\n-        while (index < result.length) {\n-            \/\/ Step the state\n-            digest.update(state);\n-            output = digest.digest();\n-            updateState(state, output);\n-\n-            \/\/ How many bytes?\n-            todo = Math.min((result.length - index), DIGEST_SIZE);\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[index++] = output[i];\n-                output[i] = 0;\n+            \/\/ Use remainder from last time\n+            int r = remCount;\n+            if (r > 0) {\n+                \/\/ How many bytes?\n+                todo = Math.min(result.length - index, DIGEST_SIZE - r);\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[i] = output[r];\n+                    output[r++] = 0;\n+                }\n+                remCount += todo;\n+                index += todo;\n@@ -260,5 +339,23 @@\n-            remCount += todo;\n-        }\n-        \/\/ Store remainder for next time\n-        remainder = output;\n-        remCount %= DIGEST_SIZE;\n+            \/\/ If we need more bytes, make them.\n+            while (index < result.length) {\n+                \/\/ Step the state\n+                digest.update(state);\n+                output = digest.digest();\n+                updateState(state, output);\n+\n+                \/\/ How many bytes?\n+                todo = Math.min((result.length - index), DIGEST_SIZE);\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[index++] = output[i];\n+                    output[i] = 0;\n+                }\n+                remCount += todo;\n+            }\n+\n+            \/\/ Store remainder for next time\n+            remainder = output;\n+            remCount %= DIGEST_SIZE;\n+        } finally {\n+            objLock.unlock();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":144,"deletions":47,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -1329,1 +1329,22 @@\n-\\f[V]-XX:ErrorFile=\\f[R]\\f[I]filename\\f[R]\n+\\f[V]-XX:CRaCCheckpointTo=\\f[R]\\f[I]directory\\f[R]\n+The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+a running Java program into an image directory. Restoring from the image should\n+solve some of the problematic start-up and warm-up times.\n+.PP\n+This option defines a path to the snapshot which is currently a directory. The\n+directory will be created if it does not exist, but no parent directories are\n+created.\n+.RS\n+.RE\n+.TP\n+\\f[V]-XX:CRaCRestoreFrom=\\f[R]\\f[I]directory\\f[R]\n+Restores a snapshot created by\n+\\f[V]-XX:CRaCCheckpointTo=\\f[R]\\f[I]directory\\f[R].\n+.RS\n+.RE\n+.TP\n+\\f[V]-XX:CRaCMinPid=\\f[R]value\\f[R]\n+A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+.RS\n+.RE\n+.TP\n@@ -2298,0 +2319,9 @@\n+\\f[V]-XX:CPUFeatures=\\f[R]\\f[I]0xnumber\\f[R]\n+CPU feature set, use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when\n+you get an error during -XX:CRaCRestoreFrom on a different machine.\n+\\f[V]-XX:CPUFeatures=native\\f[R] is the default.\n+\\f[V]-XX:CPUFeatures=generic\\f[R] is compatible with any CPU but not as slow\n+as \\f[V]-XX:CPUFeatures=0\\f[R].\n+.RS\n+.RE\n+.TP\n@@ -2541,0 +2571,6 @@\n+\\f[V]-XX:+ShowCPUFeatures\\f[R]\n+Show features of this CPU to be possibly used for the\n+\\f[V]-XX:CPUFeatures=0xnumber\\f[R] option.\n+.RS\n+.RE\n+.TP\n","filename":"src\/java.base\/share\/man\/java.1","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import jdk.internal.crac.JDKFdResource;\n@@ -628,0 +629,2 @@\n+        private final JDKFdResource resource;\n+\n@@ -629,1 +632,6 @@\n-            super(new PipeOutputStream(newFileDescriptor(fd)));\n+            this(newFileDescriptor(fd));\n+        }\n+\n+        private ProcessPipeOutputStream(FileDescriptor fd) {\n+            super(new PipeOutputStream(fd));\n+            resource = new PipeResource(this, fd);\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n@@ -33,0 +34,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -73,0 +78,5 @@\n+ * @crac Before checkpoint the underlying random number generator is discarded\n+ * and after restore a new {@link sun.security.provider.SecureRandom} is\n+ * created, therefore this produces different sequences when restored multiple\n+ * times.\n+ *\n@@ -339,1 +349,1 @@\n-    private static class RandomIO {\n+    private static class RandomIO implements JDKResource {\n@@ -393,0 +403,4 @@\n+        \/\/ lock for checkpoint\/restore\n+        \/\/ allows clearing mixRandom and internal buffer before checkpoint\n+        private final ReentrantReadWriteLock crLock = new ReentrantReadWriteLock();\n+\n@@ -399,0 +413,1 @@\n+            Core.Priority.NATIVE_PRNG.getContext().register(this);\n@@ -485,1 +500,9 @@\n-                getMixRandom().engineSetSeed(seed);\n+                crLock.readLock().lock();\n+                try {\n+                    if(crLock.getWriteHoldCount() != 0) {\n+                        throw new IllegalStateException(\"PRNG object is invalidated\");\n+                    }\n+                    getMixRandom().engineSetSeed(seed);\n+                } finally {\n+                    crLock.readLock().unlock();\n+                }\n@@ -543,0 +566,1 @@\n+            crLock.readLock().lock();\n@@ -544,0 +568,3 @@\n+                    if(crLock.getWriteHoldCount() != 0) {\n+                        throw new IllegalStateException(\"PRNG object is invalidated\");\n+                    }\n@@ -576,0 +603,2 @@\n+                } finally {\n+                    crLock.readLock().unlock();\n@@ -578,0 +607,15 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            synchronized (LOCK_SET_SEED) {\n+                if (seedOut != null) {\n+                    FileDescriptor fd = ((FileOutputStream)seedOut).getFD();\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+                }\n+            }\n+\n+            crLock.writeLock().lock();\n+            mixRandom = null;\n+            buffered = 0;\n+            lastRead = 0;\n+            Arrays.fill(nextBuffer, (byte)0);\n@@ -579,0 +623,6 @@\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            crLock.writeLock().unlock();\n+        }\n+    }\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":52,"deletions":2,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -682,0 +682,9 @@\n+    {\n+      const int restore_signal = SIGRTMIN + 2;\n+      \/\/ block restore_signal in launcher thread to allow JVM handle it\n+      sigset_t block_sig;\n+      sigemptyset(&block_sig);\n+      sigaddset(&block_sig, restore_signal);\n+      pthread_sigmask(SIG_BLOCK, &block_sig, NULL);\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        this.addJavaOpts(javaOpts);\n+        Collections.addAll(this.javaOpts, javaOpts);\n@@ -65,1 +65,1 @@\n-        this.addJavaOpts(\"-XX:+ErrorFileToStderr\");\n+        Collections.addAll(this.javaOpts, \"-XX:+ErrorFileToStderr\");\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerRunOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,3 @@\n+    public static final String BASE_IMAGE_NAME = \"jdk.test.docker.image.name\";\n+    public static final String BASE_IMAGE_VERSION = \"jdk.test.docker.image.version\";\n+\n@@ -41,1 +44,1 @@\n-        String name = System.getProperty(\"jdk.test.docker.image.name\");\n+        String name = System.getProperty(BASE_IMAGE_NAME);\n@@ -60,1 +63,1 @@\n-        String version = System.getProperty(\"jdk.test.docker.image.version\");\n+        String version = System.getProperty(BASE_IMAGE_VERSION);\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}