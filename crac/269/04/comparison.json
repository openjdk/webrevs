{"files":[{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CRLIB_IMAGE_SCORE_H\n+#define CRLIB_IMAGE_SCORE_H\n+\n+#include \"crlib.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CRLIB_EXTENSION_IMAGE_SCORE_NAME \"image score\"\n+#define CRLIB_EXTENSION_IMAGE_SCORE(api) \\\n+  CRLIB_EXTENSION(api, crlib_image_score_t, CRLIB_EXTENSION_IMAGE_SCORE_NAME)\n+\n+\/\/ API for quantifying image performance. This is a write-only API.\n+\/\/ The metrics are NOT retained after checkpoint (succesful or not),\n+\/\/ the application is expected to set scores again before next attempt\n+\/\/ to checkpoint.\n+typedef const struct crlib_image_score {\n+  crlib_extension_t header;\n+  \/\/ Invoked before checkpoint. When invoked with the same metric name\n+  \/\/ multiple times the older value is overwritten.\n+  \/\/ Returns false if the score cannot be recorded, true on success.\n+  \/\/ The score is persisted during checkpoint (not in this function).\n+  bool (*set_score)(crlib_conf_t *conf, const char *metric, double value);\n+} crlib_image_score_t;\n+\n+#ifdef __cplusplus\n+} \/\/ extern \"C\"\n+#endif\n+\n+#endif \/\/ CRLIB_IMAGE_SCORE_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib_image_score.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -1196,0 +1196,6 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsCRaCScoreSupported(JNIEnv *env);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_RecordCRaCScore(JNIEnv *env, jobjectArray metrics, jdoubleArray values);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3718,0 +3718,8 @@\n+JVM_ENTRY(jboolean, JVM_IsCRaCScoreSupported(JNIEnv *env))\n+  return crac::is_image_score_supported();\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_RecordCRaCScore(JNIEnv *env, jobjectArray metrics, jdoubleArray values))\n+  return crac::record_image_score(metrics, values);\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"compiler\/compileBroker.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"oops\/oopCast.inline.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"services\/classLoadingService.hpp\"\n@@ -163,1 +166,1 @@\n-  return os::javaTimeMillis() - 1000 * (os::elapsed_counter() \/ os::elapsed_frequency());\n+  return os::javaTimeMillis() - (1000 * os::elapsed_counter() \/ os::elapsed_frequency());\n@@ -702,0 +705,60 @@\n+bool crac::is_image_score_supported() {\n+  return _engine->prepare_image_score_api() == CracEngine::ApiStatus::OK;\n+}\n+\n+bool crac::record_image_score(jobjectArray metrics, jdoubleArray values) {\n+  if (_engine->prepare_image_score_api() != CracEngine::ApiStatus::OK) {\n+    \/\/ silently ignoring this\n+    return true;\n+  }\n+  ResourceMark rm;\n+  objArrayOop metrics_oops = oop_cast<objArrayOop>(JNIHandles::resolve_non_null(metrics));\n+  typeArrayOop values_oops = oop_cast<typeArrayOop>(JNIHandles::resolve_non_null(values));\n+  assert(metrics_oops->length() == values_oops->length(), \"should be equal\");\n+  for (int i = 0; i < metrics_oops->length(); ++i) {\n+    oop metric_oop = metrics_oops->obj_at(i);\n+    assert(metric_oop != nullptr, \"not null\");\n+    const char* metric = java_lang_String::as_utf8_string(metric_oop);\n+    double value = values_oops->double_at(i);\n+    if (!_engine->set_score(metric, value)) {\n+      return false;\n+    }\n+  }\n+\n+  bool result = true;\n+  result = result && _engine->set_score(\"java.lang.Runtime.availableProcessors\", os::active_processor_count());\n+  result = result && _engine->set_score(\"java.lang.Runtime.totalMemory\", Universe::heap()->capacity());\n+  result = result && _engine->set_score(\"java.lang.Runtime.maxMemory\", Universe::heap()->max_capacity());\n+\n+  double uptime = TimeHelper::counter_to_millis(os::elapsed_counter());\n+  result = result && _engine->set_score(\"vm.boot_time\", os::javaTimeMillis() - uptime);\n+  result = result && _engine->set_score(\"vm.uptime\", uptime);\n+  result = result && _engine->set_score(\"vm.uptime_since_restore\", TimeHelper::counter_to_millis(os::elapsed_counter_since_restore()));\n+\n+#if INCLUDE_MANAGEMENT\n+  jlong shared_loaded_classes = ClassLoadingService::loaded_shared_class_count();\n+  jlong shared_unloaded_classes = ClassLoadingService::unloaded_shared_class_count();\n+  \/\/ The keys match what jcmd <pid> PerfCounter.print would use\n+  result = result && _engine->set_score(\"java.cls.loadedClasses\", ClassLoadingService::loaded_class_count() - shared_loaded_classes);\n+  result = result && _engine->set_score(\"java.cls.sharedLoadedClasses\", shared_loaded_classes);\n+  result = result && _engine->set_score(\"java.cls.unloadedClasses\", ClassLoadingService::unloaded_class_count() - shared_unloaded_classes);\n+  result = result && _engine->set_score(\"java.cls.sharedUnloadedClasses\", shared_unloaded_classes);\n+#endif \/\/ INCLUDE_MANAGEMENT\n+  if (ClassLoader::perf_app_classload_count() != nullptr) {\n+    result = result && _engine->set_score(\"sun.cls.appClassLoadCount\", ClassLoader::perf_app_classload_count()->get_value());\n+  }\n+\n+  result = result && _engine->set_score(\"sun.ci.totalCompiles\", CompileBroker::get_total_compile_count());\n+  result = result && _engine->set_score(\"sun.ci.totalBailouts\", CompileBroker::get_total_bailout_count());\n+  result = result && _engine->set_score(\"sun.ci.totalInvalidates\", CompileBroker::get_total_invalidated_count());\n+  \/\/ CompileBroker::get_total_native_compile_count() is never incremented?\n+  result = result && _engine->set_score(\"sun.ci.osrCompiles\", CompileBroker::get_total_osr_compile_count());\n+  result = result && _engine->set_score(\"sun.ci.standardCompiles\", CompileBroker::get_total_standard_compile_count());\n+  result = result && _engine->set_score(\"sun.ci.osrBytes\", CompileBroker::get_sum_osr_bytes_compiled());\n+  result = result && _engine->set_score(\"sun.ci.standardBytes\", CompileBroker::get_sum_standard_bytes_compiled());\n+  result = result && _engine->set_score(\"sun.ci.nmethodSize\", CompileBroker::get_sum_nmethod_size());\n+  result = result && _engine->set_score(\"sun.ci.nmethodCodeSize\", CompileBroker::get_sum_nmethod_code_size());\n+  result = result && _engine->set_score(\"java.ci.totalTime\", CompileBroker::get_total_compilation_time());\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+  static bool is_image_score_supported();\n+  static bool record_image_score(jobjectArray metrics, jdoubleArray values);\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -369,16 +369,20 @@\n-CracEngine::ApiStatus CracEngine::prepare_restore_data_api() {\n-  precond(is_initialized());\n-  if (_restore_data_api != nullptr) {\n-    return ApiStatus::OK;\n-  }\n-\n-  crlib_restore_data_t * const restore_data_api = CRLIB_EXTENSION_RESTORE_DATA(_api);\n-  if (restore_data_api == nullptr) {\n-    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n-    return ApiStatus::UNSUPPORTED;\n-  }\n-  if (restore_data_api->set_restore_data == nullptr || restore_data_api->get_restore_data == nullptr) {\n-    log_error(crac)(\"CRaC engine provided invalid API for extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n-    return ApiStatus::ERR;\n-  }\n-  _restore_data_api = restore_data_api;\n+#define prepare_extension_api(_ext_api, ext_name) \\\n+  precond(is_initialized()); \\\n+  if (_ext_api != nullptr) { \\\n+    return ApiStatus::OK; \\\n+  } \\\n+  auto const ext_api = CRLIB_EXTENSION(_api, std::remove_reference<decltype(*_ext_api)>::type, ext_name); \\\n+  if (ext_api == nullptr) { \\\n+    log_debug(crac)(\"CRaC engine does not support extension \" ext_name); \\\n+    return ApiStatus::UNSUPPORTED; \\\n+  } \\\n+  constexpr const char *_ext_name = ext_name;\n+\n+#define require_method(_func) \\\n+  if (ext_api->_func == nullptr) { \\\n+    log_error(crac)(\"CRaC engine provided invalid API for extension %s: %s is not set\", _ext_name, #_func); \\\n+    return ApiStatus::ERR; \\\n+  }\n+\n+#define complete_extension_api(_ext_api) \\\n+  _ext_api = ext_api; \\\n@@ -386,0 +390,6 @@\n+\n+CracEngine::ApiStatus CracEngine::prepare_restore_data_api() {\n+  prepare_extension_api(_restore_data_api, CRLIB_EXTENSION_RESTORE_DATA_NAME)\n+  require_method(set_restore_data)\n+  require_method(get_restore_data)\n+  complete_extension_api(_restore_data_api)\n@@ -399,19 +409,7 @@\n-  precond(is_initialized());\n-  if (_description_api != nullptr) {\n-    return ApiStatus::OK;\n-  }\n-\n-  crlib_description_t * const description_api = CRLIB_EXTENSION_DESCRIPTION(_api);\n-  if (description_api == nullptr) {\n-    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_DESCRIPTION_NAME);\n-    return ApiStatus::UNSUPPORTED;\n-  }\n-  if (description_api->identity == nullptr || description_api->description == nullptr ||\n-      description_api->configuration_doc == nullptr ||\n-      description_api->configurable_keys == nullptr ||\n-      description_api->supported_extensions == nullptr) {\n-    log_error(crac)(\"CRaC engine provided invalid API for extension: \" CRLIB_EXTENSION_DESCRIPTION_NAME);\n-    return ApiStatus::ERR;\n-  }\n-  _description_api = description_api;\n-  return ApiStatus::OK;\n+  prepare_extension_api(_description_api, CRLIB_EXTENSION_DESCRIPTION_NAME)\n+  require_method(identity)\n+  require_method(description)\n+  require_method(configuration_doc)\n+  require_method(configurable_keys)\n+  require_method(supported_extensions)\n+  complete_extension_api(_description_api)\n@@ -434,17 +432,7 @@\n-  precond(is_initialized());\n-  if (_image_constraints_api != nullptr) {\n-    return ApiStatus::OK;\n-  }\n-\n-  crlib_image_constraints_t * const ic_api = CRLIB_EXTENSION_IMAGE_CONSTRAINTS(_api);\n-  if (ic_api == nullptr) {\n-    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_IMAGE_CONSTRAINTS_NAME);\n-    return ApiStatus::UNSUPPORTED;\n-  }\n-  if (ic_api->set_label == nullptr || ic_api->set_bitmap == nullptr\n-      || ic_api->require_label == nullptr || ic_api->require_bitmap == nullptr) {\n-    log_error(crac)(\"CRaC engine provided invalid API for extension: \" CRLIB_EXTENSION_IMAGE_CONSTRAINTS_NAME);\n-    return ApiStatus::ERR;\n-  }\n-  _image_constraints_api = ic_api;\n-  return ApiStatus::OK;\n+  prepare_extension_api(_image_constraints_api, CRLIB_EXTENSION_IMAGE_CONSTRAINTS_NAME)\n+  require_method(set_label)\n+  require_method(set_bitmap)\n+  require_method(require_label)\n+  require_method(require_bitmap)\n+  require_method(is_failed)\n+  complete_extension_api(_image_constraints_api)\n@@ -487,0 +475,10 @@\n+\n+CracEngine::ApiStatus CracEngine::prepare_image_score_api() {\n+  prepare_extension_api(_image_score_api, CRLIB_EXTENSION_IMAGE_SCORE_NAME)\n+  require_method(set_score)\n+  complete_extension_api(_image_score_api)\n+}\n+\n+bool CracEngine::set_score(const char* metric, double value) {\n+  return _image_score_api->set_score(_conf, metric, value);\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":50,"deletions":52,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"crlib\/crlib_image_score.h\"\n@@ -74,0 +75,3 @@\n+  ApiStatus prepare_image_score_api();\n+  bool set_score(const char* metric, double value);\n+\n@@ -82,0 +86,1 @@\n+  crlib_image_score_t *_image_score_api = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.crac.mirror.impl.GlobalContext;\n@@ -70,0 +71,2 @@\n+        \/\/ Other resources can record score in the beforeCheckpoint\n+        SCORE(Score.getContext()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+package jdk.internal.crac;\n+\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * CRaC Engine can support storing additional metadata about the image.\n+ * This can help the infrastructure to further refine the set of feasible images\n+ * (constrained by CPU architecture and features) and select the image that is expected to perform best.\n+ *\/\n+public class Score {\n+    private static final Map<String, Double> score = new HashMap<>();\n+\n+    \/\/ There shouldn't be anyone else to register at Core.Priority.SCORE.\n+    \/\/ We need to class-load this class every time, to store common metrics.\n+    private static final Context<JDKResource> resource = new Context<>() {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            if (isSupported()) {\n+                record();\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+\n+        @Override\n+        public void register(JDKResource resource) {\n+            throw new UnsupportedOperationException(\"Score is a singleton resource\");\n+        }\n+    };\n+\n+    private Score() {}\n+\n+    public static native boolean isSupported();\n+\n+    private static native boolean record(String[] metrics, double[] values);\n+\n+    private static synchronized void record() {\n+        String[] metrics = new String[score.size()];\n+        double[] values = new double[score.size()];\n+        int i = 0;\n+        for (var e : score.entrySet()) {\n+            metrics[i] = e.getKey();\n+            values[i] = e.getValue();\n+            ++i;\n+        }\n+        if (!record(metrics, values)) {\n+            throw new RuntimeException(\"Cannot record image score\");\n+        }\n+    }\n+\n+    \/**\n+     * Record value to be stored in the image metadata on checkpoint. Repeated invocations\n+     * with the same {@code metric} overwrite previous value. This method can be safely\n+     * called even if the C\/R engine does not support recording metadata.\n+     * On checkpoint the metrics are not reset; if that is desired invoke {@link #resetAll()}\n+     * manually.\n+     *\n+     * @param metric Name of the metric.\n+     * @param value Numeric value of the metric.\n+     *\/\n+    public static synchronized void setScore(String metric, double value) {\n+        score.put(metric, value);\n+    }\n+\n+    \/**\n+     * Drop all currently stored metrics. This method can be safely called\n+     * even if the C\/R engine does not support recording metadata.\n+     *\/\n+    public static synchronized void resetAll() {\n+        score.clear();\n+    }\n+\n+    static Context<JDKResource> getContext() {\n+        return resource;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Score.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -73,1 +73,1 @@\n-    private static final Context<Resource> globalContext = GlobalContext.createGlobalContextImpl();\n+    private static final Context<Resource> globalContext = GlobalContext.createGlobalContextImpl(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n@@ -3,0 +28,1 @@\n+import jdk.internal.crac.JDKResource;\n@@ -6,0 +32,3 @@\n+import java.util.HashMap;\n+import java.util.Map;\n+\n@@ -9,1 +38,26 @@\n-    public static Context<Resource> createGlobalContextImpl() {\n+    \/\/ Scores are in this map only to keep a strong reference to the resource\n+    @SuppressWarnings(\"MismatchedQueryAndUpdateOfCollection\")\n+    private static final Map<String, Score> scores = new HashMap<>();\n+\n+    public static class Score implements JDKResource {\n+        private final String name;\n+        private final OrderedContext<?> ctx;\n+\n+        private Score(String name, OrderedContext<?> ctx) {\n+            this.name = name;\n+            this.ctx = ctx;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            jdk.internal.crac.Score.setScore(name + \".size\", ctx.size());\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+    }\n+\n+    private GlobalContext() {}\n+\n+    public static Context<Resource> createGlobalContextImpl(String name) {\n@@ -11,1 +65,1 @@\n-        return switch (implName) {\n+        OrderedContext<Resource> ctx = switch (implName) {\n@@ -16,0 +70,12 @@\n+        \/\/ The 'internal' context from jdk.internal.crac.mirror.Core should host only the Core.Priority contexts\n+        \/\/ and the context created by jdk.crac.Core (the 'user' global context). We won't record score for\n+        \/\/ the internal context as if registered here, beforeCheckpoint would be called after Core.Priority.SCORE\n+        \/\/ and the score would not be recorded.\n+        if (name != null) {\n+            Score score = new Score(name, ctx);\n+            synchronized (scores) {\n+                scores.put(name, score);\n+            }\n+            ctx.register(score);\n+        }\n+        return ctx;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/impl\/GlobalContext.java","additions":68,"deletions":2,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+\n+    public int size() {\n+        return resources.size();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/impl\/OrderedContext.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"crlib\/crlib_image_score.h\"\n@@ -42,0 +43,1 @@\n+#include \"image_score.hpp\"\n@@ -82,0 +84,2 @@\n+static bool set_score(crlib_conf_t *, const char* name, double value);\n+\n@@ -138,0 +142,8 @@\n+static crlib_image_score_t image_score_extension {\n+  {\n+    CRLIB_EXTENSION_IMAGE_SCORE_NAME,\n+    sizeof(image_score_extension),\n+  },\n+  set_score,\n+};\n+\n@@ -141,0 +153,1 @@\n+  &image_score_extension.header,\n@@ -232,0 +245,1 @@\n+  ImageScore _image_score;\n@@ -306,0 +320,4 @@\n+  ImageScore &image_score() {\n+    return _image_score;\n+  }\n+\n@@ -615,0 +633,4 @@\n+static bool set_score(crlib_conf_t *conf, const char *name, double value) {\n+  return conf->image_score().set_score(name, value);\n+}\n+\n@@ -752,1 +774,2 @@\n-  if (conf->argv()[ARGV_IMAGE_LOCATION] == nullptr) {\n+  const char *image_location = conf->argv()[ARGV_IMAGE_LOCATION];\n+  if (image_location == nullptr) {\n@@ -762,1 +785,2 @@\n-  if (!conf->image_constraints().persist(conf->argv()[ARGV_IMAGE_LOCATION])) {\n+  if (!conf->image_constraints().persist(image_location) ||\n+      !conf->image_score().persist(image_location)) {\n@@ -765,0 +789,4 @@\n+  \/\/ We will reset scores now; scores can be retained or reset higher on the Java level.\n+  \/\/ Before another checkpoint all the scores will be recorded again; we won't keep\n+  \/\/ anything here to not write down any outdated value.\n+  conf->image_score().reset_all();\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.cpp","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,0 +39,12 @@\n+template<typename F> class deferred {\n+private:\n+  F _f;\n+public:\n+  inline deferred(F f): _f(f) {}\n+  inline ~deferred() { _f(); }\n+};\n+\n+template<typename F> deferred<F> defer(F f) {\n+  return deferred<F>(f);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-  Hashtable(const char * const keys[], size_t length);\n+  inline Hashtable(const char * const keys[], size_t num_keys): Hashtable(keys, num_keys, num_keys) {}\n+  Hashtable(const char * const keys[], size_t num_keys, size_t capacity);\n@@ -43,2 +44,0 @@\n-  size_t length() const { return _length; }\n-\n@@ -49,0 +48,2 @@\n+  template<typename F> void foreach(F func) const;\n+\n@@ -50,1 +51,1 @@\n-  size_t _length;\n+  size_t _capacity;\n@@ -68,4 +69,4 @@\n-Hashtable<T>::Hashtable(const char * const keys[], size_t length) :\n-    _length(length),\n-    _keys(new(std::nothrow) const char*[length]()),\n-    _values(new(std::nothrow) T[length]()) {\n+Hashtable<T>::Hashtable(const char * const keys[], size_t num_keys, size_t capacity) :\n+    _capacity(capacity),\n+    _keys(new(std::nothrow) const char*[capacity]()),\n+    _values(new(std::nothrow) T[capacity]()) {\n@@ -81,1 +82,1 @@\n-  for (size_t i = 0; i < length; i++) {\n+  for (size_t i = 0; i < num_keys; i++) {\n@@ -84,1 +85,1 @@\n-    const unsigned int hash = string_hash(key) % length;\n+    const unsigned int hash = string_hash(key) % capacity;\n@@ -86,1 +87,1 @@\n-    for (size_t j = hash; !place_found && j < length; j++) {\n+    for (size_t j = hash; !place_found && j < capacity; j++) {\n@@ -90,0 +91,2 @@\n+      } else if (!strcmp(key, _keys[j])) {\n+        place_found = true;\n@@ -96,0 +99,2 @@\n+      } else if (!strcmp(key, _keys[j])) {\n+        place_found = true;\n@@ -117,1 +122,1 @@\n-  if (_length == 0) {\n+  if (_capacity == 0) {\n@@ -121,2 +126,2 @@\n-  const unsigned int hash = string_hash(key) % _length;\n-  for (size_t i = hash; i < _length; i++) {\n+  const unsigned int hash = string_hash(key) % _capacity;\n+  for (size_t i = hash; i < _capacity; i++) {\n@@ -145,0 +150,10 @@\n+template<class T> template<typename F>\n+void Hashtable<T>::foreach(F func) const {\n+  for (size_t i = 0; i < _capacity; ++i) {\n+    const char *key = _keys[i];\n+    if (key != nullptr) {\n+      func(key, _values[i]);\n+    }\n+  }\n+}\n+\n","filename":"src\/java.base\/share\/native\/libcrexec\/hashtable.hpp","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <cerrno>\n+#include <cstdio>\n+#include <cstring>\n+\n+#include \"crexec.hpp\"\n+#include \"hashtable.hpp\"\n+#include \"image_score.hpp\"\n+\n+bool ImageScore::persist(const char* image_location) const {\n+  char fname[PATH_MAX];\n+  if (snprintf(fname, sizeof(fname), \"%s\/score\", image_location) >= (int) sizeof(fname) - 1) {\n+    fprintf(stderr, CREXEC \"filename too long: %s\/score\\n\", image_location);\n+    return false;\n+  }\n+  FILE* f = fopen(fname, \"w\");\n+  if (f == nullptr) {\n+    fprintf(stderr, CREXEC \"cannot open %s for writing: %s\\n\", fname, strerror(errno));\n+    return false;\n+  }\n+  auto close_f = defer([&] {\n+    if (fclose(f)) {\n+     fprintf(stderr, CREXEC \"cannot close %s\/score: %s\\n\", image_location, strerror(errno));\n+    }\n+  });\n+  \/\/ Handle duplicates\n+  bool result = true;\n+  const char **keys = new(std::nothrow) const char*[_score.size()];\n+  if (keys == nullptr) {\n+    fprintf(stderr, CREXEC \"cannot allocate array of metrics\\n\");\n+    return false;\n+  }\n+  auto delete_keys = defer([&] { delete[] keys; });\n+  size_t index = 0;\n+  _score.foreach([&](const Score& score){\n+    keys[index++] = score._name;\n+  });\n+  Hashtable<double> ht(keys, _score.size(), _score.size() * 3 \/ 2);\n+  if (!ht.is_initialized()) {\n+    fprintf(stderr, CREXEC \"cannot create score hashtable (allocation failure)\\n\");\n+    return false;\n+  }\n+  _score.foreach([&](const Score& score) {\n+    ht.put(score._name, score._value);\n+  });\n+  ht.foreach([&](const char *key, double value){\n+    fprintf(f, \"%s=%f\\n\", key, value);\n+  });\n+  return result;\n+}\n","filename":"src\/java.base\/share\/native\/libcrexec\/image_score.cpp","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef IMAGE_SCORE_HPP\n+#define IMAGE_SCORE_HPP\n+\n+#include <cstring>\n+#include <cstdlib>\n+#include <cstdint>\n+\n+#include \"crexec.hpp\"\n+#include \"crlib\/crlib_image_constraints.h\"\n+#include \"linkedlist.hpp\"\n+\n+class ImageScore {\n+private:\n+\n+  struct Score {\n+    const char* _name;\n+    double _value;\n+\n+    Score(const char* name, double value): _name(name), _value(value) {}\n+\n+    Score(Score &&o) {\n+      _name = o._name;\n+      _value = o._value;\n+      o._name = nullptr;\n+    }\n+\n+    ~Score() {\n+      free((void*) _name);\n+    }\n+  };\n+\n+  LinkedList<Score> _score;\n+\n+public:\n+  bool set_score(const char* name, double value) {\n+    const char* name_copy = strdup(name);\n+    if (name_copy == nullptr) {\n+      fprintf(stderr, CREXEC \"Cannot allocate copy of metric name\\n\");\n+      return false;\n+    }\n+    \/\/ We don't have expandable hashtable, so we'll sort out duplicates\n+    \/\/ in persist() when we have all the keys.\n+    return _score.add(Score(name_copy, value));\n+  }\n+\n+  void reset_all() {\n+    _score.clear();\n+  }\n+\n+  bool persist(const char* image_location) const;\n+};\n+\n+#endif \/\/ IMAGE_SCORE_HPP\n","filename":"src\/java.base\/share\/native\/libcrexec\/image_score.hpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -63,0 +63,4 @@\n+    clear();\n+  }\n+\n+  void clear() {\n@@ -69,0 +73,3 @@\n+    _head = nullptr;\n+    _tail = nullptr;\n+    _size = 0;\n","filename":"src\/java.base\/share\/native\/libcrexec\/linkedlist.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -51,0 +51,10 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_crac_Score_isSupported(JNIEnv *env, jclass ignore) {\n+    return JVM_IsCRaCScoreSupported(env);\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_crac_Score_record(JNIEnv *env, jclass ignore, jobjectArray metrics, jdoubleArray values) {\n+    return JVM_RecordCRaCScore(env, metrics, values);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        jdk.internal.crac.mirror.impl.GlobalContext.createGlobalContextImpl());\n+        jdk.internal.crac.mirror.impl.GlobalContext.createGlobalContextImpl(\"jdk.crac.globalContext\"));\n","filename":"src\/jdk.crac\/share\/classes\/jdk\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-            checkDateEquals(matcher1.group(6), b1);\n-            checkDateEquals(matcher2.group(6), b2);\n+            checkDateEquals(matcher1.group(6), r1);\n+            checkDateEquals(matcher2.group(6), r2);\n","filename":"test\/jdk\/jdk\/crac\/PathPatternTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Score;\n+import jdk.test.lib.crac.*;\n+\n+import java.lang.ref.Reference;\n+import java.nio.file.Files;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test\n+ * @summary Check scores written by image_score extension\n+ * @requires (os.family == \"linux\")\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @library \/test\/lib\n+ * @build ImageScoreTest\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ *\/\n+public class ImageScoreTest implements CracTest {\n+    private static final String JDK_CRAC_GLOBAL_CONTEXT_SIZE = \"jdk.crac.globalContext.size\";\n+    private static final String TEST_SCORE_AAA = \"test.score.aaa\";\n+    private static final String TEST_SCORE_BBB = \"test.score.bbb\";\n+    public static final String RESTORE1 = \"RESTORE1\";\n+    public static final String RESTORE2 = \"RESTORE2\";\n+\n+    @CracTestArg\n+    boolean usePerfData;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final CracBuilder builder = new CracBuilder().engine(CracEngine.PAUSE).captureOutput(true);\n+        builder.vmOption(\"-XX:\" + (usePerfData ? '+' : '-') + \"UsePerfData\");\n+        builder.vmOption(\"--add-opens=java.base\/jdk.internal.crac=ALL-UNNAMED\");\n+        final CracProcess process = builder.startCheckpoint();\n+        builder.clearVmOptions();\n+        process.waitForPausePid();\n+\n+        List<String> score1 = Files.readAllLines(builder.imageDir().resolve(\"score\"));\n+        assertGT(score1.size(), 10); \/\/ at least 10 items\n+        assertEquals(1L, score1.stream().filter(line -> line.startsWith(\"vm.uptime=\")).count());\n+        int context1 = getScore(score1, JDK_CRAC_GLOBAL_CONTEXT_SIZE).intValue();\n+        \/\/ overwritten value should be there only once\n+        assertEquals(1L, score1.stream().filter(line-> line.startsWith(TEST_SCORE_AAA)).count());\n+        assertEquals(123.456, getScore(score1, TEST_SCORE_AAA));\n+        assertEquals(42.0   , getScore(score1, TEST_SCORE_BBB));\n+        builder.doRestore();\n+        CompletableFuture<?> f = new CompletableFuture<>();\n+        process.watch(line -> {\n+            if (line.equals(RESTORE1)) {\n+                try {\n+                    builder.doRestore();\n+                } catch (Exception e) {\n+                    f.completeExceptionally(e);\n+                }\n+            } else if (line.equals(RESTORE2)) {\n+                f.complete(null);\n+            }\n+        }, System.err::println);\n+        assertNull(f.get());\n+\n+        List<String> score2 = Files.readAllLines(builder.imageDir().resolve(\"score\"));\n+        int context2 = getScore(score2, JDK_CRAC_GLOBAL_CONTEXT_SIZE).intValue();\n+        assertEquals(context1 + 1, context2);\n+        assertEquals(456.789, getScore(score2, TEST_SCORE_AAA));\n+        assertTrue(score2.stream().noneMatch(line -> line.startsWith(TEST_SCORE_BBB)));\n+        process.waitForSuccess();\n+    }\n+\n+    private static Double getScore(List<String> score1, String metric) {\n+        Optional<Double> contextSize = score1.stream().filter(line -> line.startsWith(metric + '='))\n+                .findFirst().map(line -> Double.parseDouble(line.substring(line.indexOf('=') + 1)));\n+        assertTrue(contextSize.isPresent());\n+        return contextSize.orElseThrow(() -> new AssertionError(\"context size not found\"));\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Score.setScore(TEST_SCORE_AAA, 0.001); \/\/ should be overwritten\n+        Score.setScore(TEST_SCORE_AAA, 123.456);\n+        Score.setScore(TEST_SCORE_BBB, 42);\n+        Core.checkpointRestore();\n+\n+        Score.resetAll();\n+        Score.setScore(TEST_SCORE_AAA, 456.789);\n+        System.out.println(RESTORE1);\n+        Resource dummy = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) {\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) {\n+            }\n+        };\n+        Core.getGlobalContext().register(dummy);\n+        Core.checkpointRestore();\n+\n+        Reference.reachabilityFence(dummy);\n+        System.out.println(RESTORE2);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/engine\/ImageScoreTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}