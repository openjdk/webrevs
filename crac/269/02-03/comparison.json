{"files":[{"patch":"@@ -37,0 +37,3 @@\n+\/\/ The metrics are NOT retained after checkpoint (succesful or not),\n+\/\/ the application is expected to set scores again before next attempt\n+\/\/ to checkpoint.\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib_image_score.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3726,1 +3726,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/oopCast.inline.hpp\"\n@@ -714,2 +715,2 @@\n-  objArrayOop metrics_oops = objArrayOop(JNIHandles::resolve_non_null(metrics));\n-  typeArrayOop values_oops = typeArrayOop(JNIHandles::resolve_non_null(values));\n+  objArrayOop metrics_oops = oop_cast<objArrayOop>(JNIHandles::resolve_non_null(metrics));\n+  typeArrayOop values_oops = oop_cast<typeArrayOop>(JNIHandles::resolve_non_null(values));\n@@ -746,1 +747,3 @@\n-  result = result && _engine->set_score(\"sun.cls.appClassLoadCount\", ClassLoader::perf_app_classload_count()->get_value());\n+  if (ClassLoader::perf_app_classload_count() != nullptr) {\n+    result = result && _engine->set_score(\"sun.cls.appClassLoadCount\", ClassLoader::perf_app_classload_count()->get_value());\n+  }\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -391,1 +391,0 @@\n-\n@@ -396,1 +395,1 @@\n-  complete_extension_api(_restore_data_api);\n+  complete_extension_api(_restore_data_api)\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,6 +87,0 @@\n-        static {\n-            \/\/ We need the global context before NORMAL is created, so GlobalContext cannot\n-            \/\/ register the resource in static constructor\n-            NORMAL.getContext().register(GlobalContext.Score.instance());\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+    private Score() {}\n+\n@@ -41,1 +43,1 @@\n-    static synchronized void record() {\n+    private static synchronized void record() {\n@@ -57,2 +59,2 @@\n-     * with the same {@code metric} overwrite previous value. If the engine does not support\n-     * recording metadata this is ignored.\n+     * with the same {@code metric} overwrite previous value. This method can be safely\n+     * called even if the C\/R engine does not support recording metadata.\n@@ -69,0 +71,4 @@\n+    \/**\n+     * Drop all currently stored metrics. This method can be safely called\n+     * even if the C\/R engine does not support recording metadata.\n+     *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Score.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    private static final Context<Resource> globalContext = GlobalContext.createGlobalContextImpl();\n+    private static final Context<Resource> globalContext = GlobalContext.createGlobalContextImpl(\"jdk.crac.internal.globalContext\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n@@ -7,0 +32,3 @@\n+import java.util.HashMap;\n+import java.util.Map;\n+\n@@ -10,0 +38,4 @@\n+    \/\/ Scores are in this map only to keep a strong reference to the resource\n+    @SuppressWarnings(\"MismatchedQueryAndUpdateOfCollection\")\n+    private static final Map<String, Score> scores = new HashMap<>();\n+\n@@ -11,1 +43,7 @@\n-        private static final Score instance = new Score();\n+        private final String name;\n+        private final OrderedContext<?> ctx;\n+\n+        private Score(String name, OrderedContext<?> ctx) {\n+            this.name = name;\n+            this.ctx = ctx;\n+        }\n@@ -15,4 +53,1 @@\n-            Context<?> ctx = jdk.internal.crac.mirror.Core.getGlobalContext();\n-            if (ctx instanceof OrderedContext<?> octx) {\n-                jdk.internal.crac.Score.setScore(\"jdk.crac.globalContext.size\", octx.size());\n-            }\n+            jdk.internal.crac.Score.setScore(name + \".size\", ctx.size());\n@@ -24,0 +59,1 @@\n+    }\n@@ -25,4 +61,1 @@\n-        public static Score instance() {\n-            return instance;\n-        }\n-    };\n+    private GlobalContext() {}\n@@ -30,1 +63,1 @@\n-    public static Context<Resource> createGlobalContextImpl() {\n+    public static Context<Resource> createGlobalContextImpl(String name) {\n@@ -32,1 +65,1 @@\n-        return switch (implName) {\n+        OrderedContext<Resource> ctx = switch (implName) {\n@@ -37,0 +70,6 @@\n+        Score score = new Score(name, ctx);\n+        synchronized (scores) {\n+            scores.put(name, score);\n+        }\n+        ctx.register(score);\n+        return ctx;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/impl\/GlobalContext.java","additions":50,"deletions":11,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -789,0 +789,4 @@\n+  \/\/ We will reset scores now; scores can be retained or reset higher on the Java level.\n+  \/\/ Before another checkpoint all the scores will be recorded again; we won't keep\n+  \/\/ anything here to not write down any outdated value.\n+  conf->image_score().reset_all();\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,12 @@\n+template<typename F> class deferred {\n+private:\n+  F _f;\n+public:\n+  inline deferred(F f): _f(f) {}\n+  inline ~deferred() { _f(); }\n+};\n+\n+template<typename F> deferred<F> defer(F f) {\n+  return deferred<F>(f);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-  Hashtable(const char * const keys[], size_t length);\n+  inline Hashtable(const char * const keys[], size_t num_keys): Hashtable(keys, num_keys, num_keys) {}\n+  Hashtable(const char * const keys[], size_t num_keys, size_t capacity);\n@@ -43,2 +44,0 @@\n-  size_t length() const { return _length; }\n-\n@@ -49,0 +48,2 @@\n+  template<typename F> void foreach(F func) const;\n+\n@@ -50,1 +51,1 @@\n-  size_t _length;\n+  size_t _capacity;\n@@ -68,4 +69,4 @@\n-Hashtable<T>::Hashtable(const char * const keys[], size_t length) :\n-    _length(length),\n-    _keys(new(std::nothrow) const char*[length]()),\n-    _values(new(std::nothrow) T[length]()) {\n+Hashtable<T>::Hashtable(const char * const keys[], size_t num_keys, size_t capacity) :\n+    _capacity(capacity),\n+    _keys(new(std::nothrow) const char*[capacity]()),\n+    _values(new(std::nothrow) T[capacity]()) {\n@@ -81,1 +82,1 @@\n-  for (size_t i = 0; i < length; i++) {\n+  for (size_t i = 0; i < num_keys; i++) {\n@@ -84,1 +85,1 @@\n-    const unsigned int hash = string_hash(key) % length;\n+    const unsigned int hash = string_hash(key) % capacity;\n@@ -86,1 +87,1 @@\n-    for (size_t j = hash; !place_found && j < length; j++) {\n+    for (size_t j = hash; !place_found && j < capacity; j++) {\n@@ -90,0 +91,2 @@\n+      } else if (!strcmp(key, _keys[j])) {\n+        place_found = true;\n@@ -96,0 +99,2 @@\n+      } else if (!strcmp(key, _keys[j])) {\n+        place_found = true;\n@@ -117,1 +122,1 @@\n-  if (_length == 0) {\n+  if (_capacity == 0) {\n@@ -121,2 +126,2 @@\n-  const unsigned int hash = string_hash(key) % _length;\n-  for (size_t i = hash; i < _length; i++) {\n+  const unsigned int hash = string_hash(key) % _capacity;\n+  for (size_t i = hash; i < _capacity; i++) {\n@@ -145,0 +150,10 @@\n+template<class T> template<typename F>\n+void Hashtable<T>::foreach(F func) const {\n+  for (size_t i = 0; i < _capacity; ++i) {\n+    const char *key = _keys[i];\n+    if (key != nullptr) {\n+      func(key, _values[i]);\n+    }\n+  }\n+}\n+\n","filename":"src\/java.base\/share\/native\/libcrexec\/hashtable.hpp","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"hashtable.hpp\"\n@@ -43,0 +44,14 @@\n+  auto close_f = defer([&] {\n+    if (fclose(f)) {\n+     fprintf(stderr, CREXEC \"cannot close %s\/score: %s\\n\", image_location, strerror(errno));\n+    }\n+  });\n+  \/\/ Handle duplicates\n+  bool result = true;\n+  const char **keys = new(std::nothrow) const char*[_score.size()];\n+  if (keys == nullptr) {\n+    fprintf(stderr, CREXEC \"cannot allocate array of metrics\\n\");\n+    return false;\n+  }\n+  auto delete_keys = defer([&] { delete[] keys; });\n+  size_t index = 0;\n@@ -44,1 +59,1 @@\n-    fprintf(f, \"%s=%f\\n\", score._name, score._value);\n+    keys[index++] = score._name;\n@@ -46,2 +61,3 @@\n-  if (fclose(f)) {\n-    fprintf(stderr, CREXEC \"cannot close %s\/score: %s\\n\", image_location, strerror(errno));\n+  Hashtable<double> ht(keys, _score.size(), _score.size() * 3 \/ 2);\n+  if (!ht.is_initialized()) {\n+    fprintf(stderr, CREXEC \"cannot create score hashtable (allocation failure)\\n\");\n@@ -50,1 +66,7 @@\n-  return true;\n+  _score.foreach([&](const Score& score) {\n+    ht.put(score._name, score._value);\n+  });\n+  ht.foreach([&](const char *key, double value){\n+    fprintf(f, \"%s=%f\\n\", key, value);\n+  });\n+  return result;\n","filename":"src\/java.base\/share\/native\/libcrexec\/image_score.cpp","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"crexec.hpp\"\n@@ -61,0 +62,1 @@\n+      fprintf(stderr, CREXEC \"Cannot allocate copy of metric name\\n\");\n@@ -63,0 +65,2 @@\n+    \/\/ We don't have expandable hashtable, so we'll sort out duplicates\n+    \/\/ in persist() when we have all the keys.\n@@ -66,0 +70,4 @@\n+  void reset_all() {\n+    _score.clear();\n+  }\n+\n","filename":"src\/java.base\/share\/native\/libcrexec\/image_score.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+    clear();\n+  }\n+\n+  void clear() {\n@@ -69,0 +73,3 @@\n+    _head = nullptr;\n+    _tail = nullptr;\n+    _size = 0;\n","filename":"src\/java.base\/share\/native\/libcrexec\/linkedlist.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        jdk.internal.crac.mirror.impl.GlobalContext.createGlobalContextImpl());\n+        jdk.internal.crac.mirror.impl.GlobalContext.createGlobalContextImpl(\"jdk.crac.globalContext\"));\n","filename":"src\/jdk.crac\/share\/classes\/jdk\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Score;\n+import jdk.test.lib.crac.*;\n+\n+import java.lang.ref.Reference;\n+import java.nio.file.Files;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test\n+ * @summary Check scores written by image_score extension\n+ * @requires (os.family == \"linux\")\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @library \/test\/lib\n+ * @build ImageScoreTest\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ *\/\n+public class ImageScoreTest implements CracTest {\n+    private static final String JDK_CRAC_GLOBAL_CONTEXT_SIZE = \"jdk.crac.globalContext.size\";\n+    private static final String TEST_SCORE_AAA = \"test.score.aaa\";\n+    private static final String TEST_SCORE_BBB = \"test.score.bbb\";\n+    public static final String RESTORE1 = \"RESTORE1\";\n+    public static final String RESTORE2 = \"RESTORE2\";\n+\n+    @CracTestArg\n+    boolean usePerfData;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final CracBuilder builder = new CracBuilder().engine(CracEngine.PAUSE).captureOutput(true);\n+        builder.vmOption(\"-XX:\" + (usePerfData ? '+' : '-') + \"UsePerfData\");\n+        builder.vmOption(\"--add-opens=java.base\/jdk.internal.crac=ALL-UNNAMED\");\n+        final CracProcess process = builder.startCheckpoint();\n+        builder.clearVmOptions();\n+        process.waitForPausePid();\n+\n+        List<String> score1 = Files.readAllLines(builder.imageDir().resolve(\"score\"));\n+        assertGT(score1.size(), 10); \/\/ at least 10 items\n+        assertEquals(1L, score1.stream().filter(line -> line.startsWith(\"vm.uptime=\")).count());\n+        int context1 = getScore(score1, JDK_CRAC_GLOBAL_CONTEXT_SIZE).intValue();\n+        \/\/ overwritten value should be there only once\n+        assertEquals(1L, score1.stream().filter(line-> line.startsWith(TEST_SCORE_AAA)).count());\n+        assertEquals(123.456, getScore(score1, TEST_SCORE_AAA));\n+        assertEquals(42.0   , getScore(score1, TEST_SCORE_BBB));\n+        builder.doRestore();\n+        CompletableFuture<?> f = new CompletableFuture<>();\n+        process.watch(line -> {\n+            if (line.equals(RESTORE1)) {\n+                try {\n+                    builder.doRestore();\n+                } catch (Exception e) {\n+                    f.completeExceptionally(e);\n+                }\n+            } else if (line.equals(RESTORE2)) {\n+                f.complete(null);\n+            }\n+        }, System.err::println);\n+        assertNull(f.get());\n+\n+        List<String> score2 = Files.readAllLines(builder.imageDir().resolve(\"score\"));\n+        int context2 = getScore(score2, JDK_CRAC_GLOBAL_CONTEXT_SIZE).intValue();\n+        assertEquals(context1 + 1, context2);\n+        assertEquals(456.789, getScore(score2, TEST_SCORE_AAA));\n+        assertTrue(score2.stream().noneMatch(line -> line.startsWith(TEST_SCORE_BBB)));\n+        process.waitForSuccess();\n+    }\n+\n+    private static Double getScore(List<String> score1, String metric) {\n+        Optional<Double> contextSize = score1.stream().filter(line -> line.startsWith(metric + '='))\n+                .findFirst().map(line -> Double.parseDouble(line.substring(line.indexOf('=') + 1)));\n+        assertTrue(contextSize.isPresent());\n+        return contextSize.orElseThrow(() -> new AssertionError(\"context size not found\"));\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Score.setScore(TEST_SCORE_AAA, 0.001); \/\/ should be overwritten\n+        Score.setScore(TEST_SCORE_AAA, 123.456);\n+        Score.setScore(TEST_SCORE_BBB, 42);\n+        Core.checkpointRestore();\n+\n+        Score.resetAll();\n+        Score.setScore(TEST_SCORE_AAA, 456.789);\n+        System.out.println(RESTORE1);\n+        Resource dummy = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) {\n+                System.err.println(\"BEFORE\");\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) {\n+            }\n+        };\n+        Core.getGlobalContext().register(dummy);\n+        Core.checkpointRestore();\n+\n+        Reference.reachabilityFence(dummy);\n+        System.out.println(RESTORE2);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/engine\/ImageScoreTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}