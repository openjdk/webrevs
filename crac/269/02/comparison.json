{"files":[{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CRLIB_IMAGE_SCORE_H\n+#define CRLIB_IMAGE_SCORE_H\n+\n+#include \"crlib.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define CRLIB_EXTENSION_IMAGE_SCORE_NAME \"image score\"\n+#define CRLIB_EXTENSION_IMAGE_SCORE(api) \\\n+  CRLIB_EXTENSION(api, crlib_image_score_t, CRLIB_EXTENSION_IMAGE_SCORE_NAME)\n+\n+\/\/ API for quantifying image performance. This is a write-only API.\n+typedef const struct crlib_image_score {\n+  crlib_extension_t header;\n+  \/\/ Invoked before checkpoint. When invoked with the same metric name\n+  \/\/ multiple times the older value is overwritten.\n+  \/\/ Returns false if the score cannot be recorded, true on success.\n+  \/\/ The score is persisted during checkpoint (not in this function).\n+  bool (*set_score)(crlib_conf_t *conf, const char *metric, double value);\n+} crlib_image_score_t;\n+\n+#ifdef __cplusplus\n+} \/\/ extern \"C\"\n+#endif\n+\n+#endif \/\/ CRLIB_IMAGE_SCORE_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib_image_score.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -1196,0 +1196,6 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsCRaCScoreSupported(JNIEnv *env);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_RecordCRaCScore(JNIEnv *env, jobjectArray metrics, jdoubleArray values);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3718,0 +3718,9 @@\n+JVM_ENTRY(jboolean, JVM_IsCRaCScoreSupported(JNIEnv *env))\n+  return crac::is_image_score_supported();\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_RecordCRaCScore(JNIEnv *env, jobjectArray metrics, jdoubleArray values))\n+  return crac::record_image_score(metrics, values);\n+JVM_END\n+\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"compiler\/compileBroker.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"services\/classLoadingService.hpp\"\n@@ -163,1 +165,1 @@\n-  return os::javaTimeMillis() - 1000 * (os::elapsed_counter() \/ os::elapsed_frequency());\n+  return os::javaTimeMillis() - (1000 * os::elapsed_counter() \/ os::elapsed_frequency());\n@@ -702,0 +704,58 @@\n+bool crac::is_image_score_supported() {\n+  return _engine->prepare_image_score_api() == CracEngine::ApiStatus::OK;\n+}\n+\n+bool crac::record_image_score(jobjectArray metrics, jdoubleArray values) {\n+  if (_engine->prepare_image_score_api() != CracEngine::ApiStatus::OK) {\n+    \/\/ silently ignoring this\n+    return true;\n+  }\n+  ResourceMark rm;\n+  objArrayOop metrics_oops = objArrayOop(JNIHandles::resolve_non_null(metrics));\n+  typeArrayOop values_oops = typeArrayOop(JNIHandles::resolve_non_null(values));\n+  assert(metrics_oops->length() == values_oops->length(), \"should be equal\");\n+  for (int i = 0; i < metrics_oops->length(); ++i) {\n+    oop metric_oop = metrics_oops->obj_at(i);\n+    assert(metric_oop != nullptr, \"not null\");\n+    const char* metric = java_lang_String::as_utf8_string(metric_oop);\n+    double value = values_oops->double_at(i);\n+    if (!_engine->set_score(metric, value)) {\n+      return false;\n+    }\n+  }\n+\n+  bool result = true;\n+  result = result && _engine->set_score(\"java.lang.Runtime.availableProcessors\", os::active_processor_count());\n+  result = result && _engine->set_score(\"java.lang.Runtime.totalMemory\", Universe::heap()->capacity());\n+  result = result && _engine->set_score(\"java.lang.Runtime.maxMemory\", Universe::heap()->max_capacity());\n+\n+  double uptime = TimeHelper::counter_to_millis(os::elapsed_counter());\n+  result = result && _engine->set_score(\"vm.boot_time\", os::javaTimeMillis() - uptime);\n+  result = result && _engine->set_score(\"vm.uptime\", uptime);\n+  result = result && _engine->set_score(\"vm.uptime_since_restore\", TimeHelper::counter_to_millis(os::elapsed_counter_since_restore()));\n+\n+#if INCLUDE_MANAGEMENT\n+  jlong shared_loaded_classes = ClassLoadingService::loaded_shared_class_count();\n+  jlong shared_unloaded_classes = ClassLoadingService::unloaded_shared_class_count();\n+  \/\/ The keys match what jcmd <pid> PerfCounter.print would use\n+  result = result && _engine->set_score(\"java.cls.loadedClasses\", ClassLoadingService::loaded_class_count() - shared_loaded_classes);\n+  result = result && _engine->set_score(\"java.cls.sharedLoadedClasses\", shared_loaded_classes);\n+  result = result && _engine->set_score(\"java.cls.unloadedClasses\", ClassLoadingService::unloaded_class_count() - shared_unloaded_classes);\n+  result = result && _engine->set_score(\"java.cls.sharedUnloadedClasses\", shared_unloaded_classes);\n+#endif \/\/ INCLUDE_MANAGEMENT\n+  result = result && _engine->set_score(\"sun.cls.appClassLoadCount\", ClassLoader::perf_app_classload_count()->get_value());\n+\n+  result = result && _engine->set_score(\"sun.ci.totalCompiles\", CompileBroker::get_total_compile_count());\n+  result = result && _engine->set_score(\"sun.ci.totalBailouts\", CompileBroker::get_total_bailout_count());\n+  result = result && _engine->set_score(\"sun.ci.totalInvalidates\", CompileBroker::get_total_invalidated_count());\n+  \/\/ CompileBroker::get_total_native_compile_count() is never incremented?\n+  result = result && _engine->set_score(\"sun.ci.osrCompiles\", CompileBroker::get_total_osr_compile_count());\n+  result = result && _engine->set_score(\"sun.ci.standardCompiles\", CompileBroker::get_total_standard_compile_count());\n+  result = result && _engine->set_score(\"sun.ci.osrBytes\", CompileBroker::get_sum_osr_bytes_compiled());\n+  result = result && _engine->set_score(\"sun.ci.standardBytes\", CompileBroker::get_sum_standard_bytes_compiled());\n+  result = result && _engine->set_score(\"sun.ci.nmethodSize\", CompileBroker::get_sum_nmethod_size());\n+  result = result && _engine->set_score(\"sun.ci.nmethodCodeSize\", CompileBroker::get_sum_nmethod_code_size());\n+  result = result && _engine->set_score(\"java.ci.totalTime\", CompileBroker::get_total_compilation_time());\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+  static bool is_image_score_supported();\n+  static bool record_image_score(jobjectArray metrics, jdoubleArray values);\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -369,16 +369,20 @@\n-CracEngine::ApiStatus CracEngine::prepare_restore_data_api() {\n-  precond(is_initialized());\n-  if (_restore_data_api != nullptr) {\n-    return ApiStatus::OK;\n-  }\n-\n-  crlib_restore_data_t * const restore_data_api = CRLIB_EXTENSION_RESTORE_DATA(_api);\n-  if (restore_data_api == nullptr) {\n-    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n-    return ApiStatus::UNSUPPORTED;\n-  }\n-  if (restore_data_api->set_restore_data == nullptr || restore_data_api->get_restore_data == nullptr) {\n-    log_error(crac)(\"CRaC engine provided invalid API for extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n-    return ApiStatus::ERR;\n-  }\n-  _restore_data_api = restore_data_api;\n+#define prepare_extension_api(_ext_api, ext_name) \\\n+  precond(is_initialized()); \\\n+  if (_ext_api != nullptr) { \\\n+    return ApiStatus::OK; \\\n+  } \\\n+  auto const ext_api = CRLIB_EXTENSION(_api, std::remove_reference<decltype(*_ext_api)>::type, ext_name); \\\n+  if (ext_api == nullptr) { \\\n+    log_debug(crac)(\"CRaC engine does not support extension \" ext_name); \\\n+    return ApiStatus::UNSUPPORTED; \\\n+  } \\\n+  constexpr const char *_ext_name = ext_name;\n+\n+#define require_method(_func) \\\n+  if (ext_api->_func == nullptr) { \\\n+    log_error(crac)(\"CRaC engine provided invalid API for extension %s: %s is not set\", _ext_name, #_func); \\\n+    return ApiStatus::ERR; \\\n+  }\n+\n+#define complete_extension_api(_ext_api) \\\n+  _ext_api = ext_api; \\\n@@ -386,0 +390,7 @@\n+\n+\n+CracEngine::ApiStatus CracEngine::prepare_restore_data_api() {\n+  prepare_extension_api(_restore_data_api, CRLIB_EXTENSION_RESTORE_DATA_NAME)\n+  require_method(set_restore_data)\n+  require_method(get_restore_data)\n+  complete_extension_api(_restore_data_api);\n@@ -399,19 +410,7 @@\n-  precond(is_initialized());\n-  if (_description_api != nullptr) {\n-    return ApiStatus::OK;\n-  }\n-\n-  crlib_description_t * const description_api = CRLIB_EXTENSION_DESCRIPTION(_api);\n-  if (description_api == nullptr) {\n-    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_DESCRIPTION_NAME);\n-    return ApiStatus::UNSUPPORTED;\n-  }\n-  if (description_api->identity == nullptr || description_api->description == nullptr ||\n-      description_api->configuration_doc == nullptr ||\n-      description_api->configurable_keys == nullptr ||\n-      description_api->supported_extensions == nullptr) {\n-    log_error(crac)(\"CRaC engine provided invalid API for extension: \" CRLIB_EXTENSION_DESCRIPTION_NAME);\n-    return ApiStatus::ERR;\n-  }\n-  _description_api = description_api;\n-  return ApiStatus::OK;\n+  prepare_extension_api(_description_api, CRLIB_EXTENSION_DESCRIPTION_NAME)\n+  require_method(identity)\n+  require_method(description)\n+  require_method(configuration_doc)\n+  require_method(configurable_keys)\n+  require_method(supported_extensions)\n+  complete_extension_api(_description_api)\n@@ -434,17 +433,7 @@\n-  precond(is_initialized());\n-  if (_image_constraints_api != nullptr) {\n-    return ApiStatus::OK;\n-  }\n-\n-  crlib_image_constraints_t * const ic_api = CRLIB_EXTENSION_IMAGE_CONSTRAINTS(_api);\n-  if (ic_api == nullptr) {\n-    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_IMAGE_CONSTRAINTS_NAME);\n-    return ApiStatus::UNSUPPORTED;\n-  }\n-  if (ic_api->set_label == nullptr || ic_api->set_bitmap == nullptr\n-      || ic_api->require_label == nullptr || ic_api->require_bitmap == nullptr) {\n-    log_error(crac)(\"CRaC engine provided invalid API for extension: \" CRLIB_EXTENSION_IMAGE_CONSTRAINTS_NAME);\n-    return ApiStatus::ERR;\n-  }\n-  _image_constraints_api = ic_api;\n-  return ApiStatus::OK;\n+  prepare_extension_api(_image_constraints_api, CRLIB_EXTENSION_IMAGE_CONSTRAINTS_NAME)\n+  require_method(set_label)\n+  require_method(set_bitmap)\n+  require_method(require_label)\n+  require_method(require_bitmap)\n+  require_method(is_failed)\n+  complete_extension_api(_image_constraints_api)\n@@ -487,0 +476,10 @@\n+\n+CracEngine::ApiStatus CracEngine::prepare_image_score_api() {\n+  prepare_extension_api(_image_score_api, CRLIB_EXTENSION_IMAGE_SCORE_NAME)\n+  require_method(set_score)\n+  complete_extension_api(_image_score_api)\n+}\n+\n+bool CracEngine::set_score(const char* metric, double value) {\n+  return _image_score_api->set_score(_conf, metric, value);\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":51,"deletions":52,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"crlib\/crlib_image_score.h\"\n@@ -74,0 +75,3 @@\n+  ApiStatus prepare_image_score_api();\n+  bool set_score(const char* metric, double value);\n+\n@@ -82,0 +86,1 @@\n+  crlib_image_score_t *_image_score_api = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.crac.mirror.impl.GlobalContext;\n@@ -70,0 +71,2 @@\n+        \/\/ Other resources can record score in the beforeCheckpoint\n+        SCORE(Score.getContext()),\n@@ -84,0 +87,6 @@\n+        static {\n+            \/\/ We need the global context before NORMAL is created, so GlobalContext cannot\n+            \/\/ register the resource in static constructor\n+            NORMAL.getContext().register(GlobalContext.Score.instance());\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+package jdk.internal.crac;\n+\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * CRaC Engine can support storing additional metadata about the image.\n+ * This can help the infrastructure to further refine the set of feasible images\n+ * (constrained by CPU architecture and features) and select the image that is expected to perform best.\n+ *\/\n+public class Score {\n+    private static final Map<String, Double> score = new HashMap<>();\n+\n+    \/\/ There shouldn't be anyone else to register at Core.Priority.SCORE.\n+    \/\/ We need to class-load this class every time, to store common metrics.\n+    private static final Context<JDKResource> resource = new Context<>() {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            if (isSupported()) {\n+                record();\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+\n+        @Override\n+        public void register(JDKResource resource) {\n+            throw new UnsupportedOperationException(\"Score is a singleton resource\");\n+        }\n+    };\n+\n+    public static native boolean isSupported();\n+\n+    private static native boolean record(String[] metrics, double[] values);\n+\n+    static synchronized void record() {\n+        String[] metrics = new String[score.size()];\n+        double[] values = new double[score.size()];\n+        int i = 0;\n+        for (var e : score.entrySet()) {\n+            metrics[i] = e.getKey();\n+            values[i] = e.getValue();\n+            ++i;\n+        }\n+        if (!record(metrics, values)) {\n+            throw new RuntimeException(\"Cannot record image score\");\n+        }\n+    }\n+\n+    \/**\n+     * Record value to be stored in the image metadata on checkpoint. Repeated invocations\n+     * with the same {@code metric} overwrite previous value. If the engine does not support\n+     * recording metadata this is ignored.\n+     * On checkpoint the metrics are not reset; if that is desired invoke {@link #resetAll()}\n+     * manually.\n+     *\n+     * @param metric Name of the metric.\n+     * @param value Numeric value of the metric.\n+     *\/\n+    public static synchronized void setScore(String metric, double value) {\n+        score.put(metric, value);\n+    }\n+\n+    public static synchronized void resetAll() {\n+        score.clear();\n+    }\n+\n+    static Context<JDKResource> getContext() {\n+        return resource;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Score.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+import jdk.internal.crac.JDKResource;\n@@ -9,0 +10,20 @@\n+    public static class Score implements JDKResource {\n+        private static final Score instance = new Score();\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            Context<?> ctx = jdk.internal.crac.mirror.Core.getGlobalContext();\n+            if (ctx instanceof OrderedContext<?> octx) {\n+                jdk.internal.crac.Score.setScore(\"jdk.crac.globalContext.size\", octx.size());\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+\n+        public static Score instance() {\n+            return instance;\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/impl\/GlobalContext.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+\n+    public int size() {\n+        return resources.size();\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/impl\/OrderedContext.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"crlib\/crlib_image_score.h\"\n@@ -42,0 +43,1 @@\n+#include \"image_score.hpp\"\n@@ -82,0 +84,2 @@\n+static bool set_score(crlib_conf_t *, const char* name, double value);\n+\n@@ -138,0 +142,8 @@\n+static crlib_image_score_t image_score_extension {\n+  {\n+    CRLIB_EXTENSION_IMAGE_SCORE_NAME,\n+    sizeof(image_score_extension),\n+  },\n+  set_score,\n+};\n+\n@@ -141,0 +153,1 @@\n+  &image_score_extension.header,\n@@ -232,0 +245,1 @@\n+  ImageScore _image_score;\n@@ -306,0 +320,4 @@\n+  ImageScore &image_score() {\n+    return _image_score;\n+  }\n+\n@@ -615,0 +633,4 @@\n+static bool set_score(crlib_conf_t *conf, const char *name, double value) {\n+  return conf->image_score().set_score(name, value);\n+}\n+\n@@ -752,1 +774,2 @@\n-  if (conf->argv()[ARGV_IMAGE_LOCATION] == nullptr) {\n+  const char *image_location = conf->argv()[ARGV_IMAGE_LOCATION];\n+  if (image_location == nullptr) {\n@@ -762,1 +785,2 @@\n-  if (!conf->image_constraints().persist(conf->argv()[ARGV_IMAGE_LOCATION])) {\n+  if (!conf->image_constraints().persist(image_location) ||\n+      !conf->image_score().persist(image_location)) {\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <cerrno>\n+#include <cstdio>\n+#include <cstring>\n+\n+#include \"crexec.hpp\"\n+#include \"image_score.hpp\"\n+\n+bool ImageScore::persist(const char* image_location) const {\n+  char fname[PATH_MAX];\n+  if (snprintf(fname, sizeof(fname), \"%s\/score\", image_location) >= (int) sizeof(fname) - 1) {\n+    fprintf(stderr, CREXEC \"filename too long: %s\/score\\n\", image_location);\n+    return false;\n+  }\n+  FILE* f = fopen(fname, \"w\");\n+  if (f == nullptr) {\n+    fprintf(stderr, CREXEC \"cannot open %s for writing: %s\\n\", fname, strerror(errno));\n+    return false;\n+  }\n+  _score.foreach([&](const Score& score){\n+    fprintf(f, \"%s=%f\\n\", score._name, score._value);\n+  });\n+  if (fclose(f)) {\n+    fprintf(stderr, CREXEC \"cannot close %s\/score: %s\\n\", image_location, strerror(errno));\n+    return false;\n+  }\n+  return true;\n+}\n","filename":"src\/java.base\/share\/native\/libcrexec\/image_score.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef IMAGE_SCORE_HPP\n+#define IMAGE_SCORE_HPP\n+\n+#include <cstring>\n+#include <cstdlib>\n+#include <cstdint>\n+\n+#include \"crlib\/crlib_image_constraints.h\"\n+#include \"linkedlist.hpp\"\n+\n+class ImageScore {\n+private:\n+\n+  struct Score {\n+    const char* _name;\n+    double _value;\n+\n+    Score(const char* name, double value): _name(name), _value(value) {}\n+\n+    Score(Score &&o) {\n+      _name = o._name;\n+      _value = o._value;\n+      o._name = nullptr;\n+    }\n+\n+    ~Score() {\n+      free((void*) _name);\n+    }\n+  };\n+\n+  LinkedList<Score> _score;\n+\n+public:\n+  bool set_score(const char* name, double value) {\n+    const char* name_copy = strdup(name);\n+    if (name_copy == nullptr) {\n+      return false;\n+    }\n+    return _score.add(Score(name_copy, value));\n+  }\n+\n+  bool persist(const char* image_location) const;\n+};\n+\n+#endif \/\/ IMAGE_SCORE_HPP\n","filename":"src\/java.base\/share\/native\/libcrexec\/image_score.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -51,0 +51,10 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_crac_Score_isSupported(JNIEnv *env, jclass ignore) {\n+    return JVM_IsCRaCScoreSupported(env);\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_crac_Score_record(JNIEnv *env, jclass ignore, jobjectArray metrics, jdoubleArray values) {\n+    return JVM_RecordCRaCScore(env, metrics, values);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-            checkDateEquals(matcher1.group(6), b1);\n-            checkDateEquals(matcher2.group(6), b2);\n+            checkDateEquals(matcher1.group(6), r1);\n+            checkDateEquals(matcher2.group(6), r2);\n","filename":"test\/jdk\/jdk\/crac\/PathPatternTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}