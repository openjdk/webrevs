{"files":[{"patch":"@@ -35,0 +35,2 @@\n+import jdk.internal.crac.mirror.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.mirror.impl.CheckpointOpenSocketException;\n@@ -38,1 +40,2 @@\n-import java.nio.channels.IllegalSelectorException;\n+import java.io.Serial;\n+import java.nio.channels.SelectableChannel;\n@@ -42,4 +45,1 @@\n-import java.util.ArrayDeque;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.*;\n@@ -48,0 +48,1 @@\n+import java.util.stream.Collectors;\n@@ -114,0 +115,1 @@\n+    private Set<SelectableChannel> currentChannels;\n@@ -160,0 +162,1 @@\n+                currentChannels = fdToKey.values().stream().map(SelectionKey::channel).collect(Collectors.toSet());\n@@ -428,1 +431,6 @@\n-                throw new IllegalSelectorException();\n+                JavaIOFileDescriptorAccess access = SharedSecrets.getJavaIOFileDescriptorAccess();\n+                var ex = new BusySelectorException(\"Selector \" + this + \" has registered keys from channels: \" + currentChannels, null);\n+                ex.epollFds.add(claimFd(access, this.epfd, \"EPoll FD \"));\n+                ex.epollFds.add(claimFd(access, this.eventfd.efd(), \"EPoll Event FD \"));\n+                currentChannels = null;\n+                throw ex;\n@@ -433,0 +441,8 @@\n+    private FileDescriptor claimFd(JavaIOFileDescriptorAccess access, int fdval, String type) {\n+        FileDescriptor fd = new FileDescriptor();\n+        access.set(fd, fdval);\n+        Core.getClaimedFDs().claimFd(fd, this,\n+                () -> new CheckpointOpenSocketException(type + fdval + \" left open in \" + this + \" with registered keys.\", null));\n+        return fd;\n+    }\n+\n@@ -450,0 +466,13 @@\n+\n+    private static class BusySelectorException extends CheckpointOpenResourceException {\n+        @Serial\n+        private static final long serialVersionUID = 5615481252774343456L;\n+        \/\/ We need to keep the FileDescriptors around until the checkpoint completes\n+        \/\/ as ClaimedFDs use WeakHashMap. Transient because exception is serializable\n+        \/\/ and FileDescriptor is not.\n+        transient List<FileDescriptor> epollFds = new ArrayList<>();\n+\n+        public BusySelectorException(String details, Throwable cause) {\n+            super(details, cause);\n+        }\n+    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+        SOCKETS(new BlockingOrderedContext<>()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-    @SuppressWarnings(\"this-escape\")\n@@ -32,0 +31,5 @@\n+        this(Core.Priority.FILE_DESCRIPTORS);\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public JDKFdResource(Core.Priority priority) {\n@@ -40,1 +44,1 @@\n-        Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+        priority.getContext().register(this);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFdResource.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+        super(Core.Priority.SOCKETS);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResourceBase.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build SocketWithSelectorTest\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ *\/\n+public class SocketWithSelectorTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg\n+    boolean closeSocket;\n+\n+    @Override\n+    public void test() throws Exception {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+        Path config = writeConfig(\"\"\"\n+                type: SOCKET\n+                family: ip\n+                localAddress: $loopback\n+                action: close\n+                \"\"\".replace(\"$loopback\", loopback));\n+        try {\n+            CracBuilder builder = new CracBuilder();\n+            if (closeSocket) {\n+                builder.javaOption(OpenResourcePolicies.PROPERTY, config.toString());\n+            }\n+            CracProcess checkpointed = builder.startCheckpoint();\n+            if (closeSocket) {\n+                checkpointed.waitForCheckpointed();\n+                builder.doRestore();\n+            } else {\n+                \/\/ the checkpoint is supposed to fail\n+                checkpointed.waitForSuccess();\n+            }\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Selector selector = Selector.open();\n+        ServerSocketChannel serverChannel = ServerSocketChannel.open()\n+                .bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        serverChannel.configureBlocking(false);\n+        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n+        try {\n+            Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            assertEquals(1L, Arrays.stream(e.getSuppressed()).filter(e2 -> e2.getMessage().contains(\"has registered keys from channels\")).count());\n+            assertEquals(2L, Arrays.stream(e.getSuppressed()).filter(e2 -> e2.getMessage().contains(\"with registered keys\")).count());\n+            assertEquals(1L, Arrays.stream(e.getSuppressed()).filter(e2 -> e2.getClass().getSimpleName().equals(\"CheckpointOpenSocketException\"))\n+                    .filter(e2 -> e2.getMessage().contains(\"ServerSocketChannelImpl\")).count());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/SocketWithSelectorTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"}]}