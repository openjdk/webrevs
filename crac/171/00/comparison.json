{"files":[{"patch":"@@ -230,0 +230,8 @@\n+        \/\/ The agent should be started only after all Resources are restored so that it finds\n+        \/\/ the system in consistent state and is free to register more Resources (e.g. because\n+        \/\/ it may open configuration file for JMX).\n+        if (newProperties != null && Arrays.stream(newProperties).anyMatch(prop -> prop.startsWith(\"com.sun.management\")) ||\n+                System.getProperties().keySet().stream().anyMatch(prop -> prop.toString().startsWith(\"com.sun.management\"))) {\n+            tryStartManagementAgent();\n+        }\n+\n@@ -323,0 +331,13 @@\n+\n+    private static void tryStartManagementAgent() {\n+        try {\n+            Class<?> agentClass = Class.forName(\"jdk.internal.agent.Agent\");\n+            Method startAgent = agentClass.getMethod(\"startAgent\");\n+            startAgent.setAccessible(true);\n+            startAgent.invoke(null);\n+        } catch (ClassNotFoundException | NoSuchMethodException e) {\n+            LoggerContainer.error(e, \"Cannot find JMX agent start method\");\n+        } catch (InvocationTargetException | IllegalAccessException e) {\n+            LoggerContainer.error(e, \"Cannot start JMX agent\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -179,0 +179,2 @@\n+        java.rmi,\n+        jdk.management.agent,\n@@ -427,1 +429,3 @@\n-        jdk.crac;\n+        java.rmi,\n+        jdk.crac,\n+        jdk.management.agent;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -288,1 +293,1 @@\n-        if (exportCount == 0 && getEndpoint().getListenPort() != 0) {\n+        if (exportCount == 0) {\n@@ -653,1 +658,1 @@\n-    private class ConnectionHandler implements Runnable {\n+    private class ConnectionHandler implements Runnable, JDKResource {\n@@ -676,0 +681,1 @@\n+            Core.Priority.NORMAL.getContext().register(this);\n@@ -867,0 +873,10 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            closeSocket(socket);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            \/\/ noop, the connection is not reopened\n+        }\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPTransport.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -55,0 +55,5 @@\n+\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -260,0 +265,1 @@\n+    private static JMXConnectorServer localServer = null;\n@@ -262,0 +268,1 @@\n+    private static JDKResource cracResource;\n@@ -318,2 +325,2 @@\n-            JMXConnectorServer cs = ConnectorBootstrap.startLocalConnectorServer();\n-            String address = cs.getAddress().toString();\n+            localServer = ConnectorBootstrap.startLocalConnectorServer();\n+            String address = localServer.getAddress().toString();\n@@ -334,0 +341,14 @@\n+    private static synchronized void stopLocalManagementAgent() throws IOException {\n+        Properties agentProps = VMSupport.getAgentProperties();\n+        agentProps.remove(LOCAL_CONNECTOR_ADDRESS_PROP);\n+        try {\n+            localServer.stop();\n+            localServer = null;\n+        } catch (IOException e) {\n+            warning(CONNECTOR_SERVER_IO_ERROR, e.getMessage());\n+            \/\/ rethrowing to fail the checkpoint\n+            throw e;\n+        }\n+        ConnectorAddressLink.unexportLocal();\n+    }\n+\n@@ -445,1 +466,1 @@\n-                if (jmxremotePort != null) {\n+                if (jmxremotePort != null && jmxServer == null) {\n@@ -452,0 +473,17 @@\n+            if (cracResource == null) {\n+                cracResource = new JDKResource() {\n+                    @Override\n+                    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                        stopRemoteManagementAgent();\n+                        stopLocalManagementAgent();\n+                        \/\/ reload properties after restore\n+                        mgmtProps = null;\n+                    }\n+\n+                    @Override\n+                    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                        startAgent();\n+                    }\n+                };\n+                Core.Priority.NORMAL.getContext().register(cracResource);\n+            }\n","filename":"src\/jdk.management.agent\/share\/classes\/jdk\/internal\/agent\/Agent.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,4 +31,2 @@\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n@@ -63,0 +61,10 @@\n+\n+        private void putString(String str) {\n+            byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n+            if (bytes.length + 1 > bb.capacity()) {\n+                throw new IllegalArgumentException(\"Address is too long\");\n+            }\n+            bb.clear();\n+            bb.put(0, bytes, 0, bytes.length);\n+            bb.put(bytes.length, (byte) 0);\n+        }\n@@ -102,0 +110,1 @@\n+    private static PerfHandle localPerfHandle = null;\n@@ -114,3 +123,12 @@\n-        Perf perf = Perf.getPerf();\n-        perf.createString(\n-            CONNECTOR_ADDRESS_COUNTER, 1, Units.STRING.intValue(), address);\n+        if (localPerfHandle == null) {\n+            Perf perf = Perf.getPerf();\n+            byte[] addressBytes = address.getBytes(StandardCharsets.UTF_8);\n+            \/\/ These 2kB is a magic constant - should we make it tunable via system property?\n+            byte[] bytes = new byte[Math.max(addressBytes.length + 1, 2048)];\n+            System.arraycopy(addressBytes, 0, bytes, 0, addressBytes.length);\n+            Arrays.fill(bytes, addressBytes.length, bytes.length, (byte) 0);\n+            localPerfHandle = new PerfHandle(perf.createString(\n+                    CONNECTOR_ADDRESS_COUNTER, 3, Units.STRING.intValue(), address));\n+        } else {\n+            localPerfHandle.putString(address);\n+        }\n@@ -123,0 +141,4 @@\n+    public static void unexportLocal() {\n+        localPerfHandle.putString(\"\");\n+    }\n+\n","filename":"src\/jdk.management.agent\/share\/classes\/jdk\/internal\/agent\/ConnectorAddressLink.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.management.*;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMX;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+import javax.management.remote.JMXConnector;\n+import javax.management.remote.JMXConnectorFactory;\n+import javax.management.remote.JMXServiceURL;\n+import java.io.IOException;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build RemoteJmxTest\n+ * @run driver jdk.test.lib.crac.CracTest 9995 none\n+ * @run driver jdk.test.lib.crac.CracTest 9995 10095\n+ * @run driver jdk.test.lib.crac.CracTest none 10095\n+ *\/\n+public class RemoteJmxTest implements CracTest {\n+    private static final String BOOTED = \"BOOTED\";\n+    private static final String RESTORED = \"RESTORED\";\n+    public static final String NONE = \"none\";\n+\n+    @CracTestArg(0)\n+    String portBefore;\n+\n+    @CracTestArg(1)\n+    String portAfter;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().captureOutput(true);\n+        builder.engine(CracEngine.SIMULATE);\n+        if (!NONE.equals(portBefore)) {\n+            javaOptions(portBefore).forEach(builder::javaOption);\n+        }\n+        CracProcess process = builder.startCheckpoint();\n+        try {\n+            var reader = new BufferedReader(new InputStreamReader(process.output()));\n+            waitForString(reader, BOOTED);\n+            if (!NONE.equals(portBefore)) {\n+                assertEquals(-1L, getUptimeFromRestoreFromJmx(portBefore));\n+            }\n+            process.sendNewline();\n+            waitForString(reader, RESTORED);\n+            String currentPort = NONE.equals(portAfter) ? portBefore : portAfter;\n+            assertGreaterThanOrEqual(getUptimeFromRestoreFromJmx(currentPort), 0L);\n+            process.sendNewline();\n+            process.waitForSuccess();\n+        } finally {\n+            process.destroyForcibly();\n+        }\n+    }\n+\n+    private void waitForString(BufferedReader reader, String str) throws IOException {\n+        for (String line = reader.readLine(); true; line = reader.readLine()) {\n+            System.out.println(line);\n+            if (line.contains(str))\n+                break;\n+        }\n+    }\n+\n+    private static Map<String, String> javaOptions(String port) {\n+        \/\/ the options are in a map, so the values will be overwritten\n+        var opts = new HashMap<String, String>();\n+        opts.put(\"java.rmi.server.hostname\", \"localhost\");\n+        opts.put(\"com.sun.management.jmxremote\", \"true\");\n+        opts.put(\"com.sun.management.jmxremote.port\", port);\n+        opts.put(\"com.sun.management.jmxremote.rmi.port\", port);\n+        opts.put(\"com.sun.management.jmxremote.ssl\", \"false\");\n+        opts.put(\"com.sun.management.jmxremote.authenticate\", \"false\");\n+        opts.put(\"sun.rmi.transport.tcp.logLevel\", \"FINER\");\n+        opts.put(\"jdk.crac.collect-fd-stacktraces\", \"true\");\n+        return opts;\n+    }\n+\n+    private long getUptimeFromRestoreFromJmx(String port) throws IOException, MalformedObjectNameException {\n+        JMXConnector conn = JMXConnectorFactory.connect(new JMXServiceURL(\"service:jmx:rmi:\/\/\/jndi\/rmi:\/\/localhost:\" + port + \"\/jmxrmi\"));\n+        CRaCMXBean cracBean = JMX.newMBeanProxy(conn.getMBeanServerConnection(), new ObjectName(\"jdk.management:type=CRaC\"), CRaCMXBean.class);\n+        return cracBean.getUptimeSinceRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(BOOTED);\n+        assertEquals((int)'\\n', System.in.read());\n+        if (!NONE.equals(portAfter)) {\n+            javaOptions(portAfter).forEach(System::setProperty);\n+        }\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED);\n+        assertEquals((int)'\\n', System.in.read());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RemoteJmxTest.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -10,0 +10,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -99,7 +100,1 @@\n-            try {\n-                OutputAnalyzer oa = outputAnalyzer();\n-                System.err.print(oa.getStderr());\n-                System.out.print(oa.getStdout());\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n+            printOutput();\n@@ -112,0 +107,10 @@\n+    private void printOutput() {\n+        try {\n+            OutputAnalyzer oa = outputAnalyzer();\n+            System.err.print(oa.getStderr());\n+            System.out.print(oa.getStdout());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n@@ -124,0 +129,12 @@\n+    public void waitForStdout(String str) throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        watch(line -> {\n+            if (line.equals(str)) {\n+                latch.countDown();\n+            } else {\n+                throw new IllegalArgumentException(\"Unexpected input\");\n+            }\n+        }, System.err::println);\n+        assertTrue(latch.await(10, TimeUnit.SECONDS));\n+    }\n+\n@@ -140,0 +157,14 @@\n+\n+    public InputStream output() {\n+        return process.getInputStream();\n+    }\n+\n+    public void sendNewline() throws IOException {\n+        OutputStream input = process.getOutputStream();\n+        input.write('\\n');\n+        input.flush();\n+    }\n+\n+    public void destroyForcibly() {\n+        process.destroyForcibly();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"}]}