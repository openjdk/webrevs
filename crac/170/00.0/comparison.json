{"files":[{"patch":"@@ -153,1 +153,0 @@\n-  JVM_EXCLUDE_PATTERNS += gc\/x\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1793,3 +1793,10 @@\n-  if (UseSHA3Intrinsics) {\n-    warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n+#ifdef _LP64\n+  if (supports_evex() && supports_avx512bw()) {\n+      if (FLAG_IS_DEFAULT(UseSHA3Intrinsics)) {\n+          UseSHA3Intrinsics = true;\n+      }\n+  } else\n+#endif\n+   if (UseSHA3Intrinsics) {\n+      warning(\"Intrinsics for SHA3-224, SHA3-256, SHA3-384 and SHA3-512 crypto hash functions not available on this CPU.\");\n+      FLAG_SET_DEFAULT(UseSHA3Intrinsics, false);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -713,2 +713,2 @@\n-  static void set_avx_cpuFeatures() { _features = (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }\n-  static void set_evex_cpuFeatures() { _features = (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }\n+  static void set_avx_cpuFeatures() { _features |= (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }\n+  static void set_evex_cpuFeatures() { _features |= (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }\n@@ -716,0 +716,1 @@\n+  static void set_bmi_cpuFeatures() { _features |= (CPU_BMI1 | CPU_BMI2 | CPU_LZCNT); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1095,1 +1095,1 @@\n-    ThreadCritical tc;\n+    NmtVirtualMemoryLocker ml;\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3856,1 +3856,2 @@\n-      os::print_memory_mappings((char*)start, bytes, tty);\n+      fileStream fs(stdout);\n+      os::print_memory_mappings((char*)start, bytes, &fs);\n@@ -5809,0 +5810,7 @@\n+    \/\/ The following code is only here to maintain the\n+    \/\/ characteristics\/performance from when an ObjectMonitor\n+    \/\/ \"responsible\" thread used to issue timed parks.\n+    HighResolutionInterval *phri = nullptr;\n+    if (!ForceTimeHighResolution) {\n+      phri = new HighResolutionInterval((jlong)1);\n+    }\n@@ -5810,0 +5818,1 @@\n+    delete phri; \/\/ if it is null, harmless\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -556,0 +556,15 @@\n+  \/\/ Add XMM registers + MXCSR. Note that C2 uses XMM to spill GPR values including pointers.\n+  st->cr();\n+  st->cr();\n+  \/\/ Sanity check: fpregs should point into the context.\n+  if ((address)uc->uc_mcontext.fpregs < (address)uc ||\n+      pointer_delta(uc->uc_mcontext.fpregs, uc, 1) >= sizeof(ucontext_t)) {\n+    st->print_cr(\"bad uc->uc_mcontext.fpregs: \" INTPTR_FORMAT \" (uc: \" INTPTR_FORMAT \")\",\n+                 p2i(uc->uc_mcontext.fpregs), p2i(uc));\n+  } else {\n+    for (int i = 0; i < 16; ++i) {\n+      const int64_t* xmm_val_addr = (int64_t*)&(uc->uc_mcontext.fpregs->_xmm[i]);\n+      st->print_cr(\"XMM[%d]=\" INTPTR_FORMAT \" \" INTPTR_FORMAT, i, xmm_val_addr[1], xmm_val_addr[0]);\n+    }\n+    st->print(\"  MXCSR=\" UINT32_FORMAT_X_0, uc->uc_mcontext.fpregs->mxcsr);\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -265,1 +265,0 @@\n-  template(reflect_DelegatingClassLoader,             \"jdk\/internal\/reflect\/DelegatingClassLoader\")   \\\n@@ -270,1 +269,0 @@\n-  template(reflect_SerializationConstructorAccessorImpl,             \"jdk\/internal\/reflect\/SerializationConstructorAccessorImpl\") \\\n@@ -311,0 +309,1 @@\n+  template(jdk_internal_vm_annotation_JvmtiHideEvents_signature,       \"Ljdk\/internal\/vm\/annotation\/JvmtiHideEvents;\")  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2599,0 +2599,1 @@\n+  size_t total_old_allocated = _old_evac_stats.allocated() + _old_evac_stats.direct_allocated();\n@@ -2600,1 +2601,1 @@\n-    add_allocated_bytes_since_last_gc(_old_evac_stats.allocated() * HeapWordSize);\n+    add_allocated_bytes_since_last_gc(total_old_allocated * HeapWordSize);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3282,4 +3282,1 @@\n-      \/\/ Skip reflection related frames\n-      if (!ik->is_subclass_of(vmClasses::reflect_SerializationConstructorAccessorImpl_klass())) {\n-        return JNIHandles::make_local(THREAD, loader);\n-      }\n+      return JNIHandles::make_local(THREAD, loader);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -510,1 +510,0 @@\n-  { \"ZGenerational\",                JDK_Version::jdk(23), JDK_Version::undefined(), JDK_Version::undefined() },\n@@ -526,1 +525,1 @@\n-\n+  { \"ZGenerational\",                JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::undefined() },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2169,1 +2169,1 @@\n-    ThreadCritical tc;\n+    NmtVirtualMemoryLocker ml;\n@@ -2191,1 +2191,1 @@\n-    ThreadCritical tc;\n+    NmtVirtualMemoryLocker ml;\n@@ -2283,1 +2283,1 @@\n-    ThreadCritical tc;\n+    NmtVirtualMemoryLocker ml;\n@@ -2322,1 +2322,1 @@\n-    ThreadCritical tc;\n+    NmtVirtualMemoryLocker ml;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -91,0 +92,4 @@\n+    \/\/ This field indicates whether the file is a regular file as some\n+    \/\/ operations need the current position which requires seeking\n+    private @Stable Boolean isRegularFile;\n+\n@@ -341,0 +346,3 @@\n+        if (!isRegularFile())\n+            return super.readAllBytes();\n+\n@@ -392,0 +400,3 @@\n+        if (!isRegularFile())\n+            return super.readNBytes(len);\n+\n@@ -428,1 +439,1 @@\n-        if (out instanceof FileOutputStream fos) {\n+        if (out instanceof FileOutputStream fos && isRegularFile()) {\n@@ -481,1 +492,4 @@\n-        return skip0(n);\n+        if (isRegularFile())\n+            return skip0(n);\n+\n+        return super.skip(n);\n@@ -678,0 +692,12 @@\n+    \/**\n+     * Determine whether the file is a regular file.\n+     *\/\n+    private boolean isRegularFile() {\n+        Boolean isRegularFile = this.isRegularFile;\n+        if (isRegularFile == null) {\n+            this.isRegularFile = isRegularFile = isRegularFile0(fd);\n+        }\n+        return isRegularFile;\n+    }\n+    private native boolean isRegularFile0(FileDescriptor fd);\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -150,2 +150,1 @@\n-     * {@link Console#charset()} if the {@code Console} exists,\n-     * <a href=\"#stdout.encoding\">stdout.encoding<\/a> otherwise.\n+     * {@link ##stdout.encoding stdout.encoding}.\n@@ -171,2 +170,1 @@\n-     * @see     Console#charset()\n-     * @see     <a href=\"#stdout.encoding\">stdout.encoding<\/a>\n+     * @see     ##stdout.encoding stdout.encoding\n@@ -188,2 +186,1 @@\n-     * equivalent to {@link Console#charset()} if the {@code Console}\n-     * exists, <a href=\"#stderr.encoding\">stderr.encoding<\/a> otherwise.\n+     * equivalent to {@link ##stderr.encoding stderr.encoding}.\n@@ -191,2 +188,1 @@\n-     * @see     Console#charset()\n-     * @see     <a href=\"#stderr.encoding\">stderr.encoding<\/a>\n+     * @see     ##stderr.encoding stderr.encoding\n@@ -796,1 +792,2 @@\n-     *     <td>Character encoding name for {@link System#out System.out}.\n+     *     <td>Character encoding name for {@link System#out System.out} and\n+     *     {@link System#console() System.console()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -143,0 +143,5 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc4086\n+ *      RFC 4086: Randomness Requirements for Security\n+ * @spec https:\/\/nvlpubs.nist.gov\/nistpubs\/FIPS\/NIST.FIPS.140-2.pdf\n+ *      Security Requirements for Cryptographic Modules\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,17 +41,1 @@\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Deque;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Objects;\n-import java.util.NoSuchElementException;\n-import java.util.Set;\n-import java.util.Spliterator;\n-import java.util.Spliterators;\n-import java.util.TreeSet;\n-import java.util.WeakHashMap;\n+import java.util.*;\n@@ -69,0 +53,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -1103,2 +1088,3 @@\n-     * Returns the versions for which there exists a non-directory\n-     * entry that begin with \"META-INF\/versions\/\" (case ignored).\n+     * Returns a BitSet where the set bits represents versions found for\n+     * the given entry name. For performance reasons, the name is looked\n+     * up only by hashcode, meaning the result is an over-approximation.\n@@ -1107,1 +1093,2 @@\n-     * Returns an empty array if no versioned entries exist.\n+     * Returns an empty BitSet if no versioned entries exist for this\n+     * name.\n@@ -1109,1 +1096,1 @@\n-    private int[] getMetaInfVersions() {\n+    private BitSet getMetaInfVersions(String name) {\n@@ -1112,1 +1099,1 @@\n-            return res.zsrc.metaVersions;\n+            return res.zsrc.metaVersions.getOrDefault(ZipCoder.hash(name), EMPTY_VERSIONS);\n@@ -1116,0 +1103,2 @@\n+    private static final BitSet EMPTY_VERSIONS = new BitSet();\n+\n@@ -1156,2 +1145,2 @@\n-                public int[] getMetaInfVersions(JarFile jar) {\n-                    return ((ZipFile)jar).getMetaInfVersions();\n+                public BitSet getMetaInfVersions(JarFile jar, String name) {\n+                    return ((ZipFile)jar).getMetaInfVersions(name);\n@@ -1195,1 +1184,2 @@\n-        private static final int[] EMPTY_META_VERSIONS = new int[0];\n+        \/\/ \"META-INF\/versions\/\/\".length()\n+        private static final int META_INF_VERSIONS_LEN = 19;\n@@ -1212,1 +1202,1 @@\n-        private int[] metaVersions;          \/\/ list of unique versions found in META-INF\/versions\/\n+        private Map<Integer, BitSet> metaVersions; \/\/ Versions found in META-INF\/versions\/, by entry name hash\n@@ -1594,1 +1584,1 @@\n-            metaVersions = EMPTY_META_VERSIONS;\n+            metaVersions = null;\n@@ -1779,2 +1769,0 @@\n-            \/\/ Set of all version numbers seen in META-INF\/versions\/\n-            Set<Integer> metaVersionsSet = null;\n@@ -1819,3 +1807,13 @@\n-                            if (metaVersionsSet == null)\n-                                metaVersionsSet = new TreeSet<>();\n-                            metaVersionsSet.add(version);\n+                            try {\n+                                \/\/ Compute hash code of name from \"META-INF\/versions\/{version)\/{name}\n+                                int prefixLen = META_INF_VERSIONS_LEN + DecimalDigits.stringSize(version);\n+                                int hashCode = zipCoderForPos(pos).checkedHash(cen,\n+                                        entryPos + prefixLen,\n+                                        nlen - prefixLen);\n+                                \/\/ Register version for this hash code\n+                                if (metaVersions == null)\n+                                    metaVersions = new HashMap<>();\n+                                metaVersions.computeIfAbsent(hashCode, _ -> new BitSet()).set(version);\n+                            } catch (Exception e) {\n+                                throw new IllegalArgumentException(e);\n+                            }\n@@ -1839,8 +1837,2 @@\n-            if (metaVersionsSet != null) {\n-                metaVersions = new int[metaVersionsSet.size()];\n-                int c = 0;\n-                for (Integer version : metaVersionsSet) {\n-                    metaVersions[c++] = version;\n-                }\n-            } else {\n-                metaVersions = EMPTY_META_VERSIONS;\n+            if (metaVersions == null) {\n+                metaVersions = Map.of();\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":32,"deletions":40,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.BitSet;\n@@ -41,1 +42,1 @@\n-    public int[] getMetaInfVersions(JarFile zip);\n+    public BitSet getMetaInfVersions(JarFile zip, String name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilZipFileAccess.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -495,0 +495,1 @@\n+\n@@ -570,0 +571,43 @@\n+    \/**\n+     * Returns an estimate of the number of remaining bytes that can be read\n+     * from this channel without blocking.\n+     *\/\n+    int available() throws IOException {\n+        ensureOpen();\n+        synchronized (positionLock) {\n+            int a = -1;\n+            int ti = -1;\n+            try {\n+                beginBlocking();\n+                ti = threads.add();\n+                if (!isOpen())\n+                    return -1;\n+                a = nd.available(fd);\n+            } finally {\n+                threads.remove(ti);\n+                endBlocking(a > -1);\n+            }\n+            return a;\n+        }\n+    }\n+\n+    \/**\n+     * Tells whether the channel represents something other than a regular\n+     * file, directory, or symbolic link.\n+     *\/\n+    boolean isOther() throws IOException {\n+        ensureOpen();\n+        int ti = -1;\n+        Boolean isOther = null;\n+        try {\n+            beginBlocking();\n+            ti = threads.add();\n+            if (!isOpen())\n+                return false;\n+            return isOther = nd.isOther(fd);\n+        } finally {\n+            threads.remove(ti);\n+            endBlocking(isOther != null);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,8 @@\n+    int available(FileDescriptor fd) throws IOException {\n+        return available0(fd);\n+    }\n+\n+    boolean isOther(FileDescriptor fd) throws IOException {\n+        return isOther0(fd);\n+    }\n+\n@@ -203,0 +211,4 @@\n+    static native int available0(FileDescriptor fd) throws IOException;\n+\n+    static native boolean isOther0(FileDescriptor fd) throws IOException;\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixFileDispatcherImpl.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -256,2 +256,2 @@\n-     * previous versions of the JRE, thus it is the only path that matters here.\n-     * So we check to see if the desired JRE is set.\n+     * previous versions of the JDK, thus it is the only path that matters here.\n+     * So we check to see if the desired JDK is set.\n@@ -276,1 +276,1 @@\n-                           char jrepath[], jint so_jrepath,\n+                           char jdkroot[], jint so_jdkroot,\n@@ -297,3 +297,3 @@\n-    \/* Find out where the JRE is that we will be using. *\/\n-    if (!GetJREPath(jrepath, so_jrepath, JNI_FALSE)) {\n-        JLI_ReportErrorMessage(JRE_ERROR1);\n+    \/* Find out where the JDK is that we will be using. *\/\n+    if (!GetJDKInstallRoot(jdkroot, so_jdkroot, JNI_FALSE)) {\n+        JLI_ReportErrorMessage(LAUNCHER_ERROR1);\n@@ -303,1 +303,1 @@\n-            jrepath, FILESEP, FILESEP);\n+            jdkroot, FILESEP, FILESEP);\n@@ -317,1 +317,1 @@\n-    if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) {\n+    if (!GetJVMPath(jdkroot, jvmtype, jvmpath, so_jvmpath)) {\n@@ -342,2 +342,2 @@\n-         *     o          $JRE\/lib\n-         *     o          $JRE\/..\/lib\n+         *     o          $JDK\/lib\n+         *     o          $JDK\/..\/lib\n@@ -355,1 +355,1 @@\n-                    2 * JLI_StrLen(jrepath) +\n+                    2 * JLI_StrLen(jdkroot) +\n@@ -375,2 +375,2 @@\n-                        jrepath,\n-                        jrepath\n+                        jdkroot,\n+                        jdkroot\n@@ -405,1 +405,1 @@\n-                JLI_ReportErrorMessageSys(JRE_ERROR11);\n+                JLI_ReportErrorMessageSys(LAUNCHER_ERROR3);\n@@ -440,1 +440,1 @@\n-        JLI_ReportErrorMessageSys(JRE_ERROR4, newexec);\n+        JLI_ReportErrorMessageSys(LAUNCHER_ERROR4, newexec);\n@@ -447,1 +447,1 @@\n-GetJVMPath(const char *jrepath, const char *jvmtype,\n+GetJVMPath(const char *jdkroot, const char *jvmtype,\n@@ -455,1 +455,1 @@\n-        JLI_Snprintf(jvmpath, jvmpathsize, \"%s\/lib\/%s\/\" JVM_DLL, jrepath, jvmtype);\n+        JLI_Snprintf(jvmpath, jvmpathsize, \"%s\/lib\/%s\/\" JVM_DLL, jdkroot, jvmtype);\n@@ -470,1 +470,1 @@\n- * Find path to JRE based on .exe's location or registry settings.\n+ * Find path to the JDK installation root\n@@ -473,1 +473,1 @@\n-GetJREPath(char *path, jint pathsize, jboolean speculative)\n+GetJDKInstallRoot(char *path, jint pathsize, jboolean speculative)\n@@ -478,1 +478,1 @@\n-    JLI_TraceLauncher(\"Attempt to get JRE path from launcher executable path\\n\");\n+    JLI_TraceLauncher(\"Attempt to get JDK installation root from launcher executable path\\n\");\n@@ -481,1 +481,1 @@\n-        \/* Is JRE co-located with the application? *\/\n+        \/* Is JDK co-located with the application? *\/\n@@ -484,1 +484,1 @@\n-            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            JLI_TraceLauncher(\"JDK installation root path is %s\\n\", path);\n@@ -489,1 +489,1 @@\n-    JLI_TraceLauncher(\"Attempt to get JRE path from shared lib of the image\\n\");\n+    JLI_TraceLauncher(\"Attempt to get JDK installation root path from shared lib of the image\\n\");\n@@ -494,1 +494,1 @@\n-            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            JLI_TraceLauncher(\"JDK installation root path is %s\\n\", path);\n@@ -504,1 +504,1 @@\n-            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            JLI_TraceLauncher(\"JDK installation root path is %s\\n\", path);\n@@ -511,1 +511,1 @@\n-      JLI_ReportErrorMessage(JRE_ERROR8 JAVA_DLL);\n+      JLI_ReportErrorMessage(LAUNCHER_ERROR2 JAVA_DLL);\n@@ -600,1 +600,1 @@\n-        char jrePath[MAXPATHLEN];\n+        char jdkRoot[MAXPATHLEN];\n@@ -603,2 +603,2 @@\n-        if (!GetJREPath(jrePath, sizeof(jrePath), JNI_FALSE)) {\n-            JLI_ReportErrorMessage(JRE_ERROR1);\n+        if (!GetJDKInstallRoot(jdkRoot, sizeof(jdkRoot), JNI_FALSE)) {\n+            JLI_ReportErrorMessage(LAUNCHER_ERROR1);\n@@ -608,1 +608,1 @@\n-                     jrePath, SPLASHSCREEN_SO);\n+                           jdkRoot, SPLASHSCREEN_SO);\n@@ -611,1 +611,1 @@\n-            JLI_ReportErrorMessage(JRE_ERROR11);\n+            JLI_ReportErrorMessage(LAUNCHER_ERROR3);\n@@ -615,1 +615,1 @@\n-            JLI_ReportErrorMessage(JRE_ERROR13);\n+            JLI_ReportErrorMessage(LAUNCHER_ERROR5);\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -62,2 +62,1 @@\n-compiler\/vectorapi\/VectorRebracket128Test.java#ZSinglegen 8330538 generic-all\n-compiler\/vectorapi\/VectorRebracket128Test.java#ZGenerational 8330538 generic-all\n+compiler\/vectorapi\/VectorRebracket128Test.java#Z 8330538 generic-all\n@@ -97,2 +96,1 @@\n-gc\/TestAlwaysPreTouchBehavior.java#ZGenerational 8334513 generic-all\n-gc\/TestAlwaysPreTouchBehavior.java#ZSinglegen 8334513 generic-all\n+gc\/TestAlwaysPreTouchBehavior.java#Z 8334513 generic-all\n@@ -108,0 +106,1 @@\n+runtime\/Monitor\/SyncOnValueBasedClassTest.java 8340995 linux-s390x\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}