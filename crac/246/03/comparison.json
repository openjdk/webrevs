{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2022, 2025, Azul Systems, Inc. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.test.lib.Platform;\n@@ -38,1 +39,1 @@\n-import static jdk.test.lib.Asserts.assertLT;\n+import static jdk.test.lib.Asserts.*;\n@@ -47,1 +48,6 @@\n-    static final long TIME_TOLERANCE = 10_000; \/\/ ms\n+    static final long TIME_TOLERANCE = 1000; \/\/ ms\n+\n+    private static String formatTime(long t) {\n+        return DateTimeFormatter.ofPattern(\"E dd LLL yyyy HH:mm:ss.n\").format(\n+                Instant.ofEpochMilli(t).atZone(ZoneId.systemDefault()));\n+    }\n@@ -58,4 +64,1 @@\n-        System.out.println(\"RestoreTime \" + restoreTime + \" \" +\n-            DateTimeFormatter.ofPattern(\"E dd LLL yyyy HH:mm:ss.n\").format(\n-                Instant.ofEpochMilli(restoreTime)\n-                    .atZone(ZoneId.systemDefault())));\n+        System.out.println(\"RestoreTime \" + restoreTime + \" \" + formatTime(restoreTime));\n@@ -66,1 +69,1 @@\n-        long start = System.currentTimeMillis();\n+        final var builder = new CracBuilder().captureOutput(true);\n@@ -68,7 +71,11 @@\n-        OutputAnalyzer output = new CracBuilder().engine(CracEngine.SIMULATE)\n-                .captureOutput(true)\n-                .startCheckpoint().waitForSuccess().outputAnalyzer();\n-\n-        long restoreUptime = Long.parseLong(output.firstMatch(\"UptimeSinceRestore ([0-9-]+)\", 1));\n-        if (restoreUptime < 0 || TIME_TOLERANCE < restoreUptime) {\n-            throw new Error(\"bad UptimeSinceRestore: \" + restoreUptime);\n+        final OutputAnalyzer output;\n+        final long restoreStartTime;\n+        if (Platform.isLinux()) { \/\/ Linux is currently the only platform supporting non-immediate restore\n+            final var process = builder.engine(CracEngine.PAUSE).startCheckpoint();\n+            output = process.outputAnalyzer();\n+            process.waitForPausePid();\n+            restoreStartTime = System.currentTimeMillis();\n+            builder.doRestore();\n+        } else {\n+            restoreStartTime = System.currentTimeMillis(); \/\/ A very rough approximation\n+            output = builder.engine(CracEngine.SIMULATE).startCheckpoint().waitForSuccess().outputAnalyzer();\n@@ -76,0 +83,1 @@\n+        System.out.println(\"RestoreStartTime \" + restoreStartTime + \" \" + formatTime(restoreStartTime));\n@@ -77,2 +85,3 @@\n-        long restoreTime = Long.parseLong(output.firstMatch(\"RestoreTime ([0-9-]+)\", 1));\n-        restoreTime -= start;\n+        final long uptimeSinceRestore = Long.parseLong(output.firstMatch(\"UptimeSinceRestore ([0-9-]+)\", 1));\n+        assertGTE(uptimeSinceRestore, 0L, \"Bad UptimeSinceRestore\");\n+        assertLT(uptimeSinceRestore, TIME_TOLERANCE, \"UptimeSinceRestore should be a bit greater than 0\");\n@@ -80,1 +89,8 @@\n-        assertLT(Math.abs(restoreTime), TIME_TOLERANCE, \"bad RestoreTime: \" + restoreTime);\n+        final long restoreTime = Long.parseLong(output.firstMatch(\"RestoreTime ([0-9-]+)\", 1));\n+        assertGTE(restoreTime, 0L, \"Bad RestoreTime\");\n+        if (Platform.isLinux()) {\n+            assertLT(restoreTime - restoreStartTime, TIME_TOLERANCE,\n+                    \"RestoreTime \" + restoreTime + \" should be a bit greater than \" + restoreStartTime);\n+        } else {\n+            assertGT(restoreTime, restoreStartTime, \"Time has gone backwards?\");\n+        }\n","filename":"test\/jdk\/jdk\/crac\/MXBean.java","additions":34,"deletions":18,"binary":false,"changes":52,"status":"modified"}]}