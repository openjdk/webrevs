{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import jdk.test.lib.Platform;\n@@ -39,1 +38,1 @@\n-import static jdk.test.lib.Asserts.*;\n+import static jdk.test.lib.Asserts.assertLT;\n@@ -48,6 +47,1 @@\n-    static final long TIME_TOLERANCE = 1000; \/\/ ms\n-\n-    private static String formatTime(long t) {\n-        return DateTimeFormatter.ofPattern(\"E dd LLL yyyy HH:mm:ss.n\").format(\n-                Instant.ofEpochMilli(t).atZone(ZoneId.systemDefault()));\n-    }\n+    static final long TIME_TOLERANCE = 100_000; \/\/ ms; some Mac CI can fail with 10_000\n@@ -64,1 +58,4 @@\n-        System.out.println(\"RestoreTime \" + restoreTime + \" \" + formatTime(restoreTime));\n+        System.out.println(\"RestoreTime \" + restoreTime + \" \" +\n+            DateTimeFormatter.ofPattern(\"E dd LLL yyyy HH:mm:ss.n\").format(\n+                Instant.ofEpochMilli(restoreTime)\n+                    .atZone(ZoneId.systemDefault())));\n@@ -69,1 +66,1 @@\n-        final var builder = new CracBuilder().captureOutput(true);\n+        long start = System.currentTimeMillis();\n@@ -71,11 +68,7 @@\n-        final OutputAnalyzer output;\n-        final long restoreStartTime;\n-        if (Platform.isLinux()) { \/\/ Linux is currently the only platform supporting non-immediate restore\n-            final var process = builder.engine(CracEngine.PAUSE).startCheckpoint();\n-            output = process.outputAnalyzer();\n-            process.waitForPausePid();\n-            restoreStartTime = System.currentTimeMillis();\n-            builder.doRestore();\n-        } else {\n-            restoreStartTime = System.currentTimeMillis(); \/\/ A very rough approximation\n-            output = builder.engine(CracEngine.SIMULATE).startCheckpoint().waitForSuccess().outputAnalyzer();\n+        OutputAnalyzer output = new CracBuilder().engine(CracEngine.SIMULATE)\n+                .captureOutput(true)\n+                .startCheckpoint().waitForSuccess().outputAnalyzer();\n+\n+        long restoreUptime = Long.parseLong(output.firstMatch(\"UptimeSinceRestore ([0-9-]+)\", 1));\n+        if (restoreUptime < 0 || TIME_TOLERANCE < restoreUptime) {\n+            throw new Error(\"bad UptimeSinceRestore: \" + restoreUptime);\n@@ -83,1 +76,0 @@\n-        System.out.println(\"RestoreStartTime \" + restoreStartTime + \" \" + formatTime(restoreStartTime));\n@@ -85,3 +77,2 @@\n-        final long uptimeSinceRestore = Long.parseLong(output.firstMatch(\"UptimeSinceRestore ([0-9-]+)\", 1));\n-        assertGTE(uptimeSinceRestore, 0L, \"Bad UptimeSinceRestore\");\n-        assertLT(uptimeSinceRestore, TIME_TOLERANCE, \"UptimeSinceRestore should be a bit greater than 0\");\n+        long restoreTime = Long.parseLong(output.firstMatch(\"RestoreTime ([0-9-]+)\", 1));\n+        restoreTime -= start;\n@@ -89,8 +80,1 @@\n-        final long restoreTime = Long.parseLong(output.firstMatch(\"RestoreTime ([0-9-]+)\", 1));\n-        assertGTE(restoreTime, 0L, \"Bad RestoreTime\");\n-        if (Platform.isLinux()) {\n-            assertLT(restoreTime - restoreStartTime, TIME_TOLERANCE,\n-                    \"RestoreTime \" + restoreTime + \" should be a bit greater than \" + restoreStartTime);\n-        } else {\n-            assertGT(restoreTime, restoreStartTime, \"Time has gone backwards?\");\n-        }\n+        assertLT(Math.abs(restoreTime), TIME_TOLERANCE, \"bad RestoreTime: \" + restoreTime);\n","filename":"test\/jdk\/jdk\/crac\/MXBean.java","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"}]}