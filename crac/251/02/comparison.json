{"files":[{"patch":"@@ -821,1 +821,1 @@\n-    if (nm->make_not_entrant(\"C1 deoptimize\")) {\n+    if (nm->make_not_entrant(\"C1 deoptimize\", true \/* OK to recompile *\/)) {\n@@ -1113,1 +1113,1 @@\n-      nm->make_not_entrant(\"C1 code patch\");\n+      nm->make_not_entrant(\"C1 code patch\", true \/* OK to recompile *\/);\n@@ -1361,1 +1361,1 @@\n-      nm->make_not_entrant(\"C1 deoptimize for patching\");\n+      nm->make_not_entrant(\"C1 deoptimize for patching\", true \/* OK to recompile *\/);\n@@ -1489,1 +1489,1 @@\n-  nm->make_not_entrant(\"C1 predicate failed trap\");\n+  nm->make_not_entrant(\"C1 predicate failed trap\", true \/* OK to recompile *\/);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -805,1 +805,1 @@\n-      nm->make_not_entrant(\"CI replay\");\n+      nm->make_not_entrant(\"CI replay\", false \/* recompiling by ourselves *\/);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -76,0 +77,1 @@\n+    CRaCRecompiler::metadata_do(Metadata::mark_on_stack);\n","filename":"src\/hotspot\/share\/classfile\/metadataOnStackMark.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1364,1 +1364,1 @@\n-      nm->make_not_entrant(\"marked for deoptimization\");\n+      nm->make_not_entrant(\"marked for deoptimization\", true \/* OK to recompile *\/);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -2009,1 +2010,1 @@\n-bool nmethod::make_not_entrant(const char* reason) {\n+bool nmethod::make_not_entrant(const char* reason, bool can_schedule_recompilation) {\n@@ -2103,0 +2104,4 @@\n+  if (can_schedule_recompilation) {\n+    CRaCRecompiler::record_decompilation(*this);\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -636,2 +636,7 @@\n-  bool  make_not_entrant(const char* reason);\n-  bool  make_not_used()    { return make_not_entrant(\"not used\"); }\n+  \/\/\n+  \/\/ can_schedule_recompilation should be true if the decompilation\n+  \/\/ is triggered by an application state change and it makes sense\n+  \/\/ to request recompilation of the method as soon as the state\n+  \/\/ becomes stable again.\n+  bool  make_not_entrant(const char* reason, bool can_schedule_recompilation);\n+  bool  make_not_used()    { return make_not_entrant(\"not used\", false \/* likely already recompiling *\/); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -927,1 +927,1 @@\n-          osr_nm->make_not_entrant(\"OSR invalidation for compiling with C1\");\n+          osr_nm->make_not_entrant(\"OSR invalidation for compiling with C1\", false \/* recompiling by ourselves *\/);\n@@ -1519,1 +1519,1 @@\n-            nm->make_not_entrant(\"OSR invalidation, back branch\");\n+            nm->make_not_entrant(\"OSR invalidation, back branch\", false \/* recompiling by ourselves *\/);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -1260,0 +1261,9 @@\n+    \/\/ Ensure the method has not gotten compiled on a better level since CRaC\n+    \/\/ recorded its decompilation. We do it this late to ensure there is no race\n+    \/\/ between the recompilation requesting thread and other threads requesting\n+    \/\/ compilation through the usual routes.\n+    if (compile_reason == CompileTask::Reason_CRaC &&\n+        !CRaCRecompiler::is_recompilation_relevant(method, osr_bci, comp_level)) {\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+      Reason_CRaC,             \/\/ CRaC-initiated recompilation\n@@ -79,1 +80,2 @@\n-      \"bootstrap\"\n+      \"bootstrap\",\n+      \"crac\"\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1190,0 +1190,6 @@\n+JNIEXPORT void JNICALL\n+JVM_StartRecordingDecompilations(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL\n+JVM_FinishRecordingDecompilationsAndRecompile(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1385,1 +1385,1 @@\n-    code->make_not_entrant(\"JVMCI reprofile\");\n+    code->make_not_entrant(\"JVMCI reprofile\", false \/* trust the compiler, ideally should be a parameter *\/);\n@@ -1825,1 +1825,2 @@\n-    fst.current()->cb()->as_nmethod()->make_not_entrant(\"JVMCI materialize virtual objects\");\n+    fst.current()->cb()->as_nmethod()->make_not_entrant(\"JVMCI materialize virtual objects\",\n+                                                        false \/* likely not caused by app state change *\/);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1776,1 +1776,1 @@\n-    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\");\n+    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\", false \/* trust the compiler, ideally should be a parameter *\/);\n@@ -1785,1 +1785,1 @@\n-    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\");\n+    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\", false \/* trust the compiler, ideally should be a parameter *\/);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2187,1 +2187,1 @@\n-              old->make_not_entrant(\"JVMCI register method\");\n+              old->make_not_entrant(\"JVMCI register method\", false \/* already being replaced *\/);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3495,1 +3495,1 @@\n-      inv->make_not_entrant(\"OSR invalidation of lower levels\");\n+      inv->make_not_entrant(\"OSR invalidation of lower levels\", false \/* already being replaced *\/);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1031,1 +1031,1 @@\n-    nm->make_not_entrant(\"set native function\");\n+    nm->make_not_entrant(\"set native function\", false \/* replaced by native function *\/);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -3709,0 +3710,8 @@\n+JVM_ENTRY(void, JVM_StartRecordingDecompilations(JNIEnv *env))\n+  CRaCRecompiler::start_recording_decompilations();\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_FinishRecordingDecompilationsAndRecompile(JNIEnv *env))\n+  CRaCRecompiler::finish_recording_decompilations_and_recompile();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -797,1 +797,1 @@\n-                nm->make_not_entrant(\"Whitebox deoptimization\");\n+                nm->make_not_entrant(\"Whitebox deoptimization\", false \/* don't interfere with testing *\/);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"runtime\/cracRecompiler.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/metadata.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ Records information about a decompiled method.\n+\/\/\n+\/\/ Safepoints may occur between the moments when it is recorded and used which\n+\/\/ can lead to the Method* getting freed. To fight this we use the same\n+\/\/ mechanisms as CompileTask does:\n+\/\/ 1. Method holder class may get unloaded. A jweak to class holder is used to\n+\/\/    checked for this, the method will not be re-compiled if this happens.\n+\/\/ 2. Method may get thrown away by RedefineClasses. We forbid this for all\n+\/\/    recorded methods by marking them \"on-stack\" for RedefineClasses.\n+class CompilationInfo : public CHeapObj<MemTag::mtInternal> {\n+public:\n+  CompilationInfo(Method *method, int bci, int comp_level) :\n+      _klass_holder(JNIHandles::make_weak_global(Handle(Thread::current(), method->method_holder()->klass_holder()))),\n+      _method(method), _bci(bci), _comp_level(comp_level) {}\n+  ~CompilationInfo() {\n+    if (_klass_holder != nullptr) {\n+      if (JNIHandles::is_weak_global_handle(_klass_holder)) {\n+        JNIHandles::destroy_weak_global(_klass_holder);\n+      } else {\n+        JNIHandles::destroy_global(_klass_holder);\n+      }\n+    }\n+  }\n+  NONCOPYABLE(CompilationInfo);\n+\n+  Method *method() const { return _method; }\n+  int bci() const { return _bci; };\n+  int comp_level() const { return _comp_level; };\n+\n+  bool is_method_loaded() const {\n+    return _klass_holder == nullptr || \/\/ bootstrap loader is never unloaded\n+           JNIHandles::is_global_handle(_klass_holder) || \/\/ Strong handle keeps it loaded\n+           !JNIHandles::is_weak_global_cleared(_klass_holder); \/\/ Weak handle but still loaded\n+  }\n+  bool keep_method_loaded() {\n+    const NoSafepointVerifier nsv; \/\/ Ensure not unloaded concurrently\n+    if (!is_method_loaded()) {\n+      return false; \/\/ Already unloaded\n+    }\n+    JNIHandles::destroy_weak_global(_klass_holder);\n+    _klass_holder = JNIHandles::make_global(Handle(Thread::current(), method()->method_holder()->klass_holder()));\n+    postcond(is_method_loaded());\n+    return true;\n+  }\n+\n+private:\n+  jweak _klass_holder;\n+  Method * const _method;\n+  const int _bci;\n+  const int _comp_level;\n+};\n+\n+static void request_recompilation(CompilationInfo *info) {\n+  if (!info->keep_method_loaded()) {\n+    log_trace(crac, compilation)(\n+      \"Skipping recompilation: <unloaded method>, bci=%i, comp_level=%i — method got unloaded\",\n+      info->bci(), info->comp_level());\n+    return;\n+  }\n+  assert(Method::is_valid_method(info->method()), \"sanity check\");\n+\n+  if (log_is_enabled(Trace, crac)) {\n+    ResourceMark rm;\n+    log_trace(crac, compilation)(\n+      \"Requesting recompilation: %s, bci=%i, comp_level=%i\",\n+      info->method()->external_name(), info->bci(), info->comp_level());\n+  }\n+\n+  auto * const THREAD = JavaThread::current();\n+  \/\/ Note: this does not guarantee the method will get compiled; e.g. there may\n+  \/\/ already be compilation tasks for this method (even if on another level or\n+  \/\/ OSR-BCI) or it may have gotten not-compilable since it was recorded.\n+  CompileBroker::compile_method(methodHandle(THREAD, info->method()), info->bci(), info->comp_level(),\n+                                0, CompileTask::Reason_CRaC, THREAD);\n+  guarantee(!HAS_PENDING_EXCEPTION, \"the method should have been successfully compiled before\");\n+}\n+\n+\/\/ States:\n+\/\/  ┌─> IDLE ─> RECORDING ─> COMPILING ─┐\n+\/\/  └───────────────────────────────────┘\n+\/\/ - IDLE — doing nothing.\n+\/\/  - is_recording == false\n+\/\/  - decompilations == null\n+\/\/ - RECORDING — recording decompilations.\n+\/\/  - is_recording == true\n+\/\/  - decompilations != null — used for concurrent writing\n+\/\/ - COMPILING — recompiling the recorded decompilations.\n+\/\/  - is_recording == false\n+\/\/  - decompilations != null — used for non-concurrent reading and writing\n+static volatile bool is_recording;\n+static Mutex *decompilations_lock;\n+static GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *decompilations;\n+\n+void CRaCRecompiler::start_recording_decompilations() {\n+  if (decompilations_lock == nullptr) {\n+    \/\/ Rank must be lower than that of MDOExtraData_lock\n+    decompilations_lock = new Mutex(Mutex::nosafepoint - 2, \"CRaCRecompiler_lock\");\n+  }\n+\n+  assert(!is_recording && decompilations == nullptr, \"unexpected state: is_recording = %s, decompilations = %p\",\n+         BOOL_TO_STR(is_recording), decompilations);\n+  decompilations = new GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal>();\n+  Atomic::release_store_fence(&is_recording, true);\n+  log_debug(crac, compilation)(\"CRaCRecompiler state: IDLE -> RECORDING\");\n+}\n+\n+void CRaCRecompiler::finish_recording_decompilations_and_recompile() {\n+  assert(Thread::current()->is_Java_thread(), \"need a Java thread to request compilations\");\n+\n+  {\n+    \/\/ The lock ensures we do not change the state while someone is recording\n+    const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n+    assert(is_recording && decompilations != nullptr, \"unexpected state: is_recording = %s, decompilations = %p\",\n+           BOOL_TO_STR(is_recording), decompilations);\n+    Atomic::release_store_fence(&is_recording, false);\n+    log_debug(crac, compilation)(\"CRaCRecompiler state: RECORDING -> COMPILING (recorded: %i)\", decompilations->length());\n+  }\n+\n+  \/\/ No lock because while the state is COMPILING only metadata_do() can access\n+  \/\/ decompilations besides us and it does that only on safepoints. We also rely\n+  \/\/ on the caller to ensure that if another recording will be started later\n+  \/\/ that thread will see all of these updates.\n+  while (decompilations->is_nonempty()) {\n+    \/\/ TODO: there can only be one compilation queued\/in-progress for a method\n+    \/\/  at a time, if there is one already for this method our request for it\n+    \/\/  will just be ignored. We could optimize at least our own requests by\n+    \/\/  placing requests for the same method further away from each other.\n+    request_recompilation(decompilations->last()); \/\/ Order should not matter\n+    \/\/ Method must stay in the decompilations list until we're done processing\n+    \/\/ it to let metadata_do() defend it from being deleted, so only pop now\n+    delete decompilations->pop();\n+  }\n+  delete decompilations;\n+  decompilations = nullptr;\n+  log_debug(crac, compilation)(\"CRaCRecompiler state: COMPILING -> IDLE\");\n+}\n+\n+void CRaCRecompiler::record_decompilation(const nmethod &nmethod) {\n+  if (!Atomic::load_acquire(&is_recording)) {\n+    return; \/\/ Fast pass to not acquire a lock when no C\/R occurs (i.e. most of the time)\n+  }\n+\n+  const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n+  if (is_recording) { \/\/ Re-check under the lock to be safe from concurrent changes\n+    assert(decompilations != nullptr, \"unexpected state: is_recording = %s, decompilations = %p\",\n+           BOOL_TO_STR(is_recording), decompilations);\n+    decompilations->append(new CompilationInfo(nmethod.method(),\n+                                               nmethod.is_osr_method() ? nmethod.osr_entry_bci() : InvocationEntryBci,\n+                                               nmethod.comp_level()));\n+  }\n+}\n+\n+bool CRaCRecompiler::is_recompilation_relevant(const methodHandle &method, int bci, int comp_level) {\n+  const nmethod *current_nmethod = bci == InvocationEntryBci ?\n+      method->code() :\n+      method->lookup_osr_nmethod_for(bci, CompLevel::CompLevel_any, false);\n+  const CompLevel current_comp_level = current_nmethod != nullptr ?\n+    checked_cast<CompLevel>(current_nmethod->comp_level()) :\n+    CompLevel::CompLevel_none;\n+  switch (current_comp_level) {\n+    case CompLevel::CompLevel_none:\n+      assert(comp_level > CompLevel::CompLevel_none, \"must be compiled\");\n+      return true; \/\/ JIT is better than interpreter\n+    case CompLevel::CompLevel_simple:\n+    case CompLevel::CompLevel_full_optimization:\n+      return false; \/\/ Already on a final level\n+    case CompLevel::CompLevel_limited_profile:\n+    case CompLevel::CompLevel_full_profile:\n+      return comp_level == CompLevel::CompLevel_full_optimization; \/\/ C2 is better than C1\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+  }\n+}\n+\n+void CRaCRecompiler::metadata_do(void f(Metadata *)) {\n+  assert_at_safepoint();\n+  \/\/ Since we are at a safepoint no synchronization is needed\n+  if (decompilations != nullptr) {\n+    for (const auto *decompilation : *decompilations) {\n+      if (decompilation->is_method_loaded()) {\n+        f(decompilation->method());\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/cracRecompiler.cpp","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRACRECOMPILER_HPP\n+#define SHARE_RUNTIME_CRACRECOMPILER_HPP\n+\n+#include \"code\/nmethod.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/metadata.hpp\"\n+#include \"runtime\/handles.hpp\"\n+\n+\/\/ During checkpoint-restore there is a high chance that application state will\n+\/\/ temporarily change. This may trigger deoptimizations and make methods\n+\/\/ decompile (make nmethods non-entrant). After restore the application is\n+\/\/ likely to quickly return to its previous stable state but it will take some\n+\/\/ time to compile the decompiled methods back, probably to the same code as\n+\/\/ before.\n+\/\/\n+\/\/ To speed up such after-restore warmup this class records decompilations\n+\/\/ occuring during checkpoint-restore and requests their compilation afterwards.\n+\/\/\n+\/\/ We don't recompile during checkpoint-restore because if the compilation\n+\/\/ manages to finish and get executed before the restoring is over it may trip\n+\/\/ over the temporary state again and get recompiled again, thus slowing the\n+\/\/ restoring.\n+\/\/\n+\/\/ Note that we don't prevent methods from becoming non-compilable during the\n+\/\/ above because that likely means the methods had been recompiling a lot even\n+\/\/ before the checkpoint started so it is reasonable to expect them to continue\n+\/\/ doing so afterwards. Although having that could still help in some cases so\n+\/\/ it may be implemented at some point.\n+class CRaCRecompiler : public AllStatic {\n+public:\n+  \/\/ Caller must ensure that starting a recording happens-before finishing it\n+  \/\/ and finishing an old recording happens-before starting a new one.\n+  static void start_recording_decompilations();\n+  static void finish_recording_decompilations_and_recompile();\n+\n+  static void record_decompilation(const nmethod &nmethod);\n+\n+  \/\/ Whether compiling the method on this level is still needed.\n+  static bool is_recompilation_relevant(const methodHandle &method, int bci, int comp_level);\n+\n+  \/\/ RedefineClasses support.\n+  static void metadata_do(void f(Metadata *));\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_CRACRECOMPILER_HPP\n","filename":"src\/hotspot\/share\/runtime\/cracRecompiler.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -1829,1 +1829,1 @@\n-  nm->make_not_entrant(\"missing exception handler\");\n+  nm->make_not_entrant(\"missing exception handler\", true \/* OK to recompile *\/);\n@@ -2458,1 +2458,1 @@\n-      if (!nm->make_not_entrant(\"uncommon trap\")) {\n+      if (!nm->make_not_entrant(\"uncommon trap\", true \/* OK to recompile *\/)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1340,1 +1340,1 @@\n-      nm->make_not_entrant(\"zombie\");\n+      nm->make_not_entrant(\"zombie\", false \/* don't interfere with testing\/debugging *\/);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2025, Azul Systems, Inc. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.internal.misc.InnocuousThread;\n@@ -65,0 +66,2 @@\n+    private static final String ENABLE_RECOMPILATION_PROPERTY = \"jdk.crac.enable-recompilation\";\n+    private static final String RECOMPILATION_DELAY_MS_PROPERTY = \"jdk.crac.recompilation-delay-ms\";\n@@ -69,0 +72,2 @@\n+        public static final boolean ENABLE_RECOMPILATION =\n+            Boolean.parseBoolean(System.getProperty(ENABLE_RECOMPILATION_PROPERTY, \"true\"));\n@@ -304,0 +309,1 @@\n+            startRecordingDecompilations();\n@@ -312,0 +318,1 @@\n+                scheduleFinishRecordingDecompilationsAndRecompile();\n@@ -344,0 +351,53 @@\n+\n+    private static Thread recompilerThread;\n+\n+    private static native void startRecordingDecompilations0();\n+    private static native void finishRecordingDecompilationsAndRecompile0();\n+\n+    private static void startRecordingDecompilations() throws CheckpointException {\n+        if (!FlagsHolder.ENABLE_RECOMPILATION) {\n+            return;\n+        }\n+\n+        if (recompilerThread != null) {\n+            \/\/ Finish the existing recording, if any\n+            recompilerThread.interrupt();\n+            try {\n+                recompilerThread.join();\n+            } catch (InterruptedException ie) {\n+                final CheckpointException ex = new CheckpointException();\n+                ex.addSuppressed(ie);\n+                throw ex;\n+            }\n+        }\n+        startRecordingDecompilations0();\n+    }\n+\n+    private static void scheduleFinishRecordingDecompilationsAndRecompile() {\n+        if (!FlagsHolder.ENABLE_RECOMPILATION) {\n+            if (System.getProperty(RECOMPILATION_DELAY_MS_PROPERTY) != null) {\n+                System.err.printf(\"Ignoring '%s' because '%s' is false\\n\",\n+                        RECOMPILATION_DELAY_MS_PROPERTY, ENABLE_RECOMPILATION_PROPERTY);\n+            }\n+            return;\n+        }\n+\n+        final var recompilationDelayMs = Long.getLong(RECOMPILATION_DELAY_MS_PROPERTY, 10L);\n+        if (recompilationDelayMs <= 0) {\n+            finishRecordingDecompilationsAndRecompile0();\n+        } else {\n+            \/\/ InnocuousThread not to add a thread into the user's thread group\n+            final Thread t = InnocuousThread.newThread(\"CRaC Recompiler\", () -> {\n+                try {\n+                    Thread.sleep(recompilationDelayMs);\n+                } catch (InterruptedException ignored) {\n+                    \/\/ Just finish earlier\n+                } finally {\n+                    finishRecordingDecompilationsAndRecompile0();\n+                }\n+            });\n+            t.setDaemon(true);\n+            t.start();\n+            recompilerThread = t;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2025, Azul Systems, Inc. All rights reserved.\n@@ -41,0 +41,10 @@\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_crac_mirror_Core_startRecordingDecompilations0(JNIEnv *env, jclass ignore) {\n+    JVM_StartRecordingDecompilations(env);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_crac_mirror_Core_finishRecordingDecompilationsAndRecompile0(JNIEnv *env, jclass ignore) {\n+    JVM_FinishRecordingDecompilationsAndRecompile(env);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @summary Should recompile iff the recorded compilation level was better than\n+ *          the current one.\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar wb.jar jdk.test.whitebox.WhiteBox\n+ * @build CompilationLevelTest\n+ * @run driver jdk.test.lib.crac.CracTest 4 0 true\n+ * @run driver jdk.test.lib.crac.CracTest 4 3 true\n+ * @run driver jdk.test.lib.crac.CracTest 2 0 true\n+ * @run driver jdk.test.lib.crac.CracTest 1 4 false\n+ * @run driver jdk.test.lib.crac.CracTest 4 1 false\n+ * @run driver jdk.test.lib.crac.CracTest 3 2 false\n+ * @run driver jdk.test.lib.crac.CracTest 0 3 false\n+ *\/\n+public class CompilationLevelTest implements CracTest {\n+    @CracTestArg(0)\n+    int preCrCompilationLevel;\n+    @CracTestArg(1)\n+    int inCrCompilationLevel;\n+    @CracTestArg(2)\n+    boolean shouldRecompile;\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void testMethod() {}\n+\n+    private static final String TEST_METHOD_NAME = \"testMethod\";\n+    private static final String MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE =\n+        \"\"\"\n+        [\n+            {\n+                match: \"%s.%s\",\n+                BackgroundCompilation: false\n+            }\n+        ]\n+        \"\"\".formatted(CompilationLevelTest.class.getName().replace('.', '\/'), TEST_METHOD_NAME);\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE)\n+            .vmOption(\"-Xbootclasspath\/a:wb.jar\").vmOption(\"-XX:+UnlockDiagnosticVMOptions\").vmOption(\"-XX:+WhiteBoxAPI\")\n+            .javaOption(\"jdk.crac.recompilation-delay-ms\", \"0\")\n+            .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        final var whiteBox = WhiteBox.getWhiteBox();\n+        final var testMethodRef = CompilationLevelTest.class.getDeclaredMethod(TEST_METHOD_NAME);\n+\n+        assertEquals(\n+            1, whiteBox.addCompilerDirective(MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE),\n+            \"Unexpected number of directives installed\"\n+        );\n+\n+        if (preCrCompilationLevel > 0) {\n+            assertTrue(\n+                whiteBox.enqueueMethodForCompilation(testMethodRef, preCrCompilationLevel),\n+                \"Failed to compile immediately\"\n+            );\n+        }\n+        assertEquals(\n+            preCrCompilationLevel, whiteBox.getMethodCompilationLevel(testMethodRef),\n+            \"Unexpected pre-C\/R compilation level\"\n+        );\n+\n+        final var resource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) {\n+                if (preCrCompilationLevel > 0) {\n+                    assertEquals(\n+                        1, whiteBox.deoptimizeMethod(testMethodRef),\n+                        \"Unexpected number of deoptimizations\"\n+                    );\n+                }\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) {\n+                if (inCrCompilationLevel > 0) {\n+                    assertTrue(\n+                        whiteBox.enqueueMethodForCompilation(testMethodRef, inCrCompilationLevel),\n+                        \"Failed to compile immediately\"\n+                    );\n+                }\n+                assertEquals(\n+                    inCrCompilationLevel, whiteBox.getMethodCompilationLevel(testMethodRef),\n+                    \"Unexpected in-C\/R compilation level\"\n+                );\n+            }\n+        };\n+        Core.getGlobalContext().register(resource);\n+\n+        Core.checkpointRestore();\n+\n+        final var expectedCompilationLevel = shouldRecompile ? preCrCompilationLevel : inCrCompilationLevel;\n+        assertEquals(\n+            expectedCompilationLevel, whiteBox.getMethodCompilationLevel(testMethodRef),\n+            \"Unexpected post-C\/R compilation level\"\n+        );\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/CompilationLevelTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Objects;\n+import java.util.function.BooleanSupplier;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @summary Tests recompilation of a method deoptimized because of reaching an\n+ *          uncompiled path (e.g. uncommon trap). Other recompiler tests rely on\n+ *          WhiteBox to force a method to compile\/decompile — this test is\n+ *          supposed to check a more real-life scenerio instead.\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar wb.jar jdk.test.whitebox.WhiteBox\n+ * @build NaturalDecompilationTest\n+ * @run driver jdk.test.lib.crac.CracTest TIERED\n+ * @run driver jdk.test.lib.crac.CracTest C1_ONLY\n+ * @run driver jdk.test.lib.crac.CracTest C2_ONLY\n+ *\/\n+public class NaturalDecompilationTest implements CracTest {\n+    \/\/ For debugging: set to a positive number to limit the time a stage (a timedDoWhile call) can take\n+    private static final long STAGE_TIME_LIMIT_SEC = 0;\n+\n+    \/\/ The compilers have different deoptimization implementations so it is\n+    \/\/ worth to test each of them.\n+    public enum Variant {\n+        TIERED,\n+        C1_ONLY,\n+        C2_ONLY,\n+    };\n+\n+    @CracTestArg\n+    Variant variant;\n+\n+    private static void blackhole(@SuppressWarnings(\"unused\") Object o) {}\n+\n+    private static int testMethod(int i) {\n+        try {\n+            \/\/ A compiler intrinsic which triggers decompilation in both C1 and\n+            \/\/ C2 when it has to throw IndexOutOfBoundsException\n+            Objects.checkIndex(i, 10);\n+            return i;\n+        } catch (IndexOutOfBoundsException ignored) {\n+            return -1;\n+        }\n+    }\n+\n+    private static final String BLACKHOLE_NAME = \"blackhole\";\n+    private static final String TEST_METHOD_NAME = \"testMethod\";\n+\n+    private static final int TEST_ARG_EXPECTED = 0;\n+    private static final int TEST_ARG_UNEXPECTED = -1;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final var builder = new CracBuilder().engine(CracEngine.SIMULATE).captureOutput(true)\n+            .vmOption(\"-Xbootclasspath\/a:wb.jar\").vmOption(\"-XX:+UnlockDiagnosticVMOptions\").vmOption(\"-XX:+WhiteBoxAPI\")\n+            .javaOption(\"jdk.crac.recompilation-delay-ms\", \"0\")\n+            .vmOption(\"-XX:+UnlockExperimentalVMOptions\")\n+            .vmOption(\"-XX:CompileCommand=blackhole,\" + NaturalDecompilationTest.class.getName() + \".\" + BLACKHOLE_NAME)\n+            .vmOption(\"-XX:CompileCommand=dontinline,\" + NaturalDecompilationTest.class.getName() + \".\" + TEST_METHOD_NAME)\n+            .vmOption(\"-XX:+PrintCompilation\") \/\/ To ease debugging, not actually used by the test\n+            .vmOption(\"-Xlog:crac*=trace\");\n+        switch (variant) {\n+            case TIERED -> { \/* This is the default *\/ }\n+            case C1_ONLY -> builder.vmOption(\"-XX:TieredStopAtLevel=1\");\n+            case C2_ONLY -> builder.vmOption(\"-XX:-TieredCompilation\");\n+        }\n+\n+        \/\/ Must create an output analyzer before waiting for success, otherwise\n+        \/\/ on Windows PrintCompilation overflows the piping buffer and the\n+        \/\/ waiting never completes\n+        final var proc = builder.startCheckpoint();\n+        final var out = proc.outputAnalyzer();\n+        proc.waitForSuccess();\n+        out.shouldContain(\"Requesting recompilation: int \" + NaturalDecompilationTest.class.getName() + \".\" + TEST_METHOD_NAME + \"(int)\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        final var whiteBox = WhiteBox.getWhiteBox();\n+        final var testMethodRef = NaturalDecompilationTest.class.getDeclaredMethod(TEST_METHOD_NAME, int.class);\n+\n+        timedDoWhile(\"compilation\", () -> {\n+            for (int i = 0; i < 2000; i++) {\n+                final var res = testMethod(TEST_ARG_EXPECTED);\n+                blackhole(res);\n+            }\n+            try {\n+                Thread.sleep(500); \/\/ Time to compile\n+            } catch (InterruptedException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+            return whiteBox.isMethodCompiled(testMethodRef);\n+        });\n+\n+        final var resource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) {\n+                assertTrue(whiteBox.isMethodCompiled(testMethodRef), \"Should still be compiled\");\n+                timedDoWhile(\"deoptimization\", () -> {\n+                    \/\/ We don't want to call to many times or the method may\n+                    \/\/ get compiled again. Normally just one call is enough\n+                    \/\/ to make it decompile,\n+                    testMethod(TEST_ARG_UNEXPECTED);\n+                    return !whiteBox.isMethodCompiled(testMethodRef);\n+                });\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) {\n+                assertFalse(whiteBox.isMethodCompiled(testMethodRef), \"Should still be deoptimized\");\n+            }\n+        };\n+        Core.getGlobalContext().register(resource);\n+\n+        Core.checkpointRestore();\n+\n+        timedDoWhile(\"recompilation\", () -> {\n+            try {\n+                Thread.sleep(1000); \/\/ Time to recompile\n+            } catch (InterruptedException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+            return whiteBox.isMethodCompiled(testMethodRef);\n+        });\n+    }\n+\n+    private static void timedDoWhile(String name, BooleanSupplier action) {\n+        final var startTime = System.nanoTime();\n+        boolean completed;\n+        do {\n+            if (STAGE_TIME_LIMIT_SEC > 0) {\n+                assertLessThan(\n+                    (System.nanoTime() - startTime) \/ 1_000_000_000, STAGE_TIME_LIMIT_SEC,\n+                    \"Task takes too long: \" + name\n+                );\n+            }\n+            System.out.println(\"Running: \" + name);\n+            completed = action.getAsBoolean();\n+        } while (!completed);\n+        System.out.println(\"Completed: \" + name);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/NaturalDecompilationTest.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @summary Tests flags that control recompilation.\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar wb.jar jdk.test.whitebox.WhiteBox\n+ * @build RecompilationFlagsTest\n+ * @run driver jdk.test.lib.crac.CracTest true  -1\n+ * @run driver jdk.test.lib.crac.CracTest true  0\n+ * @run driver jdk.test.lib.crac.CracTest true  10000\n+ * @run driver jdk.test.lib.crac.CracTest false 10000\n+ *\/\n+public class RecompilationFlagsTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean enableRecompilation;\n+    @CracTestArg(1)\n+    long delayMs;\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void testMethod() {}\n+\n+    private static final String TEST_METHOD_NAME = \"testMethod\";\n+    private static final String MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE =\n+        \"\"\"\n+        [\n+            {\n+                match: \"%s.%s\",\n+                BackgroundCompilation: false\n+            }\n+        ]\n+        \"\"\".formatted(RecompilationFlagsTest.class.getName().replace('.', '\/'), TEST_METHOD_NAME);\n+    private static final int TEST_METHOD_COMP_LEVEL = 4;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final var builder = new CracBuilder().engine(CracEngine.SIMULATE)\n+            .vmOption(\"-Xbootclasspath\/a:wb.jar\").vmOption(\"-XX:+UnlockDiagnosticVMOptions\").vmOption(\"-XX:+WhiteBoxAPI\")\n+            .javaOption(\"jdk.crac.enable-recompilation\", Boolean.toString(enableRecompilation))\n+            .javaOption(\"jdk.crac.recompilation-delay-ms\", Long.toString(delayMs))\n+            .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        final var whiteBox = WhiteBox.getWhiteBox();\n+        final var testMethodRef = RecompilationFlagsTest.class.getDeclaredMethod(TEST_METHOD_NAME);\n+\n+        assertEquals(\n+            1, whiteBox.addCompilerDirective(MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE),\n+            \"Unexpected number of directives installed\"\n+        );\n+\n+        assertTrue(\n+            whiteBox.enqueueMethodForCompilation(testMethodRef, TEST_METHOD_COMP_LEVEL),\n+            \"Failed to compile immediately\"\n+        );\n+        assertEquals(\n+            TEST_METHOD_COMP_LEVEL, whiteBox.getMethodCompilationLevel(testMethodRef),\n+            \"Unexpected pre-C\/R compilation level\"\n+        );\n+\n+        final var resource = new Resource() {\n+            public long restoreFinishTimeMs = -1;\n+\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) {}\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) {\n+                if (delayMs <= 0) {\n+                    assertEquals(\n+                        1, whiteBox.deoptimizeMethod(testMethodRef),\n+                        \"Unexpected number of deoptimizations\"\n+                    );\n+                } else {\n+                    restoreFinishTimeMs = Math.floorDiv(System.nanoTime(), 1_000_000);\n+                }\n+            }\n+        };\n+        Core.getGlobalContext().register(resource);\n+\n+        Core.checkpointRestore();\n+\n+        if (delayMs > 0) {\n+            assertEquals(\n+                1, whiteBox.deoptimizeMethod(testMethodRef),\n+                \"Unexpected number of deoptimizations\"\n+            );\n+\n+            \/\/ Ensure the delay has not expired before we triggered the decompilation\n+            final var timeSinceRestoreFinishMs = Math.ceilDiv(System.nanoTime(), 1_000_000) - resource.restoreFinishTimeMs;\n+            assertLessThan(timeSinceRestoreFinishMs, delayMs, \"Specified delay is too low for this machine\");\n+\n+            \/\/ Wait for the delay to expire and give the concurrent compilations some time to finish\n+            Thread.sleep(delayMs + 500);\n+        }\n+\n+        if (enableRecompilation) {\n+            assertEquals(\n+                TEST_METHOD_COMP_LEVEL, whiteBox.getMethodCompilationLevel(testMethodRef),\n+                \"Unexpected post-C\/R compilation level\"\n+            );\n+        } else {\n+            assertFalse(whiteBox.isMethodCompiled(testMethodRef), \"Should not get recompiled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/RecompilationFlagsTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}