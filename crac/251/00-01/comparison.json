{"files":[{"patch":"@@ -104,2 +104,3 @@\n-    log_trace(crac)(\"Skipping recompilation: <unloaded method>, bci=%i, comp_level=%i — got unloaded\",\n-                    info->bci(), info->comp_level());\n+    log_trace(crac, compilation)(\n+      \"Skipping recompilation: <unloaded method>, bci=%i, comp_level=%i — method got unloaded\",\n+      info->bci(), info->comp_level());\n@@ -112,2 +113,3 @@\n-    log_trace(crac)(\"Requesting recompilation: %s, bci=%i, comp_level=%i\",\n-                    info->method()->external_name(), info->bci(), info->comp_level());\n+    log_trace(crac, compilation)(\n+      \"Requesting recompilation: %s, bci=%i, comp_level=%i\",\n+      info->method()->external_name(), info->bci(), info->comp_level());\n@@ -125,0 +127,13 @@\n+\/\/ States:\n+\/\/  ┌─> IDLE ─> RECORDING ─> COMPILING ─┐\n+\/\/  └───────────────────────────────────┘\n+\/\/ - IDLE — doing nothing.\n+\/\/  - is_recording == false\n+\/\/  - decompilations == null\n+\/\/ - RECORDING — recording decompilations.\n+\/\/  - is_recording == true\n+\/\/  - decompilations != null — used for concurrent writing\n+\/\/ - COMPILING — recompiling the recorded decompilations.\n+\/\/  - is_recording == false\n+\/\/  - decompilations != null — used for non-concurrent reading and writing\n+static volatile bool is_recording;\n@@ -126,5 +141,1 @@\n-static volatile GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *decompilations;\n-\n-static bool is_recording_decompilations() {\n-  return Atomic::load_acquire(&decompilations) != nullptr;\n-}\n+static GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *decompilations;\n@@ -137,8 +148,0 @@\n-  const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n-  precond(!is_recording_decompilations());\n-  log_debug(crac)(\"Starting recording decompilations\");\n-  \/\/ release to ensuree decompilations_lock has been stored before the non-locked load in record_decompilation(),\n-  \/\/ fence to not proceed with C\/R until the recorder threads will see the recording update\n-  Atomic::release_store_fence(&decompilations, new GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal>());\n-  postcond(is_recording_decompilations());\n-}\n@@ -146,11 +149,5 @@\n-void CRaCRecompiler::record_decompilation(const nmethod &nmethod) {\n-  if (!is_recording_decompilations()) {\n-    return; \/\/ Fast pass to not acquire a lock when no C\/R occurs (i.e. most of the time)\n-  }\n-  const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n-  auto * const decomps = const_cast<GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *>(decompilations);\n-  if (decomps != nullptr) { \/\/ Re-check under the lock to be safe from concurrent deletion\n-    decomps->append(new CompilationInfo(nmethod.method(),\n-                                        nmethod.is_osr_method() ? nmethod.osr_entry_bci() : InvocationEntryBci,\n-                                        nmethod.comp_level()));\n-  }\n+  assert(!is_recording && decompilations == nullptr, \"unexpected state: is_recording = %s, decompilations = %p\",\n+         BOOL_TO_STR(is_recording), decompilations);\n+  decompilations = new GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal>();\n+  Atomic::release_store_fence(&is_recording, true);\n+  log_debug(crac, compilation)(\"CRaCRecompiler state: IDLE -> RECORDING\");\n@@ -160,2 +157,1 @@\n-  assert(Thread::current()->is_Java_thread(), \"need a Java thread\");\n-  assert(decompilations_lock != nullptr, \"lock must be initialized when starting the recording\");\n+  assert(Thread::current()->is_Java_thread(), \"need a Java thread to request compilations\");\n@@ -163,1 +159,0 @@\n-  const GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *decomps;\n@@ -165,0 +160,1 @@\n+    \/\/ The lock ensures we do not change the state while someone is recording\n@@ -166,7 +162,4 @@\n-    precond(is_recording_decompilations());\n-    decomps = const_cast<GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *>(decompilations);\n-    assert(decomps != nullptr, \"recording has not been started\");\n-    log_debug(crac)(\"Finishing recording decompilations and requesting %i recompilations\", decomps->length());\n-    \/\/ fence should allow the recorder threads to stop locking quicker\n-    Atomic::release_store_fence(&decompilations, static_cast<decltype(decompilations)>(nullptr));\n-    postcond(!is_recording_decompilations());\n+    assert(is_recording && decompilations != nullptr, \"unexpected state: is_recording = %s, decompilations = %p\",\n+           BOOL_TO_STR(is_recording), decompilations);\n+    Atomic::release_store_fence(&is_recording, false);\n+    log_debug(crac, compilation)(\"CRaCRecompiler state: RECORDING -> COMPILING (recorded: %i)\", decompilations->length());\n@@ -175,8 +168,31 @@\n-  \/\/ There can only be one compilation queued\/in-progress for a method at a\n-  \/\/ time, if there is one already for this method our request for it will just\n-  \/\/ be ignored.\n-  \/\/ TODO: we could optimize at least our own requests by placing requests for\n-  \/\/  the same method further away from each other.\n-  for (auto * const decompilation : *decomps) {\n-    request_recompilation(decompilation);\n-    delete decompilation;\n+  \/\/ No lock because while the state is COMPILING only metadata_do() can access\n+  \/\/ decompilations besides us and it does that only on safepoints. We also rely\n+  \/\/ on the caller to ensure that if another recording will be started later\n+  \/\/ that thread will see all of these updates.\n+  while (decompilations->is_nonempty()) {\n+    \/\/ TODO: there can only be one compilation queued\/in-progress for a method\n+    \/\/  at a time, if there is one already for this method our request for it\n+    \/\/  will just be ignored. We could optimize at least our own requests by\n+    \/\/  placing requests for the same method further away from each other.\n+    request_recompilation(decompilations->last()); \/\/ Order should not matter\n+    \/\/ Method must stay in the decompilations list until we're done processing\n+    \/\/ it to let metadata_do() defend it from being deleted, so only pop now\n+    delete decompilations->pop();\n+  }\n+  delete decompilations;\n+  decompilations = nullptr;\n+  log_debug(crac, compilation)(\"CRaCRecompiler state: COMPILING -> IDLE\");\n+}\n+\n+void CRaCRecompiler::record_decompilation(const nmethod &nmethod) {\n+  if (!Atomic::load_acquire(&is_recording)) {\n+    return; \/\/ Fast pass to not acquire a lock when no C\/R occurs (i.e. most of the time)\n+  }\n+\n+  const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n+  if (is_recording) { \/\/ Re-check under the lock to be safe from concurrent changes\n+    assert(decompilations != nullptr, \"unexpected state: is_recording = %s, decompilations = %p\",\n+           BOOL_TO_STR(is_recording), decompilations);\n+    decompilations->append(new CompilationInfo(nmethod.method(),\n+                                               nmethod.is_osr_method() ? nmethod.osr_entry_bci() : InvocationEntryBci,\n+                                               nmethod.comp_level()));\n@@ -184,1 +200,0 @@\n-  delete decomps;\n@@ -213,3 +228,2 @@\n-  auto * const decomps = const_cast<GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *>(decompilations);\n-  if (decomps != nullptr) {\n-    for (const auto *decompilation : *decomps) {\n+  if (decompilations != nullptr) {\n+    for (const auto *decompilation : *decompilations) {\n","filename":"src\/hotspot\/share\/runtime\/cracRecompiler.cpp","additions":64,"deletions":50,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-\/\/ occuring during checkpoint-restore (and shortly after) and requests their\n-\/\/ compilation immediately afterwards.\n+\/\/ occuring during checkpoint-restore and requests their compilation afterwards.\n@@ -43,3 +42,4 @@\n-\/\/ We don't recompile immediately because if the compilation manages to finish\n-\/\/ and get executed before the restoring is over it will trip over the temporary\n-\/\/ state again and get recompiled again, thus slowing the restoring.\n+\/\/ We don't recompile during checkpoint-restore because if the compilation\n+\/\/ manages to finish and get executed before the restoring is over it may trip\n+\/\/ over the temporary state again and get recompiled again, thus slowing the\n+\/\/ restoring.\n@@ -47,5 +47,5 @@\n-\/\/ We don't prevent methods from becoming non-compilable during\n-\/\/ checkpoint-restore because that likely means the methods had been recompiling\n-\/\/ a lot even before the checkpoint started so it is reasonable to expect them\n-\/\/ to continue doing so afterwards. Although having that could still help in\n-\/\/ some cases so it may be implemented at some point.\n+\/\/ Note that we don't prevent methods from becoming non-compilable during the\n+\/\/ above because that likely means the methods had been recompiling a lot even\n+\/\/ before the checkpoint started so it is reasonable to expect them to continue\n+\/\/ doing so afterwards. Although having that could still help in some cases so\n+\/\/ it may be implemented at some point.\n@@ -54,0 +54,2 @@\n+  \/\/ Caller must ensure that starting a recording happens-before finishing it\n+  \/\/ and finishing an old recording happens-before starting a new one.\n@@ -55,1 +57,0 @@\n-  static void record_decompilation(const nmethod &nmethod);\n@@ -58,0 +59,2 @@\n+  static void record_decompilation(const nmethod &nmethod);\n+\n","filename":"src\/hotspot\/share\/runtime\/cracRecompiler.hpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+    private static final String ENABLE_RECOMPILATION_PROPERTY = \"jdk.crac.enable-recompilation\";\n+    private static final String RECOMPILATION_DELAY_MS_PROPERTY = \"jdk.crac.recompilation-delay-ms\";\n@@ -70,2 +72,2 @@\n-        public static final long RECOMPILATION_DELAY_MS =\n-            Long.getLong(\"jdk.crac.recompilation-delay-ms\", 10L);\n+        public static final boolean ENABLE_RECOMPILATION =\n+            Boolean.parseBoolean(System.getProperty(ENABLE_RECOMPILATION_PROPERTY, \"true\"));\n@@ -356,0 +358,4 @@\n+        if (!FlagsHolder.ENABLE_RECOMPILATION) {\n+            return;\n+        }\n+\n@@ -371,2 +377,5 @@\n-        if (FlagsHolder.RECOMPILATION_DELAY_MS <= 0) {\n-            finishRecordingDecompilationsAndRecompile0();\n+        if (!FlagsHolder.ENABLE_RECOMPILATION) {\n+            if (System.getProperty(RECOMPILATION_DELAY_MS_PROPERTY) != null) {\n+                System.err.printf(\"Ignoring '%s' because '%s' is false\\n\",\n+                        RECOMPILATION_DELAY_MS_PROPERTY, ENABLE_RECOMPILATION_PROPERTY);\n+            }\n@@ -376,9 +385,2 @@\n-        \/\/ InnocuousThread not to add a thread into the user's thread group\n-        final Thread t = InnocuousThread.newThread(\"CRaC Recompiler\", () -> {\n-            try {\n-                Thread.sleep(FlagsHolder.RECOMPILATION_DELAY_MS);\n-            } catch (InterruptedException ignored) {\n-                \/\/ Finish even if interrupted by another checkpoint: asking for\n-                \/\/ recompilations earlier shouldn't hurt and is also safe in\n-                \/\/ case interrupted by user code somehow\n-            }\n+        final var recompilationDelayMs = Long.getLong(RECOMPILATION_DELAY_MS_PROPERTY, 10L);\n+        if (recompilationDelayMs <= 0) {\n@@ -386,4 +388,15 @@\n-        });\n-        t.setDaemon(true);\n-        t.start();\n-        recompilerThread = t;\n+        } else {\n+            \/\/ InnocuousThread not to add a thread into the user's thread group\n+            final Thread t = InnocuousThread.newThread(\"CRaC Recompiler\", () -> {\n+                try {\n+                    Thread.sleep(recompilationDelayMs);\n+                } catch (InterruptedException ignored) {\n+                    \/\/ Just finish earlier\n+                } finally {\n+                    finishRecordingDecompilationsAndRecompile0();\n+                }\n+            });\n+            t.setDaemon(true);\n+            t.start();\n+            recompilerThread = t;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":30,"deletions":17,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            public void beforeCheckpoint(Context<? extends Resource> context) {\n@@ -113,1 +113,1 @@\n-            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            public void afterRestore(Context<? extends Resource> context) {\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/CompilationLevelTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,2 @@\n-    private static final long STAGE_TIME_LIMIT_SEC = 30;\n+    \/\/ For debugging: set to a positive number to limit the time a stage (a timedDoWhile call) can take\n+    private static final long STAGE_TIME_LIMIT_SEC = 0;\n@@ -92,2 +93,2 @@\n-            .vmOption(\"-XX:+PrintCompilation\")\n-            .vmOption(\"-Xlog:crac=trace\");\n+            .vmOption(\"-XX:+PrintCompilation\") \/\/ To ease debugging, not actually used by the test\n+            .vmOption(\"-Xlog:crac*=trace\");\n@@ -129,1 +130,1 @@\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            public void beforeCheckpoint(Context<? extends Resource> context) {\n@@ -141,1 +142,1 @@\n-            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            public void afterRestore(Context<? extends Resource> context) {\n@@ -163,3 +164,6 @@\n-            assertLessThan((System.nanoTime() - startTime) \/ 1_000_000_000, STAGE_TIME_LIMIT_SEC,\n-                \"Task takes too long: \" + name\n-            );\n+            if (STAGE_TIME_LIMIT_SEC > 0) {\n+                assertLessThan(\n+                    (System.nanoTime() - startTime) \/ 1_000_000_000, STAGE_TIME_LIMIT_SEC,\n+                    \"Task takes too long: \" + name\n+                );\n+            }\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/NaturalDecompilationTest.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.crac.Context;\n-import jdk.crac.Core;\n-import jdk.crac.Resource;\n-import static jdk.test.lib.Asserts.*;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracEngine;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/*\n- * @test\n- * @summary Recompilation should not happen earlier than after the specified\n- *          delay after the restoring finishes.\n- * @library \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar wb.jar jdk.test.whitebox.WhiteBox\n- * @build RecompilationDelayTest\n- * @run driver jdk.test.lib.crac.CracTest -1\n- * @run driver jdk.test.lib.crac.CracTest 0\n- * @run driver jdk.test.lib.crac.CracTest 10000\n- *\/\n-public class RecompilationDelayTest implements CracTest {\n-    @CracTestArg(0)\n-    long delayMs;\n-\n-    @SuppressWarnings(\"unused\")\n-    private static void testMethod() {}\n-\n-    private static final String TEST_METHOD_NAME = \"testMethod\";\n-    private static final String MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE =\n-        \"\"\"\n-        [\n-            {\n-                match: \"%s.%s\",\n-                BackgroundCompilation: false\n-            }\n-        ]\n-        \"\"\".formatted(RecompilationDelayTest.class.getName().replace('.', '\/'), TEST_METHOD_NAME);\n-    private static final int TEST_METHOD_COMP_LEVEL = 4;\n-\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().engine(CracEngine.SIMULATE)\n-            .vmOption(\"-Xbootclasspath\/a:wb.jar\").vmOption(\"-XX:+UnlockDiagnosticVMOptions\").vmOption(\"-XX:+WhiteBoxAPI\")\n-            .javaOption(\"jdk.crac.recompilation-delay-ms\", Long.toString(delayMs))\n-            .startCheckpoint().waitForSuccess();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        final var whiteBox = WhiteBox.getWhiteBox();\n-        final var testMethodRef = RecompilationDelayTest.class.getDeclaredMethod(TEST_METHOD_NAME);\n-\n-        assertEquals(\n-            1, whiteBox.addCompilerDirective(MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE),\n-            \"Unexpected number of directives installed\"\n-        );\n-\n-        assertTrue(\n-            whiteBox.enqueueMethodForCompilation(testMethodRef, TEST_METHOD_COMP_LEVEL),\n-            \"Failed to compile immediately\"\n-        );\n-        assertEquals(\n-            TEST_METHOD_COMP_LEVEL, whiteBox.getMethodCompilationLevel(testMethodRef),\n-            \"Unexpected pre-C\/R compilation level\"\n-        );\n-\n-        final var resource = new Resource() {\n-            public long restoreFinishTimeMs = -1;\n-\n-            @Override\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {}\n-\n-            @Override\n-            public void afterRestore(Context<? extends Resource> context) throws Exception {\n-                if (delayMs <= 0) {\n-                    assertEquals(\n-                        1, whiteBox.deoptimizeMethod(testMethodRef),\n-                        \"Unexpected number of deoptimizations\"\n-                    );\n-                } else {\n-                    restoreFinishTimeMs = Math.floorDiv(System.nanoTime(), 1_000_000);\n-                }\n-            }\n-        };\n-        Core.getGlobalContext().register(resource);\n-\n-        Core.checkpointRestore();\n-\n-        if (delayMs > 0) {\n-            assertEquals(\n-                1, whiteBox.deoptimizeMethod(testMethodRef),\n-                \"Unexpected number of deoptimizations\"\n-            );\n-\n-            \/\/ Ensure the delay has not expired before we triggered the decompilation\n-            final var timeSinceRestoreFinishMs = Math.ceilDiv(System.nanoTime(), 1_000_000) - resource.restoreFinishTimeMs;\n-            assertLessThan(timeSinceRestoreFinishMs, delayMs, \"Specified delay is too low for this machine\");\n-\n-            \/\/ Wait for the delay to expire and give the concurrent compilations some time to finish\n-            Thread.sleep(delayMs + 500);\n-        }\n-\n-        assertEquals(\n-            TEST_METHOD_COMP_LEVEL, whiteBox.getMethodCompilationLevel(testMethodRef),\n-            \"Unexpected post-C\/R compilation level\"\n-        );\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/RecompilationDelayTest.java","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @summary Tests flags that control recompilation.\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar wb.jar jdk.test.whitebox.WhiteBox\n+ * @build RecompilationFlagsTest\n+ * @run driver jdk.test.lib.crac.CracTest true  -1\n+ * @run driver jdk.test.lib.crac.CracTest true  0\n+ * @run driver jdk.test.lib.crac.CracTest true  10000\n+ * @run driver jdk.test.lib.crac.CracTest false 10000\n+ *\/\n+public class RecompilationFlagsTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean enableRecompilation;\n+    @CracTestArg(1)\n+    long delayMs;\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void testMethod() {}\n+\n+    private static final String TEST_METHOD_NAME = \"testMethod\";\n+    private static final String MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE =\n+        \"\"\"\n+        [\n+            {\n+                match: \"%s.%s\",\n+                BackgroundCompilation: false\n+            }\n+        ]\n+        \"\"\".formatted(RecompilationFlagsTest.class.getName().replace('.', '\/'), TEST_METHOD_NAME);\n+    private static final int TEST_METHOD_COMP_LEVEL = 4;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final var builder = new CracBuilder().engine(CracEngine.SIMULATE)\n+            .vmOption(\"-Xbootclasspath\/a:wb.jar\").vmOption(\"-XX:+UnlockDiagnosticVMOptions\").vmOption(\"-XX:+WhiteBoxAPI\")\n+            .javaOption(\"jdk.crac.enable-recompilation\", Boolean.toString(enableRecompilation))\n+            .javaOption(\"jdk.crac.recompilation-delay-ms\", Long.toString(delayMs))\n+            .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        final var whiteBox = WhiteBox.getWhiteBox();\n+        final var testMethodRef = RecompilationFlagsTest.class.getDeclaredMethod(TEST_METHOD_NAME);\n+\n+        assertEquals(\n+            1, whiteBox.addCompilerDirective(MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE),\n+            \"Unexpected number of directives installed\"\n+        );\n+\n+        assertTrue(\n+            whiteBox.enqueueMethodForCompilation(testMethodRef, TEST_METHOD_COMP_LEVEL),\n+            \"Failed to compile immediately\"\n+        );\n+        assertEquals(\n+            TEST_METHOD_COMP_LEVEL, whiteBox.getMethodCompilationLevel(testMethodRef),\n+            \"Unexpected pre-C\/R compilation level\"\n+        );\n+\n+        final var resource = new Resource() {\n+            public long restoreFinishTimeMs = -1;\n+\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) {}\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) {\n+                if (delayMs <= 0) {\n+                    assertEquals(\n+                        1, whiteBox.deoptimizeMethod(testMethodRef),\n+                        \"Unexpected number of deoptimizations\"\n+                    );\n+                } else {\n+                    restoreFinishTimeMs = Math.floorDiv(System.nanoTime(), 1_000_000);\n+                }\n+            }\n+        };\n+        Core.getGlobalContext().register(resource);\n+\n+        Core.checkpointRestore();\n+\n+        if (delayMs > 0) {\n+            assertEquals(\n+                1, whiteBox.deoptimizeMethod(testMethodRef),\n+                \"Unexpected number of deoptimizations\"\n+            );\n+\n+            \/\/ Ensure the delay has not expired before we triggered the decompilation\n+            final var timeSinceRestoreFinishMs = Math.ceilDiv(System.nanoTime(), 1_000_000) - resource.restoreFinishTimeMs;\n+            assertLessThan(timeSinceRestoreFinishMs, delayMs, \"Specified delay is too low for this machine\");\n+\n+            \/\/ Wait for the delay to expire and give the concurrent compilations some time to finish\n+            Thread.sleep(delayMs + 500);\n+        }\n+\n+        if (enableRecompilation) {\n+            assertEquals(\n+                TEST_METHOD_COMP_LEVEL, whiteBox.getMethodCompilationLevel(testMethodRef),\n+                \"Unexpected post-C\/R compilation level\"\n+            );\n+        } else {\n+            assertFalse(whiteBox.isMethodCompiled(testMethodRef), \"Should not get recompiled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/RecompilationFlagsTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}