{"files":[{"patch":"@@ -803,1 +803,1 @@\n-    if (nm->make_not_entrant(\"C1 deoptimize\")) {\n+    if (nm->make_not_entrant(\"C1 deoptimize\", true \/* OK to recompile *\/)) {\n@@ -1095,1 +1095,1 @@\n-      nm->make_not_entrant(\"C1 code patch\");\n+      nm->make_not_entrant(\"C1 code patch\", true \/* OK to recompile *\/);\n@@ -1343,1 +1343,1 @@\n-      nm->make_not_entrant(\"C1 deoptimize for patching\");\n+      nm->make_not_entrant(\"C1 deoptimize for patching\", true \/* OK to recompile *\/);\n@@ -1471,1 +1471,1 @@\n-  nm->make_not_entrant(\"C1 predicate failed trap\");\n+  nm->make_not_entrant(\"C1 predicate failed trap\", true \/* OK to recompile *\/);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -805,1 +805,1 @@\n-      nm->make_not_entrant(\"CI replay\");\n+      nm->make_not_entrant(\"CI replay\", false \/* recompiling by ourselves *\/);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -76,0 +77,1 @@\n+    CRaCRecompiler::metadata_do(Metadata::mark_on_stack);\n","filename":"src\/hotspot\/share\/classfile\/metadataOnStackMark.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1364,1 +1364,1 @@\n-      nm->make_not_entrant(\"marked for deoptimization\");\n+      nm->make_not_entrant(\"marked for deoptimization\", true \/* OK to recompile *\/);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -2005,1 +2006,1 @@\n-bool nmethod::make_not_entrant(const char* reason) {\n+bool nmethod::make_not_entrant(const char* reason, bool can_schedule_recompilation) {\n@@ -2099,0 +2100,4 @@\n+  if (can_schedule_recompilation) {\n+    CRaCRecompiler::record_decompilation(*this);\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -636,2 +636,7 @@\n-  bool  make_not_entrant(const char* reason);\n-  bool  make_not_used()    { return make_not_entrant(\"not used\"); }\n+  \/\/\n+  \/\/ can_schedule_recompilation should be true if the decompilation\n+  \/\/ is triggered by an application state change and it makes sense\n+  \/\/ to request recompilation of the method as soon as the state\n+  \/\/ becomes stable again.\n+  bool  make_not_entrant(const char* reason, bool can_schedule_recompilation);\n+  bool  make_not_used()    { return make_not_entrant(\"not used\", false \/* likely already recompiling *\/); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -799,1 +799,1 @@\n-          osr_nm->make_not_entrant(\"OSR invalidation for compiling with C1\");\n+          osr_nm->make_not_entrant(\"OSR invalidation for compiling with C1\", false \/* recompiling by ourselves *\/);\n@@ -1204,1 +1204,1 @@\n-            nm->make_not_entrant(\"OSR invalidation, back branch\");\n+            nm->make_not_entrant(\"OSR invalidation, back branch\", false \/* recompiling by ourselves *\/);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -1243,0 +1244,9 @@\n+    \/\/ Ensure the method has not gotten compiled on a better level since CRaC\n+    \/\/ recorded its decompilation. We do it this late to ensure there is no race\n+    \/\/ between the recompilation requesting thread and other threads requesting\n+    \/\/ compilation through the usual routes.\n+    if (compile_reason == CompileTask::Reason_CRaC &&\n+        !CRaCRecompiler::is_recompilation_relevant(method, osr_bci, comp_level)) {\n+      return;\n+    }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+      Reason_CRaC,             \/\/ CRaC-initiated recompilation\n@@ -77,1 +78,2 @@\n-      \"bootstrap\"\n+      \"bootstrap\",\n+      \"crac\"\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1187,0 +1187,6 @@\n+JNIEXPORT void JNICALL\n+JVM_StartRecordingDecompilations(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL\n+JVM_FinishRecordingDecompilationsAndRecompile(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1372,1 +1372,1 @@\n-    code->make_not_entrant(\"JVMCI reprofile\");\n+    code->make_not_entrant(\"JVMCI reprofile\", false \/* trust the compiler, ideally should be a parameter *\/);\n@@ -1812,1 +1812,2 @@\n-    fst.current()->cb()->as_nmethod()->make_not_entrant(\"JVMCI materialize virtual objects\");\n+    fst.current()->cb()->as_nmethod()->make_not_entrant(\"JVMCI materialize virtual objects\",\n+                                                        false \/* likely not caused by app state change *\/);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1779,1 +1779,1 @@\n-    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\");\n+    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\", false \/* trust the compiler, ideally should be a parameter *\/);\n@@ -1788,1 +1788,1 @@\n-    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\");\n+    nm->make_not_entrant(\"JVMCI invalidate nmethod mirror\", false \/* trust the compiler, ideally should be a parameter *\/);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2199,1 +2199,1 @@\n-              old->make_not_entrant(\"JVMCI register method\");\n+              old->make_not_entrant(\"JVMCI register method\", false \/* already being replaced *\/);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3498,1 +3498,1 @@\n-      inv->make_not_entrant(\"OSR invalidation of lower levels\");\n+      inv->make_not_entrant(\"OSR invalidation of lower levels\", false \/* already being replaced *\/);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -982,1 +982,1 @@\n-    nm->make_not_entrant(\"set native function\");\n+    nm->make_not_entrant(\"set native function\", false \/* replaced by native function *\/);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+#include \"runtime\/cracRecompiler.hpp\"\n@@ -3700,0 +3701,8 @@\n+JVM_ENTRY(void, JVM_StartRecordingDecompilations(JNIEnv *env))\n+  CRaCRecompiler::start_recording_decompilations();\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_FinishRecordingDecompilationsAndRecompile(JNIEnv *env))\n+  CRaCRecompiler::finish_recording_decompilations_and_recompile();\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -797,1 +797,1 @@\n-                nm->make_not_entrant(\"Whitebox deoptimization\");\n+                nm->make_not_entrant(\"Whitebox deoptimization\", false \/* don't interfere with testing *\/);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"runtime\/cracRecompiler.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"compiler\/compileBroker.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/metadata.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ Records information about a decompiled method.\n+\/\/\n+\/\/ Safepoints may occur between the moments when it is recorded and used which\n+\/\/ can lead to the Method* getting freed. To fight this we use the same\n+\/\/ mechanisms as CompileTask does:\n+\/\/ 1. Method holder class may get unloaded. A jweak to class holder is used to\n+\/\/    checked for this, the method will not be re-compiled if this happens.\n+\/\/ 2. Method may get thrown away by RedefineClasses. We forbid this for all\n+\/\/    recorded methods by marking them \"on-stack\" for RedefineClasses.\n+class CompilationInfo : public CHeapObj<MemTag::mtInternal> {\n+public:\n+  CompilationInfo(Method *method, int bci, int comp_level) :\n+      _klass_holder(JNIHandles::make_weak_global(Handle(Thread::current(), method->method_holder()->klass_holder()))),\n+      _method(method), _bci(bci), _comp_level(comp_level) {}\n+  ~CompilationInfo() {\n+    if (_klass_holder != nullptr) {\n+      if (JNIHandles::is_weak_global_handle(_klass_holder)) {\n+        JNIHandles::destroy_weak_global(_klass_holder);\n+      } else {\n+        JNIHandles::destroy_global(_klass_holder);\n+      }\n+    }\n+  }\n+  NONCOPYABLE(CompilationInfo);\n+\n+  Method *method() const { return _method; }\n+  int bci() const { return _bci; };\n+  int comp_level() const { return _comp_level; };\n+\n+  bool is_method_loaded() const {\n+    return _klass_holder == nullptr || \/\/ bootstrap loader is never unloaded\n+           JNIHandles::is_global_handle(_klass_holder) || \/\/ Strong handle keeps it loaded\n+           !JNIHandles::is_weak_global_cleared(_klass_holder); \/\/ Weak handle but still loaded\n+  }\n+  bool keep_method_loaded() {\n+    const NoSafepointVerifier nsv; \/\/ Ensure not unloaded concurrently\n+    if (!is_method_loaded()) {\n+      return false; \/\/ Already unloaded\n+    }\n+    JNIHandles::destroy_weak_global(_klass_holder);\n+    _klass_holder = JNIHandles::make_global(Handle(Thread::current(), method()->method_holder()->klass_holder()));\n+    postcond(is_method_loaded());\n+    return true;\n+  }\n+\n+private:\n+  jweak _klass_holder;\n+  Method * const _method;\n+  const int _bci;\n+  const int _comp_level;\n+};\n+\n+static void request_recompilation(CompilationInfo *info) {\n+  if (!info->keep_method_loaded()) {\n+    log_trace(crac)(\"Skipping recompilation: <unloaded method>, bci=%i, comp_level=%i — got unloaded\",\n+                    info->bci(), info->comp_level());\n+    return;\n+  }\n+  assert(Method::is_valid_method(info->method()), \"sanity check\");\n+\n+  if (log_is_enabled(Trace, crac)) {\n+    ResourceMark rm;\n+    log_trace(crac)(\"Requesting recompilation: %s, bci=%i, comp_level=%i\",\n+                    info->method()->external_name(), info->bci(), info->comp_level());\n+  }\n+\n+  auto * const THREAD = JavaThread::current();\n+  \/\/ Note: this does not guarantee the method will get compiled; e.g. there may\n+  \/\/ already be compilation tasks for this method (even if on another level or\n+  \/\/ OSR-BCI) or it may have gotten not-compilable since it was recorded.\n+  CompileBroker::compile_method(methodHandle(THREAD, info->method()), info->bci(), info->comp_level(),\n+                                methodHandle(), 0, CompileTask::Reason_CRaC, THREAD);\n+  guarantee(!HAS_PENDING_EXCEPTION, \"the method should have been successfully compiled before\");\n+}\n+\n+static Mutex *decompilations_lock;\n+static volatile GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *decompilations;\n+\n+static bool is_recording_decompilations() {\n+  return Atomic::load_acquire(&decompilations) != nullptr;\n+}\n+\n+void CRaCRecompiler::start_recording_decompilations() {\n+  if (decompilations_lock == nullptr) {\n+    \/\/ Rank is nosafepoint - 1 because it should be acquirable when holding MDOExtraData_lock ranked nosafepoint\n+    decompilations_lock = new Mutex(Mutex::nosafepoint - 1, \"CRaCRecompiler_lock\");\n+  }\n+  const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n+  precond(!is_recording_decompilations());\n+  log_debug(crac)(\"Starting recording decompilations\");\n+  \/\/ release to ensuree decompilations_lock has been stored before the non-locked load in record_decompilation(),\n+  \/\/ fence to not proceed with C\/R until the recorder threads will see the recording update\n+  Atomic::release_store_fence(&decompilations, new GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal>());\n+  postcond(is_recording_decompilations());\n+}\n+\n+void CRaCRecompiler::record_decompilation(const nmethod &nmethod) {\n+  if (!is_recording_decompilations()) {\n+    return; \/\/ Fast pass to not acquire a lock when no C\/R occurs (i.e. most of the time)\n+  }\n+  const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n+  auto * const decomps = const_cast<GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *>(decompilations);\n+  if (decomps != nullptr) { \/\/ Re-check under the lock to be safe from concurrent deletion\n+    decomps->append(new CompilationInfo(nmethod.method(),\n+                                        nmethod.is_osr_method() ? nmethod.osr_entry_bci() : InvocationEntryBci,\n+                                        nmethod.comp_level()));\n+  }\n+}\n+\n+void CRaCRecompiler::finish_recording_decompilations_and_recompile() {\n+  assert(Thread::current()->is_Java_thread(), \"need a Java thread\");\n+  assert(decompilations_lock != nullptr, \"lock must be initialized when starting the recording\");\n+\n+  const GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *decomps;\n+  {\n+    const MutexLocker ml(decompilations_lock, Mutex::_no_safepoint_check_flag);\n+    precond(is_recording_decompilations());\n+    decomps = const_cast<GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *>(decompilations);\n+    assert(decomps != nullptr, \"recording has not been started\");\n+    log_debug(crac)(\"Finishing recording decompilations and requesting %i recompilations\", decomps->length());\n+    \/\/ fence should allow the recorder threads to stop locking quicker\n+    Atomic::release_store_fence(&decompilations, static_cast<decltype(decompilations)>(nullptr));\n+    postcond(!is_recording_decompilations());\n+  }\n+\n+  \/\/ There can only be one compilation queued\/in-progress for a method at a\n+  \/\/ time, if there is one already for this method our request for it will just\n+  \/\/ be ignored.\n+  \/\/ TODO: we could optimize at least our own requests by placing requests for\n+  \/\/  the same method further away from each other.\n+  for (auto * const decompilation : *decomps) {\n+    request_recompilation(decompilation);\n+    delete decompilation;\n+  }\n+  delete decomps;\n+}\n+\n+bool CRaCRecompiler::is_recompilation_relevant(const methodHandle &method, int bci, int comp_level) {\n+  const nmethod *current_nmethod = bci == InvocationEntryBci ?\n+      method->code() :\n+      method->lookup_osr_nmethod_for(bci, CompLevel::CompLevel_any, false);\n+  const CompLevel current_comp_level = current_nmethod != nullptr ?\n+    checked_cast<CompLevel>(current_nmethod->comp_level()) :\n+    CompLevel::CompLevel_none;\n+  switch (current_comp_level) {\n+    case CompLevel::CompLevel_none:\n+      assert(comp_level > CompLevel::CompLevel_none, \"must be compiled\");\n+      return true; \/\/ JIT is better than interpreter\n+    case CompLevel::CompLevel_simple:\n+    case CompLevel::CompLevel_full_optimization:\n+      return false; \/\/ Already on a final level\n+    case CompLevel::CompLevel_limited_profile:\n+    case CompLevel::CompLevel_full_profile:\n+      return comp_level == CompLevel::CompLevel_full_optimization; \/\/ C2 is better than C1\n+    default:\n+      ShouldNotReachHere();\n+      return false;\n+  }\n+}\n+\n+void CRaCRecompiler::metadata_do(void f(Metadata *)) {\n+  assert_at_safepoint();\n+  \/\/ Since we are at a safepoint no synchronization is needed\n+  auto * const decomps = const_cast<GrowableArrayCHeap<CompilationInfo *, MemTag::mtInternal> *>(decompilations);\n+  if (decomps != nullptr) {\n+    for (const auto *decompilation : *decomps) {\n+      if (decompilation->is_method_loaded()) {\n+        f(decompilation->method());\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/cracRecompiler.cpp","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRACRECOMPILER_HPP\n+#define SHARE_RUNTIME_CRACRECOMPILER_HPP\n+\n+#include \"code\/nmethod.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/metadata.hpp\"\n+#include \"runtime\/handles.hpp\"\n+\n+\/\/ During checkpoint-restore there is a high chance that application state will\n+\/\/ temporarily change. This may trigger deoptimizations and make methods\n+\/\/ decompile (make nmethods non-entrant). After restore the application is\n+\/\/ likely to quickly return to its previous stable state but it will take some\n+\/\/ time to compile the decompiled methods back, probably to the same code as\n+\/\/ before.\n+\/\/\n+\/\/ To speed up such after-restore warmup this class records decompilations\n+\/\/ occuring during checkpoint-restore (and shortly after) and requests their\n+\/\/ compilation immediately afterwards.\n+\/\/\n+\/\/ We don't recompile immediately because if the compilation manages to finish\n+\/\/ and get executed before the restoring is over it will trip over the temporary\n+\/\/ state again and get recompiled again, thus slowing the restoring.\n+\/\/\n+\/\/ We don't prevent methods from becoming non-compilable during\n+\/\/ checkpoint-restore because that likely means the methods had been recompiling\n+\/\/ a lot even before the checkpoint started so it is reasonable to expect them\n+\/\/ to continue doing so afterwards. Although having that could still help in\n+\/\/ some cases so it may be implemented at some point.\n+class CRaCRecompiler : public AllStatic {\n+public:\n+  static void start_recording_decompilations();\n+  static void record_decompilation(const nmethod &nmethod);\n+  static void finish_recording_decompilations_and_recompile();\n+\n+  \/\/ Whether compiling the method on this level is still needed.\n+  static bool is_recompilation_relevant(const methodHandle &method, int bci, int comp_level);\n+\n+  \/\/ RedefineClasses support.\n+  static void metadata_do(void f(Metadata *));\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_CRACRECOMPILER_HPP\n","filename":"src\/hotspot\/share\/runtime\/cracRecompiler.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -1816,1 +1816,1 @@\n-  nm->make_not_entrant(\"missing exception handler\");\n+  nm->make_not_entrant(\"missing exception handler\", true \/* OK to recompile *\/);\n@@ -2445,1 +2445,1 @@\n-      if (!nm->make_not_entrant(\"uncommon trap\")) {\n+      if (!nm->make_not_entrant(\"uncommon trap\", true \/* OK to recompile *\/)) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1342,1 +1342,1 @@\n-      nm->make_not_entrant(\"zombie\");\n+      nm->make_not_entrant(\"zombie\", false \/* don't interfere with testing\/debugging *\/);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2025, Azul Systems, Inc. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.internal.misc.InnocuousThread;\n@@ -69,0 +70,2 @@\n+        public static final long RECOMPILATION_DELAY_MS =\n+            Long.getLong(\"jdk.crac.recompilation-delay-ms\", 10L);\n@@ -304,0 +307,1 @@\n+            startRecordingDecompilations();\n@@ -312,0 +316,1 @@\n+                scheduleFinishRecordingDecompilationsAndRecompile();\n@@ -344,0 +349,42 @@\n+\n+    private static Thread recompilerThread;\n+\n+    private static native void startRecordingDecompilations0();\n+    private static native void finishRecordingDecompilationsAndRecompile0();\n+\n+    private static void startRecordingDecompilations() throws CheckpointException {\n+        if (recompilerThread != null) {\n+            \/\/ Finish the existing recording, if any\n+            recompilerThread.interrupt();\n+            try {\n+                recompilerThread.join();\n+            } catch (InterruptedException ie) {\n+                final CheckpointException ex = new CheckpointException();\n+                ex.addSuppressed(ie);\n+                throw ex;\n+            }\n+        }\n+        startRecordingDecompilations0();\n+    }\n+\n+    private static void scheduleFinishRecordingDecompilationsAndRecompile() {\n+        if (FlagsHolder.RECOMPILATION_DELAY_MS <= 0) {\n+            finishRecordingDecompilationsAndRecompile0();\n+            return;\n+        }\n+\n+        \/\/ InnocuousThread not to add a thread into the user's thread group\n+        final Thread t = InnocuousThread.newThread(\"CRaC Recompiler\", () -> {\n+            try {\n+                Thread.sleep(FlagsHolder.RECOMPILATION_DELAY_MS);\n+            } catch (InterruptedException ignored) {\n+                \/\/ Finish even if interrupted by another checkpoint: asking for\n+                \/\/ recompilations earlier shouldn't hurt and is also safe in\n+                \/\/ case interrupted by user code somehow\n+            }\n+            finishRecordingDecompilationsAndRecompile0();\n+        });\n+        t.setDaemon(true);\n+        t.start();\n+        recompilerThread = t;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2025, Azul Systems, Inc. All rights reserved.\n@@ -41,0 +41,10 @@\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_crac_mirror_Core_startRecordingDecompilations0(JNIEnv *env, jclass ignore) {\n+    JVM_StartRecordingDecompilations(env);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_internal_crac_mirror_Core_finishRecordingDecompilationsAndRecompile0(JNIEnv *env, jclass ignore) {\n+    JVM_FinishRecordingDecompilationsAndRecompile(env);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @summary Should recompile iff the recorded compilation level was better than\n+ *          the current one.\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar wb.jar jdk.test.whitebox.WhiteBox\n+ * @build CompilationLevelTest\n+ * @run driver jdk.test.lib.crac.CracTest 4 0 true\n+ * @run driver jdk.test.lib.crac.CracTest 4 3 true\n+ * @run driver jdk.test.lib.crac.CracTest 2 0 true\n+ * @run driver jdk.test.lib.crac.CracTest 1 4 false\n+ * @run driver jdk.test.lib.crac.CracTest 4 1 false\n+ * @run driver jdk.test.lib.crac.CracTest 3 2 false\n+ * @run driver jdk.test.lib.crac.CracTest 0 3 false\n+ *\/\n+public class CompilationLevelTest implements CracTest {\n+    @CracTestArg(0)\n+    int preCrCompilationLevel;\n+    @CracTestArg(1)\n+    int inCrCompilationLevel;\n+    @CracTestArg(2)\n+    boolean shouldRecompile;\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void testMethod() {}\n+\n+    private static final String TEST_METHOD_NAME = \"testMethod\";\n+    private static final String MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE =\n+        \"\"\"\n+        [\n+            {\n+                match: \"%s.%s\",\n+                BackgroundCompilation: false\n+            }\n+        ]\n+        \"\"\".formatted(CompilationLevelTest.class.getName().replace('.', '\/'), TEST_METHOD_NAME);\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE)\n+            .vmOption(\"-Xbootclasspath\/a:wb.jar\").vmOption(\"-XX:+UnlockDiagnosticVMOptions\").vmOption(\"-XX:+WhiteBoxAPI\")\n+            .javaOption(\"jdk.crac.recompilation-delay-ms\", \"0\")\n+            .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        final var whiteBox = WhiteBox.getWhiteBox();\n+        final var testMethodRef = CompilationLevelTest.class.getDeclaredMethod(TEST_METHOD_NAME);\n+\n+        assertEquals(\n+            1, whiteBox.addCompilerDirective(MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE),\n+            \"Unexpected number of directives installed\"\n+        );\n+\n+        if (preCrCompilationLevel > 0) {\n+            assertTrue(\n+                whiteBox.enqueueMethodForCompilation(testMethodRef, preCrCompilationLevel),\n+                \"Failed to compile immediately\"\n+            );\n+        }\n+        assertEquals(\n+            preCrCompilationLevel, whiteBox.getMethodCompilationLevel(testMethodRef),\n+            \"Unexpected pre-C\/R compilation level\"\n+        );\n+\n+        final var resource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                if (preCrCompilationLevel > 0) {\n+                    assertEquals(\n+                        1, whiteBox.deoptimizeMethod(testMethodRef),\n+                        \"Unexpected number of deoptimizations\"\n+                    );\n+                }\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                if (inCrCompilationLevel > 0) {\n+                    assertTrue(\n+                        whiteBox.enqueueMethodForCompilation(testMethodRef, inCrCompilationLevel),\n+                        \"Failed to compile immediately\"\n+                    );\n+                }\n+                assertEquals(\n+                    inCrCompilationLevel, whiteBox.getMethodCompilationLevel(testMethodRef),\n+                    \"Unexpected in-C\/R compilation level\"\n+                );\n+            }\n+        };\n+        Core.getGlobalContext().register(resource);\n+\n+        Core.checkpointRestore();\n+\n+        final var expectedCompilationLevel = shouldRecompile ? preCrCompilationLevel : inCrCompilationLevel;\n+        assertEquals(\n+            expectedCompilationLevel, whiteBox.getMethodCompilationLevel(testMethodRef),\n+            \"Unexpected post-C\/R compilation level\"\n+        );\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/CompilationLevelTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Objects;\n+import java.util.function.BooleanSupplier;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @summary Tests recompilation of a method deoptimized because of reaching an\n+ *          uncompiled path (e.g. uncommon trap). Other recompiler tests rely on\n+ *          WhiteBox to force a method to compile\/decompile — this test is\n+ *          supposed to check a more real-life scenerio instead.\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar wb.jar jdk.test.whitebox.WhiteBox\n+ * @build NaturalDecompilationTest\n+ * @run driver jdk.test.lib.crac.CracTest TIERED\n+ * @run driver jdk.test.lib.crac.CracTest C1_ONLY\n+ * @run driver jdk.test.lib.crac.CracTest C2_ONLY\n+ *\/\n+public class NaturalDecompilationTest implements CracTest {\n+    private static final long STAGE_TIME_LIMIT_SEC = 30;\n+\n+    \/\/ The compilers have different deoptimization implementations so it is\n+    \/\/ worth to test each of them.\n+    public enum Variant {\n+        TIERED,\n+        C1_ONLY,\n+        C2_ONLY,\n+    };\n+\n+    @CracTestArg\n+    Variant variant;\n+\n+    private static void blackhole(@SuppressWarnings(\"unused\") Object o) {}\n+\n+    private static int testMethod(int i) {\n+        try {\n+            \/\/ A compiler intrinsic which triggers decompilation in both C1 and\n+            \/\/ C2 when it has to throw IndexOutOfBoundsException\n+            Objects.checkIndex(i, 10);\n+            return i;\n+        } catch (IndexOutOfBoundsException ignored) {\n+            return -1;\n+        }\n+    }\n+\n+    private static final String BLACKHOLE_NAME = \"blackhole\";\n+    private static final String TEST_METHOD_NAME = \"testMethod\";\n+\n+    private static final int TEST_ARG_EXPECTED = 0;\n+    private static final int TEST_ARG_UNEXPECTED = -1;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final var builder = new CracBuilder().engine(CracEngine.SIMULATE).captureOutput(true)\n+            .vmOption(\"-Xbootclasspath\/a:wb.jar\").vmOption(\"-XX:+UnlockDiagnosticVMOptions\").vmOption(\"-XX:+WhiteBoxAPI\")\n+            .javaOption(\"jdk.crac.recompilation-delay-ms\", \"0\")\n+            .vmOption(\"-XX:+UnlockExperimentalVMOptions\")\n+            .vmOption(\"-XX:CompileCommand=blackhole,\" + NaturalDecompilationTest.class.getName() + \".\" + BLACKHOLE_NAME)\n+            .vmOption(\"-XX:CompileCommand=dontinline,\" + NaturalDecompilationTest.class.getName() + \".\" + TEST_METHOD_NAME)\n+            .vmOption(\"-XX:+PrintCompilation\")\n+            .vmOption(\"-Xlog:crac=trace\");\n+        switch (variant) {\n+            case TIERED -> { \/* This is the default *\/ }\n+            case C1_ONLY -> builder.vmOption(\"-XX:TieredStopAtLevel=1\");\n+            case C2_ONLY -> builder.vmOption(\"-XX:-TieredCompilation\");\n+        }\n+\n+        \/\/ Must create an output analyzer before waiting for success, otherwise\n+        \/\/ on Windows PrintCompilation overflows the piping buffer and the\n+        \/\/ waiting never completes\n+        final var proc = builder.startCheckpoint();\n+        final var out = proc.outputAnalyzer();\n+        proc.waitForSuccess();\n+        out.shouldContain(\"Requesting recompilation: int \" + NaturalDecompilationTest.class.getName() + \".\" + TEST_METHOD_NAME + \"(int)\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        final var whiteBox = WhiteBox.getWhiteBox();\n+        final var testMethodRef = NaturalDecompilationTest.class.getDeclaredMethod(TEST_METHOD_NAME, int.class);\n+\n+        timedDoWhile(\"compilation\", () -> {\n+            for (int i = 0; i < 2000; i++) {\n+                final var res = testMethod(TEST_ARG_EXPECTED);\n+                blackhole(res);\n+            }\n+            try {\n+                Thread.sleep(500); \/\/ Time to compile\n+            } catch (InterruptedException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+            return whiteBox.isMethodCompiled(testMethodRef);\n+        });\n+\n+        final var resource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                assertTrue(whiteBox.isMethodCompiled(testMethodRef), \"Should still be compiled\");\n+                timedDoWhile(\"deoptimization\", () -> {\n+                    \/\/ We don't want to call to many times or the method may\n+                    \/\/ get compiled again. Normally just one call is enough\n+                    \/\/ to make it decompile,\n+                    testMethod(TEST_ARG_UNEXPECTED);\n+                    return !whiteBox.isMethodCompiled(testMethodRef);\n+                });\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                assertFalse(whiteBox.isMethodCompiled(testMethodRef), \"Should still be deoptimized\");\n+            }\n+        };\n+        Core.getGlobalContext().register(resource);\n+\n+        Core.checkpointRestore();\n+\n+        timedDoWhile(\"recompilation\", () -> {\n+            try {\n+                Thread.sleep(1000); \/\/ Time to recompile\n+            } catch (InterruptedException ex) {\n+                throw new RuntimeException(ex);\n+            }\n+            return whiteBox.isMethodCompiled(testMethodRef);\n+        });\n+    }\n+\n+    private static void timedDoWhile(String name, BooleanSupplier action) {\n+        final var startTime = System.nanoTime();\n+        boolean completed;\n+        do {\n+            assertLessThan((System.nanoTime() - startTime) \/ 1_000_000_000, STAGE_TIME_LIMIT_SEC,\n+                \"Task takes too long: \" + name\n+            );\n+            System.out.println(\"Running: \" + name);\n+            completed = action.getAsBoolean();\n+        } while (!completed);\n+        System.out.println(\"Completed: \" + name);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/NaturalDecompilationTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import static jdk.test.lib.Asserts.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @summary Recompilation should not happen earlier than after the specified\n+ *          delay after the restoring finishes.\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar wb.jar jdk.test.whitebox.WhiteBox\n+ * @build RecompilationDelayTest\n+ * @run driver jdk.test.lib.crac.CracTest -1\n+ * @run driver jdk.test.lib.crac.CracTest 0\n+ * @run driver jdk.test.lib.crac.CracTest 10000\n+ *\/\n+public class RecompilationDelayTest implements CracTest {\n+    @CracTestArg(0)\n+    long delayMs;\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void testMethod() {}\n+\n+    private static final String TEST_METHOD_NAME = \"testMethod\";\n+    private static final String MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE =\n+        \"\"\"\n+        [\n+            {\n+                match: \"%s.%s\",\n+                BackgroundCompilation: false\n+            }\n+        ]\n+        \"\"\".formatted(RecompilationDelayTest.class.getName().replace('.', '\/'), TEST_METHOD_NAME);\n+    private static final int TEST_METHOD_COMP_LEVEL = 4;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE)\n+            .vmOption(\"-Xbootclasspath\/a:wb.jar\").vmOption(\"-XX:+UnlockDiagnosticVMOptions\").vmOption(\"-XX:+WhiteBoxAPI\")\n+            .javaOption(\"jdk.crac.recompilation-delay-ms\", Long.toString(delayMs))\n+            .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        final var whiteBox = WhiteBox.getWhiteBox();\n+        final var testMethodRef = RecompilationDelayTest.class.getDeclaredMethod(TEST_METHOD_NAME);\n+\n+        assertEquals(\n+            1, whiteBox.addCompilerDirective(MAKE_TEST_METHOD_COMP_BLOCKING_DIRECTIVE),\n+            \"Unexpected number of directives installed\"\n+        );\n+\n+        assertTrue(\n+            whiteBox.enqueueMethodForCompilation(testMethodRef, TEST_METHOD_COMP_LEVEL),\n+            \"Failed to compile immediately\"\n+        );\n+        assertEquals(\n+            TEST_METHOD_COMP_LEVEL, whiteBox.getMethodCompilationLevel(testMethodRef),\n+            \"Unexpected pre-C\/R compilation level\"\n+        );\n+\n+        final var resource = new Resource() {\n+            public long restoreFinishTimeMs = -1;\n+\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {}\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                if (delayMs <= 0) {\n+                    assertEquals(\n+                        1, whiteBox.deoptimizeMethod(testMethodRef),\n+                        \"Unexpected number of deoptimizations\"\n+                    );\n+                } else {\n+                    restoreFinishTimeMs = Math.floorDiv(System.nanoTime(), 1_000_000);\n+                }\n+            }\n+        };\n+        Core.getGlobalContext().register(resource);\n+\n+        Core.checkpointRestore();\n+\n+        if (delayMs > 0) {\n+            assertEquals(\n+                1, whiteBox.deoptimizeMethod(testMethodRef),\n+                \"Unexpected number of deoptimizations\"\n+            );\n+\n+            \/\/ Ensure the delay has not expired before we triggered the decompilation\n+            final var timeSinceRestoreFinishMs = Math.ceilDiv(System.nanoTime(), 1_000_000) - resource.restoreFinishTimeMs;\n+            assertLessThan(timeSinceRestoreFinishMs, delayMs, \"Specified delay is too low for this machine\");\n+\n+            \/\/ Wait for the delay to expire and give the concurrent compilations some time to finish\n+            Thread.sleep(delayMs + 500);\n+        }\n+\n+        assertEquals(\n+            TEST_METHOD_COMP_LEVEL, whiteBox.getMethodCompilationLevel(testMethodRef),\n+            \"Unexpected post-C\/R compilation level\"\n+        );\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recompiler\/RecompilationDelayTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}