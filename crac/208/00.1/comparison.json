{"files":[{"patch":"@@ -55,3 +55,3 @@\n-          - s390x\n-          - ppc64le\n-          - riscv64\n+          # - s390x\n+          # - ppc64le\n+          # - riscv64\n@@ -72,18 +72,18 @@\n-          - target-cpu: s390x\n-            gnu-arch: s390x\n-            debian-arch: s390x\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: bullseye\n-            tolerate-sysroot-errors: false\n-          - target-cpu: ppc64le\n-            gnu-arch: powerpc64le\n-            debian-arch: ppc64el\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: bullseye\n-            tolerate-sysroot-errors: false\n-          - target-cpu: riscv64\n-            gnu-arch: riscv64\n-            debian-arch: riscv64\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: sid\n-            tolerate-sysroot-errors: true\n+#          - target-cpu: s390x\n+#            gnu-arch: s390x\n+#            debian-arch: s390x\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: bullseye\n+#            tolerate-sysroot-errors: false\n+#          - target-cpu: ppc64le\n+#            gnu-arch: powerpc64le\n+#            debian-arch: ppc64el\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: bullseye\n+#            tolerate-sysroot-errors: false\n+#          - target-cpu: riscv64\n+#            gnu-arch: riscv64\n+#            debian-arch: riscv64\n+#            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+#            debian-version: sid\n+#            tolerate-sysroot-errors: true\n","filename":".github\/workflows\/build-cross-compile.yml","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+          - 'jdk\/crac'\n@@ -75,0 +76,3 @@\n+          - test-name: 'jdk\/crac'\n+            test-suite: 'test\/jdk\/jdk\/crac\/'\n+\n@@ -164,0 +168,6 @@\n+      - name: 'Setup CRIU'\n+        uses: .\/.github\/actions\/setup-criu\n+        with:\n+          jdk-path: ${{ steps.bundles.outputs.jdk-path }}\n+        if: runner.os == 'Linux' && matrix.test-name == 'jdk\/crac'\n+\n@@ -174,1 +184,1 @@\n-          JTREG='JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash;VERBOSE=fail,error,time;KEYWORDS=!headful'\n+          JTREG=\"JAVA_OPTIONS=$JAVA_OPTIONS;VERBOSE=fail,error,time;KEYWORDS=!headful\"\n@@ -178,0 +188,3 @@\n+          JAVA_OPTIONS: >-\n+            -XX:-CreateCoredumpOnCrash\n+            ${{ matrix.test-name == 'jdk\/crac' && '-Djdk.test.docker.retain.image=true -Djdk.test.crac.reuse.image=true' || '' }}\n","filename":".github\/workflows\/test.yml","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  LIB_SETUP_CRIU_CRAC\n@@ -316,0 +317,21 @@\n+\n+################################################################################\n+# Setup CRaC CRIU\n+################################################################################\n+AC_DEFUN_ONCE([LIB_SETUP_CRIU_CRAC],\n+[\n+  AC_ARG_WITH(criu-crac, [AS_HELP_STRING([--with-criu-crac],\n+      [use specified criu binary for CRaC implementation])])\n+\n+  AC_MSG_CHECKING([for criu-crac])\n+\n+  USE_CRIU_CRAC=\n+  if test -f \"${with_criu_crac}\"; then\n+    USE_CRIU_CRAC=\"${with_criu_crac}\"\n+    AC_MSG_RESULT([exists])\n+  else\n+    AC_MSG_RESULT([none])\n+  fi\n+\n+  AC_SUBST(USE_CRIU_CRAC)\n+])\n","filename":"make\/autoconf\/lib-bundled.m4","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -822,0 +822,2 @@\n+USE_CRIU_CRAC:=@USE_CRIU_CRAC@\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    EXCLUDES := jdk\/test\/lib\/containers jdk\/test\/lib\/security, \\\n+    EXCLUDES := jdk\/test\/lib\/containers\/cgroup jdk\/test\/lib\/containers\/systemd jdk\/test\/lib\/security, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -130,0 +132,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -282,0 +282,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,3 @@\n+  product(bool, CRaCCPUCountInit, false, \"Reinitialize number of CPUs \" \\\n+      \"during -XX:CRaCRestoreFrom\")                                     \\\n+                                                                        \\\n@@ -105,0 +108,5 @@\n+define_pd_global(ccstr, CRaCEngine, \"criuengine\");\n+\/\/ On some systems using SSSD files in this directory are left open\n+\/\/ after calling getpwuid_r, getpwname_r, getgrgid_r, getgrname_r\n+\/\/ or other functions in this family.\n+define_pd_global(ccstrlist, CRaCAllowedOpenFilePrefixes, \"\/var\/lib\/sss\/mc\/\");\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2017, 2022, Azul Systems, Inc. All rights reserved.\n@@ -27,0 +28,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -69,0 +71,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -88,0 +91,1 @@\n+# include <arpa\/inet.h>\n@@ -92,1 +96,0 @@\n-# include <sys\/stat.h>\n@@ -95,0 +98,1 @@\n+# include <sys\/sysmacros.h>\n@@ -112,1 +116,0 @@\n-# include <fcntl.h>\n@@ -121,0 +124,1 @@\n+# include <libgen.h>\n@@ -502,0 +506,5 @@\n+void os::Linux::initialize_processor_count() {\n+  set_processor_count((int) sysconf(_SC_NPROCESSORS_CONF));\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n@@ -503,1 +512,1 @@\n-  set_processor_count((int)sysconf(_SC_NPROCESSORS_CONF));\n+  initialize_processor_count();\n@@ -516,1 +525,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -60,0 +61,1 @@\n+  static void initialize_processor_count();\n@@ -277,0 +279,7 @@\n+  static void initialize_cpu_count() {\n+    initialize_processor_count();\n+    if (cpu_to_node() != NULL) {\n+      rebuild_cpu_to_node_map();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  static void initialize_time_counters(void);\n+  static void reset_time_counters(void);\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -248,0 +248,7 @@\n+  \/\/ Handle do_cleanup_unused here to print correct capacity below.\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    \/\/ HeapRegionManager::shrink_by do not allow remove all regions.\n+    \/\/ Make sure at least one is there.\n+    maximum_desired_capacity = G1HeapRegion::GrainBytes;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -136,0 +136,8 @@\n+\n+void G1UncommitRegionTask::finish_collection() {\n+  \/\/ If _instance is NULL G1 GC is either not in use or its collection has not yet been executed.\n+  if (_instance) {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    g1h->uncommit_regions((uint)-1);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -979,0 +980,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1133,0 +1141,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+  assert(CRaCMaxHeapSizeBeforeCheckpoint == 0 || CRaCMaxHeapSizeBeforeCheckpoint >= InitialHeapSize, \"Incompatible initial and maximum heap size before checkpoint\");\n+  assert(CRaCMaxHeapSizeBeforeCheckpoint == 0 || CRaCMaxHeapSizeBeforeCheckpoint <= MaxHeapSize, \"Incompatible initial and maximum heap size before checkpoint\");\n@@ -168,0 +170,20 @@\n+  if (FLAG_IS_CMDLINE(CRaCMaxHeapSizeBeforeCheckpoint)) {\n+    if (!UseG1GC) {\n+      vm_exit_during_initialization(\"CRaCMaxHeapSizeBeforeCheckpoint can be used only with G1 garbage collector.\");\n+    }\n+    if (CRaCMaxHeapSizeBeforeCheckpoint < InitialHeapSize) {\n+      if (FLAG_IS_CMDLINE(InitialHeapSize)) {\n+        vm_exit_during_initialization(\"Incompatible initial heap and maximum before checkpoint sizes specified\");\n+      } else {\n+        FLAG_SET_ERGO(InitialHeapSize, CRaCMaxHeapSizeBeforeCheckpoint);\n+      }\n+    }\n+    if (CRaCMaxHeapSizeBeforeCheckpoint > MaxHeapSize) {\n+      if (FLAG_IS_CMDLINE(MaxHeapSize)) {\n+        vm_exit_during_initialization(\"Incompatible heap sizes - maximum before checkpoint and absolute maximum - specified\");\n+      } else {\n+        FLAG_SET_ERGO(MaxHeapSize, CRaCMaxHeapSizeBeforeCheckpoint);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -170,0 +170,2 @@\n+void JNICALL jfr_start_after_restore(JNIEnv* env, jclass jvm);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-      (char*)\"nanosNow\", (char*)\"()J\", (void*)jfr_nanos_now\n+      (char*)\"nanosNow\", (char*)\"()J\", (void*)jfr_nanos_now,\n+      (char*)\"startFlightRecorderAfterRestore\", (char*)\"()V\", (void*)jfr_start_after_restore,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+static Symbol* request_start_after_restore_sym = nullptr;\n+static Symbol* request_start_after_restore_sig_sym = nullptr;\n@@ -63,0 +65,2 @@\n+    request_start_after_restore_sym = SymbolTable::new_permanent_symbol(\"requestStartAfterRestore\");\n+    request_start_after_restore_sig_sym = SymbolTable::new_permanent_symbol(\"()V\");\n@@ -211,0 +215,26 @@\n+\n+void JfrUpcalls::request_start_after_restore() {\n+  JavaThread * const THREAD = JavaThread::current();\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  if (!initialize(THREAD)) {\n+    log_error(jfr, system)(\"JfrUpcall could not be initialized.\");\n+    return;\n+  }\n+  JavaValue result(T_VOID);\n+  const Klass* klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    ResourceMark rm(THREAD);\n+    log_error(jfr, system)(\"JfrUpcall cannot resolve class %s, flight recording won't be started\",\n+      jvm_upcalls_class_sym->as_C_string());\n+    return;\n+  }\n+  assert(klass != nullptr, \"invariant\");\n+  JfrJavaArguments args(&result, klass, request_start_after_restore_sym, request_start_after_restore_sig_sym);\n+  JfrJavaSupport::call_static(&args, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    ResourceMark rm(THREAD);\n+    log_error(jfr, system)(\"JfrUpcall failed for %s\", request_start_after_restore_sym->as_C_string());\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -72,0 +72,2 @@\n+\n+  static void start_after_restore();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3725,0 +3726,5 @@\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+  EXT_EVENT_CRAC_AFTER_RESTORE = JVMTI_MIN_EVENT_TYPE_VAL-5,\n+  EXT_EVENT_CRAC_BEFORE_CHECKPOINT = JVMTI_MIN_EVENT_TYPE_VAL-4,\n@@ -50,1 +52,1 @@\n-  EXT_MIN_EVENT_TYPE_VAL = EXT_EVENT_VIRTUAL_THREAD_UNMOUNT,\n+  EXT_MIN_EVENT_TYPE_VAL = EXT_EVENT_CRAC_AFTER_RESTORE,\n@@ -58,0 +60,2 @@\n+  jvmtiExtensionEvent CracBeforeCheckpoint;\n+  jvmtiExtensionEvent CracAfterRestore;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2024, Azul Systems, Inc. All rights reserved.\n@@ -54,0 +55,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -79,0 +81,1 @@\n+#include <type_traits>\n@@ -91,0 +94,1 @@\n+char*  Arguments::_java_command_crac            = nullptr;\n@@ -553,0 +557,10 @@\n+  { \"CREngine\",                     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowedOpenFilePrefixes\",    JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowToSkipCheckpoint\",      JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRHeapDumpOnCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPrintResourcesOnCheckpoint\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTraceStartupTime\",           JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRDoThrowCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPauseOnCheckpointError\",     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTrace\",                      JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::undefined() },\n+\n@@ -564,0 +578,8 @@\n+  { \"CREngine\",                        \"CRaCEngine\" },\n+  { \"CRAllowedOpenFilePrefixes\",       \"CRaCAllowedOpenFilePrefixes\" },\n+  { \"CRAllowToSkipCheckpoint\",         \"CRaCAllowToSkipCheckpoint \"},\n+  { \"CRHeapDumpOnCheckpointException\", \"CRaCHeapDumpOnCheckpointException\" },\n+  { \"CRPrintResourcesOnCheckpoint\",    \"CRaCPrintResourcesOnCheckpoint\" },\n+  { \"CRTraceStartupTime\",              \"CRaCTraceStartupTime\" },\n+  { \"CRDoThrowCheckpointException\",    \"CRaCDoThrowCheckpointException\" },\n+  { \"CRPauseOnCheckpointError\",        \"CRaCPauseOnCheckpointError\" },\n@@ -1091,0 +1113,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == NULL) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1100,4 +1135,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1105,6 +1137,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == nullptr) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1241,1 +1269,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1243,2 +1273,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1248,1 +1276,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1256,1 +1285,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1258,1 +1287,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1260,0 +1289,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2140,0 +2176,78 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (!match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      continue;\n+    }\n+    \/\/ ccstr is never set to an empty string by the parser so we should not\n+    \/\/ treat an empty string value as the option being set. If it ever becomes\n+    \/\/ ccstrlist or the parser changes, the value check will need to be removed.\n+    static_assert(std::is_same<ccstr, decltype(CRaCRestoreFrom)>(), \"expected ccstr\");\n+    const char* eq = strchr(tail, '=');\n+    if (eq != nullptr && eq[1] != '\\0') {\n+      return true; \/\/ the value is not an empty string\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = NULL;\n+      const char* value = NULL;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.crac_command\") == 0) {\n+        char *old_java_command = _java_command_crac;\n+        _java_command_crac = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != NULL) {\n+          os::free(old_java_command);\n+        }\n+      } else {\n+        add_property(tail);\n+      }\n+\n+      if (key != tail) { \/\/ key was copied\n+        FreeHeap(const_cast<char *>(key));\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != NULL) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n+          return false;\n+        }\n+        build_jvm_flags(tail);\n+      }\n+    }\n+  }\n+\n+  postcond(CRaCRestoreFrom != nullptr);\n+\n+  return true;\n+}\n+\n@@ -2152,0 +2266,1 @@\n+        !match_option(option, \"-Dsun.java.crac_command\", &tail) &&\n@@ -2902,0 +3017,7 @@\n+  if (CRaCCheckpointTo && UseZGC) {\n+    \/\/ jdk.crac.impl.CheckpointOpenFileException: FD fd=3 type=regular path=\/memfd:java_heap (deleted)\n+    jio_fprintf(defaultStream::output_stream(),\n+      \"-XX:+UseZGC is currently unsupported for -XX:CRaCCheckpointTo.\\n\");\n+    return JNI_ERR;\n+  }\n+\n@@ -2956,0 +3078,8 @@\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return JNI_ERR;\n+  }\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n@@ -3967,0 +4097,7 @@\n+\n+void Arguments::reset_for_crac_restore() {\n+  if (!FLAG_IS_DEFAULT(LogVMOutput)){\n+    FLAG_SET_DEFAULT(LogVMOutput, false);\n+    FLAG_SET_DEFAULT(LogFile, nullptr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":153,"deletions":16,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -295,0 +295,2 @@\n+  \/\/ Before restore returns the same value as elapsed_counter()\n+  static jlong elapsed_counter_since_restore();\n@@ -486,0 +488,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n@@ -645,0 +649,2 @@\n+  static int execv(const char *path, const char *argv[]);\n+\n@@ -704,0 +710,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -707,0 +716,2 @@\n+  static bool           is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -324,0 +324,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n@@ -368,0 +373,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/Timer.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n@@ -37,0 +36,6 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -43,1 +48,1 @@\n-public final class CleanerImpl implements Runnable {\n+public final class CleanerImpl implements Runnable, JDKResource {\n@@ -49,0 +54,1 @@\n+    private static JavaLangRefAccess javaLangRefAccess = SharedSecrets.getJavaLangRefAccess();\n@@ -58,0 +64,2 @@\n+    volatile boolean forceCleanup = false;\n+\n@@ -113,0 +121,1 @@\n+        Core.Priority.CLEANERS.getContext().register(this);\n@@ -137,0 +146,23 @@\n+            if (forceCleanup) {\n+                ArrayList<PhantomCleanable<?>> refArr = new ArrayList<>();\n+                synchronized (activeList) {\n+                    for (var node = activeList.head; node != null; node = node.next) {\n+                        for (int i = node.size - 1; i >= 0; --i) {\n+                            if (node.arr[i].refersTo(null)) {\n+                                refArr.add(node.arr[i]);\n+                            }\n+                        }\n+                    }\n+                    for (var ref : refArr) {\n+                        try {\n+                            ref.clean();\n+                        } catch (Throwable e) {\n+                            \/\/ ignore exceptions from the cleanup action\n+                        }\n+                    }\n+                }\n+                synchronized (this) {\n+                    forceCleanup = false;\n+                    notify();\n+                }\n+            }\n@@ -140,1 +172,1 @@\n-                Cleanable ref = (Cleanable) queue.remove(60 * 1000L);\n+                Cleanable ref = (Cleanable) javaLangRefAccess.pollReferenceQueue(queue, 60 * 1000L);\n@@ -149,0 +181,23 @@\n+        synchronized (this) {\n+            \/\/ wakeup the checkpoint thread when we this thread terminates before noticing\n+            \/\/ the forced cleanup\n+            forceCleanup = false;\n+            notify();\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (activeList.isEmpty()) {\n+            \/\/ The thread is already terminated; don't wait for anything\n+            return;\n+        }\n+        forceCleanup = true;\n+        javaLangRefAccess.wakeupReferenceQueue(queue);\n+        while (forceCleanup) {\n+            wait();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n@@ -192,0 +247,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"PhantomCleanableRef:\"  + action;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":64,"deletions":4,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-\n@@ -179,0 +178,5 @@\n+    exports jdk.internal.crac to\n+        java.rmi,\n+        jdk.jfr,\n+        jdk.management.agent,\n+        jdk.sctp;\n@@ -416,0 +420,8 @@\n+    exports jdk.internal.crac.mirror to\n+        java.rmi,\n+        jdk.crac,\n+        jdk.jfr,\n+        jdk.management.agent;\n+\n+    exports jdk.internal.crac.mirror.impl to\n+        jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1076,0 +1076,15 @@\n+`-XX:CRaCCheckpointTo=`*directory*\n+:   The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+    a running Java program into an image directory. Restoring from the image should\n+    solve some of the problematic start-up and warm-up times.\n+\n+    This option defines a path to the snapshot which is currently a directory. The\n+    directory will be created if it does not exist, but no parent directories are\n+    created.\n+\n+`-XX:CRaCRestoreFrom=`*directory*\n+:   Restores a snapshot created by `-XX:CRaCCheckpointTo=`*directory*.\n+\n+`-XX:CRaCMinPid=`*value*\n+:   A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+\n@@ -1819,0 +1834,7 @@\n+`-XX:CPUFeatures=`*0xnumber*\n+:   CPU feature set, use `-XX:CPUFeatures=`*0xnumber* with `-XX:CRaCCheckpointTo` when\n+    you get an error during `-XX:CRaCRestoreFrom` on a different machine.\n+    `-XX:CPUFeatures=native` is the default.\n+    `-XX:CPUFeatures=generic` is compatible with any CPU but not as slow\n+    as `-XX:CPUFeatures=0`.\n+\n@@ -1986,0 +2008,4 @@\n+`-XX:+ShowCPUFeatures`\n+:   Show features of this CPU to be possibly used for the\n+    `-XX:CPUFeatures=`*0xnumber* option.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -114,0 +114,2 @@\n+# JDK-8310862 was closed but we're still seeing errors with the updated test\n+runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8310862 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        long maxHeapSize = Long.parseLong(analyzer.firstMatch(\"MaxHeapSize.+=\\\\s+(\\\\d+)\",1));\n+        long maxHeapSize = Long.parseLong(analyzer.firstMatch(\"\\\\bMaxHeapSize\\\\b.+=\\\\s+(\\\\d+)\",1));\n","filename":"test\/hotspot\/jtreg\/gc\/TestSmallHeap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}