{"files":[{"patch":"@@ -599,1 +599,1 @@\n-    int print_numbers(char *buf_orig, size_t buflen) const {\n+    int print_numbers(char *buf_orig, size_t buflen, bool hexonly = false) const {\n@@ -601,0 +601,1 @@\n+      const char *format = hexonly ? UINT64_FORMAT_0 : UINT64_FORMAT_X;\n@@ -602,1 +603,1 @@\n-        int res = jio_snprintf(buf, buflen, UINT64_FORMAT_X, u);\n+        int res = jio_snprintf(buf, buflen, format, u);\n@@ -606,1 +607,1 @@\n-        if (idx + 1 < features_bitmap_element_count()) {\n+        if (!hexonly && idx + 1 < features_bitmap_element_count()) {\n@@ -615,12 +616,0 @@\n-    int print_numbers_hexonly(char *buf_orig, size_t buflen) const {\n-      char *buf = buf_orig;\n-      apply_to_all_features([&](uint64_t u, int idx) {\n-        int res = jio_snprintf(buf, buflen, UINT64_FORMAT_0, u);\n-        buf += res;\n-        buflen -= res;\n-        assert(res > 0 && buflen >= 1, \"not enough temporary space allocated\");\n-      });\n-      *buf = 0;\n-      return buf - buf_orig;\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-static int append_time(char *buf, size_t buflen, bool iso8601, bool zero_pad, int width, long timeMillis) {\n+static int append_time(char *buf, size_t buflen, bool iso8601, bool zero_pad, int width, jlong timeMillis) {\n@@ -107,1 +107,1 @@\n-      log_warning(crac)(\"CRaCCheckpointTo=%s cannot set zero_pad or width for ISO-8601 time\", CRaCCheckpointTo);\n+      log_warning(crac)(\"Cannot use zero-padding or set width for ISO-8601 time in CRaCCheckpointTo=%s\", CRaCCheckpointTo);\n@@ -112,1 +112,1 @@\n-    if (gmtime_r(&time, &tms) == NULL) {\n+    if (os::gmtime_pd(&time, &tms) == nullptr) {\n@@ -129,1 +129,1 @@\n-    const char *suffixes[] = { \"k\", \"M\", \"G\" };\n+    static constexpr const char *suffixes[] = { \"k\", \"M\", \"G\" };\n@@ -139,1 +139,1 @@\n-#define check_no_width() do { \\\n+#define check_no_width_padding() do { \\\n@@ -141,1 +141,4 @@\n-      log_warning(crac)(\"CRaCCheckpointTo=%s cannot set width for %%%c\", CRaCCheckpointTo, c); \\\n+      log_warning(crac)(\"Cannot set width for %%%c in CRaCCheckpointTo=%s\", c, CRaCCheckpointTo); \\\n+    } \\\n+    if (zero_pad) { \\\n+      log_warning(crac)(\"Cannot use zero-padding for %%%c in CRaCCheckpointTo=%s\", c, CRaCCheckpointTo); \\\n@@ -147,2 +150,5 @@\n-    if (ret < 0 || (size_t) ret > buflen) { \\\n-      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s (@%zu, buffer size %zu)\", CRaCCheckpointTo, si, buflen); \\\n+    if (ret < 0) { \\\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s (too long)\", CRaCCheckpointTo); \\\n+      return false; \\\n+    } else if ((size_t) ret > buflen) { \\\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s\", CRaCCheckpointTo); \\\n@@ -155,1 +161,7 @@\n-bool crac::resolve_image_location(char *buf, size_t buflen, bool *fixed) {\n+static inline jlong boot_time() {\n+  \/\/ RuntimeMxBean.getStartTime() returns Management::vm_init_done_time() but this is not initialized\n+  \/\/ when CRaC checks the boot time early in the initialization phase\n+  return os::javaTimeMillis() - 1000 * (os::elapsed_counter() \/ os::elapsed_frequency());\n+}\n+\n+bool crac::interpolate_checkpoint_location(char *buf, size_t buflen, bool *fixed) {\n@@ -158,0 +170,4 @@\n+    if (buflen == 0) {\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s (too long)\", CRaCCheckpointTo);\n+      return false;\n+    }\n@@ -159,85 +175,1 @@\n-    if (c == '%') {\n-      si++;\n-      c = CRaCCheckpointTo[si];\n-      bool zero_pad = false;\n-      if (c == '0') {\n-        zero_pad = true;\n-        si++;\n-      }\n-      size_t width_start = si;\n-      while (CRaCCheckpointTo[si] >= '1' && CRaCCheckpointTo[si] <= '9') {\n-        ++si;\n-      }\n-      int width = -1;\n-      if (zero_pad && width_start == si) {\n-        log_error(crac)(\"CRaCCheckpointTo=%s contains a pattern with zero padding but no length\", CRaCCheckpointTo);\n-        return false;\n-      } else if (si > width_start) {\n-        width = atoi(&CRaCCheckpointTo[width_start]);\n-      }\n-      c = CRaCCheckpointTo[si];\n-      switch (c) {\n-      case '%':\n-        check_no_width();\n-        *(buf++) = '%';\n-        --buflen;\n-        break;\n-      case 'a': \/\/ CPU architecture; matches system property \"os.arch\"\n-          check_no_width();\n-#ifndef ARCHPROPNAME \/\/ defined by build scripts\n-# define ARCHPROPNAME \"unknown\"\n-#endif\n-        check_retval(snprintf(buf, buflen, \"%s\", ARCHPROPNAME));\n-        break;\n-      case 'f': { \/\/ CPU features\n-          struct VM_Version::VM_Features data;\n-          if (VM_Version::cpu_features_binary(&data)) {\n-            int ret = data.print_numbers_hexonly(buf, buflen);\n-            buf += ret;\n-            buflen -= ret;\n-          } \/\/ otherwise just empty string\n-        }\n-        break;\n-      case 'u': { \/\/ Random UUID (v4)\n-          check_no_width();\n-          *fixed = false; \/\/ FIXME?\n-          u4 time_mid_high = static_cast<u4>(os::random());\n-          u4 seq_and_node_low = static_cast<u4>(os::random());\n-          check_retval(snprintf(buf, buflen, \"%08x-%04x-4%03x-a%03x-%04x%08x\",\n-            static_cast<u4>(os::random()), time_mid_high >> 16, time_mid_high & 0xFFF,\n-            seq_and_node_low & 0xFFF, seq_and_node_low >> 16, static_cast<u4>(os::random())));\n-        }\n-        break;\n-      case 't': \/\/ checkpoint (current) time\n-      case 'T':\n-        *fixed = false;\n-        check_retval(append_time(buf, buflen, c == 't', zero_pad, width, os::javaTimeMillis()));\n-        break;\n-      case 'b': \/\/ boot time\n-      case 'B':\n-        check_retval(append_time(buf, buflen, c == 'b', zero_pad, width,\n-            os::javaTimeMillis() - 1000 * (os::elapsed_counter() \/ os::elapsed_frequency())));\n-        break;\n-      case 'r': \/\/ last restore time\n-      case 'R':\n-        check_retval(append_time(buf, buflen, c == 'r', zero_pad, width,\n-            os::javaTimeMillis() - 1000 * (os::elapsed_counter_since_restore() \/ os::elapsed_frequency())));\n-        break;\n-      case 'p': \/\/ PID\n-        check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::current_process_id()));\n-        break;\n-      case 'c': \/\/ Number of CPUs\n-        check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::active_processor_count()));\n-        break;\n-      case 'm': \/\/ Max heap size\n-        *fixed = false; \/\/ Heap size is not yet resolved when this is called from prepare_checkpoint()\n-        check_retval(append_size(buf, buflen, zero_pad, width, Universe::heap() != nullptr ? Universe::heap()->max_capacity() : 0));\n-        break;\n-      case 'g': \/\/ CRaC generation\n-        check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, _generation));\n-        break;\n-      default: \/* incl. terminating '\\0' *\/\n-        log_error(crac)(\"CRaCCheckpointTo=%s contains an invalid pattern\", CRaCCheckpointTo);\n-        return false;\n-      }\n-    } else {\n+    if (c != '%') {\n@@ -248,0 +180,43 @@\n+      } else {\n+        continue;\n+      }\n+    }\n+\n+    si++;\n+    c = CRaCCheckpointTo[si];\n+    bool zero_pad = false;\n+    if (c == '0') {\n+      zero_pad = true;\n+      si++;\n+    }\n+    size_t width_start = si;\n+    while (CRaCCheckpointTo[si] >= '0' && CRaCCheckpointTo[si] <= '9') {\n+      ++si;\n+    }\n+    if (zero_pad && width_start == si) {\n+      log_error(crac)(\"CRaCCheckpointTo=%s contains a pattern with zero padding but no length\", CRaCCheckpointTo);\n+      return false;\n+    }\n+    const int width = si > width_start ? atoi(&CRaCCheckpointTo[width_start]) : -1;\n+    c = CRaCCheckpointTo[si];\n+    switch (c) {\n+    case '%':\n+      check_no_width_padding();\n+      *(buf++) = '%';\n+      --buflen;\n+      break;\n+    case 'a': \/\/ CPU architecture; matches system property \"os.arch\"\n+        check_no_width_padding();\n+#ifndef ARCHPROPNAME\n+# error \"ARCHPROPNAME must be defined by build scripts\"\n+#endif\n+      check_retval(snprintf(buf, buflen, \"%s\", ARCHPROPNAME));\n+      break;\n+    case 'f': { \/\/ CPU features\n+        check_no_width_padding();\n+        struct VM_Version::VM_Features data;\n+        if (VM_Version::cpu_features_binary(&data)) {\n+          int ret = data.print_numbers(buf, buflen, true);\n+          buf += ret;\n+          buflen -= ret;\n+        } \/\/ otherwise just empty string\n@@ -249,0 +224,40 @@\n+      break;\n+    case 'u': { \/\/ Random UUID (v4)\n+        check_no_width_padding();\n+        *fixed = false; \/\/ FIXME?\n+        u4 time_mid_high = static_cast<u4>(os::random());\n+        u4 seq_and_node_low = static_cast<u4>(os::random());\n+        check_retval(snprintf(buf, buflen, \"%08x-%04x-4%03x-%04x-%04x%08x\",\n+          static_cast<u4>(os::random()), time_mid_high >> 16, time_mid_high & 0xFFF,\n+          0x8000 | (seq_and_node_low & 0x3FFF), seq_and_node_low >> 16, static_cast<u4>(os::random())));\n+      }\n+      break;\n+    case 't': \/\/ checkpoint (current) time\n+    case 'T':\n+      *fixed = false;\n+      check_retval(append_time(buf, buflen, c == 't', zero_pad, width, os::javaTimeMillis()));\n+      break;\n+    case 'b': \/\/ boot time\n+    case 'B':\n+      check_retval(append_time(buf, buflen, c == 'b', zero_pad, width, boot_time()));\n+      break;\n+    case 'r': \/\/ last restore time\n+    case 'R':\n+      check_retval(append_time(buf, buflen, c == 'r', zero_pad, width, _generation != 1 ? crac::restore_start_time() : boot_time()));\n+      break;\n+    case 'p': \/\/ PID\n+      check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::current_process_id()));\n+      break;\n+    case 'c': \/\/ Number of CPUs\n+      check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::active_processor_count()));\n+      break;\n+    case 'm': \/\/ Max heap size\n+      *fixed = false; \/\/ Heap size is not yet resolved when this is called from prepare_checkpoint()\n+      check_retval(append_size(buf, buflen, zero_pad, width, Universe::heap() != nullptr ? Universe::heap()->max_capacity() : 0));\n+      break;\n+    case 'g': \/\/ CRaC generation\n+      check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, _generation));\n+      break;\n+    default: \/* incl. terminating '\\0' *\/\n+      log_error(crac)(\"CRaCCheckpointTo=%s contains an invalid pattern\", CRaCCheckpointTo);\n+      return false;\n@@ -254,1 +269,1 @@\n-#undef check_no_width\n+#undef check_no_width_padding\n@@ -257,1 +272,1 @@\n-static bool ensure_image_location(const char *path, bool rm) {\n+static bool ensure_checkpoint_dir(const char *path, bool rm) {\n@@ -284,6 +299,0 @@\n-  char image_location[PATH_MAX];\n-  bool ignored;\n-  if (!resolve_image_location(image_location, sizeof(image_location), &ignored) ||\n-      !ensure_image_location(image_location, false)) {\n-    return JVM_CHECKPOINT_ERROR;\n-  }\n@@ -292,1 +301,5 @@\n-  if (!_engine->configure_image_location(image_location)) {\n+    char image_location[PATH_MAX];\n+  bool ignored;\n+  if (!interpolate_checkpoint_location(image_location, sizeof(image_location), &ignored) ||\n+      !ensure_checkpoint_dir(image_location, false) ||\n+      !_engine->configure_image_location(image_location)) {\n@@ -565,1 +578,1 @@\n-  if (!resolve_image_location(image_location, PATH_MAX, &fixed_path)) {\n+  if (!interpolate_checkpoint_location(image_location, PATH_MAX, &fixed_path)) {\n@@ -568,1 +581,1 @@\n-  if (fixed_path && (!ensure_image_location(image_location, true) || !engine->configure_image_location(image_location))) {\n+  if (fixed_path && (!ensure_checkpoint_dir(image_location, true) || !engine->configure_image_location(image_location))) {\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":118,"deletions":105,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  static bool resolve_image_location(char *buf, size_t buflen, bool *fixed);\n+  static bool interpolate_checkpoint_location(char *buf, size_t buflen, bool *fixed);\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  explicit CracEngine();\n+  CracEngine();\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.test.lib.Unit;\n@@ -29,0 +30,1 @@\n+import jdk.test.lib.util.FileUtils;\n@@ -72,0 +74,1 @@\n+        Path foo = Path.of(\"foo\");\n@@ -73,1 +76,1 @@\n-        new File(\"foo\").mkdirs();\n+        foo.toFile().mkdirs();\n@@ -78,2 +81,2 @@\n-                Platform.getOsArch(), pid, Runtime.getRuntime().availableProcessors(), 1024 * 1024 * 1024));\n-        assertTrue(f.exists(), \"Expect\" + f);\n+                Platform.getOsArch(), pid, Runtime.getRuntime().availableProcessors(), Unit.G.size()));\n+        assertTrue(f.exists(), \"Expect \" + f);\n@@ -81,1 +84,4 @@\n-        deleteDir(\"foo\");\n+\n+        FileUtils.deleteFileTreeWithRetry(foo);\n+        \/\/noinspection ResultOfMethodCallIgnored\n+        foo.toFile().mkdirs();\n@@ -85,1 +91,1 @@\n-        try (var stream = Files.list(Path.of(\"foo\"))) {\n+        try (var stream = Files.list(foo)) {\n@@ -96,1 +102,3 @@\n-        deleteDir(\"foo\");\n+        FileUtils.deleteFileTreeWithRetry(foo);\n+        \/\/noinspection ResultOfMethodCallIgnored\n+        foo.toFile().mkdirs();\n@@ -101,2 +109,2 @@\n-        try (var stream = Files.list(Path.of(\"foo\"))) {\n-            Path[] paths = stream.toArray(Path[]::new);\n+        try (var stream = Files.list(foo)) {\n+            Path[] paths = stream.sorted().toArray(Path[]::new);\n@@ -144,15 +152,0 @@\n-    private static void deleteDir(String dir) throws IOException {\n-        Path dirPath = Path.of(dir);\n-        try (var stream = Files.walk(dirPath)) {\n-            stream.sorted(Comparator.reverseOrder()).forEach(p -> {\n-                if (!p.equals(dirPath)) {\n-                    try {\n-                        Files.delete(p);\n-                    } catch (IOException e) {\n-                        throw new RuntimeException(e);\n-                    }\n-                }\n-            });\n-        }\n-    }\n-\n@@ -168,2 +161,0 @@\n-\n-\n","filename":"test\/jdk\/jdk\/crac\/PathPatternTest.java","additions":16,"deletions":25,"binary":false,"changes":41,"status":"modified"}]}