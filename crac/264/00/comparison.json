{"files":[{"patch":"@@ -686,0 +686,3 @@\n+  # setup arch name (the same as 'os.arch' system property)\n+  $1_DEFINES_CPU_JVM=\"${$1_DEFINES_CPU_JVM} -DARCHPROPNAME='\\\"$OPENJDK_TARGET_CPU_OSARCH\\\"'\"\n+\n","filename":"make\/autoconf\/flags-cflags.m4","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -615,0 +615,12 @@\n+    int print_numbers_hexonly(char *buf_orig, size_t buflen) const {\n+      char *buf = buf_orig;\n+      apply_to_all_features([&](uint64_t u, int idx) {\n+        int res = jio_snprintf(buf, buflen, UINT64_FORMAT_0, u);\n+        buf += res;\n+        buflen -= res;\n+        assert(res > 0 && buflen >= 1, \"not enough temporary space allocated\");\n+      });\n+      *buf = 0;\n+      return buf - buf_orig;\n+    }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+unsigned int crac::_generation = 1;\n+\n@@ -102,0 +104,173 @@\n+static int append_time(char *buf, size_t buflen, bool iso8601, bool zero_pad, int width, long timeMillis) {\n+  if (iso8601) {\n+    if (width >= 0 || zero_pad) {\n+      log_warning(crac)(\"CRaCCheckpointTo=%s cannot set zero_pad or width for ISO-8601 time\", CRaCCheckpointTo);\n+    }\n+    \/\/ os::iso8601_time formats with dashes and colons, we want the basic version\n+    time_t time = timeMillis \/ 1000;\n+    struct tm tms;\n+    if (gmtime_r(&time, &tms) == NULL) {\n+      log_warning(crac)(\"Cannot format time %ld\", timeMillis);\n+      return -1;\n+    }\n+    return strftime(buf, buflen, \"%Y%m%dT%H%M%SZ\", &tms);\n+  } else {\n+    \/\/ width -1 works too (means 1 char left aligned => we always print at least 1 char)\n+    return snprintf(buf, buflen, zero_pad ? \"%0*ld\" : \"%*ld\", width, timeMillis \/ 1000);\n+  }\n+}\n+\n+static int append_size(char *buf, size_t buflen, bool zero_pad, int width, size_t size) {\n+  if (zero_pad) {\n+    return snprintf(buf, buflen, \"%0*zu\", width, size);\n+  } else if (width >= 0) {\n+    return snprintf(buf, buflen, \"%*zu\", width, size);\n+  } else {\n+    const char *suffixes[] = { \"k\", \"M\", \"G\" };\n+    const char *suffix = \"\";\n+    for (size_t i = 0; i < ARRAY_SIZE(suffixes) && size != 0 && (size & 1023) == 0; ++i) {\n+      suffix = suffixes[i];\n+      size = size >> 10;\n+    }\n+    return snprintf(buf, buflen, \"%zu%s\", size, suffix);\n+  }\n+}\n+\n+#define check_no_width() do { \\\n+    if (width >= 0) { \\\n+      log_warning(crac)(\"CRaCCheckpointTo=%s cannot set width for %%%c\", CRaCCheckpointTo, c); \\\n+    } \\\n+  } while (false)\n+\n+#define check_retval(statement) do { \\\n+    int ret = statement; \\\n+    if (ret < 0 || (size_t) ret > buflen) { \\\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s (@%zu, buffer size %zu)\", CRaCCheckpointTo, si, buflen); \\\n+      return false; \\\n+    } \\\n+    buf += ret; \\\n+    buflen -= ret; \\\n+  } while (false)\n+\n+bool crac::resolve_image_location(char *buf, size_t buflen, bool *fixed) {\n+  *fixed = true;\n+  for (size_t si = 0; ; si++) {\n+    char c = CRaCCheckpointTo[si];\n+    if (c == '%') {\n+      si++;\n+      c = CRaCCheckpointTo[si];\n+      bool zero_pad = false;\n+      if (c == '0') {\n+        zero_pad = true;\n+        si++;\n+      }\n+      size_t width_start = si;\n+      while (CRaCCheckpointTo[si] >= '1' && CRaCCheckpointTo[si] <= '9') {\n+        ++si;\n+      }\n+      int width = -1;\n+      if (zero_pad && width_start == si) {\n+        log_error(crac)(\"CRaCCheckpointTo=%s contains a pattern with zero padding but no length\", CRaCCheckpointTo);\n+        return false;\n+      } else if (si > width_start) {\n+        width = atoi(&CRaCCheckpointTo[width_start]);\n+      }\n+      c = CRaCCheckpointTo[si];\n+      switch (c) {\n+      case '%':\n+        check_no_width();\n+        *(buf++) = '%';\n+        --buflen;\n+        break;\n+      case 'a': \/\/ CPU architecture; matches system property \"os.arch\"\n+          check_no_width();\n+#ifndef ARCHPROPNAME \/\/ defined by build scripts\n+# define ARCHPROPNAME \"unknown\"\n+#endif\n+        check_retval(snprintf(buf, buflen, \"%s\", ARCHPROPNAME));\n+        break;\n+      case 'f': { \/\/ CPU features\n+          struct VM_Version::VM_Features data;\n+          if (VM_Version::cpu_features_binary(&data)) {\n+            int ret = data.print_numbers_hexonly(buf, buflen);\n+            buf += ret;\n+            buflen -= ret;\n+          } \/\/ otherwise just empty string\n+        }\n+        break;\n+      case 'u': { \/\/ Random UUID (v4)\n+          check_no_width();\n+          *fixed = false; \/\/ FIXME?\n+          u4 time_mid_high = static_cast<u4>(os::random());\n+          u4 seq_and_node_low = static_cast<u4>(os::random());\n+          check_retval(snprintf(buf, buflen, \"%08x-%04x-4%03x-a%03x-%04x%08x\",\n+            static_cast<u4>(os::random()), time_mid_high >> 16, time_mid_high & 0xFFF,\n+            seq_and_node_low & 0xFFF, seq_and_node_low >> 16, static_cast<u4>(os::random())));\n+        }\n+        break;\n+      case 't': \/\/ checkpoint (current) time\n+      case 'T':\n+        *fixed = false;\n+        check_retval(append_time(buf, buflen, c == 't', zero_pad, width, os::javaTimeMillis()));\n+        break;\n+      case 'b': \/\/ boot time\n+      case 'B':\n+        check_retval(append_time(buf, buflen, c == 'b', zero_pad, width,\n+            os::javaTimeMillis() - 1000 * (os::elapsed_counter() \/ os::elapsed_frequency())));\n+        break;\n+      case 'r': \/\/ last restore time\n+      case 'R':\n+        check_retval(append_time(buf, buflen, c == 'r', zero_pad, width,\n+            os::javaTimeMillis() - 1000 * (os::elapsed_counter_since_restore() \/ os::elapsed_frequency())));\n+        break;\n+      case 'p': \/\/ PID\n+        check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::current_process_id()));\n+        break;\n+      case 'c': \/\/ Number of CPUs\n+        check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::active_processor_count()));\n+        break;\n+      case 'm': \/\/ Max heap size\n+        *fixed = false; \/\/ Heap size is not yet resolved when this is called from prepare_checkpoint()\n+        check_retval(append_size(buf, buflen, zero_pad, width, Universe::heap() != nullptr ? Universe::heap()->max_capacity() : 0));\n+        break;\n+      case 'g': \/\/ CRaC generation\n+        check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, _generation));\n+        break;\n+      default: \/* incl. terminating '\\0' *\/\n+        log_error(crac)(\"CRaCCheckpointTo=%s contains an invalid pattern\", CRaCCheckpointTo);\n+        return false;\n+      }\n+    } else {\n+      *(buf++) = c;\n+      --buflen;\n+      if (!c) {\n+        break;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+#undef check_no_width\n+#undef check_retval\n+\n+static bool ensure_image_location(const char *path, bool rm) {\n+  struct stat st;\n+  if (0 == os::stat(path, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      log_error(crac)(\"CRaCCheckpointTo=%s is not a directory\", path);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == os::mkdir(path)) {\n+      log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", path, os::strerror(errno));\n+      return false;\n+    }\n+    if (rm && -1 == os::rmdir(path)) {\n+      log_warning(crac)(\"Cannot cleanup after CRaCCheckpointTo check: %s\", os::strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -107,2 +282,8 @@\n-  \/\/ CRaCCheckpointTo can be changed on restore so we need to update the conf\n-  \/\/ to account for that.\n+  \/\/ CRaCCheckpointTo can be changed on restore, and if this contains a pattern\n+  \/\/ it might not have been configured => we need to update the conf.\n+  char image_location[PATH_MAX];\n+  bool ignored;\n+  if (!resolve_image_location(image_location, sizeof(image_location), &ignored) ||\n+      !ensure_image_location(image_location, false)) {\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n@@ -111,2 +292,1 @@\n-  if (restore_start_time() != -1 && \/\/ A way to detect we've restored at least once\n-      !_engine->configure_image_location(CRaCCheckpointTo)) {\n+  if (!_engine->configure_image_location(image_location)) {\n@@ -137,1 +317,1 @@\n-    log_error(crac)(\"CRaC engine failed to checkpoint to %s: error %i\", CRaCCheckpointTo, ret);\n+    log_error(crac)(\"CRaC engine failed to checkpoint to %s: error %i\", image_location, ret);\n@@ -278,0 +458,1 @@\n+  crac::_generation++;\n@@ -354,0 +535,18 @@\n+template<class T> class FutureRef {\n+private:\n+  T *_t;\n+public:\n+  FutureRef(T *t): _t(t) {}\n+  ~FutureRef() {\n+    delete _t;\n+  }\n+  T *operator->() {\n+    return _t;\n+  }\n+  T *extract() {\n+    T *tmp = _t;\n+    _t = nullptr;\n+    return tmp;\n+  }\n+};\n+\n@@ -357,17 +556,0 @@\n-  struct stat st;\n-  if (0 == os::stat(CRaCCheckpointTo, &st)) {\n-    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n-      log_error(crac)(\"CRaCCheckpointTo=%s is not a directory\", CRaCCheckpointTo);\n-      return false;\n-    }\n-  } else {\n-    if (-1 == os::mkdir(CRaCCheckpointTo)) {\n-      log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n-      return false;\n-    }\n-    if (-1 == os::rmdir(CRaCCheckpointTo)) {\n-      log_warning(crac)(\"Cannot cleanup after CRaCCheckpointTo check: %s\", os::strerror(errno));\n-      \/\/ not fatal\n-    }\n-  }\n-\n@@ -376,4 +558,9 @@\n-  _engine = new CracEngine(CRaCCheckpointTo);\n-  if (!_engine->is_initialized()) {\n-    delete _engine;\n-    _engine = nullptr;\n+  FutureRef<CracEngine> engine(new CracEngine());\n+  if (!engine->is_initialized()) {\n+    return false;\n+  }\n+\n+  char image_location[PATH_MAX];\n+  bool fixed_path;\n+  if (!resolve_image_location(image_location, PATH_MAX, &fixed_path)) {\n+    return false;\n@@ -381,1 +568,6 @@\n-  return _engine != nullptr;\n+  if (fixed_path && (!ensure_image_location(image_location, true) || !engine->configure_image_location(image_location))) {\n+    return false;\n+  }\n+\n+  _engine = engine.extract();\n+  return true;\n@@ -408,5 +600,0 @@\n-  if (-1 == os::mkdir(CRaCCheckpointTo) && errno != EEXIST) {\n-    log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n-  }\n-\n@@ -518,2 +705,2 @@\n-  CracEngine engine(CRaCRestoreFrom);\n-  if (!engine.is_initialized()) {\n+  CracEngine engine;\n+  if (!engine.is_initialized() || !engine.configure_image_location(CRaCRestoreFrom)) {\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":221,"deletions":34,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  static unsigned int _generation;\n@@ -78,0 +79,2 @@\n+\n+  static bool resolve_image_location(char *buf, size_t buflen, bool *fixed);\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-static crlib_conf_t *create_conf(const crlib_api_t &api, const char *image_location, const char *exec_location) {\n+static crlib_conf_t *create_conf(const crlib_api_t &api, const char *exec_location) {\n@@ -189,5 +189,0 @@\n-  if (image_location != nullptr && !configure_image_location(api, conf, image_location)) {\n-    api.destroy_conf(conf);\n-    return nullptr;\n-  }\n-\n@@ -245,1 +240,1 @@\n-CracEngine::CracEngine(const char *image_location) {\n+CracEngine::CracEngine() {\n@@ -324,1 +319,1 @@\n-  crlib_conf_t * const conf = create_conf(*api, image_location, exec_location);\n+  crlib_conf_t * const conf = create_conf(*api, exec_location);\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  explicit CracEngine(const char *image_location = nullptr);\n+  explicit CracEngine();\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.SimpleDateFormat;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @summary Checks that we can use patterns in CRaCCheckpointTo\n+ * @library \/test\/lib\n+ * @build PathPatternTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class PathPatternTest implements CracTest {\n+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyyMMdd'T'HHmmss\");\n+    private static final int MAX_DURATION_SECONDS = 300;\n+\n+    static {\n+        DATE_FORMAT.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    }\n+\n+    private static long runCheckpoints(String pattern, boolean pause) throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE)\n+                .vmOption(\"-Xmx1G\")\n+                .imageDir(pattern);\n+        if (pause) {\n+            builder.vmOption(\"-Dtest.pause=true\");\n+        }\n+        return builder.startCheckpoint().waitForSuccess().pid();\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        \/\/noinspection ResultOfMethodCallIgnored\n+        new File(\"foo\").mkdirs();\n+\n+        \/\/ Fixed fields only, no-timestamps\n+        long pid = runCheckpoints(\"foo\/cr_%%_%a_%p_%05c_%3m_%m_%g\", false);\n+        File f = new File(String.format(\"foo\/cr_%%_%s_%d_%05d_%d_1G_1\",\n+                Platform.getOsArch(), pid, Runtime.getRuntime().availableProcessors(), 1024 * 1024 * 1024));\n+        assertTrue(f.exists(), \"Expect\" + f);\n+        assertTrue(f.isDirectory());\n+        deleteDir(\"foo\");\n+\n+        \/\/ Pattern-based checks\n+        runCheckpoints(\"foo\/%u_%f_\", false);\n+        try (var stream = Files.list(Path.of(\"foo\"))) {\n+            AtomicInteger count = new AtomicInteger(0);\n+            assertTrue(stream.allMatch(d -> {\n+                count.incrementAndGet();\n+                if (!d.getFileName().toString().matches(\"\\\\p{XDigit}{8}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{12}_\\\\p{XDigit}{32}_\")) {\n+                    return false;\n+                }\n+                return d.toFile().isDirectory();\n+            }));\n+            assertEquals(count.intValue(), 2);\n+        }\n+        deleteDir(\"foo\");\n+\n+        \/\/ Timestamps and generation\n+        runCheckpoints(\"foo\/%T_%t_%015B_%b_%15R_%r_%02g\", true);\n+        Pattern pattern = Pattern.compile(\"(\\\\d+)_(\\\\d{8}T\\\\d{6})Z_0*(\\\\d+)_(\\\\d{8}T\\\\d{6})Z_ *(\\\\d+)_(\\\\d{8}T\\\\d{6})Z_0(\\\\d)\");\n+        try (var stream = Files.list(Path.of(\"foo\"))) {\n+            Path[] paths = stream.toArray(Path[]::new);\n+            assertEquals(paths.length, 2);\n+            Matcher matcher1 = pattern.matcher(paths[0].getFileName().toString());\n+            assertTrue(matcher1.matches());\n+            Matcher matcher2 = pattern.matcher(paths[1].getFileName().toString());\n+            assertTrue(matcher2.matches());\n+\n+            long t1 = Long.parseLong(matcher1.group(1));\n+            long t2 = Long.parseLong(matcher2.group(1));\n+            assertLT(t1, t2);\n+            long now = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n+            assertLTE(t2, now);\n+            assertGT(t1 + MAX_DURATION_SECONDS, now);\n+            checkDateEquals(matcher1.group(2), t1);\n+            checkDateEquals(matcher2.group(2), t2);\n+\n+            \/\/ boot time is constant\n+            long b1 = Long.parseLong(matcher1.group(3));\n+            long b2 = Long.parseLong(matcher1.group(3));\n+            assertEquals(b1, b2);\n+            assertLTE(b1, t1);\n+            assertGT(b1 + MAX_DURATION_SECONDS, now);\n+            checkDateEquals(matcher1.group(4), b1);\n+            checkDateEquals(matcher2.group(4), b2);\n+\n+            long r1 = Long.parseLong(matcher1.group(5));\n+            long r2 = Long.parseLong(matcher2.group(5));\n+            assertEquals(r1, b1);\n+            assertLTE(t1, r2);\n+            assertLTE(r2, now);\n+            checkDateEquals(matcher1.group(6), b1);\n+            checkDateEquals(matcher2.group(6), b2);\n+\n+            assertEquals(\"1\", matcher1.group(7));\n+            assertEquals(\"2\", matcher2.group(7));\n+        }\n+    }\n+\n+    private static void checkDateEquals(String str, long ts) {\n+        assertEquals(str, DATE_FORMAT.format(new Date(TimeUnit.SECONDS.toMillis(ts))));\n+    }\n+\n+    private static void deleteDir(String dir) throws IOException {\n+        Path dirPath = Path.of(dir);\n+        try (var stream = Files.walk(dirPath)) {\n+            stream.sorted(Comparator.reverseOrder()).forEach(p -> {\n+                if (!p.equals(dirPath)) {\n+                    try {\n+                        Files.delete(p);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        \/\/ Do two checkpoint-restores to ensure code behaves correctly after repeated execution\n+        Core.checkpointRestore();\n+        if (Boolean.getBoolean(\"test.pause\")) {\n+            Thread.sleep(1000);\n+        }\n+        Core.checkpointRestore();\n+    }\n+\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/PathPatternTest.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"}]}