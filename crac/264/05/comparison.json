{"files":[{"patch":"@@ -686,0 +686,3 @@\n+  # setup arch name (the same as 'os.arch' system property)\n+  $1_DEFINES_CPU_JVM=\"${$1_DEFINES_CPU_JVM} -DARCHPROPNAME='\\\"$OPENJDK_TARGET_CPU_OSARCH\\\"'\"\n+\n","filename":"make\/autoconf\/flags-cflags.m4","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,1 +67,3 @@\n-  struct VM_Features {};\n+  struct VM_Features {\n+    inline int print_numbers(char *buf_orig, size_t buflen, bool hexonly = false) const { return 0; }\n+  };\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,3 @@\n-  struct VM_Features {};\n+  struct VM_Features {\n+    inline int print_numbers(char *buf_orig, size_t buflen, bool hexonly = false) const { return 0; }\n+  };\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,3 @@\n-  struct VM_Features {};\n+  struct VM_Features {\n+    inline int print_numbers(char *buf_orig, size_t buflen, bool hexonly = false) const { return 0; }\n+  };\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -310,1 +310,3 @@\n-  struct VM_Features {};\n+  struct VM_Features {\n+    inline int print_numbers(char *buf_orig, size_t buflen, bool hexonly = false) const { return 0; }\n+  };\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -417,1 +417,3 @@\n-  struct VM_Features {};\n+  struct VM_Features {\n+    inline int print_numbers(char *buf_orig, size_t buflen, bool hexonly = false) const { return 0; }\n+  };\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  flush.print_numbers(buf, sizeof(buf));\n+  guarantee(flush.print_numbers(buf, sizeof(buf)) >= 0, \"buffer too short\");\n@@ -1264,1 +1264,1 @@\n-    handled.print_numbers(buf_handled, sizeof(buf_handled));\n+    guarantee(handled.print_numbers(buf_handled, sizeof(buf_handled)) >= 0, \"buffer too short\");\n@@ -1266,1 +1266,1 @@\n-    all_features.print_numbers(buf_all_features, sizeof(buf_all_features));\n+    guarantee(all_features.print_numbers(buf_all_features, sizeof(buf_all_features)) >= 0, \"buffer too short\");\n@@ -1285,1 +1285,1 @@\n-    _features.print_numbers(buf, sizeof(buf));\n+    guarantee(_features.print_numbers(buf, sizeof(buf)) >= 0, \"buffer too short\");\n@@ -1325,1 +1325,1 @@\n-    _features.print_numbers(buf, sizeof(buf));\n+    guarantee(_features.print_numbers(buf, sizeof(buf)) >= 0, \"buffer too short\");\n@@ -1337,1 +1337,1 @@\n-      sse2.print_numbers(buf, sizeof(buf));\n+      guarantee(sse2.print_numbers(buf, sizeof(buf)) >= 0, \"buffer too short\");\n@@ -2584,1 +2584,1 @@\n-    (data & _features).print_numbers(buf_use, sizeof(buf_use));\n+    guarantee((data & _features).print_numbers(buf_use, sizeof(buf_use)) >= 0, \"buffer too short\");\n@@ -2586,1 +2586,1 @@\n-    data.print_numbers(buf_have, sizeof(buf_have));\n+    guarantee(data.print_numbers(buf_have, sizeof(buf_have)) >= 0, \"buffer too short\");\n@@ -2674,1 +2674,1 @@\n-    CPUFeatures_parsed.print_numbers(buf_CPUFeatures_parsed, sizeof(buf_CPUFeatures_parsed));\n+    guarantee(CPUFeatures_parsed.print_numbers(buf_CPUFeatures_parsed, sizeof(buf_CPUFeatures_parsed)) >= 0, \"buffer too short\");\n@@ -2676,1 +2676,1 @@\n-    _features.print_numbers(buf_features, sizeof(buf_features));\n+    guarantee(_features.print_numbers(buf_features, sizeof(buf_features)) >= 0, \"buffer too short\");\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -599,1 +599,1 @@\n-    int print_numbers(char *buf_orig, size_t buflen) const {\n+    int print_numbers(char *buf_orig, size_t buflen, bool hexonly = false) const {\n@@ -601,0 +601,1 @@\n+      const char *format = hexonly ? UINT64_FORMAT_0 : UINT64_FORMAT_X;\n@@ -602,1 +603,5 @@\n-        int res = jio_snprintf(buf, buflen, UINT64_FORMAT_X, u);\n+        int res = jio_snprintf(buf, buflen, format, u);\n+        if (res < 0) {\n+          buflen = 0;\n+          return;\n+        }\n@@ -605,2 +610,1 @@\n-        assert(res > 0 && buflen >= 1, \"not enough temporary space allocated\");\n-        if (idx + 1 < features_bitmap_element_count()) {\n+        if (!hexonly && idx + 1 < features_bitmap_element_count() && buflen > 0) {\n@@ -611,0 +615,3 @@\n+      if (buflen == 0) {\n+        return -1;\n+      }\n@@ -617,0 +624,1 @@\n+      assert(res >= 0, \"buffer too short\");\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,1 +35,3 @@\n-  struct VM_Features {};\n+  struct VM_Features {\n+    inline int print_numbers(char *buf_orig, size_t buflen, bool hexonly = false) const { return 0; }\n+  };\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+unsigned int crac::_generation = 1;\n+\n@@ -102,0 +104,190 @@\n+static int append_time(char *buf, size_t buflen, bool iso8601, bool zero_pad, int width, jlong timeMillis) {\n+  if (iso8601) {\n+    if (width >= 0 || zero_pad) {\n+      log_warning(crac)(\"Cannot use zero-padding or set width for ISO-8601 time in CRaCCheckpointTo=%s\", CRaCCheckpointTo);\n+    }\n+    \/\/ os::iso8601_time formats with dashes and colons, we want the basic version\n+    time_t time = timeMillis \/ 1000;\n+    struct tm tms;\n+    if (os::gmtime_pd(&time, &tms) == nullptr) {\n+      log_warning(crac)(\"Cannot format time \" JLONG_FORMAT, timeMillis);\n+      return -1;\n+    }\n+    return (int) strftime(buf, buflen, \"%Y%m%dT%H%M%SZ\", &tms);\n+  } else {\n+    \/\/ width -1 works too (means 1 char left aligned => we always print at least 1 char)\n+    return snprintf(buf, buflen, zero_pad ? \"%0*\" PRId64 : \"%*\" PRId64, width, (int64_t) (timeMillis \/ 1000));\n+  }\n+}\n+\n+static int append_size(char *buf, size_t buflen, bool zero_pad, int width, size_t size) {\n+  if (zero_pad) {\n+    return snprintf(buf, buflen, \"%0*zu\", width, size);\n+  } else if (width >= 0) {\n+    return snprintf(buf, buflen, \"%*zu\", width, size);\n+  } else {\n+    static constexpr const char *suffixes[] = { \"k\", \"M\", \"G\" };\n+    const char *suffix = \"\";\n+    for (size_t i = 0; i < ARRAY_SIZE(suffixes) && size != 0 && (size & 1023) == 0; ++i) {\n+      suffix = suffixes[i];\n+      size = size >> 10;\n+    }\n+    return snprintf(buf, buflen, \"%zu%s\", size, suffix);\n+  }\n+}\n+\n+#define check_no_width_padding() do { \\\n+    if (width >= 0) { \\\n+      log_warning(crac)(\"Cannot set width for %%%c in CRaCCheckpointTo=%s\", c, CRaCCheckpointTo); \\\n+    } \\\n+    if (zero_pad) { \\\n+      log_warning(crac)(\"Cannot use zero-padding for %%%c in CRaCCheckpointTo=%s\", c, CRaCCheckpointTo); \\\n+    } \\\n+  } while (false)\n+\n+#define check_retval(statement) do { \\\n+    int ret = statement; \\\n+    if ((size_t) ret > buflen) { \\\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s (too long)\", CRaCCheckpointTo); \\\n+      return false; \\\n+    } else if (ret < 0) { \\\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s\", CRaCCheckpointTo); \\\n+      return false; \\\n+    } \\\n+    buf += ret; \\\n+    buflen -= ret; \\\n+  } while (false)\n+\n+static inline jlong boot_time() {\n+  \/\/ RuntimeMxBean.getStartTime() returns Management::vm_init_done_time() but this is not initialized\n+  \/\/ when CRaC checks the boot time early in the initialization phase\n+  return os::javaTimeMillis() - 1000 * (os::elapsed_counter() \/ os::elapsed_frequency());\n+}\n+\n+bool crac::interpolate_checkpoint_location(char *buf, size_t buflen, bool *fixed) {\n+  *fixed = true;\n+  for (size_t si = 0; ; si++) {\n+    if (buflen == 0) {\n+      log_error(crac)(\"Error interpolating CRaCCheckpointTo=%s (too long)\", CRaCCheckpointTo);\n+      return false;\n+    }\n+    char c = CRaCCheckpointTo[si];\n+    if (c != '%') {\n+      *(buf++) = c;\n+      --buflen;\n+      if (!c) {\n+        break;\n+      } else {\n+        continue;\n+      }\n+    }\n+\n+    si++;\n+    c = CRaCCheckpointTo[si];\n+    bool zero_pad = false;\n+    if (c == '0') {\n+      zero_pad = true;\n+      si++;\n+    }\n+    size_t width_start = si;\n+    while (CRaCCheckpointTo[si] >= '0' && CRaCCheckpointTo[si] <= '9') {\n+      ++si;\n+    }\n+    if (zero_pad && width_start == si) {\n+      log_error(crac)(\"CRaCCheckpointTo=%s contains a pattern with zero padding but no length\", CRaCCheckpointTo);\n+      return false;\n+    }\n+    const int width = si > width_start ? atoi(&CRaCCheckpointTo[width_start]) : -1;\n+    c = CRaCCheckpointTo[si];\n+    switch (c) {\n+    case '%':\n+      check_no_width_padding();\n+      *(buf++) = '%';\n+      --buflen;\n+      break;\n+    case 'a': \/\/ CPU architecture; matches system property \"os.arch\"\n+        check_no_width_padding();\n+#ifndef ARCHPROPNAME\n+# error \"ARCHPROPNAME must be defined by build scripts\"\n+#endif\n+      check_retval(snprintf(buf, buflen, \"%s\", ARCHPROPNAME));\n+      break;\n+    case 'f': { \/\/ CPU features\n+        check_no_width_padding();\n+        VM_Version::VM_Features data;\n+        if (VM_Version::cpu_features_binary(&data)) {\n+          check_retval(data.print_numbers(buf, buflen, true));\n+        } \/\/ otherwise just empty string\n+      }\n+      break;\n+    case 'u': { \/\/ Random UUID (v4)\n+        check_no_width_padding();\n+        *fixed = false; \/\/ FIXME?\n+        u4 time_mid_high = static_cast<u4>(os::random());\n+        u4 seq_and_node_low = static_cast<u4>(os::random());\n+        check_retval(snprintf(buf, buflen, \"%08x-%04x-4%03x-%04x-%04x%08x\",\n+          static_cast<u4>(os::random()), time_mid_high >> 16, time_mid_high & 0xFFF,\n+          0x8000 | (seq_and_node_low & 0x3FFF), seq_and_node_low >> 16, static_cast<u4>(os::random())));\n+      }\n+      break;\n+    case 't': \/\/ checkpoint (current) time\n+    case 'T':\n+      *fixed = false;\n+      check_retval(append_time(buf, buflen, c == 't', zero_pad, width, os::javaTimeMillis()));\n+      break;\n+    case 'b': \/\/ boot time\n+    case 'B':\n+      check_retval(append_time(buf, buflen, c == 'b', zero_pad, width, boot_time()));\n+      break;\n+    case 'r': \/\/ last restore time\n+    case 'R':\n+      check_retval(append_time(buf, buflen, c == 'r', zero_pad, width, _generation != 1 ? crac::restore_start_time() : boot_time()));\n+      break;\n+    case 'p': \/\/ PID\n+      check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::current_process_id()));\n+      break;\n+    case 'c': \/\/ Number of CPUs\n+      check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, os::active_processor_count()));\n+      break;\n+    case 'm': \/\/ Max heap size\n+      *fixed = false; \/\/ Heap size is not yet resolved when this is called from prepare_checkpoint()\n+      check_retval(append_size(buf, buflen, zero_pad, width, Universe::heap() != nullptr ? Universe::heap()->max_capacity() : 0));\n+      break;\n+    case 'g': \/\/ CRaC generation\n+      check_retval(snprintf(buf, buflen, zero_pad ? \"%0*d\" : \"%*d\", width, _generation));\n+      break;\n+    default: \/* incl. terminating '\\0' *\/\n+      log_error(crac)(\"CRaCCheckpointTo=%s contains an invalid pattern\", CRaCCheckpointTo);\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+#undef check_no_width_padding\n+#undef check_retval\n+\n+static bool ensure_checkpoint_dir(const char *path, bool rm) {\n+  struct stat st;\n+  if (0 == os::stat(path, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      log_error(crac)(\"CRaCCheckpointTo=%s is not a directory\", path);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == os::mkdir(path)) {\n+      log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", path, os::strerror(errno));\n+      return false;\n+    }\n+    if (rm && -1 == os::rmdir(path)) {\n+      log_warning(crac)(\"Cannot cleanup after CRaCCheckpointTo check: %s\", os::strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+  return true;\n+}\n+\n+#ifndef PATH_MAX\n+# define PATH_MAX 1024\n+#endif\n+\n@@ -107,2 +299,2 @@\n-  \/\/ CRaCCheckpointTo can be changed on restore so we need to update the conf\n-  \/\/ to account for that.\n+  \/\/ CRaCCheckpointTo can be changed on restore, and if this contains a pattern\n+  \/\/ it might not have been configured => we need to update the conf.\n@@ -111,2 +303,5 @@\n-  if (restore_start_time() != -1 && \/\/ A way to detect we've restored at least once\n-      !_engine->configure_image_location(CRaCCheckpointTo)) {\n+  char image_location[PATH_MAX];\n+  bool ignored;\n+  if (!interpolate_checkpoint_location(image_location, sizeof(image_location), &ignored) ||\n+      !ensure_checkpoint_dir(image_location, false) ||\n+      !_engine->configure_image_location(image_location)) {\n@@ -137,1 +332,1 @@\n-    log_error(crac)(\"CRaC engine failed to checkpoint to %s: error %i\", CRaCCheckpointTo, ret);\n+    log_error(crac)(\"CRaC engine failed to checkpoint to %s: error %i\", image_location, ret);\n@@ -278,0 +473,1 @@\n+  crac::_generation++;\n@@ -354,0 +550,18 @@\n+template<class T> class FutureRef {\n+private:\n+  T *_t;\n+public:\n+  FutureRef(T *t): _t(t) {}\n+  ~FutureRef() {\n+    delete _t;\n+  }\n+  T *operator->() {\n+    return _t;\n+  }\n+  T *extract() {\n+    T *tmp = _t;\n+    _t = nullptr;\n+    return tmp;\n+  }\n+};\n+\n@@ -357,17 +571,0 @@\n-  struct stat st;\n-  if (0 == os::stat(CRaCCheckpointTo, &st)) {\n-    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n-      log_error(crac)(\"CRaCCheckpointTo=%s is not a directory\", CRaCCheckpointTo);\n-      return false;\n-    }\n-  } else {\n-    if (-1 == os::mkdir(CRaCCheckpointTo)) {\n-      log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n-      return false;\n-    }\n-    if (-1 == os::rmdir(CRaCCheckpointTo)) {\n-      log_warning(crac)(\"Cannot cleanup after CRaCCheckpointTo check: %s\", os::strerror(errno));\n-      \/\/ not fatal\n-    }\n-  }\n-\n@@ -376,4 +573,3 @@\n-  _engine = new CracEngine(CRaCCheckpointTo);\n-  if (!_engine->is_initialized()) {\n-    delete _engine;\n-    _engine = nullptr;\n+  FutureRef<CracEngine> engine(new CracEngine());\n+  if (!engine->is_initialized()) {\n+    return false;\n@@ -381,1 +577,12 @@\n-  return _engine != nullptr;\n+\n+  char image_location[PATH_MAX];\n+  bool fixed_path;\n+  if (!interpolate_checkpoint_location(image_location, PATH_MAX, &fixed_path)) {\n+    return false;\n+  }\n+  if (fixed_path && (!ensure_checkpoint_dir(image_location, true) || !engine->configure_image_location(image_location))) {\n+    return false;\n+  }\n+\n+  _engine = engine.extract();\n+  return true;\n@@ -408,5 +615,0 @@\n-  if (-1 == os::mkdir(CRaCCheckpointTo) && errno != EEXIST) {\n-    log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n-  }\n-\n@@ -518,2 +720,2 @@\n-  CracEngine engine(CRaCRestoreFrom);\n-  if (!engine.is_initialized()) {\n+  CracEngine engine;\n+  if (!engine.is_initialized() || !engine.configure_image_location(CRaCRestoreFrom)) {\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":236,"deletions":34,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  static unsigned int _generation;\n@@ -78,0 +79,2 @@\n+\n+  static bool interpolate_checkpoint_location(char *buf, size_t buflen, bool *fixed);\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-static crlib_conf_t *create_conf(const crlib_api_t &api, const char *image_location, const char *exec_location) {\n+static crlib_conf_t *create_conf(const crlib_api_t &api, const char *exec_location) {\n@@ -189,5 +189,0 @@\n-  if (image_location != nullptr && !configure_image_location(api, conf, image_location)) {\n-    api.destroy_conf(conf);\n-    return nullptr;\n-  }\n-\n@@ -245,1 +240,1 @@\n-CracEngine::CracEngine(const char *image_location) {\n+CracEngine::CracEngine() {\n@@ -324,1 +319,1 @@\n-  crlib_conf_t * const conf = create_conf(*api, image_location, exec_location);\n+  crlib_conf_t * const conf = create_conf(*api, exec_location);\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  explicit CracEngine(const char *image_location = nullptr);\n+  CracEngine();\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1965,1 +1965,2 @@\n-          \"otherwise.\")                                                     \\\n+          \"otherwise. The path can contain placeholders (e.g. %p for PID);\" \\\n+          \" check documentation for pattern format.\")                       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1085,0 +1085,22 @@\n+    It is possible to use a pattern with automatically inferred values, using\n+    these placeholders:\n+    -   `%%`: single % character\n+    -   `%a`: architecture; the same value as system property 'os.arch'\n+    -   `%f`: CPU features hex string. Empty string if the architecture does not\n+              use optional CPU features.\n+    -   `%u`: UUID (version 4 = random)\n+    -   `%g`: checkpoint generation (starting with 1, 0 is reserved for ‘unknown’)\n+    -   `%t`: checkpoint date & time in ISO-8601 in UTC, basic format (without\n+              separators) with second precision, e.g. `20250909T141711Z`\n+    -   `%T`: checkpoint epoch time (second precision)\n+    -   `%b` and `%B`: process boot time (generation 1), same format as `%t` or `%T`\n+    -   `%r` and `%R`: last restore time, same format as `%t` or `%T`. In case\n+                       of generation 1 this is is the same as process boot time.\n+    -   `%p`: PID of checkpointed process\n+    -   `%c`: number of CPU cores\n+    -   `%m`: max heap size (`-Xmx`) in a user-friendly format - using G or M suffix\n+\n+    Numeric placeholders (`%T`, `%B`, `%R`, `%p`, `%c`, `%m` and `%g`) support\n+    an optional prefix with minimum width, padded with spaces or zeroes if the prefix\n+    starts with zero, e.g. `%3g` -> `  1`, `%03g` -> `001`.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Unit;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.util.FileUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.SimpleDateFormat;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @summary Checks that we can use patterns in CRaCCheckpointTo\n+ * @library \/test\/lib\n+ * @build PathPatternTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class PathPatternTest implements CracTest {\n+    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(\"yyyyMMdd'T'HHmmss\");\n+    private static final int MAX_DURATION_SECONDS = 300;\n+\n+    static {\n+        DATE_FORMAT.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    }\n+\n+    private static long runCheckpoints(String pattern, boolean pause) throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE)\n+                .vmOption(\"-Xmx1G\")\n+                .imageDir(pattern);\n+        if (pause) {\n+            builder.vmOption(\"-Dtest.pause=true\");\n+        }\n+        return builder.startCheckpoint().waitForSuccess().pid();\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path foo = Path.of(\"foo\");\n+        \/\/noinspection ResultOfMethodCallIgnored\n+        foo.toFile().mkdirs();\n+\n+        \/\/ Fixed fields only, no-timestamps\n+        long pid = runCheckpoints(\"foo\/cr_%%_%a_%p_%05c_%3m_%m_%g\", false);\n+        File f = new File(String.format(\"foo\/cr_%%_%s_%d_%05d_%d_1G_1\",\n+                Platform.getOsArch(), pid, Runtime.getRuntime().availableProcessors(), Unit.G.size()));\n+        assertTrue(f.exists(), \"Expect \" + f);\n+        assertTrue(f.isDirectory());\n+\n+        FileUtils.deleteFileTreeWithRetry(foo);\n+        \/\/noinspection ResultOfMethodCallIgnored\n+        foo.toFile().mkdirs();\n+\n+        \/\/ Pattern-based checks\n+        runCheckpoints(\"foo\/%u_%f_\", false);\n+        try (var stream = Files.list(foo)) {\n+            AtomicInteger count = new AtomicInteger(0);\n+            String featuresPattern = Platform.isX64() ? \"\\\\p{XDigit}{32}\" : \"\";\n+            assertTrue(stream.allMatch(d -> {\n+                count.incrementAndGet();\n+                if (!d.getFileName().toString().matches(\"\\\\p{XDigit}{8}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{12}_\" + featuresPattern + \"_\")) {\n+                    System.err.printf(\"Unexpected file: %s%nFull path: %s%n\", d.getFileName(), d);\n+                    return false;\n+                }\n+                return d.toFile().isDirectory();\n+            }));\n+            assertEquals(count.intValue(), 2);\n+        }\n+        FileUtils.deleteFileTreeWithRetry(foo);\n+        \/\/noinspection ResultOfMethodCallIgnored\n+        foo.toFile().mkdirs();\n+\n+        \/\/ Timestamps and generation\n+        runCheckpoints(\"foo\/%T_%t_%015B_%b_%15R_%r_%02g\", true);\n+        Pattern pattern = Pattern.compile(\"(\\\\d+)_(\\\\d{8}T\\\\d{6})Z_0*(\\\\d+)_(\\\\d{8}T\\\\d{6})Z_ *(\\\\d+)_(\\\\d{8}T\\\\d{6})Z_0(\\\\d)\");\n+        try (var stream = Files.list(foo)) {\n+            Path[] paths = stream.sorted().toArray(Path[]::new);\n+            assertEquals(paths.length, 2);\n+            System.err.println(\"IMAGE1: \" + paths[0]);\n+            System.err.println(\"IMAGE2: \" + paths[1]);\n+\n+            Matcher matcher1 = pattern.matcher(paths[0].getFileName().toString());\n+            assertTrue(matcher1.matches());\n+            Matcher matcher2 = pattern.matcher(paths[1].getFileName().toString());\n+            assertTrue(matcher2.matches());\n+\n+            long t1 = Long.parseLong(matcher1.group(1));\n+            long t2 = Long.parseLong(matcher2.group(1));\n+            assertLT(t1, t2);\n+            long now = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());\n+            assertLTE(t2, now);\n+            assertGT(t1 + MAX_DURATION_SECONDS, now);\n+            checkDateEquals(matcher1.group(2), t1);\n+            checkDateEquals(matcher2.group(2), t2);\n+\n+            \/\/ boot time is constant\n+            long b1 = Long.parseLong(matcher1.group(3));\n+            long b2 = Long.parseLong(matcher2.group(3));\n+            assertEquals(b1, b2);\n+            assertLTE(b1, t1);\n+            assertGT(b1 + MAX_DURATION_SECONDS, now);\n+            checkDateEquals(matcher1.group(4), b1);\n+            checkDateEquals(matcher2.group(4), b2);\n+\n+            long r1 = Long.parseLong(matcher1.group(5));\n+            long r2 = Long.parseLong(matcher2.group(5));\n+            assertEquals(r1, b1);\n+            assertLTE(t1, r2);\n+            assertLTE(r2, now);\n+            checkDateEquals(matcher1.group(6), b1);\n+            checkDateEquals(matcher2.group(6), b2);\n+\n+            assertEquals(\"1\", matcher1.group(7));\n+            assertEquals(\"2\", matcher2.group(7));\n+        }\n+    }\n+\n+    private static void checkDateEquals(String str, long ts) {\n+        assertEquals(str, DATE_FORMAT.format(new Date(TimeUnit.SECONDS.toMillis(ts))));\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        \/\/ Do two checkpoint-restores to ensure code behaves correctly after repeated execution\n+        Core.checkpointRestore();\n+        if (Boolean.getBoolean(\"test.pause\")) {\n+            Thread.sleep(1000);\n+        }\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/PathPatternTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}