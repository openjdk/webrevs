{"files":[{"patch":"@@ -0,0 +1,120 @@\n+\/\/ Copyright 2019, 2025, Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.*;\n+import static jdk.test.lib.Asserts.*;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test\n+ * @summary check that the recursive checkpoint is not allowed\n+ * @library \/test\/lib\n+ * @build RecursiveCheckpointTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest 10\n+ *\/\n+public class RecursiveCheckpointTest implements Resource, CracTest {\n+    private static final AtomicInteger counter = new AtomicInteger(0);\n+    private static final List<Throwable> throwables = Collections.synchronizedList(new ArrayList<>());\n+\n+    @CracTestArg\n+    int numThreads;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        builder.startCheckpoint().waitForSuccess();\n+    }\n+\n+    private static class TestThread extends Thread {\n+        public TestThread() {\n+            setUncaughtExceptionHandler(TestThread::handleException);\n+        }\n+\n+        private static void handleException(@SuppressWarnings(\"unused\") Thread thread, Throwable throwable) {\n+            throwables.add(throwable);\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                Core.checkpointRestore();\n+            } catch (CheckpointException | RestoreException e) {\n+                throw new IllegalStateException(\"C\/R failed\", e);\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        assertEquals(1, counter.incrementAndGet(), \"Concurrent checkpoint detected\");\n+        Thread.sleep(100);\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Recursive checkpoint should fail\");\n+        } catch (CheckpointException e) {\n+            \/\/ Expected exception\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        try {\n+            Thread.sleep(100);\n+            try {\n+                Core.checkpointRestore();\n+                fail(\"Recursive checkpoint should fail\");\n+            } catch (CheckpointException e) {\n+                \/\/ Expected exception\n+            }\n+        } finally {\n+            counter.decrementAndGet();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.getGlobalContext().register(new RecursiveCheckpointTest());\n+\n+        final var threads = new TestThread[numThreads];\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i] = new TestThread();\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i].join();\n+        }\n+\n+        if (!throwables.isEmpty()) {\n+            final var aggregated = new IllegalStateException(\"\" + throwables.size() + \" test threads failed\");\n+            for (final var t : throwables) {\n+                aggregated.addSuppressed(t);\n+            }\n+            throw aggregated;\n+        }\n+\n+        assertEquals(0, counter.get());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RecursiveCheckpointTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.*;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test\n+ * @summary pauseengine should pause the execution of the checkpointed process.\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build PauseEngineTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class PauseEngineTest implements CracTest {\n+    private static final long PAUSE_TIME_MS = 5000;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final CracBuilder builder = new CracBuilder().engine(CracEngine.PAUSE);\n+        final CracProcess process = builder.startCheckpoint();\n+        process.waitForPausePid();\n+        Thread.sleep(PAUSE_TIME_MS);\n+        builder.doRestore();\n+        process.waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        final long before = System.nanoTime();\n+        Core.checkpointRestore();\n+        final long after = System.nanoTime();\n+        final long pauseTimeMs = (after - before) \/ 1_000_000;\n+        assertGTE(pauseTimeMs, PAUSE_TIME_MS,\n+            \"Pause time is less than expected: \" + pauseTimeMs + \" < \" + PAUSE_TIME_MS + \" ms\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/engine\/PauseEngineTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -1,142 +0,0 @@\n-\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.crac.*;\n-import jdk.test.lib.crac.*;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-\/*\n- * @test\n- * @summary check that the recursive checkpoint is not allowed\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver\/timeout=60 jdk.test.lib.crac.CracTest 10\n- *\/\n-public class Test implements Resource, CracTest {\n-    private static final AtomicInteger counter = new AtomicInteger(0);\n-    private static Exception exception = null;\n-\n-    @CracTestArg\n-    int numThreads;\n-\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder().engine(CracEngine.PAUSE);\n-        CracProcess process = builder.startCheckpoint();\n-        process.waitForPausePid();\n-        for (int i = 1; i <= numThreads + 1; ++i) {\n-            System.err.printf(\"Restore #%d%n\", i);\n-            builder.doRestore();\n-        }\n-        process.waitForSuccess();\n-    }\n-\n-    private static class TestThread extends Thread {\n-\n-        @Override\n-        public void run() {\n-            try {\n-                jdk.crac.Core.checkpointRestore();\n-            } catch (CheckpointException e) {\n-                if (exception == null)\n-                    exception = new RuntimeException(\"Checkpoint in thread ERROR \" + e);\n-            } catch (RestoreException e) {\n-                if (exception == null)\n-                    exception = new RuntimeException(\"Restore in thread ERROR \" + e);\n-            }\n-        }\n-    };\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        try {\n-            int c = counter.incrementAndGet();\n-            if (c > 1) {\n-                if (exception == null)\n-                    exception = new RuntimeException(\"Parallel checkpoint\");\n-            }\n-            Thread.sleep(100);\n-            jdk.crac.Core.checkpointRestore();\n-            if (exception != null)\n-                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n-        } catch (CheckpointException e) {\n-            \/\/ Expected Exception\n-        } catch (RestoreException e) {\n-            if (exception == null)\n-                exception = new RuntimeException(\"Restore ERROR\", e);\n-        }\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws Exception {\n-        try {\n-            int c = counter.get();\n-            if (c > 1) {\n-                if (exception == null)\n-                    exception = new RuntimeException(\"Parallel checkpoint\");\n-            }\n-            Thread.sleep(100);\n-            jdk.crac.Core.checkpointRestore();\n-            if (exception == null)\n-                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n-        } catch (CheckpointException e) {\n-            \/\/ Expected Exception\n-        } catch (RestoreException e) {\n-            if (exception == null)\n-                exception = new RuntimeException(\"Restore ERROR\", e);\n-        } finally {\n-            counter.decrementAndGet();\n-        }\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        Core.getGlobalContext().register(new Test());\n-\n-        TestThread[] threads = new TestThread[numThreads];\n-        for (int i = 0; i < numThreads; i++) {\n-            threads[i] = new TestThread();\n-            threads[i].start();\n-        };\n-\n-        Thread.sleep(100);\n-        try {\n-            jdk.crac.Core.checkpointRestore();\n-        } catch (CheckpointException e) {\n-            throw new RuntimeException(\"Checkpoint ERROR\", e);\n-        } catch (RestoreException e) {\n-            throw new RuntimeException(\"Restore ERROR\", e);\n-        }\n-\n-        for (int i = 0; i < numThreads; i++) {\n-            threads[i].join();\n-        };\n-\n-        long ccounter = counter.get();\n-        if (ccounter != 0)\n-            throw new RuntimeException(\"Incorrect counter after restore: \" + ccounter + \" instead of 0\");\n-        if (exception != null) {\n-            throw exception;\n-        }\n-        System.out.println(\"PASSED\");\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"}]}