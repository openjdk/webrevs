{"files":[{"patch":"@@ -109,0 +109,11 @@\n+  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n+      NAME := pauseengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/linux\/native\/pauseengine, \\\n+      INCLUDE_FILES := pauseengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_PAUSEENGINE)\n+\n@@ -111,1 +122,1 @@\n-      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criuengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/linux\/native\/criuengine, \\\n@@ -129,11 +140,0 @@\n-  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n-      NAME := pauseengine, \\\n-      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/pauseengine, \\\n-      INCLUDE_FILES := pauseengine.c, \\\n-      OPTIMIZATION := LOW, \\\n-      CFLAGS := $(CFLAGS_JDKEXE), \\\n-      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n-      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n-  ))\n-  TARGETS += $(BUILD_PAUSEENGINE)\n-\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"","filename":"src\/java.base\/linux\/native\/criuengine\/criuengine.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.base\/unix\/native\/criuengine\/criuengine.c","status":"renamed"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <unistd.h>\n+\n+#define PAUSEENGINE \"pauseengine: \"\n+\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+static int kickjvm(pid_t jvm, int code) {\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(PAUSEENGINE \"sigqueue\");\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+    char* imagedir = argv[2];\n+\n+    char pidpath[1024];\n+    if (0 > snprintf(pidpath, sizeof(pidpath), \"%s\/pid\", imagedir)) {\n+        return 1;\n+    }\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+        pid_t jvm = getppid();\n+\n+        FILE *pidfile = fopen(pidpath, \"w\");\n+        if (!pidfile) {\n+            perror(PAUSEENGINE \"fopen pidfile\");\n+            kickjvm(jvm, -1);\n+            return 1;\n+        }\n+\n+        fprintf(pidfile, \"%d\\n\", jvm);\n+        fclose(pidfile);\n+\n+        printf(PAUSEENGINE \"pausing the process, restore in another process to unpause it\\n\");\n+    } else if (!strcmp(action, \"restore\")) {\n+        FILE *pidfile = fopen(pidpath, \"r\");\n+        if (!pidfile) {\n+            perror(PAUSEENGINE \"fopen pidfile\");\n+            return 1;\n+        }\n+\n+        pid_t jvm;\n+        if (1 != fscanf(pidfile, \"%d\", &jvm)) {\n+            perror(PAUSEENGINE \"fscanf pidfile\");\n+            fclose(pidfile);\n+            return 1;\n+        }\n+        fclose(pidfile);\n+\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        if (kickjvm(jvm, strid ? atoi(strid) : 0)) {\n+            return 1;\n+        }\n+\n+        printf(PAUSEENGINE \"successfully unpaused the checkpointed process\\n\");\n+    } else {\n+        fprintf(stderr, PAUSEENGINE \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/linux\/native\/pauseengine\/pauseengine.c","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <string.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <signal.h>\n-\n-#ifdef LINUX\n-#include <unistd.h>\n-#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n-#else\n-typedef int pid_t;\n-#endif \/\/LINUX\n-\n-static int kickjvm(pid_t jvm, int code) {\n-#ifdef LINUX\n-    union sigval sv = { .sival_int = code };\n-    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n-        perror(\"sigqueue\");\n-        return 1;\n-    }\n-#endif \/\/LINUX\n-    return 0;\n-}\n-\n-int main(int argc, char *argv[]) {\n-    char* action = argv[1];\n-    char* imagedir = argv[2];\n-\n-    char pidpath[1024];\n-    if (0 > snprintf(pidpath, sizeof(pidpath), \"%s\/pid\", imagedir)) {\n-        return 1;\n-    }\n-\n-    if (!strcmp(action, \"checkpoint\")) {\n-#ifdef LINUX\n-        pid_t jvm = getppid();\n-#else\n-        pid_t jvm = -1;\n-#endif \/\/LINUX\n-\n-        FILE *pidfile = fopen(pidpath, \"w\");\n-        if (!pidfile) {\n-            perror(\"fopen pidfile\");\n-            kickjvm(jvm, -1);\n-            return 1;\n-        }\n-\n-        fprintf(pidfile, \"%d\\n\", jvm);\n-        fclose(pidfile);\n-\n-    } else if (!strcmp(action, \"restore\")) {\n-        FILE *pidfile = fopen(pidpath, \"r\");\n-        if (!pidfile) {\n-            perror(\"fopen pidfile\");\n-            return 1;\n-        }\n-\n-        pid_t jvm;\n-        if (1 != fscanf(pidfile, \"%d\", &jvm)) {\n-            fclose(pidfile);\n-            fprintf(stderr, \"cannot read pid\\n\");\n-            return 1;\n-        }\n-        fclose(pidfile);\n-\n-        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n-        if (kickjvm(jvm, strid ? atoi(strid) : 0)) {\n-            return 1;\n-        }\n-\n-    } else {\n-        fprintf(stderr, \"unknown action: %s\\n\", action);\n-        return 1;\n-    }\n-\n-    return 0;\n-}\n","filename":"src\/java.base\/share\/native\/pauseengine\/pauseengine.c","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -30,0 +30,1 @@\n+#ifdef LINUX\n@@ -31,0 +32,4 @@\n+#include <unistd.h>\n+#endif \/\/ LINUX\n+\n+#define SIMENGINE \"simengine: \"\n@@ -33,1 +38,0 @@\n-#include <unistd.h>\n@@ -35,3 +39,0 @@\n-#else\n-typedef int pid_t;\n-#endif \/\/LINUX\n@@ -40,1 +41,0 @@\n-#ifdef LINUX\n@@ -43,1 +43,1 @@\n-        perror(\"sigqueue\");\n+        perror(SIMENGINE \"sigqueue\");\n@@ -46,1 +46,0 @@\n-#endif \/\/LINUX\n@@ -49,0 +48,1 @@\n+#endif \/\/ LINUX\n@@ -54,0 +54,1 @@\n+#ifdef LINUX\n@@ -56,1 +57,0 @@\n-#ifdef LINUX\n@@ -58,3 +58,0 @@\n-#else\n-        pid_t jvm = -1;\n-#endif \/\/LINUX\n@@ -62,0 +59,1 @@\n+#endif \/\/ LINUX\n@@ -63,2 +61,4 @@\n-        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n-        printf(\"CRAC_NEW_ARGS_ID=%s\\n\", strid ? strid : \"0\");\n+        fprintf(stderr,\n+            SIMENGINE \"restore is not supported as a separate action by this engine, \"\n+            \"it always restores a process immediately after checkpointing it\\n\");\n+        return 1;\n@@ -66,1 +66,1 @@\n-        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        fprintf(stderr, SIMENGINE \"unknown action: %s\\n\", action);\n","filename":"src\/java.base\/share\/native\/simengine\/simengine.c","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/\/ Copyright 2019, 2025, Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.*;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test\n+ * @summary check that the recursive checkpoint is not allowed\n+ * @library \/test\/lib\n+ * @build RecursiveCheckpointTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest 10\n+ *\/\n+public class RecursiveCheckpointTest implements Resource, CracTest {\n+    private static final AtomicInteger counter = new AtomicInteger(0);\n+    private static Exception exception = null;\n+\n+    @CracTestArg\n+    int numThreads;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        builder.startCheckpoint().waitForSuccess();\n+    }\n+\n+    private static class TestThread extends Thread {\n+        @Override\n+        public void run() {\n+            try {\n+                Core.checkpointRestore();\n+            } catch (CheckpointException e) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Checkpoint in thread ERROR \" + e);\n+            } catch (RestoreException e) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Restore in thread ERROR \" + e);\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        try {\n+            int c = counter.incrementAndGet();\n+            if (c > 1) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Parallel checkpoint\");\n+            }\n+            Thread.sleep(100);\n+            Core.checkpointRestore();\n+            if (exception != null)\n+                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n+        } catch (CheckpointException e) {\n+            \/\/ Expected Exception\n+        } catch (RestoreException e) {\n+            if (exception == null)\n+                exception = new RuntimeException(\"Restore ERROR\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        try {\n+            int c = counter.get();\n+            if (c > 1) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Parallel checkpoint\");\n+            }\n+            Thread.sleep(100);\n+            Core.checkpointRestore();\n+            if (exception == null)\n+                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n+        } catch (CheckpointException e) {\n+            \/\/ Expected Exception\n+        } catch (RestoreException e) {\n+            if (exception == null)\n+                exception = new RuntimeException(\"Restore ERROR\", e);\n+        } finally {\n+            counter.decrementAndGet();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.getGlobalContext().register(new RecursiveCheckpointTest());\n+\n+        TestThread[] threads = new TestThread[numThreads];\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i] = new TestThread();\n+            threads[i].start();\n+        }\n+\n+        Thread.sleep(100);\n+        try {\n+            Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            throw new RuntimeException(\"Checkpoint ERROR\", e);\n+        } catch (RestoreException e) {\n+            throw new RuntimeException(\"Restore ERROR\", e);\n+        }\n+\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i].join();\n+        }\n+\n+        long ccounter = counter.get();\n+        if (ccounter != 0)\n+            throw new RuntimeException(\"Incorrect counter after restore: \" + ccounter + \" instead of 0\");\n+        if (exception != null) {\n+            throw exception;\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RecursiveCheckpointTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.*;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/*\n+ * @test\n+ * @summary pauseengine should pause the execution of the checkpointed process.\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build PauseEngineTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class PauseEngineTest implements CracTest {\n+    private static final long PAUSE_TIME_MS = 5000;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final CracBuilder builder = new CracBuilder().engine(CracEngine.PAUSE);\n+        final CracProcess process = builder.startCheckpoint();\n+        process.waitForPausePid();\n+        Thread.sleep(PAUSE_TIME_MS);\n+        builder.doRestore();\n+        process.waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        final long before = System.nanoTime();\n+        Core.checkpointRestore();\n+        final long after = System.nanoTime();\n+        final long pauseTimeMs = (after - before) \/ 1_000_000;\n+        assertGTE(pauseTimeMs, PAUSE_TIME_MS,\n+            \"Pause time is less than expected: \" + pauseTimeMs + \" < \" + PAUSE_TIME_MS + \" ms\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/engine\/PauseEngineTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -62,2 +62,0 @@\n-        test(\"pause\");\n-        test(\"pauseengine\");\n@@ -65,0 +63,2 @@\n+            test(\"pause\");\n+            test(\"pauseengine\");\n","filename":"test\/jdk\/jdk\/crac\/engineOptions\/ParsingTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,141 +0,0 @@\n-\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.crac.*;\n-import jdk.test.lib.crac.*;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-\/*\n- * @test\n- * @summary check that the recursive checkpoint is not allowed\n- * @library \/test\/lib\n- * @build Test\n- * @run driver\/timeout=60 jdk.test.lib.crac.CracTest 10\n- *\/\n-public class Test implements Resource, CracTest {\n-    private static final AtomicInteger counter = new AtomicInteger(0);\n-    private static Exception exception = null;\n-\n-    @CracTestArg\n-    int numThreads;\n-\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder().engine(CracEngine.PAUSE);\n-        CracProcess process = builder.startCheckpoint();\n-        process.waitForPausePid();\n-        for (int i = 1; i <= numThreads + 1; ++i) {\n-            System.err.printf(\"Restore #%d%n\", i);\n-            builder.doRestore();\n-        }\n-        process.waitForSuccess();\n-    }\n-\n-    private static class TestThread extends Thread {\n-\n-        @Override\n-        public void run() {\n-            try {\n-                jdk.crac.Core.checkpointRestore();\n-            } catch (CheckpointException e) {\n-                if (exception == null)\n-                    exception = new RuntimeException(\"Checkpoint in thread ERROR \" + e);\n-            } catch (RestoreException e) {\n-                if (exception == null)\n-                    exception = new RuntimeException(\"Restore in thread ERROR \" + e);\n-            }\n-        }\n-    };\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        try {\n-            int c = counter.incrementAndGet();\n-            if (c > 1) {\n-                if (exception == null)\n-                    exception = new RuntimeException(\"Parallel checkpoint\");\n-            }\n-            Thread.sleep(100);\n-            jdk.crac.Core.checkpointRestore();\n-            if (exception != null)\n-                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n-        } catch (CheckpointException e) {\n-            \/\/ Expected Exception\n-        } catch (RestoreException e) {\n-            if (exception == null)\n-                exception = new RuntimeException(\"Restore ERROR\", e);\n-        }\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws Exception {\n-        try {\n-            int c = counter.get();\n-            if (c > 1) {\n-                if (exception == null)\n-                    exception = new RuntimeException(\"Parallel checkpoint\");\n-            }\n-            Thread.sleep(100);\n-            jdk.crac.Core.checkpointRestore();\n-            if (exception == null)\n-                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n-        } catch (CheckpointException e) {\n-            \/\/ Expected Exception\n-        } catch (RestoreException e) {\n-            if (exception == null)\n-                exception = new RuntimeException(\"Restore ERROR\", e);\n-        } finally {\n-            counter.decrementAndGet();\n-        }\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        Core.getGlobalContext().register(new Test());\n-\n-        TestThread[] threads = new TestThread[numThreads];\n-        for (int i = 0; i < numThreads; i++) {\n-            threads[i] = new TestThread();\n-            threads[i].start();\n-        };\n-\n-        Thread.sleep(100);\n-        try {\n-            jdk.crac.Core.checkpointRestore();\n-        } catch (CheckpointException e) {\n-            throw new RuntimeException(\"Checkpoint ERROR\", e);\n-        } catch (RestoreException e) {\n-            throw new RuntimeException(\"Restore ERROR\", e);\n-        }\n-\n-        for (int i = 0; i < numThreads; i++) {\n-            threads[i].join();\n-        };\n-\n-        long ccounter = counter.get();\n-        if (ccounter != 0)\n-            throw new RuntimeException(\"Incorrect counter after restore: \" + ccounter + \" instead of 0\");\n-        if (exception != null) {\n-            throw exception;\n-        }\n-        System.out.println(\"PASSED\");\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"}]}