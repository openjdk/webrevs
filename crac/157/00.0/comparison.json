{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -252,2 +252,5 @@\n-    AC_MSG_CHECKING([for dtrace tool])\n-    if test \"x$DTRACE\" != \"x\" && test -x \"$DTRACE\"; then\n+    AC_MSG_CHECKING([for dtrace tool and platform support])\n+    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = \"xppc\"; then\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_CPU_ARCH])\n+      AVAILABLE=false\n+    elif test \"x$DTRACE\" != \"x\" && test -x \"$DTRACE\"; then\n@@ -311,1 +314,3 @@\n-        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" || \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xppc64le\" || \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xriscv64\"; then\n@@ -361,0 +366,8 @@\n+    elif test \"x$OPENJDK_TARGET_CPU\" = \"xppc64le\" || \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xriscv64\"; then\n+      if test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then\n+        AC_MSG_RESULT([yes])\n+      else\n+        AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n+        AVAILABLE=false\n+      fi\n","filename":"make\/autoconf\/jvm-features.m4","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+#\n+# Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Versions and download locations for dependencies used by GitHub Actions (GHA)\n+\n+GTEST_VERSION=1.8.1\n+JTREG_VERSION=7.3.1+1\n+\n+LINUX_X64_BOOT_JDK_EXT=tar.gz\n+LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin17-binaries\/releases\/download\/jdk-17.0.11%2B9\/OpenJDK17U-jdk_x64_linux_hotspot_17.0.11_9.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=aa7fb6bb342319d227a838af5c363bfa1b4a670c209372f9e6585bd79da6220c\n+\n+LINUX_X64_CRIU_FILENAME=criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_URL=https:\/\/github.com\/CRaC\/criu\/releases\/download\/release-1.3\/criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_SHA256=82a014bf342c957305b98a71867c0994ebf6e7379f01f083121884793768d966\n+\n+WINDOWS_X64_BOOT_JDK_EXT=zip\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin17-binaries\/releases\/download\/jdk-17.0.11%2B9\/OpenJDK17U-jdk_x64_windows_hotspot_17.0.11_9.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=fdd6664d4131370398fbc8bfbb7b46dbfec4a22a090a511fe5c379dae188c390\n+\n+MACOS_X64_BOOT_JDK_EXT=tar.gz\n+MACOS_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin17-binaries\/releases\/download\/jdk-17.0.11%2B9\/OpenJDK17U-jdk_x64_mac_hotspot_17.0.11_9.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=f8b96724618f4df557c47f11048d1084e98ed3eb87f0dbd5b84f768a80c3348e\n","filename":"make\/conf\/github-actions.conf","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"spin_wait_aarch64.hpp\"\n@@ -48,0 +49,2 @@\n+  static SpinWait _spin_wait;\n+\n@@ -60,0 +63,4 @@\n+  static void check_virtualizations();\n+\n+  static void print_platform_virtualization_info(outputStream*);\n+\n@@ -100,0 +107,9 @@\n+  enum Ampere_CPU_Model {\n+    CPU_MODEL_EMAG      = 0x0,   \/* CPU implementer is CPU_AMCC *\/\n+    CPU_MODEL_ALTRA     = 0xd0c, \/* CPU implementer is CPU_ARM, Neoverse N1 *\/\n+    CPU_MODEL_ALTRAMAX  = 0xd0c, \/* CPU implementer is CPU_ARM, Neoverse N1 *\/\n+    CPU_MODEL_AMPERE_1  = 0xac3, \/* CPU implementer is CPU_AMPERE *\/\n+    CPU_MODEL_AMPERE_1A = 0xac4, \/* CPU implementer is CPU_AMPERE *\/\n+    CPU_MODEL_AMPERE_1B = 0xac5  \/* AMPERE_1B core Implements ARMv8.7 with CSSC, MTE, SM3\/SM4 extensions *\/\n+};\n+\n@@ -146,0 +162,4 @@\n+  static const SpinWait& spin_wait_desc() { return _spin_wait; }\n+\n+  static bool supports_on_spin_wait() { return _spin_wait.inst() != SpinWait::NONE; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1396,1 +1396,1 @@\n-  char buf[512];\n+  char buf[1024];\n@@ -2384,9 +2384,9 @@\n-    \/\/ 06_8EH | 9 | 8th Generation Intel® Core™ Processor Family based on microarchitecture code name Amber Lake Y\n-    \/\/ 06_8EH | 9 | 7th Generation Intel® Core™ Processor Family based on microarchitecture code name Kaby Lake U\n-    \/\/ 06_8EH | 9 | 7th Generation Intel® Core™ Processor Family based on microarchitecture code name Kaby Lake U 23e\n-    \/\/ 06_8EH | 9 | 7th Generation Intel® Core™ Processor Family based on microarchitecture code name Kaby Lake Y\n-    \/\/ 06_8EH | A | 8th Generation Intel® Core™ Processor Family based on microarchitecture code name Coffee Lake U43e\n-    \/\/ 06_8EH | B | 8th Generation Intel® Core™ Processors based on microarchitecture code name Whiskey Lake U\n-    \/\/ 06_8EH | C | 8th Generation Intel® Core™ Processor Family based on microarchitecture code name Amber Lake Y\n-    \/\/ 06_8EH | C | 10th Generation Intel® Core™ Processor Family based on microarchitecture code name Comet Lake U42\n-    \/\/ 06_8EH | C | 8th Generation Intel® Core™ Processors based on microarchitecture code name Whiskey Lake U\n+    \/\/ 06_8EH | 9 | 8th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Amber Lake Y\n+    \/\/ 06_8EH | 9 | 7th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Kaby Lake U\n+    \/\/ 06_8EH | 9 | 7th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Kaby Lake U 23e\n+    \/\/ 06_8EH | 9 | 7th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Kaby Lake Y\n+    \/\/ 06_8EH | A | 8th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Coffee Lake U43e\n+    \/\/ 06_8EH | B | 8th Generation Intel(R) Core(TM) Processors based on microarchitecture code name Whiskey Lake U\n+    \/\/ 06_8EH | C | 8th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Amber Lake Y\n+    \/\/ 06_8EH | C | 10th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Comet Lake U42\n+    \/\/ 06_8EH | C | 8th Generation Intel(R) Core(TM) Processors based on microarchitecture code name Whiskey Lake U\n@@ -2395,3 +2395,3 @@\n-    \/\/ 06_4E  | 3 | 6th Generation Intel® Core™ Processors based on microarchitecture code name Skylake U\n-    \/\/ 06_4E  | 3 | 6th Generation Intel® Core™ Processor Family based on microarchitecture code name Skylake U23e\n-    \/\/ 06_4E  | 3 | 6th Generation Intel® Core™ Processors based on microarchitecture code name Skylake Y\n+    \/\/ 06_4E  | 3 | 6th Generation Intel(R) Core(TM) Processors based on microarchitecture code name Skylake U\n+    \/\/ 06_4E  | 3 | 6th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Skylake U23e\n+    \/\/ 06_4E  | 3 | 6th Generation Intel(R) Core(TM) Processors based on microarchitecture code name Skylake Y\n@@ -2400,6 +2400,6 @@\n-    \/\/ 06_55H | 4 | Intel® Xeon® Processor D Family based on microarchitecture code name Skylake D, Bakerville\n-    \/\/ 06_55H | 4 | Intel® Xeon® Scalable Processors based on microarchitecture code name Skylake Server\n-    \/\/ 06_55H | 4 | Intel® Xeon® Processor W Family based on microarchitecture code name Skylake W\n-    \/\/ 06_55H | 4 | Intel® Core™ X-series Processors based on microarchitecture code name Skylake X\n-    \/\/ 06_55H | 4 | Intel® Xeon® Processor E3 v5 Family based on microarchitecture code name Skylake Xeon E3\n-    \/\/ 06_55  | 7 | 2nd Generation Intel® Xeon® Scalable Processors based on microarchitecture code name Cascade Lake (server)\n+    \/\/ 06_55H | 4 | Intel(R) Xeon(R) Processor D Family based on microarchitecture code name Skylake D, Bakerville\n+    \/\/ 06_55H | 4 | Intel(R) Xeon(R) Scalable Processors based on microarchitecture code name Skylake Server\n+    \/\/ 06_55H | 4 | Intel(R) Xeon(R) Processor W Family based on microarchitecture code name Skylake W\n+    \/\/ 06_55H | 4 | Intel(R) Core(TM) X-series Processors based on microarchitecture code name Skylake X\n+    \/\/ 06_55H | 4 | Intel(R) Xeon(R) Processor E3 v5 Family based on microarchitecture code name Skylake Xeon E3\n+    \/\/ 06_55  | 7 | 2nd Generation Intel(R) Xeon(R) Scalable Processors based on microarchitecture code name Cascade Lake (server)\n@@ -2408,2 +2408,2 @@\n-    \/\/ 06_5E  | 3 | 6th Generation Intel® Core™ Processor Family based on microarchitecture code name Skylake H\n-    \/\/ 06_5E  | 3 | 6th Generation Intel® Core™ Processor Family based on microarchitecture code name Skylake S\n+    \/\/ 06_5E  | 3 | 6th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Skylake H\n+    \/\/ 06_5E  | 3 | 6th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Skylake S\n@@ -2412,14 +2412,14 @@\n-    \/\/ 06_9EH | 9 | 8th Generation Intel® Core™ Processor Family based on microarchitecture code name Kaby Lake G\n-    \/\/ 06_9EH | 9 | 7th Generation Intel® Core™ Processor Family based on microarchitecture code name Kaby Lake H\n-    \/\/ 06_9EH | 9 | 7th Generation Intel® Core™ Processor Family based on microarchitecture code name Kaby Lake S\n-    \/\/ 06_9EH | 9 | Intel® Core™ X-series Processors based on microarchitecture code name Kaby Lake X\n-    \/\/ 06_9EH | 9 | Intel® Xeon® Processor E3 v6 Family Kaby Lake Xeon E3\n-    \/\/ 06_9EH | A | 8th Generation Intel® Core™ Processor Family based on microarchitecture code name Coffee Lake H\n-    \/\/ 06_9EH | A | 8th Generation Intel® Core™ Processor Family based on microarchitecture code name Coffee Lake S\n-    \/\/ 06_9EH | A | 8th Generation Intel® Core™ Processor Family based on microarchitecture code name Coffee Lake S (6+2) x\/KBP\n-    \/\/ 06_9EH | A | Intel® Xeon® Processor E Family based on microarchitecture code name Coffee Lake S (6+2)\n-    \/\/ 06_9EH | A | Intel® Xeon® Processor E Family based on microarchitecture code name Coffee Lake S (4+2)\n-    \/\/ 06_9EH | B | 8th Generation Intel® Core™ Processor Family based on microarchitecture code name Coffee Lake S (4+2)\n-    \/\/ 06_9EH | B | Intel® Celeron® Processor G Series based on microarchitecture code name Coffee Lake S (4+2)\n-    \/\/ 06_9EH | D | 9th Generation Intel® Core™ Processor Family based on microarchitecturecode name Coffee Lake H (8+2)\n-    \/\/ 06_9EH | D | 9th Generation Intel® Core™ Processor Family based on microarchitecture code name Coffee Lake S (8+2)\n+    \/\/ 06_9EH | 9 | 8th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Kaby Lake G\n+    \/\/ 06_9EH | 9 | 7th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Kaby Lake H\n+    \/\/ 06_9EH | 9 | 7th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Kaby Lake S\n+    \/\/ 06_9EH | 9 | Intel(R) Core(TM) X-series Processors based on microarchitecture code name Kaby Lake X\n+    \/\/ 06_9EH | 9 | Intel(R) Xeon(R) Processor E3 v6 Family Kaby Lake Xeon E3\n+    \/\/ 06_9EH | A | 8th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Coffee Lake H\n+    \/\/ 06_9EH | A | 8th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Coffee Lake S\n+    \/\/ 06_9EH | A | 8th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Coffee Lake S (6+2) x\/KBP\n+    \/\/ 06_9EH | A | Intel(R) Xeon(R) Processor E Family based on microarchitecture code name Coffee Lake S (6+2)\n+    \/\/ 06_9EH | A | Intel(R) Xeon(R) Processor E Family based on microarchitecture code name Coffee Lake S (4+2)\n+    \/\/ 06_9EH | B | 8th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Coffee Lake S (4+2)\n+    \/\/ 06_9EH | B | Intel(R) Celeron(R) Processor G Series based on microarchitecture code name Coffee Lake S (4+2)\n+    \/\/ 06_9EH | D | 9th Generation Intel(R) Core(TM) Processor Family based on microarchitecturecode name Coffee Lake H (8+2)\n+    \/\/ 06_9EH | D | 9th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Coffee Lake S (8+2)\n@@ -2429,1 +2429,1 @@\n-    \/\/ 06_A5H |    | 10th Generation Intel® Core™ Processor Family based on microarchitecture code name Comet Lake S\/H\n+    \/\/ 06_A5H |    | 10th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Comet Lake S\/H\n@@ -2432,1 +2432,1 @@\n-    \/\/ 06_A6H | 0  | 10th Generation Intel® Core™ Processor Family based on microarchitecture code name Comet Lake U62\n+    \/\/ 06_A6H | 0  | 10th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Comet Lake U62\n@@ -2435,1 +2435,1 @@\n-    \/\/ 06_AEH | A | 8th Generation Intel® Core™ Processor Family based on microarchitecture code name Kaby Lake Refresh U (4+2)\n+    \/\/ 06_AEH | A | 8th Generation Intel(R) Core(TM) Processor Family based on microarchitecture code name Kaby Lake Refresh U (4+2)\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,0 @@\n-               lzcnt_intel  : 1,\n@@ -164,1 +163,1 @@\n-                            : 14;\n+                            : 15;\n@@ -675,1 +674,1 @@\n-      if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)\n+      if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0) {\n@@ -677,2 +676,2 @@\n-      \/\/ for Intel, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw\n-      if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {\n+      }\n+      if (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0) {\n@@ -688,1 +687,1 @@\n-      if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt_intel != 0)\n+      if (_cpuid_info.ext_cpuid1_ecx.bits.lzcnt != 0) {\n@@ -690,2 +689,2 @@\n-      \/\/ for ZX, ecx.bits.misalignsse bit (bit 8) indicates support for prefetchw\n-      if (_cpuid_info.ext_cpuid1_ecx.bits.misalignsse != 0) {\n+      }\n+      if (_cpuid_info.ext_cpuid1_ecx.bits.prefetchw != 0) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+  constexpr static bool supports_stack_watermark_barrier() { return true; }\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"services\/dtraceAttacher.hpp\"\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024 SAP SE. All rights reserved.\n@@ -34,0 +35,1 @@\n+#include \"hugepages.hpp\"\n@@ -114,0 +116,1 @@\n+# include <sys\/prctl.h>\n@@ -171,1 +174,0 @@\n-size_t os::Linux::_default_large_page_size = 0;\n@@ -201,5 +203,2 @@\n-    jlong mem_limit, mem_usage;\n-    if ((mem_limit = OSContainer::memory_limit_in_bytes()) < 1) {\n-      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value\",\n-                             mem_limit == OSCONTAINER_ERROR ? \"failed\" : \"unlimited\", mem_limit);\n-    }\n+    jlong mem_limit = OSContainer::memory_limit_in_bytes();\n+    jlong mem_usage;\n@@ -209,1 +208,1 @@\n-    if (mem_limit > 0 && mem_usage > 0 ) {\n+    if (mem_limit > 0 && mem_usage > 0) {\n@@ -230,2 +229,0 @@\n-    log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value\",\n-                            mem_limit == OSCONTAINER_ERROR ? \"failed\" : \"unlimited\", mem_limit);\n@@ -360,0 +357,8 @@\n+\/\/ Returns the amount of swap currently configured, in bytes.\n+\/\/ This can change at any time.\n+julong os::Linux::host_swap() {\n+  struct sysinfo si;\n+  sysinfo(&si);\n+  return (julong)(si.totalswap * si.mem_unit);\n+}\n+\n@@ -727,0 +732,4 @@\n+  if (DelayThreadStartALot) {\n+    os::naked_short_sleep(100);\n+  }\n+\n@@ -751,1 +760,2 @@\n-\/\/ size by this TLS size.\n+\/\/ size by this TLS size. The same function is used to determine whether\n+\/\/ adjustStackSizeForGuardPages() needs to be true.\n@@ -757,8 +767,1 @@\n-GetMinStack _get_minstack_func = NULL;\n-\n-static void get_minstack_init() {\n-  _get_minstack_func =\n-        (GetMinStack)dlsym(RTLD_DEFAULT, \"__pthread_get_minstack\");\n-  log_info(os, thread)(\"Lookup of __pthread_get_minstack %s\",\n-                       _get_minstack_func == NULL ? \"failed\" : \"succeeded\");\n-}\n+GetMinStack _get_minstack_func = nullptr;  \/\/ Initialized via os::init_2()\n@@ -777,2 +780,2 @@\n-    \/\/ In glibc before 2.27, minstack size includes guard_size.\n-    \/\/ In glibc 2.27 and later, guard_size is automatically added\n+    \/\/ If adjustStackSizeForGuardPages() is true, minstack size includes\n+    \/\/ guard_size. Otherwise guard_size is automatically added\n@@ -807,0 +810,36 @@\n+\/\/ In glibc versions prior to 2.27 the guard size mechanism\n+\/\/ was not implemented properly. The POSIX standard requires adding\n+\/\/ the size of the guard pages to the stack size, instead glibc\n+\/\/ took the space out of 'stacksize'. Thus we need to adapt the requested\n+\/\/ stack_size by the size of the guard pages to mimic proper behaviour.\n+\/\/ The fix in glibc 2.27 has now been backported to numerous earlier\n+\/\/ glibc versions so we need to do a dynamic runtime check.\n+static bool _adjustStackSizeForGuardPages = true;\n+bool os::Linux::adjustStackSizeForGuardPages() {\n+  return _adjustStackSizeForGuardPages;\n+}\n+\n+#ifdef __GLIBC__\n+static void init_adjust_stacksize_for_guard_pages() {\n+  assert(_get_minstack_func == nullptr, \"initialization error\");\n+  _get_minstack_func =(GetMinStack)dlsym(RTLD_DEFAULT, \"__pthread_get_minstack\");\n+  log_info(os, thread)(\"Lookup of __pthread_get_minstack %s\",\n+                       _get_minstack_func == nullptr ? \"failed\" : \"succeeded\");\n+\n+  if (_get_minstack_func != nullptr) {\n+    pthread_attr_t attr;\n+    pthread_attr_init(&attr);\n+    size_t min_stack = _get_minstack_func(&attr);\n+    size_t guard = 16 * K; \/\/ Actual value doesn't matter as it is not examined\n+    pthread_attr_setguardsize(&attr, guard);\n+    size_t min_stack2 = _get_minstack_func(&attr);\n+    pthread_attr_destroy(&attr);\n+    \/\/ If the minimum stack size changed when we added the guard page space\n+    \/\/ then we need to perform the adjustment.\n+    _adjustStackSizeForGuardPages = (min_stack2 != min_stack);\n+    log_info(os)(\"Glibc stack size guard page adjustment is %sneeded\",\n+                 _adjustStackSizeForGuardPages ? \"\" : \"not \");\n+  }\n+}\n+#endif \/\/ GLIBC\n+\n@@ -832,7 +871,1 @@\n-  \/\/ In glibc versions prior to 2.7 the guard size mechanism\n-  \/\/ is not implemented properly. The posix standard requires adding\n-  \/\/ the size of the guard pages to the stack size, instead Linux\n-  \/\/ takes the space out of 'stacksize'. Thus we adapt the requested\n-  \/\/ stack_size by the size of the guard pages to mimick proper\n-  \/\/ behaviour. However, be careful not to end up with a size\n-  \/\/ of zero due to overflow. Don't add the guard page in that case.\n+\n@@ -844,0 +877,2 @@\n+  \/\/ Apply stack size adjustments if needed. However, be careful not to end up\n+  \/\/ with a size of zero due to overflow. Don't add the adjustment in that case.\n@@ -848,1 +883,1 @@\n-  } else {\n+  } else if (os::Linux::adjustStackSizeForGuardPages()) {\n@@ -858,0 +893,12 @@\n+  if (THPStackMitigation) {\n+    \/\/ In addition to the glibc guard page that prevents inter-thread-stack hugepage\n+    \/\/ coalescing (see comment in os::Linux::default_guard_size()), we also make\n+    \/\/ sure the stack size itself is not huge-page-size aligned; that makes it much\n+    \/\/ more likely for thread stack boundaries to be unaligned as well and hence\n+    \/\/ protects thread stacks from being targeted by khugepaged.\n+    if (HugePages::thp_pagesize() > 0 &&\n+        is_aligned(stack_size, HugePages::thp_pagesize())) {\n+      stack_size += os::vm_page_size();\n+    }\n+  }\n+\n@@ -874,0 +921,1 @@\n+    ResourceMark rm;\n@@ -875,1 +923,5 @@\n-    int ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n+    int ret = 0;\n+    int limit = 3;\n+    do {\n+      ret = pthread_create(&tid, &attr, (void* (*)(void*)) thread_native_entry, thread);\n+    } while (ret == EAGAIN && limit-- > 0);\n@@ -879,2 +931,12 @@\n-      log_info(os, thread)(\"Thread started (pthread id: \" UINTX_FORMAT \", attributes: %s). \",\n-        (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n+      log_info(os, thread)(\"Thread \\\"%s\\\" started (pthread id: \" UINTX_FORMAT \", attributes: %s). \",\n+                           thread->name(), (uintx) tid, os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n+\n+      \/\/ Print current timer slack if override is enabled and timer slack value is available.\n+      \/\/ Avoid calling prctl otherwise for extra safety.\n+      if (TimerSlack >= 0) {\n+        int slack = prctl(PR_GET_TIMERSLACK);\n+        if (slack >= 0) {\n+          log_info(os, thread)(\"Thread \\\"%s\\\" (pthread id: \" UINTX_FORMAT \") timer slack: %dns\",\n+                               thread->name(), (uintx) tid, slack);\n+        }\n+      }\n@@ -882,2 +944,2 @@\n-      log_warning(os, thread)(\"Failed to start thread - pthread_create failed (%s) for attributes: %s.\",\n-        os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n+      log_warning(os, thread)(\"Failed to start thread \\\"%s\\\" - pthread_create failed (%s) for attributes: %s.\",\n+                              thread->name(), os::errno_name(ret), os::Posix::describe_pthread_attr(buf, sizeof(buf), &attr));\n@@ -985,2 +1047,4 @@\n-  log_info(os, thread)(\"Thread attached (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT \").\",\n-    os::current_thread_id(), (uintx) pthread_self());\n+  log_info(os, thread)(\"Thread attached (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT\n+                       \", stack: \" PTR_FORMAT \" - \" PTR_FORMAT \" (\" SIZE_FORMAT \"K) ).\",\n+                       os::current_thread_id(), (uintx) pthread_self(),\n+                       p2i(thread->stack_base()), p2i(thread->stack_end()), thread->stack_size() \/ K);\n@@ -1326,1 +1390,1 @@\n-  \/\/ If the fast Posix clocks are supported then the clock_getres()\n+  \/\/ If the fast POSIX clocks are supported then the clock_getres()\n@@ -1388,8 +1452,0 @@\n-static bool file_exists(const char* filename) {\n-  struct stat statbuf;\n-  if (filename == NULL || strlen(filename) == 0) {\n-    return false;\n-  }\n-  return os::stat(filename, &statbuf) == 0;\n-}\n-\n@@ -1679,0 +1735,3 @@\n+#ifndef EM_LOONGARCH\n+  #define EM_LOONGARCH  258               \/* LoongArch *\/\n+#endif\n@@ -1706,0 +1765,1 @@\n+    {EM_LOONGARCH,   EM_LOONGARCH, ELFCLASS64, ELFDATA2LSB, (char*)\"LoongArch\"},\n@@ -1742,0 +1802,2 @@\n+#elif  (defined LOONGARCH64)\n+  static  Elf32_Half running_arch_code=EM_LOONGARCH;\n@@ -1744,1 +1806,1 @@\n-        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n+        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n@@ -1817,1 +1879,1 @@\n-    Events::log(NULL, \"Loading shared library %s failed, %s\", filename, error_report);\n+    Events::log_dll_message(NULL, \"Loading shared library %s failed, %s\", filename, error_report);\n@@ -1820,1 +1882,1 @@\n-    Events::log(NULL, \"Loaded shared library %s\", filename);\n+    Events::log_dll_message(NULL, \"Loaded shared library %s\", filename);\n@@ -1856,4 +1918,4 @@\n-void* os::dll_lookup(void* handle, const char* name) {\n-  void* res = dlsym(handle, name);\n-  return res;\n-}\n+const char* os::Linux::dll_path(void* lib) {\n+  struct link_map *lmap;\n+  const char* l_path = NULL;\n+  assert(lib != NULL, \"dll_path parameter must not be NULL\");\n@@ -1861,2 +1923,5 @@\n-void* os::get_default_process_handle() {\n-  return (void*)::dlopen(NULL, RTLD_LAZY);\n+  int res_dli = ::dlinfo(lib, RTLD_DI_LINKMAP, &lmap);\n+  if (res_dli == 0) {\n+    l_path = lmap->l_name;\n+  }\n+  return l_path;\n@@ -2025,1 +2090,0 @@\n-  \"\/etc\/SuSE-release\",\n@@ -2033,0 +2097,1 @@\n+  \"\/etc\/SuSE-release\", \/\/ Deprecated in favor of os-release since SuSE 12\n@@ -2132,0 +2197,2 @@\n+  _print_ascii_file_h(\"\/proc\/sys\/vm\/swappiness (control to define how aggressively the kernel swaps out anonymous memory)\",\n+                      \"\/proc\/sys\/vm\/swappiness\", st);\n@@ -2144,0 +2211,2 @@\n+  _print_ascii_file_h(\"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pmd_size\",\n+                      \"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pmd_size\", st);\n@@ -2148,10 +2217,1 @@\n-void os::Linux::print_process_memory_info(outputStream* st) {\n-\n-  st->print_cr(\"Process Memory:\");\n-\n-  \/\/ Print virtual and resident set size; peak values; swap; and for\n-  \/\/  rss its components if the kernel is recent enough.\n-  ssize_t vmsize = -1, vmpeak = -1, vmswap = -1,\n-      vmrss = -1, vmhwm = -1, rssanon = -1, rssfile = -1, rssshmem = -1;\n-  const int num_values = 8;\n-  int num_found = 0;\n+bool os::Linux::query_process_memory_info(os::Linux::meminfo_t* info) {\n@@ -2159,0 +2219,2 @@\n+  const int num_values = sizeof(os::Linux::meminfo_t) \/ sizeof(size_t);\n+  int num_found = 0;\n@@ -2160,0 +2222,2 @@\n+  info->vmsize = info->vmpeak = info->vmrss = info->vmhwm = info->vmswap =\n+      info->rssanon = info->rssfile = info->rssshmem = -1;\n@@ -2162,8 +2226,8 @@\n-      if ( (vmsize == -1    && sscanf(buf, \"VmSize: \" SSIZE_FORMAT \" kB\", &vmsize) == 1) ||\n-           (vmpeak == -1    && sscanf(buf, \"VmPeak: \" SSIZE_FORMAT \" kB\", &vmpeak) == 1) ||\n-           (vmswap == -1    && sscanf(buf, \"VmSwap: \" SSIZE_FORMAT \" kB\", &vmswap) == 1) ||\n-           (vmhwm == -1     && sscanf(buf, \"VmHWM: \" SSIZE_FORMAT \" kB\", &vmhwm) == 1) ||\n-           (vmrss == -1     && sscanf(buf, \"VmRSS: \" SSIZE_FORMAT \" kB\", &vmrss) == 1) ||\n-           (rssanon == -1   && sscanf(buf, \"RssAnon: \" SSIZE_FORMAT \" kB\", &rssanon) == 1) ||\n-           (rssfile == -1   && sscanf(buf, \"RssFile: \" SSIZE_FORMAT \" kB\", &rssfile) == 1) ||\n-           (rssshmem == -1  && sscanf(buf, \"RssShmem: \" SSIZE_FORMAT \" kB\", &rssshmem) == 1)\n+      if ( (info->vmsize == -1    && sscanf(buf, \"VmSize: \" SSIZE_FORMAT \" kB\", &info->vmsize) == 1) ||\n+           (info->vmpeak == -1    && sscanf(buf, \"VmPeak: \" SSIZE_FORMAT \" kB\", &info->vmpeak) == 1) ||\n+           (info->vmswap == -1    && sscanf(buf, \"VmSwap: \" SSIZE_FORMAT \" kB\", &info->vmswap) == 1) ||\n+           (info->vmhwm == -1     && sscanf(buf, \"VmHWM: \" SSIZE_FORMAT \" kB\", &info->vmhwm) == 1) ||\n+           (info->vmrss == -1     && sscanf(buf, \"VmRSS: \" SSIZE_FORMAT \" kB\", &info->vmrss) == 1) ||\n+           (info->rssanon == -1   && sscanf(buf, \"RssAnon: \" SSIZE_FORMAT \" kB\", &info->rssanon) == 1) || \/\/ Needs Linux 4.5\n+           (info->rssfile == -1   && sscanf(buf, \"RssFile: \" SSIZE_FORMAT \" kB\", &info->rssfile) == 1) || \/\/ Needs Linux 4.5\n+           (info->rssshmem == -1  && sscanf(buf, \"RssShmem: \" SSIZE_FORMAT \" kB\", &info->rssshmem) == 1)  \/\/ Needs Linux 4.5\n@@ -2176,0 +2240,36 @@\n+    return true;\n+  }\n+  return false;\n+}\n+\n+#ifdef __GLIBC__\n+\/\/ For Glibc, print a one-liner with the malloc tunables.\n+\/\/ Most important and popular is MALLOC_ARENA_MAX, but we are\n+\/\/ thorough and print them all.\n+static void print_glibc_malloc_tunables(outputStream* st) {\n+  static const char* var[] = {\n+      \/\/ the new variant\n+      \"GLIBC_TUNABLES\",\n+      \/\/ legacy variants\n+      \"MALLOC_CHECK_\", \"MALLOC_TOP_PAD_\", \"MALLOC_PERTURB_\",\n+      \"MALLOC_MMAP_THRESHOLD_\", \"MALLOC_TRIM_THRESHOLD_\",\n+      \"MALLOC_MMAP_MAX_\", \"MALLOC_ARENA_TEST\", \"MALLOC_ARENA_MAX\",\n+      NULL};\n+  st->print(\"glibc malloc tunables: \");\n+  bool printed = false;\n+  for (int i = 0; var[i] != NULL; i ++) {\n+    const char* const val = ::getenv(var[i]);\n+    if (val != NULL) {\n+      st->print(\"%s%s=%s\", (printed ? \", \" : \"\"), var[i], val);\n+      printed = true;\n+    }\n+  }\n+  if (!printed) {\n+    st->print(\"(default)\");\n+  }\n+}\n+#endif \/\/ __GLIBC__\n+\n+void os::Linux::print_process_memory_info(outputStream* st) {\n+\n+  st->print_cr(\"Process Memory:\");\n@@ -2177,3 +2277,7 @@\n-    st->print_cr(\"Virtual Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmsize, vmpeak);\n-    st->print(\"Resident Set Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmrss, vmhwm);\n-    if (rssanon != -1) { \/\/ requires kernel >= 4.5\n+  \/\/ Print virtual and resident set size; peak values; swap; and for\n+  \/\/  rss its components if the kernel is recent enough.\n+  meminfo_t info;\n+  if (query_process_memory_info(&info)) {\n+    st->print_cr(\"Virtual Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", info.vmsize, info.vmpeak);\n+    st->print(\"Resident Set Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", info.vmrss, info.vmhwm);\n+    if (info.rssanon != -1) { \/\/ requires kernel >= 4.5\n@@ -2181,1 +2285,1 @@\n-                  rssanon, rssfile, rssshmem);\n+                info.rssanon, info.rssfile, info.rssshmem);\n@@ -2184,2 +2288,2 @@\n-    if (vmswap != -1) { \/\/ requires kernel >= 2.6.34\n-      st->print_cr(\"Swapped out: \" SSIZE_FORMAT \"K\", vmswap);\n+    if (info.vmswap != -1) { \/\/ requires kernel >= 2.6.34\n+      st->print_cr(\"Swapped out: \" SSIZE_FORMAT \"K\", info.vmswap);\n@@ -2191,2 +2295,3 @@\n-  \/\/ Print glibc outstanding allocations.\n-  \/\/ (note: there is no implementation of mallinfo for muslc)\n+  \/\/ glibc only:\n+  \/\/ - Print outstanding allocations using mallinfo\n+  \/\/ - Print glibc tunables\n@@ -2195,0 +2300,1 @@\n+  size_t free_retained = 0;\n@@ -2198,1 +2304,2 @@\n-    total_allocated = mi.uordblks;\n+    total_allocated = mi.uordblks + mi.hblkhd;\n+    free_retained = mi.fordblks;\n@@ -2200,3 +2307,4 @@\n-    \/\/ mallinfo is an old API. Member names mean next to nothing and, beyond that, are int.\n-    \/\/ So values may have wrapped around. Still useful enough to see how much glibc thinks\n-    \/\/ we allocated.\n+    \/\/ mallinfo is an old API. Member names mean next to nothing and, beyond that, are 32-bit signed.\n+    \/\/ So for larger footprints the values may have wrapped around. We try to detect this here: if the\n+    \/\/ process whole resident set size is smaller than 4G, malloc footprint has to be less than that\n+    \/\/ and the numbers are reliable.\n@@ -2204,1 +2312,2 @@\n-    total_allocated = (size_t)(unsigned)mi.uordblks;\n+    total_allocated = (size_t)(unsigned)mi.uordblks + (size_t)(unsigned)mi.hblkhd;\n+    free_retained = (size_t)(unsigned)mi.fordblks;\n@@ -2206,1 +2315,1 @@\n-    might_have_wrapped = (vmrss * K) > UINT_MAX && (vmrss * K) > (total_allocated + UINT_MAX);\n+    might_have_wrapped = (info.vmrss * K) > UINT_MAX && (info.vmrss * K) > (total_allocated + UINT_MAX);\n@@ -2209,2 +2318,2 @@\n-    st->print_cr(\"C-Heap outstanding allocations: \" SIZE_FORMAT \"K%s\",\n-                 total_allocated \/ K,\n+    st->print_cr(\"C-Heap outstanding allocations: \" SIZE_FORMAT \"K, retained: \" SIZE_FORMAT \"K%s\",\n+                 total_allocated \/ K, free_retained \/ K,\n@@ -2213,2 +2322,4 @@\n-#endif \/\/ __GLIBC__\n-\n+  \/\/ Tunables\n+  print_glibc_malloc_tunables(st);\n+  st->cr();\n+#endif\n@@ -2231,0 +2342,1 @@\n+    st->print_cr(\"container information not found.\");\n@@ -2250,1 +2362,5 @@\n-    st->print_cr(\"%d\", i);\n+    if (ActiveProcessorCount > 0) {\n+      st->print_cr(\"%d, but overridden by -XX:ActiveProcessorCount %d\", i, ActiveProcessorCount);\n+    } else {\n+      st->print_cr(\"%d\", i);\n+    }\n@@ -2279,15 +2395,5 @@\n-  jlong j = OSContainer::memory_limit_in_bytes();\n-  st->print(\"memory_limit_in_bytes: \");\n-  if (j > 0) {\n-    st->print_cr(JLONG_FORMAT, j);\n-  } else {\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n-  }\n-\n-  j = OSContainer::memory_and_swap_limit_in_bytes();\n-  st->print(\"memory_and_swap_limit_in_bytes: \");\n-  if (j > 0) {\n-    st->print_cr(JLONG_FORMAT, j);\n-  } else {\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n-  }\n+  OSContainer::print_container_helper(st, OSContainer::memory_limit_in_bytes(), \"memory_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, OSContainer::memory_and_swap_limit_in_bytes(), \"memory_and_swap_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, OSContainer::memory_soft_limit_in_bytes(), \"memory_soft_limit_in_bytes\");\n+  OSContainer::print_container_helper(st, OSContainer::memory_usage_in_bytes(), \"memory_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, OSContainer::memory_max_usage_in_bytes(), \"memory_max_usage_in_bytes\");\n@@ -2295,7 +2401,1 @@\n-  j = OSContainer::memory_soft_limit_in_bytes();\n-  st->print(\"memory_soft_limit_in_bytes: \");\n-  if (j > 0) {\n-    st->print_cr(JLONG_FORMAT, j);\n-  } else {\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n-  }\n+  OSContainer::print_version_specific_info(st);\n@@ -2303,2 +2403,2 @@\n-  j = OSContainer::OSContainer::memory_usage_in_bytes();\n-  st->print(\"memory_usage_in_bytes: \");\n+  jlong j = OSContainer::pids_max();\n+  st->print(\"maximum number of tasks: \");\n@@ -2311,2 +2411,2 @@\n-  j = OSContainer::OSContainer::memory_max_usage_in_bytes();\n-  st->print(\"memory_max_usage_in_bytes: \");\n+  j = OSContainer::pids_current();\n+  st->print(\"current number of tasks: \");\n@@ -2316,1 +2416,3 @@\n-    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    if (j == OSCONTAINER_ERROR) {\n+      st->print_cr(\"not supported\");\n+    }\n@@ -2417,1 +2519,1 @@\n-      if (file_exists(hbuf_level)) {\n+      if (os::file_exists(hbuf_level)) {\n@@ -2517,0 +2619,2 @@\n+#elif defined(RISCV)\n+  strncpy(cpuinfo, \"RISCV64\", length);\n@@ -3046,0 +3150,21 @@\n+\n+  if (THPStackMitigation) {\n+    \/\/ If THPs are unconditionally enabled, the following scenario can lead to huge RSS\n+    \/\/ - parent thread spawns, in quick succession, multiple child threads\n+    \/\/ - child threads are slow to start\n+    \/\/ - thread stacks of future child threads are adjacent and get merged into one large VMA\n+    \/\/   by the kernel, and subsequently transformed into huge pages by khugepaged\n+    \/\/ - child threads come up, place JVM guard pages, thus splinter the large VMA, splinter\n+    \/\/   the huge pages into many (still paged-in) small pages.\n+    \/\/ The result of that sequence are thread stacks that are fully paged-in even though the\n+    \/\/ threads did not even start yet.\n+    \/\/ We prevent that by letting the glibc allocate a guard page, which causes a VMA with different\n+    \/\/ permission bits to separate two ajacent thread stacks and therefore prevent merging stacks\n+    \/\/ into one VMA.\n+    \/\/\n+    \/\/ Yes, this means we have two guard sections - the glibc and the JVM one - per thread. But the\n+    \/\/ cost for that one extra protected page is dwarfed from a large win in performance and memory\n+    \/\/ that avoiding interference by khugepaged buys us.\n+    return os::vm_page_size();\n+  }\n+\n@@ -3358,0 +3483,3 @@\n+      assert((uintptr_t)addr >= stack_extent,\n+             \"Sanity: addr should be larger than extent, \" PTR_FORMAT \" >= \" PTR_FORMAT,\n+             p2i(addr), stack_extent);\n@@ -3522,1 +3650,1 @@\n-  if (page_size != default_large_page_size()) {\n+  if (page_size != HugePages::default_static_hugepage_size()) {\n@@ -3630,73 +3758,0 @@\n-static size_t scan_default_large_page_size() {\n-  size_t default_large_page_size = 0;\n-\n-  \/\/ large_page_size on Linux is used to round up heap size. x86 uses either\n-  \/\/ 2M or 4M page, depending on whether PAE (Physical Address Extensions)\n-  \/\/ mode is enabled. AMD64\/EM64T uses 2M page in 64bit mode. IA64 can use\n-  \/\/ page as large as 1G.\n-  \/\/\n-  \/\/ Here we try to figure out page size by parsing \/proc\/meminfo and looking\n-  \/\/ for a line with the following format:\n-  \/\/    Hugepagesize:     2048 kB\n-  \/\/\n-  \/\/ If we can't determine the value (e.g. \/proc is not mounted, or the text\n-  \/\/ format has been changed), we'll set largest page size to 0\n-\n-  FILE *fp = fopen(\"\/proc\/meminfo\", \"r\");\n-  if (fp) {\n-    while (!feof(fp)) {\n-      int x = 0;\n-      char buf[16];\n-      if (fscanf(fp, \"Hugepagesize: %d\", &x) == 1) {\n-        if (x && fgets(buf, sizeof(buf), fp) && strcmp(buf, \" kB\\n\") == 0) {\n-          default_large_page_size = x * K;\n-          break;\n-        }\n-      } else {\n-        \/\/ skip to next line\n-        for (;;) {\n-          int ch = fgetc(fp);\n-          if (ch == EOF || ch == (int)'\\n') break;\n-        }\n-      }\n-    }\n-    fclose(fp);\n-  }\n-\n-  return default_large_page_size;\n-}\n-\n-static os::PageSizes scan_multiple_page_support() {\n-  \/\/ Scan \/sys\/kernel\/mm\/hugepages\n-  \/\/ to discover the available page sizes\n-  const char* sys_hugepages = \"\/sys\/kernel\/mm\/hugepages\";\n-  os::PageSizes page_sizes;\n-\n-  DIR *dir = opendir(sys_hugepages);\n-\n-  struct dirent *entry;\n-  size_t page_size;\n-  while ((entry = readdir(dir)) != NULL) {\n-    if (entry->d_type == DT_DIR &&\n-        sscanf(entry->d_name, \"hugepages-%zukB\", &page_size) == 1) {\n-      \/\/ The kernel is using kB, hotspot uses bytes\n-      \/\/ Add each found Large Page Size to page_sizes\n-      page_sizes.add(page_size * K);\n-    }\n-  }\n-  closedir(dir);\n-\n-  LogTarget(Debug, pagesize) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"Large Page sizes: \");\n-    page_sizes.print_on(&ls);\n-  }\n-\n-  return page_sizes;\n-}\n-\n-size_t os::Linux::default_large_page_size() {\n-  return _default_large_page_size;\n-}\n-\n@@ -3755,0 +3810,18 @@\n+struct LargePageInitializationLoggerMark {\n+  ~LargePageInitializationLoggerMark() {\n+    LogTarget(Info, pagesize) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      if (UseLargePages) {\n+        ls.print_cr(\"UseLargePages=1, UseTransparentHugePages=%d, UseHugeTLBFS=%d, UseSHM=%d\",\n+                    UseTransparentHugePages, UseHugeTLBFS, UseSHM);\n+        ls.print(\"Large page support enabled. Usable page sizes: \");\n+        os::page_sizes().print_on(&ls);\n+        ls.print_cr(\". Default large page size: \" EXACTFMT \".\", EXACTFMTARGS(os::large_page_size()));\n+      } else {\n+        ls.print(\"Large page support disabled.\");\n+      }\n+    }\n+  }\n+};\n+\n@@ -3756,2 +3829,21 @@\n-  \/\/ 1) Handle the case where we do not want to use huge pages and hence\n-  \/\/    there is no need to scan the OS for related info\n+  LargePageInitializationLoggerMark logger;\n+\n+  \/\/ Query OS information first.\n+  HugePages::initialize();\n+\n+  \/\/ If THPs are unconditionally enabled (THP mode \"always\"), khugepaged may attempt to\n+  \/\/ coalesce small pages in thread stacks to huge pages. That costs a lot of memory and\n+  \/\/ is usually unwanted for thread stacks. Therefore we attempt to prevent THP formation in\n+  \/\/ thread stacks unless the user explicitly allowed THP formation by manually disabling\n+  \/\/ -XX:-THPStackMitigation.\n+  if (HugePages::thp_mode() == THPMode::always) {\n+    if (THPStackMitigation) {\n+      log_info(pagesize)(\"JVM will attempt to prevent THPs in thread stacks.\");\n+    } else {\n+      log_info(pagesize)(\"JVM will *not* prevent THPs in thread stacks. This may cause high RSS.\");\n+    }\n+  } else {\n+    FLAG_SET_ERGO(THPStackMitigation, false); \/\/ Mitigation not needed\n+  }\n+\n+  \/\/ 1) Handle the case where we do not want to use huge pages\n@@ -3775,5 +3867,9 @@\n-  \/\/ 2) Scan OS info\n-  size_t default_large_page_size = scan_default_large_page_size();\n-  os::Linux::_default_large_page_size = default_large_page_size;\n-  if (default_large_page_size == 0) {\n-    \/\/ No large pages configured, return.\n+  \/\/ 2) check if the OS supports THPs resp. static hugepages.\n+  if (UseTransparentHugePages && !HugePages::supports_thp()) {\n+    if (!FLAG_IS_DEFAULT(UseTransparentHugePages)) {\n+      log_warning(pagesize)(\"UseTransparentHugePages disabled, transparent huge pages are not supported by the operating system.\");\n+    }\n+    UseLargePages = UseTransparentHugePages = UseHugeTLBFS = UseSHM = false;\n+    return;\n+  }\n+  if (!UseTransparentHugePages && !HugePages::supports_static_hugepages()) {\n@@ -3781,4 +3877,1 @@\n-    UseLargePages = false;\n-    UseTransparentHugePages = false;\n-    UseHugeTLBFS = false;\n-    UseSHM = false;\n+    UseLargePages = UseTransparentHugePages = UseHugeTLBFS = UseSHM = false;\n@@ -3787,19 +3880,10 @@\n-  os::PageSizes all_large_pages = scan_multiple_page_support();\n-\n-  \/\/ 3) Consistency check and post-processing\n-\n-  \/\/ It is unclear if \/sys\/kernel\/mm\/hugepages\/ and \/proc\/meminfo could disagree. Manually\n-  \/\/ re-add the default page size to the list of page sizes to be sure.\n-  all_large_pages.add(default_large_page_size);\n-\n-  \/\/ Check LargePageSizeInBytes matches an available page size and if so set _large_page_size\n-  \/\/ using LargePageSizeInBytes as the maximum allowed large page size. If LargePageSizeInBytes\n-  \/\/ doesn't match an available page size set _large_page_size to default_large_page_size\n-  \/\/ and use it as the maximum.\n- if (FLAG_IS_DEFAULT(LargePageSizeInBytes) ||\n-      LargePageSizeInBytes == 0 ||\n-      LargePageSizeInBytes == default_large_page_size) {\n-    _large_page_size = default_large_page_size;\n-    log_info(pagesize)(\"Using the default large page size: \" SIZE_FORMAT \"%s\",\n-                       byte_size_in_exact_unit(_large_page_size),\n-                       exact_unit_for_byte_size(_large_page_size));\n+\n+  if (UseTransparentHugePages) {\n+    \/\/ In THP mode:\n+    \/\/ - os::large_page_size() is the *THP page size*\n+    \/\/ - os::pagesizes() has two members, the THP page size and the system page size\n+    assert(HugePages::supports_thp() && HugePages::thp_pagesize() > 0, \"Missing OS info\");\n+    _large_page_size = HugePages::thp_pagesize();\n+    _page_sizes.add(_large_page_size);\n+    _page_sizes.add(os::vm_page_size());\n+\n@@ -3807,9 +3891,17 @@\n-    if (all_large_pages.contains(LargePageSizeInBytes)) {\n-      _large_page_size = LargePageSizeInBytes;\n-      log_info(pagesize)(\"Overriding default large page size (\" SIZE_FORMAT \"%s) \"\n-                         \"using LargePageSizeInBytes: \" SIZE_FORMAT \"%s\",\n-                         byte_size_in_exact_unit(default_large_page_size),\n-                         exact_unit_for_byte_size(default_large_page_size),\n-                         byte_size_in_exact_unit(_large_page_size),\n-                         exact_unit_for_byte_size(_large_page_size));\n-    } else {\n+\n+    \/\/ In static hugepage mode:\n+    \/\/ - os::large_page_size() is the default static hugepage size (\/proc\/meminfo \"Hugepagesize\")\n+    \/\/ - os::pagesizes() contains all hugepage sizes the kernel supports, regardless whether there\n+    \/\/   are pages configured in the pool or not (from \/sys\/kernel\/hugepages\/hugepage-xxxx ...)\n+    os::PageSizes all_large_pages = HugePages::static_info().pagesizes();\n+    const size_t default_large_page_size = HugePages::default_static_hugepage_size();\n+\n+    \/\/ 3) Consistency check and post-processing\n+\n+    \/\/ Check LargePageSizeInBytes matches an available page size and if so set _large_page_size\n+    \/\/ using LargePageSizeInBytes as the maximum allowed large page size. If LargePageSizeInBytes\n+    \/\/ doesn't match an available page size set _large_page_size to default_large_page_size\n+    \/\/ and use it as the maximum.\n+   if (FLAG_IS_DEFAULT(LargePageSizeInBytes) ||\n+        LargePageSizeInBytes == 0 ||\n+        LargePageSizeInBytes == default_large_page_size) {\n@@ -3817,4 +3909,1 @@\n-      log_info(pagesize)(\"LargePageSizeInBytes is not a valid large page size (\" SIZE_FORMAT \"%s) \"\n-                         \"using the default large page size: \" SIZE_FORMAT \"%s\",\n-                         byte_size_in_exact_unit(LargePageSizeInBytes),\n-                         exact_unit_for_byte_size(LargePageSizeInBytes),\n+      log_info(pagesize)(\"Using the default large page size: \" SIZE_FORMAT \"%s\",\n@@ -3823,0 +3912,18 @@\n+    } else {\n+      if (all_large_pages.contains(LargePageSizeInBytes)) {\n+        _large_page_size = LargePageSizeInBytes;\n+        log_info(pagesize)(\"Overriding default large page size (\" SIZE_FORMAT \"%s) \"\n+                           \"using LargePageSizeInBytes: \" SIZE_FORMAT \"%s\",\n+                           byte_size_in_exact_unit(default_large_page_size),\n+                           exact_unit_for_byte_size(default_large_page_size),\n+                           byte_size_in_exact_unit(_large_page_size),\n+                           exact_unit_for_byte_size(_large_page_size));\n+      } else {\n+        _large_page_size = default_large_page_size;\n+        log_info(pagesize)(\"LargePageSizeInBytes is not a valid large page size (\" SIZE_FORMAT \"%s) \"\n+                           \"using the default large page size: \" SIZE_FORMAT \"%s\",\n+                           byte_size_in_exact_unit(LargePageSizeInBytes),\n+                           exact_unit_for_byte_size(LargePageSizeInBytes),\n+                           byte_size_in_exact_unit(_large_page_size),\n+                           exact_unit_for_byte_size(_large_page_size));\n+      }\n@@ -3824,13 +3931,6 @@\n-  }\n-  \/\/ Populate _page_sizes with large page sizes less than or equal to\n-  \/\/ _large_page_size.\n-  for (size_t page_size = _large_page_size; page_size != 0;\n-         page_size = all_large_pages.next_smaller(page_size)) {\n-    _page_sizes.add(page_size);\n-  }\n-\n-  LogTarget(Info, pagesize) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"Usable page sizes: \");\n-    _page_sizes.print_on(&ls);\n+    \/\/ Populate _page_sizes with large page sizes less than or equal to\n+    \/\/ _large_page_size.\n+    for (size_t page_size = _large_page_size; page_size != 0;\n+           page_size = all_large_pages.next_smaller(page_size)) {\n+      _page_sizes.add(page_size);\n+    }\n@@ -4203,7 +4303,0 @@\n-\/\/ Sleep forever; naked call to OS-specific sleep; use with CAUTION\n-void os::infinite_sleep() {\n-  while (true) {    \/\/ sleep forever ...\n-    ::sleep(100);   \/\/ ... 100 seconds at a time\n-  }\n-}\n-\n@@ -4522,4 +4615,0 @@\n-  if (AdjustStackSizeForTLS) {\n-    get_minstack_init();\n-  }\n-\n@@ -4548,0 +4637,5 @@\n+#ifdef __GLIBC__\n+  \/\/ Check if we need to adjust the stack size for glibc guard pages.\n+  init_adjust_stacksize_for_guard_pages();\n+#endif\n+\n@@ -4608,0 +4702,9 @@\n+  \/\/ Override the timer slack value if needed. The adjustment for the main\n+  \/\/ thread will establish the setting for child threads, which would be\n+  \/\/ most threads in JDK\/JVM.\n+  if (TimerSlack >= 0) {\n+    if (prctl(PR_SET_TIMERSLACK, TimerSlack) < 0) {\n+      vm_exit_during_initialization(\"Setting timer slack failed: %s\", os::strerror(errno));\n+    }\n+  }\n+\n@@ -4637,1 +4740,2 @@\n-int os::Linux::active_processor_count() {\n+static int get_active_processor_count() {\n+  \/\/ Note: keep this function, with its CPU_xx macros, *outside* the os namespace (see JDK-8289477).\n@@ -4709,0 +4813,4 @@\n+int os::Linux::active_processor_count() {\n+  return get_active_processor_count();\n+}\n+\n@@ -4856,41 +4964,0 @@\n-void os::print_statistics() {\n-}\n-\n-bool os::message_box(const char* title, const char* message) {\n-  int i;\n-  fdStream err(defaultStream::error_fd());\n-  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n-  err.cr();\n-  err.print_raw_cr(title);\n-  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n-  err.cr();\n-  err.print_raw_cr(message);\n-  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n-  err.cr();\n-\n-  char buf[16];\n-  \/\/ Prevent process from exiting upon \"read error\" without consuming all CPU\n-  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n-\n-  return buf[0] == 'y' || buf[0] == 'Y';\n-}\n-\n-\/\/ Is a (classpath) directory empty?\n-bool os::dir_is_empty(const char* path) {\n-  DIR *dir = NULL;\n-  struct dirent *ptr;\n-\n-  dir = opendir(path);\n-  if (dir == NULL) return true;\n-\n-  \/\/ Scan the directory\n-  bool result = true;\n-  while (result && (ptr = readdir(dir)) != NULL) {\n-    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n-      result = false;\n-    }\n-  }\n-  closedir(dir);\n-  return result;\n-}\n-\n@@ -4979,3 +5046,1 @@\n-  if (!rewrite_existing) {\n-    oflags |= O_EXCL;\n-  }\n+  oflags |= rewrite_existing ? O_TRUNC : O_EXCL;\n@@ -5360,3 +5425,3 @@\n-\/\/ ** Due to NPTL implementation error, linux takes the glibc guard page out\n-\/\/    of the stack size given in pthread_attr. We work around this for\n-\/\/    threads created by the VM. (We adapt bottom to be P1 and size accordingly.)\n+\/\/ ** If adjustStackSizeForGuardPages() is true the guard pages have been taken\n+\/\/    out of the stack size given in pthread_attr. We work around this for\n+\/\/    threads created by the VM. We adjust bottom to be P1 and size accordingly.\n@@ -5389,5 +5454,8 @@\n-    \/\/ Work around NPTL stack guard error.\n-    size_t guard_size = 0;\n-    rslt = pthread_attr_getguardsize(&attr, &guard_size);\n-    if (rslt != 0) {\n-      fatal(\"pthread_attr_getguardsize failed with error = %d\", rslt);\n+    if (os::Linux::adjustStackSizeForGuardPages()) {\n+      size_t guard_size = 0;\n+      rslt = pthread_attr_getguardsize(&attr, &guard_size);\n+      if (rslt != 0) {\n+        fatal(\"pthread_attr_getguardsize failed with error = %d\", rslt);\n+      }\n+      *bottom += guard_size;\n+      *size   -= guard_size;\n@@ -5395,2 +5463,0 @@\n-    *bottom += guard_size;\n-    *size   -= guard_size;\n@@ -5444,0 +5510,1 @@\n+  \/\/ Note: all ranges are \"[..)\"\n@@ -5449,1 +5516,1 @@\n-    st->print(\"Range [%llx-%llx) contains: \", start, end);\n+    st->print_cr(\"Range [%llx-%llx) contains: \", start, end);\n@@ -5452,3 +5519,3 @@\n-      unsigned long long a1 = 0;\n-      unsigned long long a2 = 0;\n-      if (::sscanf(line, \"%llx-%llx\", &a1, &a2) == 2) {\n+      unsigned long long segment_start = 0;\n+      unsigned long long segment_end = 0;\n+      if (::sscanf(line, \"%llx-%llx\", &segment_start, &segment_end) == 2) {\n@@ -5456,3 +5523,1 @@\n-        if ((a1 >= start && a1 < end) || \/\/ left leg in\n-            (a2 >= start && a2 < end) || \/\/ right leg in\n-            (a1 < start && a2 >= end)) { \/\/ superimposition\n+        if (segment_start < end && segment_end > start) {\n@@ -5466,1 +5531,1 @@\n-      st->print(\"nothing.\");\n+      st->print_cr(\"nothing.\");\n@@ -5471,0 +5536,29 @@\n+\n+bool os::trim_native_heap(os::size_change_t* rss_change) {\n+#ifdef __GLIBC__\n+  os::Linux::meminfo_t info1;\n+  os::Linux::meminfo_t info2;\n+\n+  bool have_info1 = rss_change != nullptr &&\n+                    os::Linux::query_process_memory_info(&info1);\n+  ::malloc_trim(0);\n+  bool have_info2 = rss_change != nullptr && have_info1 &&\n+                    os::Linux::query_process_memory_info(&info2);\n+  ssize_t delta = (ssize_t) -1;\n+  if (rss_change != nullptr) {\n+    if (have_info1 && have_info2 &&\n+        info1.vmrss != -1 && info2.vmrss != -1 &&\n+        info1.vmswap != -1 && info2.vmswap != -1) {\n+      \/\/ Note: query_process_memory_info returns values in K\n+      rss_change->before = (info1.vmrss + info1.vmswap) * K;\n+      rss_change->after = (info2.vmrss + info2.vmswap) * K;\n+    } else {\n+      rss_change->after = rss_change->before = SIZE_MAX;\n+    }\n+  }\n+\n+  return true;\n+#else\n+  return false; \/\/ musl\n+#endif\n+}\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":418,"deletions":324,"binary":false,"changes":742,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,0 @@\n-  static size_t _default_large_page_size;\n-\n@@ -63,2 +61,0 @@\n-  static julong physical_memory() { return _physical_memory; }\n-  static void set_physical_memory(julong phys_mem) { _physical_memory = phys_mem; }\n@@ -82,4 +78,0 @@\n-  static size_t default_large_page_size();\n-  static size_t scan_default_large_page_size();\n-  static os::PageSizes scan_multiple_page_support();\n-\n@@ -125,0 +117,1 @@\n+  static const char *dll_path(void* lib);\n@@ -140,0 +133,3 @@\n+  static julong physical_memory() { return _physical_memory; }\n+  static julong host_swap();\n+\n@@ -157,0 +153,2 @@\n+  static bool adjustStackSizeForGuardPages(); \/\/ See comments in os_linux.cpp\n+\n@@ -179,0 +177,17 @@\n+  \/\/ Output structure for query_process_memory_info()\n+  struct meminfo_t {\n+    ssize_t vmsize;     \/\/ current virtual size\n+    ssize_t vmpeak;     \/\/ peak virtual size\n+    ssize_t vmrss;      \/\/ current resident set size\n+    ssize_t vmhwm;      \/\/ peak resident set size\n+    ssize_t vmswap;     \/\/ swapped out\n+    ssize_t rssanon;    \/\/ resident set size (anonymous mappings, needs 4.5)\n+    ssize_t rssfile;    \/\/ resident set size (file mappings, needs 4.5)\n+    ssize_t rssshmem;   \/\/ resident set size (shared mappings, needs 4.5)\n+  };\n+\n+  \/\/ Attempts to query memory information about the current process and return it in the output structure.\n+  \/\/ May fail (returns false) or succeed (returns true) but not all output fields are available; unavailable\n+  \/\/ fields will contain -1.\n+  static bool query_process_memory_info(meminfo_t* info);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"utilities\/defaultStream.hpp\"\n@@ -57,0 +58,1 @@\n+#include <locale.h>\n@@ -240,0 +242,19 @@\n+\/\/ Is a (classpath) directory empty?\n+bool os::dir_is_empty(const char* path) {\n+  DIR *dir = NULL;\n+  struct dirent *ptr;\n+\n+  dir = ::opendir(path);\n+  if (dir == NULL) return true;\n+\n+  \/\/ Scan the directory\n+  bool result = true;\n+  while (result && (ptr = ::readdir(dir)) != NULL) {\n+    if (strcmp(ptr->d_name, \".\") != 0 && strcmp(ptr->d_name, \"..\") != 0) {\n+      result = false;\n+    }\n+  }\n+  ::closedir(dir);\n+  return result;\n+}\n+\n@@ -545,0 +566,27 @@\n+\/\/ Print all active locale categories, one line each\n+void os::Posix::print_active_locale(outputStream* st) {\n+  st->print_cr(\"Active Locale:\");\n+  \/\/ Posix is quiet about how exactly LC_ALL is implemented.\n+  \/\/ Just print it out too, in case LC_ALL is held separately\n+  \/\/ from the individual categories.\n+  #define LOCALE_CAT_DO(f) \\\n+    f(LC_ALL) \\\n+    f(LC_COLLATE) \\\n+    f(LC_CTYPE) \\\n+    f(LC_MESSAGES) \\\n+    f(LC_MONETARY) \\\n+    f(LC_NUMERIC) \\\n+    f(LC_TIME)\n+  #define XX(cat) { cat, #cat },\n+  const struct { int c; const char* name; } categories[] = {\n+      LOCALE_CAT_DO(XX)\n+      { -1, NULL }\n+  };\n+  #undef XX\n+  #undef LOCALE_CAT_DO\n+  for (int i = 0; categories[i].c != -1; i ++) {\n+    const char* locale = setlocale(categories[i].c, NULL);\n+    st->print_cr(\"%s=%s\", categories[i].name,\n+                 ((locale != NULL) ? locale : \"<unknown>\"));\n+  }\n+}\n@@ -637,0 +685,15 @@\n+void* os::get_default_process_handle() {\n+#ifdef __APPLE__\n+  \/\/ MacOS X needs to use RTLD_FIRST instead of RTLD_LAZY\n+  \/\/ to avoid finding unexpected symbols on second (or later)\n+  \/\/ loads of a library.\n+  return (void*)::dlopen(NULL, RTLD_FIRST);\n+#else\n+  return (void*)::dlopen(NULL, RTLD_LAZY);\n+#endif\n+}\n+\n+void* os::dll_lookup(void* handle, const char* name) {\n+  return dlsym(handle, name);\n+}\n+\n@@ -638,1 +701,20 @@\n-  ::dlclose(lib);\n+  const char* l_path = LINUX_ONLY(os::Linux::dll_path(lib))\n+                       NOT_LINUX(\"<not available>\");\n+  if (l_path == NULL) l_path = \"<not available>\";\n+  int res = ::dlclose(lib);\n+\n+  if (res == 0) {\n+    Events::log_dll_message(NULL, \"Unloaded shared library \\\"%s\\\" [\" INTPTR_FORMAT \"]\",\n+                            l_path, p2i(lib));\n+    log_info(os)(\"Unloaded shared library \\\"%s\\\" [\" INTPTR_FORMAT \"]\", l_path, p2i(lib));\n+  } else {\n+    const char* error_report = ::dlerror();\n+    if (error_report == NULL) {\n+      error_report = \"dlerror returned no error description\";\n+    }\n+\n+    Events::log_dll_message(NULL, \"Attempt to unload shared library \\\"%s\\\" [\" INTPTR_FORMAT \"] failed, %s\",\n+                            l_path, p2i(lib), error_report);\n+    log_info(os)(\"Attempt to unload shared library \\\"%s\\\" [\" INTPTR_FORMAT \"] failed, %s\",\n+                  l_path, p2i(lib), error_report);\n+  }\n@@ -734,4 +816,0 @@\n-struct hostent* os::get_host_by_name(char* name) {\n-  return ::gethostbyname(name);\n-}\n-\n@@ -787,0 +865,6 @@\n+\/\/ Sleep forever; naked call to OS-specific sleep; use with CAUTION\n+void os::infinite_sleep() {\n+  while (true) {    \/\/ sleep forever ...\n+    ::sleep(100);   \/\/ ... 100 seconds at a time\n+  }\n+}\n@@ -809,2 +893,2 @@\n-  \/\/ Work around linux NPTL implementation error, see also os::create_thread() in os_linux.cpp.\n-  LINUX_ONLY(stack_size -= guard_size);\n+  \/\/ Work around glibc stack guard issue, see os::create_thread() in os_linux.cpp.\n+  LINUX_ONLY(if (os::Linux::adjustStackSizeForGuardPages()) stack_size -= guard_size;)\n@@ -1901,0 +1985,3 @@\n+  #ifdef __APPLE__\n+  pid = ::fork();\n+  #else\n@@ -1902,0 +1989,1 @@\n+  #endif\n@@ -1948,0 +2036,19 @@\n+bool os::message_box(const char* title, const char* message) {\n+  int i;\n+  fdStream err(defaultStream::error_fd());\n+  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n+  err.cr();\n+  err.print_raw_cr(title);\n+  for (i = 0; i < 78; i++) err.print_raw(\"-\");\n+  err.cr();\n+  err.print_raw_cr(message);\n+  for (i = 0; i < 78; i++) err.print_raw(\"=\");\n+  err.cr();\n+\n+  char buf[16];\n+  \/\/ Prevent process from exiting upon \"read error\" without consuming all CPU\n+  while (::read(0, buf, sizeof(buf)) <= 0) { ::sleep(100); }\n+\n+  return buf[0] == 'y' || buf[0] == 'Y';\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":114,"deletions":7,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+#if defined(LINUX)\n+# include <sys\/file.h>\n+#endif\n+\n@@ -85,12 +89,0 @@\n-\/\/ delete the PerfData memory region\n-\/\/\n-static void delete_standard_memory(char* addr, size_t size) {\n-\n-  \/\/ there are no persistent external resources to cleanup for standard\n-  \/\/ memory. since DestroyJavaVM does not support unloading of the JVM,\n-  \/\/ cleanup of the memory resource is not performed. The memory will be\n-  \/\/ reclaimed by the OS upon termination of the process.\n-  \/\/\n-  return;\n-}\n-\n@@ -717,2 +709,1 @@\n-\n-\/\/ cleanup stale shared memory resources\n+\/\/ cleanup stale shared memory files\n@@ -722,4 +713,5 @@\n-\/\/ for files matching the pattern ^$[0-9]*$. For each file found, the\n-\/\/ process id is extracted from the file name and a test is run to\n-\/\/ determine if the process is alive. If the process is not alive,\n-\/\/ any stale file resources are removed.\n+\/\/ for files matching the pattern ^$[0-9]*$.\n+\/\/\n+\/\/ This directory should be used only by JVM processes owned by the\n+\/\/ current user to store PerfMemory files. Any other files found\n+\/\/ in this directory may be removed.\n@@ -727,1 +719,1 @@\n-static void cleanup_sharedmem_resources(const char* dirname) {\n+static void cleanup_sharedmem_files(const char* dirname) {\n@@ -737,7 +729,6 @@\n-  \/\/ for each entry in the directory that matches the expected file\n-  \/\/ name pattern, determine if the file resources are stale and if\n-  \/\/ so, remove the file resources. Note, instrumented HotSpot processes\n-  \/\/ for this user may start and\/or terminate during this search and\n-  \/\/ remove or create new files in this directory. The behavior of this\n-  \/\/ loop under these conditions is dependent upon the implementation of\n-  \/\/ opendir\/readdir.\n+  \/\/ For each entry in the directory that matches the expected file\n+  \/\/ name pattern, remove the file if it's determine to be stale\n+  \/\/ Note, instrumented HotSpot processes for this user may start and\/or\n+  \/\/ terminate during this search and remove or create new files in this\n+  \/\/ directory. The behavior of this loop under these conditions is dependent\n+  \/\/ upon the implementation of opendir\/readdir.\n@@ -748,2 +739,2 @@\n-\n-    pid_t pid = filename_to_pid(entry->d_name);\n+    const char* filename = entry->d_name;\n+    pid_t pid = filename_to_pid(filename);\n@@ -752,2 +743,1 @@\n-\n-      if (strcmp(entry->d_name, \".\") != 0 && strcmp(entry->d_name, \"..\") != 0) {\n+      if (strcmp(filename, \".\") != 0 && strcmp(filename, \"..\") != 0) {\n@@ -755,1 +745,1 @@\n-        unlink(entry->d_name);\n+        unlink(filename);\n@@ -762,12 +752,3 @@\n-    \/\/ we now have a file name that converts to a valid integer\n-    \/\/ that could represent a process id . if this process id\n-    \/\/ matches the current process id or the process is not running,\n-    \/\/ then remove the stale file resources.\n-    \/\/\n-    \/\/ process liveness is detected by sending signal number 0 to\n-    \/\/ the process id (see kill(2)). if kill determines that the\n-    \/\/ process does not exist, then the file resources are removed.\n-    \/\/ if kill determines that that we don't have permission to\n-    \/\/ signal the process, then the file resources are assumed to\n-    \/\/ be stale and are removed because the resources for such a\n-    \/\/ process should be in a different user specific directory.\n+#if defined(LINUX)\n+    \/\/ Special case on Linux, if multiple containers share the\n+    \/\/ same \/tmp directory:\n@@ -775,3 +756,49 @@\n-    if ((pid == os::current_process_id()) ||\n-        (kill(pid, 0) == OS_ERR && (errno == ESRCH || errno == EPERM))) {\n-        unlink(entry->d_name);\n+    \/\/ - All the JVMs must have the JDK-8286030 fix, or the behavior\n+    \/\/   is undefined.\n+    \/\/ - We cannot rely on the values of the pid, because it could\n+    \/\/   be a process in a different namespace. We must use the flock\n+    \/\/   protocol to determine if a live process is using this file.\n+    \/\/   See create_sharedmem_file().\n+    int fd;\n+    RESTARTABLE(os::open(filename, O_RDONLY, 0), fd);\n+    if (fd == OS_ERR) {\n+      \/\/ Something wrong happened. Ignore the error and don't try to remove the\n+      \/\/ file.\n+      log_debug(perf, memops)(\"os::open() for stale file check failed for %s\/%s\", dirname, filename);\n+      errno = 0;\n+      continue;\n+    }\n+\n+    int n;\n+    RESTARTABLE(::flock(fd, LOCK_EX|LOCK_NB), n);\n+    if (n != 0) {\n+      \/\/ Either another process holds the exclusive lock on this file, or\n+      \/\/ something wrong happened. Ignore the error and don't try to remove the\n+      \/\/ file.\n+      log_debug(perf, memops)(\"flock for stale file check failed for %s\/%s\", dirname, filename);\n+      ::close(fd);\n+      errno = 0;\n+      continue;\n+    }\n+    \/\/ We are able to lock the file, but this file might have been created\n+    \/\/ by an older JVM that doesn't use the flock prototol, so we must do\n+    \/\/ the folowing checks (which are also done by older JVMs).\n+#endif\n+\n+    \/\/ The following code assumes that pid must be in the same\n+    \/\/ namespace as the current process.\n+    bool stale = false;\n+\n+    if (pid == os::current_process_id()) {\n+      \/\/ The file was created by a terminated process that happened\n+      \/\/ to have the same pid as the current process.\n+      stale = true;\n+    } else if (kill(pid, 0) == OS_ERR) {\n+      if (errno == ESRCH) {\n+        \/\/ The target process does not exist.\n+        stale = true;\n+      } else if (errno == EPERM) {\n+        \/\/ The file was created by a terminated process that happened\n+        \/\/ to have the same pid as a process not owned by the current user.\n+        stale = true;\n+      }\n@@ -779,0 +806,12 @@\n+\n+    if (stale) {\n+      log_info(perf, memops)(\"Remove stale file %s\/%s\", dirname, filename);\n+      unlink(filename);\n+    }\n+\n+#if defined(LINUX)\n+    \/\/ Hold the lock until here to prevent other JVMs from using this file\n+    \/\/ while we were in the middle of deleting it.\n+    ::close(fd);\n+#endif\n+\n@@ -824,1 +863,1 @@\n-\/\/ create the shared memory file resources\n+\/\/ create the shared memory file\n@@ -830,1 +869,1 @@\n-static int create_sharedmem_resources(const char* dirname, const char* filename, size_t size) {\n+static int create_sharedmem_file(const char* dirname, const char* filename, size_t size) {\n@@ -878,0 +917,26 @@\n+#if defined(LINUX)\n+  \/\/ On Linux, different containerized processes that share the same \/tmp\n+  \/\/ directory (e.g., with \"docker --volume ...\") may have the same pid and\n+  \/\/ try to use the same file. To avoid conflicts among such\n+  \/\/ processes, we allow only one of them (the winner of the flock() call)\n+  \/\/ to write to the file. All the other processes will give up and will\n+  \/\/ have perfdata disabled.\n+  \/\/\n+  \/\/ Note that the flock will be automatically given up when the winner\n+  \/\/ process exits.\n+  \/\/\n+  \/\/ The locking protocol works only with other JVMs that have the JDK-8286030\n+  \/\/ fix. If you are sharing the \/tmp difrectory among different containers,\n+  \/\/ do not use older JVMs that don't have this fix, or the behavior is undefined.\n+  int n;\n+  RESTARTABLE(::flock(fd, LOCK_EX|LOCK_NB), n);\n+  if (n != 0) {\n+    log_warning(perf, memops)(\"Cannot use file %s\/%s because %s (errno = %d)\", dirname, filename,\n+                              (errno == EWOULDBLOCK) ?\n+                              \"it is locked by another process\" :\n+                              \"flock() failed\", errno);\n+    ::close(fd);\n+    return -1;\n+  }\n+#endif\n+\n@@ -992,1 +1057,1 @@\n-  cleanup_sharedmem_resources(dirname);\n+  cleanup_sharedmem_files(dirname);\n@@ -997,1 +1062,2 @@\n-  fd = create_sharedmem_resources(dirname, short_filename, size);\n+  log_info(perf, memops)(\"Trying to open %s\/%s\", dirname, short_filename);\n+  fd = create_sharedmem_file(dirname, short_filename, size);\n@@ -1030,0 +1096,2 @@\n+  log_info(perf, memops)(\"Successfully opened\");\n+\n@@ -1059,2 +1127,2 @@\n-  \/\/ cleanup the persistent shared memory resources. since DestroyJavaVM does\n-  \/\/ not support unloading of the JVM, unmapping of the memory resource is\n+  \/\/ Remove the shared memory file. Since DestroyJavaVM does\n+  \/\/ not support unloading of the JVM, unmapping of the memory region is\n@@ -1062,1 +1130,1 @@\n-  \/\/ the process. The backing store file is deleted from the file system.\n+  \/\/ the process.\n@@ -1271,4 +1339,1 @@\n-  if (PerfDisableSharedMem) {\n-    delete_standard_memory(start(), capacity());\n-  }\n-  else {\n+  if (!PerfDisableSharedMem) {\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":122,"deletions":57,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"runtime\/safefetch.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"runtime\/stubRoutines.hpp\"\n@@ -43,6 +43,0 @@\n-#ifdef ZERO\n-\/\/ See stubGenerator_zero.cpp\n-#include <setjmp.h>\n-extern sigjmp_buf* get_jmp_buf_for_continuation();\n-#endif\n-\n@@ -344,1 +338,1 @@\n-\/\/ sun.misc.Signal support\n+\/\/ sun.misc.Signal and BREAK_SIGNAL support\n@@ -597,17 +591,15 @@\n-  if (!signal_was_handled) {\n-    \/\/ Handle SafeFetch access.\n-#ifndef ZERO\n-    if (uc != NULL) {\n-      address pc = os::Posix::ucontext_get_pc(uc);\n-      if (StubRoutines::is_safefetch_fault(pc)) {\n-        os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n-        signal_was_handled = true;\n-      }\n-    }\n-#else\n-    \/\/ See JDK-8076185\n-    if (sig == SIGSEGV || sig == SIGBUS) {\n-      sigjmp_buf* const pjb = get_jmp_buf_for_continuation();\n-      if (pjb) {\n-        siglongjmp(*pjb, 1);\n-      }\n+  \/\/ Extract pc from context. Note that for certain signals and certain\n+  \/\/ architectures the pc in ucontext_t will point *after* the offending\n+  \/\/ instruction. In those cases, use siginfo si_addr instead.\n+  address pc = NULL;\n+  if (uc != NULL) {\n+    if (S390_ONLY(sig == SIGILL || sig == SIGFPE) NOT_S390(false)) {\n+      pc = (address)info->si_addr;\n+    } else if (ZERO_ONLY(true) NOT_ZERO(false)) {\n+      \/\/ Non-arch-specific Zero code does not really know the pc.\n+      \/\/ This can be alleviated by making arch-specific os::Posix::ucontext_get_pc\n+      \/\/ available for Zero for known architectures. But for generic Zero\n+      \/\/ code, it would still remain unknown.\n+      pc = NULL;\n+    } else {\n+      pc = os::Posix::ucontext_get_pc(uc);\n@@ -615,1 +607,4 @@\n-#endif \/\/ ZERO\n+  }\n+\n+  if (!signal_was_handled) {\n+    signal_was_handled = handle_safefetch(sig, pc, uc);\n@@ -640,16 +635,0 @@\n-    \/\/ Extract pc from context for the error handler to display.\n-    address pc = NULL;\n-    if (uc != NULL) {\n-      \/\/ prepare fault pc address for error reporting.\n-      if (S390_ONLY(sig == SIGILL || sig == SIGFPE) NOT_S390(false)) {\n-        pc = (address)info->si_addr;\n-      } else if (ZERO_ONLY(true) NOT_ZERO(false)) {\n-        \/\/ Non-arch-specific Zero code does not really know the pc.\n-        \/\/ This can be alleviated by making arch-specific os::Posix::ucontext_get_pc\n-        \/\/ available for Zero for known architectures. But for generic Zero\n-        \/\/ code, it would still remain unknown.\n-        pc = NULL;\n-      } else {\n-        pc = os::Posix::ucontext_get_pc(uc);\n-      }\n-    }\n@@ -1148,1 +1127,5 @@\n-    os->print(\", si_band: %ld\", si->si_band);\n+    \/\/ siginfo_t.si_band is defined as \"long\", and it is so in most\n+    \/\/ implementations. But SPARC64 glibc has a bug: si_band is \"int\".\n+    \/\/ Cast si_band to \"long\" to prevent format specifier mismatch.\n+    \/\/ See: https:\/\/sourceware.org\/bugzilla\/show_bug.cgi?id=23821\n+    os->print(\", si_band: %ld\", (long) si->si_band);\n@@ -1238,1 +1221,1 @@\n-  \/\/ Save handler setup for later checking\n+  \/\/ Save handler setup for possible later checking\n@@ -1240,0 +1223,1 @@\n+\n@@ -1278,0 +1262,18 @@\n+  if (!ReduceSignalUsage) {\n+    \/\/ Install BREAK_SIGNAL's handler in early initialization phase, in\n+    \/\/ order to reduce the risk that an attach client accidentally forces\n+    \/\/ HotSpot to quit prematurely.\n+    \/\/ The actual work for handling BREAK_SIGNAL is performed by the Signal\n+    \/\/ Dispatcher thread, which is created and started at a much later point,\n+    \/\/ see os::initialize_jdk_signal_support(). Any BREAK_SIGNAL received\n+    \/\/ before the Signal Dispatcher thread is started is queued up via the\n+    \/\/ pending_signals[BREAK_SIGNAL] counter, and will be processed by the\n+    \/\/ Signal Dispatcher thread in a delayed fashion.\n+    \/\/\n+    \/\/ Also note that HotSpot does NOT support signal chaining for BREAK_SIGNAL.\n+    \/\/ Applications that require a custom BREAK_SIGNAL handler should run with\n+    \/\/ -XX:+ReduceSignalUsage. Otherwise if libjsig is used together with\n+    \/\/ -XX:+ReduceSignalUsage, libjsig will prevent changing BREAK_SIGNAL's\n+    \/\/ handler to a custom handler.\n+    os::signal(BREAK_SIGNAL, os::user_handler());\n+  }\n@@ -1361,1 +1363,0 @@\n-\n@@ -1378,0 +1379,5 @@\n+\n+  sigset_t thread_sig_mask;\n+  if (::pthread_sigmask(\/* ignored *\/ SIG_BLOCK, NULL, &thread_sig_mask) == 0) {\n+    st->print(\", %s\", sigismember(&thread_sig_mask, sig) ? \"blocked\" : \"unblocked\");\n+  }\n@@ -1783,3 +1789,1 @@\n-  install_signal_handlers();\n-\n-  \/\/ Initialize data for jdk.internal.misc.Signal\n+  \/\/ Initialize data for jdk.internal.misc.Signal and BREAK_SIGNAL's handler.\n@@ -1790,0 +1794,2 @@\n+  install_signal_handlers();\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":55,"deletions":49,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n-\/\/ Must be at least Windows Vista or Server 2008 to use InitOnceExecuteOnce\n-#define _WIN32_WINNT 0x0600\n+\/\/ API level must be at least Windows Vista or Server 2008 to use InitOnceExecuteOnce\n@@ -60,1 +59,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -93,0 +93,1 @@\n+#include <powerbase.h>\n@@ -629,2 +630,4 @@\n-  log_info(os, thread)(\"Thread attached (tid: \" UINTX_FORMAT \").\",\n-    os::current_thread_id());\n+  log_info(os, thread)(\"Thread attached (tid: \" UINTX_FORMAT \", stack: \"\n+                       PTR_FORMAT \" - \" PTR_FORMAT \" (\" SIZE_FORMAT \"K) ).\",\n+                       os::current_thread_id(), p2i(thread->stack_base()),\n+                       p2i(thread->stack_end()), thread->stack_size() \/ K);\n@@ -685,0 +688,3 @@\n+  \/\/ Initial state is ALLOCATED but not INITIALIZED\n+  osthread->set_state(ALLOCATED);\n+\n@@ -747,8 +753,13 @@\n-  HANDLE thread_handle =\n-    (HANDLE)_beginthreadex(NULL,\n-                           (unsigned)stack_size,\n-                           (unsigned (__stdcall *)(void*)) thread_native_entry,\n-                           thread,\n-                           initflag,\n-                           &thread_id);\n-\n+  HANDLE thread_handle;\n+  int limit = 3;\n+  do {\n+    thread_handle =\n+      (HANDLE)_beginthreadex(NULL,\n+                             (unsigned)stack_size,\n+                             (unsigned (__stdcall *)(void*)) thread_native_entry,\n+                             thread,\n+                             initflag,\n+                             &thread_id);\n+  } while (thread_handle == NULL && errno == EAGAIN && limit-- > 0);\n+\n+  ResourceMark rm;\n@@ -757,2 +768,3 @@\n-    log_info(os, thread)(\"Thread started (tid: %u, attributes: %s)\",\n-      thread_id, describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));\n+    log_info(os, thread)(\"Thread \\\"%s\\\" started (tid: %u, attributes: %s)\",\n+                         thread->name(), thread_id,\n+                         describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));\n@@ -760,2 +772,2 @@\n-    log_warning(os, thread)(\"Failed to start thread - _beginthreadex failed (%s) for attributes: %s.\",\n-      os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));\n+    log_warning(os, thread)(\"Failed to start thread \\\"%s\\\" - _beginthreadex failed (%s) for attributes: %s.\",\n+                            thread->name(), os::errno_name(errno), describe_beginthreadex_attributes(buf, sizeof(buf), stack_size, initflag));\n@@ -781,1 +793,1 @@\n-  \/\/ Initial thread state is INITIALIZED, not SUSPENDED\n+  \/\/ Thread state now is INITIALIZED, not SUSPENDED\n@@ -889,0 +901,9 @@\n+\/\/ For dynamic lookup of SetThreadDescription API\n+typedef HRESULT (WINAPI *SetThreadDescriptionFnPtr)(HANDLE, PCWSTR);\n+typedef HRESULT (WINAPI *GetThreadDescriptionFnPtr)(HANDLE, PWSTR*);\n+static SetThreadDescriptionFnPtr _SetThreadDescription = NULL;\n+DEBUG_ONLY(static GetThreadDescriptionFnPtr _GetThreadDescription = NULL;)\n+\n+\/\/ forward decl.\n+static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path);\n+\n@@ -891,0 +912,45 @@\n+  \/\/ From Windows 10 and Windows 2016 server, we have a direct API\n+  \/\/ for setting the thread name\/description:\n+  \/\/ https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/processthreadsapi\/nf-processthreadsapi-setthreaddescription\n+\n+  if (_SetThreadDescription != NULL) {\n+    \/\/ SetThreadDescription takes a PCWSTR but we have conversion routines that produce\n+    \/\/ LPWSTR. The only difference is that PCWSTR is a pointer to const WCHAR.\n+    LPWSTR unicode_name;\n+    errno_t err = convert_to_unicode(name, &unicode_name);\n+    if (err == ERROR_SUCCESS) {\n+      HANDLE current = GetCurrentThread();\n+      HRESULT hr = _SetThreadDescription(current, unicode_name);\n+      if (FAILED(hr)) {\n+        log_debug(os, thread)(\"set_native_thread_name: SetThreadDescription failed - falling back to debugger method\");\n+        FREE_C_HEAP_ARRAY(WCHAR, unicode_name);\n+      } else {\n+        log_trace(os, thread)(\"set_native_thread_name: SetThreadDescription succeeded - new name: %s\", name);\n+\n+#ifdef ASSERT\n+        \/\/ For verification purposes in a debug build we read the thread name back and check it.\n+        PWSTR thread_name;\n+        HRESULT hr2 = _GetThreadDescription(current, &thread_name);\n+        if (FAILED(hr2)) {\n+          log_debug(os, thread)(\"set_native_thread_name: GetThreadDescription failed!\");\n+        } else {\n+          int res = CompareStringW(LOCALE_USER_DEFAULT,\n+                                   0, \/\/ no special comparison rules\n+                                   unicode_name,\n+                                   -1, \/\/ null-terminated\n+                                   thread_name,\n+                                   -1  \/\/ null-terminated\n+                                   );\n+          assert(res == CSTR_EQUAL,\n+                 \"Name strings were not the same - set: %ls, but read: %ls\", unicode_name, thread_name);\n+          LocalFree(thread_name);\n+        }\n+#endif\n+        FREE_C_HEAP_ARRAY(WCHAR, unicode_name);\n+        return;\n+      }\n+    } else {\n+      log_debug(os, thread)(\"set_native_thread_name: convert_to_unicode failed - falling back to debugger method\");\n+    }\n+  }\n+\n@@ -899,0 +965,1 @@\n+    log_debug(os, thread)(\"set_native_thread_name: no debugger present so unable to set thread name\");\n@@ -1195,1 +1262,12 @@\n-  ::FreeLibrary((HMODULE)lib);\n+  char name[MAX_PATH];\n+  if (::GetModuleFileName((HMODULE)lib, name, sizeof(name)) == 0) {\n+    snprintf(name, MAX_PATH, \"<not available>\");\n+  }\n+  if (::FreeLibrary((HMODULE)lib)) {\n+    Events::log_dll_message(NULL, \"Unloaded dll \\\"%s\\\" [\" INTPTR_FORMAT \"]\", name, p2i(lib));\n+    log_info(os)(\"Unloaded dll \\\"%s\\\" [\" INTPTR_FORMAT \"]\", name, p2i(lib));\n+  } else {\n+    const DWORD errcode = ::GetLastError();\n+    Events::log_dll_message(NULL, \"Attempt to unload dll \\\"%s\\\" [\" INTPTR_FORMAT \"] failed (error code %d)\", name, p2i(lib), errcode);\n+    log_info(os)(\"Attempt to unload dll \\\"%s\\\" [\" INTPTR_FORMAT \"] failed (error code %d)\", name, p2i(lib), errcode);\n+  }\n@@ -1493,1 +1571,1 @@\n-    Events::log(NULL, \"Loaded shared library %s\", name);\n+    Events::log_dll_message(NULL, \"Loaded shared library %s\", name);\n@@ -1504,1 +1582,1 @@\n-  Events::log(NULL, \"Loading shared library %s failed, error code %lu\", name, errcode);\n+  Events::log_dll_message(NULL, \"Loading shared library %s failed, error code %lu\", name, errcode);\n@@ -1839,1 +1917,5 @@\n-      st->print(\"10\");\n+      if (build_number >= 22000) {\n+        st->print(\"11\");\n+      } else {\n+        st->print(\"10\");\n+      }\n@@ -1841,3 +1923,7 @@\n-      \/\/ distinguish Windows Server 2016 and 2019 by build number\n-      \/\/ Windows server 2019 GA 10\/2018 build number is 17763\n-      if (build_number > 17762) {\n+      \/\/ distinguish Windows Server by build number\n+      \/\/ - 2016 GA 10\/2016 build: 14393\n+      \/\/ - 2019 GA 11\/2018 build: 17763\n+      \/\/ - 2022 GA 08\/2021 build: 20348\n+      if (build_number > 20347) {\n+        st->print(\"Server 2022\");\n+      } else if (build_number > 17762) {\n@@ -1872,0 +1958,10 @@\n+\/\/ Processor Power Information; missing from Windows headers\n+typedef struct _PROCESSOR_POWER_INFORMATION {\n+    ULONG Number;\n+    ULONG MaxMhz;     \/\/ max specified clock frequency of the system processor\n+    ULONG CurrentMhz; \/\/ max specified processor clock frequency mult. by current processor throttle\n+    ULONG MhzLimit;   \/\/ max specified processor clock frequency mult. by current processor thermal throttle limit\n+    ULONG MaxIdleState;\n+    ULONG CurrentIdleState;\n+} PROCESSOR_POWER_INFORMATION;\n+\n@@ -1873,1 +1969,48 @@\n-  \/\/ Nothing to do for now.\n+  int proc_count = os::processor_count();\n+  \/\/ handle potential early cases where processor count is not yet set\n+  if (proc_count < 1) {\n+    SYSTEM_INFO si;\n+    GetSystemInfo(&si);\n+    proc_count = si.dwNumberOfProcessors;\n+  }\n+\n+  size_t sz_check = sizeof(PROCESSOR_POWER_INFORMATION) * (size_t)proc_count;\n+  NTSTATUS status = ::CallNtPowerInformation(ProcessorInformation, nullptr, 0, buf, (ULONG) buflen);\n+  int max_mhz = -1, current_mhz = -1, mhz_limit = -1;\n+  bool same_vals_for_all_cpus = true;\n+\n+  if (status == ERROR_SUCCESS) {\n+    PROCESSOR_POWER_INFORMATION* pppi = (PROCESSOR_POWER_INFORMATION*) buf;\n+    for (int i = 0; i < proc_count; i++) {\n+      if (i == 0) {\n+        max_mhz = (int) pppi->MaxMhz;\n+        current_mhz = (int) pppi->CurrentMhz;\n+        mhz_limit = (int) pppi->MhzLimit;\n+      } else {\n+        if (max_mhz != (int) pppi->MaxMhz ||\n+            current_mhz != (int) pppi->CurrentMhz ||\n+            mhz_limit != (int) pppi->MhzLimit) {\n+          same_vals_for_all_cpus = false;\n+          break;\n+        }\n+      }\n+      \/\/ avoid iteration in case buf is too small to hold all proc infos\n+      if (sz_check > buflen) break;\n+      pppi++;\n+    }\n+\n+    if (same_vals_for_all_cpus && max_mhz != -1) {\n+      st->print_cr(\"Processor Information for all %d processors :\", proc_count);\n+      st->print_cr(\"  Max Mhz: %d, Current Mhz: %d, Mhz Limit: %d\", max_mhz, current_mhz, mhz_limit);\n+      return;\n+    }\n+    \/\/ differing values, iterate again\n+    pppi = (PROCESSOR_POWER_INFORMATION*) buf;\n+    for (int i = 0; i < proc_count; i++) {\n+      st->print_cr(\"Processor Information for processor %d\", (int) pppi->Number);\n+      st->print_cr(\"  Max Mhz: %d, Current Mhz: %d, Mhz Limit: %d\",\n+                     (int) pppi->MaxMhz, (int) pppi->CurrentMhz, (int) pppi->MhzLimit);\n+      if (sz_check > buflen) break;\n+      pppi++;\n+    }\n+  }\n@@ -2215,0 +2358,9 @@\n+\n+  \/\/ Initialize sigbreakHandler.\n+  \/\/ The actual work for handling CTRL-BREAK is performed by the Signal\n+  \/\/ Dispatcher thread, which is created and started at a much later point,\n+  \/\/ see os::initialize_jdk_signal_support(). Any CTRL-BREAK received\n+  \/\/ before the Signal Dispatcher thread is started is queued up via the\n+  \/\/ pending_signals[SIGBREAK] counter, and will be processed by the\n+  \/\/ Signal Dispatcher thread in a delayed fashion.\n+  os::signal(SIGBREAK, os::user_handler());\n@@ -2464,5 +2616,0 @@\n-  \/\/ Handle SafeFetch32 and SafeFetchN exceptions.\n-  if (StubRoutines::is_safefetch_fault(pc)) {\n-    return Handle_Exception(exceptionInfo, StubRoutines::continuation_for_safefetch_fault(pc));\n-  }\n-\n@@ -3412,3 +3559,0 @@\n-void os::print_statistics() {\n-}\n-\n@@ -4224,0 +4368,1 @@\n+\n@@ -4337,1 +4482,2 @@\n-  \/\/ Initialize data for jdk.internal.misc.Signal\n+  \/\/ Initialize data for jdk.internal.misc.Signal, and install CTRL-C and\n+  \/\/ CTRL-BREAK handlers.\n@@ -4342,0 +4488,18 @@\n+  \/\/ Lookup SetThreadDescription - the docs state we must use runtime-linking of\n+  \/\/ kernelbase.dll, so that is what we do.\n+  HINSTANCE _kernelbase = LoadLibrary(TEXT(\"kernelbase.dll\"));\n+  if (_kernelbase != NULL) {\n+    _SetThreadDescription =\n+      reinterpret_cast<SetThreadDescriptionFnPtr>(\n+                                                  GetProcAddress(_kernelbase,\n+                                                                 \"SetThreadDescription\"));\n+#ifdef ASSERT\n+    _GetThreadDescription =\n+      reinterpret_cast<GetThreadDescriptionFnPtr>(\n+                                                  GetProcAddress(_kernelbase,\n+                                                                 \"GetThreadDescription\"));\n+#endif\n+  }\n+  log_info(os, thread)(\"The SetThreadDescription API is%s available.\", _SetThreadDescription == NULL ? \" not\" : \"\");\n+\n+\n@@ -4788,3 +4952,1 @@\n-  if (!rewrite_existing) {\n-    oflags |= _O_EXCL;\n-  }\n+  oflags |= rewrite_existing ? _O_TRUNC : _O_EXCL;\n@@ -5700,4 +5862,0 @@\n-struct hostent* os::get_host_by_name(char* name) {\n-  return (struct hostent*)gethostbyname(name);\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":200,"deletions":42,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -145,0 +145,6 @@\n+  if (!is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n+  }\n@@ -471,0 +477,3 @@\n+  \/\/ Note: this code runs on startup, and therefore should not be slow,\n+  \/\/ see JDK-8283200.\n+\n@@ -472,3 +481,13 @@\n-  char data[2048] = {0}; \/\/ lines should fit in 2K buf\n-  size_t len = sizeof(data);\n-  FILE *fp = fopen(\"\/proc\/cpuinfo\", \"r\");\n+\n+  \/\/ Attempt 1 (faster): Read the microcode version off the sysfs.\n+  FILE *fp = fopen(\"\/sys\/devices\/system\/cpu\/cpu0\/microcode\/version\", \"r\");\n+  if (fp) {\n+    int read = fscanf(fp, \"%x\", &result);\n+    fclose(fp);\n+    if (read > 0) {\n+      return result;\n+    }\n+  }\n+\n+  \/\/ Attempt 2 (slower): Read the microcode version off the procfs.\n+  fp = fopen(\"\/proc\/cpuinfo\", \"r\");\n@@ -476,0 +495,2 @@\n+    char data[2048] = {0}; \/\/ lines should fit in 2K buf\n+    size_t len = sizeof(data);\n@@ -487,0 +508,1 @@\n+\n@@ -521,0 +543,1 @@\n+\n@@ -566,0 +589,6 @@\n+}\n+\n+void os::print_tos_pc(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const ucontext_t* uc = (const ucontext_t*)context;\n@@ -567,3 +596,2 @@\n-  intptr_t *sp = (intptr_t *)os::Linux::ucontext_get_sp(uc);\n-  st->print_cr(\"Top of Stack: (sp=\" PTR_FORMAT \")\", p2i(sp));\n-  print_hex_dump(st, (address)sp, (address)(sp + 8), sizeof(intptr_t));\n+  address sp = (address)os::Linux::ucontext_get_sp(uc);\n+  print_tos(st, sp);\n@@ -575,2 +603,2 @@\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc, sizeof(char));\n+  address pc = os::fetch_frame_from_context(uc).pc();\n+  print_instructions(st, pc);\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":36,"deletions":8,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+  template(getStackTrace_name,                        \"getStackTrace\")                            \\\n@@ -596,1 +597,3 @@\n-  template(reflect_method_signature,                  \"Ljava\/lang\/reflect\/Method;\")                                                    \\\n+  template(reflect_method_signature,                  \"Ljava\/lang\/reflect\/Method;\")                               \\\n+  template(getStackTrace_signature,                    \"()[Ljava\/lang\/StackTraceElement;\")                        \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -983,1 +983,5 @@\n-void G1CollectedHeap::print_hrm_post_compaction() {\n+void G1CollectedHeap::print_heap_after_full_collection() {\n+  \/\/ Post collection region logging.\n+  \/\/ We should do this after we potentially resize the heap so\n+  \/\/ that all the COMMIT \/ UNCOMMIT events are generated before\n+  \/\/ the compaction events.\n@@ -1095,11 +1099,0 @@\n-void G1CollectedHeap::print_heap_after_full_collection(G1HeapTransition* heap_transition) {\n-  \/\/ Post collection logging.\n-  \/\/ We should do this after we potentially resize the heap so\n-  \/\/ that all the COMMIT \/ UNCOMMIT events are generated before\n-  \/\/ the compaction events.\n-  print_hrm_post_compaction();\n-  heap_transition->print();\n-  print_heap_after_gc();\n-  print_heap_regions();\n-}\n-\n@@ -1119,1 +1112,1 @@\n-  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs, do_maximum_compaction);\n+  G1FullGCMark gc_mark;\n@@ -1121,0 +1114,1 @@\n+  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs, do_maximum_compaction, gc_mark.tracer());\n@@ -2271,1 +2265,1 @@\n-class G1ParallelObjectIterator : public ParallelObjectIterator {\n+class G1ParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -2286,1 +2280,1 @@\n-ParallelObjectIterator* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n+ParallelObjectIteratorImpl* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n@@ -2296,1 +2290,1 @@\n-  G1BarrierSet::enqueue(obj);\n+  G1BarrierSet::enqueue_preloaded(obj);\n@@ -2570,3 +2564,0 @@\n-  \/\/ This summary needs to be printed before incrementing total collections.\n-  rem_set()->print_periodic_summary_info(\"Before GC RS summary\", total_collections());\n-\n@@ -2605,3 +2596,0 @@\n-  \/\/ We are at the end of the GC. Total collections has already been increased.\n-  rem_set()->print_periodic_summary_info(\"After GC RS summary\", total_collections() - 1);\n-\n@@ -2621,3 +2609,0 @@\n-  \/\/ Print NUMA statistics.\n-  _numa->print_statistics();\n-\n@@ -2809,1 +2794,1 @@\n-void G1CollectedHeap::calculate_collection_set(G1EvacuationInfo& evacuation_info, double target_pause_time_ms) {\n+void G1CollectedHeap::calculate_collection_set(G1EvacuationInfo* evacuation_info, double target_pause_time_ms) {\n@@ -2812,1 +2797,1 @@\n-  evacuation_info.set_collectionset_regions(collection_set()->region_length() +\n+  evacuation_info->set_collectionset_regions(collection_set()->region_length() +\n@@ -2907,0 +2892,58 @@\n+G1HeapPrinterMark::G1HeapPrinterMark(G1CollectedHeap* g1h) : _g1h(g1h), _heap_transition(g1h) {\n+  \/\/ This summary needs to be printed before incrementing total collections.\n+  _g1h->rem_set()->print_periodic_summary_info(\"Before GC RS summary\", _g1h->total_collections());\n+  _g1h->print_heap_before_gc();\n+  _g1h->print_heap_regions();\n+}\n+\n+G1HeapPrinterMark::~G1HeapPrinterMark() {\n+  _g1h->policy()->print_age_table();\n+  \/\/ not (yet) in 17u: _g1h->rem_set()->print_coarsen_stats();\n+  \/\/ We are at the end of the GC. Total collections has already been increased.\n+  _g1h->rem_set()->print_periodic_summary_info(\"After GC RS summary\", _g1h->total_collections() - 1);\n+\n+  _heap_transition.print();\n+  _g1h->print_heap_regions();\n+  _g1h->print_heap_after_gc();\n+  \/\/ Print NUMA statistics.\n+  _g1h->numa()->print_statistics();\n+}\n+\n+G1JFRTracerMark::G1JFRTracerMark(STWGCTimer* timer, GCTracer* tracer) :\n+  _timer(timer), _tracer(tracer) {\n+\n+  _timer->register_gc_start();\n+  _tracer->report_gc_start(G1CollectedHeap::heap()->gc_cause(), _timer->gc_start());\n+  G1CollectedHeap::heap()->trace_heap_before_gc(_tracer);\n+}\n+\n+G1JFRTracerMark::~G1JFRTracerMark() {\n+  G1CollectedHeap::heap()->trace_heap_after_gc(_tracer);\n+  _timer->register_gc_end();\n+  _tracer->report_gc_end(_timer->gc_end(), _timer->time_partitions());\n+}\n+\n+class G1YoungGCJFRTracerMark : public G1JFRTracerMark {\n+  G1EvacuationInfo _evacuation_info;\n+\n+  G1NewTracer* tracer() const { return (G1NewTracer*)_tracer; }\n+\n+public:\n+\n+  G1EvacuationInfo* evacuation_info() { return &_evacuation_info; }\n+\n+  G1YoungGCJFRTracerMark(STWGCTimer* gc_timer_stw, G1NewTracer* gc_tracer_stw, GCCause::Cause cause) :\n+    G1JFRTracerMark(gc_timer_stw, gc_tracer_stw), _evacuation_info() { }\n+\n+  void report_pause_type(G1GCPauseType type) {\n+    tracer()->report_young_gc_pause(type);\n+  }\n+\n+  ~G1YoungGCJFRTracerMark() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+\n+    tracer()->report_evacuation_info(&_evacuation_info);\n+    tracer()->report_tenuring_threshold(g1h->policy()->tenuring_threshold());\n+  }\n+};\n+\n@@ -2915,2 +2958,0 @@\n-  gc_tracer_report_gc_start();\n-\n@@ -2919,4 +2960,0 @@\n-  print_heap_before_gc();\n-  print_heap_regions();\n-  trace_heap_before_gc(_gc_tracer_stw);\n-\n@@ -2948,3 +2985,1 @@\n-    G1EvacuationInfo evacuation_info;\n-\n-    GCTraceCPUTime tcpu;\n+    GCTraceCPUTime tcpu(_gc_tracer_stw);\n@@ -2963,0 +2998,2 @@\n+    \/\/ JFR\n+    G1YoungGCJFRTracerMark jtm(_gc_timer_stw, _gc_tracer_stw, gc_cause());\n@@ -2966,0 +3003,5 @@\n+    \/\/ Create the heap printer before internal pause timing to have\n+    \/\/ heap information printed as last part of detailed GC log.\n+    G1HeapPrinterMark hpm(this);\n+    \/\/ Young GC internal pause timing\n+    \/\/ Not (yet) in 17: G1YoungGCNotifyPauseMark npm;\n@@ -2967,1 +3009,3 @@\n-    G1HeapTransition heap_transition(this);\n+    \/\/ Verification may use the gang workers, so they must be set up before.\n+    \/\/ Individual parallel phases may override this.\n+    \/\/ Not (yet) in 17: set_young_collection_default_active_worker_threads();\n@@ -2999,1 +3043,1 @@\n-        calculate_collection_set(evacuation_info, target_pause_time_ms);\n+        calculate_collection_set(jtm.evacuation_info(), target_pause_time_ms);\n@@ -3007,1 +3051,1 @@\n-        pre_evacuate_collection_set(evacuation_info, &per_thread_states);\n+        pre_evacuate_collection_set(jtm.evacuation_info(), &per_thread_states);\n@@ -3016,1 +3060,1 @@\n-        post_evacuate_collection_set(evacuation_info, &rdcqs, &per_thread_states);\n+        post_evacuate_collection_set(jtm.evacuation_info(), &rdcqs, &per_thread_states);\n@@ -3035,1 +3079,1 @@\n-        _gc_tracer_stw->report_young_gc_pause(collector_state()->young_gc_pause_type(concurrent_operation_is_full_mark));\n+        jtm.report_pause_type(collector_state()->young_gc_pause_type(concurrent_operation_is_full_mark));\n@@ -3053,1 +3097,0 @@\n-    heap_transition.print();\n@@ -3061,4 +3104,0 @@\n-    print_heap_after_gc();\n-    print_heap_regions();\n-    trace_heap_after_gc(_gc_tracer_stw);\n-\n@@ -3070,2 +3109,0 @@\n-\n-    gc_tracer_report_gc_end(concurrent_operation_is_full_mark, evacuation_info);\n@@ -3205,0 +3242,25 @@\n+\/\/ Special closure for enqueuing discovered fields: during enqueue the card table\n+\/\/ may not be in shape to properly handle normal barrier calls (e.g. card marks\n+\/\/ in regions that failed evacuation, scribbling of various values by card table\n+\/\/ scan code). Additionally the regular barrier enqueues into the \"global\"\n+\/\/ DCQS, but during GC we need these to-be-refined entries in the GC local queue\n+\/\/ so that after clearing the card table, the redirty cards phase will properly\n+\/\/ mark all dirty cards to be picked up by refinement.\n+class G1EnqueueDiscoveredFieldClosure : public EnqueueDiscoveredFieldClosure {\n+  G1CollectedHeap* _g1h;\n+  G1ParScanThreadState* _pss;\n+\n+public:\n+  G1EnqueueDiscoveredFieldClosure(G1CollectedHeap* g1h, G1ParScanThreadState* pss) : _g1h(g1h), _pss(pss) { }\n+\n+  virtual void enqueue(HeapWord* discovered_field_addr, oop value) {\n+    assert(_g1h->is_in(discovered_field_addr), PTR_FORMAT \" is not in heap \", p2i(discovered_field_addr));\n+    \/\/ Store the value first, whatever it is.\n+    RawAccess<>::oop_store(discovered_field_addr, value);\n+    if (value == NULL) {\n+      return;\n+    }\n+    _pss->write_ref_field_post(discovered_field_addr, value);\n+  }\n+};\n+\n@@ -3249,1 +3311,2 @@\n-    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &complete_gc);\n+    G1EnqueueDiscoveredFieldClosure enqueue(&_g1h, _pss.state_for_worker(index));\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &enqueue, &complete_gc);\n@@ -3468,1 +3531,1 @@\n-void G1CollectedHeap::pre_evacuate_collection_set(G1EvacuationInfo& evacuation_info, G1ParScanThreadStateSet* per_thread_states) {\n+void G1CollectedHeap::pre_evacuate_collection_set(G1EvacuationInfo* evacuation_info, G1ParScanThreadStateSet* per_thread_states) {\n@@ -3734,1 +3797,1 @@\n-void G1CollectedHeap::post_evacuate_collection_set(G1EvacuationInfo& evacuation_info,\n+void G1CollectedHeap::post_evacuate_collection_set(G1EvacuationInfo* evacuation_info,\n@@ -3755,1 +3818,1 @@\n-  post_evacuate_cleanup_2(&_preserved_marks_set, rdcqs, &evacuation_info, per_thread_states->surviving_young_words());\n+  post_evacuate_cleanup_2(&_preserved_marks_set, rdcqs, evacuation_info, per_thread_states->surviving_young_words());\n@@ -3763,4 +3826,2 @@\n-  evacuation_info.set_collectionset_used_before(collection_set()->bytes_used_before());\n-  evacuation_info.set_bytes_used(_bytes_used_during_gc);\n-\n-  policy()->print_age_table();\n+  evacuation_info->set_collectionset_used_before(collection_set()->bytes_used_before());\n+  evacuation_info->set_bytes_used(_bytes_used_during_gc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":117,"deletions":56,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -1778,1 +1778,1 @@\n-    GCTraceCPUTime tcpu;\n+    GCTraceCPUTime tcpu(&_gc_tracer);\n@@ -1784,1 +1784,1 @@\n-    TraceMemoryManagerStats tms(heap->old_gc_manager(), gc_cause);\n+    TraceMemoryManagerStats tms(heap->old_gc_manager(), gc_cause, \"end of major GC\");\n@@ -2085,0 +2085,1 @@\n+    BarrierEnqueueDiscoveredFieldClosure enqueue;\n@@ -2086,1 +2087,1 @@\n-    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &keep_alive, &complete_gc);\n+    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &keep_alive, &enqueue, &complete_gc);\n@@ -2154,1 +2155,4 @@\n-  _gc_tracer.report_object_count_after_gc(is_alive_closure());\n+  {\n+    GCTraceTime(Debug, gc, phases) tm(\"Report Object Count\", &_gc_timer);\n+    _gc_tracer.report_object_count_after_gc(is_alive_closure(), &ParallelScavengeHeap::heap()->workers());\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -186,0 +186,2 @@\n+\n+  _gc_tracer = new (ResourceObj::C_HEAP, mtGC) DefNewTracer();\n@@ -202,0 +204,4 @@\n+  if (eden_size > max_eden_size()) {\n+    eden_size = max_eden_size();\n+    survivor_size = (size - eden_size)\/2;\n+  }\n@@ -537,2 +543,1 @@\n-  DefNewTracer gc_tracer;\n-  gc_tracer.report_gc_start(heap->gc_cause(), _gc_timer->gc_start());\n+  _gc_tracer->report_gc_start(heap->gc_cause(), _gc_timer->gc_start());\n@@ -556,1 +561,1 @@\n-  heap->trace_heap_before_gc(&gc_tracer);\n+  heap->trace_heap_before_gc(_gc_tracer);\n@@ -600,2 +605,2 @@\n-  gc_tracer.report_gc_reference_stats(stats);\n-  gc_tracer.report_tenuring_threshold(tenuring_threshold());\n+  _gc_tracer->report_gc_reference_stats(stats);\n+  _gc_tracer->report_tenuring_threshold(tenuring_threshold());\n@@ -653,1 +658,1 @@\n-    gc_tracer.report_promotion_failed(_promotion_failed_info);\n+    _gc_tracer->report_promotion_failed(_promotion_failed_info);\n@@ -661,1 +666,1 @@\n-  heap->trace_heap_after_gc(&gc_tracer);\n+  heap->trace_heap_after_gc(_gc_tracer);\n@@ -665,1 +670,1 @@\n-  gc_tracer.report_gc_end(_gc_timer->gc_end(), _gc_timer->time_partitions());\n+  _gc_tracer->report_gc_end(_gc_timer->gc_end(), _gc_timer->time_partitions());\n@@ -851,3 +856,0 @@\n-      assert(gch->gc_cause() == GCCause::_scavenge_alot ||\n-             !gch->incremental_collection_failed(),\n-             \"Twice in a row\");\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -113,0 +113,12 @@\n+ParallelObjectIterator::ParallelObjectIterator(uint thread_num) :\n+  _impl(Universe::heap()->parallel_object_iterator(thread_num))\n+{}\n+\n+ParallelObjectIterator::~ParallelObjectIterator() {\n+  delete _impl;\n+}\n+\n+void ParallelObjectIterator::object_iterate(ObjectClosure* cl, uint worker_id) {\n+  _impl->object_iterate(cl, worker_id);\n+}\n+\n@@ -375,11 +387,0 @@\n-#ifndef PRODUCT\n-void CollectedHeap::check_for_non_bad_heap_word_value(HeapWord* addr, size_t size) {\n-  if (CheckMemoryInitialization && ZapUnusedHeapArea) {\n-    \/\/ please note mismatch between size (in 32\/64 bit words), and ju_addr that always point to a 32 bit word\n-    for (juint* ju_addr = reinterpret_cast<juint*>(addr); ju_addr < reinterpret_cast<juint*>(addr + size); ++ju_addr) {\n-      assert(*ju_addr == badHeapWordVal, \"Found non badHeapWordValue in pre-allocation check\");\n-    }\n-  }\n-}\n-#endif \/\/ PRODUCT\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-class ParallelObjectIterator : public CHeapObj<mtGC> {\n+class ParallelObjectIteratorImpl : public CHeapObj<mtGC> {\n@@ -67,0 +67,1 @@\n+  virtual ~ParallelObjectIteratorImpl() {}\n@@ -68,1 +69,13 @@\n-  virtual ~ParallelObjectIterator() {}\n+};\n+\n+\/\/ User facing parallel object iterator. This is a StackObj, which ensures that\n+\/\/ the _impl is allocated and deleted in the scope of this object. This ensures\n+\/\/ the life cycle of the implementation is as required by ThreadsListHandle,\n+\/\/ which is sometimes used by the root iterators.\n+class ParallelObjectIterator : public StackObj {\n+  ParallelObjectIteratorImpl* _impl;\n+\n+public:\n+  ParallelObjectIterator(uint thread_num);\n+  ~ParallelObjectIterator();\n+  void object_iterate(ObjectClosure* cl, uint worker_id);\n@@ -80,1 +93,1 @@\n-class CollectedHeap : public CHeapObj<mtInternal> {\n+class CollectedHeap : public CHeapObj<mtGC> {\n@@ -85,0 +98,1 @@\n+  friend class ParallelObjectIterator;\n@@ -161,2 +175,0 @@\n-  virtual void check_for_non_bad_heap_word_value(HeapWord* addr, size_t size)\n-    PRODUCT_RETURN;\n@@ -392,1 +404,2 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num) {\n+ protected:\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) {\n@@ -396,0 +409,1 @@\n+ public:\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -321,1 +321,2 @@\n-  void*        reserved6;\n+  jlong        (JNICALL *GetTotalThreadAllocatedMemory)\n+                                                 (JNIEnv *env);\n@@ -338,1 +339,2 @@\n-                                                  dcmdArgInfo *infoArray);\n+                                                  dcmdArgInfo *infoArray,\n+                                                  jint count);\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-JVM_LoadLibrary(const char *name);\n+JVM_LoadLibrary(const char *name, jboolean throwException);\n@@ -260,3 +260,0 @@\n-JNIEXPORT jboolean JNICALL\n-JVM_IsThreadAlive(JNIEnv *env, jobject thread);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-  before_exit(thread);\n+  before_exit(thread, true);\n@@ -2913,0 +2913,3 @@\n+    ResourceMark rm(thread);\n+    log_warning(os, thread)(\"Failed to start the native thread for java.lang.Thread \\\"%s\\\"\",\n+                            JavaThread::name_for(JNIHandles::resolve_non_null(jthread)));\n@@ -2977,6 +2980,0 @@\n-JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))\n-  oop thread_oop = JNIHandles::resolve_non_null(jthread);\n-  return java_lang_Thread::is_alive(thread_oop);\n-JVM_END\n-\n-\n@@ -3361,1 +3358,1 @@\n-JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))\n+JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name, jboolean throwException))\n@@ -3370,12 +3367,17 @@\n-    char msg[1024];\n-    jio_snprintf(msg, sizeof msg, \"%s: %s\", name, ebuf);\n-    \/\/ Since 'ebuf' may contain a string encoded using\n-    \/\/ platform encoding scheme, we need to pass\n-    \/\/ Exceptions::unsafe_to_utf8 to the new_exception method\n-    \/\/ as the last argument. See bug 6367357.\n-    Handle h_exception =\n-      Exceptions::new_exception(thread,\n-                                vmSymbols::java_lang_UnsatisfiedLinkError(),\n-                                msg, Exceptions::unsafe_to_utf8);\n-\n-    THROW_HANDLE_0(h_exception);\n+    if (throwException) {\n+      char msg[1024];\n+      jio_snprintf(msg, sizeof msg, \"%s: %s\", name, ebuf);\n+      \/\/ Since 'ebuf' may contain a string encoded using\n+      \/\/ platform encoding scheme, we need to pass\n+      \/\/ Exceptions::unsafe_to_utf8 to the new_exception method\n+      \/\/ as the last argument. See bug 6367357.\n+      Handle h_exception =\n+        Exceptions::new_exception(thread,\n+                                  vmSymbols::java_lang_UnsatisfiedLinkError(),\n+                                  msg, Exceptions::unsafe_to_utf8);\n+\n+      THROW_HANDLE_0(h_exception);\n+    } else {\n+      log_info(library)(\"Failed to load library %s\", name);\n+      return load_result;\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,1 +186,2 @@\n-                 S390_ONLY(\"s390\")\n+                 S390_ONLY(\"s390\")               \\\n+                 RISCV64_ONLY(\"riscv64\")\n@@ -201,5 +202,1 @@\n-      #if _MSC_VER == 1600\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 10.0 (VS2010)\"\n-      #elif _MSC_VER == 1700\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 11.0 (VS2012)\"\n-      #elif _MSC_VER == 1800\n+      #if _MSC_VER == 1800\n@@ -238,1 +235,21 @@\n-        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 16.8 (VS2019)\"\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 16.8 \/ 16.9 (VS2019)\"\n+      #elif _MSC_VER == 1929\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 16.10 \/ 16.11 (VS2019)\"\n+      #elif _MSC_VER == 1930\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.0 (VS2022)\"\n+      #elif _MSC_VER == 1931\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.1 (VS2022)\"\n+      #elif _MSC_VER == 1932\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.2 (VS2022)\"\n+      #elif _MSC_VER == 1933\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.3 (VS2022)\"\n+      #elif _MSC_VER == 1934\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.4 (VS2022)\"\n+      #elif _MSC_VER == 1935\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.5 (VS2022)\"\n+      #elif _MSC_VER == 1936\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.6 (VS2022)\"\n+      #elif _MSC_VER == 1937\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.7 (VS2022)\"\n+      #elif _MSC_VER == 1938\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.8 (VS2022)\"\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+  XenPVHVM, \/\/ mix-mode on Linux aarch64\n@@ -74,2 +75,0 @@\n-  static VirtualizationType _detected_virtualization;\n-\n@@ -79,0 +78,3 @@\n+\n+  static VirtualizationType _detected_virtualization;\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-#include \"services\/memTracker.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n@@ -2004,11 +2004,0 @@\n-  if (PrintNMTStatistics) {\n-#if INCLUDE_NMT\n-    if (MemTracker::tracking_level() == NMT_off) {\n-#endif \/\/ INCLUDE_NMT\n-      warning(\"PrintNMTStatistics is disabled, because native memory tracking is not enabled\");\n-      PrintNMTStatistics = false;\n-#if INCLUDE_NMT\n-    }\n-#endif\n-  }\n-\n@@ -2965,0 +2954,12 @@\n+    } else if (match_option(option, \"-XX:+DTraceMethodProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceMethodProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n+    } else if (match_option(option, \"-XX:+DTraceAllocProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceAllocProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n+    } else if (match_option(option, \"-XX:+DTraceMonitorProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceMonitorProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n@@ -3801,23 +3802,0 @@\n-    if (match_option(option, \"-XX:NativeMemoryTracking\", &tail)) {\n-#if INCLUDE_NMT\n-      \/\/ The launcher did not setup nmt environment variable properly.\n-      if (!MemTracker::check_launcher_nmt_support(tail)) {\n-        warning(\"Native Memory Tracking did not setup properly, using wrong launcher?\");\n-      }\n-\n-      \/\/ Verify if nmt option is valid.\n-      if (MemTracker::verify_nmt_option()) {\n-        \/\/ Late initialization, still in single-threaded mode.\n-        if (MemTracker::tracking_level() >= NMT_summary) {\n-          MemTracker::init();\n-        }\n-      } else {\n-        vm_exit_during_initialization(\"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", NULL);\n-      }\n-      continue;\n-#else\n-      jio_fprintf(defaultStream::error_stream(),\n-        \"Native Memory Tracking is not supported in this VM\\n\");\n-      return JNI_ERR;\n-#endif\n-    }\n@@ -4075,0 +4053,20 @@\n+#if INCLUDE_NMT\n+  \/\/ Verify NMT arguments\n+  const NMT_TrackingLevel lvl = NMTUtil::parse_tracking_level(NativeMemoryTracking);\n+  if (lvl == NMT_unknown) {\n+    jio_fprintf(defaultStream::error_stream(),\n+                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", NULL);\n+    return JNI_ERR;\n+  }\n+  if (PrintNMTStatistics && lvl == NMT_off) {\n+    warning(\"PrintNMTStatistics is disabled, because native memory tracking is not enabled\");\n+    FLAG_SET_DEFAULT(PrintNMTStatistics, false);\n+  }\n+#else\n+  if (!FLAG_IS_DEFAULT(NativeMemoryTracking) || PrintNMTStatistics) {\n+    warning(\"Native Memory Tracking is not supported in this VM\");\n+    FLAG_SET_DEFAULT(NativeMemoryTracking, \"off\");\n+    FLAG_SET_DEFAULT(PrintNMTStatistics, false);\n+  }\n+#endif \/\/ INCLUDE_NMT\n+\n@@ -4143,0 +4141,5 @@\n+\n+  if (LogTouchedMethods) {\n+    warning(\"LogTouchedMethods is not supported for Zero\");\n+    FLAG_SET_DEFAULT(LogTouchedMethods, false);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":38,"deletions":35,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,2 @@\n-\/\/ EXPERIMENTAL flags are in support of features that are not\n-\/\/    part of the officially supported product, but are available\n+\/\/ EXPERIMENTAL flags are in support of features that may not be\n+\/\/    an officially supported part of a product, but may be available\n@@ -78,0 +78,2 @@\n+\/\/    Refer to the documentation of any products using this code for details\n+\/\/    on support and fitness for production.\n@@ -83,2 +85,1 @@\n-\/\/    and they are not supported on production loads, except under explicit\n-\/\/    direction from support engineers.\n+\/\/    Refer to the documentation of any products using this code for details.\n@@ -297,0 +298,3 @@\n+  product(size_t, InlineCacheBufferSize, 10*K, EXPERIMENTAL,                \\\n+          \"InlineCacheBuffer size\")                                         \\\n+                                                                            \\\n@@ -462,1 +466,1 @@\n-          \"Zap freed resource\/arena space with 0xABABABAB\")                 \\\n+          \"Zap freed resource\/arena space\")                                 \\\n@@ -465,1 +469,1 @@\n-          \"Zap freed VM handle space with 0xBCBCBCBC\")                      \\\n+          \"Zap freed VM handle space\")                                      \\\n@@ -468,1 +472,1 @@\n-          \"Zap allocated\/freed stack segments with 0xFADFADED\")             \\\n+          \"Zap allocated\/freed stack segments\")                             \\\n@@ -471,1 +475,1 @@\n-          \"Zap unused heap space with 0xBAADBABE\")                          \\\n+          \"Zap unused heap space\")                                          \\\n@@ -477,1 +481,1 @@\n-          \"Zap filler objects with 0xDEAFBABE\")                             \\\n+          \"Zap filler objects\")                                             \\\n@@ -551,1 +555,1 @@\n-  product(ccstr, NativeMemoryTracking, \"off\",                               \\\n+  product(ccstr, NativeMemoryTracking, DEBUG_ONLY(\"summary\") NOT_DEBUG(\"off\"), \\\n@@ -706,0 +710,7 @@\n+  \/* notice: the max range value here is max_jint, not max_intx  *\/         \\\n+  \/* because of overflow issue                                   *\/         \\\n+  product(intx, GuaranteedAsyncDeflationInterval, 60000, DIAGNOSTIC,        \\\n+          \"Async deflate idle monitors every so many milliseconds even \"    \\\n+          \"when MonitorUsedDeflationThreshold is NOT exceeded (0 is off).\") \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n@@ -718,0 +729,4 @@\n+  product(intx, MonitorUnlinkBatch, 500, DIAGNOSTIC,                        \\\n+          \"The maximum number of monitors to unlink in one batch. \")        \\\n+          range(1, max_jint)                                                \\\n+                                                                            \\\n@@ -720,2 +735,3 @@\n-          \"off). The check is performed on GuaranteedSafepointInterval \"    \\\n-          \"or AsyncDeflationInterval.\")                                     \\\n+          \"off). The check is performed on GuaranteedSafepointInterval, \"   \\\n+          \"AsyncDeflationInterval or GuaranteedAsyncDeflationInterval, \"    \\\n+          \"whichever is lower.\")                                            \\\n@@ -914,4 +930,0 @@\n-                                                                            \\\n-  notproduct(bool, CheckMemoryInitialization, false,                        \\\n-          \"Check memory initialization\")                                    \\\n-                                                                            \\\n@@ -983,3 +995,0 @@\n-  product(bool, EnableThreadSMRExtraValidityChecks, true, DIAGNOSTIC,       \\\n-             \"Enable Thread SMR extra validity checks\")                     \\\n-                                                                            \\\n@@ -1377,0 +1386,4 @@\n+  product(int, ErrorLogPrintCodeLimit, 3, DIAGNOSTIC,                       \\\n+          \"max number of compiled code units to print in error log\")        \\\n+          range(0, VMError::max_error_log_print_code)                       \\\n+                                                                            \\\n@@ -1578,1 +1591,1 @@\n-  develop_pd(uintx, CodeCacheSegmentSize,                                   \\\n+  product_pd(uintx, CodeCacheSegmentSize, EXPERIMENTAL,                     \\\n@@ -2004,1 +2017,1 @@\n-  product(intx, ArchiveRelocationMode, 0, DIAGNOSTIC,                       \\\n+  product(intx, ArchiveRelocationMode, 1, DIAGNOSTIC,                       \\\n@@ -2006,2 +2019,2 @@\n-           \"unsuccessful, map at alternative address (default); \"           \\\n-           \"(1) always map at alternative address; \"                        \\\n+           \"unsuccessful, map at alternative address; \"                     \\\n+           \"(1) always map at alternative address (default); \"              \\\n@@ -2091,2 +2104,9 @@\n-  develop(bool, TraceOptimizedUpcallStubs, false,                           \\\n-                \"Trace optimized upcall stub generation\")                   \\\n+  develop(bool, TraceOptimizedUpcallStubs, false,                              \\\n+                \"Trace optimized upcall stub generation\")                      \\\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 0,                                  \\\n+          \"Interval, in ms, at which the JVM will trim the native heap if \" \\\n+          \"the platform supports that. Lower values will reclaim memory \"   \\\n+          \"more eagerly at the cost of higher overhead. A value of 0 \"      \\\n+          \"(default) disables native heap trimming.\")                       \\\n+          range(0, UINT_MAX)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":46,"deletions":26,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"memory\/guardedMemory.hpp\"\n@@ -56,1 +55,1 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n+#include \"runtime\/safefetch.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"services\/nmtPreInit.hpp\"\n@@ -80,7 +80,0 @@\n-#ifndef PRODUCT\n-julong os::num_mallocs = 0;         \/\/ # of calls to malloc\/realloc\n-julong os::alloc_bytes = 0;         \/\/ # of bytes allocated\n-julong os::num_frees = 0;           \/\/ # of calls to free\n-julong os::free_bytes = 0;          \/\/ # of bytes freed\n-#endif\n-\n@@ -490,15 +483,2 @@\n-    { MutexLocker mu(THREAD, Threads_lock);\n-      JavaThread* signal_thread = new JavaThread(&signal_thread_entry);\n-\n-      \/\/ At this point it may be possible that no osthread was created for the\n-      \/\/ JavaThread due to lack of memory. We would have to throw an exception\n-      \/\/ in that case. However, since this must work and we do not allow\n-      \/\/ exceptions anyway, check and abort if this fails.\n-      if (signal_thread == NULL || signal_thread->osthread() == NULL) {\n-        vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n-                                      os::native_thread_creation_failed_msg());\n-      }\n-\n-      java_lang_Thread::set_thread(thread_oop(), signal_thread);\n-      java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);\n-      java_lang_Thread::set_daemon(thread_oop());\n+    JavaThread* thread = new JavaThread(&signal_thread_entry);\n+    JavaThread::vm_exit_on_osthread_failure(thread);\n@@ -506,6 +486,1 @@\n-      signal_thread->set_threadObj(thread_oop());\n-      Threads::add(signal_thread);\n-      Thread::start(signal_thread);\n-    }\n-    \/\/ Handle ^BREAK\n-    os::signal(SIGBREAK, os::user_handler());\n+    JavaThread::start_internal_daemon(THREAD, thread, thread_oop, NearMaxPriority);\n@@ -635,20 +610,0 @@\n-\n-#define paranoid                 0  \/* only set to 1 if you suspect checking code has bug *\/\n-\n-#ifdef ASSERT\n-\n-static void verify_memory(void* ptr) {\n-  GuardedMemory guarded(ptr);\n-  if (!guarded.verify_guards()) {\n-    LogTarget(Warning, malloc, free) lt;\n-    ResourceMark rm;\n-    LogStream ls(lt);\n-    ls.print_cr(\"## nof_mallocs = \" UINT64_FORMAT \", nof_frees = \" UINT64_FORMAT, os::num_mallocs, os::num_frees);\n-    ls.print_cr(\"## memory stomp:\");\n-    guarded.print_on(&ls);\n-    fatal(\"memory stomping error\");\n-  }\n-}\n-\n-#endif\n-\n@@ -659,0 +614,1 @@\n+\n@@ -671,0 +627,13 @@\n+#ifdef ASSERT\n+static void check_crash_protection() {\n+  assert(!os::ThreadCrashProtection::is_crash_protected(Thread::current_or_null()),\n+         \"not allowed when crash protection is set\");\n+}\n+static void break_if_ptr_caught(void* ptr) {\n+  if (p2i(ptr) == (intptr_t)MallocCatchPtr) {\n+    log_warning(malloc, free)(\"ptr caught: \" PTR_FORMAT, p2i(ptr));\n+    breakpoint();\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n@@ -676,11 +645,6 @@\n-  NOT_PRODUCT(inc_stat_counter(&num_mallocs, 1));\n-  NOT_PRODUCT(inc_stat_counter(&alloc_bytes, size));\n-\n-  \/\/ Since os::malloc can be called when the libjvm.{dll,so} is\n-  \/\/ first loaded and we don't have a thread yet we must accept NULL also here.\n-  assert(!os::ThreadCrashProtection::is_crash_protected(Thread::current_or_null()),\n-         \"malloc() not allowed when crash protection is set\");\n-  if (size == 0) {\n-    \/\/ return a valid pointer if size is zero\n-    \/\/ if NULL is returned the calling functions assume out of memory.\n-    size = 1;\n+#if INCLUDE_NMT\n+  {\n+    void* rc = NULL;\n+    if (NMTPreInit::handle_malloc(&rc, size)) {\n+      return rc;\n+    }\n@@ -689,0 +653,1 @@\n+#endif\n@@ -690,3 +655,1 @@\n-  \/\/ NMT support\n-  NMT_TrackingLevel level = MemTracker::tracking_level();\n-  size_t            nmt_header_size = MemTracker::malloc_header_size(level);\n+  DEBUG_ONLY(check_crash_protection());\n@@ -694,8 +657,4 @@\n-#ifndef ASSERT\n-  const size_t alloc_size = size + nmt_header_size;\n-#else\n-  const size_t alloc_size = GuardedMemory::get_total_size(size + nmt_header_size);\n-  if (size + nmt_header_size > alloc_size) { \/\/ Check for rollover.\n-    return NULL;\n-  }\n-#endif\n+  \/\/ On malloc(0), implementators of malloc(3) have the choice to return either\n+  \/\/ NULL or a unique non-NULL pointer. To unify libc behavior across our platforms\n+  \/\/ we chose the latter.\n+  size = MAX2((size_t)1, size);\n@@ -708,2 +667,1 @@\n-  u_char* ptr;\n-  ptr = (u_char*)::malloc(alloc_size);\n+  const size_t outer_size = size + MemTracker::overhead_per_malloc();\n@@ -711,2 +669,2 @@\n-#ifdef ASSERT\n-  if (ptr == NULL) {\n+  \/\/ Check for overflow.\n+  if (outer_size < size) {\n@@ -715,9 +673,3 @@\n-  \/\/ Wrap memory with guard\n-  GuardedMemory guarded(ptr, size + nmt_header_size);\n-  ptr = guarded.get_user_ptr();\n-  if ((intptr_t)ptr == (intptr_t)MallocCatchPtr) {\n-    log_warning(malloc, free)(\"os::malloc caught, \" SIZE_FORMAT \" bytes --> \" PTR_FORMAT, size, p2i(ptr));\n-    breakpoint();\n-  }\n-  if (paranoid) {\n-    verify_memory(ptr);\n+  void* const outer_ptr = ::malloc(outer_size);\n+  if (outer_ptr == NULL) {\n+    return NULL;\n@@ -726,3 +678,6 @@\n-#endif\n-  \/\/ we do not track guard memory\n-  return MemTracker::record_malloc((address)ptr, size, memflags, stack, level);\n+  void* const inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack);\n+\n+  DEBUG_ONLY(::memset(inner_ptr, uninitBlockPad, size);)\n+  DEBUG_ONLY(break_if_ptr_caught(inner_ptr);)\n+\n+  return inner_ptr;\n@@ -738,9 +693,6 @@\n-  \/\/ For the test flag -XX:MallocMaxTestWords\n-  if (has_reached_max_malloc_test_peak(size)) {\n-    return NULL;\n-  }\n-\n-  if (size == 0) {\n-    \/\/ return a valid pointer if size is zero\n-    \/\/ if NULL is returned the calling functions assume out of memory.\n-    size = 1;\n+#if INCLUDE_NMT\n+  {\n+    void* rc = NULL;\n+    if (NMTPreInit::handle_realloc(&rc, memblock, size)) {\n+      return rc;\n+    }\n@@ -748,0 +700,1 @@\n+#endif\n@@ -749,10 +702,0 @@\n-#ifndef ASSERT\n-  NOT_PRODUCT(inc_stat_counter(&num_mallocs, 1));\n-  NOT_PRODUCT(inc_stat_counter(&alloc_bytes, size));\n-   \/\/ NMT support\n-  NMT_TrackingLevel level = MemTracker::tracking_level();\n-  void* membase = MemTracker::record_free(memblock, level);\n-  size_t  nmt_header_size = MemTracker::malloc_header_size(level);\n-  void* ptr = ::realloc(membase, size + nmt_header_size);\n-  return MemTracker::record_malloc(ptr, size, memflags, stack, level);\n-#else\n@@ -762,3 +705,11 @@\n-  if ((intptr_t)memblock == (intptr_t)MallocCatchPtr) {\n-    log_warning(malloc, free)(\"os::realloc caught \" PTR_FORMAT, p2i(memblock));\n-    breakpoint();\n+\n+  DEBUG_ONLY(check_crash_protection());\n+\n+  \/\/ On realloc(p, 0), implementators of realloc(3) have the choice to return either\n+  \/\/ NULL or a unique non-NULL pointer. To unify libc behavior across our platforms\n+  \/\/ we chose the latter.\n+  size = MAX2((size_t)1, size);\n+\n+  \/\/ For the test flag -XX:MallocMaxTestWords\n+  if (has_reached_max_malloc_test_peak(size)) {\n+    return NULL;\n@@ -766,15 +717,9 @@\n-  \/\/ NMT support\n-  void* membase = MemTracker::malloc_base(memblock);\n-  verify_memory(membase);\n-  \/\/ always move the block\n-  void* ptr = os::malloc(size, memflags, stack);\n-  \/\/ Copy to new memory if malloc didn't fail\n-  if (ptr != NULL ) {\n-    GuardedMemory guarded(MemTracker::malloc_base(memblock));\n-    \/\/ Guard's user data contains NMT header\n-    size_t memblock_size = guarded.get_user_size() - MemTracker::malloc_header_size(memblock);\n-    memcpy(ptr, memblock, MIN2(size, memblock_size));\n-    if (paranoid) {\n-      verify_memory(MemTracker::malloc_base(ptr));\n-    }\n-    os::free(memblock);\n+\n+  const size_t new_outer_size = size + MemTracker::overhead_per_malloc();\n+\n+  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n+  void* const old_outer_ptr = MemTracker::record_free(memblock);\n+\n+  void* const new_outer_ptr = ::realloc(old_outer_ptr, new_outer_size);\n+  if (new_outer_ptr == NULL) {\n+    return NULL;\n@@ -782,2 +727,6 @@\n-  return ptr;\n-#endif\n+\n+  void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack);\n+\n+  DEBUG_ONLY(break_if_ptr_caught(new_inner_ptr);)\n+\n+  return new_inner_ptr;\n@@ -786,18 +735,4 @@\n-\/\/ handles NULL pointers\n-  NOT_PRODUCT(inc_stat_counter(&num_frees, 1));\n-#ifdef ASSERT\n-  if (memblock == NULL) return;\n-  if ((intptr_t)memblock == (intptr_t)MallocCatchPtr) {\n-    log_warning(malloc, free)(\"os::free caught \" PTR_FORMAT, p2i(memblock));\n-    breakpoint();\n-  }\n-  void* membase = MemTracker::record_free(memblock, MemTracker::tracking_level());\n-  verify_memory(membase);\n-  GuardedMemory guarded(membase);\n-  size_t size = guarded.get_user_size();\n-  inc_stat_counter(&free_bytes, size);\n-  membase = guarded.release_for_freeing();\n-  ::free(membase);\n-#else\n-  void* membase = MemTracker::record_free(memblock, MemTracker::tracking_level());\n-  ::free(membase);\n+#if INCLUDE_NMT\n+  if (NMTPreInit::handle_free(memblock)) {\n+    return;\n+  }\n@@ -807,0 +742,11 @@\n+\n+  if (memblock == NULL) {\n+    return;\n+  }\n+\n+  DEBUG_ONLY(break_if_ptr_caught(memblock);)\n+\n+  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n+  void* const old_outer_ptr = MemTracker::record_free(memblock);\n+\n+  ::free(old_outer_ptr);\n@@ -914,1 +860,1 @@\n-#endif \/\/ HANDLE_FUNCTION_DESCRIPTORS\n+#endif \/\/ HAVE_FUNCTION_DESCRIPTORS\n@@ -1008,0 +954,5 @@\n+void os::print_tos(outputStream* st, address sp) {\n+  st->print_cr(\"Top of Stack: (sp=\" PTR_FORMAT \")\", p2i(sp));\n+  print_hex_dump(st, sp, sp + 512, sizeof(intptr_t));\n+}\n+\n@@ -1118,4 +1069,0 @@\n-#define SAFEFETCH_DEFAULT true\n-  if (!CanUseSafeFetch32()) {\n-    return SAFEFETCH_DEFAULT;\n-  }\n@@ -1253,0 +1200,4 @@\n+bool is_pointer_bad(intptr_t* ptr) {\n+  return !is_aligned(ptr, sizeof(uintptr_t)) || !os::is_readable_pointer(ptr);\n+}\n+\n@@ -1255,0 +1206,2 @@\n+\/\/ Returns true if this is not the case, i.e. the frame is possibly\n+\/\/ the first C frame on the stack.\n@@ -1260,1 +1213,0 @@\n-\n@@ -1264,5 +1216,1 @@\n-  uintptr_t fp_align_mask = (uintptr_t)(sizeof(address)-1);\n-  \/\/ sp on amd can be 32 bit aligned.\n-  uintptr_t sp_align_mask = (uintptr_t)(sizeof(int)-1);\n-  uintptr_t usp    = (uintptr_t)fr->sp();\n-  if ((usp & sp_align_mask) != 0) return true;\n+  if (is_pointer_bad(fr->sp())) return true;\n@@ -1272,1 +1220,1 @@\n-  if ((ufp & fp_align_mask) != 0) return true;\n+  if (is_pointer_bad(fr->fp())) return true;\n@@ -1275,2 +1223,1 @@\n-  if ((old_sp & sp_align_mask) != 0) return true;\n-  if (old_sp == 0 || old_sp == (uintptr_t)-1) return true;\n+  if ((uintptr_t)fr->sender_sp() == (uintptr_t)-1 || is_pointer_bad(fr->sender_sp())) return true;\n@@ -1278,3 +1225,3 @@\n-  uintptr_t old_fp = (uintptr_t)fr->link();\n-  if ((old_fp & fp_align_mask) != 0) return true;\n-  if (old_fp == 0 || old_fp == (uintptr_t)-1 || old_fp == ufp) return true;\n+  uintptr_t old_fp = (uintptr_t)fr->link_or_null();\n+  if (old_fp == 0 || old_fp == (uintptr_t)-1 || old_fp == ufp ||\n+    is_pointer_bad(fr->link_or_null())) return true;\n@@ -1292,1 +1239,0 @@\n-\n@@ -1400,0 +1346,8 @@\n+bool os::file_exists(const char* filename) {\n+  struct stat statbuf;\n+  if (filename == NULL || strlen(filename) == 0) {\n+    return false;\n+  }\n+  return os::stat(filename, &statbuf) == 0;\n+}\n+\n@@ -1785,1 +1739,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n@@ -1799,1 +1753,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n@@ -1875,1 +1829,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n@@ -1911,1 +1865,1 @@\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n+  if (MemTracker::enabled()) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":121,"deletions":167,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -371,0 +371,9 @@\n+  \/\/ Does the platform support trimming the native heap?\n+  static bool can_trim_native_heap();\n+\n+  \/\/ Trim the C-heap. Optionally returns working set size change (RSS+Swap) in *rss_change.\n+  \/\/ Note: If trimming succeeded but no size change information could be obtained,\n+  \/\/ rss_change.after will contain SIZE_MAX upon return.\n+  struct size_change_t { size_t before; size_t after; };\n+  static bool trim_native_heap(size_change_t* rss_change = nullptr);\n+\n@@ -560,0 +569,1 @@\n+  static bool file_exists(const char* file);\n@@ -698,0 +708,3 @@\n+  static void print_tos_pc(outputStream* st, const void* context);\n+  static void print_tos(outputStream* st, address sp);\n+  static void print_instructions(outputStream* st, address pc, int unitsize = 1);\n@@ -703,1 +716,0 @@\n-  static void print_instructions(outputStream* st, address pc, int unitsize);\n@@ -803,7 +815,0 @@\n-#ifndef PRODUCT\n-  static julong num_mallocs;         \/\/ # of calls to malloc\/realloc\n-  static julong alloc_bytes;         \/\/ # of bytes allocated\n-  static julong num_frees;           \/\/ # of calls to free\n-  static julong free_bytes;          \/\/ # of bytes freed\n-#endif\n-\n@@ -817,1 +822,0 @@\n-  static struct hostent* get_host_by_name(char* name);\n@@ -907,1 +911,1 @@\n-                                          char *buf, int buf_size) {\n+                                          char *buf, int buf_size, address& lastpc) {\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -378,2 +379,0 @@\n-  register_thread_stack_with_NMT();\n-\n@@ -382,0 +381,2 @@\n+  register_thread_stack_with_NMT();\n+\n@@ -483,0 +484,7 @@\n+  \/\/ If the target hasn't been started yet then it is trivially\n+  \/\/ \"protected\". We assume the caller is the thread that will do\n+  \/\/ the starting.\n+  if (p->osthread() == NULL || p->osthread()->get_state() <= INITIALIZED) {\n+    return true;\n+  }\n+\n@@ -650,1 +658,3 @@\n-  else                                { st->print(\"Thread\"); }\n+  else if (this == AsyncLogWriter::instance()) {\n+    st->print(\"%s\", this->name());\n+  } else                                { st->print(\"Thread\"); }\n@@ -1011,0 +1021,1 @@\n+  _in_asgct(false),\n@@ -1054,2 +1065,2 @@\n-  _jvmci_reserved0(nullptr),\n-  _jvmci_reserved1(nullptr),\n+  _jvmci_reserved0(0),\n+  _jvmci_reserved1(0),\n@@ -1333,2 +1344,3 @@\n-  \/\/ to complete once we've done the notify_all below\n-  java_lang_Thread::set_thread(threadObj(), NULL);\n+  \/\/ to complete once we've done the notify_all below. Needs a release() to obey Java Memory Model\n+  \/\/ requirements.\n+  java_lang_Thread::release_set_thread(threadObj(), NULL);\n@@ -1698,1 +1710,1 @@\n-    frame_anchor()->make_walkable(this);\n+    frame_anchor()->make_walkable();\n@@ -2194,1 +2206,1 @@\n-\/\/ descriptive string if there is no set name\n+\/\/ descriptive string if there is no set name.\n@@ -2218,0 +2230,13 @@\n+\/\/ Helper to extract the name from the thread oop for logging.\n+const char* JavaThread::name_for(oop thread_obj) {\n+  assert(thread_obj != NULL, \"precondition\");\n+  oop name = java_lang_Thread::name(thread_obj);\n+  const char* name_str;\n+  if (name != NULL) {\n+    name_str = java_lang_String::as_utf8_string(name);\n+  } else {\n+    name_str = \"<un-named>\";\n+  }\n+  return name_str;\n+}\n+\n@@ -2240,1 +2265,0 @@\n-  java_lang_Thread::set_thread(thread_oop(), this);\n@@ -2256,0 +2280,5 @@\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList. We don't want to wait for the release when the\n+  \/\/ Theads_lock is dropped somewhere in the caller since the JavaThread*\n+  \/\/ is already visible to JVM\/TI via the ThreadsList.\n+  java_lang_Thread::release_set_thread(thread_oop(), this);\n@@ -2267,0 +2296,19 @@\n+\/\/ Print current stack trace for checked JNI warnings and JNI fatal errors.\n+\/\/ This is the external format, selecting the platform\n+\/\/ as applicable, and allowing for a native-only stack.\n+void JavaThread::print_jni_stack() {\n+  assert(this == JavaThread::current(), \"Can't print stack of other threads\");\n+  if (!has_last_Java_frame()) {\n+    ResourceMark rm(this);\n+    char* buf = NEW_RESOURCE_ARRAY_RETURN_NULL(char, O_BUFLEN);\n+    if (buf == nullptr) {\n+      tty->print_cr(\"Unable to print native stack - out of memory\");\n+      return;\n+    }\n+    frame f = os::current_frame();\n+    VMError::print_native_stack(tty, f, this,\n+                                buf, O_BUFLEN);\n+  } else {\n+    print_stack_on(tty);\n+  }\n+}\n@@ -2769,0 +2817,5 @@\n+#if INCLUDE_NMT\n+  \/\/ Initialize NMT right after argument parsing to keep the pre-NMT-init window small.\n+  MemTracker::initialize();\n+#endif \/\/ INCLUDE_NMT\n+\n@@ -3053,0 +3106,4 @@\n+  if (NativeHeapTrimmer::enabled()) {\n+    NativeHeapTrimmer::initialize();\n+  }\n+\n@@ -3969,0 +4026,43 @@\n+\n+\/\/ Starts the target JavaThread as a daemon of the given priority, and\n+\/\/ bound to the given java.lang.Thread instance.\n+\/\/ The Threads_lock is held for the duration.\n+void JavaThread::start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                       Handle thread_oop, ThreadPriority prio) {\n+\n+  assert(target->osthread()!= NULL, \"target thread is not properly initialized\");\n+\n+  MutexLocker mu(current, Threads_lock);\n+\n+  \/\/ Initialize the fields of the thread_oop first.\n+  if (prio != NoPriority) {\n+    java_lang_Thread::set_priority(thread_oop(), prio);\n+    \/\/ Note: we don't call os::set_priority here. Possibly we should,\n+    \/\/ else all threads should call it themselves when they first run.\n+  }\n+\n+  java_lang_Thread::set_daemon(thread_oop());\n+\n+  \/\/ Now bind the thread_oop to the target JavaThread.\n+  target->set_threadObj(thread_oop());\n+\n+  Threads::add(target); \/\/ target is now visible for safepoint\/handshake\n+  \/\/ Publish the JavaThread* in java.lang.Thread after the JavaThread* is\n+  \/\/ on a ThreadsList. We don't want to wait for the release when the\n+  \/\/ Theads_lock is dropped when the 'mu' destructor is run since the\n+  \/\/ JavaThread* is already visible to JVM\/TI via the ThreadsList.\n+  java_lang_Thread::release_set_thread(thread_oop(), target); \/\/ isAlive == true now\n+  Thread::start(target);\n+}\n+\n+void JavaThread::vm_exit_on_osthread_failure(JavaThread* thread) {\n+  \/\/ At this point it may be possible that no osthread was created for the\n+  \/\/ JavaThread due to lack of resources. However, since this must work\n+  \/\/ for critical system threads just check and abort if this fails.\n+  if (thread->osthread() == nullptr) {\n+    \/\/ This isn't really an OOM condition, but historically this is what\n+    \/\/ we report.\n+    vm_exit_during_initialization(\"java.lang.OutOfMemoryError\",\n+                                  os::native_thread_creation_failed_msg());\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":110,"deletions":10,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n@@ -657,0 +656,25 @@\n+\n+ private:\n+  bool _in_asgct = false;\n+ public:\n+  bool in_asgct() const { return _in_asgct; }\n+  void set_in_asgct(bool value) { _in_asgct = value; }\n+  static bool current_in_asgct() {\n+    Thread *cur = Thread::current_or_null_safe();\n+    return cur != nullptr && cur->in_asgct();\n+  }\n+};\n+\n+class ThreadInAsgct {\n+ private:\n+  Thread* _thread;\n+ public:\n+  ThreadInAsgct(Thread* thread) : _thread(thread) {\n+    assert(thread != nullptr, \"invariant\");\n+    assert(!thread->in_asgct(), \"invariant\");\n+    thread->set_in_asgct(true);\n+  }\n+  ~ThreadInAsgct() {\n+    assert(_thread->in_asgct(), \"invariant\");\n+    _thread->set_in_asgct(false);\n+  }\n@@ -695,0 +719,1 @@\n+  bool           _in_asgct;                      \/\/ Is set when this JavaThread is handling ASGCT call\n@@ -960,2 +985,2 @@\n-  intptr_t*  _jvmci_reserved0;\n-  intptr_t*  _jvmci_reserved1;\n+  jlong      _jvmci_reserved0;\n+  jlong      _jvmci_reserved1;\n@@ -972,0 +997,24 @@\n+  void set_jvmci_reserved_oop0(oop value) {\n+    _jvmci_reserved_oop0 = value;\n+  }\n+\n+  oop get_jvmci_reserved_oop0() {\n+    return _jvmci_reserved_oop0;\n+  }\n+\n+  void set_jvmci_reserved0(jlong value) {\n+    _jvmci_reserved0 = value;\n+  }\n+\n+  jlong get_jvmci_reserved0() {\n+    return _jvmci_reserved0;\n+  }\n+\n+  void set_jvmci_reserved1(jlong value) {\n+    _jvmci_reserved1 = value;\n+  }\n+\n+  jlong get_jvmci_reserved1() {\n+    return _jvmci_reserved1;\n+  }\n+\n@@ -1379,0 +1428,1 @@\n+  static const char* name_for(oop thread_obj);\n@@ -1393,1 +1443,1 @@\n-    _anchor.make_walkable(this);\n+    _anchor.make_walkable();\n@@ -1405,0 +1455,4 @@\n+  \/\/ Print current stack trace for checked JNI warnings and JNI fatal errors.\n+  \/\/ This is the external format from above, but selecting the platform\n+  \/\/ as applicable.\n+  void print_jni_stack();\n@@ -1592,0 +1646,13 @@\n+\n+  \/\/ Helper function to start a VM-internal daemon thread.\n+  \/\/ E.g. ServiceThread, NotificationThread, CompilerThread etc.\n+  static void start_internal_daemon(JavaThread* current, JavaThread* target,\n+                                    Handle thread_oop, ThreadPriority prio);\n+\n+  \/\/ Helper function to do vm_exit_on_initialization for osthread\n+  \/\/ resource allocation failure.\n+  static void vm_exit_on_osthread_failure(JavaThread* thread);\n+\n+  \/\/ AsyncGetCallTrace support\n+  inline bool in_asgct(void) {return _in_asgct;}\n+  inline void set_in_asgct(bool value) {_in_asgct = value;}\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":71,"deletions":4,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-  template(G1Concurrent)                          \\\n+  template(G1PauseRemark)                         \\\n+  template(G1PauseCleanup)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1601,1 +1601,1 @@\n-  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n+  declare_c2_type(BlackholeNode, MultiNode)                               \\\n@@ -2560,1 +2560,1 @@\n-  declare_constant(RegisterImpl::number_of_registers)                     \\\n+  NOT_S390(NOT_PPC64(declare_constant(RegisterImpl::number_of_registers)))\\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,3 @@\n-\n+#ifdef LINUX\n+#include \"trimCHeapDCmd.hpp\"\n+#endif\n@@ -125,0 +127,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<TrimCLibcHeapDCmd>(full_export, true, false));\n@@ -477,1 +480,3 @@\n-               \"9 the strongest compression.\", \"INT\", false, \"1\") {\n+               \"9 the strongest compression.\", \"INT\", false, \"1\"),\n+  _overwrite(\"-overwrite\", \"If specified, the dump file will be overwritten if it exists\",\n+           \"BOOLEAN\", false, \"false\") {\n@@ -481,0 +486,1 @@\n+  _dcmdparser.add_dcmd_option(&_overwrite);\n@@ -499,1 +505,1 @@\n-  dumper.dump(_filename.value(), output(), (int) level);\n+  dumper.dump(_filename.value(), output(), (int) level, _overwrite.value());\n@@ -803,1 +809,2 @@\n-          output()->print_cr(\"%s\", out);\n+          \/\/ Avoid using print_cr() because length maybe longer than O_BUFLEN\n+          output()->print_raw_cr(out);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+  DCmdArgument<bool> _overwrite;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -417,2 +418,0 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n-\n@@ -434,2 +433,0 @@\n-#if INCLUDE_MANAGEMENT\n-\n@@ -2012,1 +2009,1 @@\n-          jstring command, dcmdArgInfo* infoArray))\n+          jstring command, dcmdArgInfo* infoArray, jint count))\n@@ -2036,2 +2033,4 @@\n-  if (array->length() == 0) {\n-    return;\n+  const int num_args = array->length();\n+  if (num_args != count) {\n+    assert(false, \"jmm_GetDiagnosticCommandArgumentsInfo count mismatch (%d vs %d)\", count, num_args);\n+    THROW_MSG(vmSymbols::java_lang_InternalError(), \"jmm_GetDiagnosticCommandArgumentsInfo count mismatch\");\n@@ -2039,1 +2038,1 @@\n-  for (int i = 0; i < array->length(); i++) {\n+  for (int i = 0; i < num_args; i++) {\n@@ -2079,1 +2078,36 @@\n-#endif \/\/ INCLUDE_MANAGEMENT\n+\n+\/\/ Gets the amount of memory allocated on the Java heap since JVM launch.\n+JVM_ENTRY(jlong, jmm_GetTotalThreadAllocatedMemory(JNIEnv *env))\n+    \/\/ A thread increments exited_allocated_bytes in ThreadService::remove_thread\n+    \/\/ only after it removes itself from the threads list, and once a TLH is\n+    \/\/ created, no thread it references can remove itself from the threads\n+    \/\/ list, so none can update exited_allocated_bytes. We therefore initialize\n+    \/\/ result with exited_allocated_bytes after after we create the TLH so that\n+    \/\/ the final result can only be short due to (1) threads that start after\n+    \/\/ the TLH is created, or (2) terminating threads that escape TLH creation\n+    \/\/ and don't update exited_allocated_bytes before we initialize result.\n+\n+    \/\/ We keep a high water mark to ensure monotonicity in case threads counted\n+    \/\/ on a previous call end up in state (2).\n+    static jlong high_water_result = 0;\n+\n+    JavaThreadIteratorWithHandle jtiwh;\n+    jlong result = ThreadService::exited_allocated_bytes();\n+    for (; JavaThread* thread = jtiwh.next();) {\n+      jlong size = thread->cooked_allocated_bytes();\n+      result += size;\n+    }\n+\n+    {\n+      assert(MonitoringSupport_lock != nullptr, \"Must be\");\n+      MutexLocker ml(MonitoringSupport_lock, Mutex::_no_safepoint_check_flag);\n+      if (result < high_water_result) {\n+        \/\/ Encountered (2) above, or result wrapped to a negative value. In\n+        \/\/ the latter case, it's pegged at the last positive value.\n+        result = high_water_result;\n+      } else {\n+        high_water_result = result;\n+      }\n+    }\n+    return result;\n+JVM_END\n@@ -2213,3 +2247,0 @@\n-\n-\n-#if INCLUDE_MANAGEMENT\n@@ -2249,1 +2280,1 @@\n-  NULL,\n+  jmm_GetTotalThreadAllocatedMemory,\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":44,"deletions":13,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -569,0 +569,26 @@\n+#if defined(RISCV32) || defined(RISCV64)\n+#define RISCV\n+#define RISCV_ONLY(code) code\n+#define NOT_RISCV(code)\n+#else\n+#undef RISCV\n+#define RISCV_ONLY(code)\n+#define NOT_RISCV(code) code\n+#endif\n+\n+#ifdef RISCV32\n+#define RISCV32_ONLY(code) code\n+#define NOT_RISCV32(code)\n+#else\n+#define RISCV32_ONLY(code)\n+#define NOT_RISCV32(code) code\n+#endif\n+\n+#ifdef RISCV64\n+#define RISCV64_ONLY(code) code\n+#define NOT_RISCV64(code)\n+#else\n+#define RISCV64_ONLY(code)\n+#define NOT_RISCV64(code) code\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1108,2 +1108,2 @@\n-        for (int i = 1; i < cmdarray.length; i++) {\n-            if (cmdarray[i].indexOf('\\u0000') >= 0) {\n+        for (String s : cmdarray) {\n+            if (s.indexOf('\\u0000') >= 0) {\n@@ -1311,0 +1311,4 @@\n+                if (prevOutput instanceof RedirectPipeImpl redir) {\n+                    \/\/ Wrap the fd so it can be closed\n+                    new Process.PipeInputStream(redir.getFd()).close();\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+import jdk.internal.logger.LoggerFinderLoader.TemporaryLoggerFinder;\n@@ -1745,1 +1746,2 @@\n-            if (service == null) {\n+            LoggerFinder finder = service;\n+            if (finder == null) {\n@@ -1748,1 +1750,1 @@\n-                service = AccessController.doPrivileged(pa, null,\n+                finder = AccessController.doPrivileged(pa, null,\n@@ -1750,0 +1752,2 @@\n+                if (finder instanceof TemporaryLoggerFinder) return finder;\n+                service = finder;\n@@ -1751,1 +1755,1 @@\n-            return service;\n+            return finder;\n@@ -2442,0 +2446,4 @@\n+            public int encodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n+            }\n+\n@@ -2479,0 +2487,4 @@\n+\n+            public String getLoaderNameID(ClassLoader loader) {\n+                return loader != null ? loader.nameAndId() : \"null\";\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-        return refersTo0(obj);\n+        return refersToImpl(obj);\n@@ -384,0 +384,3 @@\n+     * This method exists only to avoid making refersTo0() virtual. Making\n+     * refersTo0() virtual has the undesirable effect of C2 often preferring\n+     * to call the native implementation over the intrinsic.\n@@ -385,0 +388,4 @@\n+    boolean refersToImpl(T obj) {\n+        return refersTo0(obj);\n+    }\n+\n@@ -386,1 +393,1 @@\n-    native boolean refersTo0(Object o);\n+    private native boolean refersTo0(Object o);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -960,0 +960,1 @@\n+            validate(host);\n@@ -1134,1 +1135,5 @@\n-            addrArray = IPAddressUtil.textToNumericFormatV4(addrStr);\n+            try {\n+                addrArray = IPAddressUtil.validateNumericFormatV4(addrStr);\n+            } catch (IllegalArgumentException iae) {\n+                return null;\n+            }\n@@ -1340,0 +1345,1 @@\n+        validate(host);\n@@ -1347,2 +1353,2 @@\n-                \/\/ This was supposed to be a IPv6 address, but it's not!\n-                throw new UnknownHostException(host + \": invalid IPv6 address\");\n+                \/\/ This was supposed to be a IPv6 literal, but it's not\n+                throw invalidIPv6LiteralException(host, false);\n@@ -1352,2 +1358,2 @@\n-        \/\/ if host is an IP address, we won't do further lookup\n-        if (Character.digit(host.charAt(0), 16) != -1\n+        \/\/ Check and try to parse host string as an IP address literal\n+        if (IPAddressUtil.digit(host.charAt(0), 16) != -1\n@@ -1358,2 +1364,11 @@\n-            \/\/ see if it is IPv4 address\n-            addr = IPAddressUtil.textToNumericFormatV4(host);\n+\n+            if (!ipv6Expected) {\n+                \/\/ check if it is IPv4 address only if host is not wrapped in '[]'\n+                try {\n+                    addr = IPAddressUtil.validateNumericFormatV4(host);\n+                } catch (IllegalArgumentException iae) {\n+                    var uhe = new UnknownHostException(host);\n+                    uhe.initCause(iae);\n+                    throw uhe;\n+                }\n+            }\n@@ -1361,2 +1376,2 @@\n-                \/\/ This is supposed to be an IPv6 literal\n-                \/\/ Check if a numeric or string zone id is present\n+                \/\/ Try to parse host string as an IPv6 literal\n+                \/\/ Check if a numeric or string zone id is present first\n@@ -1364,2 +1379,2 @@\n-                if ((pos=host.indexOf ('%')) != -1) {\n-                    numericZone = checkNumericZone (host);\n+                if ((pos = host.indexOf('%')) != -1) {\n+                    numericZone = checkNumericZone(host);\n@@ -1367,1 +1382,1 @@\n-                        ifname = host.substring (pos+1);\n+                        ifname = host.substring(pos + 1);\n@@ -1370,2 +1385,3 @@\n-                if ((addr = IPAddressUtil.textToNumericFormatV6(host)) == null && host.contains(\":\")) {\n-                    throw new UnknownHostException(host + \": invalid IPv6 address\");\n+                if ((addr = IPAddressUtil.textToNumericFormatV6(host)) == null &&\n+                        (host.contains(\":\") || ipv6Expected)) {\n+                    throw invalidIPv6LiteralException(host, ipv6Expected);\n@@ -1373,4 +1389,1 @@\n-            } else if (ipv6Expected) {\n-                \/\/ Means an IPv4 literal between brackets!\n-                throw new UnknownHostException(\"[\"+host+\"]\");\n-            InetAddress[] ret = new InetAddress[1];\n+                InetAddress[] ret = new InetAddress[1];\n@@ -1380,0 +1393,4 @@\n+                    if (numericZone != -1 || ifname != null) {\n+                        \/\/ IPv4-mapped address must not contain zone-id\n+                        throw new UnknownHostException(host + \": invalid IPv4-mapped address\");\n+                    }\n@@ -1391,2 +1408,3 @@\n-            \/\/ We were expecting an IPv6 Literal, but got something else\n-            throw new UnknownHostException(\"[\"+host+\"]\");\n+            \/\/ We were expecting an IPv6 Literal since host string starts\n+            \/\/ and ends with square brackets, but we got something else.\n+            throw invalidIPv6LiteralException(host, true);\n@@ -1397,0 +1415,5 @@\n+    private static UnknownHostException invalidIPv6LiteralException(String host, boolean wrapInBrackets) {\n+        String hostString = wrapInBrackets ? \"[\" + host + \"]\" : host;\n+        return new UnknownHostException(hostString + \": invalid IPv6 address literal\");\n+    }\n+\n@@ -1424,0 +1447,1 @@\n+        int multmax = Integer.MAX_VALUE \/ 10; \/\/ for int overflow detection\n@@ -1429,6 +1453,2 @@\n-            if (c == ']') {\n-                if (i == percent+1) {\n-                    \/* empty per-cent field *\/\n-                    return -1;\n-                }\n-                break;\n+            if ((digit = IPAddressUtil.parseAsciiDigit(c, 10)) < 0) {\n+                return -1;\n@@ -1436,1 +1456,1 @@\n-            if ((digit = Character.digit (c, 10)) < 0) {\n+            if (zone > multmax) {\n@@ -1440,0 +1460,4 @@\n+            if (zone < 0) {\n+                return -1;\n+            }\n+\n@@ -1817,0 +1841,6 @@\n+\n+    private static void validate(String host) throws UnknownHostException {\n+        if (host.indexOf(0) != -1) {\n+            throw new UnknownHostException(\"NUL character not allowed in hostname\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":58,"deletions":28,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+import sun.nio.fs.DefaultFileSystemProvider;\n+import sun.security.action.GetPropertyAction;\n@@ -125,0 +127,7 @@\n+    \/**\n+     * Flag to specify whether the Extra ZIP64 validation should be\n+     * disabled.\n+     *\/\n+    private static final boolean DISABLE_ZIP64_EXTRA_VALIDATION =\n+            getDisableZip64ExtraFieldValidation();\n+\n@@ -1095,0 +1104,15 @@\n+    \/**\n+     * Returns the value of the System property which indicates whether the\n+     * Extra ZIP64 validation should be disabled.\n+     *\/\n+    static boolean getDisableZip64ExtraFieldValidation() {\n+        boolean result;\n+        String value = GetPropertyAction.privilegedGetProperty(\n+                \"jdk.util.zip.disableZip64ExtraFieldValidation\");\n+        if (value == null) {\n+            result = false;\n+        } else {\n+            result = value.isEmpty() || value.equalsIgnoreCase(\"true\");\n+        }\n+        return result;\n+    }\n@@ -1214,0 +1238,10 @@\n+\n+            int elen = CENEXT(cen, pos);\n+            if (elen > 0 && !DISABLE_ZIP64_EXTRA_VALIDATION) {\n+                long extraStartingOffset = pos + CENHDR + nlen;\n+                if ((int)extraStartingOffset != extraStartingOffset) {\n+                    zerror(\"invalid CEN header (bad extra offset)\");\n+                }\n+                checkExtraFields(pos, (int)extraStartingOffset, elen);\n+            }\n+\n@@ -1230,0 +1264,130 @@\n+        \/**\n+         * Validate the Zip64 Extra block fields\n+         * @param startingOffset Extra Field starting offset within the CEN\n+         * @param extraFieldLen Length of this Extra field\n+         * @throws ZipException  If an error occurs validating the Zip64 Extra\n+         * block\n+         *\/\n+        private void checkExtraFields(int cenPos, int startingOffset,\n+                                      int extraFieldLen) throws ZipException {\n+            \/\/ Extra field Length cannot exceed 65,535 bytes per the PKWare\n+            \/\/ APP.note 4.4.11\n+            if (extraFieldLen > 0xFFFF) {\n+                zerror(\"invalid extra field length\");\n+            }\n+            \/\/ CEN Offset where this Extra field ends\n+            int extraEndOffset = startingOffset + extraFieldLen;\n+            if (extraEndOffset > cen.length) {\n+                zerror(\"Invalid CEN header (extra data field size too long)\");\n+            }\n+            int currentOffset = startingOffset;\n+            \/\/ Walk through each Extra Header. Each Extra Header Must consist of:\n+            \/\/       Header ID - 2 bytes\n+            \/\/       Data Size - 2 bytes:\n+            while (currentOffset + Integer.BYTES <= extraEndOffset) {\n+                int tag = get16(cen, currentOffset);\n+                currentOffset += Short.BYTES;\n+\n+                int tagBlockSize = get16(cen, currentOffset);\n+                currentOffset += Short.BYTES;\n+                int tagBlockEndingOffset = currentOffset + tagBlockSize;\n+\n+                \/\/  The ending offset for this tag block should not go past the\n+                \/\/  offset for the end of the extra field\n+                if (tagBlockEndingOffset > extraEndOffset) {\n+                    zerror(String.format(\n+                            \"Invalid CEN header (invalid extra data field size for \" +\n+                                    \"tag: 0x%04x at %d)\",\n+                            tag, cenPos));\n+                }\n+\n+                if (tag == ZIP64_EXTID) {\n+                    \/\/ Get the compressed size;\n+                    long csize = CENSIZ(cen, cenPos);\n+                    \/\/ Get the uncompressed size;\n+                    long size = CENLEN(cen, cenPos);\n+\n+                    checkZip64ExtraFieldValues(currentOffset, tagBlockSize,\n+                            csize, size);\n+                }\n+                currentOffset += tagBlockSize;\n+            }\n+        }\n+\n+        \/**\n+         * Validate the Zip64 Extended Information Extra Field (0x0001) block\n+         * size and that the uncompressed size and compressed size field\n+         * values are not negative.\n+         * Note:  As we do not use the LOC offset or Starting disk number\n+         * field value we will not validate them\n+         * @param off the starting offset for the Zip64 field value\n+         * @param blockSize the size of the Zip64 Extended Extra Field\n+         * @param csize CEN header compressed size value\n+         * @param size CEN header uncompressed size value\n+         * @throws ZipException if an error occurs\n+         *\/\n+        private void checkZip64ExtraFieldValues(int off, int blockSize, long csize,\n+                                                long size)\n+                throws ZipException {\n+            byte[] cen = this.cen;\n+            \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n+            \/\/ versions of Apache Ant and Commons Compress, validate csize and size\n+            \/\/ to make sure neither field == ZIP64_MAGICVAL\n+            if (blockSize == 0) {\n+                if (csize == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL) {\n+                    zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+                }\n+                \/\/ Only validate the ZIP64_EXTID data if the block size > 0\n+                return;\n+            }\n+            \/\/ Validate the Zip64 Extended Information Extra Field (0x0001)\n+            \/\/ length.\n+            if (!isZip64ExtBlockSizeValid(blockSize)) {\n+                zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n+            }\n+            \/\/ Check the uncompressed size is not negative\n+            \/\/ Note we do not need to check blockSize is >= 8 as\n+            \/\/ we know its length is at least 8 from the call to\n+            \/\/ isZip64ExtBlockSizeValid()\n+            if ((size == ZIP64_MAGICVAL)) {\n+                if(get64(cen, off) < 0) {\n+                    zerror(\"Invalid zip64 extra block size value\");\n+                }\n+            }\n+            \/\/ Check the compressed size is not negative\n+            if ((csize == ZIP64_MAGICVAL) && (blockSize >= 16)) {\n+                if (get64(cen, off + 8) < 0) {\n+                    zerror(\"Invalid zip64 extra block compressed size value\");\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Validate the size and contents of a Zip64 extended information field\n+         * The order of the Zip64 fields is fixed, but the fields MUST\n+         * only appear if the corresponding LOC or CEN field is set to 0xFFFF:\n+         * or 0xFFFFFFFF:\n+         * Uncompressed Size - 8 bytes\n+         * Compressed Size   - 8 bytes\n+         * LOC Header offset - 8 bytes\n+         * Disk Start Number - 4 bytes\n+         * See PKWare APP.Note Section 4.5.3 for more details\n+         *\n+         * @param blockSize the Zip64 Extended Information Extra Field size\n+         * @return true if the extra block size is valid; false otherwise\n+         *\/\n+        private static boolean isZip64ExtBlockSizeValid(int blockSize) {\n+            \/*\n+             * As the fields must appear in order, the block size indicates which\n+             * fields to expect:\n+             *  8 - uncompressed size\n+             * 16 - uncompressed size, compressed size\n+             * 24 - uncompressed size, compressed sise, LOC Header offset\n+             * 28 - uncompressed size, compressed sise, LOC Header offset,\n+             * and Disk start number\n+             *\/\n+            return switch(blockSize) {\n+                case 8, 16, 24, 28 -> true;\n+                default -> false;\n+            };\n+        }\n@@ -1274,1 +1438,6 @@\n-\n+        \/**\n+         * Use the platform's default file system to avoid\n+         * issues when the VM is configured to use a custom file system provider.\n+         *\/\n+        private static final java.nio.file.FileSystem builtInFS =\n+                DefaultFileSystemProvider.theFileSystem();\n@@ -1280,2 +1449,2 @@\n-                        Files.readAttributes(file.toPath(), BasicFileAttributes.class),\n-                        zc);\n+                        Files.readAttributes(builtInFS.getPath(file.getPath()),\n+                                BasicFileAttributes.class), zc);\n@@ -1645,5 +1814,2 @@\n-                        if ((entryLen == nameLen && entry.equals(name)) ||\n-                                (addSlash &&\n-                                nameLen + 1 == entryLen &&\n-                                entry.startsWith(name) &&\n-                                entry.charAt(entryLen - 1) == '\/')) {\n+                        if (entryLen == nameLen && entry.equals(name)) {\n+                            \/\/ Found our match\n@@ -1652,0 +1818,8 @@\n+                        \/\/ If addSlash is true we'll now test for name+\/ providing\n+                        if (addSlash && nameLen + 1 == entryLen\n+                                && entry.startsWith(name) &&\n+                                entry.charAt(entryLen - 1) == '\/') {\n+                            \/\/ Found the entry \"name+\/\", now find the CEN entry pos\n+                            int exactPos = getEntryPos(name, false);\n+                            return exactPos == -1 ? pos : exactPos;\n+                        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":182,"deletions":8,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import java.util.zip.CRC32;\n@@ -874,0 +875,1 @@\n+                private Exception dataError = null;\n@@ -889,0 +891,12 @@\n+                public Exception getDataError()\n+                    { return dataError; }\n+                public byte[] getBytes() throws IOException {\n+                    byte[] bytes = super.getBytes();\n+                    CRC32 crc32 = new CRC32();\n+                    crc32.update(bytes);\n+                    if (crc32.getValue() != entry.getCrc()) {\n+                        dataError = new IOException(\n+                                \"CRC error while extracting entry from JAR file\");\n+                    }\n+                    return bytes;\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+        jdk.charsets,\n@@ -158,0 +159,1 @@\n+        jdk.jfr,\n@@ -325,1 +327,2 @@\n-        java.naming;\n+        java.naming,\n+        jdk.jartool;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -552,1 +552,1 @@\n-                    if (n >= 0) {\n+                    if (n > 0 || (n == 0 && isOpen())) {\n@@ -673,1 +673,1 @@\n-            if (n >= 0) {\n+            if (n > 0 || (n == 0 && isOpen())) {\n@@ -710,1 +710,1 @@\n-                if (n >= 0) {\n+                if (n > 0 || (n == 0 && isOpen())) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,3 @@\n+    \/\/ Maximum direct transfer size\n+    private static final int MAX_DIRECT_TRANSFER_SIZE;\n+\n@@ -623,0 +626,9 @@\n+        if (target == this) {\n+            long posThis = position();\n+            if (posThis - count + 1 <= position &&\n+                position - count + 1 <= posThis &&\n+                !nd.canTransferToFromOverlappedMap()) {\n+                return IOStatus.UNSUPPORTED_CASE;\n+            }\n+        }\n+\n@@ -663,1 +675,1 @@\n-    private long transferToArbitraryChannel(long position, int icount,\n+    private long transferToArbitraryChannel(long position, long count,\n@@ -668,1 +680,1 @@\n-        int c = Math.min(icount, TRANSFER_SIZE);\n+        int c = (int)Math.min(count, TRANSFER_SIZE);\n@@ -673,2 +685,2 @@\n-            while (tw < icount) {\n-                bb.limit(Math.min((int)(icount - tw), TRANSFER_SIZE));\n+            while (tw < count) {\n+                bb.limit((int)Math.min(count - tw, TRANSFER_SIZE));\n@@ -713,4 +725,2 @@\n-        int icount = (int)Math.min(count, Integer.MAX_VALUE);\n-        if ((sz - position) < icount)\n-            icount = (int)(sz - position);\n-        long n;\n+        if ((sz - position) < count)\n+            count = sz - position;\n@@ -719,1 +729,4 @@\n-        \/\/ Attempt a direct transfer, if the kernel supports it\n+        \/\/ Attempt a direct transfer, if the kernel supports it, limiting\n+        \/\/ the number of bytes according to which platform\n+        int icount = (int)Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n+        long n;\n@@ -724,1 +737,1 @@\n-        if ((n = transferToTrustedChannel(position, icount, target)) >= 0)\n+        if ((n = transferToTrustedChannel(position, count, target)) >= 0)\n@@ -728,1 +741,1 @@\n-        return transferToArbitraryChannel(position, icount, target);\n+        return transferToArbitraryChannel(position, count, target);\n@@ -741,0 +754,8 @@\n+            if (src == this) {\n+                if (position() - max + 1 <= pos &&\n+                    pos - max + 1 <= position() &&\n+                    !nd.canTransferToFromOverlappedMap()) {\n+                    return IOStatus.UNSUPPORTED_CASE;\n+                }\n+            }\n+\n@@ -816,3 +837,6 @@\n-        if (src instanceof FileChannelImpl)\n-           return transferFromFileChannel((FileChannelImpl)src,\n-                                          position, count);\n+\n+        if (src instanceof FileChannelImpl fci) {\n+            long n = transferFromFileChannel(fci, position, count);\n+            if (n >= 0)\n+                return n;\n+        }\n@@ -1389,0 +1413,3 @@\n+    \/\/ Retrieves the maximum size of a transfer\n+    private static native int maxDirectTransferSize0();\n+\n@@ -1395,0 +1422,1 @@\n+        MAX_DIRECT_TRANSFER_SIZE = maxDirectTransferSize0();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":43,"deletions":15,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,0 +186,5 @@\n+            if (nanos > MILLISECONDS.toNanos(millis)) {\n+                \/\/ Round up any excess nanos to the nearest millisecond to\n+                \/\/ avoid parking for less than requested.\n+                millis++;\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.io.InvalidObjectException;\n@@ -267,1 +268,1 @@\n-     *\n+     * <p>\n@@ -366,2 +367,4 @@\n-     * readObject is called to restore the state of the random object from\n-     * a stream.  We have to create a new instance of MessageDigest, because\n+     * This method is called to restore the state of the random object from\n+     * a stream.\n+     * <p>\n+     * We have to create a new instance of {@code MessageDigest}, because\n@@ -369,3 +372,3 @@\n-     *\n-     * Note that the engineNextBytes() method invoked on the restored random\n-     * object will yield the exact same (random) bytes as the original.\n+     * <p>\n+     * Note that the {@code engineNextBytes()} method invoked on the restored\n+     * random object will yield the exact same (random) bytes as the original.\n@@ -373,1 +376,5 @@\n-     * random object, using engineSetSeed().\n+     * random object, using {@code engineSetSeed()}.\n+     *\n+     * @param  s the {@code ObjectInputStream} from which data is read\n+     * @throws IOException if an I\/O error occurs\n+     * @throws ClassNotFoundException if a serialized class cannot be loaded\n@@ -377,1 +384,1 @@\n-        throws IOException, ClassNotFoundException {\n+            throws IOException, ClassNotFoundException {\n@@ -396,0 +403,29 @@\n+\n+        \/\/ Various consistency checks\n+        if ((remainder == null) && (remCount > 0)) {\n+            throw new InvalidObjectException(\n+                    \"Remainder indicated, but no data available\");\n+        }\n+\n+        \/\/ Not yet allocated state\n+        if (state == null) {\n+            if (remainder == null) {\n+                return;\n+            } else {\n+                throw new InvalidObjectException(\n+                        \"Inconsistent buffer allocations\");\n+            }\n+        }\n+\n+        \/\/ Sanity check on sizes\/pointer\n+        if ((state.length != DIGEST_SIZE) ||\n+                ((remainder != null) && (remainder.length != DIGEST_SIZE)) ||\n+                (remCount < 0 ) || (remCount >= DIGEST_SIZE)) {\n+            throw new InvalidObjectException(\n+                    \"Inconsistent buffer sizes\/state\");\n+        }\n+\n+        state = state.clone();\n+        if (remainder != null) {\n+            remainder = remainder.clone();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1081,2 +1081,4 @@\n-purposes only and may cause intermittent failures due to the use of\n-address space layout randomization by the operation system.\n+purposes only.\n+It may cause the VM to unexpectedly exit during start\\-up when the CDS\n+archive cannot be used (for example, when certain VM parameters are\n+changed, or when a different JDK is used).\n@@ -1563,0 +1565,11 @@\n+.B \\f[CB]-XX:TrimNativeHeapInterval=\\f[R]\\f[I]millis\\f[R]\n+Interval, in ms, at which the JVM will trim the native heap.\n+Lower values will reclaim memory more eagerly at the cost of higher\n+overhead.\n+A value of 0 (default) disables native heap trimming.\n+Native heap trimming is performed in a dedicated thread.\n+.RS\n+.PP\n+This option is only supported on Linux with GNU C Library (glibc).\n+.RE\n+.TP\n@@ -1665,0 +1678,9 @@\n+\\f[V]-XX:+VerifySharedSpaces\\f[R]\n+If this option is specified, the JVM will load a CDS archive file only\n+if it passes an integrity check based on CRC32 checksums.\n+The purpose of this flag is to check for unintentional damage to CDS\n+archive files in transmission or storage.\n+To guarantee the security and proper operation of CDS, the user must\n+ensure that the CDS archive files used by Java applications cannot be\n+modified without proper authorization.\n+.TP\n@@ -5327,2 +5349,7 @@\n-Application Class Data Sharing (AppCDS) extends class data sharing (CDS)\n-to enable application classes to be placed in a shared archive.\n+Application Class Data Sharing (AppCDS) stores classes used by your\n+applications in an archive file.\n+Since these classes are stored in a format that can be loaded very\n+quickly (compared to classes stored in a JAR file), AppCDS can improve\n+the start\\-up time of your applications.\n+In addition, AppCDS can reduce the runtime memory footprint by sharing\n+parts of these classes across multiple processes.\n@@ -5330,12 +5357,9 @@\n-In addition to the core library classes, AppCDS supports \\f[B]Class Data\n-Sharing\\f[R]\n-[https:\/\/docs.oracle.com\/en\/java\/javase\/12\/vm\/class\\-data\\-sharing.html#GUID\\-7EAA3411\\-8CF0\\-4D19\\-BD05\\-DF5E1780AA91]\n-from the following locations:\n-.IP \\[bu] 2\n-Platform classes from the runtime image\n-.IP \\[bu] 2\n-Application classes from the runtime image\n-.IP \\[bu] 2\n-Application classes from the class path\n-.IP \\[bu] 2\n-Application classes from the module path\n+Classes in the CDS archive are stored in an optimized format that\\[aq]s\n+about 2 to 5 times larger than classes stored in JAR files or the JDK\n+runtime image.\n+Therefore, it\\[aq]s a good idea to archive only those classes that are\n+actually used by your application.\n+These usually are just a small portion of all available classes.\n+For example, your application may use only a few APIs provided by a\n+large library.\n+.SS Using CDS Archives\n@@ -5343,3 +5367,6 @@\n-Archiving application classes provides better start up time at runtime.\n-When running multiple JVM processes, AppCDS also reduces the runtime\n-footprint with memory sharing for read\\-only metadata.\n+By default, in most JDK distributions, unless \\f[CB]\\-Xshare:off\\f[R] is\n+specified, the JVM starts up with a default CDS archive, which is\n+usually located in \\f[CB]JAVA_HOME\/lib\/server\/classes.jsa\\f[R] (or\n+\\f[CB]JAVA_HOME\\\\bin\\\\server\\\\classes.jsa\\f[R] on Windows).\n+This archive contains about 1300 core library classes that are used by\n+most applications.\n@@ -5347,1 +5374,4 @@\n-CDS\/AppCDS supports archiving classes from JAR files only.\n+To use CDS for the exact set of classes used by your application, you\n+can use the \\f[CB]\\-XX:SharedArchiveFile\\f[R] option, which has the\n+general form:\n+.RS\n@@ -5349,5 +5379,2 @@\n-Prior to JDK 11, a non\\-empty directory was reported as a fatal error in\n-the following conditions:\n-.IP \\[bu] 2\n-For base CDS, a non\\-empty directory cannot exist in the\n-\\f[CB]\\-Xbootclasspath\/a\\f[R] path\n+\\f[CB]\\-XX:SharedArchiveFile=<static_archive>:<dynamic_archive>\\f[R]\n+.RE\n@@ -5355,8 +5382,1 @@\n-With \\f[CB]\\-XX:+UseAppCDS\\f[R], a non\\-empty directory could not exist in\n-the \\f[CB]\\-Xbootclasspath\/a\\f[R] path, class path, and module path.\n-.PP\n-In JDK 11 and later, \\f[CB]\\-XX:+UseAppCDS\\f[R] is obsolete and the\n-behavior for a non\\-empty directory is based on the class types in the\n-classlist.\n-A non\\-empty directory is reported as a fatal error in the following\n-conditions:\n+The \\f[CB]<static_archive>\\f[R] overrides the default CDS archive.\n@@ -5364,3 +5384,2 @@\n-If application classes or platform classes are not loaded, dump time\n-only reports an error if a non\\-empty directory exists in\n-\\f[CB]\\-Xbootclasspath\/a\\f[R] path\n+The \\f[CB]<dynamic_archive>\\f[R] provides additional classes that can be\n+loaded on top of those in the \\f[CB]<static_archive>\\f[R].\n@@ -5368,10 +5387,2 @@\n-If application classes or platform classes are loaded, dump time reports\n-an error for a non\\-empty directory that exists in\n-\\f[CB]\\-Xbootclasspath\/a\\f[R] path, class path, or module path\n-.PP\n-In JDK 11 and later, using\n-\\f[CB]\\-XX:DumpLoadedClassList=\\f[R]\\f[I]class_list_file\\f[R] results a\n-generated classlist with all classes (both system library classes and\n-application classes) included.\n-You no longer have to specify \\f[CB]\\-XX:+UseAppCDS\\f[R] with\n-\\f[CB]\\-XX:DumpLoadedClassList\\f[R] to produce a complete class list.\n+On Windows, the above path delimiter \\f[CB]:\\f[R] should be replaced with\n+\\f[CB];\\f[R]\n@@ -5379,4 +5390,3 @@\n-In JDK 11 and later, because \\f[CB]UseAppCDS\\f[R] is obsolete,\n-\\f[CB]SharedArchiveFile\\f[R] becomes a product flag by default.\n-Specifying \\f[CB]+UnlockDiagnosticVMOptions\\f[R] for\n-\\f[CB]SharedArchiveFile\\f[R] is no longer needed in any configuration.\n+(The names \"static\" and \"dyanmic\" are used for historical reasons.\n+The only significance is that the \"static\" archive is loaded first and\n+the \"dynamic\" archive is loaded second).\n@@ -5384,4 +5394,3 @@\n-Class Data Sharing (CDS)\/AppCDS does not support archiving array classes\n-in a class list.\n-When an array in the class list is encountered, CDS dump time gives the\n-explicit error message:\n+The JVM can use up to two archives.\n+To use only a single \\f[CB]<static_archive>\\f[R], you can omit the\n+\\f[CB]<dynamic_archive>\\f[R] portion:\n@@ -5390,1 +5399,1 @@\n-\\f[CB]Preload\\ Warning:\\ Cannot\\ find\\f[R] \\f[I]array_name\\f[R]\n+\\f[CB]\\-XX:SharedArchiveFile=<static_archive>\\f[R]\n@@ -5393,14 +5402,3 @@\n-Although an array in the class list is not allowed, some array classes\n-can still be created at CDS\/AppCDS dump time.\n-Those arrays are created during the execution of the Java code used by\n-the Java class loaders (\\f[CB]PlatformClassLoader\\f[R] and the system\n-class loader) to load classes at dump time.\n-The created arrays are archived with the rest of the loaded classes.\n-.SS Extending Class Data Sharing to Support the Module Path\n-.PP\n-In JDK 11, Class Data Sharing (CDS) has been improved to support\n-archiving classes from the module path.\n-.IP \\[bu] 2\n-To create a CDS archive using the \\f[CB]\\-\\-module\\-path\\f[R] VM option,\n-use the following command line syntax:\n-.RS 2\n+For convenience, the \\f[CB]<dynamic_archive>\\f[R] records the location of\n+the \\f[CB]<static_archive>\\f[R].\n+Therefore, you can omit the \\f[CB]<static_archive>\\f[R] by saying only:\n@@ -5409,4 +5407,1 @@\n-\\f[CB]java\\ \\-Xshare:dump\\ \\-XX:SharedClassListFile=\\f[R]\\f[I]class_list_file\\f[R]\n-\\f[CB]\\-XX:SharedArchiveFile=\\f[R]\\f[I]shared_archive_file\\f[R]\n-\\f[CB]\\-\\-module\\-path=\\f[R]\\f[I]path_to_modular_jar\\f[R] \\f[CB]\\-m\\f[R]\n-\\f[I]module_name\\f[R]\n+\\f[CB]\\-XX:SharedArchiveFile=<dynamic_archive>\\f[R]\n@@ -5414,6 +5409,1 @@\n-.RE\n-.IP \\[bu] 2\n-To run with a CDS archive using the \\f[CB]\\-\\-module\\-path\\f[R] VM option,\n-use the following the command line syntax:\n-.RS 2\n-.RS\n+.SS Creating CDS Archives\n@@ -5421,111 +5411,1 @@\n-\\f[CB]java\\ \\-XX:SharedArchiveFile=\\f[R]\\f[I]shared_archive_file\\f[R]\n-\\f[CB]\\-\\-module\\-path=\\f[R]\\f[I]path_to_modular_jar\\f[R] \\f[CB]\\-m\\f[R]\n-\\f[I]module_name\\f[R]\n-.RE\n-.RE\n-.PP\n-The following table describes how the VM options related to module paths\n-can be used along with the \\f[CB]\\-Xshare\\f[R] option.\n-.PP\n-.TS\n-tab(@);\n-l l l.\n-T{\n-Option\n-T}@T{\n-\\-Xshare:dump\n-T}@T{\n-\\-Xshare:{on,auto}\n-T}\n-_\n-T{\n-\\f[CB]\\-\\-module\\-path\\f[R][1] \\f[I]mp\\f[R]\n-T}@T{\n-Allowed\n-T}@T{\n-Allowed[2]\n-T}\n-T{\n-\\f[CB]\\-\\-module\\f[R]\n-T}@T{\n-Allowed\n-T}@T{\n-Allowed\n-T}\n-T{\n-\\f[CB]\\-\\-add\\-module\\f[R]\n-T}@T{\n-Allowed\n-T}@T{\n-Allowed\n-T}\n-T{\n-\\f[CB]\\-\\-upgrade\\-module\\-path\\f[R][3]\n-T}@T{\n-Disallowed (exits if specified)\n-T}@T{\n-Allowed (disables CDS)\n-T}\n-T{\n-\\f[CB]\\-\\-patch\\-module\\f[R][4]\n-T}@T{\n-Disallowed (exits if specified)\n-T}@T{\n-Allowed (disables CDS)\n-T}\n-T{\n-\\f[CB]\\-\\-limit\\-modules\\f[R][5]\n-T}@T{\n-Disallowed (exits if specified)\n-T}@T{\n-Allowed (disables CDS)\n-T}\n-.TE\n-.PP\n-[1] Although there are two ways of specifying a module in a\n-\\f[CB]\\-\\-module\\-path\\f[R], that is, modular JAR or exploded module, only\n-modular JARs are supported.\n-.PP\n-[2] Different \\f[I]mp\\f[R] can be specified during dump time versus run\n-time.\n-If an archived class K was loaded from \\f[CB]mp1.jar\\f[R] at dump time,\n-but changes in \\f[I]mp\\f[R] cause it to be available from a different\n-\\f[CB]mp2.jar\\f[R] at run time, then the archived version of K will be\n-disregarded at run time; K will be loaded dynamically.\n-.PP\n-[3] Currently, only two system modules are upgradeable\n-(\\f[CB]java.compiler\\f[R] and \\f[CB]jdk.internal.vm.compiler\\f[R]).\n-However, these modules are seldom upgraded in production software.\n-.PP\n-[4] As documented in JEP 261, using \\f[CB]\\-\\-patch\\-module\\f[R] is\n-strongly discouraged for production use.\n-.PP\n-[5] \\f[CB]\\-\\-limit\\-modules\\f[R] is intended for testing purposes.\n-It is seldom used in production software.\n-.PP\n-If \\f[CB]\\-\\-upgrade\\-module\\-path\\f[R], \\f[CB]\\-\\-patch\\-module\\f[R], or\n-\\f[CB]\\-\\-limit\\-modules\\f[R] is specified at dump time, an error will be\n-printed and the JVM will exit.\n-For example, if the \\f[CB]\\-\\-limit\\-modules\\f[R] option is specified at\n-dump time, the user will see the following error:\n-.IP\n-.nf\n-\\f[CB]\n-Error\\ occurred\\ during\\ initialization\\ of\\ VM\n-Cannot\\ use\\ the\\ following\\ option\\ when\\ dumping\\ the\\ shared\\ archive:\\ \\-\\-limit\\-modules\n-\\f[R]\n-.fi\n-.PP\n-If \\f[CB]\\-\\-upgrade\\-module\\-path\\f[R], \\f[CB]\\-\\-patch\\-module\\f[R], or\n-\\f[CB]\\-\\-limit\\-modules\\f[R] is specified at run time, a warning message\n-will be printed indicating that CDS is disabled.\n-For example, if the \\f[CB]\\-\\-limit\\-modules\\f[R] options is specified at\n-run time, the user will see the following warning:\n-.IP\n-.nf\n-\\f[CB]\n-Java\\ HotSpot(TM)\\ 64\\-Bit\\ Server\\ VM\\ warning:\\ CDS\\ is\\ disabled\\ when\\ the\\ \\-\\-limit\\-modules\\ option\\ is\\ specified.\n-\\f[R]\n-.fi\n-.PP\n-Several other noteworthy things include:\n+CDS archives can be created with several methods:\n@@ -5533,2 +5413,1 @@\n-Any valid combinations of \\f[CB]\\-cp\\f[R] and \\f[CB]\\-\\-module\\-path\\f[R]\n-are supported.\n+\\f[CB]\\-Xshare:dump\\f[R]\n@@ -5536,14 +5415,1 @@\n-A non\\-empty directory in the module path causes a fatal error.\n-The user will see the following error messages:\n-.RS 2\n-.IP\n-.nf\n-\\f[CB]\n-Error:\\ non\\-empty\\ directory\\ <directory>\\ Hint:\\ enable\\ \\-Xlog:class+path=info\\ to\\ diagnose\\ the\\ failure\\ Error\\ occurred\\ during\\ initialization\\ of\\ VM\\ Cannot\\ have\\ non\\-empty\\ directory\\ in\\ paths\n-\\f[R]\n-.fi\n-.RE\n-.IP \\[bu] 2\n-Unlike the class path, there\\[aq]s no restriction that the module path\n-at dump time must be equal to or be a prefix of the module path at run\n-time.\n+\\f[CB]\\-XX:ArchiveClassesAtExit\\f[R]\n@@ -5551,15 +5417,1 @@\n-The archive is invalidated if an existing JAR in the module path is\n-updated after archive generation.\n-.IP \\[bu] 2\n-Removing a JAR from the module path does not invalidate the shared\n-archive.\n-Archived classes from the removed JAR are not used at runtime.\n-.SS Dynamic CDS archive\n-.PP\n-Dynamic CDS archive extends AppCDS to allow archiving of classes when a\n-Java application exits.\n-It improves the usability of AppCDS by eliminating the trial run step\n-for creating a class list for each application.\n-The archived classes include all loaded application classes and library\n-classes that are not present in the default CDS archive which is\n-included in the JDK.\n+\\f[CB]jcmd\\ VM.cds\\f[R]\n@@ -5567,3 +5419,4 @@\n-A base archive is required when creating a dynamic archive.\n-If the base archive is not specified, the default CDS archive is used as\n-the base archive.\n+One common operation in all these methods is a \"trial run\", where you\n+run the application once to determine the classes that should be stored\n+in the archive.\n+.SS Creating a Static CDS Archive File with \\-Xshare:dump\n@@ -5571,43 +5424,2 @@\n-To create a dynamic CDS archive with the default CDS archive as the base\n-archive, just add the\n-\\f[CB]\\-XX:ArchiveClassesAtExit=<dynamic\\ archive>\\f[R] option to the\n-command line for running the Java application.\n-.PP\n-If the default CDS archive does not exist, the VM will exit with the\n-following error:\n-.IP\n-.nf\n-\\f[CB]\n-ArchiveClassesAtExit\\ not\\ supported\\ when\\ base\\ CDS\\ archive\\ is\\ not\\ loaded\n-\\f[R]\n-.fi\n-.PP\n-To run the Java application using a dynamic CDS archive, just add the\n-\\f[CB]\\-XX:SharedArchiveFile=<dynamic\\ archive>\\f[R] option to the command\n-line for running the Java application.\n-.PP\n-The base archive is not required to be specified in the command line.\n-The base archive information, including its name and full path, will be\n-retrieved from the dynamic archive header.\n-Note that the user could also use the \\f[CB]\\-XX:SharedArchiveFile\\f[R]\n-option for specifying a regular AppCDS archive.\n-Therefore, the specified archive in the \\f[CB]\\-XX:SharedArchiveFile\\f[R]\n-option could be either a regular or dynamic archive.\n-During VM start up the specified archive header will be read.\n-If \\f[CB]\\-XX:SharedArchiveFile\\f[R] refers to a regular archive, then the\n-behavior will be unchanged.\n-If \\f[CB]\\-XX:SharedArchiveFile\\f[R] refers to a dynamic archive, the VM\n-will retrieve the base archive location from the dynamic archive.\n-If the dynamic archive was created with the default CDS archive, then\n-the current default CDS archive will be used, and will be found relative\n-to the current run time environment.\n-.PP\n-Please refer to \\f[B]JDK\\-8221706\\f[R]\n-[https:\/\/bugs.openjdk.java.net\/browse\/JDK\\-8221706] for details on error\n-checking during dynamic CDS archive dump time and run time.\n-.SS Creating a Shared Archive File and Using It to Run an Application\n-.SS AppCDS archive\n-.PP\n-The following steps create a shared archive file that contains all the\n-classes used by the \\f[CB]test.Hello\\f[R] application.\n-The last step runs the application with the shared archive file.\n+The following steps create a static CDS archive file that contains all\n+the classes used by the \\f[CB]test.Hello\\f[R] application.\n@@ -5625,2 +5437,2 @@\n-Note that the classpath specified by the \\f[CB]\\-cp\\f[R] parameter must\n-contain only JAR files.\n+The classpath specified by the \\f[CB]\\-cp\\f[R] parameter must contain only\n+JAR files.\n@@ -5629,1 +5441,1 @@\n-Create a shared archive, named \\f[CB]hello.jsa\\f[R], that contains all the\n+Create a static archive, named \\f[CB]hello.jsa\\f[R], that contains all the\n@@ -5636,3 +5448,0 @@\n-.PP\n-Note that the classpath used at archive creation time must be the same\n-as (or a prefix of) the classpath used at run time.\n@@ -5641,1 +5450,1 @@\n-Run the application \\f[CB]test.Hello\\f[R] with the shared archive\n+Run the application \\f[CB]test.Hello\\f[R] with the archive\n@@ -5655,1 +5464,1 @@\n-\\f[CB]java\\ \\-XX:SharedArchiveFile=hello.jsa\\ \\-cp\\ hello.jar\\ \\-verbose:class\\ test.Hello\\f[R]\n+\\f[CB]java\\ \\-XX:SharedArchiveFile=hello.jsa\\ \\-cp\\ hello.jar\\ \\-Xlog:class+load\\ test.Hello\\f[R]\n@@ -5659,6 +5468,4 @@\n-.IP\n-.nf\n-\\f[CB]\n-Loaded\\ test.Hello\\ from\\ shared\\ objects\\ file\\ by\\ sun\/misc\/Launcher$AppClassLoader\n-\\f[R]\n-.fi\n+.RS\n+.PP\n+\\f[CB][info][class,load]\\ test.Hello\\ source:\\ shared\\ objects\\ file\\f[R]\n+.RE\n@@ -5666,1 +5473,8 @@\n-.SS Dynamic CDS archive\n+.SS Creating a Dynamic CDS Archive File with \\-XX:SharedArchiveFile\n+.PP\n+Advantages of dynamic CDS archives are:\n+.IP \\[bu] 2\n+They usually use less disk space, since they don\\[aq]t need to store the\n+classes that are already in the static archive.\n+.IP \\[bu] 2\n+They are created with one fewer step than the comparable static archive.\n@@ -5669,3 +5483,2 @@\n-classes used by the \\f[CB]test.Hello\\f[R] application and are not included\n-in the default CDS archive.\n-The second step runs the application with the dynamic CDS archive.\n+classes that are used by the \\f[CB]test.Hello\\f[R] application, excluding\n+those that are already in the default CDS archive.\n@@ -5681,3 +5494,0 @@\n-.PP\n-Note that the classpath used at archive creation time must be the same\n-as (or a prefix of) the classpath used at run time.\n@@ -5699,41 +5509,3 @@\n-To automate the above steps 1 and 2, one can write a script such as the\n-following:\n-.IP\n-.nf\n-\\f[CB]\n-\\ \\ \\ \\ ARCHIVE=hello.jsa\n-\\ \\ \\ \\ if\\ test\\ \\-f\\ $ARCHIVE;\\ then\n-\\ \\ \\ \\ \\ \\ \\ \\ FLAG=\"\\-XX:SharedArchiveFile=$ARCHIVE\"\n-\\ \\ \\ \\ else\n-\\ \\ \\ \\ \\ \\ \\ \\ FLAG=\"\\-XX:ArchiveClassesAtExit=$ARCHIVE\"\n-\\ \\ \\ \\ fi\n-\\ \\ \\ \\ $JAVA_HOME\/bin\/java\\ \\-cp\\ hello.jar\\ $FLAG\\ test.Hello\n-\\f[R]\n-.fi\n-.PP\n-Like an AppCDS archive, the archive needs to be re\\-generated if the\n-Java version has changed.\n-The above script could be adjusted to account for the Java version as\n-follows:\n-.IP\n-.nf\n-\\f[CB]\n-\\ \\ \\ \\ ARCHIVE=hello.jsa\n-\\ \\ \\ \\ VERSION=foo.version\n-\\ \\ \\ \\ if\\ test\\ \\-f\\ $ARCHIVE\\ \\-a\\ \\-f\\ $VERSION\\ &&\\ cmp\\ \\-s\\ $VERSION\\ $JAVA_HOME\/release;\\ then\n-\\ \\ \\ \\ \\ \\ \\ \\ FLAG=\"\\-XX:SharedArchiveFile=$ARCHIVE\"\n-\\ \\ \\ \\ else\n-\\ \\ \\ \\ \\ \\ \\ \\ FLAG=\"\\-XX:ArchiveClassesAtExit=$ARCHIVE\"\n-\\ \\ \\ \\ \\ \\ \\ \\ cp\\ \\-f\\ $JAVA_HOME\/release\\ $VERSION\n-\\ \\ \\ \\ fi\n-\\ \\ \\ \\ $JAVA_HOME\/bin\/java\\ \\-cp\\ hello.jar\\ $FLAG\\ test.Hello\n-\\f[R]\n-.fi\n-.PP\n-Currently, we don\\[aq]t support concurrent dumping operations to the\n-same CDS archive.\n-Care should be taken to avoid multiple writers to the same CDS archive.\n-.PP\n-The user could also create a dynamic CDS archive with a specific base\n-archive, e.g.\n-named as \\f[CB]base.jsa\\f[R] as follows:\n+It\\[aq]s also possible to create a dynamic CDS archive with a\n+non\\-default static CDS archive.\n+E.g.,\n@@ -5745,2 +5517,1 @@\n-To run the application using the dynamic CDS archive \\f[CB]hello.jsa\\f[R]\n-and a specific base CDS archive \\f[CB]base.jsa\\f[R]:\n+To run the application using this dynamic CDS archive:\n@@ -5752,21 +5523,2 @@\n-Note that on Windows, the above path delimiter \\f[CB]:\\f[R] should be\n-replaced with \\f[CB];\\f[R].\n-.PP\n-The above command for specifying a base archive is useful if the base\n-archive used for creating the dynamic archive has been moved.\n-Normally, just specifying the dynamic archive should be sufficient since\n-the base archive info can be retrieved from the dynamic archive header.\n-.SS Sharing a Shared Archive Across Multiple Application Processes\n-.PP\n-You can share the same archive file across multiple applications\n-processes.\n-This reduces memory usage because the archive is memory\\-mapped into the\n-address space of the processes.\n-The operating system automatically shares the read\\-only pages across\n-these processes.\n-.PP\n-The following steps demonstrate how to create a common archive that can\n-be shared by different applications.\n-Classes from \\f[CB]common.jar\\f[R], \\f[CB]hello.jar\\f[R] and \\f[CB]hi.jar\\f[R]\n-are archived in the \\f[CB]common.jsa\\f[R] because they are all in the\n-classpath during the archiving step (step 3).\n+(On Windows, the above path delimiter \\f[CB]:\\f[R] should be replaced with\n+\\f[CB];\\f[R])\n@@ -5774,7 +5526,1 @@\n-To include classes from \\f[CB]hello.jar\\f[R] and \\f[CB]hi.jar\\f[R], the\n-\\f[CB]\\&.jar\\f[R] files must be added to the classpath specified by the\n-\\f[CB]\\-cp\\f[R] parameter.\n-.IP \"1.\" 3\n-Create a list of all classes used by the \\f[CB]Hello\\f[R] application and\n-another list for the \\f[CB]Hi\\f[R] application:\n-.RS 4\n+As mention above, the name of the static archive can be skipped:\n@@ -5783,1 +5529,1 @@\n-\\f[CB]java\\ \\-XX:DumpLoadedClassList=hello.classlist\\ \\-cp\\ common.jar:hello.jar\\ Hello\\f[R]\n+\\f[CB]java\\ \\-XX:SharedArchiveFile=hello.jsa\\ \\-cp\\ hello.jar\\ Hello\\f[R]\n@@ -5785,1 +5531,1 @@\n-.RS\n+.SS Creating CDS Archive Files with jcmd\n@@ -5787,41 +5533,4 @@\n-\\f[CB]java\\ \\-XX:DumpLoadedClassList=hi.classlist\\ \\-cp\\ common.jar:hi.jar\\ Hi\\f[R]\n-.RE\n-.RE\n-.IP \"2.\" 3\n-Create a single list of classes used by all the applications that will\n-share the shared archive file.\n-.RS 4\n-.PP\n-\\f[B]Linux and macOS\\f[R] The following commands combine the files\n-\\f[CB]hello.classlist\\f[R] and \\f[CB]hi.classlist\\f[R] into one file,\n-\\f[CB]common.classlist\\f[R]:\n-.RS\n-.PP\n-\\f[CB]cat\\ hello.classlist\\ hi.classlist\\ >\\ common.classlist\\f[R]\n-.RE\n-.PP\n-\\f[B]Windows\\f[R] The following commands combine the files\n-\\f[CB]hello.classlist\\f[R] and \\f[CB]hi.classlist\\f[R] into one file,\n-\\f[CB]common.classlist\\f[R]:\n-.RS\n-.PP\n-\\f[CB]type\\ hello.classlist\\ hi.classlist\\ >\\ common.classlist\\f[R]\n-.RE\n-.RE\n-.IP \"3.\" 3\n-Create a shared archive named \\f[CB]common.jsa\\f[R] that contains all the\n-classes in \\f[CB]common.classlist\\f[R]:\n-.RS 4\n-.RS\n-.PP\n-\\f[CB]java\\ \\-Xshare:dump\\ \\-XX:SharedArchiveFile=common.jsa\\ \\-XX:SharedClassListFile=common.classlist\\ \\-cp\\ common.jar:hello.jar:hi.jar\\f[R]\n-.RE\n-.PP\n-The classpath parameter used is the common class path prefix shared by\n-the \\f[CB]Hello\\f[R] and \\f[CB]Hi\\f[R] applications.\n-.RE\n-.IP \"4.\" 3\n-Run the \\f[CB]Hello\\f[R] and \\f[CB]Hi\\f[R] applications with the same shared\n-archive:\n-.RS 4\n-.RS\n+The previous two sections require you to modify the application\\[aq]s\n+start\\-up script in order to create a CDS archive.\n+Sometimes this could be difficult, for example, if the application\\[aq]s\n+class path is set up by complex routines.\n@@ -5829,2 +5538,3 @@\n-\\f[CB]java\\ \\-XX:SharedArchiveFile=common.jsa\\ \\-cp\\ common.jar:hello.jar:hi.jar\\ Hello\\f[R]\n-.RE\n+The \\f[CB]jcmd\\ VM.cds\\f[R] command provides a less intrusive way for\n+creating a CDS archive by connecting to a running JVM process.\n+You can create either a static:\n@@ -5833,2 +5543,1 @@\n-\\f[CB]java\\ \\-XX:SharedArchiveFile=common.jsa\\ \\-cp\\ common.jar:hello.jar:hi.jar\\ Hi\\f[R]\n-.RE\n+\\f[CB]jcmd\\ <pid>\\ VM.cds\\ static_dump\\ my_static_archive.jsa\\f[R]\n@@ -5836,3 +5545,1 @@\n-.SS Specifying Additional Shared Data Added to an Archive File\n-The \\f[CB]SharedArchiveConfigFile\\f[R] option is used to specify\n-additional shared data to add to the archive file.\n+or a dynamic archive:\n@@ -5842,1 +5549,1 @@\n-\\f[CB]\\-XX:SharedArchiveConfigFile=\\f[R]\\f[I]shared_config_file\\f[R]\n+\\f[CB]jcmd\\ <pid>\\ VM.cds\\ dynamic_dump\\ my_dynamic_archive.jsa\\f[R]\n@@ -5845,28 +5552,3 @@\n-JDK 9 and later supports adding both symbols and string objects to an\n-archive for memory sharing when you have multiple JVM processes running\n-on the same host.\n-An example of this is having multiple JVM processes that use the same\n-set of Java EE classes.\n-When these common classes are loaded and used, new symbols and strings\n-may be created and added to the JVM\\[aq]s internal \"symbol\" and \"string\"\n-tables.\n-At runtime, the symbols or string objects mapped from the archive file\n-can be shared across multiple JVM processes, resulting in a reduction of\n-overall memory usage.\n-In addition, archiving strings also provides added performance benefits\n-in both startup time and runtime execution.\n-.PP\n-In JDK 10 and later, CONSTANT_String entries in archived classes are\n-resolved to interned String objects at dump time, and all interned\n-String objects are archived.\n-However, even though all CONSTANT_String literals in all archived\n-classes are resolved, it might still beneficial to add additional\n-strings that are not string literals in class files, but are likely to\n-be used by your application at run time.\n-.PP\n-Symbol data should be generated by the \\f[CB]jcmd\\f[R] tool attaching to a\n-running JVM process.\n-See \\f[B]jcmd\\f[R].\n-.PP\n-The following is an example of the symbol dumping command in\n-\\f[CB]jcmd\\f[R]:\n+To use the resulting archive file in a subsequent run of the application\n+without modifying the application\\[aq]s start\\-up script, you can use\n+the following technique:\n@@ -5875,1 +5557,1 @@\n-\\f[CB]jcmd\\f[R] \\f[I]pid\\f[R] \\f[CB]VM.symboltable\\ \\-verbose\\f[R]\n+\\f[CB]env\\ JAVA_TOOL_OPTIONS=\\-XX:SharedArchiveFile=my_static_archive.jsa\\ bash\\ app_start.sh\\f[R]\n@@ -5877,19 +5559,4 @@\n-.RS\n-\\f[B]Note:\\f[R] The first line (process ID) and the second line\n-(\\f[CB]\\@VERSION\\ ...\\f[R]) of this \\f[CB]jcmd\\f[R] output should be\n-excluded from the configuration file.\n-.RE\n-.SS Example of a Configuration File\n-.PP\n-The following is an example of a configuration file:\n-.IP\n-.nf\n-\\f[CB]\n-VERSION:\\ 1.0\n-\\@SECTION:\\ Symbol\n-10\\ \\-1:\\ linkMethod\n-\\f[R]\n-.fi\n-.PP\n-In the configuration file example, the \\f[CB]\\@SECTION:\\ Symbol\\f[R] entry\n-uses the following format:\n+Note: to use \\f[CB]jcmd\\ <pid>\\ VM.cds\\ dynamic_dump\\f[R], the JVM process\n+identified by \\f[CB]<pid>\\f[R] must be started with\n+\\f[CB]\\-XX:+RecordDynamicDumpInfo\\f[R], which can also be passed to the\n+application start\\-up script with the same technique:\n@@ -5899,1 +5566,1 @@\n-\\f[I]length\\f[R] \\f[I]refcount\\f[R]\\f[CB]:\\f[R] \\f[I]symbol\\f[R]\n+\\f[CB]env\\ JAVA_TOOL_OPTIONS=\\-XX:+RecordDynamicDumpInfo\\ bash\\ app_start.sh\\f[R]\n@@ -5901,10 +5568,22 @@\n-.PP\n-The \\f[I]refcount\\f[R] for a shared symbol is always \\f[CB]\\-1\\f[R].\n-.PP\n-\\f[CB]\\@SECTION\\f[R] specifies the type of the section that follows it.\n-All data within the section must be the same type that\\[aq]s specified\n-by \\f[CB]\\@SECTION\\f[R].\n-Different types of data can\\[aq]t be mixed.\n-Multiple separated data sections for the same type specified by\n-different \\f[CB]\\@SECTION\\f[R] are allowed within one\n-\\f[CB]shared_config_file\\f[R] .\n+.SS Restrictions on Class Path and Module Path\n+.IP \\[bu] 2\n+Neither the class path (\\f[CB]\\-classpath\\f[R] and\n+\\f[CB]\\-Xbootclasspath\/a\\f[R]) nor the module path\n+(\\f[CB]\\-\\-module\\-path\\f[R]) can contain non\\-empty directories.\n+.IP \\[bu] 2\n+Only modular JAR files are supported in \\f[CB]\\-\\-module\\-path\\f[R].\n+Exploded modules are not supported.\n+.IP \\[bu] 2\n+The class path used at archive creation time must be the same as (or a\n+prefix of) the class path used at run time.\n+(There\\[aq]s no such requirement for the module path.)\n+.IP \\[bu] 2\n+The CDS archive cannot be loaded if any JAR files in the class path or\n+module path are modified after the archive is generated.\n+.IP \\[bu] 2\n+If any of the VM options \\f[CB]\\-\\-upgrade\\-module\\-path\\f[R],\n+\\f[CB]\\-\\-patch\\-module\\f[R] or \\f[CB]\\-\\-limit\\-modules\\f[R] are specified,\n+CDS is disabled.\n+This means that the JVM will execute without loading any CDS archives.\n+In addition, if you try to create a CDS archive with any of these 3\n+options specified, the JVM will report an error.\n","filename":"src\/java.base\/share\/man\/java.1","additions":149,"deletions":470,"binary":false,"changes":619,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,0 +178,4 @@\n+    boolean canTransferToFromOverlappedMap() {\n+        return canTransferToFromOverlappedMap0();\n+    }\n+\n@@ -260,0 +264,2 @@\n+    static native boolean canTransferToFromOverlappedMap0();\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -362,0 +362,10 @@\n+JNIEXPORT jboolean JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_canTransferToFromOverlappedMap0(JNIEnv *env, jclass clazz)\n+{\n+#ifdef MACOSX\n+    return JNI_FALSE;\n+#else\n+    return JNI_TRUE;\n+#endif\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+        private final Platform platform;\n@@ -90,1 +91,1 @@\n-        DefaultExecutableImage(Path home, Set<String> modules) {\n+        DefaultExecutableImage(Path home, Set<String> modules, Platform p) {\n@@ -98,0 +99,1 @@\n+            this.platform = p;\n@@ -130,0 +132,5 @@\n+\n+        @Override\n+        public Platform getTargetPlatform() {\n+            return platform;\n+        }\n@@ -136,1 +143,1 @@\n-    private Platform targetPlatform;\n+    private Platform platform;\n@@ -151,0 +158,5 @@\n+    @Override\n+    public Platform getTargetPlatform() {\n+        return platform;\n+    }\n+\n@@ -161,1 +173,1 @@\n-            this.targetPlatform = Platform.toPlatform(value);\n+            this.platform = Platform.parsePlatform(value);\n@@ -481,1 +493,1 @@\n-        return targetPlatform == Platform.WINDOWS;\n+        return platform.os() == Platform.OperatingSystem.WINDOWS;\n@@ -516,1 +528,1 @@\n-        return new DefaultExecutableImage(root, modules);\n+        return new DefaultExecutableImage(root, modules, platform);\n@@ -558,1 +570,4 @@\n-            return new DefaultExecutableImage(root, retrieveModules(root));\n+            \/\/ It may be possible to extract the platform info from the given image.\n+            \/\/ --post-process-path is a hidden option and pass unknown platform for now.\n+            \/\/ --generate-cds-archive plugin cannot be used with --post-process-path option.\n+            return new DefaultExecutableImage(root, retrieveModules(root), Platform.UNKNOWN);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -570,1 +570,2 @@\n-            SctpNet.preClose(fdVal);\n+            if (state != ChannelState.KILLED)\n+                SctpNet.preClose(fdVal);\n@@ -668,0 +669,1 @@\n+                SctpNet.close(fdVal);\n@@ -675,1 +677,1 @@\n-                SctpNet.close(fdVal);\n+                SctpNet.close(fdVal);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -329,1 +329,2 @@\n-            SctpNet.preClose(fdVal);\n+            if (state != ChannelState.KILLED)\n+                SctpNet.preClose(fdVal);\n@@ -413,0 +414,1 @@\n+                SctpNet.close(fdVal);\n@@ -419,1 +421,1 @@\n-                SctpNet.close(fdVal);\n+                SctpNet.close(fdVal);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -292,1 +292,2 @@\n-            SctpNet.preClose(fdVal);\n+            if (state != ChannelState.KILLED)\n+                SctpNet.preClose(fdVal);\n@@ -307,0 +308,1 @@\n+                SctpNet.close(fdVal);\n@@ -313,1 +315,1 @@\n-                SctpNet.close(fdVal);\n+                SctpNet.close(fdVal);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,5 @@\n+        \/\/ Ubuntu 22.04 ppc started to crash in libz inflateReset on Power8 based host\n+        \/\/ those recent Ubuntu versions only work on Power9+\n+        if (Platform.isPPC()) {\n+            return \"20.04\";\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}