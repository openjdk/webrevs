{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk-updates\n+project=crac\n@@ -4,1 +4,0 @@\n-version=17.0.12\n@@ -7,1 +6,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=whitespace\n@@ -9,3 +8,3 @@\n-[repository]\n-tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n-branches=\n+[checks \"reviewers\"]\n+committers=1\n+ignore=duke\n@@ -16,20 +15,0 @@\n-\n-[checks \"whitespace\"]\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n-ignore-tabs=.*\\.gmk|Makefile\n-\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n-[checks \"committer\"]\n-role=committer\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":5,"deletions":26,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# Welcome to the JDK!\n+# CRaC JDK\n@@ -3,3 +3,1 @@\n-For build instructions please see the\n-[online documentation](https:\/\/openjdk.java.net\/groups\/build\/doc\/building.html),\n-or either of these files:\n+## Build\n@@ -7,2 +5,1 @@\n-- [doc\/building.html](doc\/building.html) (html version)\n-- [doc\/building.md](doc\/building.md) (markdown version)\n+CRaC JDK have extended build procedure.\n@@ -10,2 +7,16 @@\n-See <https:\/\/openjdk.java.net\/> for more information about\n-the OpenJDK Community and the JDK.\n+1. Build JDK as usual\n+```\n+bash configure\n+make images\n+mv build\/linux-x86_64-server-release\/images\/jdk\/ .\n+```\n+2. Download a build of [modified CRIU](https:\/\/github.com\/org-crac\/criu\/releases\/tag\/release-crac)\n+3. Extract and copy `criu` binary over a same named file in the JDK\n+```\n+cp criu-dist\/sbin\/criu jdk\/lib\/criu\n+```\n+Grant permissions to allow regular user to run it\n+```\n+sudo chown root:root jdk\/lib\/criu\n+sudo chmod u+s jdk\/lib\/criu\n+```\n","filename":"README.md","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -227,0 +227,4 @@\n+$(eval $(call SetupBuildDemo, JavaCompilerCRaC, \\\n+    DEMO_SUBDIR := crac, \\\n+))\n+\n","filename":"make\/CompileDemos.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+    -tag crac:cmopt:'CRaC:' \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    cpu_feature_active ld_so_list_diagnostics \\\n@@ -396,0 +397,136 @@\n+###############################################################################\n+# Check if glibc CPU_FEATURE_ACTIVE is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(cpu_feature_active, [\n+    AC_MSG_CHECKING([if glibc CPU_FEATURE_ACTIVE is supported])\n+    AC_COMPILE_IFELSE(\n+      [AC_LANG_PROGRAM([[#include <sys\/platform\/x86.h>]],\n+        [[int x = CPU_FEATURE_ACTIVE(SSE2);]])\n+      ],\n+      [\n+        AC_MSG_RESULT([yes])\n+      ],\n+      [\n+        AC_MSG_RESULT([no])\n+        AVAILABLE=false\n+      ]\n+    )\n+  ])\n+])\n+\n+###############################################################################\n+# Check if glibc ld.so --list-diagnostics is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_LD_SO_LIST_DIAGNOSTICS],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(ld_so_list_diagnostics, [\n+    AC_MSG_CHECKING([if glibc ld.so --list-diagnostics is supported])\n+    AC_RUN_IFELSE(\n+      [AC_LANG_SOURCE([[\n+#define _GNU_SOURCE 1\n+#include <link.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <string.h>\n+#include <limits.h>\n+static int ld_so_name_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data_voidp) {\n+  const char **retval_return = (const char **)data_voidp;\n+  if (size < offsetof(struct dl_phdr_info, dlpi_adds)) {\n+    fputs(\"missing PHDRs\\n\", stderr);\n+    exit(1);\n+  }\n+  if (strcmp(info->dlpi_name, \"\") != 0) {\n+    fprintf(stderr, \"Unexpected name of first dl_phdr_info: %s\\n\", info->dlpi_name);\n+    exit(1);\n+  }\n+  for (size_t phdr_ix = 0; phdr_ix < info->dlpi_phnum; ++phdr_ix) {\n+    const Elf64_Phdr *phdr = info->dlpi_phdr + phdr_ix;\n+    if (phdr->p_type == PT_INTERP) {\n+      *retval_return = (const char *)(phdr->p_vaddr + info->dlpi_addr);\n+      return 42;\n+    }\n+  }\n+  exit(1);\n+}\n+static const char *ld_so_name() {\n+  const char *retval;\n+  int err = dl_iterate_phdr(ld_so_name_iterate_phdr, &retval);\n+  if (err != 42)\n+    exit(1);\n+  return retval;\n+}\n+int main(void) {\n+  char cmd[PATH_MAX + 100];\n+  int got = snprintf(cmd, sizeof(cmd), \"%s --list-diagnostics\", ld_so_name());\n+  if (got < 0) {\n+    fprintf(stderr, \"snprintf error: %m\\n\");\n+  }\n+  if ((unsigned) got == sizeof(cmd)) {\n+    fputs(\"internal error - buffer overflow\\n\", stderr);\n+    exit(1);\n+  }\n+  FILE *f = popen(cmd, \"r\");\n+  if (!f) {\n+    fprintf(stderr, \"popen('%s'): %m\\n\", cmd);\n+    exit(1);\n+  }\n+  char line[LINE_MAX];\n+  int found = 0;\n+  const char prefix[] = \"x86.cpu_features.features\";\n+  for (;;) {\n+    char *s = fgets(line, sizeof(line), f);\n+    if (!s) break;\n+    if (s != line) {\n+      fprintf(stderr, \"fgets(popen('%s')) did not return buffer address\\n\", cmd);\n+      exit(1);\n+    }\n+    if (strstr(line, prefix))\n+      found = 1;\n+  }\n+  if (ferror(f)) {\n+    fprintf(stderr, \"ferror(popen('%s'))\\n\", cmd);\n+    exit(1);\n+  }\n+  if (!feof(f)) {\n+    fprintf(stderr, \"!feof(popen('%s'))\\n\", cmd);\n+    exit(1);\n+  }\n+  int wstatus = pclose(f);\n+  if (wstatus == -1) {\n+    fprintf(stderr, \"pclose('%s'): %m\\n\", cmd);\n+    exit(1);\n+  }\n+  if (!WIFEXITED(wstatus)) {\n+    fprintf(stderr, \"Child command '%s' did not properly exit (WIFEXITED): wstatus = %d\\n\", cmd, wstatus);\n+    exit(1);\n+  }\n+  if (WEXITSTATUS(wstatus) != 0) {\n+    fprintf(stderr, \"Child command '%s' did exit with an error: exit code = %d\\n\", cmd, WEXITSTATUS(wstatus));\n+    exit(1);\n+  }\n+  if (!found) {\n+    fprintf(stderr, \"Not found in '%s' output: %s\\n\", cmd, prefix);\n+    exit(1);\n+  }\n+  return 0;\n+}\n+\t]])\n+      ],\n+      [\n+        AC_MSG_RESULT([yes])\n+      ],\n+      [\n+        AC_MSG_RESULT([no])\n+        AVAILABLE=false\n+      ],\n+      [\n+        AC_MSG_RESULT([assumed no - cross compiling])\n+        AVAILABLE=false\n+      ]\n+    )\n+  ])\n+])\n+\n@@ -413,0 +550,2 @@\n+  JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE\n+  JVM_FEATURES_CHECK_LD_SO_LIST_DIAGNOSTICS\n","filename":"make\/autoconf\/jvm-features.m4","additions":139,"deletions":0,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+LINUX_X64_CRIU_FILENAME=criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_URL=https:\/\/github.com\/CRaC\/criu\/releases\/download\/release-1.3\/criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_SHA256=82a014bf342c957305b98a71867c0994ebf6e7379f01f083121884793768d966\n+\n","filename":"make\/conf\/github-actions.conf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+JVM_Checkpoint\n","filename":"make\/data\/hotspot-symbols\/symbols-shared","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -157,0 +157,7 @@\n+ifneq ($(call check-jvm-feature, cpu_feature_active), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_CPU_FEATURE_ACTIVE=0\n+endif\n+ifneq ($(call check-jvm-feature, ld_so_list_diagnostics), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_LD_SO_LIST_DIAGNOSTICS=0\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -91,0 +91,48 @@\n+\n+ifeq ($(OPENJDK_TARGET_OS), linux)\n+  $(eval $(call SetupJdkExecutable, BUILD_CRIUENGINE, \\\n+      NAME := criuengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criuengine, \\\n+      INCLUDE_FILES := criuengine.cpp, \\\n+      OPTIMIZATION := HIGH, \\\n+      CXXFLAGS := $(CXXFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      LD := $(LDCXX), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_CRIUENGINE)\n+\n+endif\n+\n+ifeq ($(call isTargetOs, macosx linux windows), true)\n+  ifeq ($(OPENJDK_TARGET_OS), windows)\n+    CRAC_ENGINE_DIR = modules_cmds\n+  else\n+    CRAC_ENGINE_DIR = modules_libs\n+  endif\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n+      NAME := pauseengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/pauseengine, \\\n+      INCLUDE_FILES := pauseengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_PAUSEENGINE)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_SIMENGINE, \\\n+      NAME := simengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/simengine, \\\n+      INCLUDE_FILES := simengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_SIMENGINE)\n+\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,5 @@\n+public class Compile {\n+    public static void main(String... args) throws Exception {\n+        JavaCompilerCRaC.runJavac(args);\n+    }\n+}\n","filename":"src\/demo\/share\/crac\/JavaCompilerCRaC\/Compile.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+import java.util.Arrays;\n+import jdk.crac.Core;\n+\n+public class JavaCompilerCRaC {\n+\n+    static void runJavac(String... args) {\n+        System.out.println(\"javac \" + String.join(\" \", args));\n+        int status = com.sun.tools.javac.Main.compile(args);\n+        if (status != 0) {\n+            System.exit(status);\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        int startIdx = 0;\n+        for (int endIdx = 1; endIdx < args.length; ++endIdx) {\n+            if (args[endIdx].equals(\"--\")) {\n+                runJavac(Arrays.copyOfRange(args, startIdx, endIdx));\n+                startIdx = endIdx + 1;\n+            }\n+        }\n+\n+        if (startIdx < args.length) {\n+            runJavac(Arrays.copyOfRange(args, startIdx, args.length));\n+        }\n+\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"src\/demo\/share\/crac\/JavaCompilerCRaC\/JavaCompilerCRaC.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -67,0 +67,2 @@\n+  static void crac_restore() {}\n+\n@@ -168,0 +170,3 @@\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  static void crac_restore() {}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  static void crac_restore() {}\n@@ -132,0 +133,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -385,0 +385,1 @@\n+  static void crac_restore() {}\n@@ -536,0 +537,3 @@\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -223,1 +223,13 @@\n-             \"mitigations for the Intel JCC erratum\")\n+             \"mitigations for the Intel JCC erratum\")                       \\\n+                                                                            \\\n+  product(ccstr, CPUFeatures, NULL, \"CPU feature set, \"                     \\\n+      \"use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when you \"    \\\n+      \"get an error during -XX:CRaCRestoreFrom on a different machine; \"    \\\n+      \"-XX:CPUFeatures=native is the default; \"                             \\\n+      \"-XX:CPUFeatures=generic is compatible but not as slow as 0\")         \\\n+                                                                            \\\n+  product(bool, ShowCPUFeatures, false, \"Show features of this CPU \"        \\\n+      \"to be possibly used for the -XX:CPUFeatures=0xnumber option\")        \\\n+                                                                            \\\n+  product(bool, CRaCCPUCountInit, false, \"Reinitialize number of CPUs \"     \\\n+      \"during -XX:CRaCRestoreFrom\")\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -40,0 +41,7 @@\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# include <sys\/platform\/x86.h>\n+#endif\n+#if INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+# include <link.h>\n+# include <sys\/wait.h>\n+#endif\n@@ -48,0 +56,1 @@\n+uint64_t VM_Version::_glibc_features;\n@@ -50,1 +59,2 @@\n-const char* VM_Version::_features_names[] = { CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::      _features_names[] = {   CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::_glibc_features_names[] = { GLIBC_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n@@ -618,1 +628,49 @@\n-void VM_Version::get_processor_features() {\n+uint64_t VM_Version::CPUFeatures_parse(uint64_t &glibc_features) {\n+  glibc_features = _glibc_features;\n+#ifndef LINUX\n+  ignore_glibc_not_using = true;\n+  return _features;\n+#endif\n+  if (CPUFeatures == NULL || strcmp(CPUFeatures, \"native\") == 0) {\n+    return _features;\n+  }\n+  if (strcmp(CPUFeatures, \"ignore\") == 0) {\n+    ignore_glibc_not_using = true;\n+    return _features;\n+  }\n+  glibc_features = 0;\n+  if (strcmp(CPUFeatures, \"generic\") == 0) {\n+    \/\/ 32-bit x86 cannot rely on anything.\n+    return 0\n+#ifdef AMD64\n+      \/\/ The following options are all in \/proc\/cpuinfo of one of the first 64-bit CPUs - Atom D2700 (and Opteron 1352): https:\/\/superuser.com\/q\/1572306\/1015048\n+      | CPU_SSE \/\/ enabled in 'gcc -Q --help=target', used by OpenJDK\n+      | CPU_SSE2 \/\/ enabled in 'gcc -Q --help=target', required by OpenJDK\n+      | CPU_FXSR \/\/ enabled in 'gcc -Q --help=target', not used by OpenJDK\n+      | CPU_MMX \/\/ enabled in 'gcc -Q --help=target', used only by 32-bit x86 OpenJDK\n+      | CPU_TSC \/\/ not used by gcc, used by OpenJDK\n+      | CPU_CX8 \/\/ gcc detects it to set cpu \"pentium\" (=32-bit only), used by OpenJDK\n+      | CPU_CMOV \/\/ gcc detects it to set cpu \"pentiumpro\" (=32-bit only), used by OpenJDK\n+      | CPU_FLUSH \/\/ =\"clflush\" in cpuinfo, not used by gcc, required by OpenJDK\n+      \/\/ GLIBC_MOVBE is disabled in 'gcc -Q --help=target' and some CPUs do not support it: https:\/\/stackoverflow.com\/a\/5246553\/2995591\n+      \/\/ GLIBC_LAHFSAHF is disabled in 'gcc -Q --help=target' and \"Early Intel Pentium 4 CPUs with Intel 64 support ... lacked the LAHF and SAHF instructions\"\n+#endif\n+    ;\n+  }\n+  char *endptr;\n+  errno = 0;\n+  uint64_t retval;\n+  unsigned long long ull = strtoull(CPUFeatures, &endptr, 0);\n+  retval = ull;\n+  if (!errno && *endptr == ',' && retval == ull) {\n+    ull = strtoull(endptr + 1, &endptr, 0);\n+    glibc_features = ull;\n+    if (!errno && !*endptr && glibc_features == ull) {\n+      return retval;\n+    }\n+  }\n+  vm_exit_during_initialization(err_msg(\"VM option 'CPUFeatures=%s' must be of the form: 0xnum,0xnum\", CPUFeatures));\n+  return -1;\n+}\n+\n+#if INCLUDE_LD_SO_LIST_DIAGNOSTICS\n@@ -620,0 +678,536 @@\n+static int ld_so_name_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data_voidp) {\n+  const char **retval_return = (const char **)data_voidp;\n+  assert(size >= offsetof(struct dl_phdr_info, dlpi_adds), \"missing PHDRs for the java executable\");\n+  if (strcmp(info->dlpi_name, \"\") != 0)\n+    vm_exit_during_initialization(err_msg(\"Unexpected name of first dl_phdr_info: %s\", info->dlpi_name));\n+  for (size_t phdr_ix = 0; phdr_ix < info->dlpi_phnum; ++phdr_ix) {\n+    const Elf64_Phdr *phdr = info->dlpi_phdr + phdr_ix;\n+    if (phdr->p_type == PT_INTERP) {\n+      *retval_return = (const char *)(phdr->p_vaddr + info->dlpi_addr);\n+      return 42;\n+    }\n+  }\n+  vm_exit_during_initialization(\"PT_INTERP not found for the java executable\");\n+  return -1;\n+}\n+\n+static const char *ld_so_name() {\n+  const char *retval;\n+  int err = dl_iterate_phdr(ld_so_name_iterate_phdr, &retval);\n+  assert(err == 42, \"internal error 42\");\n+  return retval;\n+}\n+\n+#define ARG1 \"--list-diagnostics\"\n+\n+static FILE *popen_r(const char *arg0, pid_t *pid_return) {\n+  union {\n+    int fds[2];\n+    struct {\n+      int readfd, writefd;\n+    };\n+  } fds;\n+  if (pipe(fds.fds))\n+    vm_exit_during_initialization(err_msg(\"Error creating pipe: %m\"));\n+  pid_t child = fork();\n+  switch (child) {\n+    case -1:\n+      vm_exit_during_initialization(err_msg(\"Error fork-ing: %m\"));\n+    case 0:\n+      if (close(fds.readfd))\n+        vm_exit_during_initialization(err_msgt(\"Error closing read pipe in child: %m\"));\n+      }\n+      if (dup2(fds.writefd, STDOUT_FILENO) != STDOUT_FILENO)\n+        vm_exit_during_initialization(err_msg(\"Error closing preparing write pipe in child: %m\"));\n+      if (close(fds.writefd))\n+        vm_exit_during_initialization(err_msg(\"Error closing write pipe in child: %m\"));\n+      execl(arg0, arg0, ARG1, NULL);\n+      \/\/ FIXME: Double vm_exit*()?\n+      vm_exit_during_initialization(err_msg(\"Error exec-ing %s \" ARG1 \": %m\", arg0));\n+  }\n+  if (close(fds.writefd))\n+    vm_exit_during_initialization(err_msg(\"Error closing write pipe in parent: %m\"));\n+  FILE *f = fdopen(fds.readfd, \"r\");\n+  if (f == NULL)\n+    vm_exit_during_initialization(err_msg(\"Error converting pipe fd to FILE * in parent for %s \" ARG1 \": %m\", arg0));\n+  *pid_return = child;\n+  return f;\n+}\n+\n+static void pclose_r(const char *arg0, FILE *f, pid_t pid) {\n+  if (fclose(f))\n+    vm_exit_during_initialization(err_msg(\"Error closing fdopen-ed %s \" ARG1 \": %m\", arg0));\n+  int wstatus;\n+  pid_t waiterr = waitpid(pid, &wstatus, 0);\n+  if (waiterr != pid)\n+    vm_exit_during_initialization(err_msg(\"Error waiting on %s \" ARG1 \": %m\", arg0));\n+  if (!WIFEXITED(wstatus))\n+    vm_exit_during_initialization(err_msg(\"Child command %s \" ARG1 \" did not properly exit (WIFEXITED): wstatus = %d\", arg0, wstatus));\n+  if (WEXITSTATUS(wstatus) != 0)\n+    vm_exit_during_initialization(err_msg(\"Child command %s \" ARG1 \" did exit with an error: exit code = %d\", arg0, WEXITSTATUS(wstatus)));\n+}\n+\n+#endif \/\/ !INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+\n+bool VM_Version::ignore_glibc_not_using = false;\n+#ifdef LINUX\n+const char VM_Version::glibc_prefix[] = \":glibc.cpu.hwcaps=\";\n+const size_t VM_Version::glibc_prefix_len = strlen(glibc_prefix);\n+\n+bool VM_Version::glibc_env_set(char *disable_str) {\n+#define TUNABLES_NAME \"GLIBC_TUNABLES\"\n+  char *env_val = disable_str;\n+  const char *env = getenv(TUNABLES_NAME);\n+  if (env && strcmp(env, env_val) == 0) {\n+#if !INCLUDE_CPU_FEATURE_ACTIVE && !INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Environment variable already set, both glibc CPU_FEATURE_ACTIVE and ld.so --list-diagnostics are unavailable - re-exec suppressed: \" TUNABLES_NAME \"=%s\", env);\n+    }\n+    return true;\n+#endif\n+  }\n+  char env_buf[strlen(disable_str) + (!env ? 0 : strlen(env) + 100)];\n+  if (env) {\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+    }\n+    const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n+    if (!hwcaps) {\n+      strcpy(env_buf, env);\n+      strcat(env_buf, disable_str);\n+    } else {\n+      const char *colon = strchr(hwcaps, ':');\n+      if (!colon) {\n+        strcpy(env_buf, env);\n+        strcat(env_buf, disable_str + glibc_prefix_len);\n+      } else {\n+        int err = jio_snprintf(env_buf, sizeof(env_buf), \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n+        assert(err >= 0 && (unsigned)err < sizeof(env_buf), \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+      }\n+    }\n+    env_val = env_buf;\n+  }\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+  }\n+  int err = setenv(TUNABLES_NAME, env_val, 1);\n+  if (err)\n+    vm_exit_during_initialization(err_msg(\"setenv \" TUNABLES_NAME \" error: %m\"));\n+\n+#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n+  if (getenv(REEXEC_NAME))\n+    vm_exit_during_initialization(err_msg(\"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str));\n+  if (setenv(REEXEC_NAME, \"1\", 1))\n+    vm_exit_during_initialization(err_msg(\"setenv \" REEXEC_NAME \" error: %m\"));\n+#undef REEXEC_NAME\n+#undef TUNABLES_NAME\n+  return false;\n+}\n+\n+void VM_Version::glibc_reexec() {\n+  char *buf = NULL;\n+  size_t buf_allocated = 0;\n+  size_t buf_used = 0;\n+#define CMDLINE \"\/proc\/self\/cmdline\"\n+  int fd = open(CMDLINE, O_RDONLY);\n+  if (fd == -1)\n+    vm_exit_during_initialization(err_msg(\"Cannot open \" CMDLINE \": %m\"));\n+  ssize_t got;\n+  do {\n+    if (buf_used == buf_allocated) {\n+      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n+      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n+      if (buf == NULL)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu bytes\", buf_allocated));\n+    }\n+    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n+    if (got == -1)\n+      vm_exit_during_initialization(err_msg(\"Cannot read \" CMDLINE \": %m\"));\n+    buf_used += got;\n+  } while (got);\n+  if (close(fd))\n+    vm_exit_during_initialization(err_msg(\"Cannot close \" CMDLINE \": %m\"));\n+  char **argv = NULL;\n+  size_t argv_allocated = 0;\n+  size_t argv_used = 0;\n+  char *s = buf;\n+  while (s <= buf + buf_used) {\n+    if (argv_used == argv_allocated) {\n+      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n+      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n+      if (argv == NULL)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu pointers\", argv_allocated));\n+    }\n+    if (s == buf + buf_used) {\n+      break;\n+    }\n+    argv[argv_used++] = s;\n+    s += strnlen(s, buf + buf_used - s);\n+    if (s == buf + buf_used)\n+      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n+    ++s;\n+  }\n+  argv[argv_used] = NULL;\n+#undef CMDLINE\n+\n+#define EXEC \"\/proc\/self\/exe\"\n+  execv(EXEC, argv);\n+  vm_exit_during_initialization(err_msg(\"Cannot re-execute \" EXEC \": %m\"));\n+#undef EXEC\n+}\n+\n+void VM_Version::glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC) {\n+#ifndef ASSERT\n+  if (!excessive_CPU && !excessive_GLIBC)\n+    return;\n+#endif\n+#if INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+  \/\/ sysdeps\/x86\/include\/cpu-features.h CPUID_INDEX_14_ECX_0 == 8\n+  const int CPUID_INDEX_CEIL = 8;\n+  \/\/ \/usr\/include\/bits\/platform\/x86.h\n+  enum\n+  {\n+    CPUID_INDEX_1 = 0,\n+    CPUID_INDEX_7,\n+    CPUID_INDEX_80000001,\n+    CPUID_INDEX_D_ECX_1,\n+    CPUID_INDEX_80000007,\n+    CPUID_INDEX_80000008,\n+    CPUID_INDEX_7_ECX_1,\n+    CPUID_INDEX_19,\n+    CPUID_INDEX_14_ECX_0\n+  };\n+  const int index_max = CPUID_INDEX_CEIL + 1;\n+  enum { eax = 0, ebx, ecx, edx, reg_max };\n+  unsigned active[index_max][reg_max] = { 0 };\n+  const char *arg0 = ld_so_name();\n+  pid_t f_child;\n+  FILE *f = popen_r(arg0, &f_child);\n+  if (!f)\n+    vm_exit_during_initialization(err_msg(\"Cannot popen %s \" ARG1 \": %m\", arg0));\n+  for (;;) {\n+    char line[LINE_MAX];\n+    char *s = fgets(line, sizeof(line), f);\n+    if (!s)\n+      break;\n+    s = line;\n+    \/\/ x86.cpu_features.features[0x0].active[0x2]=0x7ed83203\n+    const char prefix[] = \"x86.cpu_features.features[\";\n+    if (strncmp(s, prefix, sizeof(prefix) - 1) != 0)\n+      continue;\n+    s += sizeof(prefix) - 1;\n+    unsigned long index = strtoul(s, &s, 0);\n+    if (index >= index_max)\n+      continue;\n+    const char mid[] = \"].active[\";\n+    if (strncmp(s, mid, sizeof(mid) - 1) != 0)\n+      continue;\n+    s += sizeof(mid) - 1;\n+    unsigned long reg = strtoul(s, &s, 0);\n+    if (reg >= reg_max)\n+      continue;\n+    if (s[0] != ']' || s[1] != '=')\n+      continue;\n+    s += 2;\n+    unsigned long val = strtoul(s, &s, 0);\n+    if (val > UINT_MAX)\n+      continue;\n+    if (s[0] != '\\n' || s[1] != 0)\n+      continue;\n+    active[index][reg] = val;\n+  }\n+  if (ferror(f))\n+    vm_exit_during_initialization(err_msg(\"Error reading popen-ed %s \" ARG1 \": %m\", arg0));\n+  if (!feof(f))\n+    vm_exit_during_initialization(err_msg(\"EOF not reached on popen-ed %s \" ARG1, arg0));\n+  pclose_r(arg0, f, f_child);\n+#undef ARG1\n+#endif \/\/ INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+\n+  \/\/ glibc: sysdeps\/x86\/get-isa-level.h:\n+  \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMOV)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, CX8)\n+  \/\/ glibc:     && CPU_FEATURE_CPU_P (cpu_features, FPU)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FXSR)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MMX)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE2))\n+  \/\/ glibc:     isa_level = GNU_PROPERTY_X86_ISA_1_BASELINE;\n+  if ((_features & CPU_CMOV) &&\n+      (_features & CPU_CX8) &&\n+      \/\/ FPU is always present on i686+: (_features & CPU_FPU) &&\n+      (_features & CPU_SSE2)) {\n+    \/\/ These cannot be disabled by GLIBC_TUNABLES.\n+    if (excessive_CPU & (CPU_FXSR | CPU_MMX | CPU_SSE)) {\n+      assert(!(excessive_CPU & CPU_SSE2), \"CPU_SSE2 in both _features and excessive_CPU cannot happen\");\n+      \/\/ FIXME: The choice should be based on glibc impact, not the feature age.\n+      \/\/ CX8 is i586+, CMOV is i686+ 1995+, SSE2 is 2000+\n+      excessive_CPU |= CPU_SSE2;\n+    }\n+    if ((_features & CPU_FXSR) &&\n+        (_features & CPU_MMX) &&\n+        (_features & CPU_SSE)) {\n+      \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMPXCHG16B)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LAHF64_SAHF64)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, POPCNT)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_1)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_2))\n+      \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V2;\n+      if ((_features & CPU_POPCNT) &&\n+          (_features & CPU_SSSE3) &&\n+          (_features & CPU_SSE4_1) &&\n+          (_features & CPU_SSE4_2)) {\n+        if ((excessive_CPU & CPU_SSE3) ||\n+            (excessive_GLIBC & (GLIBC_CMPXCHG16 | GLIBC_LAHFSAHF))) {\n+          assert(!(excessive_CPU & CPU_SSE4_2), \"CPU_SSE4_2 in both _features and excessive_CPU cannot happen\");\n+          \/\/ POPCNT is 2007+, SSSE3 is 2006+, SSE4_1 is 2007+, SSE4_2 is 2008+.\n+          excessive_CPU |= CPU_SSE4_2;\n+        }\n+        if ((_features & CPU_SSE3) &&\n+            (_glibc_features & GLIBC_CMPXCHG16) &&\n+            (_glibc_features & GLIBC_LAHFSAHF)) {\n+          \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI1)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, F16C)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FMA)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LZCNT)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MOVBE))\n+          \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V3;\n+          if ((_features & CPU_AVX) &&\n+              (_features & CPU_AVX2) &&\n+              (_features & CPU_BMI1) &&\n+              (_features & CPU_BMI2) &&\n+              (_features & CPU_FMA) &&\n+              (_features & CPU_LZCNT) &&\n+              (_glibc_features & GLIBC_MOVBE)) {\n+            if (excessive_GLIBC & GLIBC_F16C) {\n+              assert(!(excessive_GLIBC & GLIBC_MOVBE), \"GLIBC_MOVBE in both _glibc_features and excessive_GLIBC cannot happen\");\n+              \/\/ FMA is 2012+, AVX2+BMI1+BMI2+LZCNT are 2013+, MOVBE is 2015+\n+              excessive_GLIBC |= GLIBC_MOVBE;\n+            }\n+            if (_glibc_features & GLIBC_F16C) {\n+              \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX512F)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512BW)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512CD)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512DQ)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512VL))\n+              \/\/ glibc:   isa_level |= GNU_PROPERTY_X86_ISA_1_V4;\n+              \/\/ All these flags are supported by GLIBC_DISABLE below.\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  uint64_t disable_CPU   = 0;\n+  uint64_t disable_GLIBC = 0;\n+#define PASTE_TOKENS3(x, y, z) PASTE_TOKENS(x, PASTE_TOKENS(y, z))\n+#ifdef ASSERT\n+  uint64_t excessive_handled_CPU   = 0;\n+  uint64_t excessive_handled_GLIBC = 0;\n+  uint64_t disable_handled_CPU   = 0;\n+  uint64_t disable_handled_GLIBC = 0;\n+#endif\n+#define EXCESSIVE_HANDLED(kind, hotspot) do {                                                                                         \\\n+    assert(!(PASTE_TOKENS(excessive_handled_, kind) & PASTE_TOKENS3(kind, _, hotspot)), \"already used \" STR(kind) \"_\" STR(hotspot) ); \\\n+    DEBUG_ONLY(PASTE_TOKENS(excessive_handled_, kind) |= PASTE_TOKENS3(kind, _, hotspot));                                            \\\n+  } while (0)\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# define FEATURE_ACTIVE(glibc, hotspot_field, hotspot_union, glibc_index, glibc_reg) CPU_FEATURE_ACTIVE(glibc)\n+#elif INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+# define FEATURE_ACTIVE(glibc, hotspot_field, hotspot_union, glibc_index, glibc_reg) ({ \\\n+    hotspot_union u;                                                                    \\\n+    u.value = active[glibc_index][glibc_reg];                                           \\\n+    u.bits.hotspot_field != 0;                                                          \\\n+  })\n+#else\n+# define FEATURE_ACTIVE(glibc, hotspot_field, hotspot_union, glibc_index, glibc_reg) true\n+#endif\n+#define EXCESSIVE6(kind, hotspotglibc, hotspot_field, hotspot_union, glibc_index, glibc_reg) do {                                                                      \\\n+    EXCESSIVE_HANDLED(kind, hotspotglibc);                                                                                                                             \\\n+    if (PASTE_TOKENS(excessive_, kind) & PASTE_TOKENS3(kind, _, hotspotglibc) && FEATURE_ACTIVE(hotspotglibc, hotspot_field, hotspot_union, glibc_index, glibc_reg)) { \\\n+      PASTE_TOKENS(disable_, kind) |= PASTE_TOKENS3(kind, _, hotspotglibc);                                                                                            \\\n+    }                                                                                                                                                                  \\\n+  } while (0)\n+#define EXCESSIVE(kind, hotspotglibc, hotspot_union, def...) EXCESSIVE6(kind, hotspotglibc, hotspot_field, def)\n+#define DEF_ExtCpuid1Ecx ExtCpuid1Ecx, CPUID_INDEX_80000001, ecx\n+#define DEF_SefCpuid7Ebx SefCpuid7Ebx, CPUID_INDEX_7       , ebx\n+#define DEF_SefCpuid7Ecx SefCpuid7Ecx, CPUID_INDEX_7       , ecx\n+#define DEF_SefCpuid7Edx SefCpuid7Edx, CPUID_INDEX_7       , edx\n+#define DEF_StdCpuid1Ecx StdCpuid1Ecx, CPUID_INDEX_1       , ecx\n+#define DEF_StdCpuid1Edx StdCpuid1Edx, CPUID_INDEX_1       , edx\n+  EXCESSIVE(CPU  , AVX     , avx     , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , CX8     , cmpxchg8, DEF_StdCpuid1Edx);\n+  EXCESSIVE(CPU  , FMA     , fma     , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , RTM     , rtm     , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX2    , avx2    , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , BMI1    , bmi1    , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , BMI2    , bmi2    , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , CMOV    , cmov    , DEF_StdCpuid1Edx);\n+  EXCESSIVE(CPU  , ERMS    , erms    , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , SSE2    , sse2    , DEF_StdCpuid1Edx);\n+  EXCESSIVE(CPU  , LZCNT   , fma4    , DEF_ExtCpuid1Ecx);\n+  EXCESSIVE(CPU  , SSSE3   , ssse3   , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , POPCNT  , popcnt  , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , SSE4_1  , sse4_1  , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , SSE4_2  , sse4_2  , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , AVX512F , avx512f , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512CD, avx512cd, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512BW, avx512bw, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512DQ, avx512dq, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512ER, avx512er, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512PF, avx512pf, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512VL, avx512vl, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(GLIBC, IBT     , ibt     , DEF_SefCpuid7Edx);\n+  EXCESSIVE(GLIBC, FMA4    , fma4    , DEF_ExtCpuid1Ecx);\n+  EXCESSIVE(GLIBC, MOVBE   , movbe   , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(GLIBC, SHSTK   , shstk   , DEF_SefCpuid7Ecx);\n+  EXCESSIVE(GLIBC, XSAVE   , xsave   , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(GLIBC, OSXSAVE , osxsave , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(GLIBC, HTT     , ht      , DEF_StdCpuid1Edx);\n+#undef EXCESSIVE\n+#undef EXCESSIVE5\n+\n+  char disable_str[64 * (10 + 3) + 1];\n+  strcpy(disable_str, glibc_prefix);\n+  char *disable_end = disable_str + glibc_prefix_len;\n+#define GLIBC_DISABLE(kind, hotspot_glibc) do {                                                                                                 \\\n+    assert(!(PASTE_TOKENS(disable_handled_, kind) & PASTE_TOKENS3(kind, _, hotspot_glibc)), \"already used \" STR(kind) \"_\" STR(hotspot_glibc) ); \\\n+    DEBUG_ONLY(PASTE_TOKENS(disable_handled_, kind) |= PASTE_TOKENS3(kind, _, hotspot_glibc));                                                  \\\n+    if (PASTE_TOKENS(disable_, kind) & PASTE_TOKENS3(kind, _, hotspot_glibc)) {                                                                 \\\n+      const char str[] = \",-\" STR(hotspot_glibc);                                                                                               \\\n+      size_t remains = disable_str + sizeof(disable_str) - disable_end;                                                                         \\\n+      strncpy(disable_end, str, remains);                                                                                                       \\\n+      size_t len = strnlen(disable_end, remains);                                                                                               \\\n+      remains -= len;                                                                                                                           \\\n+      assert(remains > 0, \"internal error: disable_str overflow\");                                                                              \\\n+      disable_end += len;                                                                                                                       \\\n+    }                                                                                                                                           \\\n+  } while (0);\n+  GLIBC_DISABLE(CPU  , AVX)\n+  GLIBC_DISABLE(CPU  , CX8)\n+  GLIBC_DISABLE(CPU  , FMA)\n+  GLIBC_DISABLE(CPU  , RTM)\n+  GLIBC_DISABLE(CPU  , AVX2)\n+  GLIBC_DISABLE(CPU  , BMI1)\n+  GLIBC_DISABLE(CPU  , BMI2)\n+  GLIBC_DISABLE(CPU  , CMOV)\n+  GLIBC_DISABLE(CPU  , ERMS)\n+  GLIBC_DISABLE(CPU  , SSE2)\n+  GLIBC_DISABLE(CPU  , LZCNT)\n+  GLIBC_DISABLE(CPU  , SSSE3)\n+  GLIBC_DISABLE(CPU  , POPCNT)\n+  GLIBC_DISABLE(CPU  , SSE4_1)\n+  GLIBC_DISABLE(CPU  , SSE4_2)\n+  GLIBC_DISABLE(CPU  , AVX512F)\n+  GLIBC_DISABLE(CPU  , AVX512CD)\n+  GLIBC_DISABLE(CPU  , AVX512BW)\n+  GLIBC_DISABLE(CPU  , AVX512DQ)\n+  GLIBC_DISABLE(CPU  , AVX512ER)\n+  GLIBC_DISABLE(CPU  , AVX512PF)\n+  GLIBC_DISABLE(CPU  , AVX512VL)\n+  GLIBC_DISABLE(GLIBC, IBT)\n+  GLIBC_DISABLE(GLIBC, FMA4)\n+  GLIBC_DISABLE(GLIBC, MOVBE)\n+  GLIBC_DISABLE(GLIBC, SHSTK)\n+  GLIBC_DISABLE(GLIBC, XSAVE)\n+  GLIBC_DISABLE(GLIBC, OSXSAVE)\n+  GLIBC_DISABLE(GLIBC, HTT)\n+#undef GLIBC_DISABLE\n+#undef GLIBC_DISABLE2\n+  *disable_end = 0;\n+\n+#ifdef ASSERT\n+#define CHECK_KIND(kind) do {                                                                                                            \\\n+    if (PASTE_TOKENS(disable_handled_, kind) != PASTE_TOKENS(excessive_handled_, kind))                                                  \\\n+      vm_exit_during_initialization(err_msg(\"internal error: Unsupported disabling of \" STR(kind) \"_* 0x%\" PRIx64 \" != used 0x%\" PRIx64, \\\n+                                            PASTE_TOKENS(disable_handled_, kind), PASTE_TOKENS(excessive_handled_, kind)));              \\\n+  } while (0)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+\n+  \/\/ These cannot be disabled by GLIBC_TUNABLES interface.\n+#define GLIBC_UNSUPPORTED(kind, hotspot) EXCESSIVE_HANDLED(kind, hotspot)\n+  GLIBC_UNSUPPORTED(CPU  , 3DNOW_PREFETCH   );\n+  GLIBC_UNSUPPORTED(CPU  , SSE4A            );\n+  GLIBC_UNSUPPORTED(CPU  , TSC              );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV_BIT       );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV           );\n+  GLIBC_UNSUPPORTED(CPU  , AES              );\n+  GLIBC_UNSUPPORTED(CPU  , CLMUL            );\n+  GLIBC_UNSUPPORTED(CPU  , ADX              );\n+  GLIBC_UNSUPPORTED(CPU  , SHA              );\n+  GLIBC_UNSUPPORTED(CPU  , VZEROUPPER       );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPOPCNTDQ );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPCLMULQDQ);\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VAES      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VNNI      );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSH            );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSHOPT         );\n+  GLIBC_UNSUPPORTED(CPU  , CLWB             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI2     );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI      );\n+  GLIBC_UNSUPPORTED(CPU  , HV               );\n+  GLIBC_UNSUPPORTED(CPU  , SSE3             );\n+  \/\/ These are handled as an exception above.\n+  GLIBC_UNSUPPORTED(CPU  , FXSR             );\n+  GLIBC_UNSUPPORTED(CPU  , MMX              );\n+  GLIBC_UNSUPPORTED(CPU  , SSE              );\n+  GLIBC_UNSUPPORTED(CPU  , HT               );\n+  GLIBC_UNSUPPORTED(GLIBC, CMPXCHG16        );\n+  GLIBC_UNSUPPORTED(GLIBC, LAHFSAHF         );\n+  GLIBC_UNSUPPORTED(GLIBC, F16C             );\n+#undef GLIBC_UNSUPPORTED\n+#define CHECK_KIND(kind) do {                                                                                                                 \\\n+    if (PASTE_TOKENS(excessive_handled_, kind) != PASTE_TOKENS(MAX_, kind) - 1)                                                               \\\n+      vm_exit_during_initialization(err_msg(\"internal error: Unsupported disabling of some \" STR(kind) \"_* 0x%\" PRIx64 \" != full 0x%\" PRIx64, \\\n+                                            PASTE_TOKENS(excessive_handled_, kind), PASTE_TOKENS(MAX_, kind) - 1));                           \\\n+  } while (0)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+#endif \/\/ ASSERT\n+\n+  if (disable_end == disable_str + glibc_prefix_len)\n+    return;\n+  if (glibc_env_set(disable_str))\n+    return;\n+  glibc_reexec();\n+}\n+#endif \/\/LINUX\n+\n+void VM_Version::nonlibc_tty_print_uint64(uint64_t num) {\n+  static const char prefix[] = \"0x\";\n+  tty->write(prefix, sizeof(prefix) - 1);\n+  bool first = true;\n+  for (int pos = 64 - 4; pos >= 0; pos -= 4) {\n+    unsigned nibble = (num >> pos) & 0xf;\n+    if (first && nibble == 0 && pos)\n+      continue;\n+    first = false;\n+    char c = nibble >= 0xa ? 'a' + nibble - 0xa : '0' + nibble;\n+    tty->write(&c, sizeof(c));\n+  }\n+}\n+\n+void VM_Version::nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2) {\n+  nonlibc_tty_print_uint64(num1);\n+  static const char comma = ',';\n+  tty->print_raw(&comma, sizeof(comma));\n+  nonlibc_tty_print_uint64(num2);\n+}\n+\n+void VM_Version::print_using_features_cr() {\n+  if (ignore_glibc_not_using) {\n+    tty->print_cr(\"CPU features are being kept intact as requested by -XX:CPUFeatures=ignore\");\n+  } else {\n+    tty->print_cr(\"CPU features being used are: -XX:CPUFeatures=0x\" UINT64_FORMAT_X \",0x\" UINT64_FORMAT_X, _features, _glibc_features);\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hardware() {\n@@ -639,0 +1233,1 @@\n+    LINUX_ONLY(_glibc_features = glibc_flags();)\n@@ -652,0 +1247,9 @@\n+  if (ShowCPUFeatures) {\n+    static const char prefix[] = \"This machine's CPU features are: -XX:CPUFeatures=\";\n+    tty->print_raw(prefix, sizeof(prefix) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    tty->cr();\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hotspot() {\n@@ -655,0 +1259,2 @@\n+    if (!FLAG_IS_DEFAULT(CPUFeatures))\n+      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: 0x%\" PRIx64 \",0x%\" PRIx64, CPU_SSE2, (uint64_t)0));\n@@ -797,1 +1403,1 @@\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  insert_features_names(buf + res, sizeof(buf) - res);\n@@ -1888,0 +2494,84 @@\n+\/\/ Print the feature names as \" = feat1, ..., featN\\n\";\n+void VM_Version::fatal_missing_features(uint64_t features_missing, uint64_t glibc_features_missing) {\n+  static const char part1[] = \"; missing features of this CPU are \";\n+  tty->print_raw(part1, sizeof(part1) - 1);\n+  nonlibc_tty_print_uint64_comma_uint64(features_missing, glibc_features_missing);\n+  static const char part2[] = \" =\";\n+  tty->print_raw(part2, sizeof(part2) - 1);\n+  char buf[512] = \"\";\n+  \/\/ insert_features_names() does crash for undefined too high-numbered features.\n+  insert_features_names(buf, sizeof(buf)          ,       features_missing & (  MAX_CPU - 1));\n+  char *s = buf;\n+  while (*s)\n+    ++s;\n+  insert_features_names(s  , buf + sizeof(buf) - s, glibc_features_missing & (MAX_GLIBC - 1));\n+  while (*s)\n+    ++s;\n+  \/* +1 to skip the first ','. *\/\n+  tty->print_raw(buf + 1, s - (buf + 1));\n+  tty->cr();\n+  vm_exit_during_initialization();\n+}\n+\n+void VM_Version::crac_restore() {\n+  assert(CRaCCheckpointTo != NULL, \"\");\n+\n+  if (ShowCPUFeatures) {\n+    static const char prefix[] = \"This snapshot's stored CPU features are: -XX:CPUFeatures=\";\n+    tty->print_raw(prefix, sizeof(prefix) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    tty->cr();\n+  }\n+\n+  uint64_t       features_saved =       _features;\n+  uint64_t glibc_features_saved = _glibc_features;\n+#define SUPPORTS_SET \\\n+    SUPPORTS(supports_cx8) \\\n+    SUPPORTS(supports_atomic_getset4) \\\n+    SUPPORTS(supports_atomic_getset8) \\\n+    SUPPORTS(supports_atomic_getadd4) \\\n+    SUPPORTS(supports_atomic_getadd8) \\\n+    \/**\/\n+#define SUPPORTS(x) bool x##_saved = Abstract_VM_Version::x();\n+  SUPPORTS_SET\n+#undef SUPPORTS\n+\n+  get_processor_features_hardware();\n+\n+  uint64_t       features_missing =       features_saved & ~      _features;\n+  uint64_t glibc_features_missing = glibc_features_saved & ~_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  if (features_missing || glibc_features_missing) {\n+    static const char part1[] = \"You have to specify -XX:CPUFeatures=\";\n+    tty->print_raw(part1, sizeof(part1) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features & features_saved, _glibc_features & glibc_features_saved);\n+    static const char part2[] = \" together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features \";\n+    tty->print_raw(part2, sizeof(part2) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(features_saved, glibc_features_saved);\n+    fatal_missing_features(features_missing, glibc_features_missing);\n+  }\n+\n+  auto supports_exit = [&](const char *supports, bool file, bool this_cpu) {\n+    char buf[512];\n+    int res = jio_snprintf(\n+                buf, sizeof(buf),\n+                \"Specified -XX:CRaCRestoreFrom file contains feature \\\"%s\\\" value %d while this CPU has value %d\",\n+                supports, file, this_cpu);\n+    assert(res > 0, \"not enough temporary space allocated\");\n+    vm_exit_during_initialization(buf);\n+  };\n+#define SUPPORTS(x)                                           \\\n+  if (x##_saved != Abstract_VM_Version::x()) {                \\\n+    supports_exit( #x , Abstract_VM_Version::x(), x##_saved); \\\n+  }\n+  SUPPORTS_SET\n+#undef SUPPORTS\n+#undef SUPPORTS_SET\n+\n+  if (ShowCPUFeatures)\n+    print_using_features_cr();\n+}\n+\n@@ -1903,1 +2593,46 @@\n-  get_processor_features();\n+  assert(      _features == 0,       \"_features should be zero at startup\");\n+  assert(_glibc_features == 0, \"_glibc_features should be zero at startup\");\n+  get_processor_features_hardware();\n+\n+  assert(!CPUFeatures == FLAG_IS_DEFAULT(CPUFeatures), \"CPUFeatures parsing\");\n+  uint64_t GLIBCFeatures_x64;\n+  uint64_t   CPUFeatures_x64 = CPUFeatures_parse(GLIBCFeatures_x64);\n+  uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+  uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  if (features_missing || glibc_features_missing) {\n+    static const char part1[] = \"Specified -XX:CPUFeatures=\";\n+    tty->print_raw(part1, sizeof(part1) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(CPUFeatures_x64, GLIBCFeatures_x64);\n+    static const char part2[] = \"; this machine's CPU features are \";\n+    tty->print_raw(part2, sizeof(part2) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    fatal_missing_features(features_missing, glibc_features_missing);\n+  }\n+\n+  uint64_t       features_saved =       _features;\n+  uint64_t glibc_features_saved = _glibc_features;\n+\n+        _features =   CPUFeatures_x64;\n+  _glibc_features = GLIBCFeatures_x64;\n+\n+  if (ShowCPUFeatures)\n+    print_using_features_cr();\n+\n+#ifdef LINUX\n+  if (!ignore_glibc_not_using) {\n+    uint64_t       features_expected =   MAX_CPU - 1;\n+    uint64_t glibc_features_expected = MAX_GLIBC - 1;\n+#if !INCLUDE_CPU_FEATURE_ACTIVE && !INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+          features_expected =       features_saved;\n+    glibc_features_expected = glibc_features_saved;\n+#endif\n+    glibc_not_using(      features_expected & ~      _features,\n+                    glibc_features_expected & ~_glibc_features);\n+  }\n+#endif\n+\n+  get_processor_features_hotspot();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":739,"deletions":4,"binary":false,"changes":743,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -31,0 +32,3 @@\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"jvm_io.h\"\n@@ -85,1 +89,2 @@\n-                        : 2,\n+                        : 1,\n+               movbe    : 1,\n@@ -89,1 +94,1 @@\n-                        : 1,\n+               xsave    : 1,\n@@ -92,1 +97,2 @@\n-                        : 2,\n+               f16c     : 1,\n+                        : 1,\n@@ -155,1 +161,3 @@\n-                            : 23;\n+                            : 7,\n+               fma4         : 1,\n+                            : 15;\n@@ -245,1 +253,1 @@\n-                           : 1,\n+                     shstk : 1,\n@@ -263,1 +271,3 @@\n-                           : 28;\n+                           : 16,\n+             ibt           : 1,\n+                           : 11;\n@@ -361,1 +371,1 @@\n-    decl(HV,                \"hv\",                46) \/* Hypervisor instructions *\/\n+    decl(HV,                \"hv\",                46) \/* Hypervisor instructions *\/ \\\n@@ -366,0 +376,1 @@\n+    MAX_CPU = CPU_HV << 1\n@@ -368,0 +379,23 @@\n+  \/* Tracking of a CPU feature for glibc *\/ \\\n+  enum Glibc_Feature_Flag : uint64_t {\n+#define GLIBC_FEATURE_FLAGS(decl) \\\n+    decl(FMA4,              \"fma4\",               0) \\\n+    decl(MOVBE,             \"movbe\",              1) \\\n+    decl(OSXSAVE,           \"osxsave\",            2) \\\n+    decl(IBT,               \"ibt\",                3) \\\n+    decl(SHSTK,             \"shstk\",              4) \/* Also known as cet_ss *\/ \\\n+    decl(XSAVE,             \"xsave\",              5) \\\n+    decl(CMPXCHG16,         \"cmpxchg16\",          6) \/* Also known in cpuinfo as cx16 and in glibc as cmpxchg16b *\/ \\\n+    decl(LAHFSAHF,          \"lahfsahf\",           7) \/* Also known in cpuinfo as lahf_lm and in glibc as lahf64_sahf64 *\/ \\\n+    decl(F16C,              \"f16c\",               8) \\\n+    decl(HTT,               \"htt\",                9) \/* hotspot calls it 'ht' but it is affected by threads_per_core() *\/ \\\n+\n+#define DECLARE_GLIBC_FEATURE_FLAG(id, name, bit) GLIBC_##id = (1ULL << bit),\n+    GLIBC_FEATURE_FLAGS(DECLARE_GLIBC_FEATURE_FLAG)\n+#undef DECLARE_GLIBC_FEATURE_FLAG\n+    MAX_GLIBC = GLIBC_HTT << 1\n+  };\n+\n+  \/\/ glibc feature flags.\n+  static uint64_t _glibc_features;\n+\n@@ -369,0 +403,1 @@\n+  static const char* _glibc_features_names[];\n@@ -670,0 +705,27 @@\n+#ifdef LINUX\n+  static uint64_t glibc_flags() {\n+    uint64_t result = 0;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.movbe != 0)\n+      result |= GLIBC_MOVBE;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.osxsave != 0)\n+      result |= GLIBC_OSXSAVE;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.xsave != 0)\n+      result |= GLIBC_XSAVE;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.cmpxchg16 != 0)\n+      result |= GLIBC_CMPXCHG16;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.f16c != 0)\n+      result |= GLIBC_F16C;\n+    if (_cpuid_info.sef_cpuid7_ecx.bits.shstk != 0)\n+      result |= GLIBC_SHSTK;\n+    if (_cpuid_info.sef_cpuid7_edx.bits.ibt != 0)\n+      result |= GLIBC_IBT;\n+    if (_cpuid_info.ext_cpuid1_ecx.bits.fma4 != 0)\n+      result |= GLIBC_FMA4;\n+    if (_cpuid_info.ext_cpuid1_ecx.bits.LahfSahf != 0)\n+      result |= GLIBC_LAHFSAHF;\n+    if (_cpuid_info.std_cpuid1_edx.bits.ht != 0)\n+      result |= GLIBC_HTT;\n+    return result;\n+  }\n+#endif \/\/LINUX\n+\n@@ -709,1 +771,18 @@\n-  static void get_processor_features();\n+  static void get_processor_features_hardware();\n+  static void get_processor_features_hotspot();\n+\n+  static uint64_t CPUFeatures_parse(uint64_t &glibc_features);\n+#ifdef LINUX\n+  static void glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC);\n+  static bool glibc_env_set(char *disable_str);\n+  \/*[[noreturn]]*\/ static void glibc_reexec();\n+  \/\/ C++17: Make glibc_prefix and glibc_prefix_len constexpr.\n+  static const char glibc_prefix[];\n+  static const size_t glibc_prefix_len;\n+#endif \/\/LINUX\n+  \/\/ C++17: Make ignore_glibc_not_using inline.\n+  static bool ignore_glibc_not_using;\n+  static void nonlibc_tty_print_uint64(uint64_t num);\n+  static void nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2);\n+  static void print_using_features_cr();\n+  \/*[[noreturn]]*\/ static void fatal_missing_features(uint64_t features_missing, uint64_t glibc_features_missing);\n@@ -742,0 +821,7 @@\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _features_names, features);\n+  }\n+  static void insert_glibc_features_names(char* buf, size_t buflen, uint64_t glibc_features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _glibc_features_names, glibc_features);\n+  }\n+\n@@ -745,0 +831,1 @@\n+  static void crac_restore();\n@@ -1042,2 +1129,11 @@\n-    assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), \"clflush should be available\");\n-    return true;\n+    if (!Universe::is_fully_initialized()) {\n+      return true;\n+    }\n+    if ((_features & CPU_FLUSH) != 0) {\n+      return true;\n+    }\n+    if (FLAG_IS_DEFAULT(CPUFeatures)) {\n+      vm_exit_during_initialization(\"clflush should be available\");\n+    }\n+    vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: 0x%\" PRIx64, CPU_FLUSH));\n+    return false;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":106,"deletions":10,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+  static void crac_restore() {}\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#include \"attachListener_linux.hpp\"\n+#include \"linuxAttachOperation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -39,4 +42,0 @@\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n-#endif\n-\n@@ -59,67 +58,0 @@\n-\/\/ forward reference\n-class LinuxAttachOperation;\n-\n-class LinuxAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n-  \/\/ reads a request from the given connected socket\n-  static LinuxAttachOperation* read_request(int s);\n-\n- public:\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n-  static void set_path(char* path) {\n-    if (path == NULL) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, int len);\n-\n-  static LinuxAttachOperation* dequeue();\n-};\n-\n-class LinuxAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  int _socket;\n-\n- public:\n-  void complete(jint res, bufferedStream* st);\n-\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n-\n-  LinuxAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n-  }\n-};\n-\n@@ -131,0 +63,1 @@\n+LinuxAttachOperation* LinuxAttachListener::_current_op = NULL;\n@@ -379,0 +312,1 @@\n+      _current_op = op;\n@@ -399,0 +333,12 @@\n+\/\/ An operation completion is splitted into two parts.\n+\/\/ For proper handling the jcmd connection at CRaC checkpoint action.\n+\/\/ An effectively_complete_raw is called in checkpoint processing, before criu engine calls, for properly closing the socket.\n+\/\/ The complete() gets called after restore for proper deletion the leftover object.\n+\n+void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n+  LinuxAttachOperation::effectively_complete_raw(result, st);\n+  \/\/ reset the current op as late as possible, this happens on attach listener thread.\n+  LinuxAttachListener::reset_current_op();\n+  delete this;\n+}\n+\n@@ -407,3 +353,6 @@\n-void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n+void LinuxAttachOperation::effectively_complete_raw(jint result, bufferedStream* st) {\n+\n+  if (_effectively_completed) {\n+    assert(st->size() == 0, \"no lost output\");\n+    return;\n+  }\n@@ -412,0 +361,11 @@\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    ThreadBlockInVM((JavaThread* )thread);\n+    write_operation_result(result, st);\n+  } else {\n+    write_operation_result(result, st);\n+  }\n+  _effectively_completed = true;\n+}\n+\n+void LinuxAttachOperation::write_operation_result(jint result, bufferedStream* st) {\n@@ -419,1 +379,1 @@\n-    ::shutdown(this->socket(), 2);\n+    ::shutdown(this->socket(), SHUT_RDWR);\n@@ -424,0 +384,2 @@\n+  st->reset();\n+}\n@@ -425,1 +387,5 @@\n-  delete this;\n+static void assert_listener_thread() {\n+#ifdef ASSERT\n+  ResourceMark rm; \/\/ For retrieving the thread names\n+  assert(strcmp(\"Attach Listener\", Thread::current()->name()) == 0, \"should gets called from Attach Listener thread\");\n+#endif\n@@ -428,0 +394,9 @@\n+LinuxAttachOperation* LinuxAttachListener::get_current_op() {\n+  assert_listener_thread();\n+  return LinuxAttachListener::_current_op;\n+}\n+\n+void LinuxAttachListener::reset_current_op() {\n+  assert_listener_thread();\n+  LinuxAttachListener::_current_op = NULL;\n+}\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":51,"deletions":76,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_ATTACHLISTENER_LINUX_HPP\n+#define OS_LINUX_ATTACHLISTENER_LINUX_HPP\n+\n+#include \"linuxAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+\n+#include <sys\/un.h>\n+\n+#ifndef UNIX_PATH_MAX\n+#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n+#endif\n+\n+class LinuxAttachListener: AllStatic {\n+ private:\n+  \/\/ the path to which we bind the UNIX domain socket\n+  static char _path[UNIX_PATH_MAX];\n+  static bool _has_path;\n+\n+  \/\/ the file descriptor for the listening socket\n+  static volatile int _listener;\n+\n+  static bool _atexit_registered;\n+\n+  \/\/ this is for proper reporting JDK.Chekpoint processing to jcmd peer\n+  static LinuxAttachOperation* _current_op;\n+\n+  \/\/ reads a request from the given connected socket\n+  static LinuxAttachOperation* read_request(int s);\n+\n+ public:\n+\n+  enum {\n+    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n+  };\n+  enum {\n+    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n+  };\n+\n+  static void set_path(char* path) {\n+    if (path == NULL) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n+  \/\/ initialize the listener, returns 0 if okay\n+  static int init();\n+\n+  static char* path()                   { return _path; }\n+  static bool has_path()                { return _has_path; }\n+  static int listener()                 { return _listener; }\n+\n+  \/\/ write the given buffer to a socket\n+  static int write_fully(int s, char* buf, int len);\n+\n+  static LinuxAttachOperation* dequeue();\n+  static LinuxAttachOperation* get_current_op();\n+  static void reset_current_op();\n+};\n+\n+#endif \/\/ OS_LINUX_ATTACHLISTENERLINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.hpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,453 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"jvm.h\"\n+#include \"perfMemory_linux.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+\n+class FdsInfo {\n+public:\n+\n+  enum state_t {\n+    INVALID = -3,\n+    CLOSED = -2,\n+    ROOT = -1,\n+    DUP_OF_0 = 0,\n+    \/\/ ...\n+  };\n+\n+  enum mark_t {\n+    M_CANT_RESTORE = 1 << 0,\n+  };\n+\n+private:\n+  struct fdinfo {\n+    int fd;\n+    struct stat stat;\n+    state_t state;\n+    unsigned mark;\n+\n+    int flags;\n+  };\n+\n+  \/\/ params are indices into _fdinfos\n+  bool same_fd(int i1, int i2);\n+\n+  bool _inited;\n+  GrowableArray<fdinfo> _fdinfos;\n+\n+  void assert_mark(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    assert(_fdinfos.at(i).state != CLOSED, \"\");\n+  }\n+\n+public:\n+  void initialize();\n+\n+  int len() { return _fdinfos.length(); }\n+\n+  state_t get_state(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).state;\n+  }\n+\n+  state_t find_state(int fd, state_t orstate) {\n+    for (int i = 0; i < _fdinfos.length(); ++i) {\n+      fdinfo *info = _fdinfos.adr_at(i);\n+      if (info->fd == fd) {\n+        return info->state;\n+      }\n+    }\n+    return orstate;\n+  }\n+\n+  int get_fd(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).fd;\n+  }\n+\n+  struct stat* get_stat(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return &_fdinfos.at(i).stat;\n+  }\n+\n+  FdsInfo(bool do_init = true) :\n+    _inited(false),\n+    _fdinfos(16, mtInternal)\n+  {\n+    if (do_init) {\n+      initialize();\n+    }\n+  }\n+};\n+\n+static FdsInfo _vm_inited_fds(false);\n+\n+\/* taken from criu, that took this from kernel *\/\n+#define NFS_PREF \".nfs\"\n+#define NFS_PREF_LEN ((unsigned)sizeof(NFS_PREF) - 1)\n+#define NFS_FILEID_LEN ((unsigned)sizeof(uint64_t) << 1)\n+#define NFS_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n+#define NFS_LEN (NFS_PREF_LEN + NFS_FILEID_LEN + NFS_COUNTER_LEN)\n+static bool nfs_silly_rename(char* path) {\n+  char *sep = strrchr(path, '\/');\n+  char *base = sep ? sep + 1 : path;\n+  if (strncmp(base, NFS_PREF, NFS_PREF_LEN)) {\n+    return false;\n+  }\n+  for (unsigned i = NFS_PREF_LEN; i < NFS_LEN; ++i) {\n+    if (!isxdigit(base[i])) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+static int readfdlink(int fd, char *link, size_t len) {\n+  char fdpath[64];\n+  snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+  int ret = readlink(fdpath, link, len);\n+  if (ret == -1) {\n+    return ret;\n+  }\n+  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n+  return ret;\n+}\n+\n+static bool same_stat(struct stat* st1, struct stat* st2) {\n+  return st1->st_dev == st2->st_dev &&\n+         st1->st_ino == st2->st_ino;\n+}\n+\n+bool FdsInfo::same_fd(int i1, int i2) {\n+  assert(i1 < _fdinfos.length(), \"\");\n+  assert(i2 < _fdinfos.length(), \"\");\n+  fdinfo *fi1 = _fdinfos.adr_at(i1);\n+  fdinfo *fi2 = _fdinfos.adr_at(i2);\n+  if (!same_stat(&fi1->stat, &fi2->stat)) {\n+    return false;\n+  }\n+\n+  int flags1 = fcntl(fi1->fd, F_GETFL);\n+  int flags2 = fcntl(fi2->fd, F_GETFL);\n+  if (flags1 != flags2) {\n+    return false;\n+  }\n+\n+  const int test_flag = O_NONBLOCK;\n+  const int new_flags1 = flags1 ^ test_flag;\n+  fcntl(fi1->fd, F_SETFL, new_flags1);\n+  if (fcntl(fi1->fd, F_GETFL) != new_flags1) {\n+    \/\/ flag write ignored or handled differently,\n+    \/\/ don't know what to do\n+    return false;\n+  }\n+\n+  const int new_flags2 = fcntl(fi2->fd, F_GETFL);\n+  const bool are_same = new_flags1 == new_flags2;\n+\n+  fcntl(fi2->fd, flags1);\n+\n+  return are_same;\n+}\n+\n+void FdsInfo::initialize() {\n+  assert(!_inited, \"should be called only once\");\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  int dfd = dirfd(dir);\n+  while (dp = readdir(dir)) {\n+    if (dp->d_name[0] == '.') {\n+      \/\/ skip \".\" and \"..\"\n+      continue;\n+    }\n+    fdinfo info;\n+    info.fd = atoi(dp->d_name);\n+    if (info.fd == dfd) {\n+      continue;\n+    }\n+    int r = fstat(info.fd, &info.stat);\n+    if (r == -1) {\n+      info.state = CLOSED;\n+      continue;\n+    }\n+    info.state = ROOT; \/\/ can be changed to DUP_OF_0 + N below\n+    info.mark = 0;\n+    _fdinfos.append(info);\n+  }\n+  closedir(dir);\n+  _inited = true;\n+\n+  for (int i = 0; i < _fdinfos.length(); ++i) {\n+    fdinfo *info = _fdinfos.adr_at(i);\n+    for (int j = 0; j < i; ++j) {\n+      if (get_state(j) == ROOT && same_fd(i, j)) {\n+        info->state = (state_t)(DUP_OF_0 + j);\n+        break;\n+      }\n+    }\n+\n+    if (info->state == ROOT) {\n+      char fdpath[PATH_MAX];\n+      int r = readfdlink(info->fd, fdpath, sizeof(fdpath));\n+      guarantee(-1 != r, \"can't stat fd\");\n+      if (info->stat.st_nlink == 0 ||\n+          strstr(fdpath, \"(deleted)\") ||\n+          nfs_silly_rename(fdpath)) {\n+        info->mark |= FdsInfo::M_CANT_RESTORE;\n+      }\n+    }\n+  }\n+}\n+\n+static const char* stat2strtype(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK: return \"socket\";\n+  case S_IFLNK:  return \"symlink\";\n+  case S_IFREG:  return \"regular\";\n+  case S_IFBLK:  return \"block\";\n+  case S_IFDIR:  return \"directory\";\n+  case S_IFCHR:  return \"character\";\n+  case S_IFIFO:  return \"fifo\";\n+  default:       break;\n+  }\n+  return \"unknown\";\n+}\n+\n+static int stat2stfail(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK:\n+    return JVM_CR_FAIL_SOCK;\n+  case S_IFLNK:\n+  case S_IFREG:\n+  case S_IFBLK:\n+  case S_IFDIR:\n+  case S_IFCHR:\n+    return JVM_CR_FAIL_FILE;\n+  case S_IFIFO:\n+    return JVM_CR_FAIL_PIPE;\n+  default:\n+    break;\n+  }\n+  return JVM_CR_FAIL;\n+}\n+\n+\/\/ If checkpoint is called throught the API, jcmd operation and jcmd output doesn't exist.\n+bool VM_Crac::is_socket_from_jcmd(int sock) {\n+  if (_attach_op == NULL)\n+    return false;\n+  int sock_fd = _attach_op->socket();\n+  return sock == sock_fd;\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+  if (_attach_op == NULL)\n+    return;\n+  bufferedStream* buf = static_cast<bufferedStream*>(_ostream);\n+  _attach_op->effectively_complete_raw(JNI_OK, buf);\n+  \/\/ redirect any further output to console\n+  _ostream = tty;\n+}\n+\n+bool VM_Crac::check_fds() {\n+\n+  AttachListener::abort();\n+\n+  FdsInfo fds;\n+\n+  bool ok = true;\n+\n+  for (int i = 0; i < fds.len(); ++i) {\n+    if (fds.get_state(i) == FdsInfo::CLOSED) {\n+      continue;\n+    }\n+    int fd = fds.get_fd(i);\n+\n+    char detailsbuf[PATH_MAX];\n+    struct stat* st = fds.get_stat(i);\n+    const char* type = stat2strtype(st->st_mode);\n+    int linkret = readfdlink(fd, detailsbuf, sizeof(detailsbuf));\n+    const char* details = 0 < linkret ? detailsbuf : \"\";\n+    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\" \", fd, type, details);\n+\n+    if (is_claimed_fd(fd)) {\n+      print_resources(\"OK: claimed by java code\\n\");\n+      continue;\n+    }\n+\n+    if (_vm_inited_fds.find_state(fd, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n+      print_resources(\"OK: inherited from process env\\n\");\n+      continue;\n+    }\n+\n+    if (S_ISSOCK(st->st_mode)) {\n+      if (is_socket_from_jcmd(fd)){\n+        print_resources(\"OK: jcmd socket\\n\");\n+        continue;\n+      }\n+    }\n+\n+    print_resources(\"BAD: opened by application\\n\");\n+    ok = false;\n+\n+    const int maxinfo = 64;\n+    size_t buflen = strlen(details) + maxinfo;\n+    char* msg = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n+    int len = snprintf(msg, buflen, \"FD fd=%d type=%s path=%s\", fd, type, detailsbuf);\n+    msg[len < 0 ? 0 : ((size_t) len >= buflen ? buflen - 1 : len)] = '\\0';\n+    _failures->append(CracFailDep(stat2stfail(st->st_mode & S_IFMT), msg));\n+  }\n+\n+  return ok;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return PerfMemoryLinux::checkpoint(CRaCCheckpointTo);\n+}\n+\n+void VM_Crac::memory_restore() {\n+  PerfMemoryLinux::restore();\n+}\n+\n+static char modules_path[JVM_MAXPATHLEN] = { '\\0' };\n+\n+static bool is_fd_ignored(int fd, const char *path) {\n+  const char *list = CRaCIgnoredFileDescriptors;\n+  while (list && *list) {\n+    const char *end = strchr(list, ',');\n+    if (!end) {\n+      end = list + strlen(list);\n+    }\n+    char *invalid;\n+    int ignored_fd = strtol(list, &invalid, 10);\n+    if (invalid == end) { \/\/ entry was integer -> file descriptor\n+      if (fd == ignored_fd) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    } else { \/\/ interpret entry as path\n+      int path_len = path ? strlen(path) : -1;\n+      if (path_len != -1 && path_len == end - list && !strncmp(path, list, end - list)) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    }\n+    if (*end) {\n+      list = end + 1;\n+    } else {\n+      break;\n+    }\n+  }\n+\n+  if (os::same_files(modules_path, path)) {\n+    \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+    \/\/ We can ignore this for purposes of CRaC.\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+static void close_extra_descriptors() {\n+  \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+  \/\/ We can ignore this for purposes of CRaC.\n+  if (modules_path[0] == '\\0') {\n+    const char* fileSep = os::file_separator();\n+    jio_snprintf(modules_path, JVM_MAXPATHLEN, \"%s%slib%s\" MODULES_IMAGE_NAME, Arguments::get_java_home(), fileSep, fileSep);\n+  }\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  while (dp = readdir(dir)) {\n+    int fd = atoi(dp->d_name);\n+    if (fd > 2 && fd != dirfd(dir)) {\n+      int r = readfdlink(fd, path, sizeof(path));\n+      if (!is_fd_ignored(fd, r != -1 ? path : nullptr)) {\n+        log_warning(os)(\"CRaC closing file descriptor %d: %s\", fd, path);\n+        close(fd);\n+      }\n+    }\n+  }\n+  closedir(dir);\n+}\n+\n+void crac::vm_create_start() {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  close_extra_descriptors();\n+  _vm_inited_fds.initialize();\n+}\n+\n+static bool read_all(int fd, char *dest, size_t n) {\n+  size_t rd = 0;\n+  do {\n+    ssize_t r = ::read(fd, dest + rd, n - rd);\n+    if (r == 0) {\n+      return false;\n+    } else if (r < 0) {\n+      if (errno == EINTR) {\n+        continue;\n+      }\n+      return false;\n+    }\n+    rd += r;\n+  } while (rd < n);\n+  return true;\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  int fd = ::open(\"\/proc\/sys\/kernel\/random\/boot_id\", O_RDONLY);\n+  if (fd < 0 || !read_all(fd, dest, UUID_LENGTH)) {\n+    perror(\"CRaC: Cannot read system boot ID\");\n+    return false;\n+  }\n+  char c;\n+  if (!read_all(fd, &c, 1) || c != '\\n') {\n+    perror(\"CRaC: system boot ID does not end with newline\");\n+    return false;\n+  }\n+  if (::read(fd, &c, 1) != 0) {\n+    perror(\"CRaC: Unexpected data\/error reading system boot ID\");\n+    return false;\n+  }\n+  if (::close(fd) != 0) {\n+    perror(\"CRaC: Cannot close system boot ID file\");\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/linux\/crac_linux.cpp","additions":453,"deletions":0,"binary":false,"changes":453,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef OS_LINUX_LINUXATTACHOPERATION_HPP\n+#define OS_LINUX_LINUXATTACHOPERATION_HPP\n+#include \"services\/attachListener.hpp\"\n+\n+class LinuxAttachOperation: public AttachOperation {\n+ private:\n+  \/\/ the connection to the client\n+  int _socket;\n+  bool _effectively_completed;\n+  void write_operation_result(jint result, bufferedStream* st);\n+\n+ public:\n+  void complete(jint res, bufferedStream* st);\n+  void effectively_complete_raw(jint res, bufferedStream* st);\n+  bool is_effectively_completed()                      { return _effectively_completed; }\n+\n+  void set_socket(int s)                                { _socket = s; }\n+  int socket() const                                    { return _socket; }\n+\n+  LinuxAttachOperation(char* name) : AttachOperation(name) {\n+    set_socket(-1);\n+    _effectively_completed = false;\n+  }\n+};\n+#endif \/\/ OS_LINUX_LINUXATTACHOPERATION_HPP\n","filename":"src\/hotspot\/os\/linux\/linuxAttachOperation.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2017, 2022, Azul Systems, Inc. All rights reserved.\n@@ -28,0 +29,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -70,0 +72,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -81,0 +84,1 @@\n+# include <arpa\/inet.h>\n@@ -83,1 +87,0 @@\n-# include <sys\/stat.h>\n@@ -85,0 +88,1 @@\n+# include <sys\/sysmacros.h>\n@@ -101,1 +105,0 @@\n-# include <fcntl.h>\n@@ -111,0 +114,1 @@\n+# include <libgen.h>\n@@ -369,1 +373,1 @@\n-void os::Linux::initialize_system_info() {\n+void os::Linux::initialize_processor_count() {\n@@ -371,0 +375,5 @@\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n+void os::Linux::initialize_system_info() {\n+  initialize_processor_count();\n@@ -383,1 +392,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -62,0 +63,1 @@\n+  static void initialize_processor_count();\n@@ -315,0 +317,7 @@\n+  static void initialize_cpu_count() {\n+    initialize_processor_count();\n+    if (cpu_to_node() != NULL) {\n+      rebuild_cpu_to_node_map();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PERFMEMORY_LINUX_HPP\n+#define OS_LINUX_PERFMEMORY_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class PerfMemoryLinux : AllStatic {\n+\n+public:\n+  static inline const char* perfdata_name() {\n+    return \"perfdata\";\n+  }\n+\n+  static bool checkpoint(const char* checkpoint_path);\n+  static bool restore();\n+};\n+\n+#endif \/\/ OS_LINUX_PERFMEMORY_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/perfMemory_linux.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"jvm.h\"\n+#include \"runtime\/crac_structs.hpp\"\n+\n+#include <sys\/mman.h>\n+\n+int CracSHM::open(int mode) {\n+  int shmfd = shm_open(_path, mode, 0600);\n+  if (-1 == shmfd) {\n+    perror(\"shm_open\");\n+  }\n+  return shmfd;\n+}\n+\n+void CracSHM::unlink() {\n+  shm_unlink(_path);\n+}\n+\n+#ifndef LINUX\n+void crac::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  return true;\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/os\/posix\/crac_posix.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -94,0 +94,6 @@\n+#if defined(LINUX)\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#elif defined(__APPLE__)\n+#define RESTORE_SIGNAL   SIGUSR2\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -738,0 +739,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -764,0 +769,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1497,1 +1510,1 @@\n-  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec);\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + crac::monotonic_time_offset();\n@@ -2042,0 +2055,30 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  char** env = os::get_environ();\n+\n+  pid_t pid = fork();\n+  if (pid == -1) {\n+    perror(\"cannot fork for crengine\");\n+    return -1;\n+  }\n+  if (pid == 0) {\n+    execve(path, (char* const*)argv, env);\n+    perror(\"execve\");\n+    exit(1);\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return -1;\n+  }\n+  return WEXITSTATUS(status) == 0 ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return ::execv(path, (char * const *)argv);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -33,0 +34,1 @@\n+\/\/#include \"os_linux.inline.hpp\"\n@@ -40,0 +42,4 @@\n+#ifdef LINUX\n+#include \"perfMemory_linux.hpp\"\n+#endif \/\/LINUX\n+\n@@ -56,0 +62,1 @@\n+static int checkpoint_fd = -1;\n@@ -1391,0 +1398,100 @@\n+\n+#ifdef LINUX\n+bool PerfMemoryLinux::checkpoint(const char* checkpoint_path) {\n+  assert(checkpoint_path, \"should be set\");\n+\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  int pathlen = snprintf(path, sizeof(path),\"%s\/%s\", checkpoint_path, perfdata_name());\n+\n+  RESTARTABLE(::open(path, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), checkpoint_fd);\n+  if (checkpoint_fd < 0) {\n+    tty->print_cr(\"cannot open checkpoint perfdata: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  char* p = PerfMemory::start();\n+  size_t len = PerfMemory::capacity();\n+  do {\n+    int result;\n+    RESTARTABLE(::write(checkpoint_fd, p, len), result);\n+    if (result == OS_ERR) {\n+      tty->print_cr(\"cannot write data to checkpoint perfdata file: %s\", os::strerror(errno));\n+      ::close(checkpoint_fd);\n+      checkpoint_fd = -1;\n+      return false;\n+    }\n+    p += result;\n+    len -= (size_t)result;\n+  } while (0 < len);\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, checkpoint_fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap checkpoint perfdata file: %s\", os::strerror(errno));\n+    ::close(checkpoint_fd);\n+    checkpoint_fd = -1;\n+    return false;\n+  }\n+\n+  remove_file(backing_store_file_name);\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::restore() {\n+  if (checkpoint_fd < 0) {\n+    return true;\n+  }\n+\n+  int vmid = os::current_process_id();\n+  char* user_name = get_user_name(geteuid());\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  if (!make_user_tmp_dir(dirname)) {\n+    return false;\n+  }\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"cannot open restore perfdata file: %s\", os::strerror(errno));\n+\n+    void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+        PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, checkpoint_fd, 0);\n+    if (MAP_FAILED == mmapret) {\n+      tty->print_cr(\"cannot remap checkpoint perfdata file: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  char* p = PerfMemory::start();\n+  size_t len = PerfMemory::capacity();\n+  do {\n+    int result;\n+    RESTARTABLE(::write(fd, p, len), result);\n+    if (result == OS_ERR) {\n+      tty->print_cr(\"cannot write data to restore perfdata file: %s\", os::strerror(errno));\n+      ::close(fd);\n+      return false;\n+    }\n+    p += result;\n+    len -= (size_t)result;\n+  } while (0 < len);\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap restore perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  ::close(fd);\n+  ::close(checkpoint_fd);\n+  checkpoint_fd = -1;\n+  return true;\n+}\n+#endif \/\/LINUX\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n@@ -1486,0 +1486,4 @@\n+\n+  sigemptyset(&blocked_sigs);\n+  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+\n@@ -1496,0 +1500,5 @@\n+static sigset_t* blocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &blocked_sigs;\n+}\n+\n@@ -1513,0 +1522,1 @@\n+  pthread_sigmask(SIG_BLOCK, blocked_signals(), NULL);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"jvm.h\"\n+#include \"runtime\/crac_structs.hpp\"\n+\n+void crac::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+\n+int CracSHM::open(int mode) {\n+  return -1;\n+}\n+\n+void CracSHM::unlink() {\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/windows\/crac_windows.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1407,0 +1408,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -4623,0 +4651,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5763,0 +5816,9 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  const int status = _spawnv(_P_WAIT, path, argv); \/\/ env is inherited by a child process\n+  return 0 == status ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return _execv(path, argv);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -223,0 +223,9 @@\n+  \/\/ VM_Version::crac_restore()->VM_Version::get_processor_features_hardware()\n+  \/\/ executes cpuinfo without a started Java thread.\n+  if (info != NULL && uc != NULL && thread == NULL && sig == SIGSEGV) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n+      stub = VM_Version::cpuinfo_cont_addr();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -711,0 +711,4 @@\n+  template(jdk_crac_Core,                          \"jdk\/crac\/Core\")                                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+  template(checkpointRestoreInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -240,0 +240,7 @@\n+  \/\/ Handle do_cleanup_unused here to print correct capacity below.\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    \/\/ HeapRegionManager::shrink_by do not allow remove all regions.\n+    \/\/ Make sure at least one is there.\n+    maximum_desired_capacity = HeapRegion::GrainBytes;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -1719,0 +1720,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1886,0 +1894,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -353,0 +354,6 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), (char*)eden()->end() - (char*)eden()->top());\n+    os::cleanup_memory((char*)from()->top(), (char*)from()->end() - (char*)from()->top());\n+    os::cleanup_memory((char*)to()->top(), (char*)to()->end() - (char*)to()->top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -296,0 +297,3 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    shrink_bytes = capacity_after_gc - used_after_gc;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -116,0 +116,2 @@\n+  bool _cleanup_unused;\n+\n@@ -375,0 +377,3 @@\n+  void set_cleanup_unused(bool value) { _cleanup_unused = value; }\n+  bool do_cleanup_unused() const { return _cleanup_unused; }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  JMM_JVM_RESTORE_START_TIME_MS      = 12,   \/* Time when the JVM started restore operation *\/\n+  JMM_JVM_UPTIME_SINCE_RESTORE_MS    = 13,   \/* The JVM uptime since restore *\/\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1129,0 +1129,15 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+    case JVMFlagOrigin::CRAC_RESTORE: return \"CRaC restore\";\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/crac.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3853,0 +3854,5 @@\n+\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -318,2 +318,1 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n-  uint64_t features = _features;\n+void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features) {\n@@ -324,4 +323,10 @@\n-      int res = jio_snprintf(buf, buflen, \", %s\", features_names[features_names_index]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+      \/\/ Do not use any libc string functions. Our caller VM_Version::fatal_missing_features may have GNU_IFUNC-misconfigured glibc.\n+      if (buflen-- > 0)\n+        *buf++ = ',';\n+      if (buflen-- > 0)\n+        *buf++ = ' ';\n+      for (const char *src = features_names[features_names_index]; *src; ++src)\n+      if (buflen-- > 0)\n+        *buf++ = *src;\n+      assert(buflen > 0, \"not enough temporary space allocated\");\n+      *buf = 0;\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+  static void insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features = _features);\n+\n@@ -126,1 +128,0 @@\n-  static void insert_features_names(char* buf, size_t buflen, const char* features_names[]);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -46,0 +47,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1157,0 +1159,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == NULL) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1166,4 +1181,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1171,6 +1183,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == NULL) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1309,1 +1317,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1311,2 +1321,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1316,1 +1324,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1324,1 +1333,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1326,1 +1335,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1328,0 +1337,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2297,0 +2313,65 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = NULL;\n+      const char* value = NULL;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.command\") == 0) {\n+        char *old_java_command = _java_command;\n+        _java_command = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != NULL) {\n+          os::free(old_java_command);\n+        }\n+      } else {\n+        add_property(tail);\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n+      \/\/ already been handled\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != NULL) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n+          return false;\n+        }\n+        build_jvm_flags(tail);\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -3051,0 +3132,7 @@\n+  if (CRaCCheckpointTo && UseZGC) {\n+    \/\/ jdk.crac.impl.CheckpointOpenFileException: FD fd=3 type=regular path=\/memfd:java_heap (deleted)\n+    jio_fprintf(defaultStream::output_stream(),\n+      \"-XX:+UseZGC is currently unsupported for -XX:CRaCCheckpointTo.\\n\");\n+    return JNI_ERR;\n+  }\n+\n@@ -3156,0 +3244,4 @@\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":108,"deletions":16,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -379,0 +379,4 @@\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n+\n@@ -644,0 +648,4 @@\n+  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,586 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"classfile\/classLoader.hpp\"\n+#include \"jvm.h\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/heapDumper.hpp\"\n+#include \"services\/writeableFlags.hpp\"\n+\n+static const char* _crengine = NULL;\n+static char* _crengine_arg_str = NULL;\n+static unsigned int _crengine_argc = 0;\n+static const char* _crengine_args[32];\n+static jlong _restore_start_time;\n+static jlong _restore_start_nanos;\n+\n+\/\/ Timestamps recorded before checkpoint\n+jlong crac::checkpoint_millis;\n+jlong crac::checkpoint_nanos;\n+char crac::checkpoint_bootid[UUID_LENGTH];\n+\/\/ Value based on wall clock time difference that will guarantee monotonic\n+\/\/ System.nanoTime() close to actual wall-clock time difference.\n+jlong crac::javaTimeNanos_offset = 0;\n+\n+jlong crac::restore_start_time() {\n+  if (!_restore_start_time) {\n+    return -1;\n+  }\n+  return _restore_start_time;\n+}\n+\n+jlong crac::uptime_since_restore() {\n+  if (!_restore_start_nanos) {\n+    return -1;\n+  }\n+  return os::javaTimeNanos() - _restore_start_nanos;\n+}\n+\n+void VM_Crac::trace_cr(const char* msg, ...) {\n+  if (CRTrace) {\n+    va_list ap;\n+    va_start(ap, msg);\n+    _ostream->print(\"CR: \");\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    _ostream->vprint_cr(msg, ap);\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+    va_end(ap);\n+  }\n+}\n+\n+void VM_Crac::print_resources(const char* msg, ...) {\n+  if (CRPrintResourcesOnCheckpoint) {\n+    va_list ap;\n+    va_start(ap, msg);\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    _ostream->vprint(msg, ap);\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+    va_end(ap);\n+  }\n+}\n+\n+#if defined(__APPLE__) || defined(_WINDOWS)\n+static char * strchrnul(char * str, char c) {\n+  for (; *str && c != *str; ++str) {}\n+  return str;\n+}\n+#endif \/\/__APPLE__ || _WINDOWS\n+\n+static size_t cr_util_path(char* path, int len) {\n+  os::jvm_path(path, len);\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n+  assert(1 == strlen(os::file_separator()), \"file separator must be a single-char, not a string\");\n+  char *after_elem = NULL;\n+  for (int i = 0; i < 2; ++i) {\n+    after_elem = strrchr(path, *os::file_separator());\n+    *after_elem = '\\0';\n+  }\n+  return after_elem - path;\n+}\n+\n+static bool compute_crengine() {\n+  \/\/ release possible old copies\n+  os::free((char *) _crengine); \/\/ NULL is allowed\n+  _crengine = NULL;\n+  os::free((char *) _crengine_arg_str);\n+  _crengine_arg_str = NULL;\n+\n+  if (!CREngine) {\n+    return true;\n+  }\n+  char *exec = os::strdup_check_oom(CREngine);\n+  char *comma = strchr(exec, ',');\n+  if (comma != NULL) {\n+    *comma = '\\0';\n+    _crengine_arg_str = os::strdup_check_oom(comma + 1);\n+  }\n+  if (os::is_path_absolute(exec)) {\n+    _crengine = exec;\n+  } else {\n+    char path[JVM_MAXPATHLEN];\n+    size_t pathlen = cr_util_path(path, sizeof(path));\n+    strcat(path + pathlen, os::file_separator());\n+    strcat(path + pathlen, exec);\n+\n+    struct stat st;\n+    if (0 != os::stat(path, &st)) {\n+      warning(\"Could not find %s: %s\", path, strerror(errno));\n+      return false;\n+    }\n+    _crengine = os::strdup_check_oom(path);\n+    \/\/ we have read and duplicated args from exec, now we can release\n+    os::free(exec);\n+  }\n+  _crengine_args[0] = _crengine;\n+  _crengine_argc = 2;\n+\n+  if (_crengine_arg_str != NULL) {\n+    char *arg = _crengine_arg_str;\n+    char *target = _crengine_arg_str;\n+    bool escaped = false;\n+    for (char *c = arg; *c != '\\0'; ++c) {\n+      if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 2) {\n+        warning(\"Too many options to CREngine; cannot proceed with these: %s\", arg);\n+        return false;\n+      }\n+      if (!escaped) {\n+        switch(*c) {\n+        case '\\\\':\n+          escaped = true;\n+          continue; \/\/ for\n+        case ',':\n+          *target++ = '\\0';\n+          _crengine_args[_crengine_argc++] = arg;\n+          arg = target;\n+          continue; \/\/ for\n+        }\n+      }\n+      escaped = false;\n+      *target++ = *c;\n+    }\n+    *target = '\\0';\n+    _crengine_args[_crengine_argc++] = arg;\n+    _crengine_args[_crengine_argc] = NULL;\n+  }\n+  return true;\n+}\n+\n+static void add_crengine_arg(const char *arg) {\n+  if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 1) {\n+      warning(\"Too many options to CREngine; cannot add %s\", arg);\n+      return;\n+  }\n+  _crengine_args[_crengine_argc++] = arg;\n+  _crengine_args[_crengine_argc] = NULL;\n+}\n+\n+static int call_crengine() {\n+  if (!_crengine) {\n+    return -1;\n+  }\n+  _crengine_args[1] = \"checkpoint\";\n+  add_crengine_arg(CRaCCheckpointTo);\n+  return os::exec_child_process_and_wait(_crengine, _crengine_args);\n+}\n+\n+static int checkpoint_restore(int *shmid) {\n+  crac::record_time_before_checkpoint();\n+\n+  int cres = call_crengine();\n+  if (cres < 0) {\n+    tty->print_cr(\"CRaC error executing: %s\\n\", _crengine);\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+#ifdef LINUX\n+  sigset_t waitmask;\n+  sigemptyset(&waitmask);\n+  sigaddset(&waitmask, RESTORE_SIGNAL);\n+\n+  siginfo_t info;\n+  int sig;\n+  do {\n+    sig = sigwaitinfo(&waitmask, &info);\n+  } while (sig == -1 && errno == EINTR);\n+  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n+\n+  if (CRaCCPUCountInit) {\n+    os::Linux::initialize_cpu_count();\n+  }\n+#else\n+  \/\/ TODO add sync processing\n+#endif \/\/LINUX\n+\n+  crac::update_javaTimeNanos_offset();\n+\n+  if (CRTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n+  }\n+\n+#ifdef LINUX\n+  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n+    tty->print(\"JVM: invalid info for restore provided: %s\", info.si_code == SI_QUEUE ? \"queued\" : \"not queued\");\n+    if (info.si_code == SI_QUEUE) {\n+      tty->print(\" code %d\", info.si_int);\n+    }\n+    tty->cr();\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  if (0 < info.si_int) {\n+    *shmid = info.si_int;\n+  }\n+#else\n+  *shmid = 0;\n+#endif \/\/LINUX\n+  return JVM_CHECKPOINT_OK;\n+}\n+\n+bool VM_Crac::read_shm(int shmid) {\n+  CracSHM shm(shmid);\n+  int shmfd = shm.open(O_RDONLY);\n+  shm.unlink();\n+  if (shmfd < 0) {\n+    return false;\n+  }\n+  bool ret = _restore_parameters.read_from(shmfd);\n+  close(shmfd);\n+  return ret;\n+}\n+\n+bool VM_Crac::is_claimed_fd(int fd) {\n+  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n+  for (int j = 0; j < claimed_fds->length(); ++j) {\n+    jint cfd = claimed_fds->int_at(j);\n+    if (fd == cfd) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+class WakeupClosure: public ThreadClosure {\n+  void do_thread(Thread* thread) {\n+    JavaThread *jt = thread->as_Java_thread();\n+    jt->wakeup_sleep();\n+    jt->parker()->unpark();\n+    jt->_ParkEvent->unpark();\n+  }\n+};\n+\n+static void wakeup_threads_in_timedwait() {\n+  WakeupClosure wc;\n+  Threads::java_threads_do(&wc);\n+\n+  MonitorLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);\n+  WatcherThread::watcher_thread()->unpark();\n+}\n+\n+void VM_Crac::doit() {\n+  \/\/ dry-run fails checkpoint\n+  bool ok = true;\n+\n+  if (!check_fds()) {\n+    ok = false;\n+  }\n+\n+  if ((!ok || _dry_run) && CRHeapDumpOnCheckpointException) {\n+    HeapDumper::dump_heap();\n+  }\n+\n+  if (!ok && CRPauseOnCheckpointError) {\n+    os::message_box(\"Checkpoint failed\", \"Errors were found during checkpoint.\");\n+  }\n+\n+  if (!ok && CRDoThrowCheckpointException) {\n+    return;\n+  } else if (_dry_run) {\n+    _ok = ok;\n+    return;\n+  }\n+\n+  if (!memory_checkpoint()) {\n+    return;\n+  }\n+\n+  int shmid = 0;\n+  if (CRAllowToSkipCheckpoint) {\n+    trace_cr(\"Skip Checkpoint\");\n+  } else {\n+    trace_cr(\"Checkpoint ...\");\n+    report_ok_to_jcmd_if_any();\n+    int ret = checkpoint_restore(&shmid);\n+    if (ret == JVM_CHECKPOINT_ERROR) {\n+      memory_restore();\n+      return;\n+    }\n+  }\n+\n+  VM_Version::crac_restore();\n+\n+  if (shmid <= 0 || !VM_Crac::read_shm(shmid)) {\n+    _restore_start_time = os::javaTimeMillis();\n+    _restore_start_nanos = os::javaTimeNanos();\n+  } else {\n+    _restore_start_nanos += crac::monotonic_time_offset();\n+  }\n+  memory_restore();\n+\n+  wakeup_threads_in_timedwait();\n+\n+  _ok = true;\n+}\n+\n+bool crac::prepare_checkpoint() {\n+  struct stat st;\n+\n+  if (0 == os::stat(CRaCCheckpointTo, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      warning(\"%s: not a directory\", CRaCCheckpointTo);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == os::mkdir(CRaCCheckpointTo)) {\n+      warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+      return false;\n+    }\n+    if (-1 == os::rmdir(CRaCCheckpointTo)) {\n+      warning(\"cannot cleanup after check: %s\", strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+\n+  if (!compute_crengine()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n+  objArrayHandle bundle(THREAD, bundleObj);\n+  jvalue jval;\n+  jval.i = ret;\n+  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n+  bundle->obj_at_put(0, retObj);\n+  bundle->obj_at_put(1, new_args());\n+  bundle->obj_at_put(2, new_props());\n+  bundle->obj_at_put(3, err_codes());\n+  bundle->obj_at_put(4, err_msgs());\n+  return bundle;\n+}\n+\n+\/** Checkpoint main entry.\n+ *\/\n+Handle crac::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n+  if (!CRaCCheckpointTo) {\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+  if (-1 == os::mkdir(CRaCCheckpointTo) && errno != EEXIST) {\n+    warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+  Universe::heap()->set_cleanup_unused(true);\n+  Universe::heap()->collect(GCCause::_full_gc_alot);\n+  Universe::heap()->set_cleanup_unused(false);\n+\n+  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    VMThread::execute(&cr);\n+  }\n+  if (cr.ok()) {\n+    oop new_args = NULL;\n+    if (cr.new_args()) {\n+      new_args = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n+    }\n+    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n+    objArrayHandle props(THREAD, propsObj);\n+\n+    for (int i = 0; i < new_properties->length(); i++) {\n+      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n+      props->obj_at_put(i, propObj);\n+    }\n+    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n+  }\n+\n+  GrowableArray<CracFailDep>* failures = cr.failures();\n+\n+  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n+  typeArrayHandle codes(THREAD, codesObj);\n+  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n+  objArrayHandle msgs(THREAD, msgsObj);\n+\n+  for (int i = 0; i < failures->length(); ++i) {\n+    codes->int_at_put(i, failures->at(i)._type);\n+    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n+    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n+    msgs->obj_at_put(i, msgObj);\n+  }\n+\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n+}\n+\n+void crac::restore() {\n+  jlong restore_time = os::javaTimeMillis();\n+  jlong restore_nanos = os::javaTimeNanos();\n+\n+  compute_crengine();\n+\n+  const int id = os::current_process_id();\n+\n+  CracSHM shm(id);\n+  int shmfd = shm.open(O_RDWR | O_CREAT);\n+  if (0 <= shmfd) {\n+    if (CracRestoreParameters::write_to(\n+          shmfd,\n+          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n+          Arguments::system_properties(),\n+          Arguments::java_command() ? Arguments::java_command() : \"\",\n+          restore_time,\n+          restore_nanos)) {\n+      char strid[32];\n+      snprintf(strid, sizeof(strid), \"%d\", id);\n+      LINUX_ONLY(setenv(\"CRAC_NEW_ARGS_ID\", strid, true));\n+    }\n+    close(shmfd);\n+  }\n+\n+  if (_crengine) {\n+    _crengine_args[1] = \"restore\";\n+    add_crengine_arg(CRaCRestoreFrom);\n+    os::execv(_crengine, _crengine_args);\n+    warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", _crengine, strerror(errno));\n+  }\n+}\n+\n+bool CracRestoreParameters::read_from(int fd) {\n+  struct stat st;\n+  if (fstat(fd, &st)) {\n+    perror(\"fstat (ignoring restore parameters)\");\n+    return false;\n+  }\n+\n+  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+  if (read(fd, contents, st.st_size) < 0) {\n+    perror(\"read (ignoring restore parameters)\");\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return false;\n+  }\n+\n+  _raw_content = contents;\n+\n+  \/\/ parse the contents to read new system properties and arguments\n+  header* hdr = (header*)_raw_content;\n+  char* cursor = _raw_content + sizeof(header);\n+\n+  ::_restore_start_time = hdr->_restore_time;\n+  ::_restore_start_nanos = hdr->_restore_nanos;\n+\n+  for (int i = 0; i < hdr->_nflags; i++) {\n+    FormatBuffer<80> err_msg(\"%s\", \"\");\n+    JVMFlag::Error result;\n+    const char *name = cursor;\n+    if (*cursor == '+' || *cursor == '-') {\n+      name = cursor + 1;\n+      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n+        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+      cursor += strlen(cursor) + 1;\n+    } else {\n+      char* eq = strchrnul(cursor, '=');\n+      if (*eq == '\\0') {\n+        result = JVMFlag::Error::MISSING_VALUE;\n+        cursor = eq + 1;\n+      } else {\n+        *eq = '\\0';\n+        char* value = eq + 1;\n+        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+        cursor = value + strlen(value) + 1;\n+      }\n+    }\n+    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %s\",\n+        name, JVMFlag::flag_error_str(result));\n+  }\n+\n+  for (int i = 0; i < hdr->_nprops; i++) {\n+    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+    int idx = _properties->append(cursor);\n+    size_t prop_len = strlen(cursor) + 1;\n+    cursor = cursor + prop_len;\n+  }\n+\n+  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n+  memcpy(env_mem, cursor, hdr->_env_memory_size);\n+\n+  const char* env_end = env_mem + hdr->_env_memory_size;\n+  while (env_mem < env_end) {\n+    const size_t s = strlen(env_mem) + 1;\n+    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n+    putenv(env_mem);\n+    env_mem += s;\n+  }\n+  cursor += hdr->_env_memory_size;\n+\n+  _args = cursor;\n+  return true;\n+}\n+\n+void crac::record_time_before_checkpoint() {\n+  checkpoint_millis = os::javaTimeMillis();\n+  checkpoint_nanos = os::javaTimeNanos();\n+  memset(checkpoint_bootid, 0, UUID_LENGTH);\n+  read_bootid(checkpoint_bootid);\n+}\n+\n+void crac::update_javaTimeNanos_offset() {\n+  char buf[UUID_LENGTH];\n+  \/\/ We will change the nanotime offset only if this is not the same boot\n+  \/\/ to prevent reducing the accuracy of System.nanoTime() unnecessarily.\n+  \/\/ It is possible that in a real-world case the boot_id does not change\n+  \/\/ (containers keep the boot_id) - but the monotonic time changes. We will\n+  \/\/ only guarantee that the nanotime does not go backwards in that case but\n+  \/\/ won't offset the time based on wall-clock time as this change in monotonic\n+  \/\/ time is likely intentional.\n+  if (!read_bootid(buf) || memcmp(buf, checkpoint_bootid, UUID_LENGTH) != 0) {\n+    assert(checkpoint_millis >= 0, \"Restore without a checkpoint?\");\n+    long diff_millis = os::javaTimeMillis() - checkpoint_millis;\n+    \/\/ If the wall clock has gone backwards we won't add it to the offset\n+    if (diff_millis < 0) {\n+      diff_millis = 0;\n+    }\n+    \/\/ javaTimeNanos() call on the second line below uses the *_offset, so we will zero\n+    \/\/ it to make the call return true monotonic time rather than the adjusted value.\n+    javaTimeNanos_offset = 0;\n+    javaTimeNanos_offset = checkpoint_nanos - os::javaTimeNanos() + diff_millis * 1000000L;\n+  } else {\n+    \/\/ ensure monotonicity even if this looks like the same boot\n+    jlong diff = os::javaTimeNanos() - checkpoint_nanos;\n+    if (diff < 0) {\n+      javaTimeNanos_offset -= diff;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":586,"deletions":0,"binary":false,"changes":586,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_HPP\n+#define SHARE_RUNTIME_CRAC_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n+#define UUID_LENGTH 36\n+\n+class crac: AllStatic {\n+public:\n+  static void vm_create_start();\n+  static bool prepare_checkpoint();\n+  static Handle checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS);\n+  static void restore();\n+\n+  static jlong restore_start_time();\n+  static jlong uptime_since_restore();\n+\n+  static void record_time_before_checkpoint();\n+  static void update_javaTimeNanos_offset();\n+\n+  static jlong monotonic_time_offset() {\n+    return javaTimeNanos_offset;\n+  }\n+\n+private:\n+  static bool read_bootid(char *dest);\n+\n+  static jlong checkpoint_millis;\n+  static jlong checkpoint_nanos;\n+  static char checkpoint_bootid[UUID_LENGTH];\n+  static jlong javaTimeNanos_offset;\n+};\n+\n+#endif \/\/SHARE_RUNTIME_CRAC_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+#define SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+\n+#include \"jvm.h\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+\n+#ifdef LINUX\n+#include \"attachListener_linux.hpp\"\n+#include \"linuxAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+#endif\n+\n+struct CracFailDep {\n+  int _type;\n+  char* _msg;\n+  CracFailDep(int type, char* msg) :\n+    _type(type),\n+    _msg(msg)\n+  { }\n+  CracFailDep() :\n+    _type(JVM_CR_FAIL),\n+    _msg(NULL)\n+  { }\n+};\n+\n+class CracRestoreParameters : public CHeapObj<mtInternal> {\n+  char* _raw_content;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  struct header {\n+    jlong _restore_time;\n+    jlong _restore_nanos;\n+    int _nflags;\n+    int _nprops;\n+    int _env_memory_size;\n+  };\n+\n+  static bool write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  static int system_props_length(const SystemProperty* props) {\n+    int len = 0;\n+    while (props != NULL) {\n+      ++len;\n+      props = props->next();\n+    }\n+    return len;\n+  }\n+\n+  static int env_vars_size(const char* const * env) {\n+    int len = 0;\n+    for (; *env; ++env) {\n+      len += (int)strlen(*env) + 1;\n+    }\n+    return len;\n+  }\n+\n+ public:\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  CracRestoreParameters() :\n+    _raw_content(NULL),\n+    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(NULL)\n+  {}\n+\n+  ~CracRestoreParameters() {\n+    if (_raw_content) {\n+      FREE_C_HEAP_ARRAY(char, _raw_content);\n+    }\n+    delete _properties;\n+  }\n+\n+  static bool write_to(int fd,\n+      const char* const* flags, int num_flags,\n+      const SystemProperty* props,\n+      const char *args,\n+      jlong restore_time,\n+      jlong restore_nanos) {\n+    header hdr = {\n+      restore_time,\n+      restore_nanos,\n+      num_flags,\n+      system_props_length(props),\n+      env_vars_size(os::get_environ())\n+    };\n+\n+    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < num_flags; ++i) {\n+      if (!write_check_error(fd, flags[i], (int)strlen(flags[i]) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    const SystemProperty* p = props;\n+    while (p != NULL) {\n+      char prop[4096];\n+      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n+      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n+      if (!write_check_error(fd, prop, len+1)) {\n+        return false;\n+      }\n+      p = p->next();\n+    }\n+\n+    \/\/ Write env vars\n+    for (char** env = os::get_environ(); *env; ++env) {\n+      if (!write_check_error(fd, *env, (int)strlen(*env) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    return write_check_error(fd, args, (int)strlen(args)+1); \/\/ +1 for null char\n+  }\n+\n+  bool read_from(int fd);\n+\n+};\n+\n+class VM_Crac: public VM_Operation {\n+  jarray _fd_arr;\n+  const bool _dry_run;\n+  bool _ok;\n+  GrowableArray<CracFailDep>* _failures;\n+  CracRestoreParameters _restore_parameters;\n+  outputStream* _ostream;\n+#ifdef LINUX\n+  LinuxAttachOperation* _attach_op;\n+#endif \/\/LINUX\n+\n+public:\n+  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n+    _fd_arr(fd_arr),\n+    _dry_run(dry_run),\n+    _ok(false),\n+    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n+    _restore_parameters(),\n+    _ostream(jcmd_stream ? jcmd_stream : tty)\n+#ifdef LINUX\n+    , _attach_op(jcmd_stream ? LinuxAttachListener::get_current_op() : NULL)\n+#endif \/\/LINUX\n+  { }\n+\n+  ~VM_Crac() {\n+    delete _failures;\n+  }\n+\n+  GrowableArray<CracFailDep>* failures() { return _failures; }\n+  bool ok() { return _ok; }\n+  const char* new_args() { return _restore_parameters.args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n+  virtual bool allow_nested_vm_operations() const  { return true; }\n+  VMOp_Type type() const { return VMOp_VM_Crac; }\n+  void doit();\n+  bool read_shm(int shmid);\n+\n+private:\n+  bool is_claimed_fd(int fd);\n+  bool is_socket_from_jcmd(int sock_fd);\n+  void report_ok_to_jcmd_if_any();\n+  void print_resources(const char* msg, ...);\n+  void trace_cr(const char* msg, ...);\n+  bool check_fds();\n+  bool memory_checkpoint();\n+  void memory_restore();\n+};\n+\n+class CracSHM {\n+  char _path[128];\n+public:\n+  CracSHM(int id) {\n+    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n+    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n+      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    }\n+  }\n+\n+  int open(int mode);\n+  void unlink();\n+};\n+\n+#endif \/\/SHARE_RUNTIME_CRAC_STRUCTS_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac_structs.hpp","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -408,0 +408,2 @@\n+    case JVMFlagOrigin::CRAC_RESTORE:\n+      st->print(\"crac restore\");\n@@ -531,3 +533,4 @@\n-const int DIAGNOSTIC   = JVMFlag::KIND_DIAGNOSTIC;\n-const int MANAGEABLE   = JVMFlag::KIND_MANAGEABLE;\n-const int EXPERIMENTAL = JVMFlag::KIND_EXPERIMENTAL;\n+const int DIAGNOSTIC       = JVMFlag::KIND_DIAGNOSTIC;\n+const int MANAGEABLE       = JVMFlag::KIND_MANAGEABLE;\n+const int EXPERIMENTAL     = JVMFlag::KIND_EXPERIMENTAL;\n+const int RESTORE_SETTABLE = JVMFlag::KIND_RESTORE_SETTABLE;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  CRAC_RESTORE     = 9,\n@@ -51,1 +52,1 @@\n-ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::JIMAGE_RESOURCE)\n+ENUMERATOR_RANGE(JVMFlagOrigin, JVMFlagOrigin::DEFAULT, JVMFlagOrigin::CRAC_RESTORE)\n@@ -74,1 +75,1 @@\n-\n+    KIND_RESTORE_SETTABLE   = 1 << 16,\n@@ -253,0 +254,1 @@\n+  bool is_restore_settable() const { return (_flags & (KIND_RESTORE_SETTABLE | KIND_MANAGEABLE)) != 0; }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n-\/\/ only with product\/product_pd flags.\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, MANAGEABLE or RESTORE_SETTABLE. Currently\n+\/\/ extra_attrs can be used only with product\/product_pd flags.\n@@ -101,0 +101,3 @@\n+\/\/ RESTORE_SETTABLE are flags that can be set during restore from a snapshot.\n+\/\/    All MANAGEABLE flags are implicitly RESTORE_SETTABLE but\n+\/\/    RESTORE_SETTABLE are not MANAGEABLE.\n@@ -2110,0 +2113,49 @@\n+                                                                            \\\n+  product(ccstr, CRaCCheckpointTo, NULL, RESTORE_SETTABLE,                  \\\n+        \"Path to checkpoint image directory\")                               \\\n+                                                                            \\\n+  product(ccstr, CRaCRestoreFrom, NULL, RESTORE_SETTABLE,                   \\\n+      \"Path to image for restore, replaces the initializing VM on success\") \\\n+                                                                            \\\n+  product(uint, CRaCMinPid, 128,                                            \\\n+      \"Mininal PID value for checkpoint'ed process\")                        \\\n+      range(1, UINT_MAX)                                                    \\\n+                                                                            \\\n+  product(ccstr, CREngine, \"criuengine\", RESTORE_SETTABLE,                  \\\n+      \"Path or name of a program implementing checkpoint\/restore and \"      \\\n+      \"optional extra parameters as a comma-separated list: \"               \\\n+      \"-XX:CREngine=program,--key,value,--anotherkey results in calling \"   \\\n+      \"'program --key value --anotherkey'. Commas used as part of args \"    \\\n+      \"should be escaped with a backslash character ('\\\\').\")               \\\n+                                                                            \\\n+  product(bool, CRaCIgnoreRestoreIfUnavailable, false, RESTORE_SETTABLE,    \\\n+      \"Ignore -XX:CRaCRestoreFrom and continue initialization if restore \"  \\\n+      \"is unavailable\")                                                     \\\n+                                                                            \\\n+  product(ccstr, CRaCIgnoredFileDescriptors, NULL, RESTORE_SETTABLE,        \\\n+      \"Comma-separated list of file descriptor numbers or paths. \"          \\\n+      \"All file descriptors greater than 2 (stdin, stdout and stderr are \"  \\\n+      \"excluded automatically) not in this list are closed when the VM \"    \\\n+      \"is started.\")                                                        \\\n+                                                                            \\\n+  product(bool, CRAllowToSkipCheckpoint, false, DIAGNOSTIC,                 \\\n+          \"Allow implementation to not call Checkpoint if helper not found\")\\\n+                                                                            \\\n+  product(bool, CRHeapDumpOnCheckpointException, false, DIAGNOSTIC,         \\\n+      \"Dump heap on CheckpointException thrown because of CRaC \"            \\\n+      \"precondition failed\")                                                \\\n+                                                                            \\\n+  product(bool, CRPrintResourcesOnCheckpoint, false, DIAGNOSTIC,            \\\n+      \"Print resources to decide CheckpointException\")                      \\\n+                                                                            \\\n+  product(bool, CRTraceStartupTime, false, DIAGNOSTIC,                      \\\n+      \"Trace startup time\")                                                 \\\n+                                                                            \\\n+  product(bool, CRDoThrowCheckpointException, true, EXPERIMENTAL,           \\\n+      \"Throw CheckpointException if uncheckpointable resource handle found\")\\\n+                                                                            \\\n+  product(bool, CRTrace, true, RESTORE_SETTABLE, \"Minimal C\/R tracing\")     \\\n+                                                                            \\\n+  product(bool, CRPauseOnCheckpointError, false, DIAGNOSTIC,                \\\n+      \"Pauses the checkpoint when a problem is found on VM level.\")\n+\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":54,"deletions":2,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -43,2 +43,0 @@\n-#include \"oops\/compressedOops.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n@@ -75,3 +73,0 @@\n-# include <signal.h>\n-# include <errno.h>\n-\n@@ -1774,0 +1769,7 @@\n+void os::cleanup_memory(char* addr, size_t bytes) {\n+  char* start = (char*)align_up(addr, os::vm_page_size());\n+  char* end = (char*)align_down(addr + bytes, os::vm_page_size());\n+  os::uncommit_memory(start, end - start);\n+  os::commit_memory(start, end - start, false);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -369,0 +369,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n@@ -539,0 +541,4 @@\n+  static int exec_child_process_and_wait(const char *path, const char *argv[]);\n+\n+  static int execv(const char *path, const char *argv[]);\n+\n@@ -590,0 +596,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -596,0 +605,2 @@\n+  static bool is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -2755,0 +2756,15 @@\n+jint Threads::check_for_restore(JavaVMInitArgs* args) {\n+  if (Arguments::is_restore_option_set(args)) {\n+    if (!Arguments::parse_options_for_restore(args)) {\n+      return JNI_ERR;\n+    }\n+    crac::restore();\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -2758,0 +2774,2 @@\n+  if (check_for_restore(args) != JNI_OK) return JNI_ERR;\n+\n@@ -2824,0 +2842,2 @@\n+  crac::vm_create_start();\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1637,0 +1637,1 @@\n+  void wakeup_sleep() { _SleepEvent->unpark(); }\n@@ -1708,0 +1709,2 @@\n+  static jint check_for_restore(JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-  template(JvmtiPostObjectFree)\n+  template(JvmtiPostObjectFree)                   \\\n+  template(VM_Crac)\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2604,0 +2604,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+#ifdef LINUX\n+#include \"attachListener_linux.hpp\"\n+#include \"linuxAttachOperation.hpp\"\n+#endif \/\/LINUX\n@@ -133,0 +137,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -798,1 +804,1 @@\n-  jvalue* jv = (jvalue*) result.get_value_addr();\n+  jvalue* jv = (jvalue*)result.get_value_addr();\n@@ -1044,0 +1050,26 @@\n+\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_crac_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::checkpointRestoreInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != NULL) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      outputStream* stream = output();\n+#ifdef LINUX\n+      assert(LinuxAttachListener::get_current_op(), \"should exist\");\n+      if (LinuxAttachListener::get_current_op()->is_effectively_completed()) {\n+        stream = tty;\n+      }\n+#endif \/\/LINUX\n+      stream->print_cr(\"An exception during a checkpoint operation:\");\n+      stream->print(\"%s\", out);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -905,0 +905,14 @@\n+class CheckpointDCmd : public DCmd {\n+public:\n+  CheckpointDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"JDK.checkpoint\"; }\n+    static const char* description() {\n+      return \"Checkpoint via jdk.crac.checkpointRestore().\";\n+    }\n+    static const char* impact() {\n+      return \"High: JVM terminates\";\n+    }\n+    static int num_arguments() { return 0; }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -953,0 +954,12 @@\n+  case JMM_JVM_RESTORE_START_TIME_MS:\n+    return crac::restore_start_time();\n+\n+  case JMM_JVM_UPTIME_SINCE_RESTORE_MS:\n+    {\n+      jlong ticks = crac::uptime_since_restore();\n+      if (ticks == -1) {\n+        return -1;\n+      }\n+      return Management::ticks_to_ms(ticks);\n+    }\n+\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-    \/\/ only writeable flags are allowed to be set\n-    if (f->is_writeable()) {\n+    \/\/ only writeable or restore_settable flags are allowed to be set\n+    if (f->is_writeable() || (f->is_restore_settable() && origin == JVMFlagOrigin::CRAC_RESTORE)) {\n","filename":"src\/hotspot\/share\/services\/writeableFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -242,0 +242,13 @@\n+#ifndef INCLUDE_CPU_FEATURE_ACTIVE\n+#define INCLUDE_CPU_FEATURE_ACTIVE 1\n+#endif \/\/ INCLUDE_CPU_FEATURE_ACTIVE\n+\n+#ifndef INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+#define INCLUDE_LD_SO_LIST_DIAGNOSTICS 1\n+#endif \/\/ INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+\n+#if INCLUDE_CPU_FEATURE_ACTIVE && INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+#undef  INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+#define INCLUDE_LD_SO_LIST_DIAGNOSTICS 0\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -28,0 +29,8 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n+import java.io.FileDescriptor;\n@@ -30,0 +39,1 @@\n+import java.nio.channels.IllegalSelectorException;\n@@ -48,0 +58,3 @@\n+ *\n+ * @crac The file descriptor(s) used internally by this class are automatically\n+ * closed before checkpointing the process and opened after the restore.\n@@ -49,2 +62,1 @@\n-\n-class EPollSelectorImpl extends SelectorImpl {\n+class EPollSelectorImpl extends SelectorImpl implements JDKResource {\n@@ -55,0 +67,27 @@\n+    private static final JavaIOFileDescriptorAccess fdAccess\n+            = SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    private enum CheckpointRestoreState {\n+        NORMAL_OPERATION,\n+        CHECKPOINT_TRANSITION,\n+        CHECKPOINTED,\n+        CHECKPOINT_ERROR,\n+        RESTORE_TRANSITION,\n+    }\n+\n+    private static class MoveToCheckpointThread extends Thread {\n+        private Selector selector;\n+\n+        MoveToCheckpointThread(Selector selector) {\n+            this.selector = selector;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                selector.select(1);\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+\n@@ -56,1 +95,1 @@\n-    private final int epfd;\n+    private int epfd;\n@@ -59,1 +98,1 @@\n-    private final long pollArrayAddress;\n+    private long pollArrayAddress;\n@@ -62,1 +101,1 @@\n-    private final EventFD eventfd;\n+    private EventFD eventfd;\n@@ -75,2 +114,1 @@\n-    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n-        super(sp);\n+    private volatile CheckpointRestoreState checkpointState = CheckpointRestoreState.NORMAL_OPERATION;;\n@@ -78,2 +116,2 @@\n-        this.epfd = EPoll.create();\n-        this.pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+    private void initFDs() throws IOException {\n+        epfd = EPoll.create();\n@@ -83,1 +121,4 @@\n-            IOUtil.configureBlocking(IOUtil.newFD(eventfd.efd()), false);\n+            FileDescriptor fd = IOUtil.newFD(eventfd.efd());\n+            \/\/ This FileDescriptor is a one-time use, the actual FD will be closed from EventFD\n+            fdAccess.markClosed(fd);\n+            IOUtil.configureBlocking(fd, false);\n@@ -94,0 +135,9 @@\n+    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n+        super(sp);\n+        pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+        initFDs();\n+        \/\/ trigger FileDispatcherImpl initialization\n+        new FileDispatcherImpl();\n+        Core.Priority.EPOLLSELECTOR.getContext().register(this);\n+    }\n+\n@@ -99,0 +149,47 @@\n+    private boolean processCheckpointRestore() throws IOException {\n+        assert Thread.holdsLock(this);\n+\n+        if (checkpointState != CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+            return false;\n+        }\n+\n+        synchronized (interruptLock) {\n+\n+            CheckpointRestoreState thisState;\n+            if (fdToKey.size() == 0) {\n+                eventfd.close();\n+                eventfd = null;\n+                FileDispatcherImpl.closeIntFD(epfd);\n+                thisState = CheckpointRestoreState.CHECKPOINTED;\n+            } else {\n+                thisState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+            }\n+\n+            checkpointState = thisState;\n+            interruptLock.notifyAll();\n+            while (checkpointState == thisState) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+\n+            assert checkpointState == CheckpointRestoreState.RESTORE_TRANSITION;\n+            if (thisState == CheckpointRestoreState.CHECKPOINTED) {\n+                initFDs();\n+            }\n+            checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+            interruptLock.notifyAll();\n+\n+            if (interruptTriggered) {\n+                try {\n+                    eventfd.set();\n+                } catch (IOException ioe) {\n+                    throw new InternalError(ioe);\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n@@ -118,1 +215,3 @@\n-                numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                do {\n+                    numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                } while (processCheckpointRestore());\n@@ -200,1 +299,1 @@\n-        if (interrupted) {\n+        if (interrupted && !(Thread.currentThread() instanceof MoveToCheckpointThread)) {\n@@ -267,0 +366,51 @@\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.CHECKPOINT_TRANSITION;\n+            eventfd.set();\n+            int tries = 5;\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION && 0 < tries--) {\n+                try {\n+                    interruptLock.wait(5);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                Thread thr = new MoveToCheckpointThread(this);\n+                thr.setDaemon(true);\n+                thr.start();\n+            }\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_ERROR) {\n+                throw new IllegalSelectorException();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.RESTORE_TRANSITION;\n+            interruptLock.notifyAll();\n+            while (checkpointState == CheckpointRestoreState.RESTORE_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":162,"deletions":12,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n+import java.util.*;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n@@ -32,0 +32,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n@@ -34,0 +36,1 @@\n+import jdk.internal.crac.*;\n@@ -58,0 +61,66 @@\n+    class Resource extends JDKFdResource {\n+        private boolean closedByNIO;\n+\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n+            if (!closedByNIO && valid()) {\n+                ClaimedFDs claimedFDs = Core.getClaimedFDs();\n+                FileDescriptor self = FileDescriptor.this;\n+                String nativeDescription = nativeDescription0();\n+\n+                OpenResourcePolicies.Policy policy = findPolicy(nativeDescription);\n+                String action = \"error\";\n+                Supplier<Exception> supplier = null;\n+                \/\/ Normally the claiming should be overridden by FileInputStream\/FileOutputStream\n+                \/\/ but in case these are collected we handle FDs 0..2 here as well.\n+                if (policy != null) {\n+                    action = policy.action;\n+                } else if (self == in || self == out || self == err) {\n+                    action = \"ignore\";\n+                }\n+                supplier = switch (action.toLowerCase()) {\n+                    case \"error\":\n+                        yield () -> new CheckpointOpenResourceException(\n+                            FileDescriptor.class.getSimpleName() + \" \" + fd + \": \" + nativeDescription,\n+                            getStackTraceHolder());\n+                    case \"close\":\n+                        close();\n+                    case \"ignore\":\n+                        warnOpenResource(policy, \"File descriptor \" + fd);\n+                        yield NO_EXCEPTION;\n+                    default: throw new IllegalArgumentException(\"Unknown policy action for file descriptor \" + fd + \": \" + action);\n+                };\n+                claimedFDs.claimFd(self, self, supplier);\n+            }\n+        }\n+\n+        private OpenResourcePolicies.Policy findPolicy(String nativeDescription) {\n+            return OpenResourcePolicies.find(false, \"filedescriptor\", params -> {\n+                String value = params.get(\"value\");\n+                if (value != null) {\n+                    try {\n+                        int expected = Integer.parseInt(value);\n+                        if (expected != fd) {\n+                            return false;\n+                        }\n+                    } catch (NumberFormatException e) {\n+                        throw new IllegalArgumentException(\"Cannot parse file descriptor value '\" + value + \"'\");\n+                    }\n+                }\n+                String regex = params.get(\"regex\");\n+                if (regex != null) {\n+                    return Pattern.compile(regex).matcher(nativeDescription).find();\n+                }\n+                return true;\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getName() + \"(FD \" + fd + \")\";\n+        }\n+    }\n+\n+    Resource resource = new Resource();\n+\n@@ -91,0 +160,5 @@\n+                    @Override\n+                    public void markClosed(FileDescriptor fdo) {\n+                        fdo.resource.closedByNIO = true;\n+                    }\n+\n@@ -300,0 +374,2 @@\n+    private native String nativeDescription0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":79,"deletions":3,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFileResource;\n@@ -519,0 +526,65 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (fd == FileDescriptor.in) {\n+                Core.getClaimedFDs().claimFd(fd, FileInputStream.this, NO_EXCEPTION, fd);\n+            } else {\n+                \/\/ When the stream is opened with file descriptor we don't have any extra\n+                \/\/ information we could use for policy (this is most often a pipe, but could\n+                \/\/ be a socket as well). Such cases need to be handled on a higher level.\n+                super.beforeCheckpoint(context);\n+            }\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            try {\n+                offset = position();\n+            } catch (IOException e) {\n+                \/\/ We might get IOException from native code when lseeking a named pipe.\n+                offset = 0;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path);\n+                if (offset > 0) {\n+                    skip(offset);\n+                }\n+                FileInputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -29,0 +29,8 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -31,0 +39,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -97,0 +106,10 @@\n+    \/**\n+     * When the file is opened in non-append mode we need to check position\n+     * through the {@link #channel} when handling the file descriptor policy;\n+     * this needs to be independent of the regular resource as we need to\n+     * ensure initialization of the channel before FD priority class.\n+     * This field being <code>null<\/code> means that the file is opened in\n+     * append-only mode and does not need to track the position.\n+     *\/\n+    private final EnsureChannelResource channelResource;\n+\n@@ -234,0 +253,5 @@\n+        if (append) {\n+            channelResource = null;\n+        } else {\n+            channelResource = new EnsureChannelResource();\n+        }\n@@ -273,0 +297,2 @@\n+        \/\/ We don't have path information and won't reopen the file\n+        this.channelResource = null;\n@@ -282,1 +308,1 @@\n-    private native void open0(String name, boolean append)\n+    private native void open0(String name, boolean append, boolean truncate)\n@@ -293,1 +319,1 @@\n-        open0(name, append);\n+        open0(name, append, !append);\n@@ -458,0 +484,77 @@\n+\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            if (channelResource != null) {\n+                FileChannel channel = getChannel();\n+                channelResource.position = channel.isOpen() ? channel.position() : -1;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            assert path != null; \/\/ won't be reopened if it was not closed, and won't be closed without path\n+            synchronized (closeLock) {\n+                \/\/ We have been writing to a file, but it disappeared during checkpoint\n+                if (!Files.exists(Path.of(path))) {\n+                    throw new IOException(\"File \" + path + \" is not present during restore\");\n+                }\n+                if (channelResource == null) {\n+                    open(path, true);\n+                } else {\n+                    open0(path, false, false);\n+                    \/\/noinspection resource\n+                    getChannel().position(channelResource.position);\n+                }\n+                FileOutputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n+    private class EnsureChannelResource implements JDKResource {\n+        public long position;\n+\n+        EnsureChannelResource() {\n+            \/\/ This must be before PRE_FILE_DESCRIPTORS as getChannel()\n+            \/\/ could clinit FileDispatcherImpl\n+            Core.Priority.NORMAL.getContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            \/\/ the channel is not used but we ensure its existence\n+            getChannel();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":105,"deletions":2,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -32,0 +33,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -66,0 +68,1 @@\n+    private final int imode;\n@@ -83,0 +86,31 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ We cannot synchronize this without making every other method call synchronized\n+            offset = getFilePointer();\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path, imode);\n+                seek(offset);\n+                RandomAccessFile.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n@@ -259,0 +293,1 @@\n+        this.imode = imode;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,0 +28,7 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -38,0 +45,1 @@\n+import java.util.function.Supplier;\n@@ -816,0 +824,1 @@\n+        private final JDKFdResource resource;\n@@ -819,0 +828,1 @@\n+            resource = new PipeResource(this, fd);\n@@ -844,0 +854,31 @@\n+    static class PipeResource extends JDKFdResource {\n+        private final Closeable owner;\n+        private final FileDescriptor fd;\n+\n+        PipeResource(Closeable owner, FileDescriptor fd) {\n+            this.owner = owner;\n+            this.fd = fd;\n+        }\n+\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            OpenResourcePolicies.Policy policy = OpenResourcePolicies.find(false, OpenResourcePolicies.PIPE, null);\n+            String action = policy != null ? policy.action.toLowerCase() : \"error\";\n+            Supplier<Exception> exceptionSupplier = switch (action) {\n+                case \"error\":\n+                    yield  () -> new CheckpointOpenResourceException(owner.toString(), getStackTraceHolder());\n+                case \"close\":\n+                    owner.close();\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    warnOpenResource(policy, owner.toString());\n+                    yield NO_EXCEPTION;\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + owner, null);\n+            };\n+            \/\/ FileInputStream does not claim when path is null\n+            Core.getClaimedFDs().claimFd(fd, this, exceptionSupplier, fd);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -33,5 +33,8 @@\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.StringJoiner;\n+import java.util.*;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -714,0 +717,2 @@\n+            \/\/ This creates a file descriptor but does not need own resource,\n+            \/\/ see PipelineResource.\n@@ -1275,11 +1280,18 @@\n-        try {\n-            Redirect prevOutput = null;\n-            for (int index = 0; index < builders.size(); index++) {\n-                ProcessBuilder builder = builders.get(index);\n-                Redirect[] redirects = builder.redirects();\n-                if (index > 0) {\n-                    \/\/ check the current Builder to see if it can take input from the previous\n-                    if (builder.redirectInput() != Redirect.PIPE) {\n-                        throw new IllegalArgumentException(\"builder redirectInput()\" +\n-                                \" must be PIPE except for the first builder: \"\n-                                + builder.redirectInput());\n+        \/\/ This resource helps us block the checkpoint until all subprocesses\n+        \/\/ are created; after that we won't need the FileDescriptors and can safely\n+        \/\/ close these.\n+        PipelineResource pipelineResource = new PipelineResource();\n+        synchronized (pipelineResource) {\n+            try (pipelineResource) {\n+                Redirect prevOutput = null;\n+                for (int index = 0; index < builders.size(); index++) {\n+                    ProcessBuilder builder = builders.get(index);\n+                    Redirect[] redirects = builder.redirects();\n+                    if (index > 0) {\n+                        \/\/ check the current Builder to see if it can take input from the previous\n+                        if (builder.redirectInput() != Redirect.PIPE) {\n+                            throw new IllegalArgumentException(\"builder redirectInput()\" +\n+                                    \" must be PIPE except for the first builder: \"\n+                                    + builder.redirectInput());\n+                        }\n+                        redirects[0] = prevOutput;\n@@ -1287,8 +1299,10 @@\n-                    redirects[0] = prevOutput;\n-                }\n-                if (index < numBuilders - 1) {\n-                    \/\/ check all but the last stage has output = PIPE\n-                    if (builder.redirectOutput() != Redirect.PIPE) {\n-                        throw new IllegalArgumentException(\"builder redirectOutput()\" +\n-                                \" must be PIPE except for the last builder: \"\n-                                + builder.redirectOutput());\n+                    if (index < numBuilders - 1) {\n+                        \/\/ check all but the last stage has output = PIPE\n+                        if (builder.redirectOutput() != Redirect.PIPE) {\n+                            throw new IllegalArgumentException(\"builder redirectOutput()\" +\n+                                    \" must be PIPE except for the last builder: \"\n+                                    + builder.redirectOutput());\n+                        }\n+                        RedirectPipeImpl redirectPipe = new RedirectPipeImpl();\n+                        redirects[1] = redirectPipe;  \/\/ placeholder for new output\n+                        pipelineResource.addRedirect(redirectPipe);\n@@ -1296,3 +1310,1 @@\n-                    redirects[1] = new RedirectPipeImpl();  \/\/ placeholder for new output\n-                }\n-                processes.add(builder.start(redirects));\n+                    processes.add(builder.start(redirects));\n@@ -1303,11 +1315,1 @@\n-                prevOutput = redirects[1];\n-            }\n-        } catch (Exception ex) {\n-            \/\/ Cleanup processes already started\n-            processes.forEach(Process::destroyForcibly);\n-            processes.forEach(p -> {\n-                try {\n-                    p.waitFor();        \/\/ Wait for it to exit\n-                } catch (InterruptedException ie) {\n-                    \/\/ If interrupted; continue with next Process\n-                    Thread.currentThread().interrupt();\n+                    prevOutput = redirects[1];\n@@ -1315,2 +1317,13 @@\n-            });\n-            throw ex;\n+            } catch (Exception ex) {\n+                \/\/ Cleanup processes already started\n+                processes.forEach(Process::destroyForcibly);\n+                processes.forEach(p -> {\n+                    try {\n+                        p.waitFor();        \/\/ Wait for it to exit\n+                    } catch (InterruptedException ie) {\n+                        \/\/ If interrupted; continue with next Process\n+                        Thread.currentThread().interrupt();\n+                    }\n+                });\n+                throw ex;\n+            }\n@@ -1320,0 +1333,32 @@\n+\n+    private static class PipelineResource implements JDKResource, AutoCloseable {\n+        private static final JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+        private final List<RedirectPipeImpl> redirects = new ArrayList<>();\n+\n+        public PipelineResource() {\n+            Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+        }\n+\n+        @Override\n+        public synchronized void beforeCheckpoint(Context<? extends Resource> context) {\n+            \/\/ Noop, but this method is synchronized\n+            assert redirects.isEmpty();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+\n+        public void addRedirect(RedirectPipeImpl redirect) {\n+            this.redirects.add(redirect);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            \/\/ The file descriptors won't be used by this process\n+            for (RedirectPipeImpl r : redirects) {\n+                fdAccess.close(r.getFd());\n+            }\n+            redirects.clear();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":85,"deletions":40,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -547,0 +547,5 @@\n+     * @crac When the process is restored on another machine or if the machine\n+     * rebooted the value is updated based on wall-clock time difference,\n+     * resulting in a loss of accuracy when comparing timestamps obtained\n+     * before and after checkpoint.\n+     *\n@@ -783,0 +788,6 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload system properties in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -897,0 +908,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -933,0 +947,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -1087,0 +1104,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload environment variables in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -1140,0 +1163,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload the environment variables in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.crac.Core;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -329,0 +333,10 @@\n+\n+            @Override\n+            public <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException {\n+                return queue.poll(timeout);\n+            }\n+\n+            @Override\n+            public void wakeupReferenceQueue(ReferenceQueue<?> queue) {\n+                queue.wakeup();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -124,0 +124,16 @@\n+    Reference<? extends T> poll(long timeout) throws InterruptedException {\n+        synchronized (lock) {\n+            Reference<? extends T> r = reallyPoll();\n+            if (r != null) return r;\n+            \/\/ any wake (including spurious) ends the wait\n+            lock.wait(timeout);\n+            return reallyPoll();\n+        }\n+    }\n+\n+    void wakeup() {\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.crac.JDKSocketResource;\n+import sun.nio.ch.Net;\n+\n@@ -75,0 +78,23 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() {\n+            disconnect();\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n@@ -51,0 +53,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -191,0 +195,6 @@\n+ * @crac This class holds a cache of resolved hostname-address pairs;\n+ * this cache is wiped out before checkpoint. Therefore, lookups after restore\n+ * will cause name address resolution.\n+ * This ensures that the addresses are up-to-date in the environment where\n+ * the process is restored.\n+ *\n@@ -304,0 +314,3 @@\n+    \/* Resource registration uses weak references; we need to keep it locally. *\/\n+    private static final JDKResource checkpointListener;\n+\n@@ -344,0 +357,14 @@\n+        \/\/ DNS cache is cleared before the checkpoint; application restored at a later point\n+        \/\/ or in a different environment should query DNS again.\n+        checkpointListener = new JDKResource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                cache.clear();\n+                expirySet.clear();\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            }\n+        };\n+        Core.Priority.NORMAL.getContext().register(checkpointListener);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -30,0 +31,1 @@\n+import java.io.FileDescriptor;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -39,0 +40,1 @@\n+import sun.nio.ch.Net;\n@@ -107,0 +109,23 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return new InetSocketAddress(address, port);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -217,0 +217,4 @@\n+     *\n+     * @crac Instances created by this constructor are automatically reseeded\n+     * after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n@@ -259,0 +263,4 @@\n+     * @crac Instances created by this constructor are <strong>not<\/strong>\n+     * reseeded after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n+     *\n@@ -358,0 +366,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -405,0 +415,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -449,0 +461,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -496,0 +510,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -553,0 +569,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -606,0 +624,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -325,0 +325,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n@@ -369,0 +374,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/Timer.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -150,0 +150,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n@@ -189,0 +194,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledExecutorService.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -66,0 +67,1 @@\n+import jdk.internal.crac.Core;\n@@ -809,0 +811,8 @@\n+\n+        public void beforeCheckpoint() {\n+            if (zsrc != null) {\n+                synchronized (zsrc) {\n+                    zsrc.beforeCheckpoint();\n+                }\n+            }\n+        }\n@@ -1089,0 +1099,4 @@\n+    private synchronized void beforeCheckpoint() {\n+        res.beforeCheckpoint();\n+    }\n+\n@@ -1149,2 +1163,5 @@\n-\n-             }\n+                @Override\n+                public void beforeCheckpoint(ZipFile zip) {\n+                    zip.beforeCheckpoint();\n+                }\n+            }\n@@ -1951,0 +1968,13 @@\n+\n+        public void beforeCheckpoint() {\n+            synchronized (zfile) {\n+                FileDescriptor fd = null;\n+                try {\n+                    fd = zfile.getFD();\n+                } catch (IOException e) {\n+                }\n+                if (fd != null) {\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+                }\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * This exception works as an aggregate for all errors found during checkpoint;\n+ * these are recorded as {@linkplain #getSuppressed() suppressed exceptions}.\n+ * The exception does not have any own message, cause nor collects stack trace.\n+ *\/\n+public final class CheckpointException extends Exception {\n+    private static final long serialVersionUID = 6859967688386143096L;\n+\n+    \/**\n+     * Creates a {@code CheckpointException}.\n+     *\/\n+    public CheckpointException() {\n+        super(null, null, true, false);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/CheckpointException.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * A {@code Resource} that allows other {@code Resource}s to be registered with it.\n+ *\n+ * <p>{@code Context} implementation overrides {@code beforeCheckpoint} and {@code afterRestore}, defining how the notification about checkpoint and restore will be distributed by the {@code Context} hierarchy.\n+ *\n+ * <p>A {@code Context} implementor is encouraged to respect properties of the global {@code Context}.\n+ *\/\n+public abstract class Context<R extends Resource> implements Resource {\n+\n+    \/** Creates a {@code Context}.\n+     *\/\n+    protected Context() {\n+    }\n+\n+    @Override\n+    public abstract void beforeCheckpoint(Context<? extends Resource> context)\n+            throws CheckpointException;\n+\n+    @Override\n+    public abstract void afterRestore(Context<? extends Resource> context)\n+            throws RestoreException;\n+\n+    \/**\n+     * Registers a {@code Resource} with this {@code Context}.\n+     *\n+     * @param resource {@code Resource} to be registered.\n+     * @throws NullPointerException if {@code resource} is {@code null}\n+     *\/\n+    public abstract void register(R resource);\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Context.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+class ContextWrapper extends Context<Resource> {\n+    private final jdk.crac.Context<jdk.crac.Resource> context;\n+\n+    public ContextWrapper(jdk.crac.Context<jdk.crac.Resource> context) {\n+        this.context = context;\n+    }\n+\n+    private static jdk.crac.Context<? extends jdk.crac.Resource> convertContext(\n+            Context<? extends Resource> context) {\n+        return context instanceof ContextWrapper ?\n+                ((ContextWrapper)context).context :\n+                null;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context)\n+            throws CheckpointException {\n+        try {\n+            this.context.beforeCheckpoint(convertContext(context));\n+        } catch (jdk.crac.CheckpointException e) {\n+            CheckpointException newException = new CheckpointException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context)\n+            throws RestoreException {\n+        try {\n+            this.context.afterRestore(convertContext(context));\n+        } catch (jdk.crac.RestoreException e) {\n+            RestoreException newException = new RestoreException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        }\n+    }\n+\n+    @Override\n+    public void register(Resource r) {\n+        ResourceWrapper wrapper = new ResourceWrapper(this, r);\n+        context.register(wrapper);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ContextWrapper[\" + context.toString() + \"]\";\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/ContextWrapper.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+import jdk.crac.impl.BlockingOrderedContext;\n+import jdk.crac.impl.OrderedContext;\n+\n+\/**\n+ * The coordination service.\n+ *\/\n+public class Core {\n+\n+    \/** This class is not instantiable. *\/\n+    private Core() {\n+    }\n+\n+    private static final Context<Resource> globalContext = new ContextWrapper(\n+        jdk.crac.impl.GlobalContext.createGlobalContextImpl());\n+\n+    static {\n+        jdk.crac.Core.getGlobalContext().register(new ResourceWrapper(null, globalContext));\n+    }\n+\n+    \/**\n+     * Gets the global {@code Context} for checkpoint\/restore notifications.\n+     *\n+     * @return the global {@code Context}\n+     *\/\n+    public static Context<Resource> getGlobalContext() {\n+        return globalContext;\n+    }\n+\n+    \/**\n+     * Requests checkpoint and returns upon a successful restore.\n+     * May throw an exception if the checkpoint or restore are unsuccessful.\n+     *\n+     * @throws CheckpointException if an exception occured during checkpoint\n+     * notification and the execution continues in the original Java instance.\n+     * @throws RestoreException if an exception occured during restore\n+     * notification and execution continues in a new Java instance.\n+     * @throws UnsupportedOperationException if checkpoint\/restore is not\n+     * supported, no notification performed and the execution continues in\n+     * the original Java instance.\n+     *\/\n+    public static void checkpointRestore() throws\n+            CheckpointException,\n+            RestoreException {\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (jdk.crac.CheckpointException e) {\n+            CheckpointException newException = new CheckpointException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        } catch (jdk.crac.RestoreException e) {\n+            RestoreException newException = new RestoreException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * An interface for receiving checkpoint\/restore notifications.\n+ *\n+ * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * implements this interface, and the object created with that class is\n+ * registered with a {@code Context}, using {@code register} method.\n+ *\/\n+public interface Resource {\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about checkpoint.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void beforeCheckpoint(Context<? extends Resource> context) throws Exception;\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about restore.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void afterRestore(Context<? extends Resource> context) throws Exception;\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Resource.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.WeakHashMap;\n+\n+class ResourceWrapper extends WeakReference<Resource> implements jdk.crac.Resource {\n+    private static WeakHashMap<Resource, ResourceWrapper> weakMap = new WeakHashMap<>();\n+\n+    \/\/ Create strong reference to avoid losing the Resource.\n+    \/\/ It's set unconditionally in beforeCheckpoint and cleaned in afterRestore\n+    \/\/ (latter is called regardless of beforeCheckpoint result).\n+    private Resource strongRef;\n+\n+    private final Context<Resource> context;\n+\n+    public ResourceWrapper(Context<Resource> context, Resource resource) {\n+        super(resource);\n+        weakMap.put(resource, this);\n+        strongRef = null;\n+        this.context = context;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ResourceWrapper[\" + get().toString() + \"]\";\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(jdk.crac.Context<? extends jdk.crac.Resource> context)\n+            throws Exception {\n+        Resource r = get();\n+        strongRef = r;\n+        if (r != null) {\n+            try {\n+                r.beforeCheckpoint(this.context);\n+            } catch (CheckpointException e) {\n+                Exception newException = new jdk.crac.CheckpointException();\n+                for (Throwable t : e.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                throw newException;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(jdk.crac.Context<? extends jdk.crac.Resource> context) throws Exception {\n+        Resource r = get();\n+        strongRef = null;\n+        if (r != null) {\n+            try {\n+                r.afterRestore(this.context);\n+            } catch (RestoreException e) {\n+                Exception newException = new jdk.crac.RestoreException();\n+                for (Throwable t : e.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                throw newException;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/ResourceWrapper.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * This exception works as an aggregate for all errors found during checkpoint;\n+ * these are recorded as {@linkplain #getSuppressed() suppressed exceptions}.\n+ * The exception does not have any own message, cause nor collects stack trace.\n+ *\/\n+public final class RestoreException extends Exception {\n+    private static final long serialVersionUID = -4091592505524280559L;\n+\n+    \/**\n+     * Creates a {@code RestoreException}.\n+     *\/\n+    public RestoreException() {\n+        super(null, null, true, false);\n+    }\n+}\n+\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/RestoreException.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides explicit coordination with a checkpoint\/restore mechanism.\n+ * A checkpoint\/restore implementation may capture process or application state images for later continuation.\n+ * Coordination allows application code to prepare for a checkpoint and to adapt to changes in the execution environment after a restore.\n+ * <p>\n+ * Successful checkpointing and restoration may require that no checkpointed state exist that might not be validly reproducible when\n+restoring instances from the image.\n+ * Coordination enables application to proactively discard problematic state ahead of checkpointing, and to reestablish needed state upon restoration.\n+ * A Java implementation may provide detection of some subsets of state that are known to prevent successful checkpoints.\n+ * <p>\n+ * For example, a state of opened file descriptors or socket may be impossible to store in the image.\n+ * The implementation may detect such resources and then prevent checkpoint.\n+ * The application must then close file descriptors and sockets to be successfully checkpointed.\n+ * Files and sockets may be opened back after restore, then the application is responsible for processing possible exceptions.\n+ * <p>\n+ * {@link Resource} is an interface for receiving checkpoint\/restore notifications.\n+ * In order to be notified, {@code Resource} needs to be registered in a {@link Context}.\n+ * {@link Core} is a core interface for coordination. It provides the global {@code Context} which can be used as default choice.\n+ * The global {@code Context} have properties listed below, one can define a custom {@code Context} and register it with the global one.\n+ * {@code Core} has also a method to request checkpoint.\n+ * <p>\n+ * Methods of {@code Resource} are invoked as a notification of checkpoint and restore.\n+ * If a {@code Resource} is incapable to process notification, corresponding method throws an exception.\n+ * The global {@code Context} ensures that exceptions are propagated to a requester of checkpoint\/restore.\n+ * <p>\n+ * {@code Context} is a {@code Resource}, that allows other {@code Resource}s to be registered with it.\n+ * {@code Context} defines how {@code Resource}s are notified and may provide different guarantees compared to the global {@code Context}, such as order of notification.\n+ * A class may extend {@code Context} and define custom rules of notification processing by overriding {@code Resource} method.\n+ * Since a {@code Context} may be registered with other {@code Context}, they form a {@code Context} hierarchy.\n+ * <p>\n+ * Checkpoint can requested by {@code Core.checkpointRestore} or by some other way.\n+ * Then checkpoint notification of the global {@code Context} is performed.\n+ * If the global {@code Context} have not thrown {@code CheckpointException}, the current Java instance is used to create the image in a platform dependent way.\n+ * The current instance is terminated.\n+ * Later, a new instance is created by some means, for example via Java launcher in a special mode.\n+ * The new instance is started at the point where the image was created, it is followed by the restore notification.\n+ * Exceptions from restore notification are provided as suppressed ones by a {@code RestoreException} (in a sense of {@link Throwable#addSuppressed}).\n+ * <p>\n+ * If the global {@code Context} throws an exception during checkpoint notification then restore notificaion starts immediately without the image creation.\n+ * In this case, exceptions from checkpoint and restore notifications are provided as suppressed ones by {@code CheckpointException}.\n+ * <p>\n+ * {@code UnsupportedOperationException} is thrown if the service is not supported.\n+ * No notification is performed in this case.\n+ * <h2>Global Context Properties<\/h2>\n+ * Java Runtime maintains the global {@code Context} with following properties.\n+ * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n+ * <ul>\n+ * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n+ * <\/li>\n+ * <li>Order of checkpoint notification is the reverse order of registration.\n+ * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n+ * <\/li>\n+ * <li>For single {@code Resource} registered in this {@code Context}:\n+ * <ul>\n+ *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n+ *   <\/li>\n+ *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n+ *   <\/li>\n+ *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ * <\/ul>\n+ * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * @since TBD\n+ *\/\n+\n+package javax.crac;\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/package-info.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * This exception works as an aggregate for all errors found during checkpoint;\n+ * these are recorded as {@linkplain #getSuppressed() suppressed exceptions}.\n+ * The exception does not have any own message, cause nor collects stack trace.\n+ *\/\n+public final class CheckpointException extends Exception {\n+    private static final long serialVersionUID = 8879167591426115859L;\n+\n+    \/**\n+     * Creates a {@code CheckpointException}.\n+     *\/\n+    public CheckpointException() {\n+        super(null, null, true, false);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/CheckpointException.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * A {@code Resource} that allows other {@code Resource}s to be registered with it.\n+ *\n+ * <p>{@code Context} implementation overrides {@code beforeCheckpoint} and {@code afterRestore}, defining how the notification about checkpoint and restore will be distributed by the {@code Context} hierarchy.\n+ *\n+ * <p>A {@code Context} implementor is encouraged to respect properties of the global {@code Context}.\n+ *\/\n+public abstract class Context<R extends Resource> implements Resource {\n+\n+    \/** Creates a {@code Context}.\n+     *\/\n+    protected Context() {\n+    }\n+\n+    @Override\n+    public abstract void beforeCheckpoint(Context<? extends Resource> context)\n+            throws CheckpointException;\n+\n+    @Override\n+    public abstract void afterRestore(Context<? extends Resource> context)\n+            throws RestoreException;\n+\n+    \/**\n+     * Registers a {@code Resource} with this {@code Context}.\n+     *\n+     * @param resource {@code Resource} to be registered.\n+     * @throws NullPointerException if {@code resource} is {@code null}\n+     *\/\n+    public abstract void register(R resource);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Context.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,324 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+import jdk.crac.impl.*;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.ClaimedFDs;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.LoggerContainer;\n+import sun.security.action.GetBooleanAction;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * The coordination service.\n+ *\/\n+public class Core {\n+    private static final int JVM_CHECKPOINT_OK    = 0;\n+    private static final int JVM_CHECKPOINT_ERROR = 1;\n+    private static final int JVM_CHECKPOINT_NONE  = 2;\n+\n+    private static final int JVM_CR_FAIL = 0;\n+    private static final int JVM_CR_FAIL_FILE = 1;\n+    private static final int JVM_CR_FAIL_SOCK = 2;\n+    private static final int JVM_CR_FAIL_PIPE = 3;\n+\n+    private static final long JCMD_STREAM_NULL = 0;\n+    private static native Object[] checkpointRestore0(int[] fdArr, Object[] objArr, boolean dryRun, long jcmdStream);\n+    private static final Object checkpointRestoreLock = new Object();\n+    private static boolean checkpointInProgress = false;\n+\n+    private static class FlagsHolder {\n+        private FlagsHolder() {}\n+        public static final boolean TRACE_STARTUP_TIME =\n+            GetBooleanAction.privilegedGetProperty(\"jdk.crac.trace-startup-time\");\n+    }\n+\n+    private static final Context<Resource> globalContext = GlobalContext.createGlobalContextImpl();\n+\n+    private static class ReferenceHandlerResource implements JDKResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            System.gc();\n+            \/\/ TODO ensure GC done processing all References\n+            while (SharedSecrets.getJavaLangRefAccess().waitForReferenceProcessing());\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+\n+        private static ReferenceHandlerResource resource = new ReferenceHandlerResource();\n+\n+        static {\n+            jdk.internal.crac.Core.Priority.REFERENCE_HANDLER.getContext().register(resource);\n+        }\n+\n+        \/**\n+         * Performs one-time registration of the Reference handling resource\n+         *\/\n+        public static void register() {\n+            \/\/ nothing to do: the resource registered in the static initializer\n+        }\n+    }\n+\n+    \/** This class is not instantiable. *\/\n+    private Core() {\n+    }\n+\n+    private static void translateJVMExceptions(int[] codes, String[] messages,\n+                                               ExceptionHolder<CheckpointException> exception) {\n+        assert codes.length == messages.length;\n+        \/\/ When the CR engine fails (e.g. due to permissions, missing binaries...)\n+        \/\/ there are no messages recorded, but the user would end up with an empty\n+        \/\/ CheckpointException without stack trace nor message.\n+        if (codes.length == 0) {\n+            exception.handle(new RuntimeException(\"Native checkpoint failed.\"));\n+        }\n+\n+        for (int i = 0; i < codes.length; ++i) {\n+            Exception ex = switch (codes[i]) {\n+                case JVM_CR_FAIL_FILE -> new CheckpointOpenFileException(messages[i], null);\n+                case JVM_CR_FAIL_SOCK -> new CheckpointOpenSocketException(messages[i], null);\n+                case JVM_CR_FAIL_PIPE -> new CheckpointOpenResourceException(messages[i], null);\n+                default -> new CheckpointOpenResourceException(messages[i], null);\n+            };\n+            exception.handle(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Gets the global {@code Context} for checkpoint\/restore notifications.\n+     *\n+     * @return the global {@code Context}\n+     *\/\n+    public static Context<Resource> getGlobalContext() {\n+        return globalContext;\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private static void checkpointRestore1(long jcmdStream) throws\n+            CheckpointException,\n+            RestoreException {\n+        final ExceptionHolder<CheckpointException> checkpointException = new ExceptionHolder<>(CheckpointException::new);\n+\n+        \/\/ Register the resource here late, to avoid early registration\n+        \/\/ during JDK initialization, e.g. if performed during j.l.r.Reference\n+        \/\/ initialization.\n+        ReferenceHandlerResource.register();\n+\n+        \/\/ FIXME: log something to complete logger initialization:\n+        \/\/ - call sites in logger formatters.\n+        \/\/ - FileDescriptors for resources (sun.util.calendar.ZoneInfoFile)\n+        LoggerContainer.info(\"Starting checkpoint\");\n+        LoggerContainer.debug(\"at epoch:{0}\", System.currentTimeMillis());\n+\n+        ClaimedFDs claimedFDs = new ClaimedFDs();\n+\n+        jdk.internal.crac.Core.setClaimedFDs(claimedFDs);\n+        try {\n+            globalContext.beforeCheckpoint(null);\n+        } catch (CheckpointException ce) {\n+            checkpointException.handle(ce);\n+        }\n+        jdk.internal.crac.Core.setClaimedFDs(null);\n+\n+        List<ClaimedFDs.Descriptor> claimedList = claimedFDs.getClaimedFds();\n+        int[] fdArr = new int[claimedList.size()];\n+        LoggerContainer.debug(\"Claimed open file descriptors:\");\n+        for (int i = 0; i < claimedList.size(); ++i) {\n+            ClaimedFDs.Descriptor desc = claimedList.get(i);\n+            LoggerContainer.debug(\"\\t{0} {1} {2}\", desc.getFd(), desc.getClaimer(), desc.getExceptionSupplier());\n+            fdArr[i] = desc.getFd();\n+\n+            Supplier<Exception> exceptionSupplier = desc.getExceptionSupplier();\n+            if (exceptionSupplier != null) {\n+                Exception e = exceptionSupplier.get();\n+                checkpointException.handle(e);\n+            }\n+        }\n+\n+        final Object[] bundle = checkpointRestore0(fdArr, null, checkpointException.hasException(), jcmdStream);\n+        final int retCode = (null == bundle) ? JVM_CHECKPOINT_NONE : (Integer)bundle[0];\n+        final String newArguments = (null == bundle) ? null : (String)bundle[1];\n+        final String[] newProperties = (null == bundle) ? null : (String[])bundle[2];\n+        final int[] codes = (null == bundle) ? null : (int[])bundle[3];\n+        final String[] messages = (null == bundle) ? null : (String[])bundle[4];\n+\n+        if (FlagsHolder.TRACE_STARTUP_TIME) {\n+            System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore\");\n+        }\n+\n+        if (retCode != JVM_CHECKPOINT_OK) {\n+            switch (retCode) {\n+                case JVM_CHECKPOINT_ERROR -> translateJVMExceptions(codes, messages, checkpointException);\n+                case JVM_CHECKPOINT_NONE -> checkpointException.handle(new RuntimeException(\"C\/R is not configured\"));\n+                default ->                  checkpointException.handle(new RuntimeException(\"Unknown C\/R result: \" + retCode));\n+            }\n+        }\n+\n+        if (newProperties != null && newProperties.length > 0) {\n+            \/\/ Do not use lambda here since lambda will introduce registration\n+            \/\/ during checkpoint, which may cause dead loop.\n+            Arrays.stream(newProperties).map(new Function<String, String[]>() {\n+                @Override\n+                public String[] apply(String propStr) {\n+                    return propStr.split(\"=\", 2);\n+                }\n+            }).forEach(new Consumer<String[]>() {\n+                @Override\n+                public void accept(String[] pair) {\n+                    AccessController.doPrivileged(\n+                            new PrivilegedAction<String>() {\n+                                @Override\n+                                public String run() {\n+                                    return System.setProperty(pair[0], pair.length == 2 ? pair[1] : \"\");\n+                                }\n+                            });\n+                }\n+            });\n+        }\n+\n+        ExceptionHolder<RestoreException> restoreException = new ExceptionHolder<>(RestoreException::new);\n+        try {\n+            globalContext.afterRestore(null);\n+        } catch (RestoreException re) {\n+            if (checkpointException.hasException()) {\n+                checkpointException.resuppress(re);\n+            } else {\n+                restoreException.handle(re);\n+            }\n+        }\n+\n+        if (newArguments != null && newArguments.length() > 0) {\n+            String[] args = newArguments.split(\" \");\n+            if (args.length > 0) {\n+                try {\n+                    Method newMain = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n+                       @Override\n+                       public Method run() throws Exception {\n+                           Class < ?> newMainClass = Class.forName(args[0], false,\n+                               ClassLoader.getSystemClassLoader());\n+                           Method newMain = newMainClass.getDeclaredMethod(\"main\",\n+                               String[].class);\n+                           newMain.setAccessible(true);\n+                           return newMain;\n+                       }\n+                    });\n+                    newMain.invoke(null,\n+                        (Object)Arrays.copyOfRange(args, 1, args.length));\n+                } catch (PrivilegedActionException |\n+                         InvocationTargetException |\n+                         IllegalAccessException e) {\n+                    assert !checkpointException.hasException() :\n+                        \"should not have new arguments\";\n+                    restoreException.handle(e);\n+                }\n+            }\n+        }\n+\n+        assert !checkpointException.hasException() || !restoreException.hasException();\n+        checkpointException.throwIfAny();\n+        restoreException.throwIfAny();\n+    }\n+\n+    \/**\n+     * Requests checkpoint and returns upon a successful restore.\n+     * May throw an exception if the checkpoint or restore are unsuccessful.\n+     *\n+     * @throws CheckpointException if an exception occured during checkpoint\n+     * notification and the execution continues in the original Java instance.\n+     * @throws RestoreException if an exception occured during restore\n+     * notification and execution continues in a new Java instance.\n+     * @throws UnsupportedOperationException if checkpoint\/restore is not\n+     * supported, no notification performed and the execution continues in\n+     * the original Java instance.\n+     *\/\n+    public static void checkpointRestore() throws\n+            CheckpointException,\n+            RestoreException {\n+        checkpointRestore(JCMD_STREAM_NULL);\n+    }\n+\n+    @SuppressWarnings(\"try\")\n+    private static void checkpointRestore(long jcmdStream) throws\n+            CheckpointException,\n+            RestoreException {\n+        \/\/ checkpointRestoreLock protects against the simultaneous\n+        \/\/ call of checkpointRestore from different threads.\n+        synchronized (checkpointRestoreLock) {\n+            \/\/ checkpointInProgress protects against recursive\n+            \/\/ checkpointRestore from resource's\n+            \/\/ beforeCheckpoint\/afterRestore methods\n+            if (checkpointInProgress) {\n+                CheckpointException ex = new CheckpointException();\n+                ex.addSuppressed(new IllegalStateException(\"Recursive checkpoint is not allowed\"));\n+                throw ex;\n+            }\n+\n+            try (@SuppressWarnings(\"unused\") var keepAlive = new KeepAlive()) {\n+                checkpointInProgress = true;\n+                checkpointRestore1(jcmdStream);\n+            } finally {\n+                if (FlagsHolder.TRACE_STARTUP_TIME) {\n+                    System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore-finish\");\n+                }\n+                checkpointInProgress = false;\n+            }\n+        }\n+    }\n+\n+    \/* called by VM *\/\n+    private static String checkpointRestoreInternal(long jcmdStream) {\n+        try {\n+            checkpointRestore(jcmdStream);\n+        } catch (CheckpointException e) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+            e.printStackTrace(pw);\n+            return sw.toString();\n+        } catch (RestoreException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":324,"deletions":0,"binary":false,"changes":324,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * An interface for receiving checkpoint\/restore notifications.\n+ *\n+ * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * implements this interface, and the object created with that class is\n+ * registered with a {@code Context}, using {@code register} method.\n+ *\/\n+public interface Resource {\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about checkpoint.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void beforeCheckpoint(Context<? extends Resource> context) throws Exception;\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about restore.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void afterRestore(Context<? extends Resource> context) throws Exception;\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Resource.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * This exception works as an aggregate for all errors found during restore;\n+ * these are recorded as {@linkplain #getSuppressed() suppressed exceptions}.\n+ * The exception does not have any own message, cause nor collects stack trace.\n+ *\/\n+public final class RestoreException extends Exception {\n+    private static final long serialVersionUID = 5235124335683732665L;\n+\n+    \/**\n+     * Creates a {@code RestoreException}.\n+     *\/\n+    public RestoreException() {\n+        super(null, null, true, false);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/RestoreException.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+import jdk.crac.*;\n+import jdk.internal.crac.LoggerContainer;\n+\n+import java.util.List;\n+\n+\/**\n+ * An abstract context with few utilities.\n+ * @param <R> Type of Resource managed by the context.\n+ *\/\n+public abstract class AbstractContext<R extends Resource> extends Context<R> {\n+    protected abstract List<R> checkpointSnapshot();\n+    protected abstract List<R> restoreSnapshot();\n+\n+    protected void invokeBeforeCheckpoint(Resource resource) throws Exception {\n+        LoggerContainer.debug(\"beforeCheckpoint {0}\", resource);\n+        resource.beforeCheckpoint(this);\n+    }\n+\n+    protected void invokeAfterRestore(Resource resource) throws Exception {\n+        LoggerContainer.debug(\"afterRestore {0}\", resource);\n+        resource.afterRestore(this);\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        ExceptionHolder<CheckpointException> checkpointException =\n+            new ExceptionHolder<>(CheckpointException::new);\n+        List<R> resources = checkpointSnapshot();\n+        for (R r : resources) {\n+            try {\n+                invokeBeforeCheckpoint(r);\n+            } catch (Exception e) {\n+                checkpointException.handle(e);\n+            }\n+        }\n+        checkpointException.throwIfAny();\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        ExceptionHolder<RestoreException> restoreException =\n+            new ExceptionHolder<>(RestoreException::new);\n+        List<R> resources = restoreSnapshot();\n+        for (R r : resources) {\n+            try {\n+                invokeAfterRestore(r);\n+            } catch (Exception e) {\n+                restoreException.handle(e);\n+            }\n+        }\n+        restoreException.throwIfAny();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContext.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+import jdk.internal.crac.LoggerContainer;\n+\n+public class BlockingOrderedContext<R extends Resource> extends OrderedContext<R> {\n+    private boolean checkpointing = false;\n+\n+    \/\/ This method has particularly verbose name to stick out in thread dumps\n+    \/\/ when the registration leads to a deadlock.\n+    private void waitWhileCheckpointIsInProgress(R resource) {\n+        if (Thread.currentThread().isInterrupted()) {\n+            \/\/ FIXME this block effectively translates interrupted status to RuntimeException\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" not waiting in \" + this +\n+                \" to register \" + resource + \"; the thread has already been interrupted.\");\n+            \/\/ We won't cause IllegalStateException because this is not an unexpected state\n+            \/\/ from the point of CRaC - it probably tried to register some code before.\n+            throw new RuntimeException(\"Interrupted thread tried to block in registration of \" + resource + \" in \" + this);\n+        }\n+        LoggerContainer.debug(Thread.currentThread().getName() + \" waiting in \" + this + \" to register \" + resource);\n+        try {\n+            wait();\n+        } catch (InterruptedException e) {\n+            \/\/ FIXME there should be no interrupt once we've got interrupted\n+            Thread.currentThread().interrupt();\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" interrupted waiting in \" + this +\n+                \" to register \" + resource);\n+            throw new RuntimeException(\"Interrupted while trying to register \" + resource + \" in \" + this, e);\n+        }\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        synchronized (this) {\n+            checkpointing = true;\n+        }\n+        super.beforeCheckpoint(context);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        \/\/ unblock all registrations before running afterRestore()'s\n+        synchronized (this) {\n+            checkpointing = false;\n+            notifyAll();\n+        }\n+        super.afterRestore(context);\n+    }\n+\n+    @Override\n+    public void register(R resource) {\n+        synchronized (this) {\n+            while (checkpointing) {\n+                waitWhileCheckpointIsInProgress(resource);\n+            }\n+            super.register(resource);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/BlockingOrderedContext.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+public class CheckpointOpenFileException extends\n+        CheckpointOpenResourceException {\n+    private static final long serialVersionUID = 4696394478625532246L;\n+\n+    public CheckpointOpenFileException(String details, Throwable cause) {\n+        super(details, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenFileException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+public class CheckpointOpenResourceException extends Exception {\n+    private static final long serialVersionUID = -3858375642480846931L;\n+\n+    public CheckpointOpenResourceException(String details, Throwable cause) {\n+        super(details, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenResourceException.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+public class CheckpointOpenSocketException extends\n+        CheckpointOpenResourceException {\n+    private static final long serialVersionUID = 4778540502218641776L;\n+\n+    public CheckpointOpenSocketException(String details, Throwable cause) {\n+        super(details, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenSocketException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+package jdk.crac.impl;\n+\n+import java.util.function.Supplier;\n+\n+public class ExceptionHolder<E extends Exception> {\n+    E exception = null;\n+    final Supplier<E> constructor;\n+\n+    public ExceptionHolder(Supplier<E> constructor) {\n+        this.constructor = constructor;\n+    }\n+\n+    public E get() {\n+        if (exception == null) {\n+            exception = constructor.get();\n+        }\n+        return exception;\n+    }\n+\n+    public void throwIfAny() throws E {\n+        if (exception != null) {\n+            throw exception;\n+        }\n+    }\n+\n+    public boolean hasException() {\n+        return exception != null;\n+    }\n+\n+    public void resuppress(Exception e) {\n+        E exception = get();\n+        for (Throwable t : e.getSuppressed()) {\n+            exception.addSuppressed(t);\n+        }\n+    }\n+\n+    public void handle(Exception e) throws RuntimeException {\n+        if (e == null) {\n+            return;\n+        }\n+\n+        E exception = get();\n+        if (exception.getClass() == e.getClass()) {\n+            resuppress(e);\n+        } else {\n+            if (e instanceof InterruptedException) {\n+                \/\/ FIXME interrupt re-set should be up to the Context implementation, as\n+                \/\/ some implementations may prefer to continue beforeCheckpoint\/afterRestore\n+                \/\/ notification, rather than exiting as soon as possible.\n+                Thread.currentThread().interrupt();\n+            }\n+            exception.addSuppressed(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/ExceptionHolder.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import sun.security.action.GetPropertyAction;\n+\n+public class GlobalContext {\n+    private static final String GLOBAL_CONTEXT_IMPL_PROP = \"jdk.crac.globalContext.impl\";\n+    private static final String GLOBAL_CONTEXT_IMPL_NAME =\n+        GetPropertyAction.privilegedGetProperty(GLOBAL_CONTEXT_IMPL_PROP, \"\");\n+\n+    public static Context<Resource> createGlobalContextImpl() {\n+        return switch (GLOBAL_CONTEXT_IMPL_NAME) {\n+            case \"BlockingOrderedContext\" -> new BlockingOrderedContext<>();\n+            case \"OrderedContext\" -> new OrderedContext<>();\n+            default -> new OrderedContext<>(); \/\/ cannot report as System.out\/err are not initialized yet\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/GlobalContext.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.crac.impl;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * Keeps VM alive by at least one non-daemon thread.\n+ *\/\n+public class KeepAlive implements AutoCloseable {\n+    private final CountDownLatch start = new CountDownLatch(1);\n+    private final CountDownLatch finish = new CountDownLatch(1);\n+    private final Thread thread;\n+\n+    public KeepAlive() {\n+        \/\/ When the thread running notifications is not a daemon thread\n+        \/\/ it is unnecessary to create the keep-alive thread.\n+        if (!Thread.currentThread().isDaemon()) {\n+            thread = null;\n+            return;\n+        }\n+        thread = new Thread(() -> {\n+            start.countDown();\n+            try {\n+                finish.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }, \"CRaC Keep-Alive\");\n+        thread.setDaemon(false);\n+        thread.start();\n+        try {\n+            start.await();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new RuntimeException(\"Interrupted waiting for the keep-alive thread to start.\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (thread == null) {\n+            return; \/\/ noop\n+        }\n+        finish.countDown();\n+        try {\n+            thread.join();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new RuntimeException(\"Interrupted waiting for the keep-alive thread to complete\", e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/KeepAlive.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+import jdk.crac.*;\n+\n+import java.util.*;\n+\n+\/**\n+ * Context performing Checkpoint notification in reverse order of registration.\n+ * Concurrent registration along notification is silently ignored.\n+ * @param <R>\n+ *\/\n+public class OrderedContext<R extends Resource> extends AbstractContext<R> {\n+    private final WeakHashMap<R, Long> resources = new WeakHashMap<>();\n+    private long order = 0;\n+    private List<R> restoreSnapshot = null;\n+\n+    protected List<R> checkpointSnapshot() {\n+        List<R> snapshot;\n+        synchronized (this) {\n+            snapshot = this.resources.entrySet().stream()\n+                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\n+                .map(Map.Entry::getKey)\n+                .toList();\n+        }\n+        restoreSnapshot = new ArrayList<>(snapshot);\n+        Collections.reverse(restoreSnapshot);\n+        return snapshot;\n+    }\n+\n+    \/\/ We won't synchronize access to restoreSnapshot because methods\n+    \/\/ beforeCheckpoint and afterRestore should be invoked only\n+    \/\/ by the single thread performing the C\/R and other threads should\n+    \/\/ not touch that.\n+    protected List<R> restoreSnapshot() {\n+        List<R> snapshot = restoreSnapshot;\n+        restoreSnapshot = null;\n+        return snapshot;\n+    }\n+\n+    @Override\n+    public synchronized void register(R resource) {\n+        resources.put(resource, order++);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides explicit coordination with a checkpoint\/restore mechanism.\n+ * A checkpoint\/restore implementation may capture process or application state images for later continuation.\n+ * Coordination allows application code to prepare for a checkpoint and to adapt to changes in the execution environment after a restore.\n+ * <p>\n+ * Successful checkpointing and restoration may require that no checkpointed state exist that might not be validly reproducible when\n+restoring instances from the image.\n+ * Coordination enables application to proactively discard problematic state ahead of checkpointing, and to reestablish needed state upon restoration.\n+ * A Java implementation may provide detection of some subsets of state that are known to prevent successful checkpoints.\n+ * <p>\n+ * For example, a state of opened file descriptors or socket may be impossible to store in the image.\n+ * The implementation may detect such resources and then prevent checkpoint.\n+ * The application must then close file descriptors and sockets to be successfully checkpointed.\n+ * Files and sockets may be opened back after restore, then the application is responsible for processing possible exceptions.\n+ * <p>\n+ * {@link Resource} is an interface for receiving checkpoint\/restore notifications.\n+ * In order to be notified, {@code Resource} needs to be registered in a {@link Context}.\n+ * {@link Core} is a core interface for coordination. It provides the global {@code Context} which can be used as default choice.\n+ * The global {@code Context} have properties listed below, one can define a custom {@code Context} and register it with the global one.\n+ * {@code Core} has also a method to request checkpoint.\n+ * <p>\n+ * Methods of {@code Resource} are invoked as a notification of checkpoint and restore.\n+ * If a {@code Resource} is incapable to process notification, corresponding method throws an exception.\n+ * The global {@code Context} ensures that exceptions are propagated to a requester of checkpoint\/restore.\n+ * <p>\n+ * {@code Context} is a {@code Resource}, that allows other {@code Resource}s to be registered with it.\n+ * {@code Context} defines how {@code Resource}s are notified and may provide different guarantees compared to the global {@code Context}, such as order of notification.\n+ * A class may extend {@code Context} and define custom rules of notification processing by overriding {@code Resource} method.\n+ * Since a {@code Context} may be registered with other {@code Context}, they form a {@code Context} hierarchy.\n+ * <p>\n+ * Checkpoint can requested by {@code Core.checkpointRestore} or by some other way.\n+ * Then checkpoint notification of the global {@code Context} is performed.\n+ * If the global {@code Context} have not thrown {@code CheckpointException}, the current Java instance is used to create the image in a platform dependent way.\n+ * The current instance is terminated.\n+ * Later, a new instance is created by some means, for example via Java launcher in a special mode.\n+ * The new instance is started at the point where the image was created, it is followed by the restore notification.\n+ * Exceptions from restore notification are provided as suppressed ones by a {@code RestoreException} (in a sense of {@link Throwable#addSuppressed}).\n+ * <p>\n+ * If the global {@code Context} throws an exception during checkpoint notification then restore notificaion starts immediately without the image creation.\n+ * In this case, exceptions from checkpoint and restore notifications are provided as suppressed ones by {@code CheckpointException}.\n+ * <p>\n+ * {@code UnsupportedOperationException} is thrown if the service is not supported.\n+ * No notification is performed in this case.\n+ * <h2>Global Context Properties<\/h2>\n+ * Java Runtime maintains the global {@code Context} with following properties.\n+ * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n+ * <ul>\n+ * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n+ * <\/li>\n+ * <li>Order of checkpoint notification is the reverse order of registration.\n+ * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n+ * <\/li>\n+ * <li>For single {@code Resource} registered in this {@code Context}:\n+ * <ul>\n+ *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n+ *   <\/li>\n+ *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n+ *   <\/li>\n+ *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ * <\/ul>\n+ * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * @since TBD\n+ *\/\n+\n+package jdk.crac;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/package-info.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+    public void markClosed(FileDescriptor fdo);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOFileDescriptorAccess.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+\n+import jdk.internal.crac.Core;\n+\n@@ -46,0 +51,10 @@\n+\n+    \/**\n+     * Calls package-private {@link ReferenceQueue#poll(long)}.\n+     *\/\n+    <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException;\n+\n+    \/**\n+     * Calls package-private {@link ReferenceQueue#wakeup()}.\n+     *\/\n+    void wakeupReferenceQueue(ReferenceQueue<?> queue);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+    public void beforeCheckpoint(ZipFile zip);\n@@ -48,1 +49,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilZipFileAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.io.FileDescriptor;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.WeakHashMap;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\n+public class ClaimedFDs {\n+    private final static JavaIOFileDescriptorAccess fileDescriptorAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    private WeakHashMap<FileDescriptor, Descriptor> fds = new WeakHashMap<>();\n+\n+    public static class Descriptor {\n+        private int fd;\n+        private final Object claimer;\n+        private final Supplier<Exception> exceptionSupplier;\n+\n+        public Descriptor(Object claimer, Supplier<Exception> exceptionSupplier) {\n+            this.fd = -1;\n+            this.claimer = claimer;\n+            this.exceptionSupplier = exceptionSupplier;\n+        }\n+\n+        void setFd(int fd) {\n+            assert this.fd == -1;\n+            this.fd = fd;\n+        }\n+\n+        public int getFd() {\n+            assert this.fd != -1;\n+            return fd;\n+        }\n+\n+        public Object getClaimer() {\n+            return claimer;\n+        }\n+\n+        public Supplier<Exception> getExceptionSupplier() {\n+            return exceptionSupplier;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"{fd=\" + fd + \", claimer=\" + claimer + '}';\n+        }\n+    }\n+\n+    public List<Descriptor> getClaimedFds() {\n+        List<Descriptor> list = fds.entrySet().stream()\n+            .filter((var e) -> e.getKey().valid())\n+            .map(entry -> {\n+                    Descriptor d = entry.getValue();\n+                    d.setFd(fileDescriptorAccess.get(entry.getKey()));\n+                    return d;\n+                })\n+            .collect(Collectors.toList());\n+        \/\/ destroy fds since we've modified Descriptors\n+        fds = null;\n+        return list;\n+    }\n+\n+    public void claimFd(FileDescriptor fd, Object claimer, Supplier<Exception> supplier, Object... suppressedClaimers) {\n+        if (fd == null) {\n+            return;\n+        }\n+\n+        Descriptor descriptor = fds.get(fd);\n+        LoggerContainer.debug(\"ClaimFD: fd {0} claimer {1} existing {2}\",\n+            fd, claimer, descriptor != null ? descriptor.claimer : \"NONE\");\n+        if (descriptor == null ||\n+                Stream.of(suppressedClaimers).anyMatch((supressed) -> supressed == descriptor.getClaimer())) {\n+            fds.put(fd, new Descriptor(claimer, supplier));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/ClaimedFDs.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.impl.BlockingOrderedContext;\n+\n+public class Core {\n+    private static ClaimedFDs claimedFDs;\n+\n+    \/**\n+     * Called by JDK FD resources\n+     * @return\n+     *\/\n+    public static ClaimedFDs getClaimedFDs() {\n+        return claimedFDs;\n+    }\n+\n+    \/**\n+     * Called by jdk.crac.Core to publish current ClaimedFDs\n+     *\/\n+    public static void setClaimedFDs(ClaimedFDs fds) {\n+        claimedFDs = fds;\n+    }\n+\n+    \/**\n+     * Priorities are defined in the order of registration to the global context.\n+     * Checkpoint notification will be processed in the order from the bottom to the top of the list.\n+     * Restore will be done in reverse order: from the top to the bottom.\n+     *\n+     * Resources of the same priority will be handled according the context supplied to the priority.\n+     *\n+     * Most resources should use priority NORMAL (the lowest priority).\n+     *\/\n+    public enum Priority {\n+        FILE_DESCRIPTORS(new BlockingOrderedContext<>()),\n+        PRE_FILE_DESCRIPTORS(new BlockingOrderedContext<>()),\n+        CLEANERS(new BlockingOrderedContext<>()),\n+        REFERENCE_HANDLER(new BlockingOrderedContext<>()),\n+        SEEDER_HOLDER(new BlockingOrderedContext<>()),\n+        SECURE_RANDOM(new BlockingOrderedContext<>()),\n+        NATIVE_PRNG(new BlockingOrderedContext<>()),\n+        EPOLLSELECTOR(new BlockingOrderedContext<>()),\n+        NORMAL(new BlockingOrderedContext<>());\n+\n+        private final Context<JDKResource> context;\n+        Priority(Context<JDKResource> context) {\n+            jdk.crac.Core.getGlobalContext().register(context);\n+            this.context = context;\n+        }\n+\n+        public Context<JDKResource> getContext() {\n+            return context;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.action.GetBooleanAction;\n+\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n+public class JDKContext implements JDKResource {\n+    public static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n+    public static final String COLLECT_FD_STACKTRACES_HINT = \"Use -D\" + COLLECT_FD_STACKTRACES_PROPERTY + \"=true to find the source.\";\n+\n+    \/\/ JDKContext by itself is initialized too early when system properties are not set yet\n+    public static class Properties {\n+        public static final boolean COLLECT_FD_STACKTRACES =\n+                GetBooleanAction.privilegedGetProperty(JDKContext.COLLECT_FD_STACKTRACES_PROPERTY);\n+    }\n+\n+    private WeakHashMap<FileDescriptor, Object> claimedFds;\n+\n+    public boolean matchClasspath(String path) {\n+        Path p = Path.of(path);\n+        String classpath = System.getProperty(\"java.class.path\");\n+        int index = 0;\n+        do {\n+            int end = classpath.indexOf(File.pathSeparatorChar, index);\n+            if (end < 0) {\n+                end = classpath.length();\n+            }\n+            try {\n+                if (Files.isSameFile(p, Path.of(classpath.substring(index, end)))) {\n+                    return true;\n+                }\n+            } catch (IOException e) {\n+                \/\/ ignore exception\n+                return false;\n+            }\n+            index = end + 1;\n+        } while (index < classpath.length());\n+        return false;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        claimedFds = new WeakHashMap<>();\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        claimedFds = null;\n+    }\n+\n+    public Map<Integer, Object> getClaimedFds() {\n+        JavaIOFileDescriptorAccess fileDescriptorAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+        \/\/ Using streams+lambdas here would create a new Cleaner, therefore registering a resource\n+        Map<Integer, Object> map = new HashMap<>();\n+        for (Map.Entry<FileDescriptor, Object> entry : claimedFds.entrySet()) {\n+            if (map.put(fileDescriptorAccess.get(entry.getKey()), entry.getValue()) != null) {\n+                throw new IllegalStateException(\"Duplicate key\");\n+            }\n+        }\n+        return map;\n+    }\n+\n+    public void claimFd(FileDescriptor fd, Object obj) {\n+        if (!fd.valid()) {\n+            return;\n+        }\n+        Object e = claimedFds.put(fd, obj);\n+        if (e != null) {\n+            throw new AssertionError(fd + \" was already claimed by \" + e);\n+        }\n+    }\n+\n+    public boolean claimFdWeak(FileDescriptor fd, Object obj) {\n+        if (!fd.valid()) {\n+            return false;\n+        }\n+        return claimedFds.putIfAbsent(fd, obj) == null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import sun.security.action.GetBooleanAction;\n+\n+import java.util.function.Supplier;\n+\n+public abstract class JDKFdResource implements JDKResource {\n+    public static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n+    private static final String COLLECT_FD_STACKTRACES_HINT =\n+        \"Use -D\" + COLLECT_FD_STACKTRACES_PROPERTY + \"=true to find the source.\";\n+\n+    private static final boolean COLLECT_FD_STACKTRACES =\n+        GetBooleanAction.privilegedGetProperty(COLLECT_FD_STACKTRACES_PROPERTY);\n+\n+    \/\/ No lambdas during clinit...\n+    protected static Supplier<Exception> NO_EXCEPTION = new Supplier<Exception>() {\n+        @Override\n+        public Exception get() {\n+            return null;\n+        }\n+    };\n+\n+    final Exception stackTraceHolder;\n+\n+    static volatile boolean stacktraceHintPrinted = false;\n+    static volatile boolean warningSuppressionHintPrinted = false;\n+\n+    public JDKFdResource() {\n+        stackTraceHolder = COLLECT_FD_STACKTRACES ?\n+            \/\/ About the timestamp: we cannot format it nicely since this\n+            \/\/ exception is sometimes created too early in the VM lifecycle\n+            \/\/ (but it's hard to detect when it would be safe to do).\n+            new Exception(\"This file descriptor was created by \" + Thread.currentThread().getName()\n+                + \" at epoch:\" + System.currentTimeMillis() + \" here\") :\n+            null;\n+\n+        Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+        OpenResourcePolicies.ensureRegistered();\n+    }\n+\n+    protected Exception getStackTraceHolder() {\n+        if (!stacktraceHintPrinted && stackTraceHolder == null) {\n+            stacktraceHintPrinted = true;\n+            LoggerContainer.info(COLLECT_FD_STACKTRACES_HINT);\n+        }\n+        return stackTraceHolder;\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+    }\n+\n+    protected void warnOpenResource(OpenResourcePolicies.Policy policy, String self) {\n+        \/\/ The warning is not printed for implicitly closed resource (without policy)\n+        \/\/ e.g. standard input\/output streams\n+        String warn = \"false\";\n+        if (policy != null) {\n+            warn = policy.params.getOrDefault(\"warn\", \"true\");\n+        }\n+        if (Boolean.parseBoolean(warn)) {\n+            LoggerContainer.warn(\"{0} was not closed by the application.\", self);\n+            if (!warningSuppressionHintPrinted) {\n+                LoggerContainer.info(\"To suppress the warning above use 'warn: false' in the resource policy.\");\n+                warningSuppressionHintPrinted = true;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFdResource.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.util.function.Supplier;\n+\n+public abstract class JDKFileResource extends JDKFdResource {\n+    private static final String[] CLASSPATH_ENTRIES =\n+        GetPropertyAction.privilegedGetProperty(\"java.class.path\")\n+            .split(File.pathSeparator);\n+\n+    boolean closed;\n+    boolean error;\n+\n+    public static OpenResourcePolicies.Policy findPolicy(boolean isRestore, String pathStr) {\n+        Path path = Path.of(pathStr);\n+        return OpenResourcePolicies.find(isRestore,\n+                OpenResourcePolicies.FILE, props -> {\n+                    String policyPath = props.get(\"path\");\n+                    if (policyPath == null) {\n+                        return true; \/\/ missing path matches all files\n+                    } else {\n+                        return FileSystems.getDefault().getPathMatcher(\"glob:\" + policyPath).matches(path);\n+                    }\n+                });\n+    }\n+\n+    protected abstract FileDescriptor getFD();\n+    protected abstract String getPath();\n+    protected abstract void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException;\n+    protected abstract void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException;\n+\n+    protected boolean matchClasspath(String path) {\n+        for (String cp : CLASSPATH_ENTRIES) {\n+            if (cp.equals(path)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        String path = getPath();\n+        if (path == null) {\n+            \/\/ let FileDescriptor claim everything\n+            return;\n+        }\n+\n+        OpenResourcePolicies.Policy policy = findPolicy(false, path);\n+        String action = \"error\";\n+        if (policy != null) {\n+            action = policy.action.toLowerCase();\n+        } else if (matchClasspath(path)) {\n+            \/\/ Files on the classpath are considered persistent, exception is not thrown\n+            action = \"ignore\";\n+        }\n+        Supplier<Exception> exceptionSupplier = switch (action) {\n+            case \"error\":\n+                error = true;\n+                yield () -> new CheckpointOpenFileException(path, getStackTraceHolder());\n+            case \"close\", \"reopen\":\n+                \/\/ Here we assume that the stream is idle; any concurrent access\n+                \/\/ will end with exceptions as the file-descriptors is invalidated\n+                try {\n+                    closeBeforeCheckpoint(policy);\n+                } catch (IOException e) {\n+                    throw new CheckpointOpenResourceException(\"Cannot close \" + path, e);\n+                }\n+                closed = true;\n+            case \"ignore\":\n+                warnOpenResource(policy, \"File \" + path);\n+                yield NO_EXCEPTION;\n+            default:\n+                throw new IllegalStateException(\"Unknown policy action for path \" + path + \": \" + policy.action);\n+        };\n+        FileDescriptor fd = getFD();\n+        Core.getClaimedFDs().claimFd(fd, this, exceptionSupplier, fd);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (!closed || error) {\n+            return;\n+        }\n+        OpenResourcePolicies.Policy policy = findPolicy(true, getPath());\n+        if (policy != null && \"reopen\".equalsIgnoreCase(policy.action)) {\n+            reopenAfterRestore(policy);\n+            closed = false;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFileResource.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+\n+public interface JDKResource extends Resource {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+\n+import java.io.IOException;\n+import java.net.*;\n+\n+public abstract class JDKSocketResource extends JDKSocketResourceBase {\n+\n+    private SocketAddress local;\n+    private SocketAddress remote;\n+\n+    public JDKSocketResource(Object owner) {\n+        super(owner);\n+    }\n+\n+    protected abstract SocketAddress localAddress() throws IOException;\n+    protected abstract SocketAddress remoteAddress() throws IOException;\n+\n+    @Override\n+    protected OpenResourcePolicies.Policy findPolicy(boolean isRestore) throws CheckpointOpenSocketException {\n+        if (!isRestore) {\n+            try {\n+                local = localAddress();\n+            } catch (IOException e) {\n+                throw new CheckpointOpenSocketException(\"Cannot find local address for \" + owner, e);\n+            }\n+            try {\n+                remote = remoteAddress();\n+            } catch (IOException e) {\n+                throw new CheckpointOpenSocketException(\"Cannot find remote address for \" + owner, e);\n+            }\n+        }\n+        var localMatcher = getMatcher(local, \"localAddress\", \"localPort\", \"localPath\");\n+        var remoteMatcher = getMatcher(remote, \"remoteAddress\", \"remotePort\", \"remotePath\");\n+        return OpenResourcePolicies.find(isRestore, OpenResourcePolicies.SOCKET,\n+                params -> localMatcher.test(params) && remoteMatcher.test(params));\n+    }\n+\n+    @Override\n+    protected void reset() {\n+        \/\/ Allow garbage collection\n+        local = null;\n+        remote = null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResource.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.file.FileSystems;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+public abstract class JDKSocketResourceBase extends JDKFdResource {\n+    protected final Object owner;\n+    private boolean valid;\n+    private boolean error;\n+\n+    public JDKSocketResourceBase(Object owner) {\n+        this.owner = owner;\n+    }\n+\n+    protected abstract FileDescriptor getFD();\n+    protected abstract void closeBeforeCheckpoint() throws IOException;\n+    protected abstract OpenResourcePolicies.Policy findPolicy(boolean isRestore) throws CheckpointOpenSocketException;\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        FileDescriptor fd = getFD();\n+        if (fd == null) {\n+            return;\n+        }\n+        synchronized (fd) {\n+            if (!(valid = fd.valid())) {\n+                return;\n+            }\n+            OpenResourcePolicies.Policy policy = findPolicy(false);\n+            String action = policy == null ? \"error\" : policy.action.toLowerCase();\n+            Supplier<Exception> exceptionSupplier = switch (action) {\n+                case \"error\":\n+                    error = true;\n+                    yield () -> new CheckpointOpenSocketException(owner.toString(), getStackTraceHolder());\n+                case \"close\", \"reopen\":\n+                    try {\n+                        closeBeforeCheckpoint();\n+                    } catch (IOException e) {\n+                        throw new CheckpointOpenSocketException(\"Cannot close \" + owner, e);\n+                    }\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    warnOpenResource(policy, \"Socket \" + owner);\n+                    yield NO_EXCEPTION;\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + owner, null);\n+            };\n+            Core.getClaimedFDs().claimFd(fd, owner, exceptionSupplier, fd);\n+        }\n+    }\n+\n+    protected Predicate<Map<String, String>> getMatcher(SocketAddress addr, String addressKey, String portKey, String pathKey) {\n+        return params -> {\n+            String family = params.get(\"family\");\n+            if (family != null && addr != null) {\n+                switch (family.toLowerCase()) {\n+                    case \"ipv6\", \"inet6\" -> {\n+                        if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                            return false;\n+                        } else if (!(inetAddr.getAddress() instanceof Inet6Address)) {\n+                            return false;\n+                        }\n+                    }\n+                    case \"ipv4\", \"inet4\" -> {\n+                        if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                            return false;\n+                        } else if (!(inetAddr.getAddress() instanceof Inet4Address)) {\n+                            return false;\n+                        }\n+                    }\n+                    case \"ip\", \"inet\" -> {\n+                        if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                            return false;\n+                        }\n+                    }\n+                    case \"unix\" -> {\n+                        if (!(addr instanceof UnixDomainSocketAddress)) {\n+                            return false;\n+                        }\n+                    }\n+                    default -> throw new IllegalArgumentException(\"Unknown family: \" + family);\n+                }\n+            }\n+            String cfgAddress = params.get(addressKey);\n+            String cfgPort = params.get(portKey);\n+            String cfgPath = params.get(pathKey);\n+            if (cfgAddress != null || cfgPort != null) {\n+                if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                    return false;\n+                }\n+                if (cfgAddress != null && !\"*\".equals(cfgAddress)) {\n+                    try {\n+                        if (!InetAddress.getByName(cfgAddress).equals(inetAddr.getAddress())) {\n+                            return false;\n+                        }\n+                    } catch (UnknownHostException e) {\n+                        return false;\n+                    }\n+                }\n+                if (cfgPort != null && !\"*\".equals(cfgPort)) {\n+                    return Integer.parseInt(cfgPort) == inetAddr.getPort();\n+                }\n+                return true;\n+            } else if (cfgPath != null) {\n+                if (!(addr instanceof UnixDomainSocketAddress unixAddr)) {\n+                    return false;\n+                }\n+                return FileSystems.getDefault().getPathMatcher(\"glob:\" + cfgPath)\n+                        .matches(unixAddr.getPath());\n+            } else {\n+                return true;\n+            }\n+        };\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        \/\/ Don't do anything when we've already failed\n+        if (!valid || error) {\n+            return;\n+        }\n+        FileDescriptor fd = getFD();\n+        if (fd == null) {\n+            return;\n+        }\n+        synchronized (fd) {\n+            OpenResourcePolicies.Policy policy = findPolicy(true);\n+            String action = policy == null ? \"error\" : policy.action;\n+            try {\n+                \/\/ FIXME: implement\n+                if (action.equals(\"reopen\")) {\n+                    throw new UnsupportedOperationException(\"Policy \" + policy.type + \" not implemented\");\n+                }\n+            } finally {\n+                reset();\n+            }\n+        }\n+    }\n+\n+    protected abstract void reset();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResourceBase.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+package jdk.internal.crac;\n+\n+\/**\n+ * Some classes that could use logging are initialized early during the boot\n+ * and keeping the logger in static final field there could cause problems\n+ * (e.g. recursion when service-loading logger implementation).\n+ * Therefore, we isolate the logger into a subclass and initialize lazily.\n+ *\/\n+public class LoggerContainer {\n+    public static final System.Logger logger = System.getLogger(\"jdk.crac\");\n+\n+    public static void info(String msg) {\n+        logger.log(System.Logger.Level.INFO, msg);\n+    }\n+\n+    public static void debug(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.DEBUG, fmt, params);\n+    }\n+\n+    private LoggerContainer() {}\n+\n+    public static void warn(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.WARNING, fmt, params);\n+    }\n+\n+    public static void error(String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg);\n+    }\n+\n+    public static void error(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.ERROR, fmt, params);\n+    }\n+\n+    public static void error(Throwable t, String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg, t);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.*;\n+import java.util.function.Predicate;\n+\n+public class OpenResourcePolicies {\n+    public static final String PROPERTY = \"jdk.crac.resource-policies\";\n+    public static final String FILE = \"file\";\n+    public static final String PIPE = \"pipe\";\n+    public static final String SOCKET = \"socket\";\n+\n+    private enum State {\n+        NOT_LOADED,\n+        LOADED_FOR_CHECKPOINT,\n+        LOADED_FOR_RESTORE\n+    }\n+\n+    private static final Map<String, List<Policy>> policies = new HashMap<>();\n+    private static State state = State.NOT_LOADED;\n+\n+    private static final JDKResource resource = new JDKResource() {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            \/\/ We cannot lazily wait until the FILE_DESCRIPTORS priority\n+            \/\/ because we need to open a file, too.\n+            loadPolicies(false);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+            policies.clear();\n+            state = State.NOT_LOADED;\n+        }\n+    };\n+\n+    static {\n+        Core.Priority.NORMAL.getContext().register(resource);\n+    }\n+\n+    static void ensureRegistered() {\n+        \/\/ noop\n+    }\n+\n+    private static synchronized void loadPolicies(boolean isRestore) {\n+        if (state == State.LOADED_FOR_RESTORE || (!isRestore && state == State.LOADED_FOR_CHECKPOINT)) {\n+            return;\n+        }\n+        \/\/ prevent loading recursively\n+        state = isRestore ? State.LOADED_FOR_RESTORE : State.LOADED_FOR_CHECKPOINT;\n+\n+        String file = GetPropertyAction.privilegedGetProperty(PROPERTY);\n+        if (file == null) {\n+            return;\n+        }\n+        \/\/ The newer policies have more priority; we'll copy the old ones and\n+        \/\/ append them later on\n+        Map<String, List<Policy>> old = Map.copyOf(policies);\n+        policies.clear();\n+\n+        File f = new File(file);\n+        if (!f.exists()) {\n+            throw new ConfigurationException(\"File \" + file + \" used in property \" + PROPERTY + \" does not exist\");\n+        } else if (!f.isFile() || !f.canRead()) {\n+            throw new ConfigurationException(\"File \" + file + \" used in property \" + PROPERTY + \" is not a regular file or cannot be read.\");\n+        }\n+        String type = null, action = null;\n+        Map<String, String> params = new HashMap<>();\n+        int currentLine = 1, policyStart = 1;\n+        try {\n+            for (String line : Files.readAllLines(f.toPath())) {\n+                line = line.trim();\n+                if (line.startsWith(\"#\")) {\n+                    continue;\n+                } else if (\"---\".equals(line)) {\n+                    if (type == null && action == null && params.isEmpty()) {\n+                        \/\/ ignore empty policies\n+                        policyStart = currentLine + 1;\n+                        continue;\n+                    }\n+                    addPolicy(type, action, params, file, policyStart, currentLine);\n+                    type = null;\n+                    action = null;\n+                    params = new HashMap<>();\n+                    policyStart = currentLine + 1;\n+                    continue;\n+                }\n+                int index = line.indexOf(\": \");\n+                if (index < 0) {\n+                    throw new ConfigurationException(invalid(file, policyStart, currentLine, \"cannot parse line \" + currentLine + \": \" + line));\n+                }\n+                String key = line.substring(0, index).trim();\n+                String value = line.substring(index + 2).trim();\n+                switch (key.toLowerCase()) {\n+                    case \"type\" -> type = value;\n+                    case \"action\" -> action = value;\n+                    default -> params.put(key, value);\n+                }\n+                ++currentLine;\n+            }\n+            if (type != null || action != null || !params.isEmpty()) {\n+                addPolicy(type, action, params, file, policyStart, currentLine);\n+            }\n+        } catch (IOException e) {\n+            throw new ConfigurationException(\"Cannot read file \" + file + \" used in property \" + PROPERTY, e);\n+        }\n+\n+        \/\/ Add the old policies after the newly loaded ones\n+        for (var entry : old.entrySet()) {\n+            List<Policy> newList = policies.get(entry.getKey());\n+            if (newList == null) {\n+                policies.put(entry.getKey(), entry.getValue());\n+            } else {\n+                newList.addAll(entry.getValue());\n+            }\n+        }\n+    }\n+\n+    private static void addPolicy(String type, String action, Map<String, String> params, String file, int from, int to) {\n+        if (type == null) {\n+            throw new ConfigurationException(invalid(file, from, to, \"no 'type'\"));\n+        } else if (action == null) {\n+            throw new ConfigurationException(invalid(file, from, to, \"no 'action'\"));\n+        }\n+        type = type.trim().toLowerCase();\n+        action = action.trim();\n+        policies.computeIfAbsent(type, t -> new ArrayList<>()).add(new Policy(type, action, params));\n+    }\n+\n+    private static String invalid(String file, int from, int to, String why) {\n+        return \"Invalid rule in policies file \" + file + \" on lines \" + from + \"-\" + to + \": \" + why;\n+    }\n+\n+    public static Policy find(boolean isRestore, String type, Predicate<Map<String, String>> filter) {\n+        loadPolicies(isRestore);\n+        List<Policy> list = policies.get(type);\n+        if (list == null) {\n+            return null;\n+        }\n+        if (filter == null) {\n+            return list.get(0);\n+        }\n+        return list.stream().filter(p -> filter.test(p.params)).findFirst().orElse(null);\n+    }\n+\n+    public static class Policy {\n+        \/\/ file, socket, pipe...\n+        public final String type;\n+        \/\/ The policy action\n+        public final String action;\n+        \/\/ Both filtering and action customization\n+        public final Map<String, String> params;\n+\n+        public Policy(String type, String action, Map<String, String> params) {\n+            this.type = type;\n+            this.action = action;\n+            this.params = Collections.unmodifiableMap(params);\n+        }\n+    }\n+\n+    private static class ConfigurationException extends RuntimeException {\n+        private static final long serialVersionUID = 6833568262773571378L;\n+\n+        public ConfigurationException(String message) {\n+            super(message);\n+        }\n+\n+        public ConfigurationException(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/OpenResourcePolicies.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -76,0 +76,1 @@\n+import jdk.internal.util.jar.PersistentJarFile;\n@@ -824,1 +825,1 @@\n-                return checkJar(new JarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n+                return checkJar(new PersistentJarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.internal.util.jar.PersistentJarFile;\n@@ -227,1 +228,1 @@\n-                return new JarFile(new File(path.toString()),\n+                return new PersistentJarFile(new File(path.toString()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleReferences.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -37,0 +35,6 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -43,1 +47,1 @@\n-public final class CleanerImpl implements Runnable {\n+public final class CleanerImpl implements Runnable, JDKResource {\n@@ -49,0 +53,1 @@\n+    private static JavaLangRefAccess javaLangRefAccess = SharedSecrets.getJavaLangRefAccess();\n@@ -58,0 +63,2 @@\n+    volatile boolean forceCleanup = false;\n+\n@@ -113,0 +120,1 @@\n+        Core.Priority.CLEANERS.getContext().register(this);\n@@ -137,0 +145,12 @@\n+            if (forceCleanup) {\n+                synchronized (phantomCleanableList) {\n+                    PhantomCleanable<?> next = phantomCleanableList;\n+                    do {\n+                        next = next.cleanIfNull();\n+                    } while (next != phantomCleanableList);\n+                }\n+                synchronized (this) {\n+                    forceCleanup = false;\n+                    notify();\n+                }\n+            }\n@@ -140,1 +160,1 @@\n-                Cleanable ref = (Cleanable) queue.remove(60 * 1000L);\n+                Cleanable ref = (Cleanable) javaLangRefAccess.pollReferenceQueue(queue, 60 * 1000L);\n@@ -149,0 +169,23 @@\n+        synchronized (this) {\n+            \/\/ wakeup the checkpoint thread when we this thread terminates before noticing\n+            \/\/ the forced cleanup\n+            forceCleanup = false;\n+            notify();\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (phantomCleanableList.isListEmpty()) {\n+            \/\/ The thread is already terminated; don't wait for anything\n+            return;\n+        }\n+        forceCleanup = true;\n+        javaLangRefAccess.wakeupReferenceQueue(queue);\n+        while (forceCleanup) {\n+            wait();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n@@ -200,0 +243,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"PhantomCleanableRef:\"  + action;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":52,"deletions":4,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -137,0 +137,20 @@\n+    PhantomCleanable<?> cleanIfNull() {\n+        if (this == list) {\n+            \/\/ The reference representing the list itself does not have\n+            \/\/ a referent, we will skip it.\n+            return next;\n+        }\n+        PhantomCleanable<?> oldNext = next;\n+        if (refersTo(null)) {\n+            try {\n+                clean();\n+            } catch (Throwable t) {\n+                \/\/ This method is called only from CleanerImpl and that one\n+                \/\/ ignores any exceptions thrown; we will do the same here.\n+                \/\/ The exception cannot be caught (and ignored) by the caller\n+                \/\/ since we want to continue traversing the list.\n+            }\n+        }\n+        return oldNext;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util.jar;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.JDKResource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.jar.JarFile;\n+\n+\/**\n+ * @crac It is assumed that JAR files opened through this class that are open\n+ * during checkpoint will be present on same path in the filesystem after\n+ * restore. Therefore, application does <strong>not<\/strong> have to close\n+ * these files before a checkpoint.\n+ *\/\n+public class PersistentJarFile extends JarFile implements JDKResource {\n+\n+    public PersistentJarFile(File file, boolean b, int openRead, Runtime.Version runtimeVersion) throws IOException {\n+        super(file, b, openRead, runtimeVersion);\n+        Core.Priority.NORMAL.getContext().register(this);\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        LoggerContainer.info(this.getName() + \" is recorded as always available on restore\");\n+        SharedSecrets.getJavaUtilZipFileAccess().beforeCheckpoint(this);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        \/\/ do nothing, no fixup required\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -132,0 +132,1 @@\n+    exports javax.crac;\n@@ -133,0 +134,1 @@\n+    exports jdk.crac;\n@@ -162,0 +164,2 @@\n+    exports jdk.internal.crac to\n+        jdk.sctp;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.JDKFileResource;\n+\n@@ -49,0 +54,29 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fdObj;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            \/\/ TODO: we don't have information about the path without introspecting FD\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (isOpen()) {\n+                super.beforeCheckpoint(context);\n+            }\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousFileChannelImpl.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+\n+import jdk.internal.crac.JDKSocketResource;\n@@ -53,0 +55,1 @@\n+    private final JDKSocketResource resource;\n@@ -73,0 +76,21 @@\n+        this.resource = new JDKSocketResource(this) {\n+            @Override\n+            protected FileDescriptor getFD() {\n+                return fd;\n+            }\n+\n+            @Override\n+            protected SocketAddress localAddress() {\n+                return localAddress;\n+            }\n+\n+            @Override\n+            protected SocketAddress remoteAddress() {\n+                return null;\n+            }\n+\n+            @Override\n+            protected void closeBeforeCheckpoint() throws IOException {\n+                close();\n+            }\n+        };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+\n+import jdk.internal.crac.JDKSocketResource;\n@@ -53,0 +55,2 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new Resource();\n@@ -607,0 +611,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(AsynchronousSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -97,0 +98,1 @@\n+    private final JDKSocketResource resource = new Resource();\n@@ -1891,0 +1893,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(DatagramChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -49,0 +52,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -76,0 +80,34 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (!isOpen() || path == null) {\n+                return;\n+            } else if (parent != null) {\n+                \/\/ This FileChannel is managed by a higher level object that\n+                \/\/ will handle the provided file descriptor on its own.\n+                return;\n+            }\n+            super.beforeCheckpoint(context);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ implementation is possible but non-trivial\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -131,0 +132,5 @@\n+    static {\n+        \/\/ trigger eager initialization\n+        new FileDispatcherImpl();\n+    }\n+\n@@ -1204,1 +1210,1 @@\n-    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+    private static Runnable closerFor0(FileDescriptor fd, boolean stream) {\n@@ -1227,0 +1233,14 @@\n+    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+\n+        \/\/ FIXME ensure FileDispatcherImpl's Resource is registered before the closer is used,\n+        \/\/ otherwise the closer during beforeCheckpoint may be the first one to access\n+        \/\/ FileDescriptor, and then Dispatcher Resource will be blocked for registration.\n+        try {\n+            MethodHandles.lookup().ensureInitialized(FileDispatcherImpl.class);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        return closerFor0(fd, stream);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -78,0 +79,1 @@\n+    private final Resource resource = new Resource();\n@@ -405,1 +407,0 @@\n-\n@@ -730,0 +731,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(ServerSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -84,0 +85,1 @@\n+    private final Resource resource = new Resource();\n@@ -1489,0 +1491,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(SocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -145,2 +150,2 @@\n-    private static final class UnclosableInputStream extends FilterInputStream {\n-        UnclosableInputStream(InputStream in) {\n+    private static final class UnclosableInputStream extends FilterInputStream implements JDKResource {\n+        UnclosableInputStream(FileInputStream in) {\n@@ -148,0 +153,1 @@\n+            Core.Priority.NORMAL.getContext().register(this);\n@@ -158,0 +164,11 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            FileDescriptor fd = ((FileInputStream)in).getFD();\n+            Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/FileInputStreamPool.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+\n@@ -34,0 +38,2 @@\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -51,0 +57,10 @@\n+ * @crac If this class is created using the {@link #SecureRandom() no-arg constructor}\n+ * and never {@link #engineSetSeed(byte[]) reseeded} it is automatically reseeded\n+ * after restore from a checkpoint. Therefore, after restore the sequences produced\n+ * during different runs should differ (and the application will consume system entropy).\n+ * If a seed was provided externally the application might depend on the sequence\n+ * produced by this generator, therefore it is not reseeded.\n+ * If this behaviour is not desired the application should {@link javax.crac.Context#register(javax.crac.Resource) register}\n+ * a resource and in the {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method}\n+ * reseed it using the {@link #engineSetSeed(byte[])}.\n+ *\n@@ -57,1 +73,1 @@\n-implements java.io.Serializable {\n+implements java.io.Serializable, jdk.internal.crac.JDKResource {\n@@ -67,0 +83,2 @@\n+    private boolean clearStateOnCheckpoint = true;\n+    private ReentrantLock objLock = new ReentrantLock();\n@@ -84,0 +102,4 @@\n+     *\n+     * @crac Instances created using this constructor are automatically\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n@@ -93,0 +115,4 @@\n+     * @crac Instances created using this constructor are <strong>not<\/strong>\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n+     *\n@@ -123,0 +149,1 @@\n+        Core.Priority.SECURE_RANDOM.getContext().register(this);\n@@ -155,0 +182,4 @@\n+     * @crac After this method is called the instance is <strong>not<\/strong>\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n+     *\n@@ -158,1 +189,14 @@\n-    public synchronized void engineSetSeed(byte[] seed) {\n+    public void engineSetSeed(byte[] seed) {\n+        objLock.lock();\n+        try {\n+            \/\/ check if objLock has not been already acquired in beforeCheckpoint\n+            if(objLock.getHoldCount() > 1) {\n+                throw new IllegalStateException(\"SHA1PRNG object is invalidated\");\n+            }\n+            setSeedImpl(seed);\n+        } finally {\n+            objLock.unlock();\n+        }\n+    }\n+\n+    private void setSeedImpl(byte[] seed) {\n@@ -167,0 +211,1 @@\n+        clearStateOnCheckpoint = false;\n@@ -194,0 +239,26 @@\n+    private void invalidate() {\n+        assert objLock.isHeldByCurrentThread();\n+        if (state != null) {\n+            Arrays.fill(state, (byte)0);\n+        }\n+        state = null;\n+        if (remainder != null) {\n+            Arrays.fill(remainder, (byte)0);\n+        }\n+        remainder = null;\n+        remCount = 0;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        objLock.lock();\n+        if (clearStateOnCheckpoint) {\n+            invalidate();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        objLock.unlock();\n+    }\n+\n@@ -200,3 +271,3 @@\n-    private static class SeederHolder {\n-\n-        private static final SecureRandom seeder;\n+    private static class SeederHolder implements jdk.internal.crac.JDKResource {\n+        private static final SeederHolder seederHolder = new SeederHolder();\n+        private final SecureRandom seeder;\n@@ -204,1 +275,1 @@\n-        static {\n+        private SeederHolder() {\n@@ -210,1 +281,1 @@\n-            byte [] b = new byte[DIGEST_SIZE];\n+            byte[] b = new byte[DIGEST_SIZE];\n@@ -213,0 +284,17 @@\n+            Core.Priority.SEEDER_HOLDER.getContext().register(this);\n+        }\n+\n+        public static SecureRandom getSeeder() {\n+            return seederHolder.seeder;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            seeder.invalidate();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            byte[] b = new byte[DIGEST_SIZE];\n+            SeedGenerator.generateSeed(b);\n+            seeder.setSeedImpl(b);\n@@ -222,10 +310,10 @@\n-    public synchronized void engineNextBytes(byte[] result) {\n-        int index = 0;\n-        int todo;\n-        byte[] output = remainder;\n-\n-        if (state == null) {\n-            byte[] seed = new byte[DIGEST_SIZE];\n-            SeederHolder.seeder.engineNextBytes(seed);\n-            state = digest.digest(seed);\n-        }\n+    public void engineNextBytes(byte[] result) {\n+        objLock.lock();\n+        try {\n+            \/\/ verify if objLock is already acquired in beforeCheckpoint\n+            if(objLock.getHoldCount() > 1) {\n+                throw new IllegalStateException(\"SHA1PRNG object is invalidated\");\n+            }\n+            int index = 0;\n+            int todo;\n+            byte[] output = remainder;\n@@ -233,5 +321,10 @@\n-        \/\/ Use remainder from last time\n-        int r = remCount;\n-        if (r > 0) {\n-            \/\/ How many bytes?\n-            todo = (result.length - index) < (DIGEST_SIZE - r) ?\n+            if (state == null) {\n+                byte[] seed = new byte[DIGEST_SIZE];\n+                SeederHolder.getSeeder().engineNextBytes(seed);\n+                state = digest.digest(seed);\n+            }\n+            \/\/ Use remainder from last time\n+            int r = remCount;\n+            if (r > 0) {\n+                \/\/ How many bytes?\n+                todo = (result.length - index) < (DIGEST_SIZE - r) ?\n@@ -239,4 +332,7 @@\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[i] = output[r];\n-                output[r++] = 0;\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[i] = output[r];\n+                    output[r++] = 0;\n+                }\n+                remCount += todo;\n+                index += todo;\n@@ -244,10 +340,0 @@\n-            remCount += todo;\n-            index += todo;\n-        }\n-\n-        \/\/ If we need more bytes, make them.\n-        while (index < result.length) {\n-            \/\/ Step the state\n-            digest.update(state);\n-            output = digest.digest();\n-            updateState(state, output);\n@@ -255,7 +341,15 @@\n-            \/\/ How many bytes?\n-            todo = (result.length - index) > DIGEST_SIZE ?\n-                DIGEST_SIZE : result.length - index;\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[index++] = output[i];\n-                output[i] = 0;\n+            \/\/ If we need more bytes, make them.\n+            while (index < result.length) {\n+                \/\/ Step the state\n+                digest.update(state);\n+                output = digest.digest();\n+                updateState(state, output);\n+                \/\/ How many bytes?\n+                todo = (result.length - index) > DIGEST_SIZE ?\n+                        DIGEST_SIZE : result.length - index;\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[index++] = output[i];\n+                    output[i] = 0;\n+                }\n+                remCount += todo;\n@@ -263,2 +357,0 @@\n-            remCount += todo;\n-        }\n@@ -266,3 +358,6 @@\n-        \/\/ Store remainder for next time\n-        remainder = output;\n-        remCount %= DIGEST_SIZE;\n+            \/\/ Store remainder for next time\n+            remainder = output;\n+            remCount %= DIGEST_SIZE;\n+        } finally {\n+            objLock.unlock();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":143,"deletions":48,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -1313,0 +1313,22 @@\n+.B \\f[CB]\\-XX:CRaCCheckpointTo=\\f[R]\\f[I]directory\\f[R]\n+The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+a running Java program into an image directory. Restoring from the image should\n+solve some of the problematic start-up and warm-up times.\n+.PP\n+This option defines a path to the snapshot which is currently a directory. The\n+directory will be created if it does not exist, but no parent directories are\n+created.\n+.RS\n+.RE\n+.TP\n+.B \\f[CB]\\-XX:CRaCRestoreFrom=\\f[R]\\f[I]directory\\f[R]\n+Restores a snapshot created by\n+\\f[CB]\\-XX:CRaCCheckpointTo=\\f[R]\\f[I]directory\\f[R].\n+.RS\n+.RE\n+.TP\n+.B \\f[CB]\\-XX:CRaCMinPid=\\f[R]value\\f[R]\n+A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+.RS\n+.RE\n+.TP\n@@ -2351,0 +2373,9 @@\n+.B \\f[CB]\\-XX:CPUFeatures=\\f[R]\\f[I]0xnumber\\f[R]\n+CPU feature set, use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when\n+you get an error during -XX:CRaCRestoreFrom on a different machine.\n+\\f[CB]\\-XX:CPUFeatures=native\\f[R] is the default.\n+\\f[CB]\\-XX:CPUFeatures=generic\\f[R] is compatible with any CPU but not as slow\n+as \\f[CB]\\-XX:CPUFeatures=0\\f[R].\n+.RS\n+.RE\n+.TP\n@@ -2632,0 +2663,6 @@\n+.B \\f[CB]\\-XX:+ShowCPUFeatures\\f[R]\n+Show features of this CPU to be possibly used for the\n+\\f[CB]\\-XX:CPUFeatures=0xnumber\\f[R] option.\n+.RS\n+.RE\n+.TP\n","filename":"src\/java.base\/share\/man\/java.1","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -37,0 +37,7 @@\n+#ifndef WIN32\n+#include <errno.h>\n+#endif\n+#ifdef LINUX\n+#include <syscall.h>\n+#endif\n+\n@@ -96,0 +103,143 @@\n+\n+#ifndef _WIN32\n+#include <sys\/wait.h>\n+\n+static int is_checkpoint = 0;\n+static const int crac_min_pid_default = 128;\n+static int crac_min_pid = 0;\n+static int is_min_pid_set = 0;\n+\n+static void parse_checkpoint(const char *arg) {\n+    if (!is_checkpoint) {\n+        const char *checkpoint_arg = \"-XX:CRaCCheckpointTo\";\n+        const int len = strlen(checkpoint_arg);\n+        if (0 == strncmp(arg, checkpoint_arg, len)) {\n+            is_checkpoint = 1;\n+        }\n+    }\n+    if (!is_min_pid_set) {\n+        const char *checkpoint_arg = \"-XX:CRaCMinPid=\";\n+        const int len = strlen(checkpoint_arg);\n+        if (0 == strncmp(arg, checkpoint_arg, len)) {\n+            crac_min_pid = atoi(arg + len);\n+            is_min_pid_set = 1;\n+        }\n+    }\n+}\n+\n+static pid_t g_child_pid = -1;\n+\n+static int wait_for_children() {\n+    int status = -1;\n+    pid_t pid;\n+    do {\n+        int st = 0;\n+        pid = wait(&st);\n+        if (pid == g_child_pid) {\n+            status = st;\n+        }\n+    } while (-1 != pid || ECHILD != errno);\n+\n+    if (WIFEXITED(status)) {\n+        return WEXITSTATUS(status);\n+    }\n+\n+    if (WIFSIGNALED(status)) {\n+        \/\/ Try to terminate the current process with the same signal\n+        \/\/ as the child process was terminated\n+        const int sig = WTERMSIG(status);\n+        signal(sig, SIG_DFL);\n+        raise(sig);\n+        \/\/ Signal was ignored, return 128+n as bash does\n+        \/\/ see https:\/\/linux.die.net\/man\/1\/bash\n+        return 128+sig;\n+    }\n+\n+    return 1;\n+}\n+\n+static void sighandler(int sig, siginfo_t *info, void *param) {\n+    if (0 < g_child_pid) {\n+        kill(g_child_pid, sig);\n+    }\n+}\n+\n+static void setup_sighandler() {\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    const int MaxSignalValue = 31;\n+    for (int sig = 1; sig <= MaxSignalValue; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(\"sigprocmask\");\n+    }\n+}\n+\n+static int set_last_pid(int pid) {\n+#ifdef LINUX\n+    char buf[11]; \/\/ enough for int32\n+    const int len = snprintf(buf, sizeof(buf), \"%d\", pid);\n+    if (0 > len || sizeof(buf) < (size_t)len) {\n+        return EINVAL;\n+    }\n+    const char *last_pid_filename = \"\/proc\/sys\/kernel\/ns_last_pid\";\n+    const int last_pid_file = open(last_pid_filename, O_WRONLY|O_TRUNC, 0666);\n+    if (0 > last_pid_file) {\n+        return errno;\n+    }\n+    int res = 0;\n+    if (len > write(last_pid_file, buf, len)) {\n+        res = errno;\n+    }\n+    close(last_pid_file);\n+    return res;\n+#else\n+    return EPERM;\n+#endif\n+}\n+\n+static void spin_last_pid(int pid) {\n+    const int MaxSpinCount = pid < 1000 ? 1000 : pid;\n+    int cnt = MaxSpinCount;\n+    int child = 0;\n+    int prev = 0;\n+    do {\n+        child = fork();\n+        if (0 > child) {\n+            perror(\"spin_last_pid clone\");\n+            exit(1);\n+        }\n+        if (0 == child) {\n+            exit(0);\n+        }\n+        if (child < prev) {\n+            fprintf(stderr, \"%s: Invalid argument (%d)\\n\", __FUNCTION__, pid);\n+            exit(1);\n+        }\n+        if (0 >= cnt) {\n+            fprintf(stderr, \"%s: Can't reach pid %d, out of try count. Current pid=%d\\n\", __FUNCTION__, pid, child);\n+            exit(1);\n+        }\n+        prev = child;\n+        int status;\n+        if (0 > waitpid(child, &status, 0)) {\n+            perror(\"spin_last_pid waitpid\");\n+            exit(1);\n+        }\n+        --cnt;\n+    } while (child < pid);\n+}\n+#endif \/\/ _WIN32\n+\n@@ -186,0 +336,1 @@\n+            parse_checkpoint(argv[i]);\n@@ -205,0 +356,40 @@\n+\n+    const int is_init = 1 == getpid();\n+    if (is_init && !is_min_pid_set) {\n+        crac_min_pid = crac_min_pid_default;\n+    }\n+    const int needs_pid_adjust = getpid() < crac_min_pid;\n+    if (is_checkpoint && (is_init || needs_pid_adjust)) {\n+        \/\/ Move PID value for new processes to a desired value\n+        \/\/ to avoid PID conflicts on restore.\n+        if (needs_pid_adjust) {\n+            const int res = set_last_pid(crac_min_pid);\n+            if (EPERM == res || EACCES == res || EROFS == res) {\n+                spin_last_pid(crac_min_pid);\n+            } else if (0 != res) {\n+                fprintf(stderr, \"set_last_pid: %s\\n\", strerror(res));\n+                exit(1);\n+            }\n+        }\n+\n+        \/\/ Avoid unexpected process completion when checkpointing under docker container run\n+        \/\/ by creating the main process waiting for children before exit.\n+        g_child_pid = fork();\n+        if (0 == g_child_pid && needs_pid_adjust && getpid() < crac_min_pid) {\n+            if (is_min_pid_set) {\n+                fprintf(stderr, \"Error: Can't adjust PID to min PID %d, current PID %d\\n\", crac_min_pid, (int)getpid());\n+                exit(1);\n+            } else {\n+                fprintf(stderr,\n+                        \"Warning: Can't adjust PID to min PID %d, current PID %d.\\n\"\n+                        \"This message can be suppressed by '-XX:CRaCMinPid=1' option\\n\",\n+                        crac_min_pid, (int)getpid());\n+            }\n+        }\n+        if (0 < g_child_pid) {\n+            \/\/ The main process should forward signals to the child.\n+            setup_sighandler();\n+            const int status = wait_for_children();\n+            exit(status);\n+        }\n+    }\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":191,"deletions":0,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/** \\file *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+#include \"jni_util.h\"\n+#include \"io_util.h\"\n+#include \"io_util_md.h\"\n+\n+#include \"jdk_crac_Core.h\"\n+\n+JNIEXPORT jobjectArray JNICALL\n+Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jarray fdArr, jobjectArray objArr, jboolean dry_run, jlong jcmd_stream) {\n+    return JVM_Checkpoint(env, fdArr, objArr, dry_run, jcmd_stream);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+\n+#ifdef LINUX\n+#include <unistd.h>\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#else\n+typedef int pid_t;\n+#endif \/\/LINUX\n+\n+static int kickjvm(pid_t jvm, int code) {\n+#ifdef LINUX\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+#endif \/\/LINUX\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+    char* imagedir = argv[2];\n+\n+    char pidpath[1024];\n+    if (0 > snprintf(pidpath, sizeof(pidpath), \"%s\/pid\", imagedir)) {\n+        return 1;\n+    }\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+#ifdef LINUX\n+        pid_t jvm = getppid();\n+#else\n+        pid_t jvm = -1;\n+#endif \/\/LINUX\n+\n+        FILE *pidfile = fopen(pidpath, \"w\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            kickjvm(jvm, -1);\n+            return 1;\n+        }\n+\n+        fprintf(pidfile, \"%d\\n\", jvm);\n+        fclose(pidfile);\n+\n+    } else if (!strcmp(action, \"restore\")) {\n+        FILE *pidfile = fopen(pidpath, \"r\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            return 1;\n+        }\n+\n+        pid_t jvm;\n+        if (1 != fscanf(pidfile, \"%d\", &jvm)) {\n+            fclose(pidfile);\n+            fprintf(stderr, \"cannot read pid\\n\");\n+            return 1;\n+        }\n+        fclose(pidfile);\n+\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        if (kickjvm(jvm, strid ? atoi(strid) : 0)) {\n+            return 1;\n+        }\n+\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/share\/native\/pauseengine\/pauseengine.c","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+\n+#ifdef LINUX\n+#include <unistd.h>\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#else\n+typedef int pid_t;\n+#endif \/\/LINUX\n+\n+static int kickjvm(pid_t jvm, int code) {\n+#ifdef LINUX\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+#endif \/\/LINUX\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+        const char* argsidstr = getenv(\"SIM_CRAC_NEW_ARGS_ID\");\n+        int argsid = argsidstr ? atoi(argsidstr) : 0;\n+#ifdef LINUX\n+        pid_t jvm = getppid();\n+#else\n+        pid_t jvm = -1;\n+#endif \/\/LINUX\n+        kickjvm(jvm, argsid);\n+    } else if (!strcmp(action, \"restore\")) {\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        printf(\"SIM_CRAC_NEW_ARGS_ID=%s\\n\", strid ? strid : \"0\");\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/share\/native\/simengine\/simengine.c","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n@@ -57,1 +58,4 @@\n-import java.io.*;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+\n@@ -63,2 +67,20 @@\n-    private static final HashMap<Variable,Value> theEnvironment;\n-    private static final Map<String,String> theUnmodifiableEnvironment;\n+    private static class CracSubscriber\n+            implements jdk.internal.crac.JDKResource {\n+\n+        CracSubscriber() {\n+            Core.Priority.NORMAL.getContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            ProcessEnvironment.updateEnvironment();\n+        }\n+    }\n+\n+    private static HashMap<Variable,Value> theEnvironment;\n+    private static Map<String,String> theUnmodifiableEnvironment;\n+    private static final CracSubscriber theCracSubscriber;\n@@ -81,0 +103,2 @@\n+\n+        theCracSubscriber = new CracSubscriber();\n@@ -105,0 +129,14 @@\n+    static private void updateEnvironment() {\n+        byte[][] environ = environ();\n+        \/\/ Read environment variables back to front,\n+        \/\/ so that earlier variables override later ones.\n+        for (int i = environ.length-1; i > 0; i-=2) {\n+            theEnvironment.put(Variable.valueOf(environ[i-1]),\n+                               Value.valueOf(environ[i]));\n+        }\n+\n+        theUnmodifiableEnvironment\n+            = Collections.unmodifiableMap\n+            (new StringEnvironment(theEnvironment));\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessEnvironment.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import java.util.Properties;\n@@ -51,0 +50,1 @@\n+import jdk.internal.crac.JDKFdResource;\n@@ -625,0 +625,2 @@\n+        private final JDKFdResource resource;\n+\n@@ -626,1 +628,6 @@\n-            super(new FileOutputStream(newFileDescriptor(fd)));\n+            this(newFileDescriptor(fd));\n+        }\n+\n+        private ProcessPipeOutputStream(FileDescriptor fd) {\n+            super(new FileOutputStream(fd));\n+            resource = new PipeResource(this, fd);\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,3 +28,5 @@\n-import java.util.Set;\n-import java.util.HashSet;\n-import sun.net.ext.ExtendedSocketOptions;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -40,0 +42,18 @@\n+    static class ResourceProxy implements JDKResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            PlainSocketImpl.beforeCheckpoint();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            PlainSocketImpl.afterRestore();\n+        }\n+    }\n+\n+    static Object closeLock = new Object();\n+    static boolean forceNonDeferedClose;\n+    static int closeCnt;\n+\n+    static JDKResource resourceProxy = new ResourceProxy();\n+\n@@ -42,0 +62,1 @@\n+        Core.Priority.NORMAL.getContext().register(resourceProxy);\n@@ -64,0 +85,44 @@\n+    @Override\n+    void socketClose0(boolean useDeferredClose) throws IOException {\n+        if (useDeferredClose) {\n+            synchronized (closeLock) {\n+                if (forceNonDeferedClose) {\n+                    useDeferredClose = false;\n+                }\n+                if (useDeferredClose) {\n+                    ++closeCnt;\n+                }\n+            }\n+        }\n+\n+        try {\n+            socketClose1(useDeferredClose);\n+        } finally {\n+            if (useDeferredClose) {\n+                synchronized (closeLock) {\n+                    --closeCnt;\n+                    if (forceNonDeferedClose && closeCnt == 0) {\n+                        closeLock.notifyAll();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void beforeCheckpoint() throws InterruptedException {\n+        synchronized (closeLock) {\n+            forceNonDeferedClose = true;\n+            while (closeCnt != 0) {\n+                closeLock.wait();\n+            }\n+            beforeCheckpoint0();\n+        }\n+    }\n+\n+    static void afterRestore() {\n+        synchronized (closeLock) {\n+            afterRestore0();\n+            forceNonDeferedClose = false;\n+        }\n+    }\n+\n@@ -82,1 +147,1 @@\n-    native void socketClose0(boolean useDeferredClose) throws IOException;\n+    native void socketClose1(boolean useDeferredClose) throws IOException;\n@@ -94,0 +159,4 @@\n+\n+    static native void beforeCheckpoint0();\n+\n+    static native void afterRestore0();\n","filename":"src\/java.base\/unix\/classes\/java\/net\/PlainSocketImpl.java","additions":73,"deletions":4,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.WeakHashMap;\n@@ -35,0 +36,2 @@\n+\n+import jdk.internal.crac.Core;\n@@ -36,0 +39,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n@@ -40,0 +45,3 @@\n+ * @crac All JarFile instances that are not referenced from elsewhere are\n+ * removed from the cache before a checkpoint.\n+ *\n@@ -43,1 +51,1 @@\n-class JarFileFactory implements URLJarFile.URLJarFileCloseController {\n+class JarFileFactory implements URLJarFile.URLJarFileCloseController, jdk.internal.crac.JDKResource {\n@@ -53,1 +61,3 @@\n-    private JarFileFactory() { }\n+    private JarFileFactory() {\n+        Core.Priority.NORMAL.getContext().register(this);\n+    }\n@@ -239,0 +249,26 @@\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        \/\/ Need to clear cached entries that are held by the factory only (e.g.\n+        \/\/ after JarURLInputStream.close with useCaches == true).  Creating a\n+        \/\/ temporary weak cache and triggering GC to get know JARs really in\n+        \/\/ use.\n+        synchronized (instance) {\n+            WeakHashMap<JarFile, URL> weakMap = new WeakHashMap<>(urlCache);\n+            fileCache.clear();\n+            urlCache.clear();\n+\n+            System.gc();\n+\n+            weakMap.forEach((JarFile jarFile, URL url) -> {\n+                String key = urlKey(url);\n+                urlCache.put(jarFile, url);\n+                fileCache.put(key, jarFile);\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        FileDispatcherImpl.close0(fd);\n+        FileDispatcherImpl.closeAndMark(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/DatagramDispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n@@ -33,0 +35,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -35,0 +39,18 @@\n+    static class ResourceProxy implements JDKResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            FileDispatcherImpl.beforeCheckpoint();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context)\n+                throws IOException {\n+            FileDispatcherImpl.afterRestore();\n+        }\n+    }\n+\n+    static Object closeLock = new Object();\n+    static boolean forceNonDeferedClose;\n+    static int closeCnt;\n+\n+    static ResourceProxy resourceProxy = new ResourceProxy();\n@@ -39,0 +61,4 @@\n+        \/\/ We cannot register using normal priority because other JDK resources\n+        \/\/ might read configuration files with this or later priority.\n+        \/\/ It's difficult to trigger static initialization outside the package.\n+        Core.Priority.PRE_FILE_DESCRIPTORS.getContext().register(resourceProxy);\n@@ -108,1 +134,24 @@\n-        preClose0(fd);\n+        boolean doPreclose = true;\n+        synchronized (closeLock) {\n+            if (forceNonDeferedClose) {\n+                doPreclose = false;\n+            }\n+            if (doPreclose) {\n+                ++closeCnt;\n+            }\n+        }\n+\n+        if (!doPreclose) {\n+            return;\n+        }\n+\n+        try {\n+            preClose0(fd);\n+        } finally {\n+            synchronized (closeLock) {\n+                closeCnt--;\n+                if (forceNonDeferedClose && closeCnt == 0) {\n+                    closeLock.notifyAll();\n+                }\n+            }\n+        }\n@@ -144,0 +193,26 @@\n+    static void beforeCheckpoint() throws InterruptedException {\n+        synchronized (closeLock) {\n+            forceNonDeferedClose = true;\n+            while (closeCnt != 0) {\n+                closeLock.wait();\n+            }\n+            beforeCheckpoint0();\n+        }\n+    }\n+\n+    static void afterRestore() throws IOException {\n+        synchronized (closeLock) {\n+            afterRestore0();\n+            forceNonDeferedClose = false;\n+        }\n+    }\n+\n+    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n+    \/\/ NOT used by FileDispatcherImpl\n+    static void closeAndMark(FileDescriptor fd) throws IOException {\n+        \/\/ Originally this used fdAccess.markClosed() and close0() but leaving\n+        \/\/ the FD value set breaks JDKSocketResource (we don't want the extra\n+        \/\/ test if the FD resource has been marked).\n+        fdAccess.close(fd);\n+    }\n+\n@@ -181,3 +256,1 @@\n-    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n-    \/\/ NOT used by FileDispatcherImpl\n-    static native void close0(FileDescriptor fd) throws IOException;\n+    private static native void close0(FileDescriptor fd) throws IOException;\n@@ -197,0 +270,3 @@\n+    static native void beforeCheckpoint0();\n+\n+    static native void afterRestore0() throws IOException;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":80,"deletions":4,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -28,0 +28,8 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.LoggerContainer;\n+\n@@ -31,1 +39,2 @@\n-\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n@@ -38,2 +47,35 @@\n-    private final SourceChannel source;\n-    private final SinkChannel sink;\n+    private final SourceChannelImpl source;\n+    private final SinkChannelImpl sink;\n+    private final JDKFdResource resource = new JDKFdResource() {\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            OpenResourcePolicies.Policy policy = OpenResourcePolicies.find(false, OpenResourcePolicies.PIPE, null);\n+            String action = policy != null ? policy.action.toLowerCase() : \"error\";\n+            switch (action) {\n+                case \"error\":\n+                    \/\/ We will report the error only once\n+                    AtomicBoolean reported = new AtomicBoolean();\n+                    Supplier<Exception> supplier = () -> reported.getAndSet(true) ? null :\n+                            new CheckpointOpenResourceException(toString(), getStackTraceHolder());\n+                    Core.getClaimedFDs().claimFd(source.getFD(), this, supplier, source.getFD());\n+                    Core.getClaimedFDs().claimFd(sink.getFD(), this, supplier, sink.getFD());\n+                    break;\n+                case \"close\":\n+                    source.close();\n+                    sink.close();\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    warnOpenResource(policy, PipeImpl.this.toString());\n+                    Core.getClaimedFDs().claimFd(source.getFD(), this, NO_EXCEPTION, source.getFD());\n+                    Core.getClaimedFDs().claimFd(sink.getFD(), this, NO_EXCEPTION, sink.getFD());\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + PipeImpl.this, null);\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public String toString() {\n+        return \"Pipe \" + source.getFDVal() + \" -> \" + sink.getFDVal();\n+    }\n@@ -60,1 +102,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/PipeImpl.java","additions":45,"deletions":4,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        FileDispatcherImpl.close0(fd);\n+        FileDispatcherImpl.closeAndMark(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SocketDispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n@@ -33,0 +34,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -73,0 +78,5 @@\n+ * @crac Before checkpoint the underlying random number generator is discarded\n+ * and after restore a new {@link sun.security.provider.SecureRandom} is\n+ * created, therefore this produces different sequences when restored multiple\n+ * times.\n+ *\n@@ -332,1 +342,1 @@\n-    private static class RandomIO {\n+    private static class RandomIO implements JDKResource {\n@@ -386,0 +396,4 @@\n+        \/\/ lock for checkpoint\/restore\n+        \/\/ allows clearing mixRandom and internal buffer before checkpoint\n+        private final ReentrantReadWriteLock crLock = new ReentrantReadWriteLock();\n+\n@@ -392,0 +406,1 @@\n+            Core.Priority.NATIVE_PRNG.getContext().register(this);\n@@ -478,1 +493,9 @@\n-                getMixRandom().engineSetSeed(seed);\n+                crLock.readLock().lock();\n+                try {\n+                    if(crLock.getWriteHoldCount() != 0) {\n+                        throw new IllegalStateException(\"PRNG object is invalidated\");\n+                    }\n+                    getMixRandom().engineSetSeed(seed);\n+                } finally {\n+                    crLock.readLock().unlock();\n+                }\n@@ -536,0 +559,1 @@\n+            crLock.readLock().lock();\n@@ -537,0 +561,3 @@\n+                    if(crLock.getWriteHoldCount() != 0) {\n+                        throw new IllegalStateException(\"PRNG object is invalidated\");\n+                    }\n@@ -569,0 +596,2 @@\n+                } finally {\n+                    crLock.readLock().unlock();\n@@ -571,0 +600,15 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            synchronized (LOCK_SET_SEED) {\n+                if (seedOut != null) {\n+                    FileDescriptor fd = ((FileOutputStream)seedOut).getFD();\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+                }\n+            }\n+\n+            crLock.writeLock().lock();\n+            mixRandom = null;\n+            buffered = 0;\n+            lastRead = 0;\n+            Arrays.fill(nextBuffer, (byte)0);\n@@ -572,0 +616,6 @@\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            crLock.writeLock().unlock();\n+        }\n+    }\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":52,"deletions":2,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,477 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdbool.h>\n+#include <libgen.h>\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <getopt.h>\n+#include <signal.h>\n+#include <sys\/wait.h>\n+#include <sys\/stat.h>\n+#include <string>\n+#include <vector>\n+#include <iostream>\n+\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+#define PERFDATA_NAME \"perfdata\"\n+\n+#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(x[0]))\n+\n+#define SUPPRESS_ERROR_IN_PARENT 77\n+\n+static int create_cppath(const char *imagedir);\n+\n+static int g_pid;\n+\n+static char *verbosity = NULL; \/\/ default differs for checkpoint and restore\n+static char *log_file = NULL;\n+\n+static int kickjvm(pid_t jvm, int code) {\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+static std::string join_args(const std::vector<const char *> &args) {\n+    std::string retval;\n+    for (const char *s : args) {\n+        if (!s) {\n+            continue;\n+        }\n+        if (!retval.empty()) {\n+            retval += ' ';\n+        }\n+        \/\/ https:\/\/unix.stackexchange.com\/a\/357932\/296319\n+        if (!strpbrk(s, \" \\t\\n!\\\"#$&'()*,;<=>?[\\\\]^`{|}~\")) {\n+            retval += s;\n+            continue;\n+        }\n+        retval += '\\'';\n+        for (; *s; ++s) {\n+            if (*s != '\\'') {\n+                retval += *s;\n+            } else {\n+                retval += \"'\\\\''\";\n+            }\n+        }\n+        retval += '\\'';\n+    }\n+    return retval;\n+}\n+\n+static std::string path_abs(std::string rel) {\n+    if (rel[0] == '\/') {\n+        return rel;\n+    }\n+    char *cwd_s = get_current_dir_name();\n+    if (!cwd_s) {\n+        perror(\"get_current_dir_name\");\n+        exit(1);\n+    }\n+    std::string cwd = cwd_s;\n+    free(cwd_s);\n+    return cwd + \"\/\" + rel;\n+}\n+\n+static std::string path_abs(std::string rel1, std::string rel2) {\n+    if (rel2[0] == '\/') {\n+        return rel2;\n+    }\n+    return path_abs(rel1) + \"\/\" + rel2;\n+}\n+\n+static int checkpoint(pid_t jvm,\n+        const char *basedir,\n+        const char *self,\n+        const char *criu,\n+        const char *imagedir) {\n+\n+    if (fork()) {\n+        \/\/ main process\n+        wait(NULL);\n+        return 0;\n+    }\n+\n+    pid_t parent_before = getpid();\n+\n+    \/\/ child\n+    if (fork()) {\n+        exit(0);\n+    }\n+\n+    \/\/ grand-child\n+    pid_t parent = getppid();\n+    int tries = 300;\n+    while (parent != 1 && 0 < tries--) {\n+        usleep(10);\n+        parent = getppid();\n+    }\n+\n+    if (parent == parent_before) {\n+        fprintf(stderr, \"can't move out of JVM process hierarchy\");\n+        kickjvm(jvm, -1);\n+        exit(0);\n+    }\n+\n+    char* leave_running = getenv(\"CRAC_CRIU_LEAVE_RUNNING\");\n+\n+    char jvmpidchar[32];\n+    snprintf(jvmpidchar, sizeof(jvmpidchar), \"%d\", jvm);\n+\n+    std::vector<const char *> args = {\n+        criu,\n+        \"dump\",\n+        \"-t\", jvmpidchar,\n+        \"-D\", imagedir,\n+        \"--shell-job\",\n+    };\n+\n+    args.push_back(verbosity != NULL ? verbosity : \"-v4\");\n+    args.push_back(\"-o\");\n+    \/\/ -D without -W makes criu cd to image dir for logs\n+    const char *log_local = log_file != NULL ? log_file : \"dump4.log\";\n+    args.push_back(log_local);\n+\n+    if (leave_running) {\n+        args.push_back(\"-R\");\n+    }\n+\n+    char *criuopts = getenv(\"CRAC_CRIU_OPTS\");\n+    if (criuopts) {\n+        char* criuopt = strtok(criuopts, \" \");\n+        while (criuopt) {\n+            args.push_back(criuopt);\n+            criuopt = strtok(NULL, \" \");\n+        }\n+    }\n+    args.push_back(NULL);\n+\n+    pid_t child = fork();\n+    if (!child) {\n+        execv(criu, const_cast<char **>(args.data()));\n+        std::cerr << \"Cannot execute CRIU \\\"\" << join_args(args) << \"\\\": \" << strerror(errno) << std::endl;\n+        exit(SUPPRESS_ERROR_IN_PARENT);\n+    }\n+\n+    int status;\n+    if (child != wait(&status)) {\n+        std::cerr << \"Error waiting for CRIU: \" << strerror(errno) << std::endl\n+            << \"Command: \" << join_args(args) << std::endl;\n+        kickjvm(jvm, -1);\n+    } else if (!WIFEXITED(status)) {\n+        std::cerr << \"CRIU has not properly exited, waitpid status was %d - check \" << path_abs(imagedir, log_local) << std::endl\n+            << \"Command: \" << join_args(args) << std::endl;\n+        kickjvm(jvm, -1);\n+    } else if (WEXITSTATUS(status)) {\n+        if (WEXITSTATUS(status) != SUPPRESS_ERROR_IN_PARENT) {\n+            std::cerr << \"CRIU failed with exit code \" << WEXITSTATUS(status) << \" - check \" << path_abs(imagedir, log_local) << std::endl\n+                << \"Command: \" << join_args(args) << std::endl;\n+        }\n+        kickjvm(jvm, -1);\n+    } else if (leave_running) {\n+        kickjvm(jvm, 0);\n+    }\n+\n+    create_cppath(imagedir);\n+    exit(0);\n+}\n+\n+static int restore(const char *basedir,\n+        const char *self,\n+        const char *criu,\n+        const char *imagedir) {\n+    std::string cppathpath = std::string(imagedir) + \"\/cppath\";\n+\n+    int fd = open(cppathpath.c_str(), O_RDONLY);\n+    if (fd < 0) {\n+        std::cerr << \"CRaC restore - cannot open cppath file \\\"\" << path_abs(cppathpath) << \"\\\": \" << strerror(errno) << std::endl;\n+        return 1;\n+    }\n+\n+    char cppath[PATH_MAX];\n+    int cppathlen = 0;\n+    int r;\n+    while ((r = read(fd, cppath + cppathlen, sizeof(cppath) - cppathlen - 1)) != 0) {\n+        if (r < 0 && errno == EINTR) {\n+            continue;\n+        }\n+        if (r < 0) {\n+            perror(\"read cppath\");\n+            return 1;\n+        }\n+        cppathlen += r;\n+    }\n+    cppath[cppathlen] = '\\0';\n+\n+    close(fd);\n+\n+    std::string inherit_perfdata;\n+    std::string perfdatapath = std::string(imagedir) + \"\/\" PERFDATA_NAME;\n+    int perfdatafd = open(perfdatapath.c_str(), O_RDWR);\n+    if (0 < perfdatafd) {\n+        inherit_perfdata = \"fd[\" + std::to_string(perfdatafd) + \"]:\" + std::string(cppath[0] == '\/' ? cppath + 1 : cppath) + \"\/\" PERFDATA_NAME;\n+    }\n+\n+    std::vector<const char *> args = {\n+        criu,\n+        \"restore\",\n+        \"-W\", \".\",\n+        \"--shell-job\",\n+        \"--action-script\", self,\n+        \"-D\", imagedir,\n+    };\n+\n+    args.push_back(verbosity != NULL ? verbosity : \"-v1\");\n+    if (log_file != NULL) {\n+        args.push_back(\"-o\");\n+        args.push_back(log_file);\n+    }\n+\n+    if (!inherit_perfdata.empty()) {\n+        args.push_back(\"--inherit-fd\");\n+        args.push_back(inherit_perfdata.c_str());\n+    }\n+    char *criuopts = getenv(\"CRAC_CRIU_OPTS\");\n+    if (criuopts) {\n+        char* criuopt = strtok(criuopts, \" \");\n+        while (criuopt) {\n+            args.push_back(criuopt);\n+            criuopt = strtok(NULL, \" \");\n+        }\n+    }\n+\n+    const std::vector<const char *> tail = {\n+        \"--exec-cmd\", \"--\", self, \"restorewait\", NULL,\n+    };\n+    args.insert(args.end(), tail.begin(), tail.end());\n+\n+    fflush(stderr);\n+\n+    execv(criu, const_cast<char **>(args.data()));\n+    std::cerr << \"Cannot execute CRIU \\\"\" << join_args(args) << \"\\\": \" << strerror(errno) << std::endl;\n+    return 1;\n+}\n+\n+#define MSGPREFIX \"\"\n+\n+static int post_resume(void) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"cannot find CRTOOLS_INIT_PID env\\n\");\n+        return 1;\n+    }\n+    int pid = atoi(pidstr);\n+\n+    char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+    return kickjvm(pid, strid ? atoi(strid) : 0);\n+}\n+\n+static int create_cppath(const char *imagedir) {\n+    char realdir[PATH_MAX];\n+\n+    if (!realpath(imagedir, realdir)) {\n+        fprintf(stderr, MSGPREFIX \"cannot canonicalize %s: %s\\n\", imagedir, strerror(errno));\n+        return 1;\n+    }\n+\n+    int dirfd = open(realdir, O_DIRECTORY);\n+    if (dirfd < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not open image dir %s: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+\n+    int fd = openat(dirfd, \"cppath\", O_CREAT | O_WRONLY | O_TRUNC, 0644);\n+    if (fd < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not open file %s\/cppath: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+\n+    if (write(fd, realdir, strlen(realdir)) < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not write %s\/cppath: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+static void sighandler(int sig, siginfo_t *info, void *uc) {\n+    if (0 <= g_pid) {\n+        kill(g_pid, sig);\n+    }\n+}\n+\n+static int restorewait(void) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"no CRTOOLS_INIT_PID: signals may not be delivered\\n\");\n+    }\n+    g_pid = pidstr ? atoi(pidstr) : -1;\n+\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    int sig;\n+    for (sig = 1; sig <= 31; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(MSGPREFIX \"sigprocmask\");\n+    }\n+\n+    int status;\n+    int ret;\n+    do {\n+        ret = waitpid(g_pid, &status, 0);\n+    } while (ret == -1 && errno == EINTR);\n+\n+    if (ret == -1) {\n+        perror(MSGPREFIX \"waitpid\");\n+        return 1;\n+    }\n+\n+    if (WIFEXITED(status)) {\n+        return WEXITSTATUS(status);\n+    }\n+\n+    if (WIFSIGNALED(status)) {\n+        \/\/ Try to terminate the current process with the same signal\n+        \/\/ as the child process was terminated\n+        const int sig = WTERMSIG(status);\n+        signal(sig, SIG_DFL);\n+        raise(sig);\n+        \/\/ Signal was ignored, return 128+n as bash does\n+        \/\/ see https:\/\/linux.die.net\/man\/1\/bash\n+        return 128+sig;\n+    }\n+\n+    return 1;\n+}\n+\n+\/\/ return value is one argument after options\n+static char *parse_options(int argc, char *argv[]) {\n+    optind = 2; \/\/ starting after action\n+    struct option opts[] = {{\n+        .name = \"verbosity\",\n+        .has_arg = 1,\n+        .flag = NULL,\n+        .val = 'v'\n+    }, {\n+        .name = \"log-file\",\n+        .has_arg = 1,\n+        .flag = NULL,\n+        .val = 'o',\n+    }, { NULL, 0, NULL, 0} };\n+    bool processing = true;\n+    do {\n+        switch (getopt_long(argc, argv, \"v:o:\", opts, NULL)) {\n+            case -1:\n+            case '?':\n+                processing = false;\n+                break;\n+            case 'v':\n+                if (asprintf(&verbosity, \"--verbosity=%s\", optarg) < 0) {\n+                    fprintf(stderr, \"Cannot set verbosity level\\n\");\n+                    verbosity = NULL;\n+                }\n+                break;\n+            case 'o':\n+                log_file = optarg;\n+                break;\n+        }\n+    } while (processing);\n+    return optind < argc ? argv[optind] : NULL;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action;\n+    if (argc >= 2 && (action = argv[1])) {\n+\n+        char* imagedir = parse_options(argc, argv);\n+\n+        char *basedir = dirname(strdup(argv[0]));\n+\n+        std::string criu;\n+        const char *criu_s = getenv(\"CRAC_CRIU_PATH\");\n+        if (criu_s) {\n+          criu = criu_s;\n+        } else {\n+            criu = std::string(basedir) + \"\/criu\";\n+            struct stat st;\n+            if (stat(criu.c_str(), &st)) {\n+                \/* some problem with the bundled criu *\/\n+                criu = \"\/usr\/sbin\/criu\";\n+                if (stat(criu.c_str(), &st)) {\n+                    fprintf(stderr, \"cannot find CRIU to use\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+\n+\n+        if (!strcmp(action, \"checkpoint\")) {\n+            pid_t jvm = getppid();\n+            return checkpoint(jvm, basedir, argv[0], criu.c_str(), imagedir);\n+        } else if (!strcmp(action, \"restore\")) {\n+            return restore(basedir, argv[0], criu.c_str(), imagedir);\n+        } else if (!strcmp(action, \"restorewait\")) { \/\/ called by CRIU --exec-cmd\n+            return restorewait();\n+        } else {\n+            fprintf(stderr, \"unknown command-line action: %s\\n\", action);\n+            return 1;\n+        }\n+    } else if ((action = getenv(\"CRTOOLS_SCRIPT_ACTION\"))) { \/\/ called by CRIU --action-script\n+        if (!strcmp(action, \"post-resume\")) {\n+            return post_resume();\n+        } else {\n+            \/\/ ignore other notifications\n+            return 0;\n+        }\n+    } else {\n+        fprintf(stderr, \"unknown context\\n\");\n+    }\n+\n+    return 1;\n+}\n","filename":"src\/java.base\/unix\/native\/criuengine\/criuengine.cpp","additions":477,"deletions":0,"binary":false,"changes":477,"status":"added"},{"patch":"@@ -25,2 +25,0 @@\n-\n-#include <unistd.h>\n@@ -28,0 +26,3 @@\n+#include <inttypes.h>\n+#include <stdbool.h>\n+#include <unistd.h>\n@@ -36,0 +37,9 @@\n+#include <sys\/socket.h>\n+#include <netinet\/in.h>\n+\n+typedef union {\n+    struct sockaddr     sa;\n+    struct sockaddr_in  sa4;\n+    struct sockaddr_in6 sa6;\n+} socketaddress;\n+\n@@ -92,0 +102,116 @@\n+\n+static const char* stat2strtype(mode_t mode) {\n+    switch (mode & S_IFMT) {\n+        case S_IFSOCK: return \"socket\";\n+        case S_IFLNK:  return \"symlink\";\n+        case S_IFREG:  return \"regular\";\n+        case S_IFBLK:  return \"block\";\n+        case S_IFDIR:  return \"directory\";\n+        case S_IFCHR:  return \"character\";\n+        case S_IFIFO:  return \"fifo\";\n+        default:       break;\n+    }\n+    return \"unknown\";\n+}\n+\n+static const char* family2str(int family) {\n+    switch (family) {\n+        case AF_UNIX: return \"AF_UNIX\";\n+        case AF_INET: return \"AF_INET\";\n+        case AF_INET6: return \"AF_INET6\";\n+        default: break;\n+    }\n+    return \"UNKNOWN\";\n+}\n+\n+static const char* socktype2str(int socktype) {\n+    switch (socktype) {\n+        case SOCK_STREAM: return \"SOCK_STREAM\";\n+        case SOCK_DGRAM: return \"SOCK_DGRAM\";\n+        case SOCK_RAW: return \"SOCK_RAW\";\n+        default: break;\n+    }\n+    return \"SOCK_RAW\";\n+}\n+\n+static char* fmtaddr(char *buf, const char *end, unsigned char* addr, int len) {\n+    while (buf + 2 < end && 0 < len) {\n+        sprintf(buf, \"%02x\", *addr);\n+        buf += 2;\n+        len -= 1;\n+        addr += 1;\n+    }\n+    return buf;\n+}\n+\n+__attribute__((__format__ (__printf__, 3, 0)))\n+static jstring format_string(JNIEnv *env, struct stat *st, const char *fmt, ...) {\n+    char details[PATH_MAX];\n+    va_list va;\n+\n+    va_start(va, fmt);\n+    int len = vsnprintf(details, sizeof(details), fmt, va);\n+    va_end(va);\n+\n+    \/\/ ensure terminated string\n+    details[sizeof(details) - 1] = '\\0';\n+    return (*env)->NewStringUTF(env, details);\n+}\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_nativeDescription0(JNIEnv *env, jobject this) {\n+    FD fd = (*env)->GetIntField(env, this, IO_fd_fdID);\n+\n+    char fdpath[64];\n+    snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+    char link[PATH_MAX];\n+    int linklen = readlink(fdpath, link, PATH_MAX);\n+    if (linklen >= 0) {\n+        link[(unsigned)linklen < PATH_MAX ? linklen : PATH_MAX - 1] = '\\0';\n+    }\n+\n+    struct stat st;\n+    if (fstat(fd, &st) != 0) {\n+        \/\/ return just link value\n+        return (*env)->NewStringUTF(env, link);\n+    }\n+\n+    if ((st.st_mode & S_IFMT) != S_IFSOCK) {\n+        return format_string(env, &st, \"%s: %s\", stat2strtype(st.st_mode), link);\n+    }\n+\n+    struct sockaddr sa;\n+    socklen_t slen = sizeof(sa);\n+    if (getsockname(fd, &sa, &slen) != 0) {\n+        return format_string(env, &st, \"socket: %s\", link);\n+    }\n+\n+    const int family = sa.sa_family;\n+    int socktype;\n+    socklen_t typelen = sizeof(int);\n+    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &socktype, &typelen) != 0) {\n+        return format_string(env, &st, \"socket: family=%s\", family2str(family));\n+    }\n+\n+    socketaddress local;\n+    socklen_t llen = sizeof(socketaddress);\n+    if (getsockname(fd, &local.sa, &llen) != 0) {\n+        llen = 0;\n+    }\n+\n+    socketaddress remote;\n+    socklen_t rlen = sizeof(socketaddress);\n+    if (getpeername(fd, &remote.sa, &rlen) != 0) {\n+        rlen = 0;\n+    }\n+\n+    char details[PATH_MAX];\n+    int len = snprintf(details, sizeof(details),\n+            \"socket: family=%s type=%s localaddr=\", family2str(family), socktype2str(socktype));\n+    char *end = fmtaddr(details + len, details + sizeof(details), (unsigned char*)&local, llen);\n+    end += snprintf(end, details + sizeof(details) - end, \" remoteaddr=\");\n+    end = fmtaddr(end, details + sizeof(details), (unsigned char*)&remote, rlen);\n+    \/\/ ensure terminated string\n+    details[sizeof(details) - 1] = '\\0';\n+    return (*env)->NewStringUTF(env, details);\n+}\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":128,"deletions":2,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-                                    jstring path, jboolean append) {\n+                                    jstring path, jboolean append, jboolean truncate) {\n@@ -59,1 +59,1 @@\n-             O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC));\n+             O_WRONLY | O_CREAT | (append ? O_APPEND : 0) | (truncate ? O_TRUNC : 0));\n","filename":"src\/java.base\/unix\/native\/libjava\/FileOutputStream_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -665,0 +665,9 @@\n+    {\n+      const int restore_signal = SIGRTMIN + 2;\n+      \/\/ block restore_signal in launcher thread to allow JVM handle it\n+      sigset_t block_sig;\n+      sigemptyset(&block_sig);\n+      sigaddset(&block_sig, restore_signal);\n+      pthread_sigmask(SIG_BLOCK, &block_sig, NULL);\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -143,0 +143,13 @@\n+JNIEXPORT void JNICALL\n+Java_java_net_PlainSocketImpl_beforeCheckpoint0(JNIEnv *env, jclass cls) {\n+    \/* synchronized by closeLock *\/\n+    close(marker_fd);\n+    marker_fd = -1;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_net_PlainSocketImpl_afterRestore0(JNIEnv *env, jclass cls) {\n+    \/* synchronized by closeLock *\/\n+    marker_fd = getMarkerFD();\n+}\n+\n@@ -725,1 +738,1 @@\n-Java_java_net_PlainSocketImpl_socketClose0(JNIEnv *env, jobject this,\n+Java_java_net_PlainSocketImpl_socketClose1(JNIEnv *env, jobject this,\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainSocketImpl.c","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"net_util_md.h\"\n@@ -60,1 +61,0 @@\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketImpl.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,21 @@\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_beforeCheckpoint0(JNIEnv *env, jclass cl)\n+{\n+    \/* synchronized by closeLock *\/\n+    close(preCloseFD);\n+    preCloseFD = -1;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_afterRestore0(JNIEnv *env, jclass cl)\n+{\n+    \/* synchronized by closeLock *\/\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n+        return;\n+    }\n+    preCloseFD = sp[0];\n+    close(sp[1]);\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,0 +95,5 @@\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_nativeDescription0(JNIEnv *env, jobject this) {\n+    return (*env)->NewStringUTF(env, \"(not implemented)\");\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/windows\/native\/libjava\/FileDescriptor_md.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-                                    jstring path, jboolean append) {\n+                                    jstring path, jboolean append, jboolean truncate) {\n@@ -60,1 +60,1 @@\n-             O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC));\n+             O_WRONLY | O_CREAT | (append ? O_APPEND : 0) | (truncate ? O_TRUNC : 0));\n","filename":"src\/java.base\/windows\/native\/libjava\/FileOutputStream_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,0 +108,4 @@\n+\n+    \/\/ CRaC support\n+    public long getRestoreTime();\n+    public long getUptimeSinceRestore();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagement.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,0 +285,12 @@\n+\n+    \/\/ CRaC support\n+    private native long getRestoreTime0();\n+    private native long getUptimeSinceRestore0();\n+\n+    public long getRestoreTime() {\n+        return getRestoreTime0();\n+    }\n+\n+    public long getUptimeSinceRestore() {\n+        return getUptimeSinceRestore0();\n+    }\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagementImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -325,0 +325,16 @@\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_VMManagementImpl_getRestoreTime0\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return jmm_interface->GetLongAttribute(env, NULL,\n+                                           JMM_JVM_RESTORE_START_TIME_MS);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_VMManagementImpl_getUptimeSinceRestore0\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return jmm_interface->GetLongAttribute(env, NULL,\n+                                           JMM_JVM_UPTIME_SINCE_RESTORE_MS);\n+}\n","filename":"src\/java.management\/share\/native\/libmanagement\/VMManagementImpl.c","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -214,2 +214,6 @@\n-                        return path.getFileName().toString().equals(\"jspawnhelper\")\n-                                || path.getFileName().toString().equals(\"jexec\");\n+                        String fileName = path.getFileName().toString();\n+                        return fileName.equals(\"jspawnhelper\")\n+                            || fileName.equals(\"jexec\")\n+                            || fileName.equals(\"criuengine\")\n+                            || fileName.equals(\"pauseengine\")\n+                            || fileName.equals(\"simengine\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.crac.management.CRaCMXBean;\n@@ -44,0 +45,2 @@\n+\n+import jdk.crac.management.internal.CRaCImpl;\n@@ -56,0 +59,5 @@\n+    \/\/ CRaC\n+    private static CRaCMXBean cracMXBean = null;\n+    public static final String CRAC_MXBEAN_NAME =\n+        \"jdk.management:type=CRaC\";\n+\n@@ -267,0 +275,30 @@\n+        \/**\n+         * CRaC MXBean\n+         *\/\n+        initMBeanList.add(new PlatformComponent<CRaCMXBean>() {\n+            private final Set<String> cracMXBeanInterfaceNames =\n+                Collections.singleton(\"jdk.crac.management.CRaCMXBean\");\n+\n+            @Override\n+            public Set<Class<? extends CRaCMXBean>> mbeanInterfaces() {\n+                return Collections.singleton(CRaCMXBean.class);\n+            }\n+\n+            @Override\n+            public Set<String> mbeanInterfaceNames() {\n+                return cracMXBeanInterfaceNames;\n+            }\n+\n+            @Override\n+            public String getObjectNamePattern() {\n+                return CRAC_MXBEAN_NAME;\n+            }\n+\n+            @Override\n+            public Map<String, CRaCMXBean> nameToMBeanMap() {\n+                return Collections.<String, CRaCMXBean>singletonMap(\n+                    CRAC_MXBEAN_NAME,\n+                    getCRaCMXBean());\n+            }\n+        });\n+\n@@ -284,0 +322,7 @@\n+\n+    private static synchronized CRaCMXBean getCRaCMXBean() {\n+        if (cracMXBean == null) {\n+            cracMXBean = new CRaCImpl(ManagementFactoryHelper.getVMManagement());\n+        }\n+        return cracMXBean;\n+    }\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.management;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.PlatformManagedObject;\n+import java.lang.management.RuntimeMXBean;\n+\n+\/**\n+ * Management interface for the CRaC functionality of the Java virtual machine.\n+ *\/\n+public interface CRaCMXBean extends PlatformManagedObject {\n+\n+    \/**\n+     * Returns the time since the Java virtual machine restore was initiated.\n+     * If the machine was not restored, returns -1.\n+     *\n+     * @see RuntimeMXBean#getStartTime()\n+     * @return uptime of the Java virtual machine in milliseconds.\n+     *\/\n+    public long getUptimeSinceRestore();\n+\n+    \/**\n+     * Returns the time when the Java virtual machine restore was initiated.\n+     * The value is the number of milliseconds since the start of the epoch.\n+     * If the machine was not restored, returns -1.\n+     *\n+     * @see RuntimeMXBean#getUptime()\n+     * @return start time of the Java virtual machine in milliseconds.\n+     *\/\n+    public long getRestoreTime();\n+\n+    \/**\n+     * Returns the implementation of the MXBean.\n+     *\n+     * @return implementation of the MXBean.\n+     *\/\n+    public static CRaCMXBean getCRaCMXBean() {\n+        return ManagementFactory.getPlatformMXBean(CRaCMXBean.class);\n+    }\n+\n+}\n","filename":"src\/jdk.management\/share\/classes\/jdk\/crac\/management\/CRaCMXBean.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.management.internal;\n+\n+import com.sun.management.internal.PlatformMBeanProviderImpl;\n+import jdk.crac.management.CRaCMXBean;\n+import sun.management.Util;\n+import sun.management.VMManagement;\n+\n+import javax.management.ObjectName;\n+\n+public class CRaCImpl implements CRaCMXBean {\n+    private final VMManagement vm;\n+\n+    public CRaCImpl(VMManagement vm) {\n+        this.vm = vm;\n+    }\n+\n+    @Override\n+    public long getUptimeSinceRestore() {\n+        return vm.getUptimeSinceRestore();\n+    }\n+\n+    @Override\n+    public long getRestoreTime() {\n+        return vm.getRestoreTime();\n+    }\n+\n+    @Override\n+    public ObjectName getObjectName() {\n+        return Util.newObjectName(PlatformMBeanProviderImpl.CRAC_MXBEAN_NAME);\n+    }\n+}\n","filename":"src\/jdk.management\/share\/classes\/jdk\/crac\/management\/internal\/CRaCImpl.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This package contains management interfaces for CRaC.\n+ *\/\n+\n+package jdk.crac.management;\n","filename":"src\/jdk.management\/share\/classes\/jdk\/crac\/management\/package-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+    exports jdk.crac.management;\n@@ -40,1 +41,0 @@\n-\n","filename":"src\/jdk.management\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,0 +81,25 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(remoteAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+import java.util.stream.Collectors;\n+\n@@ -77,0 +79,34 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            synchronized (stateLock) {\n+                if (!isOpen() || !isBound()) {\n+                    return Collections.emptySet();\n+                }\n+                return associationMap.keySet().stream().flatMap(a -> {\n+                    try {\n+                        return SctpMultiChannelImpl.this.getRemoteAddresses(a).stream();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }).collect(Collectors.toSet());\n+            }\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+package sun.nio.ch.sctp;\n+\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.JDKSocketResourceBase;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.channels.spi.AbstractSelectableChannel;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+abstract class SctpResource extends JDKSocketResourceBase {\n+    private Set<InetSocketAddress> localCopy;\n+    private Set<SocketAddress> remoteCopy;\n+\n+    public SctpResource(AbstractSelectableChannel sctpChannel) {\n+        super(sctpChannel);\n+    }\n+\n+    @Override\n+    protected OpenResourcePolicies.Policy findPolicy(boolean isRestore) {\n+        if (!isRestore) {\n+            localCopy = Set.copyOf(getLocalAddresses());\n+            remoteCopy = Set.copyOf(getRemoteAddresses());\n+        }\n+        List<Predicate<Map<String, String>>> localMatchers = localCopy.stream()\n+                .map(addr -> getMatcher(addr, \"localAddress\", \"localPort\", null)).toList();\n+        List<Predicate<Map<String, String>>> remoteMatchers = remoteCopy.stream()\n+                .map(addr -> getMatcher(addr, \"remoteAddress\", \"remotePort\", null)).toList();\n+        return OpenResourcePolicies.find(false, OpenResourcePolicies.SOCKET,\n+                params -> localMatchers.stream().anyMatch(matcher -> matcher.test(params)) &&\n+                        remoteMatchers.stream().anyMatch(matcher -> matcher.test(params)));\n+    }\n+\n+    @Override\n+    protected void reset() {\n+        localCopy = null;\n+        remoteCopy = null;\n+    }\n+\n+    @Override\n+    protected abstract void closeBeforeCheckpoint() throws IOException;\n+\n+    protected abstract Set<SocketAddress> getRemoteAddresses();\n+\n+    protected abstract HashSet<InetSocketAddress> getLocalAddresses();\n+}\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpResource.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.net.StandardProtocolFamily;\n@@ -44,1 +45,1 @@\n-import sun.nio.ch.DirectBuffer;\n+import jdk.internal.crac.JDKSocketResource;\n@@ -51,1 +52,0 @@\n-import sun.nio.ch.Util;\n@@ -60,1 +60,0 @@\n-\n@@ -62,0 +61,23 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            return Collections.emptySet();\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertLessThan;\n+\n+import java.util.Arrays;\n+\n+\/*\n+ * @test ContainerPidAdjustmentTest\n+ * @summary The test checks that process PID is adjusted with the specified value, when checkpointing in a container. Default min PID value is 128.\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build ContainerPidAdjustmentTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  true   false  INF     true   128\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  true   true   1       false  1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  true   true   100     true   100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  false  INF     false  1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   1       false  1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   1       true   1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   200     true   200\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   1000    false  1000\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   2000    true   2000   1000\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   0       true   -1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   -10     true   -1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   blabla  true   -1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   5000000 true   -1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   5000000 true   -1     4194200\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   4194303 true   -1\n+\n+ *\/\n+public class ContainerPidAdjustmentTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean runDirectly;\n+\n+    @CracTestArg(1)\n+    boolean needSetMinPid;\n+\n+    @CracTestArg(2)\n+    String lastPid;\n+\n+    @CracTestArg(3)\n+    boolean usePrivilegedContainer;\n+\n+    @CracTestArg(4)\n+    long expectedLastPid;\n+\n+    @CracTestArg(value = 5, optional = true)\n+    String lastPidSetup;\n+\n+    final private String CURRENT_PID_MESSAGE = \"Current PID = \";\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+        CracBuilder builder = new CracBuilder()\n+            .inDockerImage(\"pid-adjustment\")\n+            .runContainerDirectly(runDirectly)\n+            .containerUsePrivileged(usePrivilegedContainer);\n+        if (needSetMinPid) {\n+            builder.vmOption(\"-XX:CRaCMinPid=\" + lastPid);\n+        }\n+        if (0 > expectedLastPid) {\n+            builder.captureOutput(true);\n+        }\n+        if (null != lastPidSetup) {\n+            \/\/ Set up the initial last pid,\n+            \/\/ create a non-privileged user,\n+            \/\/ and force spinning the last pid running checkpoint under the user.\n+            builder\n+                .containerSetup(Arrays.asList(\"bash\", \"-c\", \"useradd the_user && echo \" + lastPidSetup + \" >\/proc\/sys\/kernel\/ns_last_pid\"))\n+                .dockerCheckpointOptions(Arrays.asList(\"-u\", \"the_user\"));\n+        }\n+\n+        if (0 < expectedLastPid) {\n+            builder.startCheckpoint().waitForSuccess();\n+        } else {\n+            final int expectedExitValue = (int)java.lang.Math.abs(expectedLastPid);\n+            CracProcess process = builder.startCheckpoint();\n+            final int exitValue = process.waitFor();\n+            assertEquals(expectedExitValue, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+            OutputAnalyzer oa = process.outputAnalyzer();\n+            oa.shouldNotContain(CURRENT_PID_MESSAGE);\n+            if (null != lastPidSetup) {\n+                oa.shouldContain(\"spin_last_pid: Invalid argument (\" + lastPid + \")\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(CURRENT_PID_MESSAGE + ProcessHandle.current().pid());\n+        assertLessThan((long)0, expectedLastPid, \"Shouldn't happen\");\n+        assertLessThan(expectedLastPid, ProcessHandle.current().pid());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContainerPidAdjustmentTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.impl.BlockingOrderedContext;\n+import jdk.crac.impl.OrderedContext;\n+import jdk.internal.crac.JDKResource;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static jdk.crac.Core.getGlobalContext;\n+import static jdk.internal.crac.Core.*;\n+import static jdk.internal.crac.Core.Priority.*;\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test ContextOrderTest\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testOrder\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testRegisterBlocks\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testThrowing\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testRegisterToCompleted\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testRegisterFromOtherThread\n+ *\/\n+public class ContextOrderTest {\n+    \/\/ prevents GC releasing the resources\n+    private static final List<Resource> rememberMe = new ArrayList<>();\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"java.util.logging.config.file\", Utils.TEST_SRC + \"\/logging.properties\");\n+\n+        Method m = ContextOrderTest.class.getDeclaredMethod(args[0]);\n+        m.invoke(null);\n+    }\n+\n+    private static void testOrder() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, \"regular1\"));\n+        NORMAL.getContext().register(new MockResource(recorder, \"jdk-normal\"));\n+        SECURE_RANDOM.getContext().register(new MockResource(recorder, \"jdk-later\"));\n+        getGlobalContext().register(new CreatingResource<>(recorder, \"regular2\", NORMAL.getContext()));\n+        \/\/ this child should run as it has higher priority\n+        NORMAL.getContext().register(new CreatingResource<>(recorder, \"jdk-create\", SEEDER_HOLDER.getContext()));\n+\n+        Core.checkpointRestore();\n+\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+\n+        assertEquals(\"regular2-child1-before\", recorder.poll());\n+        assertEquals(\"jdk-create-before\", recorder.poll());\n+        assertEquals(\"jdk-normal-before\", recorder.poll());\n+\n+        assertEquals(\"jdk-later-before\", recorder.poll());\n+        assertEquals(\"jdk-create-child1-before\", recorder.poll());\n+        \/\/ restore\n+        assertEquals(\"jdk-create-child1-after\", recorder.poll());\n+        assertEquals(\"jdk-later-after\", recorder.poll());\n+\n+        assertEquals(\"jdk-normal-after\", recorder.poll());\n+        assertEquals(\"jdk-create-after\", recorder.poll());\n+        assertEquals(\"regular2-child1-after\", recorder.poll());\n+\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+\n+        \/\/ second checkpoint - whatever was registered in first afterRestore is now notified\n+        Core.checkpointRestore();\n+        assertTrue(recorder.stream().anyMatch(\"jdk-create-child2-before\"::equals));\n+        assertTrue(recorder.stream().anyMatch(\"regular2-child2-before\"::equals));\n+    }\n+\n+    private static void testRegisterBlocks() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        BlockingOrderedContext<Resource> blockingCtx = new BlockingOrderedContext();\n+        getGlobalContext().register(blockingCtx);\n+        \/\/ blocks register into the same OrderedContext\n+        blockingCtx.register(new CreatingResource<>(recorder, \"regular\", blockingCtx));\n+        testWaiting();\n+\n+        BlockingOrderedContext<Resource> blockingCtx1 = new BlockingOrderedContext();\n+        getGlobalContext().register(blockingCtx1);\n+        BlockingOrderedContext<Resource> blockingCtx2 = new BlockingOrderedContext();\n+        getGlobalContext().register(blockingCtx2);\n+        \/\/ blocks registering to the context done notifications\n+        blockingCtx1.register(new CreatingResource<>(recorder, \"jdk-lower\", blockingCtx2));\n+        testWaiting();\n+\n+        \/\/ blocks registering with the same priority\n+        NORMAL.getContext().register(new CreatingResource<>(recorder, \"jdk-same\", NORMAL.getContext()));\n+        testWaiting();\n+    }\n+\n+    private static void testWaiting() throws InterruptedException {\n+        AtomicReference<Throwable> exceptionHolder = new AtomicReference<>();\n+        assertWaits(() -> {\n+            try {\n+                Core.checkpointRestore();\n+            } catch (Exception e) {\n+                exceptionHolder.set(e);\n+            }\n+        }, null, \"waitWhileCheckpointIsInProgress\");\n+        assertNotNull(exceptionHolder.get());\n+        exceptionHolder.get().printStackTrace();\n+    }\n+\n+    private static void assertWaits(Runnable runnable, String cls, String method) throws InterruptedException {\n+        Thread thread = new Thread(runnable);\n+        thread.start();\n+        long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(10);\n+        for (;;) {\n+            if (thread.getState() == Thread.State.WAITING) {\n+                for (var ste : thread.getStackTrace()) {\n+                    if ((cls == null || cls.equals(ste.getClassName()) || ste.getClassName().endsWith(\".\" + cls)) &&\n+                            (method == null || method.equals(ste.getMethodName()))) {\n+                        \/\/ It should be sufficient to interrupt the code once; if any Resource\n+                        \/\/ clears the flag without rethrowing it is a bug.\n+                        thread.interrupt();\n+                        thread.join(TimeUnit.NANOSECONDS.toMillis(deadline - System.nanoTime()));\n+                        if (thread.getState() == Thread.State.WAITING) {\n+                            for (var ste2 : thread.getStackTrace()) {\n+                                System.out.println(ste2);\n+                            }\n+                        }\n+                        assertFalse(thread.isAlive());\n+                        return;\n+                    }\n+                }\n+            } else if (thread.getState() == Thread.State.TERMINATED) {\n+                fail(\"Thread completed without waiting\");\n+            }\n+            if (System.nanoTime() < deadline) {\n+                \/\/noinspection BusyWait\n+                Thread.sleep(50);\n+            } else {\n+                fail(\"Timed out waiting for thread to get waiting in \" + cls + \".\" + method);\n+            }\n+        }\n+    }\n+\n+    private static void testThrowing() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, \"regular1\"));\n+        getGlobalContext().register(new ThrowingResource(recorder, \"throwing1\"));\n+        getGlobalContext().register(new MockResource(recorder, \"regular2\"));\n+        NORMAL.getContext().register(new MockResource(recorder, \"jdk1\"));\n+        EPOLLSELECTOR.getContext().register(new ThrowingResource(recorder, \"throwing2\"));\n+        SECURE_RANDOM.getContext().register(new MockResource(recorder, \"jdk2\"));\n+\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Expected to throw CheckpointException\");\n+        } catch (CheckpointException e) {\n+            assertEquals(4, e.getSuppressed().length);\n+        }\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"throwing1-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+        assertEquals(\"jdk1-before\", recorder.poll());\n+        assertEquals(\"throwing2-before\", recorder.poll());\n+        assertEquals(\"jdk2-before\", recorder.poll());\n+\n+        assertEquals(\"jdk2-after\", recorder.poll());\n+        assertEquals(\"throwing2-after\", recorder.poll());\n+        assertEquals(\"jdk1-after\", recorder.poll());\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"throwing1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+    }\n+\n+    static class NamedOrderedContext<R extends Resource> extends BlockingOrderedContext {\n+        private final String name;\n+        NamedOrderedContext(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    \/\/ Similar to the test above but registers in context that is already done\n+    \/\/ rather than iterating through now.\n+    private static void testRegisterToCompleted() throws Exception {\n+        var recorder = new LinkedList<String>();\n+\n+        OrderedContext<Resource> c1 = new NamedOrderedContext<>(\"C1\");\n+        OrderedContext<Resource> c2 = new NamedOrderedContext<>(\"C2\");\n+        getGlobalContext().register(c1);\n+        getGlobalContext().register(c2);\n+        c2.register(new MockResource(recorder, \"first\"));\n+        \/\/ Logically there's nothing that prevents to register into C2 during C1.<resource>.afterRestore\n+        \/\/ but the implementation of C1 does not know that we're already after C\/R and still blocks\n+        \/\/ any registrations.\n+        c1.register(new CreatingResource<>(recorder, \"second\", c2));\n+\n+        \/\/ This is supposed to end up with a deadlock. Even though it would block first\n+        \/\/ for -child1 and then for -child2 the first time we interrupt the thread it will\n+        \/\/ unblock and won't block any further.\n+        testWaiting();\n+\n+        \/\/ Since we have interrupted the registration no other resource was registered\n+        \/\/ so there's no point in testing anything here.\n+    }\n+\n+    \/\/ registering from lower priority resource to higher priority shouldn't block\n+    \/\/ even in another thread\n+    private static void testRegisterFromOtherThread() throws RestoreException, CheckpointException {\n+        var recorder = new LinkedList<String>();\n+        NORMAL.getContext().register(new MockResource(recorder, \"normal\") {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                super.beforeCheckpoint(context);\n+                Thread thread = new Thread(() -> {\n+                    CLEANERS.getContext().register(new MockResource(recorder, \"child\"));\n+                }, \"registrar\");\n+                thread.start();\n+                thread.join();\n+            }\n+        });\n+\n+        Core.checkpointRestore();\n+        assertEquals(\"normal-before\", recorder.poll());\n+        assertEquals(\"child-before\", recorder.poll());\n+        assertEquals(\"child-after\", recorder.poll());\n+        assertEquals(\"normal-after\", recorder.poll());\n+    }\n+\n+    private static class MockResource implements JDKResource {\n+        protected final List<String> recorder;\n+        protected final String id;\n+\n+        private MockResource(List<String> recorder, String id) {\n+            rememberMe.add(this);\n+            this.recorder = recorder;\n+            this.id = id;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            recorder.add(id + \"-before\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            recorder.add(id + \"-after\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \":\" + id;\n+        }\n+    }\n+\n+    \/\/ While normally resources should not directly register other resources it is possible\n+    \/\/ that running it will trigger (static) initialization of a class and that registers\n+    \/\/ a new resource. It is not legal to register a user resource, but for JDK resources\n+    \/\/ we can make an exception since it does not conflict with the general order (JDK resources\n+    \/\/ are notified after user resources).\n+    private static class CreatingResource<R extends Resource> extends MockResource {\n+        private final Context<R> childContext;\n+        private boolean first = true;\n+\n+        private CreatingResource(List<String> recorder, String id, Context<R> childContext) {\n+            super(recorder, id);\n+            this.childContext = childContext;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            super.beforeCheckpoint(context);\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, id + \"-child1\"));\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            super.afterRestore(context);\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, id + \"-child2\"));\n+            }\n+            first = false;\n+        }\n+    }\n+\n+    private static class ThrowingResource extends MockResource {\n+        private ThrowingResource(List<String> recorder, String id) {\n+            super(recorder, id);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            super.beforeCheckpoint(context);\n+            throw new RuntimeException(id + \"-before\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            super.afterRestore(context);\n+            throw new RuntimeException(id + \"-after\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.crac.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.channels.Pipe;\n+import java.nio.file.*;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * @test CracOptionTest\n+ * @library \/test\/lib\n+ * @build CracOptionTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+\n+public class CracOptionTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.javaOption(\"k\",\"v\");\n+        builder.doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/CracOptionTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+\n+\/**\n+ * @test\n+ * @summary All afterRestore's should complete, even if there are only daemon threads (in case one of the afterRestore's finally creates non-daemon thread that will be responsible to keep VM alive)\n+ * @library \/test\/lib\n+ * @build DaemonAfterRestore\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class DaemonAfterRestore implements CracTest {\n+    static final String MAIN_THREAD_FINISH = \"main thread finish\";\n+    static final String AFTER_RESTORE_MESSAGE = \"after restore finish\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().captureOutput(true);\n+\n+        CompletableFuture<?> firstOutputFuture = new CompletableFuture<Void>();\n+        CracProcess checkpointProcess = builder.startCheckpoint().watch(\n+            outline -> {\n+                System.out.println(outline);\n+                if (outline.equals(MAIN_THREAD_FINISH)) {\n+                    firstOutputFuture.complete(null);\n+                }\n+            },\n+            errline -> {\n+                System.err.println(\"ERROR: \" + errline);\n+                firstOutputFuture.cancel(false);\n+            });\n+        firstOutputFuture.get(10, TimeUnit.SECONDS);\n+        builder.checkpointViaJcmd();\n+        checkpointProcess.waitForCheckpointed();\n+\n+        builder.startRestore().waitForSuccess()\n+            .outputAnalyzer().shouldContain(AFTER_RESTORE_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws RestoreException, CheckpointException {\n+        CountDownLatch start = new CountDownLatch(1);\n+        CountDownLatch finish = new CountDownLatch(1);\n+        Thread workerThread = new Thread(() -> {\n+            System.out.println(\"worker thread start\");\n+            start.countDown();\n+            try {\n+                finish.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            System.out.println(\"worker thread finish\");\n+        });\n+        assertFalse(workerThread.isDaemon());\n+        workerThread.start();\n+\n+        try {\n+            start.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        Resource resource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                assert Thread.currentThread().isDaemon() : \"beforeCheckpoint is expected to be called from daemon thread\";\n+                finish.countDown();\n+            }\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                Thread.sleep(3000);\n+                System.out.println(AFTER_RESTORE_MESSAGE);\n+            }\n+        };\n+\n+        Core.getGlobalContext().register(resource);\n+\n+        System.out.println(MAIN_THREAD_FINISH);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/DaemonAfterRestore.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test DryRunTest\n+ * @library \/test\/lib\n+ * @build DryRunTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class DryRunTest implements CracTest {\n+    static class CRResource implements Resource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            throw new RuntimeException(\"should not pass\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE).printResources(true)\n+                .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Resource resource = new CRResource();\n+        Core.getGlobalContext().register(resource);\n+\n+        File tempFile = File.createTempFile(\"jtreg-DryRunTest\", null);\n+        FileOutputStream stream = new FileOutputStream(tempFile);\n+        stream.write('j');\n+\n+        int exceptions = 0;\n+\n+        try {\n+            Core.checkpointRestore();\n+        } catch (CheckpointException ce) {\n+\n+            ce.printStackTrace();\n+\n+            for (Throwable e : ce.getSuppressed()) {\n+                String name = e.getClass().getName();\n+                switch (name) {\n+                    case \"java.lang.RuntimeException\":                exceptions |= 0x1; break;\n+                    case \"jdk.crac.impl.CheckpointOpenFileException\": exceptions |= 0x2; break;\n+                }\n+            }\n+        }\n+\n+        stream.close();\n+        tempFile.delete();\n+\n+        if (exceptions != 0x3) {\n+            throw new RuntimeException(\"fail \" + exceptions);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/DryRunTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test FailedResourceTest\n+ * @library \/test\/lib\n+ * @build FailedResourceTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+\n+public class FailedResourceTest implements CracTest {\n+    public static final String EXCEPTION_MESSAGE = \"Resource failed\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        AtomicBoolean ranAfter = new AtomicBoolean();\n+        Resource resource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                throw new Exception(EXCEPTION_MESSAGE);\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                ranAfter.set(true);\n+            }\n+        };\n+        Core.getGlobalContext().register(resource);\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Was supposed to throw\");\n+        } catch (CheckpointException e) {\n+            assertEquals(1, e.getSuppressed().length, Arrays.toString(e.getSuppressed()));\n+            assertEquals(EXCEPTION_MESSAGE, e.getSuppressed()[0].getMessage());\n+        } catch (RestoreException e) {\n+            fail(\"Shouldn't error in restore\", e);\n+        }\n+        assertTrue(ranAfter.get());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/FailedResourceTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022-2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.File;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/**\n+ * @test JarFileFactoryCacheTest\n+ * @library \/test\/lib\n+ * @build JarFileFactoryCacheTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class JarFileFactoryCacheTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE).printResources(true)\n+                .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Path temp = Files.createTempDirectory(JarFileFactoryCacheTest.class.getName());\n+        Path testFilePath = temp.resolve(\"test.txt\");\n+        try {\n+            Files.writeString(testFilePath, \"test\\n\");\n+            jdk.test.lib.util.JarUtils.createJarFile(\n+                    Path.of(\"test.jar\"), temp, \"test.txt\");\n+        } finally {\n+            File testTxt = testFilePath.toFile();\n+            if (testTxt.exists()) {\n+                assert testTxt.delete();\n+            }\n+            assert temp.toFile().delete();\n+        }\n+\n+        URL url = new URL(\"jar:file:test.jar!\/test.txt\");\n+        InputStream inputStream = url.openStream();\n+        byte[] content = inputStream.readAllBytes();\n+        if (content.length != 5) {\n+            throw new AssertionError(\"wrong content: \" + new String(content));\n+        }\n+        inputStream.close();\n+        \/\/ Nulling the variables is actually necessary!\n+        inputStream = null;\n+        url = null;\n+\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/JarFileFactoryCacheTest\/JarFileFactoryCacheTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build LeaveRunning\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class LeaveRunning implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().env(\"CRAC_CRIU_LEAVE_RUNNING\", \"\")\n+                .captureOutput(true);\n+        builder.startCheckpoint().waitForSuccess().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+        builder.doRestore().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/LeaveRunning.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.management.*;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+\n+import static jdk.test.lib.Asserts.assertLT;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build MXBean\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class MXBean implements CracTest {\n+    static final long TIME_TOLERANCE = 10_000; \/\/ ms\n+\n+    @Override\n+    public void exec() throws CheckpointException, RestoreException {\n+        CRaCMXBean cracMXBean = CRaCMXBean.getCRaCMXBean();\n+\n+        Core.checkpointRestore();\n+\n+        System.out.println(\"UptimeSinceRestore \" + cracMXBean.getUptimeSinceRestore());\n+\n+        long restoreTime = cracMXBean.getRestoreTime();\n+        System.out.println(\"RestoreTime \" + restoreTime + \" \" +\n+            DateTimeFormatter.ofPattern(\"E dd LLL yyyy HH:mm:ss.n\").format(\n+                Instant.ofEpochMilli(restoreTime)\n+                    .atZone(ZoneId.systemDefault())));\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        long start = System.currentTimeMillis();\n+\n+        OutputAnalyzer output = new CracBuilder().engine(CracEngine.SIMULATE)\n+                .captureOutput(true)\n+                .startCheckpoint().waitForSuccess().outputAnalyzer();\n+\n+        long restoreUptime = Long.parseLong(output.firstMatch(\"UptimeSinceRestore ([0-9-]+)\", 1));\n+        if (restoreUptime < 0 || TIME_TOLERANCE < restoreUptime) {\n+            throw new Error(\"bad UptimeSinceRestore: \" + restoreUptime);\n+        }\n+\n+        long restoreTime = Long.parseLong(output.firstMatch(\"RestoreTime ([0-9-]+)\", 1));\n+        restoreTime -= start;\n+\n+        assertLT(Math.abs(restoreTime), TIME_TOLERANCE, \"bad RestoreTime: \" + restoreTime);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/MXBean.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.lang.ref.Cleaner;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build RefQueueTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class RefQueueTest implements CracTest {\n+    private static final Cleaner cleaner = Cleaner.create();\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE)\n+                .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        File badFile = File.createTempFile(\"jtreg-RefQueueTest\", null);\n+        OutputStream badStream = new FileOutputStream(badFile);\n+        badStream.write('j');\n+        badFile.delete();\n+\n+        \/\/ the cleaner would be able to run right away\n+        cleaner.register(new Object(), () -> {\n+            try {\n+                badStream.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+\n+        \/\/ should close the file and only then go to the native checkpoint\n+        Core.checkpointRestore();\n+\n+        \/\/ ensure that the cleaner starts working eventually\n+        CountDownLatch latch = new CountDownLatch(1);\n+        cleaner.register(new Object(), () -> {\n+            latch.countDown();\n+        });\n+        System.gc();\n+        assertTrue(latch.await(10, TimeUnit.SECONDS));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+\n+\/*\n+ * @test RestoreEnvironmentTest\n+ * @summary the test checks that actual environment variables are propagated into a restored process.\n+ * @library \/test\/lib\n+ * @build RestoreEnvironmentTest\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class RestoreEnvironmentTest implements CracTest {\n+    static final String TEST_VAR_NAME = \"RESTORE_ENVIRONMENT_TEST_VAR\";\n+    static final String BEFORE_CHECKPOINT = \"BeforeCheckpoint\";\n+    static final String AFTER_RESTORE = \"AfterRestore\";\n+    static final String NEW_VALUE = \"NewValue\";\n+    public static final String PREFIX = \"(after restore) \";\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().captureOutput(true)\n+                .env(TEST_VAR_NAME + 0, BEFORE_CHECKPOINT)\n+                .env(TEST_VAR_NAME + 1, BEFORE_CHECKPOINT);\n+        builder.doCheckpoint();\n+        builder.env(TEST_VAR_NAME + 1, AFTER_RESTORE);\n+        builder.env(TEST_VAR_NAME + 2, NEW_VALUE);\n+        builder.doRestore().outputAnalyzer()\n+                .shouldContain(PREFIX + TEST_VAR_NAME + \"0=\" + BEFORE_CHECKPOINT)\n+                .shouldContain(PREFIX + TEST_VAR_NAME + \"1=\" + AFTER_RESTORE)\n+                .shouldContain(PREFIX + TEST_VAR_NAME + \"2=\" + NEW_VALUE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        for (int i = 0; i < 3; ++i) {\n+            var testVar = java.lang.System.getenv(TEST_VAR_NAME + i);\n+            System.out.println(\"(before checkpoint) \" + TEST_VAR_NAME + i + \"=\" + testVar);\n+        }\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        for (int i = 0; i < 3; ++i) {\n+            var testVar = java.lang.System.getenv(TEST_VAR_NAME + i);\n+            System.out.println(PREFIX + TEST_VAR_NAME + i + \"=\" + testVar + \"\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RestoreEnvironmentTest.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.IOException;\n+import java.security.SecureRandom;\n+\n+\/*\n+ * @test\n+ * @summary Verify that secure random is not interlocked during checkpoint\/restore.\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build InterlockTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest SHA1PRNG 100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest NativePRNGBlocking 100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest NativePRNGNonBlocking 100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest NativePRNG 100\n+ *\/\n+public class InterlockTest implements Resource, CracTest {\n+    private static final long MIN_TIMEOUT = 100;\n+    private static final long MAX_TIMEOUT = 1000;\n+\n+    private boolean stop = false;\n+    private SecureRandom sr;\n+\n+    @CracTestArg(0)\n+    String algName;\n+\n+    @CracTestArg(1)\n+    int numThreads;\n+\n+    private class TestThread1 extends Thread {\n+        @Override\n+        public void run() {\n+            while (!stop) {\n+                set();\n+            }\n+        }\n+    };\n+\n+    private class TestThread2 extends Thread implements Resource {\n+        private final SecureRandom sr;\n+\n+        synchronized void set() {\n+            sr.nextInt();\n+        }\n+        synchronized void clean() {\n+            sr.nextInt();\n+        }\n+\n+        TestThread2() throws Exception {\n+            sr = SecureRandom.getInstance(algName);\n+            Core.getGlobalContext().register(this);\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!stop) {\n+                set();\n+            }\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            clean();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            set();\n+        }\n+    };\n+\n+    synchronized void clean() {\n+        sr.nextInt();\n+    }\n+\n+    synchronized void set() {\n+        sr.nextInt();\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        try {\n+            clean();\n+        } catch(Exception e) {\n+            e.printStackTrace(System.out);\n+        };\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        set();\n+        stop = true;\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        sr = SecureRandom.getInstance(algName);\n+        Core.getGlobalContext().register(this);\n+\n+        Thread[] threads = new Thread[numThreads];\n+        for(int i = 0; i < numThreads; i++) {\n+            threads[i] = (i % 2 == 0) ?\n+                    new TestThread1():\n+                    new TestThread2();\n+            threads[i].start();\n+        };\n+        Thread.sleep(MIN_TIMEOUT);\n+        set();\n+        Thread.sleep(MIN_TIMEOUT);\n+\n+        Object checkpointLock = new Object();\n+        Thread checkpointThread = new Thread(\"checkpointThread\") {\n+            public void run() {\n+                synchronized (checkpointLock) {\n+                    try {\n+                        jdk.crac.Core.checkpointRestore();\n+                    } catch (CheckpointException e) {\n+                        throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+                    } catch (RestoreException e) {\n+                        throw new RuntimeException(\"Restore ERROR \" + e);\n+                    }\n+                    checkpointLock.notify();\n+                }\n+            }\n+        };\n+        synchronized (checkpointLock) {\n+            try {\n+                checkpointThread.start();\n+                checkpointLock.wait(MAX_TIMEOUT * 2);\n+            } catch(Exception e){\n+                throw new RuntimeException(\"Checkpoint\/Restore ERROR \" + e);\n+            }\n+        }\n+        Thread.sleep(MAX_TIMEOUT);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/InterlockTest.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.security.SecureRandom;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertNotEquals;\n+\n+\/*\n+ * @test\n+ * @summary Verify that SHA1PRNG secure random is reseeded after restore if initialized with default seed.\n+ * @library \/test\/lib\n+ * @build ReseedTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest true\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest false\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class ReseedTest implements CracTest {\n+    @CracTestArg\n+    boolean reseed;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.doCheckpoint();\n+        builder.captureOutput(true);\n+        String e1 = builder.doRestore().outputAnalyzer().getStdout();\n+        String e2 = builder.doRestore().outputAnalyzer().getStdout();\n+        if (reseed) {\n+            assertEquals(e1, e2);\n+        } else {\n+            assertNotEquals(e1, e2);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n+        if (reseed) {\n+            sr.setSeed(sr.generateSeed(10));\n+        }\n+        sr.nextInt();\n+\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            e.printStackTrace(System.out);\n+            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+        } catch (RestoreException e) {\n+            throw new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+\n+        System.out.println(sr.nextInt());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/ReseedTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+\n+import java.io.IOException;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.SocketChannel;\n+\n+class ChannelResource implements Resource {\n+\n+    public enum SelectionType {\n+        SELECT,\n+        SELECT_TIMEOUT,\n+        SELECT_NOW\n+    };\n+\n+    private SocketChannel channel;\n+    private SelectionKey key;\n+    private Selector selector;\n+\n+    private final SelectionType selType;\n+\n+    public ChannelResource(SelectionType selType) {\n+        this.selType = selType;\n+        Core.getGlobalContext().register(this);\n+    }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_READ);\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+        channel.socket().close();\n+\n+        \/\/ causes the channel deregistration\n+        if (selType == SelectionType.SELECT_NOW) {\n+            selector.selectNow();\n+        } else if (selType == SelectionType.SELECT_TIMEOUT) {\n+            selector.select(500);\n+        } else {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        Thread.sleep(1000);\n+                        selector.wakeup();\n+                    } catch (InterruptedException ie) {\n+                        throw new RuntimeException(ie);\n+                    }\n+                }\n+            }).start();\n+\n+            selector.select();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/ChannelResource.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+\/*\n+ * @test Selector\/Test970\n+ * @summary a regression test for ZE-970 (\"a channel deregistration\n+ *          is locked depending on mutual order of selector and channel creation\")\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build ChannelResource\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW false\n+ * @run driver jdk.test.lib.crac.CracTest SELECT true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT false\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT false\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg(0)\n+    ChannelResource.SelectionType selType;\n+\n+    @CracTestArg(1)\n+    boolean openSelectorAtFirst;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        if (openSelectorAtFirst) {\n+\n+            Selector selector = Selector.open();\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            ch.register(selector);\n+\n+            Core.checkpointRestore();\n+\n+            selector.close();\n+\n+        } else { \/\/ try in other order (see ZE-970)\n+\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            Selector selector = Selector.open();\n+            ch.register(selector);\n+\n+            Core.checkpointRestore();\n+\n+            selector.close();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+\/*\n+ * @test Selector\/interruptedSelection\n+ * @summary check that the thread blocked by Selector.select() could be properly woken up by an interruption\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  false false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false false false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  true\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg(0)\n+    boolean setTimeout;\n+\n+    @CracTestArg(1)\n+    boolean interruptBeforeCheckpoint;\n+\n+    @CracTestArg(2)\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    \/\/ select(): interrupt before the checkpoint\n+    @Override\n+    public void exec() throws Exception {\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {  try {\n+                if (setTimeout) { selector.select(3600_000); }\n+                else { selector.select(); }\n+            } catch (IOException e) { throw new RuntimeException(e); }   }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+\n+        Thread.sleep(1000);\n+\n+        if (interruptBeforeCheckpoint) {\n+            t.interrupt();\n+            t.join();\n+            System.out.println(\">> interrupt before checkpoint\");\n+        }\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        if (!interruptBeforeCheckpoint) {\n+            t.interrupt();\n+            t.join();\n+            System.out.println(\">>> interrupt after restore\");\n+        }\n+\n+        \/\/ just in case, check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/Selector\/interruptedSelection\/Test.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+\n+import java.io.IOException;\n+import java.nio.channels.CancelledKeyException;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.SocketChannel;\n+\n+class ChannelResource implements Resource {\n+\n+    private SocketChannel channel;\n+    private SelectionKey key;\n+    private Selector selector;\n+\n+    private Object att = new Integer(123);\n+\n+    public ChannelResource() {\n+        Core.getGlobalContext().register(this);\n+    }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_CONNECT);\n+        key.attach(att);\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+        channel.socket().close(); \/\/ close the channel => cancel the key\n+        check(!channel.isOpen(), \"the channel should not be open\");\n+        selector.select(100); \/\/ causes the channel deregistration\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        \/\/ the key is cancelled\n+        check(!key.isValid(), \"expected: key.isValid() == false\");\n+\n+        boolean caught = false;\n+        try {\n+            key.readyOps();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.interestOps();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.interestOps(SelectionKey.OP_CONNECT);\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.readyOps();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isReadable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isWritable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isConnectable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isAcceptable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        check(att.equals(key.attachment()), \"invalid key.attachment()\");\n+\n+        key.cancel(); \/\/ try just in case\n+\n+        \/\/ register again\n+        try {\n+            channel = SocketChannel.open();\n+            channel.configureBlocking(false);\n+            key = channel.register(selector, SelectionKey.OP_READ);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ to check after restore\n+    public void checkKey() {\n+\n+        check(key.isValid(), \"key must be valid\");\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        key.isReadable(); \/\/ just call, cannot set \"ready\" state manually\n+        check(!key.isWritable(), \"invalid key.isWritable()\");\n+        check(!key.isConnectable(), \"invalid key.isConnectable()\");\n+        check(!key.isAcceptable(), \"invalid key.isAcceptable()\");\n+\n+        check(key.interestOps() == SelectionKey.OP_READ, \"invalid key.interestOps()\");\n+\n+        System.out.println(\">> ready >> \" + key.readyOps());\n+\n+        check(key.attachment() == null, \"key.attachment() expected to be null\");\n+\n+        key.cancel(); \/\/ try just in case\n+    }\n+\n+    private void check(boolean b, String msg) {\n+        if (!b) {\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/ChannelResource.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+\/*\n+ * @test Selector\/keyAfterRestore\n+ * @summary a trivial test for SelectionKey's state after restore\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build ChannelResource\n+ * @build Test\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg\n+    boolean openSelectorAtFirst;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ChannelResource ch;\n+        Selector selector = null;\n+\n+        \/\/ check various order (see ZE-970)\n+        if (openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch = new ChannelResource();\n+        ch.open();\n+\n+        if (!openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch.register(selector);\n+\n+        try {\n+            Core.checkpointRestore();\n+        } catch (CheckpointException | RestoreException e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+\n+        Thread.sleep(200);\n+\n+        ch.checkKey();\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+import java.util.Random;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test Selector\/multipleSelect\n+ * @summary check work of multiple select() + wakeup() + C\/R\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED true\n+ *\/\n+public class Test implements CracTest {\n+\n+    private final static Random RND = new Random();\n+\n+    private final static long LONG_TIMEOUT = 3600_000;\n+    private final static long SHORT_TIMEOUT = 3_000;\n+\n+    public enum TestType {\n+        NO_TIMEOUTS,    \/\/ test only select(), wakeup\n+        ONLY_TIMEOUTS,  \/\/ test only select(timeout), do not call wakeup()\n+        MIXED};\n+\n+    @CracTestArg(0)\n+    TestType type;\n+\n+    @CracTestArg(1)\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        long dt = (type == TestType.ONLY_TIMEOUTS) ? SHORT_TIMEOUT : LONG_TIMEOUT;\n+\n+        int nThreads = (type == TestType.ONLY_TIMEOUTS) ? 5 : 20;\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        Thread selectThreads[] = new Thread[nThreads];\n+\n+        boolean setTimeout[] = new boolean[nThreads];\n+        for (int i = 0; i < nThreads; ++i) {\n+            boolean t = false; \/\/ NO_TIMEOUTS\n+            if (type == TestType.ONLY_TIMEOUTS) { t = true; }\n+            else if (type == TestType.MIXED) { t = RND.nextBoolean(); }\n+            setTimeout[i] = t;\n+        }\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < nThreads; ++i) {\n+\n+                    boolean timeout = setTimeout[i];\n+\n+                    selectThreads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                int n = nSelected.incrementAndGet();\n+                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                                if (timeout) { selector.select(dt); }\n+                                else { selector.select(); }\n+                                nSelected.decrementAndGet();\n+                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    selectThreads[i].start();\n+                    try { Thread.sleep(200); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread t = new Thread(rStart);\n+        t.start();\n+        Thread.sleep(500);\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        t.join();\n+        Thread.sleep(1000);\n+\n+        if (type == TestType.ONLY_TIMEOUTS) { \/\/ do not wake threads up, the timeouts must work\n+\n+            while (nSelected.get() > 0) { Thread.sleep(1000); }\n+\n+        } else {\n+\n+            int nWakeups = 0;\n+            while (true) {\n+\n+                int nBefore = nSelected.get();\n+                if (nBefore == 0) { break; }\n+\n+                System.out.println(\">> wakeup() #\" + (nWakeups + 1));\n+                ++nWakeups;\n+\n+                selector.wakeup();\n+                while (nSelected.get() == nBefore) { \/\/ wait until any select() would be woken up\n+                    Thread.sleep(500);\n+                }\n+            }\n+\n+            if (nWakeups > nThreads) {\n+                selector.close();\n+                throw new RuntimeException(\"invalid number of wakeups\");\n+            }\n+        }\n+\n+        \/\/ just in case...\n+        for (Thread st: selectThreads) { st.join(); }\n+\n+        \/\/ === check that the selector works as expected ===\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelect\/Test.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test Selector\/multipleSelectNow\n+ * @summary check work of multiple selectNow() + C\/R peaceful coexistence\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ *\/\n+public class Test implements CracTest {\n+\n+    @CracTestArg\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        int nThreads = skipCR ? 30 : 150; \/\/ some selectNow() calls should occur at the same time with C\/R\n+        Thread threads[] = new Thread[nThreads];\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < threads.length; ++i) {\n+\n+                    threads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                System.out.println(\"selectNow\");\n+                                nSelected.incrementAndGet();\n+                                selector.selectNow();\n+                                System.out.println(\"done\");\n+                                nSelected.decrementAndGet();\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    threads[i].start();\n+                    try { Thread.sleep(5); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread tStart = new Thread(rStart);\n+        tStart.start();\n+        Thread.sleep(500);\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        tStart.join();\n+\n+        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n+        for (Thread t: threads) { t.join(); } \/\/ just in case...\n+\n+        \/\/ === check that the selector works as expected ===\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectNow\/Test.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.nio.channels.ClosedSelectorException;\n+import java.io.IOException;\n+import java.util.Random;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test Selector\/multipleSelectSingleClose\n+ * @summary check a coexistence of multiple select() + C\/R in case when the selector is finally closed\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ * @run driver jdk.test.lib.crac.CracTest true  true\n+ *\/\n+public class Test implements CracTest {\n+    private final static Random RND = new Random();\n+\n+    @CracTestArg(0)\n+    boolean skipCR;\n+\n+    @CracTestArg(1)\n+    boolean closeBeforeCheckpoint;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        int nThreads = 20;\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        Thread selectThreads[] = new Thread[nThreads];\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < nThreads; ++i) {\n+\n+                    selectThreads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                boolean timeout = RND.nextBoolean();\n+                                int n = nSelected.incrementAndGet();\n+                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                                if (timeout) { selector.select(10 + RND.nextInt(7_000)); }\n+                                else { selector.select(); }\n+                                nSelected.decrementAndGet();\n+                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                            } catch (ClosedSelectorException e) {\n+                                System.out.println(\">> ClosedSelectorException\"); \/\/ expected when the selector is closed\n+                                nSelected.decrementAndGet();\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    selectThreads[i].start();\n+                    try { Thread.sleep(50); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread tStart = new Thread(rStart);\n+        tStart.start();\n+        Thread.sleep(500);\n+\n+        if (closeBeforeCheckpoint) {\n+            tStart.join();\n+            Thread.sleep(1000);\n+            selector.close();\n+        }\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        if (!closeBeforeCheckpoint) {\n+            tStart.join();\n+            Thread.sleep(1000);\n+            selector.close();\n+        }\n+\n+        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n+\n+        if (nSelected.get() < 0) { throw new RuntimeException(\"negative nSelected??\"); }\n+\n+        \/\/ just in case...\n+        for (Thread t: selectThreads) { t.join(); }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectSingleClose\/Test.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.IOException;\n+import java.nio.channels.Selector;\n+\n+\/*\n+ * @test Selector\/selectAfterWakeup\n+ * @summary check that the Selector's wakeup() makes the subsequent select() call to return immediately\n+ *          (see also jdk\/test\/java\/nio\/channels\/Selector\/WakeupSpeed.java);\n+ *          covers ZE-983\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest true  false false\n+ * @run driver jdk.test.lib.crac.CracTest true  false true\n+ * @run driver jdk.test.lib.crac.CracTest true  true  false\n+ * @run driver jdk.test.lib.crac.CracTest true  true  true\n+ * @run driver jdk.test.lib.crac.CracTest false true  false\n+ * @run driver jdk.test.lib.crac.CracTest false true  true\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg(0)\n+    boolean wakeupBeforeCheckpoint;\n+\n+    @CracTestArg(1)\n+    boolean wakeupAfterRestore;\n+\n+    @CracTestArg(2)\n+    boolean setSelectTimeout;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        Selector selector = Selector.open();\n+\n+        \/\/ do this just in case\n+        selector.wakeup();\n+        selector.select();\n+\n+        if (wakeupBeforeCheckpoint) {\n+            selector.wakeup();\n+        }\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        if (wakeupAfterRestore) {\n+            selector.wakeup();\n+        }\n+        if (setSelectTimeout) { selector.select(3600_000); }\n+        else { selector.select(); }\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAfterWakeup\/Test.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.channels.Selector;\n+\n+\/*\n+ * @test Selector\/selectAndWakeupAfterRestore\n+ * @summary a trivial check that Selector.wakeup() after restore behaves as expected\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class Test implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    private static void selectAndWakeup(Selector selector) throws java.io.IOException {\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    Thread.sleep(7000);\n+                    System.out.println(\">> waking up\");\n+                    selector.wakeup();\n+                } catch (InterruptedException ie) { throw new RuntimeException(ie); }\n+            }\n+        }).start();\n+\n+        System.out.println(\">> selecting\");\n+        selector.select();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        Selector selector = Selector.open();\n+\n+        selectAndWakeup(selector); \/\/ just in case\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        selectAndWakeup(selector);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAndWakeupAfterRestore\/Test.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+\/*\n+ * @test Selector\/wakeupAfterRestore\n+ * @summary check that the thread blocked by Selector.select() on checkpoint could be properly woken up after restore\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ *\/\n+public class Test implements CracTest {\n+\n+    private final static long TIMEOUT = 3600_000; \/\/ looong timeout\n+\n+    static boolean awakened;\n+\n+    @CracTestArg\n+    boolean setTimeout;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                System.out.println(\">> select, setTimeout = \" + setTimeout);\n+                try {\n+                    awakened = false;\n+                    if (setTimeout) { selector.select(TIMEOUT); }\n+                    else { selector.select(); }\n+                    awakened = true;\n+                } catch (IOException e) { throw new RuntimeException(e); }\n+            }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+        Thread.sleep(1000);\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        System.out.print(\">> waking up: \");\n+        selector.wakeup();\n+        t.join();\n+        System.out.println(\"done\");\n+\n+        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n+\n+        \/\/ check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupAfterRestore\/Test.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+\/*\n+ * @test Selector\/wakeupByClose\n+ * @summary check that the Selector's close() wakes it up after restore\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest true  false\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ * @run driver jdk.test.lib.crac.CracTest true  true\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ *\/\n+public class Test implements CracTest {\n+\n+    static boolean awakened, closed;\n+\n+    @CracTestArg(0)\n+    boolean setTimeout;\n+\n+    @CracTestArg(1)\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Selector selector = Selector.open();\n+\n+        Thread tSelect = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        awakened = false;\n+                        if (setTimeout) { selector.select(3600_000); }\n+                        else { selector.select(); }\n+                        awakened = true;\n+                    } catch (IOException e) { throw new RuntimeException(e); }\n+                }\n+            });\n+        tSelect.start();\n+\n+        Thread.sleep(3000);\n+\n+        if (!skipCR) { jdk.crac.Core.checkpointRestore(); }\n+\n+        \/\/ close() must wakeup the selector\n+        Thread tClose = new Thread(new Runnable() {\n+\n+                @Override\n+                public void run() {\n+                    try {\n+                        closed = false;\n+                        selector.close();\n+                        closed = true;\n+                    } catch (IOException e) { throw new RuntimeException(e); }\n+                }\n+            });\n+        tClose.start();\n+        tClose.join();\n+        tSelect.join();\n+\n+        if (!awakened) {\n+            selector.wakeup();\n+            throw new RuntimeException(\"selector did not wake up\");\n+        }\n+\n+        if (!closed) {\n+            selector.close();\n+            throw new RuntimeException(\"selector did not close\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByClose\/Test.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+\/*\n+ * @test Selector\/wakeupByTimeoutAfterRestore\n+ * @summary check that the Selector selected before the checkpoint,\n+ *          will wake up by timeout after the restore\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class Test implements CracTest {\n+\n+    private final static long TIMEOUT = 40_000; \/\/ 40 seconds\n+\n+    static boolean awakened = false;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    selector.select(TIMEOUT);\n+                    awakened = true;\n+                } catch (IOException e) { throw new RuntimeException(e); }\n+            }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+        Thread.sleep(1000);\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        t.join();\n+        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n+\n+        \/\/ check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByTimeoutAfterRestore\/Test.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.management.HotSpotDiagnosticMXBean;\n+import com.sun.management.VMOption;\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.lang.management.ManagementFactory;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build VMOptionsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class VMOptionsTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        \/\/ this is here just to test passing CREngine params\n+        builder.engine(CracEngine.CRIU, \"--verbosity=4\", \"--log-file=\/dev\/null\");\n+        builder.vmOption(\"-XX:NativeMemoryTracking=off\");\n+        builder.doCheckpoint();\n+        builder.clearVmOptions();\n+        builder.vmOption(\"-XX:CRaCCheckpointTo=another\"); \/\/ manageable\n+        builder.vmOption(\"-XX:CRaCIgnoredFileDescriptors=42,43\"); \/\/ restore_settable\n+        builder.doRestore();\n+        \/\/ Setting non-manageable option\n+        builder.vmOption(\"-XX:NativeMemoryTracking=summary\");\n+        assertEquals(1, builder.startRestore().waitFor());\n+    }\n+\n+    @Override\n+    public void exec() throws RestoreException, CheckpointException {\n+        {\n+            HotSpotDiagnosticMXBean bean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+            VMOption checkpointTo1 = bean.getVMOption(\"CRaCCheckpointTo\");\n+            assertEquals(\"cr\", checkpointTo1.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, checkpointTo1.getOrigin());\n+            VMOption nmt1 = bean.getVMOption(\"NativeMemoryTracking\");\n+            assertEquals(\"off\", nmt1.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, nmt1.getOrigin());\n+        }\n+\n+        Core.checkpointRestore();\n+\n+        {\n+            HotSpotDiagnosticMXBean bean = ManagementFactory.getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n+            VMOption checkpointTo2 = bean.getVMOption(\"CRaCCheckpointTo\");\n+            assertEquals(\"another\", checkpointTo2.getValue());\n+            assertEquals(VMOption.Origin.OTHER, checkpointTo2.getOrigin());\n+            VMOption ignoredFileDescriptors = bean.getVMOption(\"CRaCIgnoredFileDescriptors\");\n+            assertEquals(\"42,43\", ignoredFileDescriptors.getValue());\n+            assertEquals(VMOption.Origin.OTHER, ignoredFileDescriptors.getOrigin());\n+            VMOption nmt = bean.getVMOption(\"NativeMemoryTracking\");\n+            assertEquals(\"off\", nmt.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, nmt.getOrigin());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/VMOptionsTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build CheckpointWithOpenFdsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class CheckpointWithOpenFdsTest implements CracTest {\n+    private static final String EXTRA_FD_WRAPPER = Path.of(Utils.TEST_SRC, \"extra_fd_wrapper.sh\").toString();\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.startCheckpoint(Arrays.asList(EXTRA_FD_WRAPPER, CracBuilder.JAVA)).waitForCheckpointed();\n+        builder.captureOutput(true).doRestore().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CheckpointWithOpenFdsTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build CloseProcessPipeTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseProcessPipeTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: pipe\n+                action: close\n+                \"\"\");\n+        try {\n+            CracBuilder builder = new CracBuilder()\n+                    .javaOption(JDKFdResource.COLLECT_FD_STACKTRACES_PROPERTY, \"true\")\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString());\n+            builder.doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Process process = new ProcessBuilder().command(\"cat\", \"\/dev\/zero\").start();\n+        byte[] buffer = new byte[1024];\n+        int read1 = process.getInputStream().read(buffer);\n+        assertGreaterThan(read1, 0);\n+        Core.checkpointRestore();\n+        int read2, total = read1;\n+        \/\/ Some data might got buffered from \/dev\/zero, we will still read those.\n+        try {\n+            while ((read2 = process.getInputStream().read(buffer)) >= 0) {\n+                total += read2;\n+            }\n+            fail(\"Should have failed\");\n+        } catch (IOException e) {\n+            \/\/ the exception comes from native method\n+        }\n+        System.err.printf(\"Read total %d bytes%n\", total);\n+        \/\/ The process will end with SIGPIPE\n+        assertEquals(141, process.waitFor());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseProcessPipeTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build CloseTcpSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseTcpSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+        Path config = writeConfig(\"\"\"\n+                type: SOCKET\n+                family: ip\n+                localAddress: $loopback\n+                action: close\n+                \"\"\".replace(\"$loopback\", loopback));\n+        try {\n+            new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseTcpSocketTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build CloseUdpSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseUdpSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+        Path config = writeConfig(\"\"\"\n+                type: socket\n+                localAddress: $loopback\n+                action: close\n+                \"\"\".replace(\"$loopback\", loopback));\n+        try {\n+            new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (DatagramSocket serverSocket = new DatagramSocket(0, InetAddress.getLoopbackAddress())) {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            Thread serverThread = new Thread(() -> {\n+                try {\n+                    byte[] buf = new byte[1024];\n+                    DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+                    serverSocket.receive(packet);\n+                    latch.countDown();\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            serverThread.setDaemon(true);\n+            serverThread.start();\n+            try (DatagramSocket clientSocket = new DatagramSocket()) {\n+                clientSocket.connect(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+                byte[] buf = \"Hello\".getBytes();\n+                clientSocket.send(new DatagramPacket(buf, buf.length));\n+                latch.await();\n+                Core.checkpointRestore();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseUdpSocketTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build CloseUnixSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseUnixSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: SoCkEt\n+                action: close\n+                family: unix\n+                \"\"\");\n+        try {\n+            new CracBuilder()\n+                    .javaOption(JDKFdResource.COLLECT_FD_STACKTRACES_PROPERTY, \"true\")\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Path socketFile = Files.createTempFile(CloseUnixSocketTest.class.getSimpleName(), \".socket\");\n+        Files.deleteIfExists(socketFile);\n+        UnixDomainSocketAddress address = UnixDomainSocketAddress.of(socketFile);\n+\n+        ServerSocketChannel serverChannel = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        serverChannel.bind(address);\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                SocketChannel socket = serverChannel.accept();\n+                latch1.countDown();\n+                \/\/ We need to prevent SocketChannel getting out of scope and being\n+                \/\/ garbage collected. When this happens the file descriptor leaks.\n+                \/\/ It is not up to CRaC to handle leaked descriptors.\n+                latch2.await();\n+            } catch (IOException | InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        SocketChannel clientChannel = SocketChannel.open(StandardProtocolFamily.UNIX);\n+        assertTrue(clientChannel.connect(address));\n+        latch1.await();\n+        Core.checkpointRestore();\n+        latch2.countDown();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseUnixSocketTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+\n+public abstract class FDPolicyTestBase {\n+\n+    protected void writeBigFile(Path path, String prefix, String suffix) throws IOException {\n+        StringBuilder sb = new StringBuilder().append(prefix);\n+        \/\/ Let's use 8+ MB file to avoid hidden buffering in FileInputStream or native parts\n+        for (int i = 0; i < 1024 * 1024; ++i) {\n+            sb.append(String.format(\"%08X\", 8 * i));\n+        }\n+        sb.append(suffix);\n+        Files.writeString(path, sb.toString());\n+    }\n+\n+    protected void readContents(FileReader reader) throws IOException {\n+        char[] bigbuf = new char[1024 * 1024];\n+        for (int count = 0; count < 8 * 1024 * 1024; ) {\n+            int r = reader.read(bigbuf);\n+            assertGreaterThan(r, 8);\n+            assertEquals(String.format(\"%08X\", count), new String(bigbuf, 0, 8));\n+            count += r;\n+        }\n+    }\n+\n+    protected Path writeConfig(String content) throws IOException {\n+        Path config = Files.createTempFile(getClass().getName(), \".yaml\");\n+        Files.writeString(config, content);\n+        return config;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FDPolicyTestBase.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build IgnoredFileDescriptorsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class IgnoredFileDescriptorsTest implements CracTest {\n+    private static final String EXTRA_FD_WRAPPER = Path.of(Utils.TEST_SRC, \"extra_fd_wrapper.sh\").toString();\n+\n+    @Override\n+    public void test() throws Exception {\n+        List<String> prefix = new ArrayList<>();\n+        prefix.add(EXTRA_FD_WRAPPER);\n+        prefix.addAll(Arrays.asList(\"-o\", \"43\", \"\/dev\/stdout\"));\n+        prefix.addAll(Arrays.asList(\"-o\", \"45\", \"\/dev\/urandom\"));\n+        prefix.add(CracBuilder.JAVA);\n+        prefix.add(\"-XX:CRaCIgnoredFileDescriptors=43,\/dev\/null,44,\/dev\/urandom\");\n+\n+        CracBuilder builder = new CracBuilder();\n+        builder.startCheckpoint(prefix).waitForCheckpointed();\n+        builder.captureOutput(true).doRestore().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var stream = Files.list(Path.of(\"\/proc\/self\/fd\"))) {\n+            Map<Integer, String> fds = stream.filter(Files::isSymbolicLink)\n+                    .collect(Collectors.toMap(\n+                            f -> Integer.parseInt(f.toFile().getName()),\n+                            f -> {\n+                                try {\n+                                    return Files.readSymbolicLink(f).toFile().getAbsoluteFile().toString();\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            }));\n+            if (fds.containsKey(42)) {\n+                throw new IllegalStateException(\"Oh no, 42 was not supposed to be ignored\");\n+            } else if (!fds.containsKey(0) || !fds.containsKey(1) || !fds.containsKey(2)) {\n+                throw new IllegalStateException(\"Missing standard I\/O? Available: \" + fds);\n+            } else if (!fds.containsKey(43)) {\n+                throw new IllegalStateException(\"Missing FD 43\");\n+            } else if (!fds.containsValue(\"\/dev\/urandom\")) {\n+                throw new IllegalStateException(\"Missing \/dev\/urandom\");\n+            }\n+        }\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/IgnoredFileDescriptorsTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.FileInputStream;\n+import java.io.RandomAccessFile;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build OpenFileDetectionTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class OpenFileDetectionTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder().captureOutput(true)\n+                .javaOption(\"jdk.crac.collect-fd-stacktraces\", \"true\")\n+                .startCheckpoint();\n+        cp.outputAnalyzer()\n+                .shouldHaveExitValue(1)\n+                .shouldMatch(\"CheckpointOpenFileException: \/etc\/passwd\") \/\/ RandomAccessFile should have the expected format\n+                .shouldMatch(\"\/etc\/group\") \/\/ others are allowed to specify the path in some format\n+                .shouldContain(\"This file descriptor was created by \"); \/\/ <thread> at <time> here\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var file1 = new RandomAccessFile(\"\/etc\/passwd\", \"r\");\n+             var file2 = new FileInputStream(\"\/etc\/group\")) {\n+            Core.checkpointRestore();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenFileDetectionTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build OpenSocketDetectionTest\n+ * @run driver\/timeout=10 jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class OpenSocketDetectionTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder().captureOutput(true)\n+                .startCheckpoint();\n+        cp.outputAnalyzer()\n+                .shouldHaveExitValue(1)\n+                .shouldMatch(\"CheckpointOpenSocketException: [A-Za-z0-9.$]+\\\\[addr=[A-Za-z0-9\/:.]+,port=[0-9]+,localport=[0-9]+\\\\]\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenSocketDetectionTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build ProcessPipelineTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ProcessPipelineTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        List<ProcessBuilder> pipeline = IntStream.range(0, 3)\n+                .mapToObj(ignored -> new ProcessBuilder().command(\"cat\")\n+                        .redirectError(ProcessBuilder.Redirect.DISCARD)).toList();\n+        \/\/ The pipeline creates several FDs to connect the subprocesses,\n+        \/\/ but all of them should be closed (in this process) when the method returns.\n+        List<Process> processes = ProcessBuilder.startPipeline(pipeline);\n+        try (\n+                var writer = new OutputStreamWriter(processes.get(0).getOutputStream());\n+                var reader = new BufferedReader(new InputStreamReader(processes.get(2).getInputStream()))\n+        ) {\n+            writer.write(\"Hello world\\n\");\n+            writer.flush();\n+            assertEquals(\"Hello world\", reader.readLine());\n+            try {\n+                Core.checkpointRestore();\n+                fail(\"Should have failed\");\n+            } catch (CheckpointException e) {\n+                \/\/ One for pipe to the first process, another for pipe from the last\n+                assertEquals(2, e.getSuppressed().length);\n+            }\n+        }\n+        \/\/ This time it should succeed\n+        Core.checkpointRestore();\n+        assertEquals(0, processes.get(0).waitFor());\n+        assertEquals(0, processes.get(1).waitFor());\n+        assertEquals(0, processes.get(2).waitFor());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ProcessPipelineTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.RestoreException;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.fail;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenFailureTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFailureTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String log1;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String log2;\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: file\n+                action: reopen\n+                \"\"\");\n+        Path path1 = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path path2 = Files.createTempFile(getClass().getName(), \".txt\");\n+        log1 = path1.toString();\n+        log2 = path2.toString();\n+        try {\n+            CracBuilder builder = new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .args(CracTest.args(log1, log2));\n+            builder.doCheckpoint();\n+            Files.delete(path1);\n+            Files.setPosixFilePermissions(path2, Collections.emptySet());\n+            builder.doRestore();\n+        } finally {\n+            Files.deleteIfExists(path1);\n+            Files.deleteIfExists(path2);\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var writer1 = new FileWriter(log1);\n+             var writer2 = new FileWriter(log2, true)) {\n+            writer1.write(\"Hello!\");\n+            writer1.flush();\n+            writer2.write(\"Hello!\");\n+            writer2.flush();\n+            try {\n+                Core.checkpointRestore();\n+                fail(\"Should throw\");\n+            } catch (RestoreException ex) {\n+                assertEquals(2, ex.getSuppressed().length);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFailureTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenFileReadingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileReadingTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(optional = true)\n+    String tempFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        tempFile = Files.createTempFile(getClass().getName(), \".txt\").toString();\n+        Path configFile = writeConfig(\"\"\"\n+                # These first two rules are just to test parsing\n+                type: FILE\n+                path: \/some\/other\/file\n+                action: error\n+                ---\n+                type: FILE\n+                path: **\/*.globpattern.test\n+                action: CLOSE\n+                ---\n+                type: FILE\n+                path: $tempFile\n+                # action is case-insensitive\n+                action: ReOpeN\n+                ---\n+                \"\"\".replace(\"$tempFile\", tempFile));\n+        Path tempPath = Path.of(tempFile);\n+        try {\n+            writeBigFile(tempPath, \"Hello \", \"world!\");\n+            new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, configFile.toString())\n+                    .args(CracTest.args(tempFile)).doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(tempPath);\n+            Files.deleteIfExists(configFile);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(tempFile);\n+             var fis = new FileInputStream(tempFile)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+\n+            FileChannel channel = fis.getChannel();\n+            byte[] buf2 = new byte[3];\n+            ByteBuffer byteBuffer = ByteBuffer.wrap(buf2);\n+            readFully(channel, byteBuffer);\n+            assertEquals(\"Hel\", new String(buf2, StandardCharsets.UTF_8));\n+\n+            Core.checkpointRestore();\n+            readContents(reader);\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+\n+            readFully(channel, byteBuffer);\n+            assertEquals(\"lo \", new String(buf2, StandardCharsets.UTF_8));\n+\n+            channel.position(8 * 1024 * 1024 + 6);\n+            readFully(channel, byteBuffer);\n+            assertEquals(\"wor\", new String(buf2, StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    private static void readFully(FileChannel channel, ByteBuffer byteBuffer) throws IOException {\n+        byteBuffer.clear();\n+        while (byteBuffer.position() < byteBuffer.capacity()) {\n+            channel.read(byteBuffer);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileReadingTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenFileWritingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileWritingTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String fileNoAppend;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String fileAppend;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String fileAppendExtended;\n+\n+    @CracTestArg(value = 3, optional = true)\n+    String fileAppendTruncated;\n+\n+    @CracTestArg(value = 4, optional = true)\n+    String fileUseChannel;\n+\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path noAppendPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path appendPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path appendExtendedPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path appendTruncatedPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path useChannelPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        fileNoAppend = noAppendPath.toString();\n+        fileAppend = appendPath.toString();\n+        fileAppendExtended = appendExtendedPath.toString();\n+        fileAppendTruncated = appendTruncatedPath.toString();\n+        fileUseChannel = useChannelPath.toString();\n+        Path config = writeConfig(\"\"\"\n+                type: FILE\n+                action: reopen\n+                \"\"\");\n+        try {\n+            CracBuilder builder = new CracBuilder();\n+            builder\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .args(CracTest.args(fileNoAppend, fileAppend, fileAppendExtended, fileAppendTruncated, fileUseChannel));\n+            builder.doCheckpoint();\n+            assertEquals(\"Hello \", Files.readString(noAppendPath));\n+            assertEquals(\"Hello \", Files.readString(appendPath));\n+            assertEquals(\"Hello \", Files.readString(appendExtendedPath));\n+            assertEquals(\"Hello \", Files.readString(appendTruncatedPath));\n+            assertEquals(\"Hello \", Files.readString(useChannelPath));\n+            Files.writeString(noAppendPath, \"1234567890\");\n+            Files.writeString(appendPath, \"123456\");\n+            Files.writeString(appendExtendedPath, \"1234567890\");\n+            Files.writeString(appendTruncatedPath, \"\");\n+            Files.writeString(useChannelPath, \"123456\");\n+            builder.doRestore();\n+            assertEquals(\"123456world!\", Files.readString(noAppendPath));\n+            assertEquals(\"123456world!\", Files.readString(appendPath));\n+            assertEquals(\"1234567890world!\", Files.readString(appendExtendedPath));\n+            assertEquals(\"world!\", Files.readString(appendTruncatedPath));\n+            assertEquals(\"123world!\", Files.readString(useChannelPath));\n+        } finally {\n+            Files.deleteIfExists(noAppendPath);\n+            Files.deleteIfExists(appendPath);\n+            Files.deleteIfExists(appendExtendedPath);\n+            Files.deleteIfExists(appendTruncatedPath);\n+            Files.deleteIfExists(useChannelPath);\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var w1 = new FileWriter(fileNoAppend);\n+             var w2 = new FileWriter(fileAppend, true);\n+             var w3 = new FileWriter(fileAppendExtended, true);\n+             var w4 = new FileWriter(fileAppendTruncated, true);\n+             var fos5 = new FileOutputStream(fileUseChannel)) {\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"Hello \");\n+                    w.flush();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            FileChannel ch5 = fos5.getChannel();\n+            ch5.write(ByteBuffer.wrap(\"Hello \".getBytes(StandardCharsets.UTF_8)));\n+            Core.checkpointRestore();\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"world!\");\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            ch5.position(3);\n+            ch5.write(ByteBuffer.wrap(\"world!\".getBytes(StandardCharsets.UTF_8)));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileWritingTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenNamedFifoTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenNamedFifoTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(optional = true)\n+    String fifo;\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path tempDirectory = Files.createTempDirectory(getClass().getName());\n+        Path pipePath = tempDirectory.resolve(\"pipe\");\n+        fifo = pipePath.toString();\n+        assertEquals(0, new ProcessBuilder().inheritIO().command(\"mkfifo\", fifo).start().waitFor());\n+        \/\/ From Java POV this has a path, therefore is treated as a file and not as a named pipe\n+        Path config = writeConfig(\"\"\"\n+                type: file\n+                action: reopen\n+                \"\"\");\n+        CracBuilder builder = new CracBuilder()\n+                .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                .args(CracTest.args(fifo));\n+        CracProcess cp = builder.startCheckpoint();\n+\n+        try (var writer = new FileWriter(fifo)) {\n+            writer.write(\"Hello \");\n+            writer.flush();\n+            cp.waitForCheckpointed();\n+            CracProcess rp = builder.captureOutput(true).startRestore();\n+            CountDownLatch latch = new CountDownLatch(1);\n+            rp.watch(output -> {\n+                if (output.contains(\"RESTORED\")) {\n+                    latch.countDown();\n+                }\n+            }, error -> {\n+                System.err.println(error);\n+                latch.countDown();\n+            });\n+            latch.await();\n+            writer.write(\"world!\");\n+            writer.flush();\n+            rp.waitForSuccess();\n+        } finally {\n+            Files.deleteIfExists(pipePath);\n+            Files.deleteIfExists(tempDirectory);\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(fifo)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            System.out.println(\"RESTORED\");\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenNamedFifoTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+#!\/bin\/bash\n+# Java opens all files with O_CLOEXEC (or calls fcntl(FD_CLOEXEC)) so we cannot trigger this behaviour from Java code;\n+# this opens a file descriptor and executes subprocess based on its arguments.\n+FILE=$(mktemp -p \/dev\/shm)\n+exec 42<>$FILE\n+# criu uses DEFAULT_GHOST_LIMIT 1M - let's create a file bigger than that\n+dd if=\/dev\/urandom bs=4096 count=257 >&42 2>\/dev\/null\n+rm $FILE\n+# Open some extra files\n+while [ $1 = \"-o\" ]; do\n+  eval \"exec $2<>$3\"\n+  shift 3\n+done\n+exec \"$@\"\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/extra_fd_wrapper.sh","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.management.CRaCMXBean;\n+import jdk.test.lib.Container;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.RuntimeMXBean;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test NanoTimeTest\n+ * @requires (os.family == \"linux\")\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build NanoTimeTest\n+ * @run driver jdk.test.lib.crac.CracTest      0 true\n+ * @run driver jdk.test.lib.crac.CracTest  86400 true\n+ * @run driver jdk.test.lib.crac.CracTest -86400 true\n+ * @run driver jdk.test.lib.crac.CracTest  86400 false\n+ * @run driver jdk.test.lib.crac.CracTest -86400 false\n+ *\/\n+public class NanoTimeTest implements CracTest {\n+    private static final String imageName = Common.imageName(\"system-nanotime\");\n+\n+    @CracTestArg(0)\n+    long monotonicOffset;\n+\n+    @CracTestArg(1)\n+    boolean changeBootId;\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+        CracBuilder builder = new CracBuilder();\n+        Path bootIdFile = Files.createTempFile(\"NanoTimeTest-\", \"-boot_id\");\n+        try {\n+            \/\/ TODO: use more official image\n+            builder.withBaseImage(\"ghcr.io\/crac\/test-base\", \"latest\")\n+                    .dockerOptions(\"-v\", bootIdFile + \":\/fake_boot_id\")\n+                    .inDockerImage(imageName);\n+\n+            Files.writeString(bootIdFile, \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\n\");\n+            \/\/ We need to preload the library before checkpoint\n+            builder.doCheckpoint(Container.ENGINE_COMMAND, \"exec\",\n+                    \"-e\", \"LD_PRELOAD=\/opt\/path-mapping-quiet.so\",\n+                    \"-e\", \"PATH_MAPPING=\/proc\/sys\/kernel\/random\/boot_id:\/fake_boot_id\",\n+                    CracBuilder.CONTAINER_NAME,\n+                    \/\/ In case we are trying to use negative monotonic offset we could\n+                    \/\/ run into situation where we'd set it to negative value (prohibited).\n+                    \/\/ Therefore, we'll rather offset it to the future before checkpoint\n+                    \/\/ and set to 0 for restore.\n+                    \"unshare\", \"--fork\", \"--time\", \"--monotonic\", String.valueOf(Math.max(-monotonicOffset, 0)),\n+                    CracBuilder.DOCKER_JAVA);\n+\n+            if (changeBootId) {\n+                Files.writeString(bootIdFile, \"yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\\n\");\n+            }\n+\n+            builder.doRestore(Container.ENGINE_COMMAND, \"exec\", CracBuilder.CONTAINER_NAME,\n+                    \"unshare\", \"--fork\", \"--time\", \"--boottime\", \"86400\", \"--monotonic\", String.valueOf(Math.max(monotonicOffset, 0)),\n+                    CracBuilder.DOCKER_JAVA);\n+        } finally {\n+            builder.ensureContainerKilled();\n+            assertTrue(bootIdFile.toFile().delete());\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(\"Expected offset: \" + monotonicOffset);\n+        \/\/ We use uptime to assert that changing the clock worked\n+        long boottimeBefore = readSystemUptime();\n+\n+        long before = System.nanoTime();\n+        Core.checkpointRestore();\n+        long after = System.nanoTime();\n+        System.out.println(\"Before: \" + before);\n+        System.out.println(\"After: \" + after);\n+        assertLTE(before, after, \"After < Before\");\n+        if (changeBootId || monotonicOffset <= 0) {\n+            \/\/ Even though we have shifted the monotic offset by a day the difference\n+            \/\/ is adjusted by difference between wall clock time before and after;\n+            \/\/ the difference in monotonic time is considered \"random\"\n+            assertLT(after, before + TimeUnit.HOURS.toNanos(1), \"After too late\");\n+        } else {\n+            assertGT(after, before + TimeUnit.HOURS.toNanos(1), \"After too early\");\n+            assertLT(after, before + TimeUnit.HOURS.toNanos(25), \"After too late\");\n+        }\n+        long boottimeAfter = readSystemUptime();\n+        assertGTE(boottimeAfter, boottimeBefore + 86_400_000, \"Boottime was not changed\");\n+        RuntimeMXBean runtimeMX = ManagementFactory.getRuntimeMXBean();\n+        assertGTE(runtimeMX.getUptime(), 0L, \"VM Uptime is negative!\");\n+        CRaCMXBean cracBean = CRaCMXBean.getCRaCMXBean();\n+        assertLT(cracBean.getUptimeSinceRestore(), 60_000L);\n+        assertGTE(cracBean.getUptimeSinceRestore(), 0L);\n+    }\n+\n+    private long readSystemUptime() throws IOException {\n+        String uptimeStr = Files.readString(Path.of(\"\/proc\/uptime\"));\n+        String[] parts = uptimeStr.split(\" \");\n+        return (long)(Double.parseDouble(parts[0]) * 1000);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/System\/NanoTimeTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test TimedWaitingTest checks whether timed waiting does not block when monotonic time runs backwards\n+ * @requires (os.family == \"linux\")\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build TimedWaitingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class TimedWaitingTest implements CracTest {\n+    private static final String imageName = Common.imageName(\"timed-waiting\");\n+    public static final String WAITING = \"WAITING\";\n+    public static final int WAIT_TIME_MILLIS = 1000;\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        CracBuilder builder = new CracBuilder();\n+        Path bootIdFile = Files.createTempFile(\"NanoTimeTest-\", \"-boot_id\");\n+        try {\n+            builder.withBaseImage(\"ghcr.io\/crac\/test-base\", \"latest\")\n+                    .dockerOptions(\"-v\", bootIdFile + \":\/fake_boot_id\")\n+                    .inDockerImage(imageName);\n+            builder.captureOutput(true);\n+\n+            Files.writeString(bootIdFile, \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\\n\");\n+            \/\/ We need to preload the library before checkpoint\n+            CracProcess checkpointed = builder.startCheckpoint(Container.ENGINE_COMMAND, \"exec\",\n+                    \"-e\", \"LD_PRELOAD=\/opt\/path-mapping-quiet.so\",\n+                    \"-e\", \"PATH_MAPPING=\/proc\/sys\/kernel\/random\/boot_id:\/fake_boot_id\",\n+                    CracBuilder.CONTAINER_NAME,\n+                    \"unshare\", \"--fork\", \"--time\", \"--monotonic\", \"86400\", \"--boottime\", \"86400\",\n+                    CracBuilder.DOCKER_JAVA);\n+            CountDownLatch latch = new CountDownLatch(1);\n+            checkpointed.watch(out -> {\n+                System.out.println(out);\n+                if (WAITING.equals(out)) {\n+                    latch.countDown();\n+                }\n+            }, System.err::println);\n+            latch.await();\n+            builder.checkpointViaJcmd();\n+            checkpointed.waitForCheckpointed();\n+\n+            Files.writeString(bootIdFile, \"yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyyyy\\n\");\n+\n+            CracProcess restore = builder.startRestore();\n+            CompletableFuture<Void> future = new CompletableFuture<>();\n+            new Thread(() -> {\n+                try {\n+                    restore.waitForSuccess();\n+                    System.err.print(restore.outputAnalyzer().getStderr());\n+                    future.complete(null);\n+                } catch (Throwable t) {\n+                    future.completeExceptionally(t);\n+                }\n+            }).start();\n+            future.get(10, TimeUnit.SECONDS);\n+        } finally {\n+            builder.ensureContainerKilled();\n+            assertTrue(bootIdFile.toFile().delete());\n+        }\n+    }\n+\n+    private interface Task {\n+        void run() throws InterruptedException;\n+    }\n+\n+    private static void timedWait(Task task, List<Throwable> exceptions, boolean canReturnEarly) {\n+        try {\n+            long before = System.currentTimeMillis();\n+            task.run();\n+            long after = System.currentTimeMillis();\n+            if (after - before < WAIT_TIME_MILLIS) {\n+                if (canReturnEarly) {\n+                    \/\/ Non-critical\n+                    System.err.println(Thread.currentThread().getName() + \" took: \" + (after - before) + \" ms\");\n+                } else {\n+                    exceptions.add(new IllegalStateException(\n+                            Thread.currentThread().getName() + \" was too short: \" + (after - before) + \" ms\"));\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            exceptions.add(unexpectedInterrupt(e));\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        List<Throwable> exceptions = Collections.synchronizedList(new ArrayList<>());\n+        List<Thread> threads = new ArrayList<>();\n+        CountDownLatch latch = new CountDownLatch(6);\n+\n+        startThread(\"Thread.sleep\", threads, latch, () -> {\n+            timedWait(() -> Thread.sleep(WAIT_TIME_MILLIS), exceptions, false);\n+        });\n+\n+        startThread(\"Thread.join\", threads, latch, () -> {\n+            Thread daemon = new Thread(() -> {\n+                try {\n+                    Thread.sleep(86_400_000);\n+                } catch (InterruptedException e) {\n+                    exceptions.add(unexpectedInterrupt(e));\n+                }\n+            }, \"inifinite daemon\");\n+            daemon.setDaemon(true);\n+            daemon.start();\n+            timedWait(() -> daemon.join(WAIT_TIME_MILLIS), exceptions, false);\n+        });\n+\n+        startThread(\"Object.wait\", threads, latch, () -> {\n+            synchronized (this) {\n+                timedWait(() -> this.wait(WAIT_TIME_MILLIS), exceptions, true);\n+            }\n+        });\n+\n+        ReentrantLock lock = new ReentrantLock();\n+        lock.lock();\n+        startThread(\"ReentrantLock.tryLock\", threads, latch, () -> {\n+            timedWait(() -> {\n+                if (lock.tryLock(WAIT_TIME_MILLIS, TimeUnit.MILLISECONDS)) {\n+                    exceptions.add(new AssertionError(\"Should not be able to lock\"));\n+                }\n+            }, exceptions, false);\n+        });\n+\n+        startThread(\"Condition.await\", threads, latch, () -> {\n+            ReentrantLock lock2 = new ReentrantLock();\n+            Condition condition = lock2.newCondition();\n+            lock2.lock();\n+            \/\/noinspection ResultOfMethodCallIgnored\n+            timedWait(() -> condition.await(WAIT_TIME_MILLIS, TimeUnit.MILLISECONDS), exceptions, true);\n+        });\n+\n+        startThread(\"LockSupport.parkUntil\", threads, latch, () -> {\n+            timedWait(() -> LockSupport.parkUntil(System.currentTimeMillis() + WAIT_TIME_MILLIS),\n+                    exceptions, true);\n+        });\n+\n+        assertEquals(latch.getCount(), (long) threads.size());\n+        do {\n+            Thread.yield();\n+            threads.stream().forEach(t -> {\n+                System.out.printf(\"%s: %s%n\", t.getName(), t.getState());\n+            });\n+        } while (!threads.stream().map(Thread::getState).allMatch(Thread.State.TIMED_WAITING::equals));\n+        System.out.println(WAITING);\n+        \/\/ Make sure none of the threads completed yet\n+        assertEquals(latch.getCount(), (long) threads.size());\n+        try {\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            fail(\"Should not get interrupted\", e);\n+        }\n+        assertEquals(Collections.emptyList(), exceptions);\n+    }\n+\n+    private static void startThread(String name, List<Thread> threads, CountDownLatch latch, Runnable runnable) {\n+        Thread thread = new Thread(() -> {\n+            try {\n+                runnable.run();\n+            } finally {\n+                latch.countDown();\n+            }\n+        }, name);\n+        threads.add(thread);\n+        thread.start();\n+    }\n+\n+    private static AssertionError unexpectedInterrupt(InterruptedException e) {\n+        return new AssertionError(Thread.currentThread().getName() + \" interrupted\", e);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/System\/TimedWaitingTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.util.concurrent.CountDownLatch;\n+\/*\n+ * @test JoinSleepWaitOnCRPauseTest.java\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @summary check if Thread.join(timeout), Thread.sleep(timeout)\n+ *          and Object.wait(timeout)\n+ *          will be completed on restore immediately\n+ *          if their end time fell on the CRaC pause period\n+ *          (i.e. between the checkpoint and restore)\n+ *\n+ * @build JoinSleepWaitOnCRPauseTest\n+ * @run driver jdk.test.lib.crac.CracTest join_ms\n+ * @run driver jdk.test.lib.crac.CracTest join_ns\n+ * @run driver jdk.test.lib.crac.CracTest sleep_ms\n+ * @run driver jdk.test.lib.crac.CracTest sleep_ns\n+ * @run driver jdk.test.lib.crac.CracTest wait_ms\n+ * @run driver jdk.test.lib.crac.CracTest wait_ns\n+ *\/\n+public class JoinSleepWaitOnCRPauseTest implements CracTest {\n+    private enum TestType {\n+        join_ms, join_ns, sleep_ms, sleep_ns, wait_ms, wait_ns\n+    }\n+\n+    @CracTestArg\n+    private TestType testType;\n+\n+    private final static long EPS_NS = Long.parseLong(System.getProperty(\n+        \"test.jdk.jdk.crac.java.lang.Thread.crac.JoinSleepWaitOnCRPauseTest.eps\",\n+        \"100000000\")); \/\/ default: 0.1s\n+\n+    private static final long CRPAUSE_MS = 4000;\n+\n+    private static final long T_MS = CRPAUSE_MS \/ 2;\n+    private static final  int T_NS = 100;\n+\n+    private volatile long tDone = -1;\n+\n+    private final CountDownLatch checkpointLatch = new CountDownLatch(1);\n+\n+    @Override\n+    public void exec() throws Exception {\n+\n+        String op = testType.name();\n+        op = op.substring(0, op.length() - 3); \/\/ remove suffix\n+\n+        Thread mainThread = Thread.currentThread();\n+\n+        Runnable r = () -> {\n+\n+            try {\n+\n+                checkpointLatch.countDown();\n+\n+                switch (testType) {\n+\n+                    case join_ms:\n+                        mainThread.join(T_MS);\n+                        break;\n+\n+                    case join_ns:\n+                        mainThread.join(T_MS, T_NS);\n+                        break;\n+\n+                    case sleep_ms:\n+                        Thread.sleep(T_MS);\n+                        break;\n+\n+                    case sleep_ns:\n+                        Thread.sleep(T_MS, T_NS);\n+                        break;\n+\n+                    case wait_ms:\n+                        synchronized(this) { wait(T_MS);  }\n+                        break;\n+\n+                    case wait_ns:\n+                        synchronized(this) { wait(T_MS, T_NS);  }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(\"unknown test type\");\n+                }\n+\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(ie);\n+            }\n+\n+            tDone = System.nanoTime();\n+        };\n+\n+        Thread t = new Thread(r);\n+        t.start();\n+\n+        \/\/ this additional synchronization is probably redundant;\n+        \/\/ adding it to ensure we get the expected TIMED_WAITING state\n+        \/\/ from \"our\" join or sleep\n+        checkpointLatch.await();\n+\n+        \/\/ it is expected that EPS_NS is enough to complete the join\/sleep\n+        \/\/ on restore => expecting that 5 * EPS_NS is enough to enter them\n+        long dt = 5 * EPS_NS;\n+        Thread.sleep(dt \/ 1_000_000);\n+\n+        if (t.getState() != Thread.State.TIMED_WAITING) {\n+            throw new AssertionError(\"was not able to enter \" + op\n+                + \" in \" + dt + \" ns\");\n+        }\n+\n+        long tBeforeCheckpoint = System.nanoTime();\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        long tAfterRestore = System.nanoTime();\n+\n+        t.join();\n+\n+        long pause = tAfterRestore - tBeforeCheckpoint;\n+        if (pause < 1_000_000 * CRPAUSE_MS - EPS_NS) {\n+            throw new AssertionError(\n+                \"the CR pause was less than \" + CRPAUSE_MS + \" ms\");\n+        }\n+\n+        if (tDone < tBeforeCheckpoint + EPS_NS) {\n+            throw new AssertionError(\n+                op + \" has finished before the checkpoint\");\n+        }\n+\n+        long eps = Math.abs(tAfterRestore - tDone);\n+\n+        if (eps > EPS_NS) {\n+            throw new RuntimeException(\n+                \"the \" + op + \"ing thread has finished in \" + eps + \" ns \"\n+                + \"after the restore (expected: \" + EPS_NS + \" ns)\");\n+        }\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder()\n+                .imageDir(\"cr_\" + testType.name());\n+        builder.doCheckpoint();\n+\n+        \/\/ sleep a few seconds to ensure the task execution time\n+        \/\/ falls within this pause period\n+        Thread.sleep(CRPAUSE_MS);\n+\n+        builder.doRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/Thread\/JoinSleepWaitOnCRPauseTest.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.*;\n+\n+\/*\n+ * @test\n+ * @summary Test if InetAddress cache is flushed after checkpoint\/restore\n+ * @requires (os.family == \"linux\")\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build ResolveTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ResolveTest implements CracTest {\n+    private static final String imageName = Common.imageName(\"inet-address\");\n+    public static final String TEST_HOSTNAME = \"some.test.hostname.example.com\";\n+\n+    @CracTestArg(value = 0, optional = true)\n+    String ip;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String checkFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+        CracBuilder builder = new CracBuilder()\n+                .inDockerImage(imageName).dockerOptions(\"--add-host\", TEST_HOSTNAME + \":192.168.12.34\")\n+                .captureOutput(true)\n+                .args(CracTest.args(TEST_HOSTNAME, \"\/second-run\"));\n+\n+        try {\n+            CompletableFuture<?> firstOutputFuture = new CompletableFuture<Void>();\n+            builder.vmOption(\"-XX:CRaCMinPid=100\");\n+            CracProcess checkpointed = builder.startCheckpoint().watch(line -> {\n+                System.out.println(\"OUTPUT: \" + line);\n+                if (line.equals(\"192.168.12.34\")) {\n+                    firstOutputFuture.complete(null);\n+                }\n+            }, error -> {\n+                System.err.println(\"ERROR: \" + error);\n+                firstOutputFuture.cancel(false);\n+            });\n+            firstOutputFuture.get(10, TimeUnit.SECONDS);\n+            builder.checkpointViaJcmd();\n+            checkpointed.waitForCheckpointed();\n+\n+            builder.clearVmOptions();\n+            builder.recreateContainer(imageName,\n+                    \"--add-host\", TEST_HOSTNAME + \":192.168.56.78\",\n+                    \"--volume\", Utils.TEST_CLASSES + \":\/second-run\"); \/\/ any file\/dir suffices\n+\n+\n+            builder.startRestore().outputAnalyzer()\n+                    .shouldHaveExitValue(0)\n+                    .shouldContain(\"192.168.56.78\");\n+        } finally {\n+            builder.ensureContainerKilled();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (ip == null || checkFile == null) {\n+            System.err.println(\"Args: <ip address> <check file path>\");\n+            return;\n+        }\n+        printAddress(ip);\n+        while (!Files.exists(Path.of(checkFile))) {\n+            try {\n+                \/\/noinspection BusyWait\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                System.err.println(\"Interrupted!\");\n+                return;\n+            }\n+        }\n+        printAddress(ip);\n+    }\n+\n+    private static void printAddress(String hostname) {\n+        try {\n+            InetAddress address = InetAddress.getByName(hostname);\n+            \/\/ we will assume IPv4 address\n+            byte[] bytes = address.getAddress();\n+            System.out.print(bytes[0] & 0xFF);\n+            for (int i = 1; i < bytes.length; ++i) {\n+                System.out.print('.');\n+                System.out.print(bytes[i] & 0xFF);\n+            }\n+            System.out.println();\n+        } catch (UnknownHostException e) {\n+            System.out.println();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+handlers = java.util.logging.ConsoleHandler\n+.level = ALL\n+java.util.logging.ConsoleHandler.level = FINE\n+java.util.logging.SimpleFormatter.format=%1$tH:%1$tM:%1$tS %4$s [%3$s] %5$s%6$s%n\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/crac\/logging.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.*;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/*\n+ * @test\n+ * @summary check that the recursive checkpoint is not allowed\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest 10\n+ *\/\n+public class Test implements Resource, CracTest {\n+    private static final AtomicInteger counter = new AtomicInteger(0);\n+    private static Exception exception = null;\n+\n+    @CracTestArg\n+    int numThreads;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.PAUSE);\n+        CracProcess process = builder.startCheckpoint();\n+        process.waitForPausePid();\n+        for (int i = 1; i <= numThreads + 1; ++i) {\n+            System.err.printf(\"Restore #%d%n\", i);\n+            builder.doRestore();\n+        }\n+        process.waitForSuccess();\n+    }\n+\n+    private static class TestThread extends Thread {\n+\n+        @Override\n+        public void run() {\n+            try {\n+                jdk.crac.Core.checkpointRestore();\n+            } catch (CheckpointException e) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Checkpoint in thread ERROR \" + e);\n+            } catch (RestoreException e) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Restore in thread ERROR \" + e);\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        try {\n+            int c = counter.incrementAndGet();\n+            if (c > 1) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Parallel checkpoint\");\n+            }\n+            Thread.sleep(100);\n+            jdk.crac.Core.checkpointRestore();\n+            if (exception != null)\n+                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n+        } catch (CheckpointException e) {\n+            \/\/ Expected Exception\n+        } catch (RestoreException e) {\n+            if (exception == null)\n+                exception = new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        try {\n+            int c = counter.get();\n+            if (c > 1) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Parallel checkpoint\");\n+            }\n+            Thread.sleep(100);\n+            jdk.crac.Core.checkpointRestore();\n+            if (exception == null)\n+                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n+        } catch (CheckpointException e) {\n+            \/\/ Expected Exception\n+        } catch (RestoreException e) {\n+            if (exception == null)\n+                exception = new RuntimeException(\"Restore ERROR \" + e);\n+        } finally {\n+            counter.decrementAndGet();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.getGlobalContext().register(new Test());\n+\n+        TestThread[] threads = new TestThread[numThreads];\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i] = new TestThread();\n+            threads[i].start();\n+        };\n+\n+        Thread.sleep(100);\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+        } catch (RestoreException e) {\n+            throw new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+\n+        for (int i = 0; i < numThreads; i++) {\n+            threads[i].join();\n+        };\n+\n+        long ccounter = counter.get();\n+        if (ccounter != 0)\n+            throw new RuntimeException(\"Incorrect counter after restore: \" + ccounter + \" instead of 0\");\n+        if (exception != null) {\n+            throw exception;\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -40,0 +40,3 @@\n+    public static final String BASE_IMAGE_NAME = \"jdk.test.docker.image.name\";\n+    public static final String BASE_IMAGE_VERSION = \"jdk.test.docker.image.version\";\n+\n@@ -41,1 +44,1 @@\n-        String name = System.getProperty(\"jdk.test.docker.image.name\");\n+        String name = System.getProperty(BASE_IMAGE_NAME);\n@@ -60,1 +63,1 @@\n-        String version = System.getProperty(\"jdk.test.docker.image.version\");\n+        String version = System.getProperty(BASE_IMAGE_VERSION);\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,484 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.containers.docker.DockerfileConfig;\n+import jdk.test.lib.util.FileUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+public class CracBuilder {\n+    private static final String DEFAULT_IMAGE_DIR = \"cr\";\n+    public static final String CONTAINER_NAME = \"crac-test\";\n+    public static final String JAVA = Utils.TEST_JDK + \"\/bin\/java\";\n+    public static final String DOCKER_JAVA = \"\/jdk\/bin\/java\";\n+    private static final List<String> CRIU_CANDIDATES = Arrays.asList(Utils.TEST_JDK + \"\/lib\/criu\", \"\/usr\/sbin\/criu\", \"\/sbin\/criu\");\n+    private static final String CRIU_PATH;\n+\n+    \/\/ This dummy field is here as workaround for (possibly) a JTReg bug;\n+    \/\/ some tests don't build CracTestArg into their Test.d\/ directory\n+    \/\/ (not all classes from \/test\/lib are built!) and the tests would fail.\n+    \/\/ This does not always happen when the test is run individually but breaks\n+    \/\/ when the whole suite is executed.\n+    private static final Class<CracTestArg> dummyWorkaround = CracTestArg.class;\n+\n+    boolean verbose = true;\n+    boolean debug = false;\n+    final List<String> classpathEntries = new ArrayList<>();\n+    final Map<String, String> env = new HashMap<>();\n+    final List<String> vmOptions = new ArrayList<>();\n+    final Map<String, String> javaOptions = new HashMap<>();\n+    String imageDir = DEFAULT_IMAGE_DIR;\n+    CracEngine engine;\n+    String[] engineArgs;\n+    boolean printResources;\n+    Class<?> main;\n+    String[] args;\n+    boolean captureOutput;\n+    String dockerImageBaseName;\n+    String dockerImageBaseVersion;\n+    String dockerImageName;\n+    private String[] dockerOptions;\n+    private List<String> dockerCheckpointOptions;\n+    boolean containerUsePrivileged = true;\n+    private List<String> containerSetupCommand;\n+    boolean runContainerDirectly = false;\n+    \/\/ make sure to update copy() when adding another field here\n+\n+    boolean containerStarted;\n+\n+    static {\n+        String path = System.getenv(\"CRAC_CRIU_PATH\");\n+        if (path == null) {\n+            for (String candidate : CRIU_CANDIDATES) {\n+                if (new File(candidate).exists()) {\n+                    path = candidate;\n+                    break;\n+                }\n+            }\n+        }\n+        CRIU_PATH = path;\n+    }\n+\n+    public CracBuilder() {\n+    }\n+\n+    public CracBuilder copy() {\n+        CracBuilder other = new CracBuilder();\n+        other.verbose = verbose;\n+        other.debug = debug;\n+        other.classpathEntries.addAll(classpathEntries);\n+        other.env.putAll(env);\n+        other.vmOptions.addAll(vmOptions);\n+        other.javaOptions.putAll(javaOptions);\n+        other.imageDir = imageDir;\n+        other.engine = engine;\n+        other.engineArgs = engineArgs == null ? null : Arrays.copyOf(engineArgs, engineArgs.length);\n+        other.printResources = printResources;\n+        other.main = main;\n+        other.args = args == null ? null : Arrays.copyOf(args, args.length);\n+        other.captureOutput = captureOutput;\n+        other.dockerImageName = dockerImageName;\n+        other.dockerOptions = dockerOptions == null ? null : Arrays.copyOf(dockerOptions, dockerOptions.length);\n+        other.dockerCheckpointOptions = dockerCheckpointOptions;\n+        other.containerUsePrivileged = containerUsePrivileged;\n+        other.containerSetupCommand = containerSetupCommand;\n+        other.runContainerDirectly = runContainerDirectly;\n+        return other;\n+    }\n+\n+    public CracBuilder verbose(boolean verbose) {\n+        this.verbose = verbose;\n+        return this;\n+    }\n+\n+    public CracBuilder debug(boolean debug) {\n+        this.debug = debug;\n+        return this;\n+    }\n+\n+    public CracBuilder dockerCheckpointOptions(List<String> options) {\n+        this.dockerCheckpointOptions = options;\n+        return this;\n+    }\n+\n+    public CracBuilder containerSetup(List<String> cmd) {\n+        this.containerSetupCommand = cmd;\n+        return this;\n+    }\n+\n+    public CracBuilder containerUsePrivileged(boolean usePrivileged) {\n+        this.containerUsePrivileged = usePrivileged;\n+        return this;\n+    }\n+\n+    public CracBuilder runContainerDirectly(boolean runDirectly) {\n+        this.runContainerDirectly = runDirectly;\n+        return this;\n+    }\n+\n+    public CracBuilder classpathEntry(String cp) {\n+        classpathEntries.add(cp);\n+        return this;\n+    }\n+\n+    public CracBuilder engine(CracEngine engine, String... args) {\n+        assertTrue(this.engine == null || this.engine.equals(engine)); \/\/ allow overwriting args\n+        this.engine = engine;\n+        this.engineArgs = args;\n+        return this;\n+    }\n+\n+    public Path imageDir() {\n+        return Path.of(imageDir);\n+    }\n+\n+    public CracBuilder imageDir(String imageDir) {\n+        assertEquals(DEFAULT_IMAGE_DIR, this.imageDir); \/\/ set once\n+        this.imageDir = imageDir;\n+        return this;\n+    }\n+\n+    public CracBuilder vmOption(String option) {\n+        vmOptions.add(option);\n+        return this;\n+    }\n+\n+    public void clearVmOptions() {\n+        vmOptions.clear();\n+    }\n+\n+    public CracBuilder printResources(boolean print) {\n+        this.printResources = print;\n+        return this;\n+    }\n+\n+    public CracBuilder env(String name, String value) {\n+        env.put(name, value);\n+        return this;\n+    }\n+\n+    public CracBuilder javaOption(String name, String value) {\n+        javaOptions.put(name, value);\n+        return this;\n+    }\n+\n+    public CracBuilder main(Class<?> mainClass) {\n+        assertNull(this.main); \/\/ set once\n+        this.main = mainClass;\n+        return this;\n+    }\n+\n+    public Class<?> main() {\n+        return main != null ? main : CracTest.class;\n+    }\n+\n+    public CracBuilder args(String... args) {\n+        assertNull(this.args); \/\/ set once\n+        this.args = args;\n+        return this;\n+    }\n+\n+    public String[] args() {\n+        return args != null ? args : CracTest.args();\n+    }\n+\n+    public CracBuilder captureOutput(boolean captureOutput) {\n+        this.captureOutput = captureOutput;\n+        return this;\n+    }\n+\n+    public CracBuilder withBaseImage(String name, String tag) {\n+        assertNull(dockerImageBaseName);\n+        assertNull(dockerImageBaseVersion);\n+        this.dockerImageBaseName = name;\n+        this.dockerImageBaseVersion = tag;\n+        return this;\n+    }\n+\n+    public CracBuilder inDockerImage(String imageName) {\n+        assertNull(dockerImageName);\n+        this.dockerImageName = imageName;\n+        return this;\n+    }\n+\n+    public CracBuilder dockerOptions(String... options) {\n+        assertNull(dockerOptions);\n+        this.dockerOptions = options;\n+        return this;\n+    }\n+\n+    public void doCheckpoint(String... javaPrefix) throws Exception {\n+        startCheckpoint(javaPrefix).waitForCheckpointed();\n+    }\n+\n+    public CracProcess startCheckpoint(String... javaPrefix) throws Exception {\n+        List<String> list = javaPrefix.length == 0 ? null : Arrays.asList(javaPrefix);\n+        return startCheckpoint(list);\n+    }\n+\n+    public CracProcess startCheckpoint(List<String> javaPrefix) throws Exception {\n+        if (runContainerDirectly) {\n+            prepareContainer();\n+        } else {\n+            ensureContainerStarted();\n+        }\n+        List<String> cmd = prepareCommand(javaPrefix, false);\n+        cmd.add(\"-XX:CRaCCheckpointTo=\" + imageDir);\n+        cmd.add(main().getName());\n+        cmd.addAll(Arrays.asList(args()));\n+        log(\"Starting process to be checkpointed:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    void log(String fmt, Object... args) {\n+        if (verbose) {\n+            if (args.length == 0) {\n+                System.err.println(fmt);\n+            } else {\n+                System.err.printf(fmt, args);\n+            }\n+        }\n+    }\n+\n+    public void ensureContainerStarted() throws Exception {\n+        if (dockerImageName == null) {\n+            return;\n+        }\n+        if (CRIU_PATH == null) {\n+            fail(\"CRAC_CRIU_PATH is not set and cannot find criu executable in any of: \" + CRIU_CANDIDATES);\n+        }\n+        if (!containerStarted) {\n+            prepareContainer();\n+            List<String> cmd = prepareContainerCommand(dockerImageName, dockerOptions);\n+            log(\"Starting docker container:\\n\" + String.join(\" \", cmd));\n+            assertEquals(0, new ProcessBuilder().inheritIO().command(cmd).start().waitFor());\n+            containerSetup();\n+            containerStarted = true;\n+        }\n+    }\n+\n+    private void prepareContainer() throws Exception {\n+        if (runContainerDirectly && null != containerSetupCommand) {\n+            fail(\"runContainerDirectly and containerSetupCommand cannot be used together.\");\n+        }\n+        ensureContainerKilled();\n+        buildDockerImage();\n+        FileUtils.deleteFileTreeWithRetry(Path.of(\".\", \"jdk-docker\"));\n+        \/\/ Make sure we start with a clean image directory\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"volume\", \"rm\", \"cr\");\n+    }\n+\n+    private void containerSetup() throws Exception {\n+        if (null != containerSetupCommand && 0 < containerSetupCommand.size()) {\n+            List<String> cmd = new ArrayList<>();\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+            cmd.addAll(containerSetupCommand);\n+            log(\"Container set up:\\n\" + String.join(\" \", cmd));\n+            DockerTestUtils.execute(cmd).shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    private void buildDockerImage() throws Exception {\n+        String previousBaseImageName = null;\n+        String previousBaseImageVersion = null;\n+        try {\n+            previousBaseImageName = System.getProperty(DockerfileConfig.BASE_IMAGE_NAME);\n+            previousBaseImageVersion = System.getProperty(DockerfileConfig.BASE_IMAGE_VERSION);\n+            if (dockerImageBaseName != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_NAME, dockerImageBaseName);\n+            }\n+            if (dockerImageBaseVersion != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_VERSION, dockerImageBaseVersion);\n+            }\n+            DockerTestUtils.buildJdkDockerImage(dockerImageName, \"Dockerfile-is-ignored\", \"jdk-docker\");\n+        } finally {\n+            if (previousBaseImageName != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_NAME, previousBaseImageName);\n+            } else {\n+                System.clearProperty(DockerfileConfig.BASE_IMAGE_NAME);\n+            }\n+            if (previousBaseImageVersion != null) {\n+                System.setProperty(DockerfileConfig.BASE_IMAGE_VERSION, previousBaseImageVersion);\n+            } else {\n+                System.clearProperty(DockerfileConfig.BASE_IMAGE_VERSION);\n+            }\n+        }\n+    }\n+\n+    private List<String> prepareContainerCommandBase(String imageName, String[] options) {\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(Container.ENGINE_COMMAND);\n+        cmd.addAll(Arrays.asList(\"run\", \"--rm\"));\n+        if (!runContainerDirectly) {\n+            cmd.add(\"-d\");\n+            cmd.add(\"--init\"); \/\/ otherwise the checkpointed process would not be reaped (by sleep with PID 1)\n+        }\n+        if (containerUsePrivileged) {\n+            cmd.add(\"--privileged\"); \/\/ required to give CRIU sufficient permissions\n+        }\n+        int entryCounter = 0;\n+        for (var entry : Utils.TEST_CLASS_PATH.split(File.pathSeparator)) {\n+            cmd.addAll(Arrays.asList(\"--volume\", entry + \":\/cp\/\" + (entryCounter++)));\n+        }\n+        cmd.addAll(Arrays.asList(\"--volume\", \"cr:\/cr\"));\n+        cmd.addAll(Arrays.asList(\"--volume\", CRIU_PATH + \":\/criu\"));\n+        cmd.addAll(Arrays.asList(\"--env\", \"CRAC_CRIU_PATH=\/criu\"));\n+        cmd.addAll(Arrays.asList(\"--name\", CONTAINER_NAME));\n+        if (debug) {\n+            cmd.addAll(Arrays.asList(\"--publish\", \"5005:5005\"));\n+        }\n+        if (options != null) {\n+            cmd.addAll(Arrays.asList(options));\n+        }\n+        cmd.add(imageName);\n+        return cmd;\n+    }\n+\n+    private List<String> prepareContainerCommand(String imageName, String[] options) {\n+        List<String> cmd = prepareContainerCommandBase(imageName, options);\n+        cmd.addAll(Arrays.asList(\"sleep\", \"3600\"));\n+        return cmd;\n+    }\n+\n+    public void ensureContainerKilled() throws Exception {\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"kill\", CONTAINER_NAME).getExitValue();\n+        DockerTestUtils.removeDockerImage(dockerImageName);\n+    }\n+\n+    public void recreateContainer(String imageName, String... options) throws Exception {\n+        assertTrue(containerStarted);\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"kill\", CONTAINER_NAME).getExitValue();\n+        List<String> cmd = prepareContainerCommand(imageName, options);\n+        log(\"Recreating docker container:\\n\" + String.join(\" \", cmd));\n+        assertEquals(0, new ProcessBuilder().inheritIO().command(cmd).start().waitFor());\n+    }\n+\n+    public CracProcess doRestore(String... javaPrefix) throws Exception {\n+        return startRestore(javaPrefix).waitForSuccess();\n+    }\n+\n+    public CracProcess startRestore(String... javaPrefix) throws Exception {\n+         List<String> list = javaPrefix.length == 0 ? null : Arrays.asList(javaPrefix);\n+         return startRestore(list);\n+    }\n+\n+    public CracProcess startRestore(List<String> javaPrefix) throws Exception {\n+        ensureContainerStarted();\n+        List<String> cmd = prepareCommand(javaPrefix, true);\n+        cmd.add(\"-XX:CRaCRestoreFrom=\" + imageDir);\n+        log(\"Starting restored process:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    public CracProcess startPlain() throws IOException {\n+        List<String> cmd = new ArrayList<>();\n+        if (dockerImageName != null) {\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+        }\n+        cmd.add(JAVA);\n+        cmd.add(\"-ea\");\n+        cmd.add(\"-cp\");\n+        cmd.add(getClassPath());\n+        if (debug) {\n+            cmd.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=0.0.0.0:5005\");\n+        }\n+        cmd.add(main().getName());\n+        cmd.addAll(Arrays.asList(args()));\n+        log(\"Starting process without CRaC:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    private String getClassPath() {\n+        String classPath = classpathEntries.isEmpty() ? \"\" : String.join(File.pathSeparator, classpathEntries) + File.pathSeparator;\n+        if (dockerImageName == null) {\n+            classPath += Utils.TEST_CLASS_PATH;\n+        } else {\n+            int numEntries = Utils.TEST_CLASS_PATH.split(File.pathSeparator).length;\n+            for (int i = 0; i < numEntries; ++i) {\n+                classPath += \"\/cp\/\" + i + File.pathSeparator;\n+            }\n+        }\n+        return classPath;\n+    }\n+\n+    public CracProcess doPlain() throws IOException, InterruptedException {\n+        return startPlain().waitForSuccess();\n+    }\n+\n+    private List<String> prepareCommand(List<String> javaPrefix, boolean isRestore) {\n+        List<String> cmd = new ArrayList<>();\n+        if (javaPrefix != null) {\n+            cmd.addAll(javaPrefix);\n+        } else if (dockerImageName != null) {\n+            if (runContainerDirectly) {\n+                cmd = prepareContainerCommandBase(dockerImageName, dockerOptions);\n+            } else {\n+                cmd.add(Container.ENGINE_COMMAND);\n+                cmd.add(\"exec\");\n+                if (null != dockerCheckpointOptions) {\n+                    cmd.addAll(dockerCheckpointOptions);\n+                }\n+                cmd.add(CONTAINER_NAME);\n+            }\n+            cmd.add(DOCKER_JAVA);\n+        } else {\n+            cmd.add(JAVA);\n+        }\n+        cmd.add(\"-ea\");\n+        if (engine != null) {\n+            String engArgs = engineArgs == null || engineArgs.length == 0 ? \"\" :\n+                    \",\" + Arrays.stream(engineArgs)\n+                            .map(str -> str.replace(\",\", \"\\\\,\"))\n+                            .collect(Collectors.joining(\",\"));\n+            cmd.add(\"-XX:CREngine=\" + engine.engine + engArgs);\n+        }\n+        if (!isRestore) {\n+            cmd.add(\"-cp\");\n+            cmd.add(getClassPath());\n+            if (printResources) {\n+                cmd.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+                cmd.add(\"-XX:+CRPrintResourcesOnCheckpoint\");\n+            }\n+        }\n+        if (debug) {\n+            cmd.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=0.0.0.0:5005\");\n+            if (!isRestore) {\n+                cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n+                cmd.add(\"-XX:-CRDoThrowCheckpointException\");\n+            }\n+        }\n+        cmd.addAll(vmOptions);\n+        for (var entry : javaOptions.entrySet()) {\n+            cmd.add(\"-D\" + entry.getKey() + \"=\" + entry.getValue());\n+        }\n+        return cmd;\n+    }\n+\n+    public void doCheckpointAndRestore() throws Exception {\n+        doCheckpoint();\n+        doRestore();\n+    }\n+\n+    public void checkpointViaJcmd() throws Exception {\n+        List<String> cmd = new ArrayList<>();\n+        if (dockerImageName != null) {\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME, \"\/jdk\/bin\/jcmd\"));\n+        } else {\n+            cmd.add(Utils.TEST_JDK + \"\/bin\/jcmd\");\n+        }\n+        cmd.addAll(Arrays.asList(main().getName(), \"JDK.checkpoint\"));\n+        \/\/ This works for non-docker commands, too\n+        DockerTestUtils.execute(cmd).shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":484,"deletions":0,"binary":false,"changes":484,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+package jdk.test.lib.crac;\n+\n+public enum CracEngine {\n+    CRIU(\"criuengine\"),\n+    PAUSE(System.getProperty(\"os.name\").contains(\"Windows\") ? \"pauseengine.exe\" : \"pauseengine\"),\n+    SIMULATE(System.getProperty(\"os.name\").contains(\"Windows\") ? \"simengine.exe\" : \"simengine\");\n+\n+    public final String engine;\n+\n+    CracEngine(String engine) {\n+        this.engine = engine;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracEngine.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.StreamPumper;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+public class CracProcess {\n+    private final CracBuilder builder;\n+    private final Process process;\n+\n+    public CracProcess(CracBuilder builder, List<String> cmd) throws IOException {\n+        this.builder = builder;\n+        ProcessBuilder pb = new ProcessBuilder().inheritIO();\n+        if (builder.captureOutput) {\n+            pb.redirectOutput(ProcessBuilder.Redirect.PIPE);\n+            pb.redirectError(ProcessBuilder.Redirect.PIPE);\n+        }\n+        pb.environment().putAll(builder.env);\n+        this.process = pb.command(cmd).start();\n+    }\n+\n+    public int waitFor() throws InterruptedException {\n+        return process.waitFor();\n+    }\n+\n+    public void waitForCheckpointed() throws InterruptedException {\n+        if (builder.engine == null || builder.engine == CracEngine.CRIU) {\n+            assertEquals(137, process.waitFor(), \"Checkpointed process was not killed as expected.\");\n+            \/\/ TODO: we could check that \"CR: Checkpoint\" was written out\n+        } else {\n+            fail(\"With engine \" + builder.engine.engine + \" use the async version.\");\n+        }\n+    }\n+\n+    public void waitForPausePid() throws IOException, InterruptedException {\n+        assertEquals(CracEngine.PAUSE, builder.engine, \"Pause PID file created only with pauseengine\");\n+\n+        \/\/ (at least on Windows) we need to wait to avoid os::prepare_checkpoint() interference with mkdir\/rmdir calls\n+        Thread.sleep(500);\n+\n+        try (WatchService watcher = FileSystems.getDefault().newWatchService()) {\n+            Path imageDir = builder.imageDir().toAbsolutePath();\n+            waitForFileCreated(watcher, imageDir.getParent(), path -> \"cr\".equals(path.toFile().getName()));\n+            waitForFileCreated(watcher, imageDir, path -> \"pid\".equals(path.toFile().getName()));\n+        }\n+    }\n+\n+    private void waitForFileCreated(WatchService watcher, Path dir, Predicate<Path> predicate) throws IOException, InterruptedException {\n+        WatchKey key = dir.register(watcher, StandardWatchEventKinds.ENTRY_CREATE);\n+        assertTrue(key.isValid());\n+        try {\n+            try (Stream<Path> dirContents = Files.list(dir)) {\n+                if (dirContents.anyMatch(predicate)) {\n+                    \/\/ file already present\n+                    return;\n+                }\n+            }\n+            int timeoutCounter = 10;\n+            for (; ; ) {\n+                WatchKey key2 = watcher.poll(1, TimeUnit.SECONDS);\n+                if (null == key2) {\n+                    if (!process.isAlive() && 0 < --timeoutCounter) {\n+                        \/\/ At least on macOS, it seems like WatchService's event may be delayed up to 10 secs,\n+                        \/\/ so we need to keep waiting some time for the event, even the process is completed.\n+                        continue;\n+                    }\n+                    assertTrue(process.isAlive(), \"Process should exist\");\n+                    continue;\n+                }\n+                for (WatchEvent<?> event : key2.pollEvents()) {\n+                    if (event.kind() != StandardWatchEventKinds.ENTRY_CREATE) {\n+                        continue;\n+                    }\n+                    if (predicate.test((Path) event.context())) {\n+                        return;\n+                    }\n+                }\n+                key2.reset();\n+            }\n+        } finally {\n+            key.cancel();\n+        }\n+    }\n+\n+    public CracProcess waitForSuccess() throws InterruptedException {\n+        int exitValue = process.waitFor();\n+        if (exitValue != 0 && builder.captureOutput) {\n+            try {\n+                OutputAnalyzer oa = outputAnalyzer();\n+                System.err.print(oa.getStderr());\n+                System.out.print(oa.getStdout());\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        assertEquals(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+        builder.log(\"Process %d completed with exit value %d%n\", process.pid(), exitValue);\n+        return this;\n+    }\n+\n+    public OutputAnalyzer outputAnalyzer() throws IOException {\n+        assertTrue(builder.captureOutput, \"Output must be captured with .captureOutput(true)\");\n+        return new OutputAnalyzer(process);\n+    }\n+\n+    public CracProcess watch(Consumer<String> outputConsumer, Consumer<String> errorConsumer) {\n+        assertTrue(builder.captureOutput, \"Output must be captured with .captureOutput(true)\");\n+        pump(process.getInputStream(), outputConsumer);\n+        pump(process.getErrorStream(), errorConsumer);\n+        return this;\n+    }\n+\n+    private static void pump(InputStream stream, Consumer<String> consumer) {\n+        new StreamPumper(stream).addPump(new StreamPumper.LinePump() {\n+            @Override\n+            protected void processLine(String line) {\n+                consumer.accept(line);\n+            }\n+        }).process();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.crac.Core;\n+\n+import java.lang.reflect.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * CRaC tests usually consists of two parts; the test started by JTreg through the 'run' tag\n+ * and subprocesses started by the test with various VM options. These are represented by the\n+ * {@link #test()} and {@link #exec()} methods.\n+ * CracTest use '@run driver jdk.test.crac.lib.CracTest' as the executable command; the main\n+ * method in this class discovers the executed class from system properties passed by JTReg,\n+ * instantiates the test (public no-arg constructor is needed), populates fields annotated\n+ * with {@link CracTestArg} and executes the {@link #test()} method.\n+ * The test method is expected to use {@link CracBuilder} to start another process. By default,\n+ * CracBuilder invokes the test with arguments that will again instantiate and fill the instance\n+ * and invoke the {@link #exec()} method.\n+ *\/\n+public interface CracTest {\n+\n+    String RESTORED_MESSAGE = \"Restored\";\n+\n+    \/**\n+     * This method is called when JTReg invokes the test; it is supposed to start\n+     * another process (most often using CRaC VM options) and validate its behaviour.\n+     *\n+     * @throws Exception\n+     *\/\n+    void test() throws Exception;\n+\n+    \/**\n+     * This method is invoked in the subprocess; this is where you're likely to call\n+     * {@link Core#checkpointRestore()}.\n+     *\n+     * @throws Exception\n+     *\/\n+    void exec() throws Exception;\n+\n+    class ArgsHolder {\n+        private static final String RUN_TEST = \"__run_test__\";\n+        private static Class<? extends CracTest> testClass;\n+        private static String[] args;\n+        \/\/ This field is present as workaround for @build <test> somehow missing\n+        \/\/ the annotation when\n+        private static final Class<CracTestArg> dummyField = CracTestArg.class;\n+    }\n+\n+    \/**\n+     * Main method for orchestrating the test. This should be called directly by JTReg.\n+     *\/\n+    static void main(String[] args) throws Exception {\n+        String testClassName;\n+        if (args.length == 0 || !ArgsHolder.RUN_TEST.equals(args[0])) {\n+            \/\/ We will look up the class name (and package) to avoid boilerplate in any @run invocation\n+            String testFile = System.getProperty(\"test.file\");\n+            String source = Files.readString(Path.of(testFile)).replace('\\n', ' ');\n+            Matcher clsMatcher = Pattern.compile(\"class\\\\s+(\\\\S+)\\\\s+(extends\\\\s+\\\\S+\\\\s+)?implements\\\\s+(\\\\S+\\\\s*,\\\\s*)*CracTest\").matcher(source);\n+            if (!clsMatcher.find()) {\n+                fail(\"Cannot find test class in \" + testFile + \", does it look like class <test> implements CracTest?\");\n+            }\n+            testClassName = clsMatcher.group(1);\n+            Matcher pkgMatcher = Pattern.compile(\"package\\\\s+([^;]+);\").matcher(source);\n+            if (pkgMatcher.find()) {\n+                testClassName = pkgMatcher.group(1) + \".\" + testClassName;\n+            }\n+        } else {\n+            testClassName = args[1];\n+        }\n+\n+        \/\/ When we use CracTest as driver the file with test is not compiled without a @build tag.\n+        \/\/ We could compile the class here and load it from a new classloader but since the test library\n+        \/\/ is not compiled completely we could be missing some dependencies - this would be just too fragile.\n+        Class<?> testClass;\n+        try {\n+            testClass = Class.forName(testClassName);\n+        } catch (ClassNotFoundException e) {\n+            throw new ClassNotFoundException(\"Test class \" + testClassName + \" not found, add jtreg tag @build \" + testClassName, e);\n+        }\n+        if (CracTest.class.isAssignableFrom(testClass)) {\n+            \/\/noinspection unchecked\n+            run((Class<? extends CracTest>) testClass, args);\n+        } else {\n+            throw new IllegalArgumentException(\"Class \" + testClass.getName() + \" does not implement CracTest!\");\n+        }\n+    }\n+\n+    \/**\n+     * This method should be invoked from the public static void main(String[]) method.\n+     *\n+     * @param testClass Class implementing the test.\n+     * @param args Arguments received in the main method.\n+     * @throws Exception\n+     *\/\n+    static void run(Class<? extends CracTest> testClass, String[] args) throws Exception {\n+        assertNotNull(args);\n+        ArgsHolder.testClass = testClass;\n+        int argsOffset = 0;\n+        if (args.length == 0 || !args[0].equals(ArgsHolder.RUN_TEST)) {\n+            String[] newArgs = new String[args.length + 2];\n+            newArgs[0] = ArgsHolder.RUN_TEST;\n+            newArgs[1] = testClass.getName();\n+            System.arraycopy(args, 0, newArgs, 2, args.length);\n+            ArgsHolder.args = newArgs;\n+        } else {\n+            argsOffset = 2;\n+        }\n+\n+        try {\n+            Constructor<? extends CracTest> ctor = testClass.getConstructor();\n+            CracTest testInstance = ctor.newInstance();\n+            Field[] argFields = getArgFields(testClass);\n+            for (int index = 0; index < argFields.length; index++) {\n+                Field f = argFields[index];\n+                assertFalse(Modifier.isFinal(f.getModifiers()), \"@CracTestArg fields must not be final!\");\n+                Class<?> t = f.getType();\n+                if (index + argsOffset >= args.length) {\n+                    if (f.getAnnotation(CracTestArg.class).optional()) {\n+                        break;\n+                    } else {\n+                        fail(\"Not enough args for field \" + f.getName() + \"(\" + index + \"): have \" + (args.length - argsOffset));\n+                    }\n+                }\n+                String arg = args[index + argsOffset];\n+                Object value = arg;\n+                if (t == boolean.class || t == Boolean.class) {\n+                    assertTrue(\"true\".equals(arg) || \"false\".equals(arg), \"Argument \" + index + \"Boolean arg should be either 'true' or 'false', was: \" + arg);\n+                    value = Boolean.parseBoolean(arg);\n+                } else if (t == int.class || t == Integer.class) {\n+                    try {\n+                        value = Integer.parseInt(arg);\n+                    } catch (NumberFormatException e) {\n+                        fail(\"Cannot parse argument '\" + arg + \"' as integer for @CracTestArg(\" + index + \") \" + f.getName());\n+                    }\n+                } else if (t == long.class || t == Long.class) {\n+                    try {\n+                        value = Long.parseLong(arg);\n+                    } catch (NumberFormatException e) {\n+                        fail(\"Cannot parse argument '\" + arg + \"' as long for @CracTestArg(\" + index + \") \" + f.getName());\n+                    }\n+                } else if (t.isEnum()) {\n+                    value = Enum.valueOf((Class<Enum>) t, arg);\n+                }\n+                f.setAccessible(true);\n+                f.set(testInstance, value);\n+            }\n+            if (argsOffset == 0) {\n+                testInstance.test();\n+            } else {\n+                testInstance.exec();\n+            }\n+        } catch (NoSuchMethodException e) {\n+            fail(\"Test class \" + testClass.getName() + \" is expected to have a public no-arg constructor\");\n+        }\n+    }\n+\n+    private static Field[] getArgFields(Class<? extends CracTest> testClass) {\n+        \/\/ TODO: check superclasses\n+        Field[] sortedFields = Stream.of(testClass.getDeclaredFields()).filter(f -> f.isAnnotationPresent(CracTestArg.class))\n+                .sorted(Comparator.comparingInt(f -> f.getAnnotation(CracTestArg.class).value()))\n+                .toArray(Field[]::new);\n+        if (sortedFields.length == 0) {\n+            return sortedFields;\n+        }\n+        int firstOptional = -1;\n+        for (int i = 0; i < sortedFields.length; ++i) {\n+            CracTestArg annotation = sortedFields[i].getAnnotation(CracTestArg.class);\n+            int index = annotation.value();\n+            assertGreaterThanOrEqual(index, 0);\n+            if (i == 0) {\n+                assertEquals(0, index, \"@CracTestArg numbers should start with 0\");\n+            }\n+            if (index < i) {\n+                fail(\"Duplicate @CracTestArg(\" + index + \"): both fields \" + sortedFields[i - 1].getName() + \" and \" + sortedFields[i].getName());\n+            } else if (index > i) {\n+                fail(\"Gap in @CracTestArg indices: missing \" + i + \", next is \" + index);\n+            }\n+            if (annotation.optional()) {\n+                firstOptional = index;\n+            } else if (firstOptional >= 0) {\n+                fail(\"Argument \" + firstOptional + \" is optional; all subsequent arguments must be optional, too.\");\n+            }\n+        }\n+        return sortedFields;\n+    }\n+\n+    \/**\n+     * Used as argument for {@link CracBuilder#args(String...)}.\n+     *\/\n+    static String[] args(String... extraArgs) {\n+        assertNotNull(ArgsHolder.args, \"Args are null; are you trying to access them from test method?\");\n+        if (extraArgs == null || extraArgs.length == 0) {\n+            return ArgsHolder.args;\n+        } else {\n+            return Stream.concat(Stream.of(ArgsHolder.args), Stream.of(extraArgs)).toArray(String[]::new);\n+        }\n+    }\n+\n+    static Class<? extends CracTest> testClass() {\n+        return ArgsHolder.testClass;\n+    }\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+package jdk.test.lib.crac;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Used to mark fields in {@link CracTest} that should be populated from main method arguments.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+public @interface CracTestArg {\n+    \/**\n+     * @return The (zero-based) index of the argument used as source of the data.\n+     *\/\n+    int value() default 0;\n+\n+    \/**\n+     * @return Can this argument be omitted?\n+     *\/\n+    boolean optional() default false;\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTestArg.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"}]}