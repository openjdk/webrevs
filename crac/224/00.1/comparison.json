{"files":[{"patch":"@@ -90,0 +90,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -130,0 +132,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -45,4 +48,0 @@\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(sockaddr_un::sun_path)\n-#endif\n-\n@@ -65,93 +64,0 @@\n-\/\/ forward reference\n-class PosixAttachOperation;\n-\n-class PosixAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n- public:\n-  static void set_path(char* path) {\n-    if (path == nullptr) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  static PosixAttachOperation* dequeue();\n-};\n-\n-class SocketChannel : public AttachOperation::RequestReader, public AttachOperation::ReplyWriter {\n-private:\n-  int _socket;\n-public:\n-  SocketChannel(int socket) : _socket(socket) {}\n-  ~SocketChannel() {\n-    close();\n-  }\n-\n-  bool opened() const {\n-    return _socket != -1;\n-  }\n-\n-  void close() {\n-    if (opened()) {\n-      ::close(_socket);\n-      _socket = -1;\n-    }\n-  }\n-\n-  \/\/ RequestReader\n-  int read(void* buffer, int size) override {\n-    ssize_t n;\n-    RESTARTABLE(::read(_socket, buffer, (size_t)size), n);\n-    return checked_cast<int>(n);\n-  }\n-\n-  \/\/ ReplyWriter\n-  int write(const void* buffer, int size) override {\n-    ssize_t n;\n-    RESTARTABLE(::write(_socket, buffer, size), n);\n-    return checked_cast<int>(n);\n-  }\n-  \/\/ called after writing all data\n-  void flush() override {\n-    ::shutdown(_socket, SHUT_RDWR);\n-  }\n-};\n-\n-class PosixAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  SocketChannel _socket_channel;\n-\n- public:\n-  void complete(jint res, bufferedStream* st) override;\n-\n-  PosixAttachOperation(int socket) : AttachOperation(), _socket_channel(socket) {\n-  }\n-\n-  bool read_request() {\n-    return AttachOperation::read_request(&_socket_channel, &_socket_channel);\n-  }\n-};\n-\n@@ -163,0 +69,1 @@\n+PosixAttachOperation* PosixAttachListener::_current_op = nullptr;\n@@ -308,0 +215,1 @@\n+      _current_op = op;\n@@ -313,0 +221,12 @@\n+\/\/ An operation completion is splitted into two parts.\n+\/\/ For proper handling the jcmd connection at CRaC checkpoint action.\n+\/\/ An effectively_complete_raw is called in checkpoint processing, before criu engine calls, for properly closing the socket.\n+\/\/ The complete() gets called after restore for proper deletion the leftover object.\n+\n+void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n+  PosixAttachOperation::effectively_complete_raw(result, st);\n+  \/\/ reset the current op as late as possible, this happens on attach listener thread.\n+  PosixAttachListener::reset_current_op();\n+  delete this;\n+}\n+\n@@ -321,3 +241,6 @@\n-void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n+void PosixAttachOperation::effectively_complete_raw(jint result, bufferedStream* st) {\n+\n+  if (_effectively_completed) {\n+    assert(st->size() == 0, \"no lost output\");\n+    return;\n+  }\n@@ -325,0 +248,12 @@\n+  \/\/ write operation result\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    ThreadBlockInVM tbivm(JavaThread::cast(thread));\n+    write_operation_result(result, st);\n+  } else {\n+    write_operation_result(result, st);\n+  }\n+  _effectively_completed = true;\n+}\n+\n+void PosixAttachOperation::write_operation_result(jint result, bufferedStream* st) {\n@@ -327,1 +262,2 @@\n-  delete this;\n+  _socket_channel.close();\n+  st->reset();\n@@ -330,0 +266,16 @@\n+static void assert_listener_thread() {\n+#ifdef ASSERT\n+  ResourceMark rm; \/\/ For retrieving the thread names\n+  assert(strcmp(\"Attach Listener\", Thread::current()->name()) == 0, \"should gets called from Attach Listener thread\");\n+#endif\n+}\n+\n+PosixAttachOperation* PosixAttachListener::get_current_op() {\n+  assert_listener_thread();\n+  return PosixAttachListener::_current_op;\n+}\n+\n+void PosixAttachListener::reset_current_op() {\n+  assert_listener_thread();\n+  PosixAttachListener::_current_op = NULL;\n+}\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":53,"deletions":101,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_ATTACHLISTENER_POSIX_HPP\n+#define OS_POSIX_ATTACHLISTENER_POSIX_HPP\n+\n+class PosixAttachListener;\n+\n+#if INCLUDE_SERVICES\n+\n+#include \"posixAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+\n+#include <sys\/un.h>\n+\n+#ifndef UNIX_PATH_MAX\n+#define UNIX_PATH_MAX   sizeof(sockaddr_un::sun_path)\n+#endif\n+\n+class PosixAttachListener: AllStatic {\n+ private:\n+  \/\/ the path to which we bind the UNIX domain socket\n+  static char _path[UNIX_PATH_MAX];\n+  static bool _has_path;\n+\n+  \/\/ the file descriptor for the listening socket\n+  static volatile int _listener;\n+\n+  static bool _atexit_registered;\n+\n+  \/\/ this is for proper reporting JDK.Chekpoint processing to jcmd peer\n+  static PosixAttachOperation* _current_op;\n+\n+ public:\n+  static void set_path(char* path) {\n+    if (path == nullptr) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n+  \/\/ initialize the listener, returns 0 if okay\n+  static int init();\n+\n+  static char* path()                   { return _path; }\n+  static bool has_path()                { return _has_path; }\n+  static int listener()                 { return _listener; }\n+\n+  static PosixAttachOperation* dequeue();\n+  static PosixAttachOperation* get_current_op();\n+  static void reset_current_op();\n+\n+};\n+\n+#endif \/\/ INCLUDE_SERVICES\n+\n+#endif \/\/ OS_POSIX_ATTACHLISTENER_POSIX_HPP\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.hpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -34,0 +35,1 @@\n+\/\/#include \"os_linux.inline.hpp\"\n@@ -44,0 +46,4 @@\n+#ifdef LINUX\n+#include \"perfMemory_linux.hpp\"\n+#endif \/\/LINUX\n+\n@@ -1342,0 +1348,83 @@\n+\n+#ifdef LINUX\n+bool PerfMemoryLinux::checkpoint() {\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  void *anon = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (anon == MAP_FAILED) {\n+    tty->print_cr(\"Cannot allocate new memory for perfdata: %s\", os::strerror(errno));\n+    return false;\n+  }\n+  \/\/ Note: we might be losing updates that happen between this copy and mremap\n+  \/\/ TODO: consider acquiring PeriodicTask_lock around this\n+  memcpy(anon, PerfMemory::start(), PerfMemory::used());\n+  if (mremap(anon, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap perfdata memory as anonymous: %s\", os::strerror(errno));\n+    if (munmap(anon, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap unused private perfdata memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  remove_file(backing_store_file_name);\n+  \/\/ We cannot keep the filename because some C\/R engines might not preserve PID numbers\n+  \/\/ Also, username might change.\n+  FREE_C_HEAP_ARRAY(char, backing_store_file_name);\n+  backing_store_file_name = nullptr;\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::restore() {\n+  assert(backing_store_file_name == nullptr, \"Should be nil'ed on checkpoint\");\n+  \/\/ With -XX:-UsePerfData the capacity is zero\n+  if (PerfDisableSharedMem || PerfMemory::capacity() == 0) {\n+    return true;\n+  }\n+  int vmid = os::current_process_id();\n+  char* user_name = get_user_name(geteuid());\n+  if (!user_name) {\n+    return false;\n+  }\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  if (!make_user_tmp_dir(dirname)) {\n+    return false;\n+  }\n+  backing_store_file_name = get_sharedmem_filename(dirname, vmid, -1);\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"Cannot open shared perfdata file: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  if (::ftruncate(fd, PerfMemory::capacity())) {\n+    tty->print_cr(\"Cannot restore (ftruncate) perfdata file size: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  void* shared = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == shared) {\n+    tty->print_cr(\"cannot mmap shared perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+  ::close(fd);\n+\n+  \/\/ Here is another place where we might lose the update\n+  memcpy(shared, PerfMemory::start(), PerfMemory::used());\n+  if (::mremap(shared, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap shared perfdata: %s\", os::strerror(errno));\n+    if (munmap(shared, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap the shared memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  return true;\n+}\n+#endif \/\/LINUX\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_POSIX_POSIXATTACHOPERATION_HPP\n+#define OS_POSIX_POSIXATTACHOPERATION_HPP\n+\n+#include \"os_posix.hpp\"\n+#include \"services\/attachListener.hpp\"\n+\n+class PosixAttachOperation;\n+\n+#if INCLUDE_SERVICES\n+\n+class SocketChannel : public AttachOperation::RequestReader, public AttachOperation::ReplyWriter {\n+private:\n+  int _socket;\n+public:\n+  SocketChannel(int socket) : _socket(socket) {}\n+  ~SocketChannel() {\n+    close();\n+  }\n+\n+  int socket() const {\n+    return _socket;\n+  }\n+\n+  bool opened() const {\n+    return _socket != -1;\n+  }\n+\n+  void close() {\n+    if (opened()) {\n+      ::close(_socket);\n+      _socket = -1;\n+    }\n+  }\n+\n+  \/\/ RequestReader\n+  int read(void* buffer, int size) override {\n+    ssize_t n;\n+    RESTARTABLE(::read(_socket, buffer, (size_t)size), n);\n+    return checked_cast<int>(n);\n+  }\n+\n+  \/\/ ReplyWriter\n+  int write(const void* buffer, int size) override {\n+    ssize_t n;\n+    RESTARTABLE(::write(_socket, buffer, size), n);\n+    return checked_cast<int>(n);\n+  }\n+  \/\/ called after writing all data\n+  void flush() override {\n+    ::shutdown(_socket, SHUT_RDWR);\n+  }\n+};\n+\n+class PosixAttachOperation: public AttachOperation {\n+ private:\n+  \/\/ the connection to the client\n+  SocketChannel _socket_channel;\n+  bool _effectively_completed;\n+  void write_operation_result(jint result, bufferedStream* st);\n+\n+ public:\n+  void complete(jint res, bufferedStream* st) override;\n+  void effectively_complete_raw(jint res, bufferedStream* st);\n+  bool is_effectively_completed()                      { return _effectively_completed; }\n+\n+  int socket() {\n+    return _socket_channel.socket();;\n+  }\n+\n+  PosixAttachOperation(int socket) : AttachOperation(), _socket_channel(socket) {\n+    _effectively_completed = false;\n+  }\n+\n+  bool read_request() {\n+    return AttachOperation::read_request(&_socket_channel, &_socket_channel);\n+  }\n+};\n+\n+#endif \/\/ INCLUDE_SERVICES\n+\n+#endif \/\/ OS_POSIX_POSIXATTACHOPERATION_HPP\n","filename":"src\/hotspot\/os\/posix\/posixAttachOperation.hpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -824,0 +824,20 @@\n+GrowableArray<int> ClassLoader::get_classpath_entry_fds() {\n+  GrowableArray<int> fds;\n+  assert(Thread::current()->is_VM_thread(), \"should be called from VM op\");\n+  \/\/ we don't use mutexes here because it is called from VM op\n+  for (ClassPathEntry *entry = first_append_entry(); entry != nullptr; entry = entry->next()) {\n+    if (entry->is_jar_file()) {\n+      fds.append(((ClassPathZipEntry *) entry)->get_fd());\n+    }\n+  }\n+#if INCLUDE_CDS\n+  \/\/ Probably not needed as _app_classpath_entries is filled only when dumping CDS classes\n+  for (ClassPathEntry *entry = _app_classpath_entries; entry != nullptr; entry = entry->next()) {\n+    if (entry->is_jar_file()) {\n+      fds.append(((ClassPathZipEntry *) entry)->get_fd());\n+    }\n+  }\n+#endif \/\/ INCLUDE_CDS\n+  return fds;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  int get_fd() const { return ZipLibrary::get_fd(_zip); }\n@@ -421,0 +422,3 @@\n+  \/\/ returns list of file descriptors used for both boot and app classpath entries\n+  static GrowableArray<int> get_classpath_entry_fds();\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -986,0 +987,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1140,0 +1148,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -419,0 +420,6 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), (char*)eden()->end() - (char*)eden()->top());\n+    os::cleanup_memory((char*)from()->top(), (char*)from()->end() - (char*)from()->top());\n+    os::cleanup_memory((char*)to()->top(), (char*)to()->end() - (char*)to()->top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3726,0 +3727,5 @@\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2244,0 +2244,9 @@\n+void os::cleanup_memory(char* addr, size_t bytes) {\n+  char* start = (char*)align_up(addr, os::vm_page_size());\n+  char* end = (char*)align_down(addr + bytes, os::vm_page_size());\n+  if (start < end) {\n+    os::uncommit_memory(start, end - start);\n+    os::commit_memory(start, end - start, false);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -295,0 +295,2 @@\n+  \/\/ Before restore returns the same value as elapsed_counter()\n+  static jlong elapsed_counter_since_restore();\n@@ -486,0 +488,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n@@ -645,0 +649,2 @@\n+  static int execv(const char *path, const char *argv[]);\n+\n@@ -704,0 +710,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -707,0 +716,2 @@\n+  static bool           is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2481,0 +2481,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+#if INCLUDE_SERVICES && !defined(_WINDOWS)\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS)\n@@ -155,0 +159,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -1052,0 +1058,26 @@\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_crac_mirror_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::checkpointRestoreInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != NULL) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      outputStream* stream = output();\n+#if INCLUDE_SERVICES && !defined(_WINDOWS)\n+      assert(PosixAttachListener::get_current_op(), \"should exist\");\n+      if (PosixAttachListener::get_current_op()->is_effectively_completed()) {\n+        stream = tty;\n+      }\n+#endif \/\/ INCLUDE_SERVICES\n+      stream->print_cr(\"An exception during a checkpoint operation:\");\n+      stream->print(\"%s\", out);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -853,0 +853,14 @@\n+class CheckpointDCmd : public DCmd {\n+public:\n+  CheckpointDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"JDK.checkpoint\"; }\n+    static const char* description() {\n+      return \"Checkpoint via jdk.crac.checkpointRestore().\";\n+    }\n+    static const char* impact() {\n+      return \"High: JVM terminates\";\n+    }\n+    static int num_arguments() { return 0; }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.SharedSecrets;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-\n@@ -178,0 +177,5 @@\n+    exports jdk.internal.crac to\n+        java.rmi,\n+        jdk.jfr,\n+        jdk.management.agent,\n+        jdk.sctp;\n@@ -415,0 +419,8 @@\n+    exports jdk.internal.crac.mirror to\n+        java.rmi,\n+        jdk.crac,\n+        jdk.jfr,\n+        jdk.management.agent;\n+\n+    exports jdk.internal.crac.mirror.impl to\n+        jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -114,0 +114,2 @@\n+# JDK-8310862 was closed but we're still seeing errors with the updated test\n+runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8310862 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -516,0 +516,6 @@\n+# jdk_crac\n+\n+jdk\/crac\/LinkedCleanableRefTest.java                            8353064 generic-all\n+\n+############################################################################\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    @SuppressWarnings(\"this-escape\")\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerRunOptions.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}