{"files":[{"patch":"@@ -38,2 +38,1 @@\n-#define VM_TYPES_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type) \\\n-  declare_toplevel_type(VM_Version)\n+#define VM_TYPES_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type)\n","filename":"src\/hotspot\/cpu\/aarch64\/vmStructs_aarch64.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,3 +197,0 @@\n-  \/\/ No _features_names[] available on this CPU.\n-  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,3 +134,0 @@\n-  \/\/ No _features_names[] available on this CPU.\n-  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -592,3 +592,0 @@\n-  \/\/ No _features_names[] available on this CPU.\n-  static void insert_features_names(char* buf, size_t buflen, unsigned long features[] = _features) {}\n-\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,2 +32,5 @@\n-#define VM_STRUCTS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field)            \\\n-  volatile_nonstatic_field(JavaFrameAnchor, _last_Java_fp, intptr_t*)\n+#define VM_STRUCTS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field) \\\n+  volatile_nonstatic_field(JavaFrameAnchor,         _last_Java_fp,                  intptr_t*)               \\\n+              static_field(VM_Version,              _features,                      VM_Version::VM_Features) \\\n+           nonstatic_field(VM_Version::VM_Features, _features_bitmap[0],            uint64_t)                \\\n+              static_field(VM_Version::VM_Features, _features_bitmap_size,          int)\n@@ -36,0 +39,1 @@\n+  declare_toplevel_type(VM_Version::VM_Features)\n@@ -38,3 +42,4 @@\n-  LP64_ONLY(declare_constant(frame::arg_reg_save_area_bytes))       \\\n-  declare_constant(frame::interpreter_frame_sender_sp_offset)       \\\n-  declare_constant(frame::interpreter_frame_last_sp_offset)\n+  declare_constant(frame::arg_reg_save_area_bytes)            \\\n+  declare_constant(frame::interpreter_frame_sender_sp_offset) \\\n+  declare_constant(frame::interpreter_frame_last_sp_offset)   \\\n+  declare_constant(frame::entry_frame_call_wrapper_offset)\n","filename":"src\/hotspot\/cpu\/x86\/vmStructs_x86.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -60,0 +62,1 @@\n+#endif\n@@ -63,0 +66,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -64,0 +69,1 @@\n+#endif\n@@ -78,0 +84,5 @@\n+int VM_Version::VM_Features::_features_bitmap_size = sizeof(VM_Version::VM_Features::_features_bitmap) \/ BytesPerLong;\n+\n+VM_Version::VM_Features VM_Version::_features;\n+VM_Version::VM_Features VM_Version::_cpu_features;\n+\n@@ -100,1 +111,1 @@\n-  if ((_features & CPU_FLUSH) != 0) {\n+  if (_features.supports_feature(CPU_FLUSH)) {\n@@ -106,1 +117,1 @@\n-  vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: \" UINT64_FORMAT_X, CPU_FLUSH));\n+  vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: 0x%llx\", 1ULL << CPU_FLUSH));\n@@ -157,1 +168,1 @@\n-    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4;\n+    Label detect_486, cpu486, detect_586, std_cpuid1, std_cpuid4, std_cpuid24;\n@@ -356,0 +367,11 @@\n+    \/\/\n+    \/\/ cpuid(0x24) Converged Vector ISA Main Leaf (EAX = 24H, ECX = 0).\n+    \/\/\n+    __ bind(std_cpuid24);\n+    __ movl(rax, 0x24);\n+    __ movl(rcx, 0);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::std_cpuid24_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ movl(Address(rsi, 4), rbx);\n+\n@@ -442,2 +464,1 @@\n-    __ cmpl(rax, 0x200000);\n-    __ jcc(Assembler::notEqual, vector_save_restore);\n+    __ jcc(Assembler::equal, vector_save_restore);\n@@ -447,2 +468,1 @@\n-    __ cmpl(rax, 0x80000);\n-    __ jcc(Assembler::notEqual, vector_save_restore);\n+    __ jcc(Assembler::equal, vector_save_restore);\n@@ -501,0 +521,1 @@\n+      \/\/ OR check _cpuid_info.sefsl1_cpuid7_edx.bits.avx10\n@@ -503,3 +524,6 @@\n-      __ andl(rax, Address(rsi, 4)); \/\/ xcr0 bits sse | ymm\n-      __ cmpl(rax, 0x10000);\n-      __ jccb(Assembler::notEqual, legacy_setup); \/\/ jump if EVEX is not supported\n+      __ andl(rax, Address(rsi, 4));\n+      __ lea(rsi, Address(rbp, in_bytes(VM_Version::sefsl1_cpuid7_offset())));\n+      __ movl(rbx, 0x80000);\n+      __ andl(rbx, Address(rsi, 4));\n+      __ orl(rax, rbx);\n+      __ jccb(Assembler::equal, legacy_setup); \/\/ jump if EVEX is not supported\n@@ -586,2 +610,1 @@\n-      __ cmpl(rax, 0x10000);\n-      __ jcc(Assembler::notEqual, legacy_save_restore);\n+      __ jcc(Assembler::equal, legacy_save_restore);\n@@ -854,0 +877,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1263,0 +1288,1 @@\n+#endif\n@@ -1268,0 +1294,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1270,0 +1298,5 @@\n+FIXME:CPUFeatures2\n+  _features = 0;\n+FIXME:CPUFeatures3\n+#endif\n+\/\/FIXME:CPUFeatures4\n@@ -1285,0 +1318,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1287,0 +1322,6 @@\n+FIXME:CPUFeatures2\n+    _cpu_features = _features;   \/\/ Preserve features\n+FIXME:CPUFeatures3\n+#endif\n+    _cpu_features = _features; \/\/ Preserve features\n+\/\/FIXME:CPUFeatures4\n@@ -1300,0 +1341,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1301,0 +1344,1 @@\n+#endif\n@@ -1308,1 +1352,1 @@\n-      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, CPU_SSE2, (uint64_t)0));\n+      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: 0x%llx\", 1ULL << CPU_SSE2));\n@@ -1343,2 +1387,2 @@\n-    _features &= ~CPU_SSE4_1;\n-    _features &= ~CPU_SSE4_2;\n+    _features.clear_feature(CPU_SSE4_1);\n+    _features.clear_feature(CPU_SSE4_2);\n@@ -1348,3 +1392,3 @@\n-    _features &= ~CPU_SSE3;\n-    _features &= ~CPU_SSSE3;\n-    _features &= ~CPU_SSE4A;\n+    _features.clear_feature(CPU_SSE3);\n+    _features.clear_feature(CPU_SSSE3);\n+    _features.clear_feature(CPU_SSE4A);\n@@ -1354,1 +1398,1 @@\n-    _features &= ~CPU_SSE2;\n+    _features.clear_feature(CPU_SSE2);\n@@ -1357,1 +1401,1 @@\n-    _features &= ~CPU_SSE;\n+    _features.clear_feature(CPU_SSE);\n@@ -1423,15 +1467,19 @@\n-    _features &= ~CPU_AVX512F;\n-    _features &= ~CPU_AVX512DQ;\n-    _features &= ~CPU_AVX512CD;\n-    _features &= ~CPU_AVX512BW;\n-    _features &= ~CPU_AVX512VL;\n-    _features &= ~CPU_AVX512_VPOPCNTDQ;\n-    _features &= ~CPU_AVX512_VPCLMULQDQ;\n-    _features &= ~CPU_AVX512_VAES;\n-    _features &= ~CPU_AVX512_VNNI;\n-    _features &= ~CPU_AVX512_VBMI;\n-    _features &= ~CPU_AVX512_VBMI2;\n-    _features &= ~CPU_AVX512_BITALG;\n-    _features &= ~CPU_AVX512_IFMA;\n-    _features &= ~CPU_APX_F;\n-    _features &= ~CPU_AVX512_FP16;\n+    _features.clear_feature(CPU_AVX512F);\n+    _features.clear_feature(CPU_AVX512DQ);\n+    _features.clear_feature(CPU_AVX512CD);\n+    _features.clear_feature(CPU_AVX512BW);\n+    _features.clear_feature(CPU_AVX512ER);\n+    _features.clear_feature(CPU_AVX512PF);\n+    _features.clear_feature(CPU_AVX512VL);\n+    _features.clear_feature(CPU_AVX512_VPOPCNTDQ);\n+    _features.clear_feature(CPU_AVX512_VPCLMULQDQ);\n+    _features.clear_feature(CPU_AVX512_VAES);\n+    _features.clear_feature(CPU_AVX512_VNNI);\n+    _features.clear_feature(CPU_AVX512_VBMI);\n+    _features.clear_feature(CPU_AVX512_VBMI2);\n+    _features.clear_feature(CPU_AVX512_BITALG);\n+    _features.clear_feature(CPU_AVX512_IFMA);\n+    _features.clear_feature(CPU_APX_F);\n+    _features.clear_feature(CPU_AVX512_FP16);\n+    _features.clear_feature(CPU_AVX10_1);\n+    _features.clear_feature(CPU_AVX10_2);\n@@ -1450,1 +1498,1 @@\n-    _features &= ~CPU_APX_F;\n+    _features.clear_feature(CPU_APX_F);\n@@ -1454,2 +1502,2 @@\n-    _features &= ~CPU_AVX2;\n-    _features &= ~CPU_AVX_IFMA;\n+    _features.clear_feature(CPU_AVX2);\n+    _features.clear_feature(CPU_AVX_IFMA);\n@@ -1459,4 +1507,4 @@\n-    _features &= ~CPU_AVX;\n-    _features &= ~CPU_VZEROUPPER;\n-    _features &= ~CPU_F16C;\n-    _features &= ~CPU_SHA512;\n+    _features.clear_feature(CPU_AVX);\n+    _features.clear_feature(CPU_VZEROUPPER);\n+    _features.clear_feature(CPU_F16C);\n+    _features.clear_feature(CPU_SHA512);\n@@ -1467,1 +1515,1 @@\n-    _features &= ~CPU_HT;\n+    _features.clear_feature(CPU_HT);\n@@ -1472,17 +1520,19 @@\n-      _features &= ~CPU_VZEROUPPER;\n-      _features &= ~CPU_AVX512BW;\n-      _features &= ~CPU_AVX512VL;\n-      _features &= ~CPU_AVX512DQ;\n-      _features &= ~CPU_AVX512_VNNI;\n-      _features &= ~CPU_AVX512_VAES;\n-      _features &= ~CPU_AVX512_VPOPCNTDQ;\n-      _features &= ~CPU_AVX512_VPCLMULQDQ;\n-      _features &= ~CPU_AVX512_VBMI;\n-      _features &= ~CPU_AVX512_VBMI2;\n-      _features &= ~CPU_CLWB;\n-      _features &= ~CPU_FLUSHOPT;\n-      _features &= ~CPU_GFNI;\n-      _features &= ~CPU_AVX512_BITALG;\n-      _features &= ~CPU_AVX512_IFMA;\n-      _features &= ~CPU_AVX_IFMA;\n-      _features &= ~CPU_AVX512_FP16;\n+      _features.clear_feature(CPU_VZEROUPPER);\n+      _features.clear_feature(CPU_AVX512BW);\n+      _features.clear_feature(CPU_AVX512VL);\n+      _features.clear_feature(CPU_AVX512DQ);\n+      _features.clear_feature(CPU_AVX512_VNNI);\n+      _features.clear_feature(CPU_AVX512_VAES);\n+      _features.clear_feature(CPU_AVX512_VPOPCNTDQ);\n+      _features.clear_feature(CPU_AVX512_VPCLMULQDQ);\n+      _features.clear_feature(CPU_AVX512_VBMI);\n+      _features.clear_feature(CPU_AVX512_VBMI2);\n+      _features.clear_feature(CPU_CLWB);\n+      _features.clear_feature(CPU_FLUSHOPT);\n+      _features.clear_feature(CPU_GFNI);\n+      _features.clear_feature(CPU_AVX512_BITALG);\n+      _features.clear_feature(CPU_AVX512_IFMA);\n+      _features.clear_feature(CPU_AVX_IFMA);\n+      _features.clear_feature(CPU_AVX512_FP16);\n+      _features.clear_feature(CPU_AVX10_1);\n+      _features.clear_feature(CPU_AVX10_2);\n@@ -1498,1 +1548,0 @@\n-  assert(supports_cpuid(), \"Always present\");\n@@ -1522,2 +1571,2 @@\n-  char buf[1024];\n-  int cpu_info_size = jio_snprintf(\n+  char buf[2048];\n+  size_t cpu_info_size = jio_snprintf(\n@@ -1530,0 +1579,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -1531,0 +1582,7 @@\n+FIXME:CPUFeatures2\n+  insert_features_names(buf + cpu_info_size, sizeof(buf) - cpu_info_size, _features_names);\n+FIXME:CPUFeatures3\n+#endif\n+\n+  insert_features_names(_features, buf + cpu_info_size, sizeof(buf) - cpu_info_size);\n+\/\/FIXME:CPUFeatures4\n@@ -2503,0 +2561,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2507,0 +2567,1 @@\n+#endif\n@@ -2516,0 +2577,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2518,0 +2581,1 @@\n+#endif\n@@ -2522,0 +2586,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2569,0 +2635,1 @@\n+#endif\n@@ -2605,0 +2672,1 @@\n+\n@@ -2620,0 +2688,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2622,0 +2692,1 @@\n+#endif\n@@ -2624,0 +2695,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -2658,0 +2731,1 @@\n+#endif\n@@ -3421,2 +3495,2 @@\n-uint64_t VM_Version::CpuidInfo::feature_flags() const {\n-  uint64_t result = 0;\n+VM_Version::VM_Features VM_Version::CpuidInfo::feature_flags() const {\n+  VM_Features vm_features;\n@@ -3424,1 +3498,1 @@\n-    result |= CPU_CX8;\n+    vm_features.set_feature(CPU_CX8);\n@@ -3426,1 +3500,1 @@\n-    result |= CPU_CMOV;\n+    vm_features.set_feature(CPU_CMOV);\n@@ -3428,1 +3502,1 @@\n-    result |= CPU_FLUSH;\n+    vm_features.set_feature(CPU_FLUSH);\n@@ -3432,1 +3506,1 @@\n-  assert ((result & CPU_FLUSH) != 0, \"clflush should be available\");\n+  assert (vm_features.supports_feature(CPU_FLUSH), \"clflush should be available\");\n@@ -3435,1 +3509,1 @@\n-    result |= CPU_FXSR;\n+    vm_features.set_feature(CPU_FXSR);\n@@ -3438,1 +3512,1 @@\n-    result |= CPU_HT;\n+    vm_features.set_feature(CPU_HT);\n@@ -3441,1 +3515,1 @@\n-    result |= CPU_MMX;\n+    vm_features.set_feature(CPU_MMX);\n@@ -3443,1 +3517,1 @@\n-    result |= CPU_SSE;\n+    vm_features.set_feature(CPU_SSE);\n@@ -3445,1 +3519,1 @@\n-    result |= CPU_SSE2;\n+    vm_features.set_feature(CPU_SSE2);\n@@ -3447,1 +3521,1 @@\n-    result |= CPU_SSE3;\n+    vm_features.set_feature(CPU_SSE3);\n@@ -3449,1 +3523,1 @@\n-    result |= CPU_SSSE3;\n+    vm_features.set_feature(CPU_SSSE3);\n@@ -3451,1 +3525,1 @@\n-    result |= CPU_SSE4_1;\n+    vm_features.set_feature(CPU_SSE4_1);\n@@ -3453,1 +3527,1 @@\n-    result |= CPU_SSE4_2;\n+    vm_features.set_feature(CPU_SSE4_2);\n@@ -3455,1 +3529,1 @@\n-    result |= CPU_POPCNT;\n+    vm_features.set_feature(CPU_POPCNT);\n@@ -3458,1 +3532,1 @@\n-    result |= CPU_APX_F;\n+    vm_features.set_feature(CPU_APX_F);\n@@ -3464,2 +3538,2 @@\n-    result |= CPU_AVX;\n-    result |= CPU_VZEROUPPER;\n+    vm_features.set_feature(CPU_AVX);\n+    vm_features.set_feature(CPU_VZEROUPPER);\n@@ -3467,1 +3541,1 @@\n-      result |= CPU_SHA512;\n+      vm_features.set_feature(CPU_SHA512);\n@@ -3469,1 +3543,1 @@\n-      result |= CPU_F16C;\n+      vm_features.set_feature(CPU_F16C);\n@@ -3471,1 +3545,1 @@\n-      result |= CPU_AVX2;\n+      vm_features.set_feature(CPU_AVX2);\n@@ -3473,1 +3547,1 @@\n-        result |= CPU_AVX_IFMA;\n+        vm_features.set_feature(CPU_AVX_IFMA);\n@@ -3476,1 +3550,1 @@\n-        result |= CPU_GFNI;\n+        vm_features.set_feature(CPU_GFNI);\n@@ -3481,1 +3555,1 @@\n-      result |= CPU_AVX512F;\n+      vm_features.set_feature(CPU_AVX512F);\n@@ -3483,1 +3557,1 @@\n-        result |= CPU_AVX512CD;\n+        vm_features.set_feature(CPU_AVX512CD);\n@@ -3485,1 +3559,1 @@\n-        result |= CPU_AVX512DQ;\n+        vm_features.set_feature(CPU_AVX512DQ);\n@@ -3487,1 +3561,1 @@\n-        result |= CPU_AVX512_IFMA;\n+        vm_features.set_feature(CPU_AVX512_IFMA);\n@@ -3489,1 +3563,1 @@\n-        result |= CPU_AVX512PF;\n+        vm_features.set_feature(CPU_AVX512PF);\n@@ -3491,1 +3565,1 @@\n-        result |= CPU_AVX512ER;\n+        vm_features.set_feature(CPU_AVX512ER);\n@@ -3493,1 +3567,1 @@\n-        result |= CPU_AVX512BW;\n+        vm_features.set_feature(CPU_AVX512BW);\n@@ -3495,1 +3569,1 @@\n-        result |= CPU_AVX512VL;\n+        vm_features.set_feature(CPU_AVX512VL);\n@@ -3497,1 +3571,1 @@\n-        result |= CPU_AVX512_VPOPCNTDQ;\n+        vm_features.set_feature(CPU_AVX512_VPOPCNTDQ);\n@@ -3499,1 +3573,1 @@\n-        result |= CPU_AVX512_VPCLMULQDQ;\n+        vm_features.set_feature(CPU_AVX512_VPCLMULQDQ);\n@@ -3501,1 +3575,1 @@\n-        result |= CPU_AVX512_VAES;\n+        vm_features.set_feature(CPU_AVX512_VAES);\n@@ -3503,1 +3577,1 @@\n-        result |= CPU_AVX512_VNNI;\n+        vm_features.set_feature(CPU_AVX512_VNNI);\n@@ -3505,1 +3579,1 @@\n-        result |= CPU_AVX512_BITALG;\n+        vm_features.set_feature(CPU_AVX512_BITALG);\n@@ -3507,1 +3581,1 @@\n-        result |= CPU_AVX512_VBMI;\n+        vm_features.set_feature(CPU_AVX512_VBMI);\n@@ -3509,1 +3583,28 @@\n-        result |= CPU_AVX512_VBMI2;\n+        vm_features.set_feature(CPU_AVX512_VBMI2);\n+    }\n+    if (is_intel()) {\n+      if (sefsl1_cpuid7_edx.bits.avx10 != 0 &&\n+          std_cpuid24_ebx.bits.avx10_vlen_512 !=0 &&\n+          std_cpuid24_ebx.bits.avx10_converged_isa_version >= 1 &&\n+          xem_xcr0_eax.bits.opmask != 0 &&\n+          xem_xcr0_eax.bits.zmm512 != 0 &&\n+          xem_xcr0_eax.bits.zmm32 != 0) {\n+        vm_features.set_feature(CPU_AVX10_1);\n+        vm_features.set_feature(CPU_AVX512F);\n+        vm_features.set_feature(CPU_AVX512CD);\n+        vm_features.set_feature(CPU_AVX512DQ);\n+        vm_features.set_feature(CPU_AVX512PF);\n+        vm_features.set_feature(CPU_AVX512ER);\n+        vm_features.set_feature(CPU_AVX512BW);\n+        vm_features.set_feature(CPU_AVX512VL);\n+        vm_features.set_feature(CPU_AVX512_VPOPCNTDQ);\n+        vm_features.set_feature(CPU_AVX512_VPCLMULQDQ);\n+        vm_features.set_feature(CPU_AVX512_VAES);\n+        vm_features.set_feature(CPU_AVX512_VNNI);\n+        vm_features.set_feature(CPU_AVX512_BITALG);\n+        vm_features.set_feature(CPU_AVX512_VBMI);\n+        vm_features.set_feature(CPU_AVX512_VBMI2);\n+        if (std_cpuid24_ebx.bits.avx10_converged_isa_version >= 2) {\n+          vm_features.set_feature(CPU_AVX10_2);\n+        }\n+      }\n@@ -3512,0 +3613,1 @@\n+\n@@ -3513,1 +3615,1 @@\n-    result |= CPU_HV;\n+    vm_features.set_feature(CPU_HV);\n@@ -3515,1 +3617,1 @@\n-    result |= CPU_BMI1;\n+    vm_features.set_feature(CPU_BMI1);\n@@ -3517,1 +3619,1 @@\n-    result |= CPU_TSC;\n+    vm_features.set_feature(CPU_TSC);\n@@ -3519,1 +3621,1 @@\n-    result |= CPU_TSCINV_BIT;\n+    vm_features.set_feature(CPU_TSCINV_BIT);\n@@ -3521,1 +3623,1 @@\n-    result |= CPU_AES;\n+    vm_features.set_feature(CPU_AES);\n@@ -3523,1 +3625,1 @@\n-    result |= CPU_LZCNT;\n+    vm_features.set_feature(CPU_LZCNT);\n@@ -3525,1 +3627,1 @@\n-    result |= CPU_3DNOW_PREFETCH;\n+    vm_features.set_feature(CPU_3DNOW_PREFETCH);\n@@ -3527,1 +3629,1 @@\n-    result |= CPU_ERMS;\n+    vm_features.set_feature(CPU_ERMS);\n@@ -3529,1 +3631,1 @@\n-    result |= CPU_FSRM;\n+    vm_features.set_feature(CPU_FSRM);\n@@ -3531,1 +3633,1 @@\n-    result |= CPU_CLMUL;\n+    vm_features.set_feature(CPU_CLMUL);\n@@ -3533,1 +3635,1 @@\n-    result |= CPU_RTM;\n+    vm_features.set_feature(CPU_RTM);\n@@ -3535,1 +3637,1 @@\n-     result |= CPU_ADX;\n+     vm_features.set_feature(CPU_ADX);\n@@ -3537,1 +3639,1 @@\n-    result |= CPU_BMI2;\n+    vm_features.set_feature(CPU_BMI2);\n@@ -3539,1 +3641,1 @@\n-    result |= CPU_SHA;\n+    vm_features.set_feature(CPU_SHA);\n@@ -3541,1 +3643,1 @@\n-    result |= CPU_FMA;\n+    vm_features.set_feature(CPU_FMA);\n@@ -3543,1 +3645,1 @@\n-    result |= CPU_FLUSHOPT;\n+    vm_features.set_feature(CPU_FLUSHOPT);\n@@ -3545,1 +3647,1 @@\n-    result |= CPU_CLWB;\n+    vm_features.set_feature(CPU_CLWB);\n@@ -3547,1 +3649,1 @@\n-    result |= CPU_RDTSCP;\n+    vm_features.set_feature(CPU_RDTSCP);\n@@ -3549,1 +3651,1 @@\n-    result |= CPU_RDPID;\n+    vm_features.set_feature(CPU_RDPID);\n@@ -3555,1 +3657,1 @@\n-      result |= CPU_3DNOW_PREFETCH;\n+      vm_features.set_feature(CPU_3DNOW_PREFETCH);\n@@ -3557,1 +3659,1 @@\n-      result |= CPU_SSE4A;\n+      vm_features.set_feature(CPU_SSE4A);\n@@ -3563,1 +3665,1 @@\n-      result |= CPU_SERIALIZE;\n+      vm_features.set_feature(CPU_SERIALIZE);\n@@ -3565,1 +3667,1 @@\n-      result |= CPU_AVX512_FP16;\n+      vm_features.set_feature(CPU_AVX512_FP16);\n@@ -3572,2 +3674,2 @@\n-    assert((result & CPU_CLWB) == 0, \"Check if it is supported?\");\n-    result &= ~CPU_CLWB;\n+    assert(vm_features.supports_feature(CPU_CLWB), \"Check if it is supported?\");\n+    vm_features.clear_feature(CPU_CLWB);\n@@ -3578,1 +3680,1 @@\n-    result |= CPU_PKU;\n+    vm_features.set_feature(CPU_PKU);\n@@ -3581,1 +3683,1 @@\n-    result |= CPU_OSPKE;\n+    vm_features.set_feature(CPU_OSPKE);\n@@ -3586,1 +3688,1 @@\n-    result |= CPU_CET_SS;\n+    vm_features.set_feature(CPU_CET_SS);\n@@ -3589,1 +3691,1 @@\n-    result |= CPU_CET_IBT;\n+    vm_features.set_feature(CPU_CET_IBT);\n@@ -3596,1 +3698,1 @@\n-    result |= CPU_TSCINV;\n+    vm_features.set_feature(CPU_TSCINV);\n@@ -3598,2 +3700,1 @@\n-\n-  return result;\n+  return vm_features;\n@@ -3789,0 +3890,11 @@\n+\n+void VM_Version::insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen) {\n+  for (int i = 0; i < MAX_CPU_FEATURES; i++) {\n+    if (features.supports_feature((VM_Version::Feature_Flag)i)) {\n+      int res = jio_snprintf(buf, buflen, \", %s\", _features_names[i]);\n+      assert(res > 0, \"not enough temporary space allocated\");\n+      buf += res;\n+      buflen -= res;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":246,"deletions":134,"binary":false,"changes":380,"status":"modified"},{"patch":"@@ -302,1 +302,3 @@\n-      uint32_t       : 21,\n+      uint32_t       : 19,\n+              avx10  : 1,\n+                     : 1,\n@@ -308,0 +310,18 @@\n+  union StdCpuid24MainLeafEax {\n+    uint32_t value;\n+    struct {\n+      uint32_t  sub_leaves_cnt  : 31;\n+    } bits;\n+  };\n+\n+  union StdCpuid24MainLeafEbx {\n+    uint32_t value;\n+    struct {\n+      uint32_t  avx10_converged_isa_version  : 8,\n+                                             : 8,\n+                                             : 2,\n+                avx10_vlen_512               : 1,\n+                                             : 13;\n+    } bits;\n+  };\n+\n@@ -349,1 +369,1 @@\n-   * src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.amd64\/src\/jdk\/vm\/ci\/amd64\/AMD64.java\n+   * src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java\n@@ -351,1 +371,1 @@\n-  enum Feature_Flag : uint64_t {\n+  enum Feature_Flag {\n@@ -427,1 +447,3 @@\n-    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/\n+    decl(AVX512_FP16,       \"avx512_fp16\",       62) \/* AVX512 FP16 ISA support*\/ \\\n+    decl(AVX10_1,           \"avx10_1\",           63) \/* AVX10 512 bit vector ISA Version 1 support*\/ \\\n+    decl(AVX10_2,           \"avx10_2\",           64) \/* AVX10 512 bit vector ISA Version 2 support*\/\n@@ -429,1 +451,1 @@\n-#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1ULL << bit),\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (bit),\n@@ -432,0 +454,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -433,0 +457,5 @@\n+FIXME:CPUFeatures2\n+FIXME:CPUFeatures3\n+#endif\n+    MAX_CPU_FEATURES\n+\/\/FIXME:CPUFeatures4\n@@ -435,0 +464,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -460,0 +491,66 @@\n+FIXME:CPUFeatures2\n+FIXME:CPUFeatures3\n+#endif\n+  class VM_Features {\n+    friend class VMStructs;\n+    friend class JVMCIVMStructs;\n+\n+   private:\n+    uint64_t _features_bitmap[(MAX_CPU_FEATURES \/ BitsPerLong) + 1];\n+\n+    STATIC_ASSERT(sizeof(_features_bitmap) * BitsPerByte >= MAX_CPU_FEATURES);\n+\n+    \/\/ Number of 8-byte elements in _bitmap.\n+    constexpr static int features_bitmap_element_count() {\n+      return sizeof(_features_bitmap) \/ sizeof(uint64_t);\n+    }\n+\n+    constexpr static int features_bitmap_element_shift_count() {\n+      return LogBitsPerLong;\n+    }\n+\n+    constexpr static uint64_t features_bitmap_element_mask() {\n+      return (1ULL << features_bitmap_element_shift_count()) - 1;\n+    }\n+\n+    static int index(Feature_Flag feature) {\n+      int idx = feature >> features_bitmap_element_shift_count();\n+      assert(idx < features_bitmap_element_count(), \"Features array index out of bounds\");\n+      return idx;\n+    }\n+\n+    static uint64_t bit_mask(Feature_Flag feature) {\n+      return (1ULL << (feature & features_bitmap_element_mask()));\n+    }\n+\n+    static int _features_bitmap_size; \/\/ for JVMCI purposes\n+   public:\n+    VM_Features() {\n+      for (int i = 0; i < features_bitmap_element_count(); i++) {\n+        _features_bitmap[i] = 0;\n+      }\n+    }\n+\n+    void set_feature(Feature_Flag feature) {\n+      int idx = index(feature);\n+      _features_bitmap[idx] |= bit_mask(feature);\n+    }\n+\n+    void clear_feature(VM_Version::Feature_Flag feature) {\n+      int idx = index(feature);\n+      _features_bitmap[idx] &= ~bit_mask(feature);\n+    }\n+\n+    bool supports_feature(VM_Version::Feature_Flag feature) {\n+      int idx = index(feature);\n+      return (_features_bitmap[idx] & bit_mask(feature)) != 0;\n+    }\n+  };\n+\n+  \/\/ CPU feature flags vector, can be affected by VM settings.\n+  static VM_Features _features;\n+\n+  \/\/ Original CPU feature flags vector, not affected by VM settings.\n+  static VM_Features _cpu_features;\n+\n+\/\/FIXME:CPUFeatures4\n@@ -463,0 +560,5 @@\n+  static void clear_cpu_features() {\n+    _features = VM_Features();\n+    _cpu_features = VM_Features();\n+  }\n+\n@@ -526,0 +628,5 @@\n+    \/\/ cpuid function 24 converged vector ISA main leaf\n+    \/\/ eax = 24, ecx = 0\n+    StdCpuid24MainLeafEax std_cpuid24_eax;\n+    StdCpuid24MainLeafEbx std_cpuid24_ebx;\n+\n@@ -599,1 +706,1 @@\n-    uint64_t feature_flags() const;\n+    VM_Features feature_flags() const;\n@@ -601,0 +708,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -622,0 +731,2 @@\n+#else\n+    uint64_t glibc_flags() const { return 0; }\n@@ -623,0 +734,1 @@\n+#endif\n@@ -685,0 +797,1 @@\n+  static ByteSize std_cpuid24_offset() { return byte_offset_of(CpuidInfo, std_cpuid24_eax); }\n@@ -718,8 +831,15 @@\n-  static void clean_cpuFeatures()   { _features = 0; }\n-  static void set_avx_cpuFeatures() { _features |= (CPU_SSE | CPU_SSE2 | CPU_AVX | CPU_VZEROUPPER ); }\n-  static void set_evex_cpuFeatures() { _features |= (CPU_AVX512F | CPU_SSE | CPU_SSE2 | CPU_VZEROUPPER ); }\n-  static void set_apx_cpuFeatures() { _features |= CPU_APX_F; }\n-  static void set_bmi_cpuFeatures() { _features |= (CPU_BMI1 | CPU_BMI2 | CPU_LZCNT | CPU_POPCNT); }\n-\n-  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {\n-    Abstract_VM_Version::insert_features_names(buf, buflen, _features_names, features);\n+  static void clean_cpuFeatures()   {\n+    VM_Version::clear_cpu_features();\n+  }\n+  static void set_avx_cpuFeatures() {\n+    _features.set_feature(CPU_SSE);\n+    _features.set_feature(CPU_SSE2);\n+    _features.set_feature(CPU_AVX);\n+    _features.set_feature(CPU_VZEROUPPER);\n+  }\n+  static void set_evex_cpuFeatures() {\n+    _features.set_feature(CPU_AVX10_1);\n+    _features.set_feature(CPU_AVX512F);\n+    _features.set_feature(CPU_SSE);\n+    _features.set_feature(CPU_SSE2);\n+    _features.set_feature(CPU_VZEROUPPER);\n@@ -727,2 +847,6 @@\n-  static void insert_glibc_features_names(char* buf, size_t buflen, uint64_t glibc_features) {\n-    Abstract_VM_Version::insert_features_names(buf, buflen, _glibc_features_names, glibc_features);\n+  static void set_apx_cpuFeatures() { _features.set_feature(CPU_APX_F); }\n+  static void set_bmi_cpuFeatures() {\n+    _features.set_feature(CPU_BMI1);\n+    _features.set_feature(CPU_BMI2);\n+    _features.set_feature(CPU_LZCNT);\n+    _features.set_feature(CPU_POPCNT);\n@@ -738,0 +862,2 @@\n+#if 0\n+FIXME:CPUFeatures1\n@@ -739,0 +865,3 @@\n+#else\n+  static bool ignore_cpu_features() { return true; }\n+#endif\n@@ -791,34 +920,33 @@\n-  static bool supports_cpuid()        { return _features  != 0; }\n-  static bool supports_cmov()         { return (_features & CPU_CMOV) != 0; }\n-  static bool supports_fxsr()         { return (_features & CPU_FXSR) != 0; }\n-  static bool supports_ht()           { return (_features & CPU_HT) != 0; }\n-  static bool supports_mmx()          { return (_features & CPU_MMX) != 0; }\n-  static bool supports_sse()          { return (_features & CPU_SSE) != 0; }\n-  static bool supports_sse2()         { return (_features & CPU_SSE2) != 0; }\n-  static bool supports_sse3()         { return (_features & CPU_SSE3) != 0; }\n-  static bool supports_ssse3()        { return (_features & CPU_SSSE3)!= 0; }\n-  static bool supports_sse4_1()       { return (_features & CPU_SSE4_1) != 0; }\n-  static bool supports_sse4_2()       { return (_features & CPU_SSE4_2) != 0; }\n-  static bool supports_popcnt()       { return (_features & CPU_POPCNT) != 0; }\n-  static bool supports_avx()          { return (_features & CPU_AVX) != 0; }\n-  static bool supports_avx2()         { return (_features & CPU_AVX2) != 0; }\n-  static bool supports_tsc()          { return (_features & CPU_TSC) != 0; }\n-  static bool supports_rdtscp()       { return (_features & CPU_RDTSCP) != 0; }\n-  static bool supports_rdpid()        { return (_features & CPU_RDPID) != 0; }\n-  static bool supports_aes()          { return (_features & CPU_AES) != 0; }\n-  static bool supports_erms()         { return (_features & CPU_ERMS) != 0; }\n-  static bool supports_fsrm()         { return (_features & CPU_FSRM) != 0; }\n-  static bool supports_clmul()        { return (_features & CPU_CLMUL) != 0; }\n-  static bool supports_rtm()          { return (_features & CPU_RTM) != 0; }\n-  static bool supports_bmi1()         { return (_features & CPU_BMI1) != 0; }\n-  static bool supports_bmi2()         { return (_features & CPU_BMI2) != 0; }\n-  static bool supports_adx()          { return (_features & CPU_ADX) != 0; }\n-  static bool supports_evex()         { return (_features & CPU_AVX512F) != 0; }\n-  static bool supports_avx512dq()     { return (_features & CPU_AVX512DQ) != 0; }\n-  static bool supports_avx512ifma()   { return (_features & CPU_AVX512_IFMA) != 0; }\n-  static bool supports_avxifma()      { return (_features & CPU_AVX_IFMA) != 0; }\n-  static bool supports_avx512pf()     { return (_features & CPU_AVX512PF) != 0; }\n-  static bool supports_avx512er()     { return (_features & CPU_AVX512ER) != 0; }\n-  static bool supports_avx512cd()     { return (_features & CPU_AVX512CD) != 0; }\n-  static bool supports_avx512bw()     { return (_features & CPU_AVX512BW) != 0; }\n-  static bool supports_avx512vl()     { return (_features & CPU_AVX512VL) != 0; }\n+  static bool supports_cmov()         { return _features.supports_feature(CPU_CMOV); }\n+  static bool supports_fxsr()         { return _features.supports_feature(CPU_FXSR); }\n+  static bool supports_ht()           { return _features.supports_feature(CPU_HT); }\n+  static bool supports_mmx()          { return _features.supports_feature(CPU_MMX); }\n+  static bool supports_sse()          { return _features.supports_feature(CPU_SSE); }\n+  static bool supports_sse2()         { return _features.supports_feature(CPU_SSE2); }\n+  static bool supports_sse3()         { return _features.supports_feature(CPU_SSE3); }\n+  static bool supports_ssse3()        { return _features.supports_feature(CPU_SSSE3); }\n+  static bool supports_sse4_1()       { return _features.supports_feature(CPU_SSE4_1); }\n+  static bool supports_sse4_2()       { return _features.supports_feature(CPU_SSE4_2); }\n+  static bool supports_popcnt()       { return _features.supports_feature(CPU_POPCNT); }\n+  static bool supports_avx()          { return _features.supports_feature(CPU_AVX); }\n+  static bool supports_avx2()         { return _features.supports_feature(CPU_AVX2); }\n+  static bool supports_tsc()          { return _features.supports_feature(CPU_TSC); }\n+  static bool supports_rdtscp()       { return _features.supports_feature(CPU_RDTSCP); }\n+  static bool supports_rdpid()        { return _features.supports_feature(CPU_RDPID); }\n+  static bool supports_aes()          { return _features.supports_feature(CPU_AES); }\n+  static bool supports_erms()         { return _features.supports_feature(CPU_ERMS); }\n+  static bool supports_fsrm()         { return _features.supports_feature(CPU_FSRM); }\n+  static bool supports_clmul()        { return _features.supports_feature(CPU_CLMUL); }\n+  static bool supports_rtm()          { return _features.supports_feature(CPU_RTM); }\n+  static bool supports_bmi1()         { return _features.supports_feature(CPU_BMI1); }\n+  static bool supports_bmi2()         { return _features.supports_feature(CPU_BMI2); }\n+  static bool supports_adx()          { return _features.supports_feature(CPU_ADX); }\n+  static bool supports_evex()         { return _features.supports_feature(CPU_AVX512F); }\n+  static bool supports_avx512dq()     { return _features.supports_feature(CPU_AVX512DQ); }\n+  static bool supports_avx512ifma()   { return _features.supports_feature(CPU_AVX512_IFMA); }\n+  static bool supports_avxifma()      { return _features.supports_feature(CPU_AVX_IFMA); }\n+  static bool supports_avx512pf()     { return _features.supports_feature(CPU_AVX512PF); }\n+  static bool supports_avx512er()     { return _features.supports_feature(CPU_AVX512ER); }\n+  static bool supports_avx512cd()     { return _features.supports_feature(CPU_AVX512CD); }\n+  static bool supports_avx512bw()     { return _features.supports_feature(CPU_AVX512BW); }\n+  static bool supports_avx512vl()     { return _features.supports_feature(CPU_AVX512VL); }\n@@ -833,1 +961,1 @@\n-  static bool supports_apx_f()        { return (_features & CPU_APX_F) != 0; }\n+  static bool supports_apx_f()        { return _features.supports_feature(CPU_APX_F); }\n@@ -835,20 +963,26 @@\n-  static bool supports_sha()          { return (_features & CPU_SHA) != 0; }\n-  static bool supports_fma()          { return (_features & CPU_FMA) != 0 && supports_avx(); }\n-  static bool supports_vzeroupper()   { return (_features & CPU_VZEROUPPER) != 0; }\n-  static bool supports_avx512_vpopcntdq()  { return (_features & CPU_AVX512_VPOPCNTDQ) != 0; }\n-  static bool supports_avx512_vpclmulqdq() { return (_features & CPU_AVX512_VPCLMULQDQ) != 0; }\n-  static bool supports_avx512_vaes()  { return (_features & CPU_AVX512_VAES) != 0; }\n-  static bool supports_gfni()         { return (_features & CPU_GFNI) != 0; }\n-  static bool supports_avx512_vnni()  { return (_features & CPU_AVX512_VNNI) != 0; }\n-  static bool supports_avx512_bitalg()  { return (_features & CPU_AVX512_BITALG) != 0; }\n-  static bool supports_avx512_vbmi()  { return (_features & CPU_AVX512_VBMI) != 0; }\n-  static bool supports_avx512_vbmi2() { return (_features & CPU_AVX512_VBMI2) != 0; }\n-  static bool supports_avx512_fp16()  { return (_features & CPU_AVX512_FP16) != 0; }\n-  static bool supports_hv()           { return (_features & CPU_HV) != 0; }\n-  static bool supports_serialize()    { return (_features & CPU_SERIALIZE) != 0; }\n-  static bool supports_f16c()         { return (_features & CPU_F16C) != 0; }\n-  static bool supports_pku()          { return (_features & CPU_PKU) != 0; }\n-  static bool supports_ospke()        { return (_features & CPU_OSPKE) != 0; }\n-  static bool supports_cet_ss()       { return (_features & CPU_CET_SS) != 0; }\n-  static bool supports_cet_ibt()      { return (_features & CPU_CET_IBT) != 0; }\n-  static bool supports_sha512()       { return (_features & CPU_SHA512) != 0; }\n+  static bool supports_sha()          { return _features.supports_feature(CPU_SHA); }\n+  static bool supports_fma()          { return _features.supports_feature(CPU_FMA) && supports_avx(); }\n+  static bool supports_vzeroupper()   { return _features.supports_feature(CPU_VZEROUPPER); }\n+  static bool supports_avx512_vpopcntdq()  { return _features.supports_feature(CPU_AVX512_VPOPCNTDQ); }\n+  static bool supports_avx512_vpclmulqdq() { return _features.supports_feature(CPU_AVX512_VPCLMULQDQ); }\n+  static bool supports_avx512_vaes()  { return _features.supports_feature(CPU_AVX512_VAES); }\n+  static bool supports_gfni()         { return _features.supports_feature(CPU_GFNI); }\n+  static bool supports_avx512_vnni()  { return _features.supports_feature(CPU_AVX512_VNNI); }\n+  static bool supports_avx512_bitalg()  { return _features.supports_feature(CPU_AVX512_BITALG); }\n+  static bool supports_avx512_vbmi()  { return _features.supports_feature(CPU_AVX512_VBMI); }\n+  static bool supports_avx512_vbmi2() { return _features.supports_feature(CPU_AVX512_VBMI2); }\n+  static bool supports_avx512_fp16()  { return _features.supports_feature(CPU_AVX512_FP16); }\n+  static bool supports_hv()           { return _features.supports_feature(CPU_HV); }\n+  static bool supports_serialize()    { return _features.supports_feature(CPU_SERIALIZE); }\n+  static bool supports_f16c()         { return _features.supports_feature(CPU_F16C); }\n+  static bool supports_pku()          { return _features.supports_feature(CPU_PKU); }\n+  static bool supports_ospke()        { return _features.supports_feature(CPU_OSPKE); }\n+  static bool supports_cet_ss()       { return _features.supports_feature(CPU_CET_SS); }\n+  static bool supports_cet_ibt()      { return _features.supports_feature(CPU_CET_IBT); }\n+  static bool supports_sha512()       { return _features.supports_feature(CPU_SHA512); }\n+\n+  \/\/ IntelÂ® AVX10 introduces a versioned approach for enumeration that is monotonically increasing, inclusive,\n+  \/\/ and supporting all vector lengths. Feature set supported by an AVX10 vector ISA version is also supported\n+  \/\/ by all the versions above it.\n+  static bool supports_avx10_1()      { return _features.supports_feature(CPU_AVX10_1);}\n+  static bool supports_avx10_2()      { return _features.supports_feature(CPU_AVX10_2);}\n@@ -859,1 +993,1 @@\n-  static bool cpu_supports_evex()     { return (_cpu_features & CPU_AVX512F) != 0; }\n+  static bool cpu_supports_evex()     { return _cpu_features.supports_feature(CPU_AVX512F); }\n@@ -890,0 +1024,2 @@\n+  static void insert_features_names(VM_Version::VM_Features features, char* buf, size_t buflen);\n+\n@@ -897,3 +1033,3 @@\n-  static bool supports_3dnow_prefetch()    { return (_features & CPU_3DNOW_PREFETCH) != 0; }\n-  static bool supports_lzcnt()    { return (_features & CPU_LZCNT) != 0; }\n-  static bool supports_sse4a()    { return (_features & CPU_SSE4A) != 0; }\n+  static bool supports_3dnow_prefetch()    { return _features.supports_feature(CPU_3DNOW_PREFETCH); }\n+  static bool supports_lzcnt()    { return _features.supports_feature(CPU_LZCNT); }\n+  static bool supports_sse4a()    { return _features.supports_feature(CPU_SSE4A); }\n@@ -906,1 +1042,1 @@\n-    return (_features & CPU_TSCINV_BIT) != 0;\n+    return _features.supports_feature(CPU_TSCINV_BIT);\n@@ -909,1 +1045,1 @@\n-    return (_features & CPU_TSCINV) != 0;\n+    return _features.supports_feature(CPU_TSCINV);\n@@ -970,2 +1106,2 @@\n-  static bool supports_clflushopt() { return ((_features & CPU_FLUSHOPT) != 0); }\n-  static bool supports_clwb() { return ((_features & CPU_CLWB) != 0); }\n+  static bool supports_clflushopt() { return (_features.supports_feature(CPU_FLUSHOPT)); }\n+  static bool supports_clwb() { return (_features.supports_feature(CPU_CLWB)); }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":215,"deletions":79,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-  \/\/ No _features_names[] available on this CPU.\n-  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n-\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -473,0 +473,1 @@\n+                 strcmp(vmField.typeString, \"VM_Version::VM_Features\") == 0 ||\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                         \\\n+  JVMTI_ONLY(static_field(CompilerToVM::Data,  _should_notify_object_alloc,            int*))                                        \\\n@@ -1000,1 +1000,5 @@\n-  static_field(VM_Version, _has_intel_jcc_erratum, bool)\n+  static_field(VM_Version,                     _features,                      VM_Version::VM_Features) \\\n+                                                                                                        \\\n+  nonstatic_field(VM_Version::VM_Features,     _features_bitmap[0],            uint64_t)                \\\n+  static_field(VM_Version::VM_Features,        _features_bitmap_size,          int)                     \\\n+  static_field(VM_Version,                     _has_intel_jcc_erratum,         bool)\n@@ -1008,1 +1012,2 @@\n-#define VM_LONG_CPU_FEATURE_CONSTANTS CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT)\n+#define VM_LONG_CPU_FEATURE_CONSTANTS \\\n+   CPU_FEATURE_FLAGS(DECLARE_LONG_CPU_FEATURE_CONSTANT)\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -328,15 +328,0 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features) {\n-  uint features_names_index = 0;\n-\n-  while (features != 0) {\n-    if (features & 1) {\n-      int res = jio_snprintf(buf, buflen, \", %s\", features_names[features_names_index]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n-    }\n-    features >>= 1;\n-    ++features_names_index;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\n@@ -83,1 +84,0 @@\n-  static void insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features = _features);\n@@ -132,1 +132,0 @@\n-  static uint64_t features()           { return _features; }\n@@ -134,0 +133,1 @@\n+\n@@ -135,1 +135,0 @@\n-  static void insert_features_names(char* buf, size_t buflen, const char* features_names[]);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n@@ -1167,0 +1168,1 @@\n+  declare_toplevel_type(VM_Version)                                       \\\n@@ -1719,1 +1721,0 @@\n-  NOT_ZERO(X86_ONLY(declare_constant(frame::entry_frame_call_wrapper_offset)))      \\\n@@ -2150,0 +2151,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -261,0 +261,2 @@\n+        AVX10_1,\n+        AVX10_2\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import static jdk.vm.ci.hotspot.UnsafeAccess.UNSAFE;\n@@ -83,0 +84,54 @@\n+\n+    \/**\n+     * Converts CPU features bit map into enum constants.\n+     *\n+     * @param <CPUFeatureType> CPU feature enum type\n+     * @param enumType the class of {@code CPUFeatureType}\n+     * @param constants VM constants. Each entry whose key starts with {@code \"VM_Version::CPU_\"}\n+     *            specifies a CPU feature and its value is a mask for a bit in {@code features}\n+     * @param featuresBitMapAddress pointer to {@code VM_Features::_features_bitmap} field of {@code VM_Version::_features}\n+     * @param featuresBitMapSize size of feature bit map in bytes\n+     * @param renaming maps from VM feature names to enum constant names where the two differ\n+     * @throws IllegalArgumentException if any VM CPU feature constant cannot be converted to an\n+     *             enum value\n+     * @return the set of converted values\n+     *\/\n+    static <CPUFeatureType extends Enum<CPUFeatureType>> EnumSet<CPUFeatureType> convertFeatures(\n+                    Class<CPUFeatureType> enumType,\n+                    Map<String, Long> constants,\n+                    long featuresBitMapAddress,\n+                    long featuresBitMapSize,\n+                    Map<String, String> renaming) {\n+        EnumSet<CPUFeatureType> outFeatures = EnumSet.noneOf(enumType);\n+        List<String> missing = new ArrayList<>();\n+\n+        for (Entry<String, Long> e : constants.entrySet()) {\n+            String key = e.getKey();\n+            long bitIndex = e.getValue();\n+            if (key.startsWith(\"VM_Version::CPU_\")) {\n+                String name = key.substring(\"VM_Version::CPU_\".length());\n+                try {\n+                    final long featuresElementShiftCount = 6; \/\/ log (# of bits per long)\n+                    final long featuresElementMask = (1L << featuresElementShiftCount) - 1;\n+\n+                    CPUFeatureType feature = Enum.valueOf(enumType, renaming.getOrDefault(name, name));\n+\n+                    long featureIndex = bitIndex >>> featuresElementShiftCount;\n+                    long featureBitMask = 1L << (bitIndex & featuresElementMask);\n+                    assert featureIndex < featuresBitMapSize;\n+\n+                    long featuresElement = UNSAFE.getLong(featuresBitMapAddress + featureIndex * Long.BYTES);\n+\n+                    if ((featuresElement & featureBitMask) != 0) {\n+                        outFeatures.add(feature);\n+                    }\n+                } catch (IllegalArgumentException iae) {\n+                    missing.add(name);\n+                }\n+            }\n+        }\n+        if (!missing.isEmpty()) {\n+            throw new JVMCIError(\"Missing CPU feature constants: %s\", missing);\n+        }\n+        return outFeatures;\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIBackendFactory.java","additions":56,"deletions":1,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,6 @@\n-        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class, constants, config.vmVersionFeatures, renaming);\n+        long featuresBitMapAddress = config.vmVersionFeatures + config.vmFeaturesFeaturesOffset;\n+        EnumSet<CPUFeature> features = HotSpotJVMCIBackendFactory.convertFeatures(CPUFeature.class,\n+                                                                                  constants,\n+                                                                                  featuresBitMapAddress,\n+                                                                                  config.vmFeaturesFeaturesSize,\n+                                                                                  renaming);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotJVMCIBackendFactory.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,4 @@\n+    final long vmVersionFeatures = getFieldAddress(\"VM_Version::_features\", \"VM_Version::VM_Features\");\n+    final long vmFeaturesFeaturesOffset = getFieldOffset(\"VM_Version::VM_Features::_features_bitmap[0]\", Long.class, \"uint64_t\");\n+    final long vmFeaturesFeaturesSize = getFieldValue(\"VM_Version::VM_Features::_features_bitmap_size\", Long.class, \"int\");\n+\n@@ -49,2 +53,0 @@\n-    final long vmVersionFeatures = getFieldValue(\"Abstract_VM_Version::_features\", Long.class, \"uint64_t\");\n-\n@@ -91,0 +93,2 @@\n+    final long amd64AVX10_1 = getConstant(\"VM_Version::CPU_AVX10_1\", Long.class);\n+    final long amd64AVX10_2 = getConstant(\"VM_Version::CPU_AVX10_2\", Long.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/amd64\/AMD64HotSpotVMConfig.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-        \/\/ longConstant VM_Version::CPU_SHA 17179869184\n+        \/\/ longConstant VM_Version::CPU_SHA 34\n@@ -109,1 +109,1 @@\n-                           17179869184L);\n+                           34L);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-                    \"apx_f\"\n+                    \"apx_f\",        \"avx10_1\",          \"avx10_2\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}