{"files":[{"patch":"@@ -198,1 +198,1 @@\n-        Core.Priority.EPOLLSELECTOR.getContext().register(resource);\n+        Core.Priority.SELECTOR.getContext().register(resource);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollPort.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.crac.mirror.Context;\n-import jdk.internal.crac.mirror.Resource;\n@@ -33,4 +31,0 @@\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.JDKResource;\n-import jdk.internal.crac.mirror.impl.CheckpointOpenResourceException;\n-import jdk.internal.crac.mirror.impl.CheckpointOpenSocketException;\n@@ -40,2 +34,0 @@\n-import java.io.Serial;\n-import java.nio.channels.ClosedSelectorException;\n@@ -46,1 +38,7 @@\n-import java.util.*;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n@@ -63,1 +61,1 @@\n-class EPollSelectorImpl extends SelectorImpl implements JDKResource {\n+class EPollSelectorImpl extends SelectorCRaCSupport {\n@@ -71,24 +69,0 @@\n-    private enum CheckpointRestoreState {\n-        NORMAL_OPERATION,\n-        CHECKPOINT_TRANSITION,\n-        CHECKPOINTED,\n-        CHECKPOINT_ERROR,\n-        RESTORE_TRANSITION,\n-    }\n-\n-    private static class MoveToCheckpointThread extends Thread {\n-        private Selector selector;\n-\n-        MoveToCheckpointThread(Selector selector) {\n-            this.selector = selector;\n-        }\n-\n-        @Override\n-        public void run() {\n-            try {\n-                selector.select(1);\n-            } catch (IOException | ClosedSelectorException e) {\n-            }\n-        }\n-    }\n-\n@@ -111,6 +85,5 @@\n-    \/\/ interrupt triggering and clearing\n-    private final Object interruptLock = new Object();\n-    private boolean interruptTriggered;\n-\n-    private volatile CheckpointRestoreState checkpointState = CheckpointRestoreState.NORMAL_OPERATION;;\n-    private Set<SelectableChannel> currentChannels;\n+    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n+        super(sp);\n+        pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+        initFileDescriptors(false);\n+    }\n@@ -118,1 +91,2 @@\n-    private void initFDs() throws IOException {\n+    @Override\n+    protected void initFileDescriptors(boolean restore) throws IOException {\n@@ -137,7 +111,5 @@\n-    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n-        super(sp);\n-        pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n-        initFDs();\n-        \/\/ trigger FileDispatcherImpl initialization\n-        new FileDispatcherImpl();\n-        Core.Priority.EPOLLSELECTOR.getContext().register(this);\n+    @Override\n+    protected void closeFileDescriptors() throws IOException {\n+        eventfd.close();\n+        eventfd = null;\n+        FileDispatcherImpl.closeIntFD(epfd);\n@@ -146,1 +118,2 @@\n-    private boolean processCheckpointRestore() throws IOException {\n+    @Override\n+    protected Set<SelectableChannel> getRegisteredChannels() {\n@@ -148,0 +121,2 @@\n+        return fdToKey.values().stream().map(SelectionKey::channel).collect(Collectors.toSet());\n+    }\n@@ -149,44 +124,5 @@\n-        if (checkpointState != CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n-            return false;\n-        }\n-        \/\/ If the channel using this selector was closed, some keys might be cancelled\n-        \/\/ and we shall remove them.\n-        processDeregisterQueue();\n-\n-        synchronized (interruptLock) {\n-\n-            CheckpointRestoreState thisState;\n-            if (fdToKey.size() == 0) {\n-                eventfd.close();\n-                eventfd = null;\n-                FileDispatcherImpl.closeIntFD(epfd);\n-                thisState = CheckpointRestoreState.CHECKPOINTED;\n-            } else {\n-                thisState = CheckpointRestoreState.CHECKPOINT_ERROR;\n-                currentChannels = fdToKey.values().stream().map(SelectionKey::channel).collect(Collectors.toSet());\n-            }\n-\n-            checkpointState = thisState;\n-            interruptLock.notifyAll();\n-            while (checkpointState == thisState) {\n-                try {\n-                    interruptLock.wait();\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-\n-            assert checkpointState == CheckpointRestoreState.RESTORE_TRANSITION;\n-            if (thisState == CheckpointRestoreState.CHECKPOINTED) {\n-                initFDs();\n-            }\n-            checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n-            interruptLock.notifyAll();\n-\n-            if (interruptTriggered) {\n-                try {\n-                    eventfd.set();\n-                } catch (IOException ioe) {\n-                    throw new InternalError(ioe);\n-                }\n-            }\n-        }\n+    @Override\n+    protected void wakeupInternal() throws IOException {\n+        assert Thread.holdsLock(interruptLock);\n+        eventfd.set();\n+    }\n@@ -194,1 +130,6 @@\n-        return true;\n+    \/\/ In case of C\/R exceptions, claims file descriptors that would be otherwise automatically handled\n+    @Override\n+    protected Collection<FileDescriptor> claimFileDescriptors() {\n+        return Arrays.asList(\n+                claimFileDescriptor(this.epfd, \"EPoll FD \"),\n+                claimFileDescriptor(this.eventfd.efd(), \"EPoll Event FD \"));\n@@ -340,1 +281,1 @@\n-        if (interrupted && !(Thread.currentThread() instanceof MoveToCheckpointThread)) {\n+        if (interrupted && shouldClearInterrupt()) {\n@@ -406,75 +347,0 @@\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        if (!isOpen()) {\n-            return;\n-        }\n-\n-        synchronized (interruptLock) {\n-            checkpointState = CheckpointRestoreState.CHECKPOINT_TRANSITION;\n-            eventfd.set();\n-            int tries = 5;\n-            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION && 0 < tries--) {\n-                try {\n-                    interruptLock.wait(5);\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-            if (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n-                Thread thr = new MoveToCheckpointThread(this);\n-                thr.setDaemon(true);\n-                thr.start();\n-            }\n-            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n-                try {\n-                    interruptLock.wait();\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-            if (checkpointState == CheckpointRestoreState.CHECKPOINT_ERROR) {\n-                var ex = new BusySelectorException(\"Selector \" + this + \" has registered keys from channels: \" + currentChannels, null);\n-                ex.epollFds.add(claimFd(this.epfd, \"EPoll FD \"));\n-                ex.epollFds.add(claimFd(this.eventfd.efd(), \"EPoll Event FD \"));\n-                currentChannels = null;\n-                throw ex;\n-            }\n-        }\n-    }\n-\n-    private FileDescriptor claimFd(int fdval, String type) {\n-        FileDescriptor fd = IOUtil.newFD(fdval);\n-        Core.getClaimedFDs().claimFd(fd, this,\n-                () -> new CheckpointOpenSocketException(type + fdval + \" left open in \" + this + \" with registered keys.\", null));\n-        return fd;\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws Exception {\n-        if (!isOpen()) {\n-            return;\n-        }\n-\n-        synchronized (interruptLock) {\n-            checkpointState = CheckpointRestoreState.RESTORE_TRANSITION;\n-            interruptLock.notifyAll();\n-            while (checkpointState == CheckpointRestoreState.RESTORE_TRANSITION) {\n-                try {\n-                    interruptLock.wait();\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-        }\n-    }\n-\n-    private static class BusySelectorException extends CheckpointOpenResourceException {\n-        @Serial\n-        private static final long serialVersionUID = 5615481252774343456L;\n-        \/\/ We need to keep the FileDescriptors around until the checkpoint completes\n-        \/\/ as ClaimedFDs use WeakHashMap. Transient because exception is serializable\n-        \/\/ and FileDescriptor is not.\n-        transient List<FileDescriptor> epollFds = new ArrayList<>();\n-\n-        public BusySelectorException(String details, Throwable cause) {\n-            super(details, cause);\n-        }\n-    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":36,"deletions":170,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.FileDescriptor;\n@@ -29,0 +30,1 @@\n+import java.nio.channels.SelectableChannel;\n@@ -33,0 +35,2 @@\n+import java.util.Arrays;\n+import java.util.Collection;\n@@ -36,0 +40,1 @@\n+import java.util.Set;\n@@ -38,0 +43,1 @@\n+import java.util.stream.Collectors;\n@@ -48,1 +54,1 @@\n-class KQueueSelectorImpl extends SelectorImpl {\n+class KQueueSelectorImpl extends SelectorCRaCSupport {\n@@ -54,1 +60,1 @@\n-    private final int kqfd;\n+    private int kqfd;\n@@ -60,2 +66,2 @@\n-    private final int fd0;\n-    private final int fd1;\n+    private int fd0;\n+    private int fd1;\n@@ -70,4 +76,0 @@\n-    \/\/ interrupt triggering and clearing\n-    private final Object interruptLock = new Object();\n-    private boolean interruptTriggered;\n-\n@@ -80,0 +82,3 @@\n+        this.pollArrayAddress = KQueue.allocatePollArray(MAX_KEVENTS);\n+        initFileDescriptors(false);\n+    }\n@@ -81,0 +86,2 @@\n+    @Override\n+    protected void initFileDescriptors(boolean restore) throws IOException {\n@@ -82,1 +89,0 @@\n-        this.pollArrayAddress = KQueue.allocatePollArray(MAX_KEVENTS);\n@@ -98,0 +104,25 @@\n+    @Override\n+    protected void closeFileDescriptors() throws IOException {\n+        FileDispatcherImpl.closeIntFD(fd0);\n+        FileDispatcherImpl.closeIntFD(fd1);\n+        FileDispatcherImpl.closeIntFD(kqfd);\n+    }\n+\n+    @Override\n+    protected Set<SelectableChannel> getRegisteredChannels() {\n+        return fdToKey.values().stream().map(SelectionKey::channel).collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    protected void wakeupInternal() throws IOException {\n+        IOUtil.write1(fd1, (byte)0);\n+    }\n+\n+    @Override\n+    protected Collection<FileDescriptor> claimFileDescriptors() {\n+        return Arrays.asList(\n+                claimFileDescriptor(fd0, \"Selector pipe read-end FD \"),\n+                claimFileDescriptor(fd0, \"Selector pipe write-end FD \"),\n+                claimFileDescriptor(fd0, \"KQueue FD \"));\n+    }\n+\n@@ -121,1 +152,3 @@\n-                    numEntries = KQueue.poll(kqfd, pollArrayAddress, MAX_KEVENTS, to);\n+                    do {\n+                        numEntries = KQueue.poll(kqfd, pollArrayAddress, MAX_KEVENTS, to);\n+                    } while (processCheckpointRestore());\n@@ -271,1 +304,1 @@\n-        if (interrupted) {\n+        if (interrupted && shouldClearInterrupt()) {\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueueSelectorImpl.java","additions":44,"deletions":11,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -85,1 +85,8 @@\n-                    d.setFd(fileDescriptorAccess.get(entry.getKey()));\n+                    int fd = fileDescriptorAccess.get(entry.getKey());\n+                    if (fd < 0) {\n+                        assert fileDescriptorAccess.getHandle(entry.getKey()) != -1;\n+                        \/\/ On Windows the native FDs check is a no-op, but we need to set\n+                        \/\/ the FD to prevent assertion failure on Descriptor.getFd()\n+                        fd = 0;\n+                    }\n+                    d.setFd(fd);\n@@ -100,2 +107,2 @@\n-        LoggerContainer.debug(\"ClaimFD: fd {0} claimer {1} existing {2}\",\n-            fd, claimer, descriptor != null ? descriptor.claimer : \"NONE\");\n+        LoggerContainer.debug(\"ClaimFD: fd {0} ({1}) claimer {2} existing {3}\",\n+            fd, fileDescriptorAccess.get(fd), claimer, descriptor != null ? descriptor.claimer : \"NONE\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/ClaimedFDs.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.crac.mirror.impl.GlobalContext;\n@@ -83,2 +82,6 @@\n-        EPOLLSELECTOR(new BlockingOrderedContext<>()),\n-        SOCKETS(new BlockingOrderedContext<>()),\n+        SELECTOR(new BlockingOrderedContext<>()),\n+        \/\/ We permit adding new sockets because WindowsSelectorImpl will create a socket\n+        \/\/ in afterRestore to do internal notification.\n+        \/\/ FIXME: Keep BlockingOrderedContext refusing registrations during checkpoint\n+        \/\/        but allow new resources to be added during restore.\n+        SOCKETS(new OrderedContext<>()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.nio.ch;\n+\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.mirror.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.mirror.impl.CheckpointOpenSocketException;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.io.Serial;\n+import java.nio.channels.ClosedSelectorException;\n+import java.nio.channels.SelectableChannel;\n+import java.nio.channels.Selector;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+public abstract class SelectorCRaCSupport extends SelectorImpl implements JDKResource {\n+\n+    \/\/ interrupt triggering and clearing\n+    protected final Object interruptLock = new Object();\n+    protected volatile boolean interruptTriggered;\n+\n+    private volatile CheckpointRestoreState checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+    private Set<SelectableChannel> currentChannels;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected SelectorCRaCSupport(SelectorProvider sp) {\n+        super(sp);\n+        \/\/ trigger FileDispatcherImpl initialization\n+        new FileDispatcherImpl();\n+        Core.Priority.SELECTOR.getContext().register(this);\n+    }\n+\n+    protected abstract void initFileDescriptors(boolean restore) throws IOException;\n+\n+    protected boolean processCheckpointRestore() throws IOException {\n+        assert Thread.holdsLock(this);\n+\n+        if (checkpointState != CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+            return false;\n+        }\n+        \/\/ If the channel using this selector was closed, some keys might be cancelled\n+        \/\/ and we shall remove them.\n+        processDeregisterQueue();\n+\n+        synchronized (interruptLock) {\n+\n+            CheckpointRestoreState thisState;\n+            currentChannels = getRegisteredChannels();\n+            if (currentChannels.isEmpty()) {\n+                closeFileDescriptors();\n+                thisState = CheckpointRestoreState.CHECKPOINTED;\n+            } else {\n+                thisState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+            }\n+\n+            checkpointState = thisState;\n+            interruptLock.notifyAll();\n+            while (checkpointState == thisState) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+\n+            assert checkpointState == CheckpointRestoreState.RESTORE_TRANSITION;\n+            if (thisState == CheckpointRestoreState.CHECKPOINTED) {\n+                initFileDescriptors(true);\n+            }\n+            checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+            interruptLock.notifyAll();\n+\n+            if (interruptTriggered) {\n+                try {\n+                    wakeupInternal();\n+                } catch (IOException ioe) {\n+                    throw new InternalError(ioe);\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    protected abstract void closeFileDescriptors() throws IOException;\n+\n+    protected abstract Set<SelectableChannel> getRegisteredChannels();\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.CHECKPOINT_TRANSITION;\n+            wakeupInternal();\n+            int tries = 5;\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION && 0 < tries--) {\n+                try {\n+                    interruptLock.wait(5);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                Thread thr = new MoveToCheckpointThread(this);\n+                thr.setDaemon(true);\n+                thr.start();\n+            }\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_ERROR) {\n+                var ex = new BusySelectorException(\"Selector \" + this + \" has registered keys from channels: \" + currentChannels, null);\n+                ex.fds.addAll(claimFileDescriptors());\n+                currentChannels = null;\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    protected boolean shouldClearInterrupt() {\n+        return !(Thread.currentThread() instanceof MoveToCheckpointThread);\n+    }\n+\n+    protected abstract void wakeupInternal() throws IOException;\n+\n+    protected FileDescriptor claimFileDescriptor(int fdval, String type) {\n+        FileDescriptor fd = IOUtil.newFD(fdval);\n+        Core.getClaimedFDs().claimFd(fd, this,\n+                () -> new CheckpointOpenSocketException(type + fdval + \" left open in \" + this + \" with registered keys.\", null));\n+        return fd;\n+    }\n+\n+    \/\/ In case of C\/R exceptions, claims file descriptors that would be otherwise automatically handled\n+    protected abstract Collection<FileDescriptor> claimFileDescriptors();\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.RESTORE_TRANSITION;\n+            interruptLock.notifyAll();\n+            while (checkpointState == CheckpointRestoreState.RESTORE_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+        }\n+    }\n+\n+    private enum CheckpointRestoreState {\n+        NORMAL_OPERATION,\n+        CHECKPOINT_TRANSITION,\n+        CHECKPOINTED,\n+        CHECKPOINT_ERROR,\n+        RESTORE_TRANSITION,\n+    }\n+\n+    private static class MoveToCheckpointThread extends Thread {\n+        private Selector selector;\n+\n+        MoveToCheckpointThread(Selector selector) {\n+            this.selector = selector;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                selector.select(1);\n+            } catch (IOException | ClosedSelectorException e) {\n+            }\n+        }\n+    }\n+\n+    static class BusySelectorException extends CheckpointOpenResourceException {\n+        @Serial\n+        private static final long serialVersionUID = 5615481252774343456L;\n+        \/\/ We need to keep the FileDescriptors around until the checkpoint completes\n+        \/\/ as ClaimedFDs use WeakHashMap. Transient because exception is serializable\n+        \/\/ and FileDescriptor is not.\n+        transient List<FileDescriptor> fds = new ArrayList<>();\n+\n+        public BusySelectorException(String details, Throwable cause) {\n+            super(details, cause);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorCRaCSupport.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.io.FileDescriptor;\n@@ -29,0 +30,1 @@\n+import java.nio.channels.SelectableChannel;\n@@ -34,0 +36,2 @@\n+import java.util.Arrays;\n+import java.util.Collection;\n@@ -36,0 +40,1 @@\n+import java.util.Set;\n@@ -38,0 +43,2 @@\n+import java.util.stream.Collectors;\n+\n@@ -45,1 +52,1 @@\n-class PollSelectorImpl extends SelectorImpl {\n+class PollSelectorImpl extends SelectorCRaCSupport {\n@@ -56,2 +63,2 @@\n-    private final int fd0;\n-    private final int fd1;\n+    private int fd0;\n+    private int fd1;\n@@ -66,4 +73,0 @@\n-    \/\/ interrupt triggering and clearing\n-    private final Object interruptLock = new Object();\n-    private boolean interruptTriggered;\n-\n@@ -76,0 +79,9 @@\n+        initFileDescriptors(false);\n+        \/\/ wakeup support\n+        synchronized (this) {\n+            setFirst(fd0, Net.POLLIN);\n+        }\n+    }\n+\n+    @Override\n+    protected void initFileDescriptors(boolean restore) throws IOException {\n@@ -85,4 +97,31 @@\n-        \/\/ wakeup support\n-        synchronized (this) {\n-            setFirst(fd0, Net.POLLIN);\n-        }\n+        putDescriptor(0, fd0);\n+    }\n+\n+    @Override\n+    protected void closeFileDescriptors() throws IOException {\n+        assert Thread.holdsLock(this);\n+        assert pollArraySize == 1; \/\/ only fd0 as first element\n+\n+        putDescriptor(0, -1);\n+        FileDispatcherImpl.closeIntFD(fd0);\n+        FileDispatcherImpl.closeIntFD(fd1);\n+    }\n+\n+    @Override\n+    protected Set<SelectableChannel> getRegisteredChannels() {\n+        assert Thread.holdsLock(this);\n+        assert pollKeys.getFirst() == null;\n+        return pollKeys.stream().skip(1).map(SelectionKey::channel).collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    protected void wakeupInternal() throws IOException {\n+        assert Thread.holdsLock(interruptLock);\n+        IOUtil.write1(fd1, (byte)0);\n+    }\n+\n+    @Override\n+    protected Collection<FileDescriptor> claimFileDescriptors() {\n+        return Arrays.asList(\n+                claimFileDescriptor(fd0, \"Selector pipe read-end FD \"),\n+                claimFileDescriptor(fd1, \"Selector pipe write-end FD \"));\n@@ -116,1 +155,3 @@\n-                    numPolled = poll(pollArray.address(), pollArraySize, to);\n+                    do {\n+                        numPolled = poll(pollArray.address(), pollArraySize, to);\n+                    } while (processCheckpointRestore());\n@@ -191,1 +232,1 @@\n-        if (getReventOps(0) != 0) {\n+        if (getReventOps(0) != 0 && shouldClearInterrupt()) {\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/PollSelectorImpl.java","additions":54,"deletions":13,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import java.nio.ByteBuffer;\n-import java.nio.channels.Pipe;\n+import java.nio.channels.SelectableChannel;\n@@ -36,0 +35,2 @@\n+import java.util.Arrays;\n+import java.util.Collection;\n@@ -39,0 +40,1 @@\n+import java.util.Set;\n@@ -40,0 +42,2 @@\n+import java.util.stream.Collectors;\n+\n@@ -47,1 +51,1 @@\n-class WEPollSelectorImpl extends SelectorImpl {\n+class WEPollSelectorImpl extends SelectorCRaCSupport {\n@@ -52,1 +56,1 @@\n-    private final long eph;\n+    private long eph;\n@@ -65,4 +69,2 @@\n-    private final Object interruptLock = new Object();\n-    private boolean interruptTriggered;\n-    private final PipeImpl pipe;\n-    private final int fd0Val, fd1Val;\n+    private PipeImpl pipe;\n+    private int fd0Val, fd1Val;\n@@ -72,2 +74,0 @@\n-\n-        this.eph = WEPoll.create();\n@@ -75,0 +75,2 @@\n+        initFileDescriptors(false);\n+    }\n@@ -76,1 +78,7 @@\n-        \/\/ wakeup support\n+    @Override\n+    protected void initFileDescriptors(boolean restore) throws IOException {\n+        \/\/ Creation of PipeImpl inside begin() and end() calls AbstractInterruptibleChannel.blockedOn\n+        \/\/ overriding the current Interruptable; we need to revert that before entering the poll loop.\n+        if (restore) {\n+            end();\n+        }\n@@ -78,5 +86,16 @@\n-            this.pipe = new PipeImpl(sp, \/* AF_UNIX *\/ true, \/*buffering*\/ false);\n-        } catch (IOException ioe) {\n-            WEPoll.freePollArray(pollArrayAddress);\n-            WEPoll.close(eph);\n-            throw ioe;\n+            this.eph = WEPoll.create();\n+            \/\/ wakeup support\n+            try {\n+                this.pipe = new PipeImpl(provider(), \/* AF_UNIX *\/ true, \/*buffering*\/ false);\n+            } catch (IOException ioe) {\n+                WEPoll.freePollArray(pollArrayAddress);\n+                WEPoll.close(eph);\n+                throw ioe;\n+            }\n+            this.fd0Val = pipe.source().getFDVal();\n+            this.fd1Val = pipe.sink().getFDVal();\n+\n+            \/\/ register one end of the pipe for wakeups\n+            WEPoll.ctl(eph, EPOLL_CTL_ADD, fd0Val, WEPoll.EPOLLIN);\n+        } finally {\n+            begin();\n@@ -84,2 +103,1 @@\n-        this.fd0Val = pipe.source().getFDVal();\n-        this.fd1Val = pipe.sink().getFDVal();\n+    }\n@@ -87,2 +105,24 @@\n-        \/\/ register one end of the pipe for wakeups\n-        WEPoll.ctl(eph, EPOLL_CTL_ADD, fd0Val, WEPoll.EPOLLIN);\n+    @Override\n+    protected void closeFileDescriptors() throws IOException {\n+        pipe.sink().close();\n+        pipe.source().close();\n+        pipe = null;\n+        WEPoll.close(eph);\n+    }\n+\n+    @Override\n+    protected Set<SelectableChannel> getRegisteredChannels() {\n+        return fdToKey.values().stream().map(SelectionKey::channel).collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    protected void wakeupInternal() throws IOException {\n+        IOUtil.write1(fd1Val, (byte) 0);\n+    }\n+\n+    @Override\n+    protected Collection<FileDescriptor> claimFileDescriptors() {\n+        \/\/ We do not close\/reopen `eph`; on Windows there's no actual FD check\n+        return Arrays.asList(\n+                claimFileDescriptor(fd0Val, \"WEPoll pipe sink \"),\n+                claimFileDescriptor(fd1Val, \"WEPoll pipe source \"));\n@@ -108,1 +148,3 @@\n-                numEntries = WEPoll.wait(eph, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                do {\n+                    numEntries = WEPoll.wait(eph, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                } while (processCheckpointRestore());\n@@ -185,1 +227,1 @@\n-        if (interrupted) {\n+        if (interrupted && shouldClearInterrupt()) {\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WEPollSelectorImpl.java","additions":64,"deletions":22,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.FileDescriptor;\n@@ -37,0 +38,2 @@\n+import java.util.Arrays;\n+import java.util.Collection;\n@@ -40,0 +43,1 @@\n+import java.util.Set;\n@@ -41,0 +45,2 @@\n+import java.util.stream.Collectors;\n+\n@@ -50,1 +56,1 @@\n-class WindowsSelectorImpl extends SelectorImpl {\n+class WindowsSelectorImpl extends SelectorCRaCSupport {\n@@ -90,1 +96,1 @@\n-    private final Pipe wakeupPipe;\n+    private Pipe wakeupPipe;\n@@ -93,1 +99,1 @@\n-    private final int wakeupSourceFd, wakeupSinkFd;\n+    private int wakeupSourceFd, wakeupSinkFd;\n@@ -128,4 +134,0 @@\n-    \/\/ Lock for interrupt triggering and clearing\n-    private final Object interruptLock = new Object();\n-    private volatile boolean interruptTriggered;\n-\n@@ -137,1 +139,0 @@\n-\n@@ -141,4 +142,44 @@\n-        wakeupPipe = new PipeImpl(sp, \/* AF_UNIX *\/ true, \/*buffering*\/ false);\n-        wakeupSourceFd = ((SelChImpl)wakeupPipe.source()).getFDVal();\n-        wakeupSinkFd = ((SelChImpl)wakeupPipe.sink()).getFDVal();\n-        pollWrapper.addWakeupSocket(wakeupSourceFd, 0);\n+        initFileDescriptors(false);\n+    }\n+\n+    @Override\n+    protected void initFileDescriptors(boolean restore) throws IOException {\n+        \/\/ Creation of PipeImpl inside begin() and end() calls AbstractInterruptibleChannel.blockedOn\n+        \/\/ overriding the current Interruptable; we need to revert that before entering the poll loop.\n+        if (restore) {\n+            end();\n+        }\n+        try {\n+            wakeupPipe = new PipeImpl(provider(), \/* AF_UNIX *\/ true, \/*buffering*\/ false);\n+            wakeupSourceFd = ((SelChImpl) wakeupPipe.source()).getFDVal();\n+            wakeupSinkFd = ((SelChImpl) wakeupPipe.sink()).getFDVal();\n+            pollWrapper.addWakeupSocket(wakeupSourceFd, 0);\n+        } finally {\n+            if (restore) {\n+                begin();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void closeFileDescriptors() throws IOException {\n+        wakeupPipe.sink().close();\n+        wakeupPipe.source().close();\n+        wakeupPipe = null;\n+    }\n+\n+    @Override\n+    protected Set<SelectableChannel> getRegisteredChannels() {\n+        return fdMap.values().stream().map(me -> me.ski.channel()).collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    protected void wakeupInternal() {\n+        setWakeupSocket();\n+    }\n+\n+    @Override\n+    protected Collection<FileDescriptor> claimFileDescriptors() {\n+        return Arrays.asList(\n+                claimFileDescriptor(wakeupSinkFd, \"Selector sink FD \"),\n+                claimFileDescriptor(wakeupSourceFd, \"Selector source FD \"));\n@@ -162,0 +203,2 @@\n+            \/\/ We need to transition even if another wakeup was called before\n+            processCheckpointRestore();\n@@ -176,1 +219,3 @@\n-                subSelector.poll();\n+                do {\n+                    subSelector.poll();\n+                } while (processCheckpointRestore());\n@@ -507,1 +552,1 @@\n-            if (interruptTriggered == false)\n+            if (interruptTriggered == false || !shouldClearInterrupt())\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsSelectorImpl.java","additions":59,"deletions":14,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n- * @requires os.family == \"linux\"\n@@ -175,1 +174,1 @@\n-        EPOLLSELECTOR.getContext().register(new ThrowingResource(recorder, \"throwing2\"));\n+        SELECTOR.getContext().register(new ThrowingResource(recorder, \"throwing2\"));\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,89 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.crac.Context;\n-import jdk.crac.Core;\n-import jdk.crac.Resource;\n-\n-import java.io.IOException;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.Selector;\n-import java.nio.channels.SocketChannel;\n-\n-class ChannelResource implements Resource {\n-\n-    public enum SelectionType {\n-        SELECT,\n-        SELECT_TIMEOUT,\n-        SELECT_NOW\n-    };\n-\n-    private SocketChannel channel;\n-    private SelectionKey key;\n-    private Selector selector;\n-\n-    private final SelectionType selType;\n-\n-    public ChannelResource(SelectionType selType) {\n-        this.selType = selType;\n-        Core.getGlobalContext().register(this);\n-    }\n-\n-    public void open() throws IOException {\n-        channel = SocketChannel.open();\n-        channel.configureBlocking(false);\n-    }\n-\n-    public void register(Selector selector) throws IOException {\n-        key = channel.register(selector, SelectionKey.OP_READ);\n-        this.selector = selector;\n-    }\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n-\n-        channel.socket().close();\n-\n-        \/\/ causes the channel deregistration\n-        if (selType == SelectionType.SELECT_NOW) {\n-            selector.selectNow();\n-        } else if (selType == SelectionType.SELECT_TIMEOUT) {\n-            selector.select(500);\n-        } else {\n-            new Thread(new Runnable() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        Thread.sleep(1000);\n-                        selector.wakeup();\n-                    } catch (InterruptedException ie) {\n-                        throw new RuntimeException(ie);\n-                    }\n-                }\n-            }).start();\n-\n-            selector.select();\n-        }\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) {\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/ChannelResource.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import java.nio.channels.*;\n-import java.io.IOException;\n-import jdk.crac.*;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-\/*\n- * @test Selector\/Test970\n- * @summary a regression test for ZE-970 (\"a channel deregistration\n- *          is locked depending on mutual order of selector and channel creation\")\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build ChannelResource\n- * @build Test\n- * @run driver jdk.test.lib.crac.CracTest SELECT_NOW true\n- * @run driver jdk.test.lib.crac.CracTest SELECT_NOW false\n- * @run driver jdk.test.lib.crac.CracTest SELECT true\n- * @run driver jdk.test.lib.crac.CracTest SELECT false\n- * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT true\n- * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT false\n- *\/\n-public class Test implements CracTest {\n-    @CracTestArg(0)\n-    ChannelResource.SelectionType selType;\n-\n-    @CracTestArg(1)\n-    boolean openSelectorAtFirst;\n-\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().doCheckpointAndRestore();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-\n-        if (openSelectorAtFirst) {\n-\n-            Selector selector = Selector.open();\n-            ChannelResource ch = new ChannelResource(selType);\n-            ch.open();\n-            ch.register(selector);\n-\n-            Core.checkpointRestore();\n-\n-            selector.close();\n-\n-        } else { \/\/ try in other order (see ZE-970)\n-\n-            ChannelResource ch = new ChannelResource(selType);\n-            ch.open();\n-            Selector selector = Selector.open();\n-            ch.register(selector);\n-\n-            Core.checkpointRestore();\n-\n-            selector.close();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-import java.nio.channels.Selector;\n-import java.io.IOException;\n-\n-\/*\n- * @test Selector\/interruptedSelection\n- * @summary check that the thread blocked by Selector.select() could be properly woken up by an interruption\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  false\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  false false\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  false\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false false false\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  true\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  true\n- *\/\n-public class Test implements CracTest {\n-    @CracTestArg(0)\n-    boolean setTimeout;\n-\n-    @CracTestArg(1)\n-    boolean interruptBeforeCheckpoint;\n-\n-    @CracTestArg(2)\n-    boolean skipCR;\n-\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder();\n-        if (skipCR) {\n-            builder.doPlain();\n-        } else {\n-            builder.doCheckpointAndRestore();\n-        }\n-    }\n-\n-    \/\/ select(): interrupt before the checkpoint\n-    @Override\n-    public void exec() throws Exception {\n-        Selector selector = Selector.open();\n-        Runnable r = new Runnable() {\n-            @Override\n-            public void run() {  try {\n-                if (setTimeout) { selector.select(3600_000); }\n-                else { selector.select(); }\n-            } catch (IOException e) { throw new RuntimeException(e); }   }\n-        };\n-        Thread t = new Thread(r);\n-        t.start();\n-\n-        Thread.sleep(1000);\n-\n-        if (interruptBeforeCheckpoint) {\n-            t.interrupt();\n-            t.join();\n-            System.out.println(\">> interrupt before checkpoint\");\n-        }\n-\n-        if (!skipCR) {\n-            jdk.crac.Core.checkpointRestore();\n-        }\n-\n-        Thread.sleep(1000);\n-\n-        if (!interruptBeforeCheckpoint) {\n-            t.interrupt();\n-            t.join();\n-            System.out.println(\">>> interrupt after restore\");\n-        }\n-\n-        \/\/ just in case, check that the selector works as expected\n-\n-        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n-\n-        selector.wakeup();\n-        selector.select();\n-\n-        selector.selectNow();\n-        selector.select(200);\n-        selector.close();\n-    }\n-}\n-\n","filename":"test\/jdk\/jdk\/crac\/Selector\/interruptedSelection\/Test.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,176 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.crac.Context;\n-import jdk.crac.Core;\n-import jdk.crac.Resource;\n-\n-import java.io.IOException;\n-import java.nio.channels.CancelledKeyException;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.Selector;\n-import java.nio.channels.SocketChannel;\n-\n-class ChannelResource implements Resource {\n-\n-    private SocketChannel channel;\n-    private SelectionKey key;\n-    private Selector selector;\n-\n-    private Object att = new Integer(123);\n-\n-    public ChannelResource() {\n-        Core.getGlobalContext().register(this);\n-    }\n-\n-    public void open() throws IOException {\n-        channel = SocketChannel.open();\n-        channel.configureBlocking(false);\n-    }\n-\n-    public void register(Selector selector) throws IOException {\n-        key = channel.register(selector, SelectionKey.OP_CONNECT);\n-        key.attach(att);\n-        this.selector = selector;\n-    }\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n-\n-        channel.socket().close(); \/\/ close the channel => cancel the key\n-        check(!channel.isOpen(), \"the channel should not be open\");\n-        selector.select(100); \/\/ causes the channel deregistration\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) {\n-\n-        check(key.selector().equals(selector), \"invalid key.selector()\");\n-        check(key.channel().equals(channel), \"invalid key.channel()\");\n-\n-        \/\/ the key is cancelled\n-        check(!key.isValid(), \"expected: key.isValid() == false\");\n-\n-        boolean caught = false;\n-        try {\n-            key.readyOps();\n-        } catch (CancelledKeyException e) {\n-            caught = true;\n-        }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try {\n-            key.interestOps();\n-        } catch (CancelledKeyException e) {\n-            caught = true;\n-        }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try {\n-            key.interestOps(SelectionKey.OP_CONNECT);\n-        } catch (CancelledKeyException e) {\n-            caught = true;\n-        }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try {\n-            key.readyOps();\n-        } catch (CancelledKeyException e) {\n-            caught = true;\n-        }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try {\n-            key.isReadable();\n-        } catch (CancelledKeyException e) {\n-            caught = true;\n-        }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try {\n-            key.isWritable();\n-        } catch (CancelledKeyException e) {\n-            caught = true;\n-        }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try {\n-            key.isConnectable();\n-        } catch (CancelledKeyException e) {\n-            caught = true;\n-        }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try {\n-            key.isAcceptable();\n-        } catch (CancelledKeyException e) {\n-            caught = true;\n-        }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        check(att.equals(key.attachment()), \"invalid key.attachment()\");\n-\n-        key.cancel(); \/\/ try just in case\n-\n-        \/\/ register again\n-        try {\n-            channel = SocketChannel.open();\n-            channel.configureBlocking(false);\n-            key = channel.register(selector, SelectionKey.OP_READ);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    \/\/ to check after restore\n-    public void checkKey() {\n-\n-        check(key.isValid(), \"key must be valid\");\n-\n-        check(key.selector().equals(selector), \"invalid key.selector()\");\n-        check(key.channel().equals(channel), \"invalid key.channel()\");\n-\n-        key.isReadable(); \/\/ just call, cannot set \"ready\" state manually\n-        check(!key.isWritable(), \"invalid key.isWritable()\");\n-        check(!key.isConnectable(), \"invalid key.isConnectable()\");\n-        check(!key.isAcceptable(), \"invalid key.isAcceptable()\");\n-\n-        check(key.interestOps() == SelectionKey.OP_READ, \"invalid key.interestOps()\");\n-\n-        System.out.println(\">> ready >> \" + key.readyOps());\n-\n-        check(key.attachment() == null, \"key.attachment() expected to be null\");\n-\n-        key.cancel(); \/\/ try just in case\n-    }\n-\n-    private void check(boolean b, String msg) {\n-        if (!b) {\n-            throw new RuntimeException(msg);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/ChannelResource.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import java.nio.channels.*;\n-import java.io.IOException;\n-import jdk.crac.*;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-\/*\n- * @test Selector\/keyAfterRestore\n- * @summary a trivial test for SelectionKey's state after restore\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build ChannelResource\n- * @build Test\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false\n- *\/\n-public class Test implements CracTest {\n-    @CracTestArg\n-    boolean openSelectorAtFirst;\n-\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().doCheckpointAndRestore();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        ChannelResource ch;\n-        Selector selector = null;\n-\n-        \/\/ check various order (see ZE-970)\n-        if (openSelectorAtFirst) { selector = Selector.open(); }\n-\n-        ch = new ChannelResource();\n-        ch.open();\n-\n-        if (!openSelectorAtFirst) { selector = Selector.open(); }\n-\n-        ch.register(selector);\n-\n-        try {\n-            Core.checkpointRestore();\n-        } catch (CheckpointException | RestoreException e) {\n-            e.printStackTrace();\n-            throw e;\n-        }\n-\n-        Thread.sleep(200);\n-\n-        ch.checkKey();\n-\n-        selector.close();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,173 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-import java.nio.channels.Selector;\n-import java.io.IOException;\n-import java.util.Random;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-\/*\n- * @test Selector\/multipleSelect\n- * @summary check work of multiple select() + wakeup() + C\/R\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS false\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS false\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED false\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS true\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS true\n- * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED true\n- *\/\n-public class Test implements CracTest {\n-\n-    private final static Random RND = new Random();\n-\n-    private final static long LONG_TIMEOUT = 3600_000;\n-    private final static long SHORT_TIMEOUT = 3_000;\n-\n-    public enum TestType {\n-        NO_TIMEOUTS,    \/\/ test only select(), wakeup\n-        ONLY_TIMEOUTS,  \/\/ test only select(timeout), do not call wakeup()\n-        MIXED};\n-\n-    @CracTestArg(0)\n-    TestType type;\n-\n-    @CracTestArg(1)\n-    boolean skipCR;\n-\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder();\n-        if (skipCR) {\n-            builder.doPlain();\n-        } else {\n-            builder.doCheckpointAndRestore();\n-        }\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-\n-        long dt = (type == TestType.ONLY_TIMEOUTS) ? SHORT_TIMEOUT : LONG_TIMEOUT;\n-\n-        int nThreads = (type == TestType.ONLY_TIMEOUTS) ? 5 : 20;\n-\n-        AtomicInteger nSelected = new AtomicInteger(0);\n-\n-        Selector selector = Selector.open();\n-\n-        Thread selectThreads[] = new Thread[nThreads];\n-\n-        boolean setTimeout[] = new boolean[nThreads];\n-        for (int i = 0; i < nThreads; ++i) {\n-            boolean t = false; \/\/ NO_TIMEOUTS\n-            if (type == TestType.ONLY_TIMEOUTS) { t = true; }\n-            else if (type == TestType.MIXED) { t = RND.nextBoolean(); }\n-            setTimeout[i] = t;\n-        }\n-\n-        Runnable rStart = new Runnable() {\n-            @Override\n-            public void run() {\n-\n-                for (int i = 0; i < nThreads; ++i) {\n-\n-                    boolean timeout = setTimeout[i];\n-\n-                    selectThreads[i] = new Thread(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            try {\n-                                int n = nSelected.incrementAndGet();\n-                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n-                                if (timeout) { selector.select(dt); }\n-                                else { selector.select(); }\n-                                nSelected.decrementAndGet();\n-                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n-                            } catch (IOException e) {\n-                                throw new RuntimeException(e);\n-                            }\n-                        }\n-                    });\n-                    selectThreads[i].start();\n-                    try { Thread.sleep(200); } catch (InterruptedException ie) {}\n-                }\n-            }\n-        };\n-        Thread t = new Thread(rStart);\n-        t.start();\n-        Thread.sleep(500);\n-\n-        if (!skipCR) {\n-            jdk.crac.Core.checkpointRestore();\n-        }\n-\n-        t.join();\n-        Thread.sleep(1000);\n-\n-        if (type == TestType.ONLY_TIMEOUTS) { \/\/ do not wake threads up, the timeouts must work\n-\n-            while (nSelected.get() > 0) { Thread.sleep(1000); }\n-\n-        } else {\n-\n-            int nWakeups = 0;\n-            while (true) {\n-\n-                int nBefore = nSelected.get();\n-                if (nBefore == 0) { break; }\n-\n-                System.out.println(\">> wakeup() #\" + (nWakeups + 1));\n-                ++nWakeups;\n-\n-                selector.wakeup();\n-                while (nSelected.get() == nBefore) { \/\/ wait until any select() would be woken up\n-                    Thread.sleep(500);\n-                }\n-            }\n-\n-            if (nWakeups > nThreads) {\n-                selector.close();\n-                throw new RuntimeException(\"invalid number of wakeups\");\n-            }\n-        }\n-\n-        \/\/ just in case...\n-        for (Thread st: selectThreads) { st.join(); }\n-\n-        \/\/ === check that the selector works as expected ===\n-        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n-\n-        selector.wakeup();\n-        selector.select();\n-\n-        selector.selectNow();\n-        selector.select(200);\n-\n-        selector.close();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelect\/Test.java","additions":0,"deletions":173,"binary":false,"changes":173,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-import java.nio.channels.Selector;\n-import java.io.IOException;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-\/*\n- * @test Selector\/multipleSelectNow\n- * @summary check work of multiple selectNow() + C\/R peaceful coexistence\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver jdk.test.lib.crac.CracTest false\n- * @run driver jdk.test.lib.crac.CracTest true\n- *\/\n-public class Test implements CracTest {\n-\n-    @CracTestArg\n-    boolean skipCR;\n-\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder();\n-        if (skipCR) {\n-            builder.doPlain();\n-        } else {\n-            builder.doCheckpointAndRestore();\n-        }\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        AtomicInteger nSelected = new AtomicInteger(0);\n-\n-        Selector selector = Selector.open();\n-\n-        int nThreads = skipCR ? 30 : 150; \/\/ some selectNow() calls should occur at the same time with C\/R\n-        Thread threads[] = new Thread[nThreads];\n-\n-        Runnable rStart = new Runnable() {\n-            @Override\n-            public void run() {\n-\n-                for (int i = 0; i < threads.length; ++i) {\n-\n-                    threads[i] = new Thread(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            try {\n-                                System.out.println(\"selectNow\");\n-                                nSelected.incrementAndGet();\n-                                selector.selectNow();\n-                                System.out.println(\"done\");\n-                                nSelected.decrementAndGet();\n-                            } catch (IOException e) {\n-                                throw new RuntimeException(e);\n-                            }\n-                        }\n-                    });\n-                    threads[i].start();\n-                    try { Thread.sleep(5); } catch (InterruptedException ie) {}\n-                }\n-            }\n-        };\n-        Thread tStart = new Thread(rStart);\n-        tStart.start();\n-        Thread.sleep(500);\n-\n-        if (!skipCR) {\n-            jdk.crac.Core.checkpointRestore();\n-        }\n-\n-        tStart.join();\n-\n-        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n-        for (Thread t: threads) { t.join(); } \/\/ just in case...\n-\n-        \/\/ === check that the selector works as expected ===\n-        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n-\n-        selector.wakeup();\n-        selector.select();\n-\n-        selector.selectNow();\n-        selector.select(200);\n-\n-        selector.close();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectNow\/Test.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,128 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-import java.nio.channels.Selector;\n-import java.nio.channels.ClosedSelectorException;\n-import java.io.IOException;\n-import java.util.Random;\n-\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-\/*\n- * @test Selector\/multipleSelectSingleClose\n- * @summary check a coexistence of multiple select() + C\/R in case when the selector is finally closed\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver jdk.test.lib.crac.CracTest false false\n- * @run driver jdk.test.lib.crac.CracTest false true\n- * @run driver jdk.test.lib.crac.CracTest true  true\n- *\/\n-public class Test implements CracTest {\n-    private final static Random RND = new Random();\n-\n-    @CracTestArg(0)\n-    boolean skipCR;\n-\n-    @CracTestArg(1)\n-    boolean closeBeforeCheckpoint;\n-\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder();\n-        if (skipCR) {\n-            builder.doPlain();\n-        } else {\n-            builder.doCheckpointAndRestore();\n-        }\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        int nThreads = 20;\n-\n-        AtomicInteger nSelected = new AtomicInteger(0);\n-\n-        Selector selector = Selector.open();\n-\n-        Thread selectThreads[] = new Thread[nThreads];\n-\n-        Runnable rStart = new Runnable() {\n-            @Override\n-            public void run() {\n-\n-                for (int i = 0; i < nThreads; ++i) {\n-\n-                    selectThreads[i] = new Thread(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            try {\n-                                boolean timeout = RND.nextBoolean();\n-                                int n = nSelected.incrementAndGet();\n-                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n-                                if (timeout) { selector.select(10 + RND.nextInt(7_000)); }\n-                                else { selector.select(); }\n-                                nSelected.decrementAndGet();\n-                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n-                            } catch (ClosedSelectorException e) {\n-                                System.out.println(\">> ClosedSelectorException\"); \/\/ expected when the selector is closed\n-                                nSelected.decrementAndGet();\n-                            } catch (IOException e) {\n-                                throw new RuntimeException(e);\n-                            }\n-                        }\n-                    });\n-                    selectThreads[i].start();\n-                    try { Thread.sleep(50); } catch (InterruptedException ie) {}\n-                }\n-            }\n-        };\n-        Thread tStart = new Thread(rStart);\n-        tStart.start();\n-        Thread.sleep(500);\n-\n-        if (closeBeforeCheckpoint) {\n-            tStart.join();\n-            Thread.sleep(1000);\n-            selector.close();\n-        }\n-\n-        if (!skipCR) {\n-            jdk.crac.Core.checkpointRestore();\n-        }\n-\n-        if (!closeBeforeCheckpoint) {\n-            tStart.join();\n-            Thread.sleep(1000);\n-            selector.close();\n-        }\n-\n-        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n-\n-        if (nSelected.get() < 0) { throw new RuntimeException(\"negative nSelected??\"); }\n-\n-        \/\/ just in case...\n-        for (Thread t: selectThreads) { t.join(); }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectSingleClose\/Test.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-import java.io.IOException;\n-import java.nio.channels.Selector;\n-\n-\/*\n- * @test Selector\/selectAfterWakeup\n- * @summary check that the Selector's wakeup() makes the subsequent select() call to return immediately\n- *          (see also jdk\/test\/java\/nio\/channels\/Selector\/WakeupSpeed.java);\n- *          covers ZE-983\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver jdk.test.lib.crac.CracTest true  false false\n- * @run driver jdk.test.lib.crac.CracTest true  false true\n- * @run driver jdk.test.lib.crac.CracTest true  true  false\n- * @run driver jdk.test.lib.crac.CracTest true  true  true\n- * @run driver jdk.test.lib.crac.CracTest false true  false\n- * @run driver jdk.test.lib.crac.CracTest false true  true\n- *\/\n-public class Test implements CracTest {\n-    @CracTestArg(0)\n-    boolean wakeupBeforeCheckpoint;\n-\n-    @CracTestArg(1)\n-    boolean wakeupAfterRestore;\n-\n-    @CracTestArg(2)\n-    boolean setSelectTimeout;\n-\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().doCheckpointAndRestore();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-\n-        Selector selector = Selector.open();\n-\n-        \/\/ do this just in case\n-        selector.wakeup();\n-        selector.select();\n-\n-        if (wakeupBeforeCheckpoint) {\n-            selector.wakeup();\n-        }\n-\n-        jdk.crac.Core.checkpointRestore();\n-\n-        if (wakeupAfterRestore) {\n-            selector.wakeup();\n-        }\n-        if (setSelectTimeout) { selector.select(3600_000); }\n-        else { selector.select(); }\n-\n-        selector.close();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAfterWakeup\/Test.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-\n-import java.io.IOException;\n-import java.nio.channels.Selector;\n-\n-\/*\n- * @test Selector\/selectAndWakeupAfterRestore\n- * @summary a trivial check that Selector.wakeup() after restore behaves as expected\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver jdk.test.lib.crac.CracTest\n- *\/\n-public class Test implements CracTest {\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().doCheckpointAndRestore();\n-    }\n-\n-    private static void selectAndWakeup(Selector selector) throws java.io.IOException {\n-\n-        new Thread(new Runnable() {\n-            @Override\n-            public void run() {\n-                try {\n-                    Thread.sleep(7000);\n-                    System.out.println(\">> waking up\");\n-                    selector.wakeup();\n-                } catch (InterruptedException ie) { throw new RuntimeException(ie); }\n-            }\n-        }).start();\n-\n-        System.out.println(\">> selecting\");\n-        selector.select();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-\n-        Selector selector = Selector.open();\n-\n-        selectAndWakeup(selector); \/\/ just in case\n-\n-        jdk.crac.Core.checkpointRestore();\n-\n-        selectAndWakeup(selector);\n-\n-        selector.close();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAndWakeupAfterRestore\/Test.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-import java.nio.channels.Selector;\n-import java.io.IOException;\n-\n-\/*\n- * @test Selector\/wakeupAfterRestore\n- * @summary check that the thread blocked by Selector.select() on checkpoint could be properly woken up after restore\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver jdk.test.lib.crac.CracTest true\n- * @run driver jdk.test.lib.crac.CracTest false\n- *\/\n-public class Test implements CracTest {\n-\n-    private final static long TIMEOUT = 3600_000; \/\/ looong timeout\n-\n-    static boolean awakened;\n-\n-    @CracTestArg\n-    boolean setTimeout;\n-\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().doCheckpointAndRestore();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        Selector selector = Selector.open();\n-        Runnable r = new Runnable() {\n-            @Override\n-            public void run() {\n-                System.out.println(\">> select, setTimeout = \" + setTimeout);\n-                try {\n-                    awakened = false;\n-                    if (setTimeout) { selector.select(TIMEOUT); }\n-                    else { selector.select(); }\n-                    awakened = true;\n-                } catch (IOException e) { throw new RuntimeException(e); }\n-            }\n-        };\n-        Thread t = new Thread(r);\n-        t.start();\n-        Thread.sleep(1000);\n-\n-        jdk.crac.Core.checkpointRestore();\n-\n-        System.out.print(\">> waking up: \");\n-        selector.wakeup();\n-        t.join();\n-        System.out.println(\"done\");\n-\n-        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n-\n-        \/\/ check that the selector works as expected\n-\n-        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n-\n-        selector.wakeup();\n-        selector.select();\n-\n-        selector.selectNow();\n-        selector.select(200);\n-        selector.close();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupAfterRestore\/Test.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-import java.nio.channels.Selector;\n-import java.io.IOException;\n-\n-\/*\n- * @test Selector\/wakeupByClose\n- * @summary check that the Selector's close() wakes it up after restore\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver jdk.test.lib.crac.CracTest true  false\n- * @run driver jdk.test.lib.crac.CracTest false false\n- * @run driver jdk.test.lib.crac.CracTest true  true\n- * @run driver jdk.test.lib.crac.CracTest false true\n- *\/\n-public class Test implements CracTest {\n-\n-    static boolean awakened, closed;\n-\n-    @CracTestArg(0)\n-    boolean setTimeout;\n-\n-    @CracTestArg(1)\n-    boolean skipCR;\n-\n-    @Override\n-    public void test() throws Exception {\n-        CracBuilder builder = new CracBuilder();\n-        if (skipCR) {\n-            builder.doPlain();\n-        } else {\n-            builder.doCheckpointAndRestore();\n-        }\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        Selector selector = Selector.open();\n-\n-        Thread tSelect = new Thread(new Runnable() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        awakened = false;\n-                        if (setTimeout) { selector.select(3600_000); }\n-                        else { selector.select(); }\n-                        awakened = true;\n-                    } catch (IOException e) { throw new RuntimeException(e); }\n-                }\n-            });\n-        tSelect.start();\n-\n-        Thread.sleep(3000);\n-\n-        if (!skipCR) { jdk.crac.Core.checkpointRestore(); }\n-\n-        \/\/ close() must wakeup the selector\n-        Thread tClose = new Thread(new Runnable() {\n-\n-                @Override\n-                public void run() {\n-                    try {\n-                        closed = false;\n-                        selector.close();\n-                        closed = true;\n-                    } catch (IOException e) { throw new RuntimeException(e); }\n-                }\n-            });\n-        tClose.start();\n-        tClose.join();\n-        tSelect.join();\n-\n-        if (!awakened) {\n-            selector.wakeup();\n-            throw new RuntimeException(\"selector did not wake up\");\n-        }\n-\n-        if (!closed) {\n-            selector.close();\n-            throw new RuntimeException(\"selector did not close\");\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByClose\/Test.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,79 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-\n-import java.nio.channels.Selector;\n-import java.io.IOException;\n-\n-\/*\n- * @test Selector\/wakeupByTimeoutAfterRestore\n- * @summary check that the Selector selected before the checkpoint,\n- *          will wake up by timeout after the restore\n- * @requires (os.family == \"linux\")\n- * @library \/test\/lib\n- * @build Test\n- * @run driver jdk.test.lib.crac.CracTest\n- *\/\n-public class Test implements CracTest {\n-\n-    private final static long TIMEOUT = 40_000; \/\/ 40 seconds\n-\n-    static boolean awakened = false;\n-\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().doCheckpointAndRestore();\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        Selector selector = Selector.open();\n-        Runnable r = new Runnable() {\n-            @Override\n-            public void run() {\n-                try {\n-                    selector.select(TIMEOUT);\n-                    awakened = true;\n-                } catch (IOException e) { throw new RuntimeException(e); }\n-            }\n-        };\n-        Thread t = new Thread(r);\n-        t.start();\n-        Thread.sleep(1000);\n-\n-        jdk.crac.Core.checkpointRestore();\n-\n-        t.join();\n-        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n-\n-        \/\/ check that the selector works as expected\n-\n-        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n-\n-        selector.wakeup();\n-        selector.select();\n-\n-        selector.selectNow();\n-        selector.select(200);\n-        selector.close();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByTimeoutAfterRestore\/Test.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -54,1 +54,1 @@\n-            new CracBuilder()\n+            builder()\n@@ -64,0 +64,4 @@\n+    protected CracBuilder builder() {\n+        return new CracBuilder();\n+    }\n+\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningTestBase.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.test.lib.crac.CracBuilder;\n@@ -25,0 +26,1 @@\n+import jdk.test.lib.crac.CracTestArg;\n@@ -28,0 +30,1 @@\n+import java.nio.channels.spi.SelectorProvider;\n@@ -31,1 +34,0 @@\n-\/\/ FIXME: JDK-8371549 - remove @requires Linux\n@@ -33,1 +35,1 @@\n- * @test\n+ * @test id=DEFAULT\n@@ -36,1 +38,0 @@\n- * @requires (os.family == \"linux\")\n@@ -41,1 +42,23 @@\n- * @run driver\/timeout=10 jdk.test.lib.crac.CracTest false\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ *\/\n+\/**\n+ * @test id=ALT_UNIX\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family != \"windows\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenListeningTestBase\n+ * @build ReopenListeningSocketChannelTest\n+ * @build ReopenListeningWithSelectorTest\n+ * @run driver jdk.test.lib.crac.CracTest false sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/**\n+ * @test id=ALT_WINDOWS\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"windows\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenListeningTestBase\n+ * @build ReopenListeningSocketChannelTest\n+ * @build ReopenListeningWithSelectorTest\n+ * @run driver jdk.test.lib.crac.CracTest false sun.nio.ch.WindowsSelectorProvider\n@@ -46,0 +69,12 @@\n+    @CracTestArg(value = 1, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    protected CracBuilder builder() {\n+        CracBuilder builder = super.builder();\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        return builder;\n+    }\n+\n@@ -48,0 +83,4 @@\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+        selector = Selector.open();\n@@ -54,1 +93,0 @@\n-        selector = Selector.open();\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningWithSelectorTest.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary check that the thread blocked by Selector.select() could be properly woken up by an interruption\n+ * @library \/test\/lib\n+ * @build InterruptedSelectionTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  false false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false false false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  true\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build InterruptedSelectionTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  false sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  false false sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  false sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false false false sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  true  sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  true  sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build InterruptedSelectionTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  false false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false false false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  true  sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class InterruptedSelectionTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean setTimeout;\n+\n+    @CracTestArg(1)\n+    boolean interruptBeforeCheckpoint;\n+\n+    @CracTestArg(2)\n+    boolean skipCR;\n+\n+    @CracTestArg(value = 3, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.startCheckpoint().waitForSuccess();\n+        }\n+    }\n+\n+    \/\/ select(): interrupt before the checkpoint\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {  try {\n+                if (setTimeout) { selector.select(3600_000); }\n+                else { selector.select(); }\n+            } catch (IOException e) { throw new RuntimeException(e); }   }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+\n+        Thread.sleep(1000);\n+\n+        if (interruptBeforeCheckpoint) {\n+            t.interrupt();\n+            t.join();\n+            System.out.println(\">> interrupt before checkpoint\");\n+        }\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        if (!interruptBeforeCheckpoint) {\n+            t.interrupt();\n+            t.join();\n+            System.out.println(\">>> interrupt after restore\");\n+        }\n+\n+        \/\/ just in case, check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/InterruptedSelectionTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary a trivial test for SelectionKey's state after restore\n+ * @library \/test\/lib\n+ * @build KeyAfterRestoreTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build KeyAfterRestoreTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build KeyAfterRestoreTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class KeyAfterRestoreTest implements CracTest {\n+    @CracTestArg\n+    boolean openSelectorAtFirst;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        builder.startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        ChannelResource ch;\n+        Selector selector = null;\n+\n+        \/\/ check various order (see ZE-970)\n+        if (openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch = new ChannelResource();\n+        ch.open();\n+\n+        if (!openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch.register(selector);\n+\n+        try {\n+            Core.checkpointRestore();\n+        } catch (CheckpointException | RestoreException e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+\n+        Thread.sleep(200);\n+\n+        ch.checkKey();\n+\n+        selector.close();\n+    }\n+\n+    static class ChannelResource implements Resource {\n+\n+        private SocketChannel channel;\n+        private SelectionKey key;\n+        private Selector selector;\n+\n+        private Object att = new Integer(123);\n+\n+        public ChannelResource() {\n+            Core.getGlobalContext().register(this);\n+        }\n+\n+        public void open() throws IOException {\n+            channel = SocketChannel.open();\n+            channel.configureBlocking(false);\n+        }\n+\n+        public void register(Selector selector) throws IOException {\n+            key = channel.register(selector, SelectionKey.OP_CONNECT);\n+            key.attach(att);\n+            this.selector = selector;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+            channel.socket().close(); \/\/ close the channel => cancel the key\n+            check(!channel.isOpen(), \"the channel should not be open\");\n+            selector.select(100); \/\/ causes the channel deregistration\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+\n+            check(key.selector().equals(selector), \"invalid key.selector()\");\n+            check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+            \/\/ the key is cancelled\n+            check(!key.isValid(), \"expected: key.isValid() == false\");\n+\n+            boolean caught = false;\n+            try {\n+                key.readyOps();\n+            } catch (CancelledKeyException e) {\n+                caught = true;\n+            }\n+            check(caught, \"expected CancelledKeyException is missing\");\n+\n+            caught = false;\n+            try {\n+                key.interestOps();\n+            } catch (CancelledKeyException e) {\n+                caught = true;\n+            }\n+            check(caught, \"expected CancelledKeyException is missing\");\n+\n+            caught = false;\n+            try {\n+                key.interestOps(SelectionKey.OP_CONNECT);\n+            } catch (CancelledKeyException e) {\n+                caught = true;\n+            }\n+            check(caught, \"expected CancelledKeyException is missing\");\n+\n+            caught = false;\n+            try {\n+                key.readyOps();\n+            } catch (CancelledKeyException e) {\n+                caught = true;\n+            }\n+            check(caught, \"expected CancelledKeyException is missing\");\n+\n+            caught = false;\n+            try {\n+                key.isReadable();\n+            } catch (CancelledKeyException e) {\n+                caught = true;\n+            }\n+            check(caught, \"expected CancelledKeyException is missing\");\n+\n+            caught = false;\n+            try {\n+                key.isWritable();\n+            } catch (CancelledKeyException e) {\n+                caught = true;\n+            }\n+            check(caught, \"expected CancelledKeyException is missing\");\n+\n+            caught = false;\n+            try {\n+                key.isConnectable();\n+            } catch (CancelledKeyException e) {\n+                caught = true;\n+            }\n+            check(caught, \"expected CancelledKeyException is missing\");\n+\n+            caught = false;\n+            try {\n+                key.isAcceptable();\n+            } catch (CancelledKeyException e) {\n+                caught = true;\n+            }\n+            check(caught, \"expected CancelledKeyException is missing\");\n+\n+            check(att.equals(key.attachment()), \"invalid key.attachment()\");\n+\n+            key.cancel(); \/\/ try just in case\n+\n+            \/\/ register again\n+            try {\n+                channel = SocketChannel.open();\n+                channel.configureBlocking(false);\n+                key = channel.register(selector, SelectionKey.OP_READ);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        \/\/ to check after restore\n+        public void checkKey() {\n+\n+            check(key.isValid(), \"key must be valid\");\n+\n+            check(key.selector().equals(selector), \"invalid key.selector()\");\n+            check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+            key.isReadable(); \/\/ just call, cannot set \"ready\" state manually\n+            check(!key.isWritable(), \"invalid key.isWritable()\");\n+            check(!key.isConnectable(), \"invalid key.isConnectable()\");\n+            check(!key.isAcceptable(), \"invalid key.isAcceptable()\");\n+\n+            check(key.interestOps() == SelectionKey.OP_READ, \"invalid key.interestOps()\");\n+\n+            System.out.println(\">> ready >> \" + key.readyOps());\n+\n+            check(key.attachment() == null, \"key.attachment() expected to be null\");\n+\n+            key.cancel(); \/\/ try just in case\n+        }\n+\n+        private void check(boolean b, String msg) {\n+            if (!b) {\n+                throw new RuntimeException(msg);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/KeyAfterRestoreTest.java","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary check work of multiple selectNow() + C\/R peaceful coexistence\n+ * @library \/test\/lib\n+ * @build MultipleSelectNowTest\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"unix\")\n+ * @library \/test\/lib\n+ * @build MultipleSelectNowTest\n+ * @run driver jdk.test.lib.crac.CracTest false sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build MultipleSelectNowTest\n+ * @run driver jdk.test.lib.crac.CracTest false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class MultipleSelectNowTest implements CracTest {\n+\n+    @CracTestArg\n+    boolean skipCR;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.startCheckpoint().waitForSuccess();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        int nThreads = skipCR ? 30 : 150; \/\/ some selectNow() calls should occur at the same time with C\/R\n+        Thread threads[] = new Thread[nThreads];\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < threads.length; ++i) {\n+\n+                    threads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                System.out.println(\"selectNow\");\n+                                nSelected.incrementAndGet();\n+                                selector.selectNow();\n+                                System.out.println(\"done\");\n+                                nSelected.decrementAndGet();\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    threads[i].start();\n+                    try { Thread.sleep(5); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread tStart = new Thread(rStart);\n+        tStart.start();\n+        Thread.sleep(500);\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        tStart.join();\n+\n+        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n+        for (Thread t: threads) { t.join(); } \/\/ just in case...\n+\n+        \/\/ === check that the selector works as expected ===\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/MultipleSelectNowTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.nio.channels.ClosedSelectorException;\n+import java.io.IOException;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.Random;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary check a coexistence of multiple select() + C\/R in case when the selector is finally closed\n+ * @library \/test\/lib\n+ * @build MultipleSelectSingleCloseTest\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ * @run driver jdk.test.lib.crac.CracTest true  true\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build MultipleSelectSingleCloseTest\n+ * @run driver jdk.test.lib.crac.CracTest false false sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false true sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  true sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build MultipleSelectSingleCloseTest\n+ * @run driver jdk.test.lib.crac.CracTest false false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false true sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  true sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class MultipleSelectSingleCloseTest implements CracTest {\n+    private final static Random RND = new Random();\n+\n+    @CracTestArg(0)\n+    boolean skipCR;\n+\n+    @CracTestArg(1)\n+    boolean closeBeforeCheckpoint;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.startCheckpoint().waitForSuccess();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        int nThreads = 20;\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        Thread selectThreads[] = new Thread[nThreads];\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < nThreads; ++i) {\n+\n+                    selectThreads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                boolean timeout = RND.nextBoolean();\n+                                int n = nSelected.incrementAndGet();\n+                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                                if (timeout) { selector.select(10 + RND.nextInt(7_000)); }\n+                                else { selector.select(); }\n+                                nSelected.decrementAndGet();\n+                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                            } catch (ClosedSelectorException e) {\n+                                System.out.println(\">> ClosedSelectorException\"); \/\/ expected when the selector is closed\n+                                nSelected.decrementAndGet();\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    selectThreads[i].start();\n+                    try { Thread.sleep(50); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread tStart = new Thread(rStart);\n+        tStart.start();\n+        Thread.sleep(500);\n+\n+        if (closeBeforeCheckpoint) {\n+            tStart.join();\n+            Thread.sleep(1000);\n+            selector.close();\n+        }\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        if (!closeBeforeCheckpoint) {\n+            tStart.join();\n+            Thread.sleep(1000);\n+            selector.close();\n+        }\n+\n+        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n+\n+        if (nSelected.get() < 0) { throw new RuntimeException(\"negative nSelected??\"); }\n+\n+        \/\/ just in case...\n+        for (Thread t: selectThreads) { t.join(); }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/MultipleSelectSingleCloseTest.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.Random;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary check work of multiple select() + wakeup() + C\/R\n+ * @library \/test\/lib\n+ * @build MultipleSelectTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED true\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build MultipleSelectTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS false sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS   false sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED         false sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS true  sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS   true  sun.nio.ch.PollSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED         true  sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build MultipleSelectTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS   false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED         false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS   true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED         true  sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class MultipleSelectTest implements CracTest {\n+\n+    private final static Random RND = new Random();\n+\n+    private final static long LONG_TIMEOUT = 3600_000;\n+    private final static long SHORT_TIMEOUT = 3_000;\n+\n+    public enum TestType {\n+        NO_TIMEOUTS,    \/\/ test only select(), wakeup\n+        ONLY_TIMEOUTS,  \/\/ test only select(timeout), do not call wakeup()\n+        MIXED};\n+\n+    @CracTestArg(0)\n+    TestType type;\n+\n+    @CracTestArg(1)\n+    boolean skipCR;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.startCheckpoint().waitForSuccess();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        long dt = (type == TestType.ONLY_TIMEOUTS) ? SHORT_TIMEOUT : LONG_TIMEOUT;\n+\n+        int nThreads = (type == TestType.ONLY_TIMEOUTS) ? 5 : 20;\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        Thread selectThreads[] = new Thread[nThreads];\n+\n+        boolean setTimeout[] = new boolean[nThreads];\n+        for (int i = 0; i < nThreads; ++i) {\n+            boolean t = false; \/\/ NO_TIMEOUTS\n+            if (type == TestType.ONLY_TIMEOUTS) { t = true; }\n+            else if (type == TestType.MIXED) { t = RND.nextBoolean(); }\n+            setTimeout[i] = t;\n+        }\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < nThreads; ++i) {\n+\n+                    boolean timeout = setTimeout[i];\n+\n+                    selectThreads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                int n = nSelected.incrementAndGet();\n+                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                                if (timeout) { selector.select(dt); }\n+                                else { selector.select(); }\n+                                nSelected.decrementAndGet();\n+                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    selectThreads[i].start();\n+                    try { Thread.sleep(200); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread t = new Thread(rStart);\n+        t.start();\n+        Thread.sleep(500);\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        t.join();\n+        Thread.sleep(1000);\n+\n+        if (type == TestType.ONLY_TIMEOUTS) { \/\/ do not wake threads up, the timeouts must work\n+\n+            while (nSelected.get() > 0) { Thread.sleep(1000); }\n+\n+        } else {\n+\n+            int nWakeups = 0;\n+            while (true) {\n+\n+                int nBefore = nSelected.get();\n+                if (nBefore == 0) { break; }\n+\n+                System.out.println(\">> wakeup() #\" + (nWakeups + 1));\n+                ++nWakeups;\n+\n+                selector.wakeup();\n+                while (nSelected.get() == nBefore) { \/\/ wait until any select() would be woken up\n+                    Thread.sleep(500);\n+                }\n+            }\n+\n+            if (nWakeups > nThreads) {\n+                selector.close();\n+                throw new RuntimeException(\"invalid number of wakeups\");\n+            }\n+        }\n+\n+        \/\/ just in case...\n+        for (Thread st: selectThreads) { st.join(); }\n+\n+        \/\/ === check that the selector works as expected ===\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/MultipleSelectTest.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT Selector\/selectAfterWakeup\n+ * @summary check that the Selector's wakeup() makes the subsequent select() call to return immediately\n+ *          (see also jdk\/test\/java\/nio\/channels\/Selector\/WakeupSpeed.java);\n+ *          covers ZE-983\n+ * @library \/test\/lib\n+ * @build SelectAfterWakeupTest\n+ * @run driver jdk.test.lib.crac.CracTest true  false false\n+ * @run driver jdk.test.lib.crac.CracTest true  false true\n+ * @run driver jdk.test.lib.crac.CracTest true  true  false\n+ * @run driver jdk.test.lib.crac.CracTest true  true  true\n+ * @run driver jdk.test.lib.crac.CracTest false true  false\n+ * @run driver jdk.test.lib.crac.CracTest false true  true\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build SelectAfterWakeupTest\n+ * @run driver jdk.test.lib.crac.CracTest true  false false sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  false true  sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  true  false sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  true  true  sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false true  false sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false true  true  sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build SelectAfterWakeupTest\n+ * @run driver jdk.test.lib.crac.CracTest true  false false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  false true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  true  false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  true  true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false true  false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false true  true  sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class SelectAfterWakeupTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean wakeupBeforeCheckpoint;\n+\n+    @CracTestArg(1)\n+    boolean wakeupAfterRestore;\n+\n+    @CracTestArg(2)\n+    boolean setSelectTimeout;\n+\n+    @CracTestArg(value = 3, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        builder.startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        Selector selector = Selector.open();\n+\n+        \/\/ do this just in case\n+        selector.wakeup();\n+        selector.select();\n+\n+        if (wakeupBeforeCheckpoint) {\n+            selector.wakeup();\n+        }\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        if (wakeupAfterRestore) {\n+            selector.wakeup();\n+        }\n+        if (setSelectTimeout) { selector.select(3600_000); }\n+        else { selector.select(); }\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/SelectAfterWakeupTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary a trivial check that Selector.wakeup() after restore behaves as expected\n+ * @library \/test\/lib\n+ * @build SelectAndWarkeupAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build SelectAndWarkeupAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build SelectAndWarkeupAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class SelectAndWarkeupAfterRestoreTest implements CracTest {\n+    @CracTestArg(optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        builder.startCheckpoint().waitForSuccess();\n+    }\n+\n+    private static void selectAndWakeup(Selector selector) throws java.io.IOException {\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    Thread.sleep(7000);\n+                    System.out.println(\">> waking up\");\n+                    selector.wakeup();\n+                } catch (InterruptedException ie) { throw new RuntimeException(ie); }\n+            }\n+        }).start();\n+\n+        System.out.println(\">> selecting\");\n+        selector.select();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        Selector selector = Selector.open();\n+\n+        selectAndWakeup(selector); \/\/ just in case\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        selectAndWakeup(selector);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/SelectAndWarkeupAfterRestoreTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary a regression test for ZE-970 (\"a channel deregistration\n+ *          is locked depending on mutual order of selector and channel creation\")\n+ * @library \/test\/lib\n+ * @build Test970\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW false\n+ * @run driver jdk.test.lib.crac.CracTest SELECT true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT false\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT false\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build Test970\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW     true  sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW     false sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT         true  sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT         false sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT true  sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT false sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build Test970\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW     true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW     false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT         true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT         false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT false sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class Test970 implements CracTest {\n+    @CracTestArg(0)\n+    ChannelResource.SelectionType selType;\n+\n+    @CracTestArg(1)\n+    boolean openSelectorAtFirst;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        builder.startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        if (openSelectorAtFirst) {\n+\n+            Selector selector = Selector.open();\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            ch.register(selector);\n+\n+            Core.checkpointRestore();\n+\n+            selector.close();\n+\n+        } else { \/\/ try in other order (see ZE-970)\n+\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            Selector selector = Selector.open();\n+            ch.register(selector);\n+\n+            Core.checkpointRestore();\n+\n+            selector.close();\n+        }\n+    }\n+\n+    static class ChannelResource implements Resource {\n+\n+        public enum SelectionType {\n+            SELECT,\n+            SELECT_TIMEOUT,\n+            SELECT_NOW\n+        };\n+\n+        private SocketChannel channel;\n+        private SelectionKey key;\n+        private Selector selector;\n+\n+        private final SelectionType selType;\n+\n+        public ChannelResource(SelectionType selType) {\n+            this.selType = selType;\n+            Core.getGlobalContext().register(this);\n+        }\n+\n+        public void open() throws IOException {\n+            channel = SocketChannel.open();\n+            channel.configureBlocking(false);\n+        }\n+\n+        public void register(Selector selector) throws IOException {\n+            key = channel.register(selector, SelectionKey.OP_READ);\n+            this.selector = selector;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+            channel.socket().close();\n+\n+            \/\/ causes the channel deregistration\n+            if (selType == SelectionType.SELECT_NOW) {\n+                selector.selectNow();\n+            } else if (selType == SelectionType.SELECT_TIMEOUT) {\n+                selector.select(500);\n+            } else {\n+                new Thread(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        try {\n+                            Thread.sleep(1000);\n+                            selector.wakeup();\n+                        } catch (InterruptedException ie) {\n+                            throw new RuntimeException(ie);\n+                        }\n+                    }\n+                }).start();\n+\n+                selector.select();\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/Test970.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary check that the thread blocked by Selector.select() on checkpoint could be properly woken up after restore\n+ * @library \/test\/lib\n+ * @build WakeupAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build WakeupAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest true  sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build WakeupAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class WakeupAfterRestoreTest implements CracTest {\n+\n+    private final static long TIMEOUT = 3600_000; \/\/ looong timeout\n+\n+    static boolean awakened;\n+\n+    @CracTestArg\n+    boolean setTimeout;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        builder.startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                System.out.println(\">> select, setTimeout = \" + setTimeout);\n+                try {\n+                    awakened = false;\n+                    if (setTimeout) { selector.select(TIMEOUT); }\n+                    else { selector.select(); }\n+                    awakened = true;\n+                } catch (IOException e) { throw new RuntimeException(e); }\n+            }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+        Thread.sleep(1000);\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        System.out.print(\">> waking up: \");\n+        selector.wakeup();\n+        t.join();\n+        System.out.println(\"done\");\n+\n+        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n+\n+        \/\/ check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/WakeupAfterRestoreTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary check that the Selector's close() wakes it up after restore\n+ * @library \/test\/lib\n+ * @build WakeupByCloseTest\n+ * @run driver jdk.test.lib.crac.CracTest true  false\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ * @run driver jdk.test.lib.crac.CracTest true  true\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build WakeupByCloseTest\n+ * @run driver jdk.test.lib.crac.CracTest true  false sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false false sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  true  sun.nio.ch.PollSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false true  sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build WakeupByCloseTest\n+ * @run driver jdk.test.lib.crac.CracTest true  false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false false sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest true  true  sun.nio.ch.WindowsSelectorProvider\n+ * @run driver jdk.test.lib.crac.CracTest false true  sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class WakeupByCloseTest implements CracTest {\n+\n+    static boolean awakened, closed;\n+\n+    @CracTestArg(0)\n+    boolean setTimeout;\n+\n+    @CracTestArg(1)\n+    boolean skipCR;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.startCheckpoint().waitForSuccess();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        Selector selector = Selector.open();\n+\n+        Thread tSelect = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        awakened = false;\n+                        if (setTimeout) { selector.select(3600_000); }\n+                        else { selector.select(); }\n+                        awakened = true;\n+                    } catch (IOException e) { throw new RuntimeException(e); }\n+                }\n+            });\n+        tSelect.start();\n+\n+        Thread.sleep(3000);\n+\n+        if (!skipCR) { jdk.crac.Core.checkpointRestore(); }\n+\n+        \/\/ close() must wakeup the selector\n+        Thread tClose = new Thread(new Runnable() {\n+\n+                @Override\n+                public void run() {\n+                    try {\n+                        closed = false;\n+                        selector.close();\n+                        closed = true;\n+                    } catch (IOException e) { throw new RuntimeException(e); }\n+                }\n+            });\n+        tClose.start();\n+        tClose.join();\n+        tSelect.join();\n+\n+        if (!awakened) {\n+            selector.wakeup();\n+            throw new RuntimeException(\"selector did not wake up\");\n+        }\n+\n+        if (!closed) {\n+            selector.close();\n+            throw new RuntimeException(\"selector did not close\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/WakeupByCloseTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+import java.nio.channels.spi.SelectorProvider;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/*\n+ * @test id=DEFAULT\n+ * @summary check that the Selector selected before the checkpoint,\n+ *          will wake up by timeout after the restore\n+ * @library \/test\/lib\n+ * @build WakeupByTimeoutAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+\/*\n+ * @test id=ALT_UNIX\n+ * @requires (os.family != \"windows\")\n+ * @library \/test\/lib\n+ * @build WakeupByTimeoutAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest sun.nio.ch.PollSelectorProvider\n+ *\/\n+\/*\n+ * @test id=ALT_WINDOWS\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build WakeupByTimeoutAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest sun.nio.ch.WindowsSelectorProvider\n+ *\/\n+public class WakeupByTimeoutAfterRestoreTest implements CracTest {\n+\n+    private final static long TIMEOUT = 40_000; \/\/ 40 seconds\n+\n+    static boolean awakened = false;\n+\n+    @CracTestArg(optional = true)\n+    String selectorImpl;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.SIMULATE);\n+        if (selectorImpl != null) {\n+            builder.javaOption(SelectorProvider.class.getName(), selectorImpl);\n+        }\n+        builder.startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        if (selectorImpl != null) {\n+            assertEquals(selectorImpl, SelectorProvider.provider().getClass().getName());\n+        }\n+\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    selector.select(TIMEOUT);\n+                    awakened = true;\n+                } catch (IOException e) { throw new RuntimeException(e); }\n+            }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+        Thread.sleep(1000);\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        t.join();\n+        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n+\n+        \/\/ check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/nio\/channels\/Selector\/WakeupByTimeoutAfterRestoreTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -8,0 +8,1 @@\n+import java.util.Arrays;\n@@ -9,0 +10,2 @@\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -170,2 +173,5 @@\n-        \/\/ TODO: check superclasses\n-        Field[] sortedFields = Stream.of(testClass.getDeclaredFields()).filter(f -> f.isAnnotationPresent(CracTestArg.class))\n+        Set<Field> argFields = new HashSet<>();\n+        for (Class<?> cls = testClass; cls != null && cls != Object.class; cls = cls.getSuperclass()) {\n+            Arrays.stream(cls.getDeclaredFields()).filter(f -> f.isAnnotationPresent(CracTestArg.class)).forEach(argFields::add);\n+        }\n+        Field[] sortedFields = argFields.stream()\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}