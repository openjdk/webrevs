{"files":[{"patch":"@@ -328,10 +328,7 @@\n-  const GrowableArrayCHeap<const char *, MemTag::mtInternal> *controlled_opts = engine.vm_controlled_options();\n-  assert(controlled_opts != nullptr, \"must be\");\n-  if (controlled_opts->is_nonempty()) {\n-    tty->cr();\n-    tty->print_raw(\"Configuration options controlled by the JVM: \");\n-    for (int i = 0; i < controlled_opts->length(); i++) {\n-      tty->print_raw(controlled_opts->at(i));\n-      if (i != controlled_opts->length() - 1) {\n-        tty->print_raw(\", \");\n-      }\n+  const char * const *controlled_opts = CracEngine::vm_controlled_options();\n+  tty->cr();\n+  tty->print_raw(\"Configuration options controlled by the JVM: \");\n+  for (const auto *opt = controlled_opts; *opt != nullptr; opt++) {\n+    tty->print_raw(*opt);\n+    if (*(opt + 1) != nullptr) {\n+      tty->print_raw(\", \");\n@@ -339,1 +336,0 @@\n-    tty->cr();\n@@ -341,1 +337,1 @@\n-  delete controlled_opts;\n+  tty->cr();\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -42,6 +41,14 @@\n-\/\/ CRaC engine configuration options that JVM sets directly.\n-\/\/ If an option is controlled exctusively by JVM (i.e. the user is not allowed\n-\/\/ to pass the option through CRaCEngineOptions) it should be listed in\n-\/\/ CracEngine::vm_controlled_options().\n-#define ENGINE_OPT_IMAGE_LOCATION \"image_location\"\n-#define ENGINE_OPT_EXEC_LOCATION \"exec_location\"\n+\/\/ CRaC engine configuration options JVM sets directly instead of relaying from the user\n+#define VM_CONTROLLED_ENGINE_OPTS(OPT) \\\n+  OPT(image_location) \\\n+  OPT(exec_location) \\\n+\n+#define ARRAY_ELEM(opt) #opt,\n+static constexpr const char * const vm_controlled_engine_opts[] = {\n+  VM_CONTROLLED_ENGINE_OPTS(ARRAY_ELEM) nullptr\n+};\n+#undef ARRAY_ELEM\n+\n+#define DEFINE_OPT_VAR(opt) static constexpr const char engine_opt_##opt[] = #opt;\n+VM_CONTROLLED_ENGINE_OPTS(DEFINE_OPT_VAR)\n+#undef DEFINE_OPT_VAR\n@@ -66,0 +73,4 @@\n+const char * const *CracEngine::vm_controlled_options() {\n+  return vm_controlled_engine_opts;\n+}\n+\n@@ -142,2 +153,2 @@\n-  if (!api.configure(conf, ENGINE_OPT_IMAGE_LOCATION, image_location)) {\n-    log_error(crac)(\"CRaC engine failed to configure: '\" ENGINE_OPT_IMAGE_LOCATION \"' = '%s'\", image_location);\n+  if (!api.configure(conf, engine_opt_image_location, image_location)) {\n+    log_error(crac)(\"CRaC engine failed to configure: '%s' = '%s'\", engine_opt_image_location, image_location);\n@@ -187,4 +198,4 @@\n-    guarantee(api.can_configure(conf, ENGINE_OPT_EXEC_LOCATION),\n-              \"crexec does not support expected option: \" ENGINE_OPT_EXEC_LOCATION);\n-    if (!api.configure(conf, ENGINE_OPT_EXEC_LOCATION, exec_location)) {\n-      log_error(crac)(\"crexec failed to configure: '\" ENGINE_OPT_EXEC_LOCATION \"' = '%s'\", exec_location);\n+    guarantee(api.can_configure(conf, engine_opt_exec_location),\n+              \"crexec does not support expected option: %s\", engine_opt_exec_location);\n+    if (!api.configure(conf, engine_opt_exec_location, exec_location)) {\n+      log_error(crac)(\"crexec failed to configure: '%s' = '%s'\", engine_opt_exec_location, exec_location);\n@@ -200,0 +211,5 @@\n+  CStringSet vm_controlled_keys;\n+#define PUT_CONTROLLED_KEY(opt) vm_controlled_keys.put_when_absent(engine_opt_##opt, false);\n+  VM_CONTROLLED_ENGINE_OPTS(PUT_CONTROLLED_KEY)\n+#undef PUT_CONTROLLED_KEY\n+\n@@ -208,3 +224,2 @@\n-    if (strcmp(key, ENGINE_OPT_IMAGE_LOCATION) == 0 ||\n-        (exec_location != nullptr && strcmp(key, ENGINE_OPT_EXEC_LOCATION) == 0)) {\n-      log_warning(crac)(\"Internal CRaC engine option provided, skipping: %s\", key);\n+    if (vm_controlled_keys.contains(key)) {\n+      log_warning(crac)(\"VM-controlled CRaC engine option provided, skipping: %s\", key);\n@@ -397,26 +412,0 @@\n-\n-GrowableArrayCHeap<const char *, MemTag::mtInternal> *CracEngine::vm_controlled_options() const {\n-  precond(_description_api != nullptr);\n-\n-  auto * const opts = new GrowableArrayCHeap<const char *, MemTag::mtInternal>();\n-\n-  \/\/ We expect all engines to support this but the error is to be shown when configuring checkpoint\n-  if (_api->can_configure(_conf, ENGINE_OPT_IMAGE_LOCATION)) {\n-    opts->append(ENGINE_OPT_IMAGE_LOCATION);\n-  }\n-\n-  \/\/ ID-based checks are not fully robust as engines are free to use any ID (e.g. external engines\n-  \/\/ can try to \"impersonate\" themselves as crexec) but in reality engines are expected to use\n-  \/\/ destinct IDs so this shouldn't cause problems\n-  const char *id = _description_api->identity(_conf);\n-  if (id == nullptr) {\n-    log_debug(crac)(\"CRaC engine failed to identify itself\");\n-    return opts;\n-  }\n-\n-  if (strcmp(id, \"crexec\") == 0 && _api->can_configure(_conf, ENGINE_OPT_EXEC_LOCATION)) {\n-    opts->append(ENGINE_OPT_EXEC_LOCATION);\n-  }\n-\n-  return opts;\n-}\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":31,"deletions":42,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -40,0 +39,2 @@\n+  static const char * const *vm_controlled_options();\n+\n@@ -66,1 +67,0 @@\n-  GrowableArrayCHeap<const char *, MemTag::mtInternal> *vm_controlled_options() const;\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                \"Internal CRaC engine option provided, skipping: image_location\");\n+                \"VM-controlled CRaC engine option provided, skipping: image_location\");\n","filename":"test\/jdk\/jdk\/crac\/CracEngineOptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}