{"files":[{"patch":"@@ -40,3 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -138,4 +135,28 @@\n-    @SuppressWarnings(\"removal\")\n-    private static void checkpointRestore1(long jcmdStream) throws\n-            CheckpointException,\n-            RestoreException {\n+    private static List<String> parseNewArguments(String newArguments) {\n+        if (newArguments == null || newArguments.length() == 0) {\n+            return List.of();\n+        }\n+\n+        final var parsedNewArguments = new ArrayList<String>();\n+\n+        \/\/ Spaces \" \" separate arguments, escaped scapes \"\\ \" do not\n+        final char escChar = '\\\\';\n+        final char sepChar = ' ';\n+        final var curArgBuilder = new StringBuilder();\n+        for (int i = 0; i < newArguments.length(); ++i) {\n+            final char curChar = newArguments.charAt(i);\n+            switch (curChar) {\n+                case sepChar -> {\n+                    parsedNewArguments.add(curArgBuilder.toString());\n+                    curArgBuilder.setLength(0);\n+                }\n+                case escChar -> curArgBuilder.append(newArguments.charAt(++i));\n+                default -> curArgBuilder.append(curChar);\n+            }\n+        }\n+        parsedNewArguments.add(curArgBuilder.toString());\n+\n+        return parsedNewArguments;\n+    }\n+\n+    private static List<String> checkpointRestore1(long jcmdStream) throws CheckpointException, RestoreException {\n@@ -225,45 +246,0 @@\n-        if (newArguments != null && newArguments.length() > 0) {\n-            \/\/ Parse arguments into array, unescape spaces\n-            final char escChar = '\\\\';\n-            final char sepChar = ' ';\n-            final var argList = new ArrayList<String>();\n-            final var curArgBuilder = new StringBuilder();\n-            for (int i = 0; i < newArguments.length(); ++i) {\n-                final char curChar = newArguments.charAt(i);\n-                switch (curChar) {\n-                    case sepChar -> {\n-                        argList.add(curArgBuilder.toString());\n-                        curArgBuilder.setLength(0);\n-                    }\n-                    case escChar -> curArgBuilder.append(newArguments.charAt(++i));\n-                    default -> curArgBuilder.append(curChar);\n-                }\n-            }\n-            argList.add(curArgBuilder.toString());\n-\n-            final String[] args = argList.toArray(new String[argList.size()]);\n-            if (args.length > 0) {\n-                try {\n-                    Method newMain = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n-                       @Override\n-                       public Method run() throws Exception {\n-                           Class < ?> newMainClass = Class.forName(args[0], false,\n-                               ClassLoader.getSystemClassLoader());\n-                           Method newMain = newMainClass.getDeclaredMethod(\"main\",\n-                               String[].class);\n-                           newMain.setAccessible(true);\n-                           return newMain;\n-                       }\n-                    });\n-                    newMain.invoke(null,\n-                        (Object)Arrays.copyOfRange(args, 1, args.length));\n-                } catch (PrivilegedActionException |\n-                         InvocationTargetException |\n-                         IllegalAccessException e) {\n-                    assert !checkpointException.hasException() :\n-                        \"should not have new arguments\";\n-                    restoreException.handle(e);\n-                }\n-            }\n-        }\n-\n@@ -273,0 +249,2 @@\n+\n+        return parseNewArguments(newArguments);\n@@ -297,0 +275,2 @@\n+        final List<String> newArguments;\n+\n@@ -312,1 +292,1 @@\n-                checkpointRestore1(jcmdStream);\n+                newArguments = checkpointRestore1(jcmdStream);\n@@ -321,0 +301,22 @@\n+\n+        \/\/ Launch the new main if requested\n+        if (!newArguments.isEmpty()) {\n+            final var newMainClassName = newArguments.getFirst();\n+            final var newMainArgs = newArguments.subList(1, newArguments.size()).toArray(String[]::new);\n+            try {\n+                final var newMainClass = Class.forName(newMainClassName, false, ClassLoader.getSystemClassLoader());\n+                final var newMain = newMainClass.getDeclaredMethod(\"main\", String[].class);\n+                newMain.setAccessible(true);\n+                newMain.invoke(null, (Object) newMainArgs);\n+            } catch (ReflectiveOperationException e) {\n+                \/\/ It is not uncommon for users to use this feature by accident\n+                \/\/ so the message should have a good explanation\n+                final var msg = \"Failed to execute the new main entry: \" +\n+                        \"new main class = '\" + newMainClassName + \"', \" +\n+                        \"new main arguments = \" + Arrays.toString(newMainArgs) + \". \" +\n+                        \"Do not specify these if you just wish to continue the checkpointed execution.\";\n+                RestoreException ex = new RestoreException();\n+                ex.addSuppressed(new Exception(msg, e));\n+                throw ex;\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":55,"deletions":53,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n- * CA 94089 USA or visit www.azul.com if you need additional information or\n- * have any questions.\n- *\/\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-\n-import java.io.IOException;\n-import java.util.Arrays;\n-\n-\/*\n- * @test RestoreNewArgsTest\n- * @summary the test checks new args are propagated into a restored process.\n- * @library \/test\/lib\n- * @build RestoreNewArgsTest\n- * @run driver\/timeout=120 jdk.test.lib.crac.CracTest\n- * @requires (os.family == \"linux\")\n- *\/\n-public class RestoreNewArgsTest implements CracTest {\n-\n-    @Override\n-    public void test() throws Exception {\n-        final String MAIN_CLASS = \"RestoreNewArgsTest$InternalMain\";\n-        final String ARG0 = \"test arg\";\n-        final String ARG1 = \"\\\\ another\\\\ \\\"test\\\\\\\\arg \";\n-        final String ARG2 = \"  ano\\007ther  'yet  arg  \\\\\";\n-        CracBuilder builder = new CracBuilder().captureOutput(true);\n-        builder.doCheckpoint();\n-        builder.startRestoreWithArgs(null, Arrays.asList(MAIN_CLASS, ARG0, ARG1, ARG2))\n-            .waitForSuccess().outputAnalyzer()\n-            .shouldContain(\"RESTORED\")\n-            .shouldContain(\"Arg 0: \" + ARG0 + \".\")\n-            .shouldContain(\"Arg 1: \" + ARG1 + \".\")\n-            .shouldContain(\"Arg 2: \" + ARG2 + \".\");\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        jdk.crac.Core.checkpointRestore();\n-        System.out.println(\"RESTORED\");\n-    }\n-\n-    public class InternalMain {\n-        public static void main(String args[]) throws Exception {\n-            int i = 0;\n-            for (var arg : args) {\n-                System.out.println(\"Arg \" + i++ + \": \" + arg + \".\");\n-            }\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/jdk\/crac\/RestoreNewArgsTest.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import java.util.List;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test\n+ * @summary Checks that new args are parsed correctly.\n+ * @library \/test\/lib\n+ * @build ArgsParsingTest\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class ArgsParsingTest implements CracTest {\n+    private static final String NEW_MAIN_CLASS = \"ArgsParsingTest$InternalMain\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        final String ARG0 = \"test arg\";\n+        final String ARG1 = \"\\\\ another\\\\ \\\"test\\\\\\\\arg \";\n+        final String ARG2 = \"  ano\\007ther  'yet  arg  \\\\\";\n+        CracBuilder builder = new CracBuilder().captureOutput(true);\n+        builder.doCheckpoint();\n+        builder.startRestoreWithArgs(null, List.of(NEW_MAIN_CLASS, ARG0, ARG1, ARG2))\n+            .waitForSuccess().outputAnalyzer()\n+            .shouldContain(\"RESTORED\")\n+            .shouldContain(\"Arg 0: \" + ARG0 + \".\")\n+            .shouldContain(\"Arg 1: \" + ARG1 + \".\")\n+            .shouldContain(\"Arg 2: \" + ARG2 + \".\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        jdk.crac.Core.checkpointRestore();\n+        System.out.println(\"RESTORED\");\n+    }\n+\n+    public class InternalMain {\n+        public static void main(String[] args) {\n+            int i = 0;\n+            for (var arg : args) {\n+                System.out.println(\"Arg \" + i++ + \": \" + arg + \".\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/newArgs\/ArgsParsingTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import java.util.List;\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test\n+ * @summary It should be possible to C\/R in a new main.\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build CheckpointInNewMainTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CheckpointInNewMainTest implements CracTest {\n+    private static final String NEW_MAIN_CLASS = \"CheckpointInNewMainTest$InternalMain\";\n+    private static final String RESTORE_OLD_MSG = \"RESTORED IN OLD MAIN\";\n+    private static final String RESTORE_NEW_MSG = \"RESTORED IN NEW MAIN\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        final var builder = new CracBuilder().captureOutput(true)\n+            \/\/ Disabling direct_map to be able to overwrite the first image,\n+            \/\/ otherwise the second image will depend on the first one and\n+            \/\/ we will get CRIU errors on the second restore\n+            .engine(CracEngine.CRIU).vmOption(\"-XX:CRaCEngineOptions=direct_map=false\");\n+\n+        \/\/ Checkpoint in the old main\n+        builder.doCheckpoint();\n+        \/\/ Restore from the old main and checkpoint in the new main\n+        builder.startRestoreWithArgs(null, List.of(NEW_MAIN_CLASS)).waitForCheckpointed();\n+        \/\/ Restore from the new main\n+        final var out = builder.doRestore().outputAnalyzer();\n+\n+        out.shouldContain(RESTORE_OLD_MSG).shouldContain(RESTORE_NEW_MSG);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+        System.out.println(RESTORE_OLD_MSG);\n+    }\n+\n+    public static class InternalMain {\n+        public static void main(String[] args) throws Exception {\n+            Core.checkpointRestore();\n+            System.out.println(RESTORE_NEW_MSG);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/newArgs\/CheckpointInNewMainTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import java.util.List;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @summary New main should run only if C\/R succeeds.\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build FailedCheckpointRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest SUCCESS_CONTINUE\n+ * @run driver jdk.test.lib.crac.CracTest SUCCESS_EXIT\n+ * @run driver jdk.test.lib.crac.CracTest CHECKPOINT_EXCEPTION\n+ * @run driver jdk.test.lib.crac.CracTest RESTORE_EXCEPTION\n+ *\/\n+public class FailedCheckpointRestoreTest implements CracTest {\n+    private static final String NEW_MAIN_CLASS = \"FailedCheckpointRestoreTest$InternalMain\";\n+    private static final String RESTORE_OLD_MSG = \"RESTORED IN OLD MAIN\";\n+    private static final String RESTORE_NEW_MSG = \"RESTORED IN NEW MAIN\";\n+\n+    public enum Variant {\n+        SUCCESS_CONTINUE,\n+        SUCCESS_EXIT,\n+        CHECKPOINT_EXCEPTION,\n+        RESTORE_EXCEPTION,\n+    };\n+\n+    @CracTestArg(0)\n+    Variant variant;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final CracBuilder builder = new CracBuilder().captureOutput(true);\n+        final OutputAnalyzer out;\n+        if (variant == Variant.CHECKPOINT_EXCEPTION) {\n+            out = builder.startCheckpoint().waitForSuccess().outputAnalyzer();\n+        } else {\n+            builder.doCheckpoint();\n+            out = builder.startRestoreWithArgs(null, List.of(NEW_MAIN_CLASS, variant.toString()))\n+                .waitForSuccess().outputAnalyzer();\n+        }\n+        switch (variant) {\n+            case SUCCESS_CONTINUE ->\n+                out.stdoutShouldContain(RESTORE_NEW_MSG).stdoutShouldContain(RESTORE_OLD_MSG);\n+            case SUCCESS_EXIT ->\n+                out.stdoutShouldContain(RESTORE_NEW_MSG).stdoutShouldNotContain(RESTORE_OLD_MSG);\n+            case CHECKPOINT_EXCEPTION, RESTORE_EXCEPTION ->\n+                out.stdoutShouldNotContain(RESTORE_NEW_MSG).stdoutShouldNotContain(RESTORE_OLD_MSG);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() {\n+        final var checkpointFail = \"Failing on checkpoint!\";\n+        final var restoreFail = \"Failing on restore!\";\n+\n+        final var failingResource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) {\n+                if (variant == Variant.CHECKPOINT_EXCEPTION) {\n+                    throw new RuntimeException(checkpointFail);\n+                }\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) {\n+                if (variant == Variant.RESTORE_EXCEPTION) {\n+                    throw new RuntimeException(restoreFail);\n+                }\n+            }\n+        };\n+        Core.getGlobalContext().register(failingResource);\n+\n+        try {\n+            Core.checkpointRestore();\n+            System.out.println(RESTORE_OLD_MSG);\n+        } catch (CheckpointException ex) {\n+            if (variant != Variant.CHECKPOINT_EXCEPTION) {\n+                throw new IllegalStateException(\"Unexpected checkpoint failure\", ex);\n+            }\n+            if (ex.getSuppressed().length != 1) {\n+                throw new IllegalStateException(\"Unexpected suppressions\", ex);\n+            }\n+            if (!checkpointFail.equals(ex.getSuppressed()[0].getMessage())) {\n+                throw new IllegalStateException(\"Unexpected suppression message\", ex);\n+            }\n+        } catch (RestoreException ex) {\n+            if (variant != Variant.RESTORE_EXCEPTION) {\n+                throw new IllegalStateException(\"Unexpected checkpoint failure\", ex);\n+            }\n+            if (ex.getSuppressed().length != 1) {\n+                throw new IllegalStateException(\"Unexpected suppressions\", ex);\n+            }\n+            if (!restoreFail.equals(ex.getSuppressed()[0].getMessage())) {\n+                throw new IllegalStateException(\"Unexpected suppression message\", ex);\n+            }\n+        }\n+    }\n+\n+    public static class InternalMain {\n+        public static void main(String[] args) {\n+            System.out.println(RESTORE_NEW_MSG);\n+            if (Variant.valueOf(args[0]) == Variant.SUCCESS_EXIT) {\n+                System.exit(0);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/newArgs\/FailedCheckpointRestoreTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -41,2 +41,6 @@\n-            assertEquals(137, process.waitFor(), \"Checkpointed process was not killed as expected.\");\n-            \/\/ TODO: we could check that \"CR: Checkpoint\" was written out\n+            final var exitValue = process.waitFor();\n+            if (exitValue != 137 && builder.captureOutput) {\n+                printOutput();\n+            }\n+            assertEquals(137, exitValue, \"Checkpointed process was not killed as expected.\");\n+            builder.log(\"Process %d completed with exit value %d%n\", process.pid(), exitValue);\n@@ -109,0 +113,1 @@\n+        final OutputAnalyzer oa;\n@@ -110,3 +115,1 @@\n-            OutputAnalyzer oa = outputAnalyzer();\n-            System.err.print(oa.getStderr());\n-            System.out.print(oa.getStdout());\n+            oa = outputAnalyzer();\n@@ -116,0 +119,6 @@\n+        \/\/ Similar to OutputAnalyzer.reportDiagnosticSummary() but a bit better formatted\n+        System.err.println(\"stdout: [\");\n+        System.err.print(oa.getStdout());\n+        System.err.println(\"]\\nstderr: [\");\n+        System.err.print(oa.getStderr());\n+        System.err.println(\"]\\nexitValue = \" + oa.getExitValue() + \"\\n\");\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"}]}