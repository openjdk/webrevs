{"files":[{"patch":"@@ -40,3 +40,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -139,1 +136,1 @@\n-    private static void checkpointRestore1(long jcmdStream) throws\n+    private static List<String> checkpointRestore1(long jcmdStream) throws\n@@ -225,0 +222,5 @@\n+        assert !checkpointException.hasException() || !restoreException.hasException();\n+        checkpointException.throwIfAny();\n+        restoreException.throwIfAny();\n+\n+        final var parsedNewArguments = new ArrayList<String>();\n@@ -226,1 +228,1 @@\n-            \/\/ Parse arguments into array, unescape spaces\n+            \/\/ Parse arguments, unescape spaces\n@@ -229,1 +231,0 @@\n-            final var argList = new ArrayList<String>();\n@@ -235,1 +236,1 @@\n-                        argList.add(curArgBuilder.toString());\n+                        parsedNewArguments.add(curArgBuilder.toString());\n@@ -242,26 +243,1 @@\n-            argList.add(curArgBuilder.toString());\n-\n-            final String[] args = argList.toArray(new String[argList.size()]);\n-            if (args.length > 0) {\n-                try {\n-                    Method newMain = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n-                       @Override\n-                       public Method run() throws Exception {\n-                           Class < ?> newMainClass = Class.forName(args[0], false,\n-                               ClassLoader.getSystemClassLoader());\n-                           Method newMain = newMainClass.getDeclaredMethod(\"main\",\n-                               String[].class);\n-                           newMain.setAccessible(true);\n-                           return newMain;\n-                       }\n-                    });\n-                    newMain.invoke(null,\n-                        (Object)Arrays.copyOfRange(args, 1, args.length));\n-                } catch (PrivilegedActionException |\n-                         InvocationTargetException |\n-                         IllegalAccessException e) {\n-                    assert !checkpointException.hasException() :\n-                        \"should not have new arguments\";\n-                    restoreException.handle(e);\n-                }\n-            }\n+            parsedNewArguments.add(curArgBuilder.toString());\n@@ -269,4 +245,1 @@\n-\n-        assert !checkpointException.hasException() || !restoreException.hasException();\n-        checkpointException.throwIfAny();\n-        restoreException.throwIfAny();\n+        return parsedNewArguments;\n@@ -297,0 +270,2 @@\n+        final List<String> newArguments;\n+\n@@ -312,1 +287,1 @@\n-                checkpointRestore1(jcmdStream);\n+                newArguments = checkpointRestore1(jcmdStream);\n@@ -321,0 +296,22 @@\n+\n+        \/\/ Launch the new main if requested\n+        if (!newArguments.isEmpty()) {\n+            final var newMainClassName = newArguments.getFirst();\n+            final var newMainArgs = newArguments.subList(1, newArguments.size()).toArray(String[]::new);\n+            try {\n+                final var newMainClass = Class.forName(newMainClassName, false, ClassLoader.getSystemClassLoader());\n+                final var newMain = newMainClass.getDeclaredMethod(\"main\", String[].class);\n+                newMain.setAccessible(true);\n+                newMain.invoke(null, (Object) newMainArgs);\n+            } catch (ReflectiveOperationException e) {\n+                \/\/ It is not uncommon for users to use this feature by accident\n+                \/\/ so the message should have a good explanation\n+                final var msg = \"Failed to execute the new main entry: \" +\n+                        \"new initial class = '\" + newMainClassName + \"', \" +\n+                        \"new main arguments = \" + Arrays.toString(newMainArgs) + \".\" +\n+                        \"Do not specify these if you just wish to continue the checkpointed execution.\";\n+                RestoreException ex = new RestoreException();\n+                ex.addSuppressed(new Exception(msg, e));\n+                throw ex;\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":35,"deletions":38,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n- * CA 94089 USA or visit www.azul.com if you need additional information or\n- * have any questions.\n- *\/\n-\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-\n-import java.io.IOException;\n-import java.util.Arrays;\n-\n-\/*\n- * @test RestoreNewArgsTest\n- * @summary the test checks new args are propagated into a restored process.\n- * @library \/test\/lib\n- * @build RestoreNewArgsTest\n- * @run driver\/timeout=120 jdk.test.lib.crac.CracTest\n- * @requires (os.family == \"linux\")\n- *\/\n-public class RestoreNewArgsTest implements CracTest {\n-\n-    @Override\n-    public void test() throws Exception {\n-        final String MAIN_CLASS = \"RestoreNewArgsTest$InternalMain\";\n-        final String ARG0 = \"test arg\";\n-        final String ARG1 = \"\\\\ another\\\\ \\\"test\\\\\\\\arg \";\n-        final String ARG2 = \"  ano\\007ther  'yet  arg  \\\\\";\n-        CracBuilder builder = new CracBuilder().captureOutput(true);\n-        builder.doCheckpoint();\n-        builder.startRestoreWithArgs(null, Arrays.asList(MAIN_CLASS, ARG0, ARG1, ARG2))\n-            .waitForSuccess().outputAnalyzer()\n-            .shouldContain(\"RESTORED\")\n-            .shouldContain(\"Arg 0: \" + ARG0 + \".\")\n-            .shouldContain(\"Arg 1: \" + ARG1 + \".\")\n-            .shouldContain(\"Arg 2: \" + ARG2 + \".\");\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        jdk.crac.Core.checkpointRestore();\n-        System.out.println(\"RESTORED\");\n-    }\n-\n-    public class InternalMain {\n-        public static void main(String args[]) throws Exception {\n-            int i = 0;\n-            for (var arg : args) {\n-                System.out.println(\"Arg \" + i++ + \": \" + arg + \".\");\n-            }\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/jdk\/crac\/RestoreNewArgsTest.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import java.util.List;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test\n+ * @summary Checks that new args are parsed correctly.\n+ * @library \/test\/lib\n+ * @build ArgsParsingTest\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class ArgsParsingTest implements CracTest {\n+    private static final String NEW_MAIN_CLASS = \"ArgsParsingTest$InternalMain\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        final String ARG0 = \"test arg\";\n+        final String ARG1 = \"\\\\ another\\\\ \\\"test\\\\\\\\arg \";\n+        final String ARG2 = \"  ano\\007ther  'yet  arg  \\\\\";\n+        CracBuilder builder = new CracBuilder().captureOutput(true);\n+        builder.doCheckpoint();\n+        builder.startRestoreWithArgs(null, List.of(NEW_MAIN_CLASS, ARG0, ARG1, ARG2))\n+            .waitForSuccess().outputAnalyzer()\n+            .shouldContain(\"RESTORED\")\n+            .shouldContain(\"Arg 0: \" + ARG0 + \".\")\n+            .shouldContain(\"Arg 1: \" + ARG1 + \".\")\n+            .shouldContain(\"Arg 2: \" + ARG2 + \".\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        jdk.crac.Core.checkpointRestore();\n+        System.out.println(\"RESTORED\");\n+    }\n+\n+    public class InternalMain {\n+        public static void main(String[] args) {\n+            int i = 0;\n+            for (var arg : args) {\n+                System.out.println(\"Arg \" + i++ + \": \" + arg + \".\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/newArgs\/ArgsParsingTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import java.util.List;\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test\n+ * @summary It should be possible to C\/R in a new main.\n+ * @library \/test\/lib\n+ * @build CheckpointInNewMainTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class CheckpointInNewMainTest implements CracTest {\n+    private static final String NEW_MAIN_CLASS = \"CheckpointInNewMainTest$InternalMain\";\n+    private static final String RESTORE_OLD_MSG = \"RESTORED IN OLD MAIN\";\n+    private static final String RESTORE_NEW_MSG = \"RESTORED IN NEW MAIN\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        final var builder = new CracBuilder().captureOutput(true)\n+            \/\/ Disabling direct_map to be able to overwrite the first image,\n+            \/\/ otherwise the second image will depend on the first one and\n+            \/\/ we will get CRIU errors on the second restore\n+            .engine(CracEngine.CRIU).vmOption(\"-XX:CRaCEngineOptions=direct_map=false\");\n+\n+        \/\/ Checkpoint in the old main\n+        builder.doCheckpoint();\n+        \/\/ Restore from the old main and checkpoint in the new main\n+        builder.startRestoreWithArgs(null, List.of(NEW_MAIN_CLASS)).waitForCheckpointed();\n+        \/\/ Restore from the new main\n+        final var out = builder.doRestore().outputAnalyzer();\n+\n+        out.shouldContain(RESTORE_OLD_MSG).shouldContain(RESTORE_NEW_MSG);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+        System.out.println(RESTORE_OLD_MSG);\n+    }\n+\n+    public static class InternalMain {\n+        public static void main(String[] args) throws Exception {\n+            Core.checkpointRestore();\n+            System.out.println(RESTORE_NEW_MSG);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/newArgs\/CheckpointInNewMainTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import java.util.List;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @summary New main should run only if C\/R succeeds.\n+ * @library \/test\/lib\n+ * @build FailedCheckpointRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest SUCCESS\n+ * @run driver jdk.test.lib.crac.CracTest CHECKPOINT_EXCEPTION\n+ * @run driver jdk.test.lib.crac.CracTest RESTORE_EXCEPTION\n+ * @requires (os.family == \"linux\")\n+ *\/\n+public class FailedCheckpointRestoreTest implements CracTest {\n+    private static final String NEW_MAIN_CLASS = \"FailedCheckpointRestoreTest$InternalMain\";\n+    private static final String RESTORE_MSG = \"RESTORED\";\n+    private static final String NEW_MAIN_MSG = \"Hello from new main!\";\n+\n+    public enum Variant {\n+        SUCCESS,\n+        CHECKPOINT_EXCEPTION,\n+        RESTORE_EXCEPTION,\n+    };\n+\n+    @CracTestArg(0)\n+    Variant variant;\n+\n+    @Override\n+    public void test() throws Exception {\n+        final CracBuilder builder = new CracBuilder().captureOutput(true);\n+        final OutputAnalyzer out;\n+        if (variant == Variant.CHECKPOINT_EXCEPTION) {\n+            out = builder.startCheckpoint().waitForSuccess().outputAnalyzer();\n+        } else {\n+            builder.doCheckpoint();\n+            out = builder.startRestoreWithArgs(null, List.of(NEW_MAIN_CLASS))\n+                .waitForSuccess().outputAnalyzer();\n+        }\n+        if (variant == Variant.SUCCESS) {\n+            out.stdoutShouldContain(RESTORE_MSG).stdoutShouldContain(NEW_MAIN_MSG);\n+        } else {\n+            out.stdoutShouldNotContain(RESTORE_MSG).stdoutShouldNotContain(NEW_MAIN_MSG);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() {\n+        final var checkpointFail = \"Failing on checkpoint!\";\n+        final var restoreFail = \"Failing on restore!\";\n+\n+        final var failingResource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) {\n+                if (variant == Variant.CHECKPOINT_EXCEPTION) {\n+                    throw new RuntimeException(checkpointFail);\n+                }\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) {\n+                if (variant == Variant.RESTORE_EXCEPTION) {\n+                    throw new RuntimeException(restoreFail);\n+                }\n+            }\n+        };\n+        Core.getGlobalContext().register(failingResource);\n+\n+        try {\n+            Core.checkpointRestore();\n+            System.out.println(RESTORE_MSG);\n+        } catch (CheckpointException ex) {\n+            if (variant != Variant.CHECKPOINT_EXCEPTION) {\n+                throw new IllegalStateException(\"Unexpected checkpoint failure\", ex);\n+            }\n+            if (ex.getSuppressed().length != 1) {\n+                throw new IllegalStateException(\"Unexpected suppressions\", ex);\n+            }\n+            if (!checkpointFail.equals(ex.getSuppressed()[0].getMessage())) {\n+                throw new IllegalStateException(\"Unexpected suppression message\", ex);\n+            }\n+        } catch (RestoreException ex) {\n+            if (variant != Variant.RESTORE_EXCEPTION) {\n+                throw new IllegalStateException(\"Unexpected checkpoint failure\", ex);\n+            }\n+            if (ex.getSuppressed().length != 1) {\n+                throw new IllegalStateException(\"Unexpected suppressions\", ex);\n+            }\n+            if (!restoreFail.equals(ex.getSuppressed()[0].getMessage())) {\n+                throw new IllegalStateException(\"Unexpected suppression message\", ex);\n+            }\n+        }\n+    }\n+\n+    public static class InternalMain {\n+        public static void main(String[] args) {\n+            System.out.println(NEW_MAIN_MSG);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/newArgs\/FailedCheckpointRestoreTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}