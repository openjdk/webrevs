{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/jni\/jfrUpcalls.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"jfr\/periodic\/jfrOSInterface.hpp\"\n@@ -37,0 +39,2 @@\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -152,0 +156,26 @@\n+\n+void Jfr::before_checkpoint() {\n+  JfrOSInterface::before_checkpoint();\n+}\n+\n+void Jfr::after_restore() {\n+  const char *jfr_flag = \"StartFlightRecording\";\n+  JVMFlag *flag = JVMFlag::find_flag(jfr_flag);\n+  if (flag->get_origin() == JVMFlagOrigin::CRAC_RESTORE) {\n+    \/\/ -XX:StartFlightRecording passed on restore\n+    assert(JfrOptionSet::start_flight_recording_options() == nullptr, \"should have been released\");\n+    size_t buf_len = 4 + strlen(jfr_flag) + 1 + strlen(flag->get_ccstr()) + 1;\n+    ResourceMark rm;\n+    char *buf = NEW_RESOURCE_ARRAY(char, buf_len);\n+    snprintf(buf, buf_len, \"-XX:%s=%s\", jfr_flag, flag->get_ccstr());\n+    JavaVMOption option;\n+    option.optionString = buf;\n+    option.extraInfo = nullptr;\n+    const JavaVMOption *option_ptr = &option;\n+    JfrOptionSet::parse_start_flight_recording_option(&option_ptr, buf + 4 + strlen(jfr_flag));\n+    \/\/ We cannot invoke this directly now as DCmdStart command would be blocked\n+    \/\/ trying to register new file descriptors. Instead we just record a request and\n+    \/\/ the recording will be started at the right moment from JDKResource.\n+    JfrUpcalls::request_start_after_restore(JavaThread::current());\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+  static void before_checkpoint();\n+  static void after_restore();\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -433,0 +433,4 @@\n+\n+JVM_ENTRY_NO_ENV(void, jfr_start_after_restore(JNIEnv* env, jclass jvm))\n+  return JfrRecorder::start_after_restore();\n+JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,0 +170,2 @@\n+void JNICALL jfr_start_after_restore(JNIEnv* env, jclass jvm);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-      (char*)\"nanosNow\", (char*)\"()J\", (void*)jfr_nanos_now\n+      (char*)\"nanosNow\", (char*)\"()J\", (void*)jfr_nanos_now,\n+      (char*)\"startFlightRecorderAfterRestore\", (char*)\"()V\", (void*)jfr_start_after_restore,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+static Symbol* request_start_after_restore_sym = nullptr;\n+static Symbol* request_start_after_restore_sig_sym = nullptr;\n@@ -63,0 +65,2 @@\n+    request_start_after_restore_sym = SymbolTable::new_permanent_symbol(\"requestStartAfterRestore\");\n+    request_start_after_restore_sig_sym = SymbolTable::new_permanent_symbol(\"()V\");\n@@ -211,0 +215,19 @@\n+\n+void JfrUpcalls::request_start_after_restore(TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  if (!initialize(THREAD)) {\n+    log_error(jfr, system)(\"JfrUpcall could not be initialized.\");\n+    return;\n+  }\n+  JavaValue result(T_VOID);\n+  const Klass* klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, CHECK);\n+  assert(klass != nullptr, \"invariant\");\n+  JfrJavaArguments args(&result, klass, request_start_after_restore_sym, request_start_after_restore_sig_sym);\n+  JfrJavaSupport::call_static(&args, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    ResourceMark rm(THREAD);\n+    log_error(jfr, system)(\"JfrUpcall failed for %s\", unhide_internal_types_sym->as_C_string());\n+    return;\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  static void request_start_after_restore(TRAPS);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,0 +92,8 @@\n+\n+  void before_checkpoint() {\n+    \/\/ SystemProcessInterface::SystemProcesses::ProcessIterator has an open FD\n+    \/\/ to \/proc directory - we need to close this before checkpoint.\n+    \/\/ _system_process_interfaces will be re-created on demand\n+    delete _system_process_interface;\n+    _system_process_interface = nullptr;\n+  }\n@@ -315,0 +323,6 @@\n+\n+void JfrOSInterface::before_checkpoint() {\n+  if (_instance != nullptr && _instance->_impl != nullptr) {\n+    return _instance->_impl->before_checkpoint();\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrOSInterface.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+\n+  static void before_checkpoint();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrOSInterface.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -466,0 +466,6 @@\n+\n+void JfrRecorder::start_after_restore() {\n+  JavaThread* const thread = JavaThread::current();\n+  validate_recording_options(thread);\n+  launch_command_line_recordings(thread);\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,0 +72,2 @@\n+\n+  static void start_after_restore();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"jfr\/jfr.hpp\"\n@@ -454,0 +455,2 @@\n+  JFR_ONLY(Jfr::before_checkpoint();)\n+\n@@ -473,0 +476,2 @@\n+  JFR_ONLY(Jfr::after_restore();)\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1935,1 +1935,1 @@\n-  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                    \\\n+  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr, RESTORE_SETTABLE,  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.crac.mirror.impl.OrderedContext;\n@@ -34,0 +35,1 @@\n+    private static JfrResource jfrResource = new JfrResource();\n@@ -50,0 +52,8 @@\n+    \/**\n+     * Called by jdk.jfr.internal.JVMUpcalls when native code requests to start flight recording\n+     * @param runnable\n+     *\/\n+    public static void setStartFlightRecorder(Runnable runnable) {\n+        jfrResource.setStartFlightRecorder(runnable);\n+    }\n+\n@@ -62,0 +72,3 @@\n+        \/\/ We use OrderedContext to not cause failure when PlatformRecorder tries to\n+        \/\/ register itself when the recording is started from JfrResource.\n+        JFR(new OrderedContext<>()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+package jdk.internal.crac;\n+\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+\n+class JfrResource implements JDKResource {\n+    private Runnable startRecording;\n+\n+    JfrResource() {\n+        Core.Priority.JFR.getContext().register(this);\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) {\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+        if (startRecording != null) {\n+            startRecording.run();\n+        }\n+    }\n+\n+    public void setStartFlightRecorder(Runnable runnable) {\n+        this.startRecording = runnable;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JfrResource.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -180,0 +180,1 @@\n+        jdk.jfr.internal,\n@@ -423,0 +424,1 @@\n+        jdk.jfr.internal,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -678,0 +678,5 @@\n+\n+    \/**\n+     * Starts recording based on -XX:StartFlightRecorder passed on restore.\n+     *\/\n+    public static native void startFlightRecorderAfterRestore();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.crac.Core;\n@@ -160,0 +161,7 @@\n+\n+    \/**\n+     * Called by the JVM when it is restored with a new -XX:StartFlightRecorder\n+     *\/\n+    static void requestStartAfterRestore() {\n+        Core.setStartFlightRecorder(JVM::startFlightRecorderAfterRestore);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.stream.Collectors;\n@@ -51,0 +52,4 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -76,0 +81,58 @@\n+    private JDKResource resource = new JDKResource() {\n+        private List<PlatformRecording> futureRecordings;\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            synchronized (PlatformRecorder.this) {\n+                ArrayList<PlatformRecording> copy = new ArrayList<>(recordings);\n+                futureRecordings = copy.stream().map(r -> {\n+                    \/\/ PlatformRecording has to have a matching Recording - otherwise we could not control those\n+                    \/\/ through jcmd\n+                    Recording rec = new Recording(r.getSettings());\n+                    PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(rec);\n+                    if (r.getName().equals(String.valueOf(r.getId()))) {\n+                        \/\/ default name == id, use the new id as name as well\n+                        rec.setName(String.valueOf(rec.getId()));\n+                    } else {\n+                        \/\/ custom name, keep it\n+                        rec.setName(r.getName());\n+                    }\n+                    rec.setToDisk(r.isToDisk());\n+                    rec.setSettings(r.getSettings());\n+                    pr.setDumpDirectory(r.getDumpDirectory());\n+                    try {\n+                        pr.setDestination(r.getDestination());\n+                    } catch (IOException e) {\n+                        \/\/ never thrown\n+                        Logger.log(JFR, ERROR, \"Cannot copy destination: \" + e.getMessage());\n+                    }\n+                    rec.setMaxAge(r.getMaxAge());\n+                    rec.setMaxSize(r.getMaxSize());\n+                    pr.setInternalDuration(r.getDuration());\n+                    rec.setDumpOnExit(r.getDumpOnExit());\n+                    pr.setFlushInterval(r.getFlushInterval());\n+                    return pr;\n+                }).collect(Collectors.toList());\n+                recordings.removeAll(futureRecordings);\n+                copy.forEach(r -> r.stop(\"Checkpoint\"));\n+                assert recordings.isEmpty();\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            synchronized (PlatformRecorder.this) {\n+                futureRecordings.forEach(r -> {\n+                    recordings.add(r);\n+                    try {\n+                        \/\/ We need to invoke WritableUserPath after restore to create the dump file.\n+                        \/\/ Since we're creating another WritableUserPath we can use the original specification\n+                        r.setDestination(new WriteableUserPath(r.getDestination().getPotentiallyMaliciousOriginal()));\n+                    } catch (IOException e) {\n+                        Logger.log(JFR, ERROR, \"Cannot reset recording destination: \" + e);\n+                    }\n+                    r.start();\n+                });\n+            }\n+        }\n+    };\n@@ -89,0 +152,2 @@\n+\n+        Core.Priority.JFR.getContext().register(resource);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -857,0 +857,4 @@\n+    SafePath getDumpDirectory() {\n+        return dumpDirectory;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+\/**\n+ * @test FlightRecorderCmdlineTest\n+ * @library \/test\/lib\n+ * @requires (os.family == \"linux\")\n+ * @build FlightRecorderTestBase\n+ * @build FlightRecorderCmdlineTest\n+ * @run driver jdk.test.lib.crac.CracTest true false\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ * @run driver jdk.test.lib.crac.CracTest true true\n+ *\n+ *\/\n+public class FlightRecorderCmdlineTest extends FlightRecorderTestBase implements CracTest {\n+    @CracTestArg(0)\n+    boolean beforeCheckpoint;\n+\n+    @CracTestArg(1)\n+    boolean afterRestore;\n+\n+    @Override\n+    public void test() throws Exception {\n+        File jfrOne = File.createTempFile(\"one\", \".jfr\");\n+        File jfrTwo = File.createTempFile(\"two\", \".jfr\");\n+        assertTrue(jfrOne.delete());\n+        assertTrue(jfrTwo.delete());\n+        CracBuilder cpBuilder = new CracBuilder();\n+        cpBuilder.vmOption(\"-Xlog:jfr=debug\");\n+        if (beforeCheckpoint) {\n+            cpBuilder.vmOption(\"-XX:StartFlightRecording=dumponexit=true,filename=\" + jfrOne);\n+        }\n+        cpBuilder.doCheckpoint();\n+        if (beforeCheckpoint) {\n+            assertRecording(jfrOne);\n+        }\n+        CracBuilder rsBuilder = new CracBuilder();\n+        if (afterRestore) {\n+            rsBuilder.vmOption(\"-XX:StartFlightRecording=dumponexit=true,filename=\" + jfrTwo);\n+        }\n+        rsBuilder.doRestore();\n+        if (beforeCheckpoint) {\n+            assertRecording(jfrOne);\n+        }\n+        if (afterRestore) {\n+            assertRecording(jfrTwo);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/jfr\/FlightRecorderCmdlineTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.File;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+\/**\n+ * @test FlightRecorderJcmdTest\n+ * @library \/test\/lib\n+ * @requires (os.family == \"linux\")\n+ * @build FlightRecorderTestBase\n+ * @build FlightRecorderJcmdTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\n+ *\/\n+public class FlightRecorderJcmdTest extends FlightRecorderTestBase implements CracTest {\n+    protected static final String TEST_STARTED = \"TEST STARTED\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        File jfr = File.createTempFile(\"flight\", \".jfr\");\n+        assertTrue(jfr.delete());\n+        CracBuilder builder = new CracBuilder().captureOutput(true);\n+        CracProcess first = builder.startCheckpoint();\n+        first.waitForStdout(TEST_STARTED);\n+        builder.runJcmd(String.valueOf(first.pid()), \"JFR.start\", \"name=xxx\", \"dumponexit=true\", \"filename=\" + jfr)\n+                .shouldHaveExitValue(0)\n+                .shouldContain(\"Started recording\");\n+        first.input().write('\\n');\n+        first.input().flush();\n+        first.waitForCheckpointed();\n+        assertRecording(jfr);\n+        CracProcess second = new CracBuilder().captureOutput(true).startRestore();\n+        second.waitForStdout(RESTORED_MESSAGE, false);\n+\n+        File jfrOther = File.createTempFile(\"other\", \".jfr\");\n+        assertTrue(jfrOther.delete());\n+        \/\/ CRIU restored with the same PID\n+        String restoredPid = String.valueOf(first.pid());\n+        builder.runJcmd(restoredPid, \"JFR.dump\", \"name=xxx\", \"filename=\" + jfrOther)\n+                .shouldHaveExitValue(0)\n+                .shouldContain(\"Dumped recording \\\"xxx\\\"\");\n+        assertRecording(jfrOther);\n+        second.input().write('\\n');\n+        second.input().flush();\n+        second.waitForSuccess();\n+        assertRecording(jfr);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(TEST_STARTED);\n+        System.in.read();\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+        System.in.read();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/jfr\/FlightRecorderJcmdTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.fail;\n+\n+abstract class FlightRecorderTestBase implements CracTest {\n+    protected static void assertRecording(File jfr) {\n+        assertTrue(jfr.exists());\n+        assertTrue(jfr.length() > 0);\n+        try (RecordingFile recordingFile = new RecordingFile(jfr.toPath())) {\n+            while (recordingFile.hasMoreEvents()) {\n+                recordingFile.readEvent();\n+            }\n+        } catch (IOException e) {\n+            fail(\"Cannot read JFR file\", e);\n+        }\n+        assertTrue(jfr.delete());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/jfr\/FlightRecorderTestBase.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -13,0 +13,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -130,0 +131,4 @@\n+        waitForStdout(str, true);\n+    }\n+\n+    public void waitForStdout(String str, boolean failOnUnexpected) throws InterruptedException {\n@@ -131,0 +136,1 @@\n+        AtomicReference<String> unexpected = new AtomicReference<>();\n@@ -134,2 +140,3 @@\n-            } else {\n-                throw new IllegalArgumentException(\"Unexpected input\");\n+            } else if (failOnUnexpected) {\n+                unexpected.set(line);\n+                latch.countDown();\n@@ -139,0 +146,4 @@\n+        String unexpectedLine = unexpected.get();\n+        if (unexpectedLine != null) {\n+            throw new IllegalArgumentException(unexpectedLine);\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"}]}