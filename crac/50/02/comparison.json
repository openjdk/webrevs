{"files":[{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.crac.CheckpointException;\n-import jdk.crac.Core;\n-import jdk.crac.RestoreException;\n-\n-class CheckpointRestore {\n-    static final String RESTORED_MESSAGE = \"Restored\";\n-\n-    public static void main(String[] args) throws CheckpointException, RestoreException {\n-        Core.checkpointRestore();\n-        System.out.println(RESTORED_MESSAGE);\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/CheckpointRestore.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.IOException;\n@@ -28,0 +29,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n@@ -31,1 +35,3 @@\n- * @run main\/othervm -XX:CREngine=simengine -XX:CRaCCheckpointTo=.\/cr -XX:+UnlockDiagnosticVMOptions -XX:+CRPrintResourcesOnCheckpoint DryRunTest\n+ * @library \/test\/lib\n+ * @build DryRunTest\n+ * @run driver jdk.test.lib.crac.CracTest\n@@ -33,1 +39,1 @@\n-public class DryRunTest {\n+public class DryRunTest implements CracTest {\n@@ -45,1 +51,8 @@\n-    static public void main(String[] args) throws Exception {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE).printResources(true)\n+                .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n","filename":"test\/jdk\/jdk\/crac\/DryRunTest.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.crac.CheckpointException;\n-import jdk.crac.RestoreException;\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Method;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.*;\n-import java.util.stream.Collectors;\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @build CheckpointRestore\n- * @run main FileDescriptorsCloseTest testCheckpointWithOpenFds\n- * @run main FileDescriptorsCloseTest testIgnoredFileDescriptors\n- *\/\n-public class FileDescriptorsCloseTest {\n-    private static final String EXTRA_FD_WRAPPER = Path.of(Utils.TEST_SRC, \"extra_fd_wrapper.sh\").toString();\n-\n-    public static void main(String[] args) throws Throwable {\n-        if (args.length < 1) {\n-            throw new IllegalArgumentException();\n-        }\n-        FileDescriptorsCloseTest.class.getMethod(args[0]).invoke(null);\n-    }\n-\n-    public static void testCheckpointWithOpenFds() throws Throwable {\n-        List<String> cmd = new ArrayList<>();\n-        cmd.add(EXTRA_FD_WRAPPER);\n-        cmd.add(JDKToolFinder.getJDKTool(\"java\"));\n-        cmd.add(\"-cp\");\n-        cmd.add(System.getProperty(\"java.class.path\"));\n-        cmd.add(\"-XX:CRaCCheckpointTo=.\/cr\");\n-        cmd.add(CheckpointRestore.class.getSimpleName());\n-        \/\/ Note that the process is killed after checkpoint\n-        ProcessTools.executeProcess(cmd.toArray(new String[0]))\n-                .shouldHaveExitValue(137);\n-\n-        ProcessTools.executeTestJvm(\"-XX:CRaCRestoreFrom=.\/cr\")\n-                .shouldHaveExitValue(0)\n-                .shouldContain(CheckpointRestore.RESTORED_MESSAGE);\n-    }\n-\n-    public static void testIgnoredFileDescriptors() throws Throwable {\n-        List<String> cmd = new ArrayList<>();\n-        cmd.add(EXTRA_FD_WRAPPER);\n-        cmd.addAll(Arrays.asList(\"-o\", \"43\", \"\/dev\/stdout\"));\n-        cmd.addAll(Arrays.asList(\"-o\", \"45\", \"\/dev\/urandom\"));\n-        cmd.add(JDKToolFinder.getJDKTool(\"java\"));\n-        cmd.add(\"-cp\");\n-        cmd.add(System.getProperty(\"java.class.path\"));\n-        cmd.add(\"-XX:CRaCCheckpointTo=.\/cr\");\n-        cmd.add(\"-XX:CRaCIgnoredFileDescriptors=43,\/dev\/null,44,\/dev\/urandom\");\n-        cmd.add(\"FileDescriptorsCloseTest$TestIgnoredDescriptors\");\n-        \/\/ Note that the process is killed after checkpoint\n-        ProcessTools.executeProcess(cmd.toArray(new String[0]))\n-                .shouldHaveExitValue(137);\n-\n-        ProcessTools.executeTestJvm(\"-XX:CRaCRestoreFrom=.\/cr\")\n-                .shouldHaveExitValue(0)\n-                .shouldContain(CheckpointRestore.RESTORED_MESSAGE);\n-    }\n-\n-    public static class TestIgnoredDescriptors {\n-        public static void main(String[] args) throws IOException, RestoreException, CheckpointException {\n-            try (var stream = Files.list(Path.of(\"\/proc\/self\/fd\"))) {\n-                Map<Integer, String> fds = stream.filter(Files::isSymbolicLink)\n-                        .collect(Collectors.toMap(\n-                                f -> Integer.parseInt(f.toFile().getName()),\n-                                f -> {\n-                                    try {\n-                                        return Files.readSymbolicLink(f).toFile().getAbsoluteFile().toString();\n-                                    } catch (IOException e) {\n-                                        throw new RuntimeException(e);\n-                                    }\n-                                }));\n-                if (fds.containsKey(42)) {\n-                    throw new IllegalStateException(\"Oh no, 42 was not supposed to be ignored\");\n-                } else if (!fds.containsKey(0) || !fds.containsKey(1) || !fds.containsKey(2)) {\n-                    throw new IllegalStateException(\"Missing standard I\/O? Available: \" + fds);\n-                } else if (!fds.containsKey(43)) {\n-                    throw new IllegalStateException(\"Missing FD 43\");\n-                } else if (!fds.containsValue(\"\/dev\/urandom\")) {\n-                    throw new IllegalStateException(\"Missing \/dev\/urandom\");\n-                }\n-            }\n-            CheckpointRestore.main(args);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/FileDescriptorsCloseTest.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2022-2023, Azul Systems, Inc. All rights reserved.\n@@ -25,0 +25,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n@@ -26,0 +29,1 @@\n+import java.io.File;\n@@ -28,0 +32,1 @@\n+import java.nio.file.Files;\n@@ -33,1 +38,2 @@\n- * @run main\/othervm -XX:CREngine=simengine -XX:CRaCCheckpointTo=.\/cr -XX:+UnlockDiagnosticVMOptions -XX:+CRPrintResourcesOnCheckpoint JarFileFactoryCacheTest\n+ * @build JarFileFactoryCacheTest\n+ * @run driver jdk.test.lib.crac.CracTest\n@@ -35,6 +41,21 @@\n-public class JarFileFactoryCacheTest {\n-    static public void main(String[] args) throws Exception {\n-        jdk.test.lib.util.JarUtils.createJarFile(\n-            Path.of(\"test.jar\"),\n-            Path.of(System.getProperty(\"test.src\")),\n-            \"test.txt\");\n+public class JarFileFactoryCacheTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE).printResources(true)\n+                .startCheckpoint().waitForSuccess();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Path temp = Files.createTempDirectory(JarFileFactoryCacheTest.class.getName());\n+        try {\n+            Files.writeString(temp.resolve(\"test.txt\"), \"test\\n\");\n+            jdk.test.lib.util.JarUtils.createJarFile(\n+                    Path.of(\"test.jar\"), temp, \"test.txt\");\n+        } finally {\n+            File testTxt = temp.resolve(\"test.txt\").toFile();\n+            if (testTxt.exists()) {\n+                assert testTxt.delete();\n+            }\n+            assert temp.toFile().delete();\n+        }\n@@ -46,1 +67,1 @@\n-            throw new AssertionError(\"wrong content\");\n+            throw new AssertionError(\"wrong content: \" + new String(content));\n@@ -49,0 +70,1 @@\n+        \/\/ Nulling the variables is actually necessary!\n","filename":"test\/jdk\/jdk\/crac\/JarFileFactoryCacheTest\/JarFileFactoryCacheTest.java","additions":31,"deletions":9,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-test\n","filename":"test\/jdk\/jdk\/crac\/JarFileFactoryCacheTest\/test.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"deleted"},{"patch":"@@ -25,2 +25,3 @@\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n@@ -31,1 +32,2 @@\n- * @run main LazyProps\n+ * @build LazyProps\n+ * @run driver jdk.test.lib.crac.CracTest\n@@ -33,17 +35,18 @@\n-public class LazyProps {\n-    static public void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            OutputAnalyzer output = ProcessTools.executeTestJvm(\n-                    \"-XX:CREngine=simengine\", \"-XX:CRaCCheckpointTo=.\/cr\",\n-                    \"LazyProps\",\n-                    \"-runTest\");\n-            output.shouldHaveExitValue(0);\n-            output.shouldContain(\"jdk.crac beforeCheckpoint\");\n-        } else {\n-            Resource resource = new Resource() {\n-                @Override\n-                public void beforeCheckpoint(Context<? extends Resource> context) throws Exception { }\n-                @Override\n-                public void afterRestore(Context<? extends Resource> context) throws Exception { }\n-            };\n-            Core.getGlobalContext().register(resource);\n+public class LazyProps implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE)\n+                .captureOutput(true)\n+                .startCheckpoint().waitForSuccess()\n+                .outputAnalyzer().shouldContain(\"jdk.crac beforeCheckpoint\");\n+    }\n+\n+    @Override\n+    public void exec() throws RestoreException, CheckpointException {\n+        Resource resource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception { }\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception { }\n+        };\n+        Core.getGlobalContext().register(resource);\n@@ -51,3 +54,2 @@\n-            System.setProperty(\"jdk.crac.debug\", \"true\");\n-            Core.checkpointRestore();\n-        }\n+        System.setProperty(\"jdk.crac.debug\", \"true\");\n+        Core.checkpointRestore();\n","filename":"test\/jdk\/jdk\/crac\/LazyProps.java","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -26,2 +26,4 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n+import jdk.crac.*;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n@@ -32,2 +34,2 @@\n- * @build CheckpointRestore\n- * @run main LeaveRunning\n+ * @build LeaveRunning\n+ * @run driver jdk.test.lib.crac.CracTest\n@@ -35,21 +37,8 @@\n-public class LeaveRunning {\n-    public static void main(String[] args) {\n-        OutputAnalyzer output;\n-        try {\n-            ProcessBuilder pb = ProcessTools.createTestJvm(\n-                \"-XX:CRaCCheckpointTo=.\/cr\", CheckpointRestore.class.getSimpleName());\n-            pb.environment().put(\"CRAC_CRIU_LEAVE_RUNNING\", \"\");\n-            output = ProcessTools.executeProcess(pb);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        output.shouldHaveExitValue(0);\n-        output.shouldContain(CheckpointRestore.RESTORED_MESSAGE);\n-\n-        try {\n-            output = ProcessTools.executeTestJvm(\n-                \"-XX:CRaCRestoreFrom=.\/cr\");\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n+public class LeaveRunning implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().env(\"CRAC_CRIU_LEAVE_RUNNING\", \"\")\n+                .captureOutput(true);\n+        builder.startCheckpoint().waitForSuccess().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+        builder.doRestore().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n@@ -57,2 +46,4 @@\n-        output.shouldHaveExitValue(0);\n-        output.shouldContain(CheckpointRestore.RESTORED_MESSAGE);\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n","filename":"test\/jdk\/jdk\/crac\/LeaveRunning.java","additions":18,"deletions":27,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n@@ -30,1 +33,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -32,1 +34,0 @@\n-import java.lang.management.ManagementFactory;\n@@ -37,0 +38,2 @@\n+import static jdk.test.lib.Asserts.assertLT;\n+\n@@ -40,1 +43,2 @@\n- * @run main MXBean\n+ * @build MXBean\n+ * @run driver jdk.test.lib.crac.CracTest\n@@ -42,1 +46,1 @@\n-public class MXBean {\n+public class MXBean implements CracTest {\n@@ -45,3 +49,3 @@\n-    static class Test {\n-        public static void main(String[] args) throws CheckpointException, RestoreException {\n-            CRaCMXBean cracMXBean = CRaCMXBean.getCRaCMXBean();\n+    @Override\n+    public void exec() throws CheckpointException, RestoreException {\n+        CRaCMXBean cracMXBean = CRaCMXBean.getCRaCMXBean();\n@@ -49,1 +53,1 @@\n-            Core.checkpointRestore();\n+        Core.checkpointRestore();\n@@ -51,1 +55,1 @@\n-            System.out.println(\"UptimeSinceRestore \" + cracMXBean.getUptimeSinceRestore());\n+        System.out.println(\"UptimeSinceRestore \" + cracMXBean.getUptimeSinceRestore());\n@@ -53,6 +57,5 @@\n-            long restoreTime = cracMXBean.getRestoreTime();\n-            System.out.println(\"RestoreTime \" + restoreTime + \" \" +\n-                DateTimeFormatter.ofPattern(\"E dd LLL yyyy HH:mm:ss.n\").format(\n-                    Instant.ofEpochMilli(restoreTime)\n-                        .atZone(ZoneId.systemDefault())));\n-        }\n+        long restoreTime = cracMXBean.getRestoreTime();\n+        System.out.println(\"RestoreTime \" + restoreTime + \" \" +\n+            DateTimeFormatter.ofPattern(\"E dd LLL yyyy HH:mm:ss.n\").format(\n+                Instant.ofEpochMilli(restoreTime)\n+                    .atZone(ZoneId.systemDefault())));\n@@ -61,1 +64,2 @@\n-    public static void main(String[] args) {\n+    @Override\n+    public void test() throws Exception {\n@@ -64,10 +68,3 @@\n-        OutputAnalyzer output;\n-        try {\n-            output = ProcessTools.executeTestJvm(\n-                \"-XX:CREngine=simengine\", \"-XX:CRaCCheckpointTo=.\/cr\",\n-                \"MXBean$Test\");\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-\n-        output.shouldHaveExitValue(0);\n+        OutputAnalyzer output = new CracBuilder().engine(CracEngine.SIMULATE)\n+                .captureOutput(true)\n+                .startCheckpoint().waitForSuccess().outputAnalyzer();\n@@ -83,3 +80,1 @@\n-        if (restoreTime < -TIME_TOLERANCE || TIME_TOLERANCE < restoreTime) {\n-            throw new Error(\"bad RestoreTime: \" + restoreTime);\n-        }\n+        assertLT(Math.abs(restoreTime), TIME_TOLERANCE, \"bad RestoreTime: \" + restoreTime);\n","filename":"test\/jdk\/jdk\/crac\/MXBean.java","additions":24,"deletions":29,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n@@ -31,3 +34,3 @@\n- * The test will inherit FD with asmtools open and checkpoint would complain; as a workaround we'll add this to classpath\n- * @library ${jtreg.home}\/lib\/asmtools.jar\n- * @run main\/othervm -XX:CREngine=simengine -XX:CRaCCheckpointTo=.\/cr RefQueueTest\n+ * @library \/test\/lib\n+ * @build RefQueueTest\n+ * @run driver jdk.test.lib.crac.CracTest\n@@ -35,1 +38,1 @@\n-public class RefQueueTest {\n+public class RefQueueTest implements CracTest {\n@@ -38,1 +41,5 @@\n-    static public void main(String[] args) throws Exception {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().engine(CracEngine.SIMULATE)\n+                .startCheckpoint().waitForSuccess();\n+    }\n@@ -40,0 +47,2 @@\n+    @Override\n+    public void exec() throws Exception {\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n-import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n@@ -26,4 +27,1 @@\n-public class RestoreEnvironmentTest {\n-    static public void main(String[] args) throws Exception {\n-        {\n-            String testVarName = \"RESTORE_ENVIRONMENT_TEST_VAR\";\n+import java.io.IOException;\n@@ -31,4 +29,34 @@\n-            for (int i = 0; i < 3; ++i) {\n-                var testVar = java.lang.System.getenv(testVarName + i);\n-                System.out.println(\"(before checkpoint) \" + testVarName + i + \"=\" + testVar);\n-            }\n+\/*\n+ * @test RestoreEnvironmentTest\n+ * @summary the test checks that actual environment variables are propagated into a restored process.\n+ * @library \/test\/lib\n+ * @build RestoreEnvironmentTest\n+ * @run driver\/timeout=120 jdk.test.lib.crac.CracTest\n+ *\/\n+public class RestoreEnvironmentTest implements CracTest {\n+    static final String TEST_VAR_NAME = \"RESTORE_ENVIRONMENT_TEST_VAR\";\n+    static final String BEFORE_CHECKPOINT = \"BeforeCheckpoint\";\n+    static final String AFTER_RESTORE = \"AfterRestore\";\n+    static final String NEW_VALUE = \"NewValue\";\n+    public static final String PREFIX = \"(after restore) \";\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().captureOutput(true)\n+                .env(TEST_VAR_NAME + 0, BEFORE_CHECKPOINT)\n+                .env(TEST_VAR_NAME + 1, BEFORE_CHECKPOINT);\n+        builder.doCheckpoint();\n+        builder.env(TEST_VAR_NAME + 1, AFTER_RESTORE);\n+        builder.env(TEST_VAR_NAME + 2, NEW_VALUE);\n+        builder.doRestore().outputAnalyzer()\n+                .shouldContain(PREFIX + TEST_VAR_NAME + \"0=\" + BEFORE_CHECKPOINT)\n+                .shouldContain(PREFIX + TEST_VAR_NAME + \"1=\" + AFTER_RESTORE)\n+                .shouldContain(PREFIX + TEST_VAR_NAME + \"2=\" + NEW_VALUE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        for (int i = 0; i < 3; ++i) {\n+            var testVar = java.lang.System.getenv(TEST_VAR_NAME + i);\n+            System.out.println(\"(before checkpoint) \" + TEST_VAR_NAME + i + \"=\" + testVar);\n+        }\n@@ -36,1 +64,1 @@\n-            jdk.crac.Core.checkpointRestore();\n+        jdk.crac.Core.checkpointRestore();\n@@ -38,5 +66,3 @@\n-            System.out.print(\"(after restore) \");\n-            for (int i = 0; i < 3; ++i) {\n-                var testVar = java.lang.System.getenv(testVarName + i);\n-                System.out.print(testVarName + i + \"=\" + testVar + \";\");\n-            }\n+        for (int i = 0; i < 3; ++i) {\n+            var testVar = java.lang.System.getenv(TEST_VAR_NAME + i);\n+            System.out.println(PREFIX + TEST_VAR_NAME + i + \"=\" + testVar + \"\");\n@@ -44,1 +70,0 @@\n-        System.out.println();\n","filename":"test\/jdk\/jdk\/crac\/RestoreEnvironmentTest.java","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-##\n-## @test RestoreEnvironmentTest.sh\n-## @summary the test checks that actual environment variables are propagated into a restored process.\n-## @compile RestoreEnvironmentTest.java\n-## @run shell\/timeout=120 RestoreEnvironmentTest.sh\n-##\n-\n-set -x\n-\n-CHECKPOINT_DIR=cr_dir\n-BEFORE=BeforeCheckpoint\n-AFTER=AfterRestore\n-NEWVAL=NewValue\n-\n-echo CHECKPOINT_DIR=$CHECKPOINT_DIR\n-rm -rf CHECKPOINT_DIR\n-\n-echo === Checkpointing...\n-export RESTORE_ENVIRONMENT_TEST_VAR0=$BEFORE\n-export RESTORE_ENVIRONMENT_TEST_VAR1=$BEFORE\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$CHECKPOINT_DIR RestoreEnvironmentTest\n-\n-echo === Restoring...\n-export RESTORE_ENVIRONMENT_TEST_VAR1=$AFTER\n-RESULT=`RESTORE_ENVIRONMENT_TEST_VAR2=$NEWVAL ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCRestoreFrom=$CHECKPOINT_DIR`\n-\n-EXPECTED=\"(after restore) RESTORE_ENVIRONMENT_TEST_VAR0=$BEFORE;RESTORE_ENVIRONMENT_TEST_VAR1=$AFTER;RESTORE_ENVIRONMENT_TEST_VAR2=$NEWVAL;\"\n-echo RESULT=$RESULT\n-echo EXPECTED=$EXPECTED\n-if [ \"$EXPECTED\" != \"$RESULT\" ]; then\n-    echo FAILED\n-    exit 1\n-fi\n-echo PASSED\n","filename":"test\/jdk\/jdk\/crac\/RestoreEnvironmentTest.sh","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -0,0 +1,167 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.IOException;\n+import java.security.SecureRandom;\n+\n+\/*\n+ * @test\n+ * @summary Verify that secure random is not interlocked during checkpoint\/restore.\n+ * @library \/test\/lib\n+ * @build InterlockTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest SHA1PRNG 100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest NativePRNGBlocking 100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest NativePRNGNonBlocking 100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest NativePRNG 100\n+ *\/\n+public class InterlockTest implements Resource, CracTest {\n+    private static final long MIN_TIMEOUT = 100;\n+    private static final long MAX_TIMEOUT = 1000;\n+\n+    private boolean stop = false;\n+    private SecureRandom sr;\n+\n+    @CracTestArg(0)\n+    String algName;\n+\n+    @CracTestArg(1)\n+    int numThreads;\n+\n+    private class TestThread1 extends Thread {\n+        @Override\n+        public void run() {\n+            while (!stop) {\n+                set();\n+            }\n+        }\n+    };\n+\n+    private class TestThread2 extends Thread implements Resource {\n+        private final SecureRandom sr;\n+\n+        synchronized void set() {\n+            sr.nextInt();\n+        }\n+        synchronized void clean() {\n+            sr.nextInt();\n+        }\n+\n+        TestThread2() throws Exception {\n+            sr = SecureRandom.getInstance(algName);\n+            Core.getGlobalContext().register(this);\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!stop) {\n+                set();\n+            }\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            clean();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            set();\n+        }\n+    };\n+\n+    synchronized void clean() {\n+        sr.nextInt();\n+    }\n+\n+    synchronized void set() {\n+        sr.nextInt();\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        try {\n+            clean();\n+        } catch(Exception e) {\n+            e.printStackTrace(System.out);\n+        };\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        set();\n+        stop = true;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        CracTest.run(InterlockTest.class, args);\n+    }\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        sr = SecureRandom.getInstance(algName);\n+        Core.getGlobalContext().register(this);\n+\n+        Thread[] threads = new Thread[numThreads];\n+        for(int i = 0; i < numThreads; i++) {\n+            threads[i] = (i % 2 == 0) ?\n+                    new TestThread1():\n+                    new TestThread2();\n+            threads[i].start();\n+        };\n+        Thread.sleep(MIN_TIMEOUT);\n+        set();\n+        Thread.sleep(MIN_TIMEOUT);\n+\n+        Object checkpointLock = new Object();\n+        Thread checkpointThread = new Thread(\"checkpointThread\") {\n+            public void run() {\n+                synchronized (checkpointLock) {\n+                    try {\n+                        jdk.crac.Core.checkpointRestore();\n+                    } catch (CheckpointException e) {\n+                        throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+                    } catch (RestoreException e) {\n+                        throw new RuntimeException(\"Restore ERROR \" + e);\n+                    }\n+                    checkpointLock.notify();\n+                }\n+            }\n+        };\n+        synchronized (checkpointLock) {\n+            try {\n+                checkpointThread.start();\n+                checkpointLock.wait(MAX_TIMEOUT * 2);\n+            } catch(Exception e){\n+                throw new RuntimeException(\"Checkpoint\/Restore ERROR \" + e);\n+            }\n+        }\n+        Thread.sleep(MAX_TIMEOUT);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/InterlockTest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.security.SecureRandom;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertNotEquals;\n+\n+\/*\n+ * @test\n+ * @summary Verify that SHA1PRNG secure random is reseeded after restore if initialized with default seed.\n+ * @library \/test\/lib\n+ * @build ReseedTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest true\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest false\n+ *\/\n+public class ReseedTest implements CracTest {\n+    @CracTestArg\n+    boolean reseed;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.doCheckpoint();\n+        int e1 = builder.startRestore().waitFor();\n+        int e2 = builder.startRestore().waitFor();\n+        if (reseed) {\n+            assertEquals(e1, e2);\n+        } else {\n+            assertNotEquals(e1, e2);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n+        if (reseed) {\n+            sr.setSeed(sr.generateSeed(10));\n+        }\n+        sr.nextInt();\n+\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            e.printStackTrace(System.out);\n+            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+        } catch (RestoreException e) {\n+            throw new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+\n+        int r = sr.nextInt(255);\n+        System.exit(r);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/ReseedTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -1,160 +0,0 @@\n-\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-\n-import jdk.crac.*;\n-import java.util.Random;\n-import java.security.SecureRandom;\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-public class Test implements Resource {\n-\n-    private static final AtomicLong counter = new AtomicLong(0);\n-    private static boolean stop = false;\n-    private static final long MIN_TIMEOUT = 100;\n-    private static final long MAX_TIMEOUT = 1000;\n-    private static SecureRandom sr;\n-    private static String algName = null;\n-\n-    private static class TestThread1 extends Thread {\n-        private long timeout;\n-\n-        TestThread1(long timeout) {\n-            this.timeout = timeout;\n-        }\n-\n-        @Override\n-        public void run() {\n-            while (!stop) {\n-                Test.set();\n-            }\n-        }\n-    };\n-\n-    private static class TestThread2 extends Thread implements Resource {\n-        private long timeout;\n-        private SecureRandom sr;\n-\n-        synchronized void set() {\n-            sr.nextInt();\n-        }\n-        synchronized void clean() {\n-            sr.nextInt();\n-        }\n-\n-        TestThread2(long timeout) throws Exception {\n-            this.timeout = timeout;\n-            sr = SecureRandom.getInstance(algName);\n-            Core.getGlobalContext().register(this);\n-        }\n-\n-        @Override\n-        public void run() {\n-            while (!stop) {\n-                set();\n-            }\n-        }\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            clean();\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-            set();\n-        }\n-    };\n-\n-    synchronized static void clean() {\n-        sr.nextInt();\n-    }\n-\n-    synchronized static void set() {\n-        sr.nextInt();\n-    }\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        try {\n-            clean();\n-        } catch(Exception e) {\n-            e.printStackTrace(System.out);\n-        };\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws Exception {\n-        set();\n-        stop = true;\n-    }\n-\n-    public static void main(String args[]) throws Exception {\n-        if (args.length < 1) { throw new RuntimeException(\"Alg name is not provided\"); }\n-        if (args.length < 2) { throw new RuntimeException(\"number of threads is missing\"); }\n-        algName = args[0];\n-        int numThreads;\n-        try{\n-            numThreads = Integer.parseInt(args[1]);\n-        } catch (NumberFormatException ex){\n-            throw new RuntimeException(\"invalid number of threads\");\n-        }\n-        Test test = new Test();\n-        test.sr = SecureRandom.getInstance(algName);\n-        Core.getGlobalContext().register(test);\n-\n-        Random random = new Random();\n-        Thread[] threads = new Thread[numThreads];\n-        for(int i=0; i<numThreads; i++) {\n-            threads[i] = (i%2==0)?\n-                    new TestThread1(random.nextLong(MAX_TIMEOUT - MIN_TIMEOUT) + MIN_TIMEOUT):\n-                    new TestThread2(random.nextLong(MAX_TIMEOUT - MIN_TIMEOUT) + MIN_TIMEOUT);\n-            threads[i].start();\n-        };\n-        Thread.currentThread().sleep(MIN_TIMEOUT);\n-        set();\n-        Thread.currentThread().sleep(MIN_TIMEOUT);\n-\n-        Object checkpointLock = new Object();\n-        Thread checkpointThread = new Thread(\"checkpointThread\") {\n-            public void run() {\n-                synchronized (checkpointLock) {\n-                    try {\n-                        jdk.crac.Core.checkpointRestore();\n-                    } catch (CheckpointException e) {\n-                        throw new RuntimeException(\"Checkpoint ERROR \" + e);\n-                    } catch (RestoreException e) {\n-                        throw new RuntimeException(\"Restore ERROR \" + e);\n-                    }\n-                    checkpointLock.notify();\n-                }\n-            }\n-        };\n-        synchronized (checkpointLock) {\n-            try {\n-                checkpointThread.start();\n-                checkpointLock.wait(MAX_TIMEOUT * 2);\n-            } catch(Exception e){\n-                throw new RuntimeException(\"Checkpoint\/Restore ERROR \" + e);\n-            }\n-        }\n-        Thread.currentThread().sleep(MAX_TIMEOUT);\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test.java","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary verify that secure random is not interlocked during checkpoint\/restore\n-## @compile Test.java\n-## @run shell\/timeout=60 Test.sh\n-##\n-\n-set -x\n-\n-AlgNames=\"SHA1PRNG NativePRNGBlocking NativePRNGNonBlocking NativePRNG\"\n-for alg in $AlgNames; do\n-set +e\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test $alg 100\n-e=$?\n-\n-set -e\n-[ $e -eq 137 ]\n-\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCRestoreFrom=cr\n-\n-echo PASSED\n-done\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test.sh","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-\n-import jdk.crac.*;\n-import java.security.SecureRandom;\n-\n-public class Test1 {\n-\n-    private static SecureRandom sr;\n-\n-    public static void main(String args[]) throws Exception {\n-        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n-        if (\"1\".equalsIgnoreCase(args[0])) {\n-            sr.setSeed(sr.generateSeed(10));\n-        }\n-        sr.nextInt();\n-\n-        try {\n-            jdk.crac.Core.checkpointRestore();\n-        } catch (CheckpointException e) {\n-            e.printStackTrace(System.out);\n-            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n-        } catch (RestoreException e) {\n-            throw new RuntimeException(\"Restore ERROR \" + e);\n-        }\n-\n-        int r = sr.nextInt(255);\n-        System.exit(r);\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test1.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test1.sh\n-## @summary verify that SHA1PRNG secure random is reseeded after restore if\n-##  initialized with default seed\n-## @compile Test1.java\n-## @run shell\/timeout=60 Test1.sh\n-##\n-\n-set -x\n-\n-set +e\n-for test in `seq 0 1`\n-do\n-\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test1 $test\n-    e=$?\n-\n-    [ $e -eq 137 ]\n-\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCRestoreFrom=cr\n-    e1=$?\n-\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCRestoreFrom=cr\n-    e2=$?\n-\n-    if [ $test = \"0\" ]; then\n-        if [ $e1 = $e2 ]; then\n-            echo FAILED\n-            exit 1\n-        fi\n-    else \n-        if [ $e1 != $e2 ]; then\n-            echo FAILED\n-            exit 1\n-        fi\n-    fi\n-done\n-echo PASSED\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test1.sh","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -0,0 +1,87 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+\n+import java.io.IOException;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.SocketChannel;\n+\n+class ChannelResource implements Resource {\n+\n+    public enum SelectionType {SELECT, SELECT_TIMEOUT, SELECT_NOW}\n+\n+    ;\n+\n+    private SocketChannel channel;\n+    private SelectionKey key;\n+    private Selector selector;\n+\n+    private final SelectionType selType;\n+\n+    public ChannelResource(SelectionType selType) {\n+        this.selType = selType;\n+        Core.getGlobalContext().register(this);\n+    }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_READ);\n+        this.selector = selector;\n+    }\n+\n+    @java.lang.Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+        channel.socket().close();\n+\n+        \/\/ causes the channel deregistration\n+        if (selType == SelectionType.SELECT_NOW) {\n+            selector.selectNow();\n+        } else if (selType == SelectionType.SELECT_TIMEOUT) {\n+            selector.select(500);\n+        } else {\n+            new Thread(new Runnable() {\n+                @java.lang.Override\n+                public void run() {\n+                    try {\n+                        Thread.sleep(1000);\n+                        selector.wakeup();\n+                    } catch (InterruptedException ie) {\n+                        throw new RuntimeException(ie);\n+                    }\n+                }\n+            }).start();\n+\n+            selector.select();\n+        }\n+    }\n+\n+    @java.lang.Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/ChannelResource.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -21,1 +21,0 @@\n-\n@@ -25,25 +24,24 @@\n-\n-class ChannelResource implements Resource {\n-\n-    public enum SelectionType {SELECT, SELECT_TIMEOUT, SELECT_NOW};\n-\n-    private SocketChannel channel;\n-    private SelectionKey  key;\n-    private Selector      selector;\n-\n-    private final SelectionType selType;\n-\n-    public ChannelResource(SelectionType selType) {\n-        this.selType = selType;\n-        Core.getGlobalContext().register(this);\n-    }\n-\n-    public void open() throws IOException {\n-        channel = SocketChannel.open();\n-        channel.configureBlocking(false);\n-    }\n-\n-    public void register(Selector selector) throws IOException {\n-        key = channel.register(selector, SelectionKey.OP_READ);\n-        this.selector = selector;\n-    }\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+\/*\n+ * @test Selector\/Test970\n+ * @summary a regression test for ZE-970 (\"a channel deregistration\n+ *          is locked depending on mutual order of selector and channel creation\")\n+ * @library \/test\/lib\n+ * @build ChannelResource\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_NOW false\n+ * @run driver jdk.test.lib.crac.CracTest SELECT true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT false\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT true\n+ * @run driver jdk.test.lib.crac.CracTest SELECT_TIMEOUT false\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg(0)\n+    ChannelResource.SelectionType selType;\n+\n+    @CracTestArg(1)\n+    boolean openSelectorAtFirst;\n@@ -52,22 +50,2 @@\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n-\n-        channel.socket().close();\n-\n-        \/\/ causes the channel deregistration\n-        if (selType == SelectionType.SELECT_NOW) {\n-            selector.selectNow();\n-        } else if (selType == SelectionType.SELECT_TIMEOUT) {\n-            selector.select(500);\n-        } else {\n-            new Thread(new Runnable() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        Thread.sleep(1000);\n-                        selector.wakeup();\n-                    } catch (InterruptedException ie) { throw new RuntimeException(ie); }\n-                }\n-            }).start();\n-\n-            selector.select();\n-        }\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n@@ -77,8 +55,1 @@\n-    public void afterRestore(Context<? extends Resource> context) {\n-    }\n-}\n-\n-\n-public class Test {\n-\n-    private static void Test(ChannelResource.SelectionType selType, boolean openSelectorAtFirst) throws Exception {\n+    public void exec() throws Exception {\n@@ -109,30 +80,0 @@\n-\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n-\n-        switch (args[0]) { \/\/ 1, 2: ZE-970\n-            case \"1\":\n-                Test(ChannelResource.SelectionType.SELECT_NOW, true);\n-                break;\n-            case \"2\":\n-                Test(ChannelResource.SelectionType.SELECT_NOW, false);\n-                break;\n-            case \"3\":\n-                Test(ChannelResource.SelectionType.SELECT, true);\n-                break;\n-            case \"4\":\n-                Test(ChannelResource.SelectionType.SELECT, false);\n-                break;\n-            case \"5\":\n-                Test(ChannelResource.SelectionType.SELECT_TIMEOUT, true);\n-                break;\n-            case \"6\":\n-                Test(ChannelResource.SelectionType.SELECT_TIMEOUT, false);\n-                break;\n-            default:\n-                throw new RuntimeException(\"invalid test number\");\n-        }\n-\n-    }\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.java","additions":27,"deletions":86,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary a regression test for ZE-970 (\"a channel deregistration\n-##          is locked depending on mutual order of selector and channel creation\")\n-## @compile Test.java\n-## @run shell\/timeout=120 Test.sh\n-##\n-\n-set -x\n-\n-for test in `seq 1 6`\n-do\n-\n-    IMGDIR=\"cr$test\"\n-\n-    set +e\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n-    e=$?\n-\n-    set -e\n-    [ $e -eq 137 ]\n-\n-    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR\n-\n-    echo \"PASSED $test\"\n-\n-done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.sh","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -21,0 +21,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n@@ -25,1 +28,31 @@\n-public class Test {\n+\/*\n+ * @test Selector\/interruptedSelection\n+ * @summary check that the thread blocked by Selector.select() could be properly woken up by an interruption\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  false false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false false false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true  true  true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false true  true\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg(0)\n+    boolean setTimeout;\n+\n+    @CracTestArg(1)\n+    boolean interruptBeforeCheckpoint;\n+\n+    @CracTestArg(2)\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n@@ -28,2 +61,2 @@\n-    private static void test(boolean setTimeout, boolean interruptBeforeCheckpoint, boolean skipCR) throws Exception {\n-\n+    @Override\n+    public void exec() throws Exception {\n@@ -72,30 +105,0 @@\n-\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n-\n-        switch (args[0]) {\n-            case \"1\":\n-                test(true, true, false);\n-                break;\n-            case \"2\":\n-                test(true, false, false);\n-                break;\n-            case \"3\":\n-                test(false, true, false);\n-                break;\n-            case \"4\":\n-                test(false, false, false);\n-                break;\n-            \/\/ 5, 6: skip C\/R\n-            case \"5\":\n-                test(true, true, true);\n-                break;\n-            case \"6\":\n-                test(false, true, true);\n-                break;\n-            default:\n-                throw new RuntimeException(\"invalid test number\");\n-        }\n-    }\n@@ -103,0 +106,1 @@\n+\n","filename":"test\/jdk\/jdk\/crac\/Selector\/interruptedSelection\/Test.java","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary check that the thread blocked by Selector.select() could be properly woken up by an interruption\n-## @compile Test.java\n-## @run shell\/timeout=120 Test.sh\n-##\n-\n-set -x\n-\n-for test in `seq 1 4`\n-do\n-\n-    IMGDIR=\"cr$test\"\n-\n-    set +e\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n-    e=$?\n-\n-    set -e\n-    [ $e -eq 137 ]\n-\n-    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR\n-\n-    echo \"PASSED $test\"\n-\n-done\n-\n-\n-\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 5\n-echo \"PASSED 5\"\n-\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 6\n-echo \"PASSED 6\"\n","filename":"test\/jdk\/jdk\/crac\/Selector\/interruptedSelection\/Test.sh","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -0,0 +1,176 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+import jdk.crac.Context;\n+import jdk.crac.Core;\n+import jdk.crac.Resource;\n+\n+import java.io.IOException;\n+import java.nio.channels.CancelledKeyException;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.SocketChannel;\n+\n+class ChannelResource implements Resource {\n+\n+    private SocketChannel channel;\n+    private SelectionKey key;\n+    private Selector selector;\n+\n+    private Object att = new Integer(123);\n+\n+    public ChannelResource() {\n+        Core.getGlobalContext().register(this);\n+    }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_CONNECT);\n+        key.attach(att);\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+        channel.socket().close(); \/\/ close the channel => cancel the key\n+        check(!channel.isOpen(), \"the channel should not be open\");\n+        selector.select(100); \/\/ causes the channel deregistration\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        \/\/ the key is cancelled\n+        check(!key.isValid(), \"expected: key.isValid() == false\");\n+\n+        boolean caught = false;\n+        try {\n+            key.readyOps();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.interestOps();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.interestOps(SelectionKey.OP_CONNECT);\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.readyOps();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isReadable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isWritable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isConnectable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try {\n+            key.isAcceptable();\n+        } catch (CancelledKeyException e) {\n+            caught = true;\n+        }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        check(att.equals(key.attachment()), \"invalid key.attachment()\");\n+\n+        key.cancel(); \/\/ try just in case\n+\n+        \/\/ register again\n+        try {\n+            channel = SocketChannel.open();\n+            channel.configureBlocking(false);\n+            key = channel.register(selector, SelectionKey.OP_READ);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ to check after restore\n+    public void checkKey() {\n+\n+        check(key.isValid(), \"key must be valid\");\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        key.isReadable(); \/\/ just call, cannot set \"ready\" state manually\n+        check(!key.isWritable(), \"invalid key.isWritable()\");\n+        check(!key.isConnectable(), \"invalid key.isConnectable()\");\n+        check(!key.isAcceptable(), \"invalid key.isAcceptable()\");\n+\n+        check(key.interestOps() == SelectionKey.OP_READ, \"invalid key.interestOps()\");\n+\n+        System.out.println(\">> ready >> \" + key.readyOps());\n+\n+        check(key.attachment() == null, \"key.attachment() expected to be null\");\n+\n+        key.cancel(); \/\/ try just in case\n+    }\n+\n+    private void check(boolean b, String msg) {\n+        if (!b) {\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/ChannelResource.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -21,1 +21,0 @@\n-\n@@ -25,21 +24,16 @@\n-\n-class ChannelResource implements Resource {\n-\n-    private SocketChannel channel;\n-    private SelectionKey  key;\n-    private Selector      selector;\n-\n-    private Object        att = new Integer(123);\n-\n-    public ChannelResource() { Core.getGlobalContext().register(this); }\n-\n-    public void open() throws IOException {\n-        channel = SocketChannel.open();\n-        channel.configureBlocking(false);\n-    }\n-\n-    public void register(Selector selector) throws IOException {\n-        key = channel.register(selector, SelectionKey.OP_CONNECT);\n-        key.attach(att);\n-        this.selector = selector;\n-    }\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+\/*\n+ * @test Selector\/keyAfterRestore\n+ * @summary a trivial test for SelectionKey's state after restore\n+ * @library \/test\/lib\n+ * @build ChannelResource\n+ * @build Test\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest false\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg\n+    boolean openSelectorAtFirst;\n@@ -48,5 +42,2 @@\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n-\n-        channel.socket().close(); \/\/ close the channel => cancel the key\n-        check(!channel.isOpen(), \"the channel should not be open\");\n-        selector.select(100); \/\/ causes the channel deregistration\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n@@ -56,91 +47,1 @@\n-    public void afterRestore(Context<? extends Resource> context) {\n-\n-        check(key.selector().equals(selector), \"invalid key.selector()\");\n-        check(key.channel().equals(channel), \"invalid key.channel()\");\n-\n-        \/\/ the key is cancelled\n-        check(!key.isValid(), \"expected: key.isValid() == false\");\n-\n-        boolean caught = false;\n-        try { key.readyOps(); }\n-        catch (CancelledKeyException e) { caught = true; }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try { key.interestOps(); }\n-        catch (CancelledKeyException e) { caught = true; }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try { key.interestOps(SelectionKey.OP_CONNECT); }\n-        catch (CancelledKeyException e) { caught = true; }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try { key.readyOps(); }\n-        catch (CancelledKeyException e) { caught = true; }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try { key.isReadable(); }\n-        catch (CancelledKeyException e) { caught = true; }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try { key.isWritable(); }\n-        catch (CancelledKeyException e) { caught = true; }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try { key.isConnectable(); }\n-        catch (CancelledKeyException e) { caught = true; }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        caught = false;\n-        try { key.isAcceptable(); }\n-        catch (CancelledKeyException e) { caught = true; }\n-        check(caught, \"expected CancelledKeyException is missing\");\n-\n-        check(att.equals(key.attachment()), \"invalid key.attachment()\");\n-\n-        key.cancel(); \/\/ try just in case\n-\n-        \/\/ register again\n-        try {\n-            channel = SocketChannel.open();\n-            channel.configureBlocking(false);\n-            key = channel.register(selector, SelectionKey.OP_READ);\n-        }\n-        catch (Exception e) { throw new RuntimeException(e); }\n-    }\n-\n-    \/\/ to check after restore\n-    public void checkKey() {\n-\n-        check(key.isValid(), \"key must be valid\");\n-\n-        check(key.selector().equals(selector), \"invalid key.selector()\");\n-        check(key.channel().equals(channel), \"invalid key.channel()\");\n-\n-        key.isReadable(); \/\/ just call, cannot set \"ready\" state manually\n-        check( !key.isWritable()   , \"invalid key.isWritable()\"   );\n-        check( !key.isConnectable(), \"invalid key.isConnectable()\");\n-        check( !key.isAcceptable() , \"invalid key.isAcceptable()\" );\n-\n-        check(key.interestOps() == SelectionKey.OP_READ, \"invalid key.interestOps()\");\n-\n-        System.out.println(\">> ready >> \" + key.readyOps());\n-\n-        check(key.attachment() == null, \"key.attachment() expected to be null\");\n-\n-        key.cancel(); \/\/ try just in case\n-    }\n-\n-    private void check(boolean b, String msg) { if (!b) { throw new RuntimeException(msg); } }\n-}\n-\n-\n-public class Test {\n-\n-    private static void test(boolean openSelectorAtFirst) throws Exception {\n-\n+    public void exec() throws Exception {\n@@ -173,17 +74,0 @@\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n-\n-        switch (args[0]) {\n-            case \"1\":\n-                test(true);\n-                break;\n-            case \"2\":\n-                test(false);\n-                break;\n-            default:\n-                throw new RuntimeException(\"invalid test number\");\n-        }\n-\n-    }\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.java","additions":19,"deletions":135,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary a trivial test for SelectionKey's state after restore\n-## @compile Test.java\n-## @run shell\/timeout=60 Test.sh\n-##\n-\n-set -x\n-\n-for test in `seq 1 2`\n-do\n-\n-    IMGDIR=\"cr$test\"\n-\n-    set +e\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n-    e=$?\n-\n-    set -e\n-    [ $e -eq 137 ]\n-\n-    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR\n-\n-    echo \"PASSED $test\"\n-\n-done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.sh","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -21,0 +21,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n@@ -28,2 +31,13 @@\n-\n-public class Test {\n+\/*\n+ * @test Selector\/multipleSelect\n+ * @summary check work of multiple select() + wakeup() + C\/R\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED false\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest ONLY_TIMEOUTS true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest NO_TIMEOUTS true\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest MIXED true\n+ *\/\n+public class Test implements CracTest {\n@@ -36,1 +50,1 @@\n-    public enum testType {\n+    public enum TestType {\n@@ -41,1 +55,18 @@\n-    private static void test(testType type, boolean skipCR) throws Exception {\n+    @CracTestArg(0)\n+    TestType type;\n+\n+    @CracTestArg(1)\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n@@ -43,1 +74,1 @@\n-        long dt = (type == testType.ONLY_TIMEOUTS) ? SHORT_TIMEOUT : LONG_TIMEOUT;\n+        long dt = (type == TestType.ONLY_TIMEOUTS) ? SHORT_TIMEOUT : LONG_TIMEOUT;\n@@ -45,1 +76,1 @@\n-        int nThreads = (type == testType.ONLY_TIMEOUTS) ? 5 : 20;\n+        int nThreads = (type == TestType.ONLY_TIMEOUTS) ? 5 : 20;\n@@ -56,2 +87,2 @@\n-            if (type == testType.ONLY_TIMEOUTS) { t = true; }\n-            else if (type == testType.MIXED) { t = RND.nextBoolean(); }\n+            if (type == TestType.ONLY_TIMEOUTS) { t = true; }\n+            else if (type == TestType.MIXED) { t = RND.nextBoolean(); }\n@@ -100,1 +131,1 @@\n-        if (type == testType.ONLY_TIMEOUTS) { \/\/ do not wake threads up, the timeouts must work\n+        if (type == TestType.ONLY_TIMEOUTS) { \/\/ do not wake threads up, the timeouts must work\n@@ -141,31 +172,0 @@\n-\n-\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n-\n-        switch (args[0]) {\n-            case \"1\":\n-                test(testType.ONLY_TIMEOUTS, false);\n-                break;\n-            case \"2\":\n-                test(testType.NO_TIMEOUTS, false);\n-                break;\n-            case \"3\":\n-                test(testType.MIXED, false);\n-                break;\n-            \/\/ 4-6: no C\/R\n-            case \"4\":\n-                test(testType.ONLY_TIMEOUTS, true);\n-                break;\n-            case \"5\":\n-                test(testType.NO_TIMEOUTS, true);\n-                break;\n-            case \"6\":\n-                test(testType.MIXED, true);\n-                break;\n-            default:\n-                throw new RuntimeException(\"invalid test number\");\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelect\/Test.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary check work of multiple select() + wakeup() + C\/R\n-## @compile Test.java\n-## @run shell\/timeout=240 Test.sh\n-##\n-\n-set -x\n-\n-for test in `seq 1 3`\n-do\n-\n-    IMGDIR=\"cr$test\"\n-\n-    set +e\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH}:$CPAPPEND -XX:CRaCCheckpointTo=$IMGDIR Test $test\n-    e=$?\n-\n-    set -e\n-    [ $e -eq 137 ]\n-\n-    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR\n-\n-    echo \"PASSED $test\"\n-\n-done\n-\n-# check conformity (no C\/R)\n-\n-set -e\n-for test in `seq 4 6`\n-do\n-\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test $test\n-    echo \"PASSED $test\"\n-\n-done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelect\/Test.sh","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -21,0 +21,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n@@ -27,0 +30,22 @@\n+\/*\n+ * @test Selector\/multipleSelectNow\n+ * @summary check work of multiple selectNow() + C\/R peaceful coexistence\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ *\/\n+public class Test implements CracTest {\n+\n+    @CracTestArg\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n@@ -28,4 +53,2 @@\n-public class Test {\n-\n-    private static void test(boolean skipCR) throws Exception {\n-\n+    @Override\n+    public void exec() throws Exception {\n@@ -88,18 +111,0 @@\n-\n-\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n-\n-        switch (args[0]) {\n-            case \"1\":\n-                test(false);\n-                break;\n-            case \"2\":\n-                test(true);\n-                break;\n-            default:\n-                throw new RuntimeException(\"invalid test number\");\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectNow\/Test.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary check work of multiple selectNow() + C\/R peaceful coexistence\n-## @compile Test.java\n-## @run shell\/timeout=120 Test.sh\n-##\n-\n-set -x\n-\n-set +e\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test 1\n-e=$?\n-\n-set -e\n-[ $e -eq 137 ]\n-\n-${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=cr\n-echo \"PASSED 1\"\n-\n-\n-# check conformity (no C\/R)\n-\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 2\n-echo \"PASSED 2\"\n-\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectNow\/Test.sh","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -21,0 +21,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n@@ -29,0 +32,11 @@\n+\/*\n+ * @test Selector\/multipleSelectSingleClose\n+ * @summary check a coexistence of multiple select() + C\/R in case when the selector is finally closed\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ * @run driver jdk.test.lib.crac.CracTest true  true\n+ *\/\n+public class Test implements CracTest {\n+    private final static Random RND = new Random();\n@@ -30,1 +44,2 @@\n-public class Test {\n+    @CracTestArg(0)\n+    boolean skipCR;\n@@ -32,1 +47,2 @@\n-    private final static Random RND = new Random();\n+    @CracTestArg(1)\n+    boolean closeBeforeCheckpoint;\n@@ -34,1 +50,9 @@\n-    private static void test(boolean skipCR, boolean closeBeforeCheckpoint) throws Exception {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n@@ -36,0 +60,2 @@\n+    @Override\n+    public void exec() throws Exception {\n@@ -101,21 +127,0 @@\n-\n-\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n-\n-        switch (args[0]) {\n-            case \"1\":\n-                test(false, false);\n-                break;\n-            case \"2\":\n-                test(false, true);\n-                break;\n-            case \"3\":\n-                test(true, true);\n-                break;\n-            default:\n-                throw new RuntimeException(\"invalid test number\");\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectSingleClose\/Test.java","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary check a coexistence of multiple select() + C\/R in case when the selector is finally closed\n-## @compile Test.java\n-## @run shell\/timeout=120 Test.sh\n-##\n-\n-set -x\n-\n-for test in `seq 1 2`\n-do\n-\n-    IMGDIR=\"cr$test\"\n-\n-    set +e\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n-    e=$?\n-\n-    set -e\n-    [ $e -eq 137 ]\n-\n-    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR\n-\n-    echo \"PASSED $test\"\n-\n-done\n-\n-\n-# check conformity (no C\/R)\n-\n-set -e\n-\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 3\n-echo \"PASSED 3\"\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectSingleClose\/Test.sh","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -21,0 +21,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n@@ -22,0 +25,1 @@\n+import java.io.IOException;\n@@ -24,0 +28,17 @@\n+\/*\n+ * @test Selector\/selectAfterWakeup\n+ * @summary check that the Selector's wakeup() makes the subsequent select() call to return immediately\n+ *          (see also jdk\/test\/java\/nio\/channels\/Selector\/WakeupSpeed.java);\n+ *          covers ZE-983\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest true  false false\n+ * @run driver jdk.test.lib.crac.CracTest true  false true\n+ * @run driver jdk.test.lib.crac.CracTest true  true  false\n+ * @run driver jdk.test.lib.crac.CracTest true  true  true\n+ * @run driver jdk.test.lib.crac.CracTest false true  false\n+ * @run driver jdk.test.lib.crac.CracTest false true  true\n+ *\/\n+public class Test implements CracTest {\n+    @CracTestArg(0)\n+    boolean wakeupBeforeCheckpoint;\n@@ -25,1 +46,2 @@\n-public class Test {\n+    @CracTestArg(1)\n+    boolean wakeupAfterRestore;\n@@ -27,3 +49,10 @@\n-    private static void test(boolean wakeupBeforeCheckpoint,\n-                             boolean wakeupAfterRestore,\n-                             boolean setSelectTimeout) throws Exception {\n+    @CracTestArg(2)\n+    boolean setSelectTimeout;\n+\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n@@ -51,29 +80,0 @@\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n-\n-        switch (args[0]) {\n-            case \"1\":\n-                test(true, false, false); \/\/ ZE-983\n-                break;\n-            case \"2\":\n-                test(true, false, true);\n-                break;\n-            case \"3\":\n-                test(true, true, false); \/\/ ZE-983\n-                break;\n-            case \"4\":\n-                test(true, true, true);\n-                break;\n-            case \"5\":\n-                test(false, true, false);\n-                break;\n-            case \"6\":\n-                test(false, true, true);\n-                break;\n-\n-            default:\n-                throw new RuntimeException(\"invalid test number\");\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAfterWakeup\/Test.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary check that the Selector's wakeup() makes the subsequent select() call to return immediately\n-##          (see also jdk\/test\/java\/nio\/channels\/Selector\/WakeupSpeed.java);\n-##          covers ZE-983\n-## @compile Test.java\n-## @run shell\/timeout=120 Test.sh\n-##\n-\n-set -x\n-\n-for test in `seq 1 6`\n-do\n-\n-    IMGDIR=\"cr$test\"\n-\n-    set +e\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n-    e=$?\n-\n-    set -e\n-    [ $e -eq 137 ]\n-\n-    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR\n-\n-    echo \"PASSED $test\"\n-\n-done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAfterWakeup\/Test.sh","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -21,0 +21,2 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n@@ -22,0 +24,1 @@\n+import java.io.IOException;\n@@ -24,1 +27,12 @@\n-public class Test {\n+\/*\n+ * @test Selector\/selectAndWakeupAfterRestore\n+ * @summary a trivial check that Selector.wakeup() after restore behaves as expected\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class Test implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n@@ -43,1 +57,2 @@\n-    public static void main(String args[]) throws Exception {\n+    @Override\n+    public void exec() throws Exception {\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAndWakeupAfterRestore\/Test.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary a trivial check that Selector.wakeup() after restore behaves as expected\n-## @compile Test.java\n-## @run shell\/timeout=60 Test.sh\n-##\n-\n-set -x\n-\n-set +e\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test\n-e=$?\n-\n-set -e\n-[ $e -eq 137 ]\n-\n-${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=cr\n-\n-echo PASSED\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAndWakeupAfterRestore\/Test.sh","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -21,0 +21,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n@@ -25,1 +28,9 @@\n-public class Test {\n+\/*\n+ * @test Selector\/wakeupAfterRestore\n+ * @summary check that the thread blocked by Selector.select() on checkpoint could be properly woken up after restore\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n+ *\/\n+public class Test implements CracTest {\n@@ -31,1 +42,2 @@\n-    private static void test(boolean setTimeout) throws Exception {\n+    @CracTestArg\n+    boolean setTimeout;\n@@ -33,0 +45,7 @@\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n@@ -70,19 +89,0 @@\n-\n-\n-\n-\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n-\n-        switch (args[0]) {\n-            case \"1\":\n-                test(true);\n-                break;\n-            case \"2\":\n-                test(false);\n-                break;\n-            default:\n-                throw new RuntimeException(\"invalid test number\");\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupAfterRestore\/Test.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary check that the thread blocked by Selector.select() on checkpoint could be properly woken up after restore\n-## @compile Test.java\n-## @run shell\/timeout=120 Test.sh\n-##\n-\n-set -x\n-\n-for test in `seq 1 2`\n-do\n-\n-    IMGDIR=\"cr$test\"\n-\n-    set +e\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n-    e=$?\n-\n-    set -e\n-    [ $e -eq 137 ]\n-\n-    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR\n-\n-    echo \"PASSED $test\"\n-\n-done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupAfterRestore\/Test.sh","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -21,0 +21,3 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n@@ -25,1 +28,11 @@\n-public class Test {\n+\/*\n+ * @test Selector\/wakeupByClose\n+ * @summary check that the Selector's close() wakes it up after restore\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest true  false\n+ * @run driver jdk.test.lib.crac.CracTest false false\n+ * @run driver jdk.test.lib.crac.CracTest true  true\n+ * @run driver jdk.test.lib.crac.CracTest false true\n+ *\/\n+public class Test implements CracTest {\n@@ -29,1 +42,2 @@\n-    private static void test(boolean setTimeout, boolean skipCR) throws Exception {\n+    @CracTestArg(0)\n+    boolean setTimeout;\n@@ -31,0 +45,15 @@\n+    @CracTestArg(1)\n+    boolean skipCR;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        if (skipCR) {\n+            builder.doPlain();\n+        } else {\n+            builder.doCheckpointAndRestore();\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n@@ -76,23 +105,0 @@\n-\n-    public static void main(String[] args) throws Exception {\n-\n-       if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n-\n-        switch (args[0]) {\n-            case \"1\":\n-                test(true, false);\n-                break;\n-            case \"2\":\n-                test(false, false);\n-                break;\n-            \/\/ 3, 4: skip C\/R\n-            case \"3\":\n-                test(true, true);\n-                break;\n-            case \"4\":\n-                test(false, true);\n-                break;\n-            default:\n-                throw new RuntimeException(\"invalid test number\");\n-        }\n-    }\n@@ -100,0 +106,1 @@\n+\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByClose\/Test.java","additions":32,"deletions":25,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary check that the Selector's close() wakes it up after restore\n-## @compile Test.java\n-## @run shell\/timeout=60 Test.sh\n-##\n-\n-\n-set -x\n-\n-for test in `seq 1 2`\n-do\n-\n-    IMGDIR=\"cr$test\"\n-\n-    set +e\n-    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n-    e=$?\n-\n-    set -e\n-    [ $e -eq 137 ]\n-\n-    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR\n-\n-    echo \"PASSED $test\"\n-\n-done\n-\n-\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 3\n-echo \"PASSED 3\"\n-\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 4\n-echo \"PASSED 4\"\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByClose\/Test.sh","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -21,0 +21,2 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n@@ -25,1 +27,9 @@\n-public class Test {\n+\/*\n+ * @test Selector\/wakeupByTimeoutAfterRestore\n+ * @summary check that the Selector selected before the checkpoint,\n+ *          will wake up by timeout after the restore\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class Test implements CracTest {\n@@ -31,1 +41,4 @@\n-    public static void main(String args[]) throws Exception {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n@@ -33,0 +46,2 @@\n+    @Override\n+    public void exec() throws Exception {\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByTimeoutAfterRestore\/Test.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary check that the Selector selected before the checkpoint,\n-##          will wake up by timeout after the restore\n-## @compile Test.java\n-## @run shell\/timeout=120 Test.sh\n-##\n-\n-set -x\n-\n-set +e\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test\n-e=$?\n-\n-set -e\n-[ $e -eq 137 ]\n-\n-${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=cr\n-\n-echo PASSED\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByTimeoutAfterRestore\/Test.sh","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build CheckpointWithOpenFdsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CheckpointWithOpenFdsTest implements CracTest {\n+    private static final String EXTRA_FD_WRAPPER = Path.of(Utils.TEST_SRC, \"extra_fd_wrapper.sh\").toString();\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.startCheckpoint(Arrays.asList(EXTRA_FD_WRAPPER, CracBuilder.JAVA)).waitForCheckpointed();\n+        builder.captureOutput(true).doRestore().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CheckpointWithOpenFdsTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build IgnoredFileDescriptorsTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class IgnoredFileDescriptorsTest implements CracTest {\n+    private static final String EXTRA_FD_WRAPPER = Path.of(Utils.TEST_SRC, \"extra_fd_wrapper.sh\").toString();\n+\n+    @Override\n+    public void test() throws Exception {\n+        List<String> prefix = new ArrayList<>();\n+        prefix.add(EXTRA_FD_WRAPPER);\n+        prefix.addAll(Arrays.asList(\"-o\", \"43\", \"\/dev\/stdout\"));\n+        prefix.addAll(Arrays.asList(\"-o\", \"45\", \"\/dev\/urandom\"));\n+        prefix.add(CracBuilder.JAVA);\n+        prefix.add(\"-XX:CRaCIgnoredFileDescriptors=43,\/dev\/null,44,\/dev\/urandom\");\n+\n+        CracBuilder builder = new CracBuilder();\n+        builder.startCheckpoint(prefix).waitForCheckpointed();\n+        builder.captureOutput(true).doRestore().outputAnalyzer().shouldContain(RESTORED_MESSAGE);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var stream = Files.list(Path.of(\"\/proc\/self\/fd\"))) {\n+            Map<Integer, String> fds = stream.filter(Files::isSymbolicLink)\n+                    .collect(Collectors.toMap(\n+                            f -> Integer.parseInt(f.toFile().getName()),\n+                            f -> {\n+                                try {\n+                                    return Files.readSymbolicLink(f).toFile().getAbsoluteFile().toString();\n+                                } catch (IOException e) {\n+                                    throw new RuntimeException(e);\n+                                }\n+                            }));\n+            if (fds.containsKey(42)) {\n+                throw new IllegalStateException(\"Oh no, 42 was not supposed to be ignored\");\n+            } else if (!fds.containsKey(0) || !fds.containsKey(1) || !fds.containsKey(2)) {\n+                throw new IllegalStateException(\"Missing standard I\/O? Available: \" + fds);\n+            } else if (!fds.containsKey(43)) {\n+                throw new IllegalStateException(\"Missing FD 43\");\n+            } else if (!fds.containsValue(\"\/dev\/urandom\")) {\n+                throw new IllegalStateException(\"Missing \/dev\/urandom\");\n+            }\n+        }\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED_MESSAGE);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/IgnoredFileDescriptorsTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/extra_fd_wrapper.sh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/crac\/extra_fd_wrapper.sh","status":"renamed"},{"patch":"@@ -24,0 +24,5 @@\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.util.concurrent.CountDownLatch;\n@@ -34,6 +39,7 @@\n- * @run main\/othervm JoinSleepWaitOnCRPauseTest join_ms\n- * @run main\/othervm JoinSleepWaitOnCRPauseTest join_ns\n- * @run main\/othervm JoinSleepWaitOnCRPauseTest sleep_ms\n- * @run main\/othervm JoinSleepWaitOnCRPauseTest sleep_ns\n- * @run main\/othervm JoinSleepWaitOnCRPauseTest wait_ms\n- * @run main\/othervm JoinSleepWaitOnCRPauseTest wait_ns\n+ * @build JoinSleepWaitOnCRPauseTest\n+ * @run driver jdk.test.lib.crac.CracTest join_ms\n+ * @run driver jdk.test.lib.crac.CracTest join_ns\n+ * @run driver jdk.test.lib.crac.CracTest sleep_ms\n+ * @run driver jdk.test.lib.crac.CracTest sleep_ns\n+ * @run driver jdk.test.lib.crac.CracTest wait_ms\n+ * @run driver jdk.test.lib.crac.CracTest wait_ns\n@@ -41,0 +47,4 @@\n+public class JoinSleepWaitOnCRPauseTest implements CracTest {\n+    private enum TestType {\n+        join_ms, join_ns, sleep_ms, sleep_ns, wait_ms, wait_ns\n+    }\n@@ -42,12 +52,2 @@\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.util.concurrent.CountDownLatch;\n-\n-\n-public class JoinSleepWaitOnCRPauseTest {\n-\n-    private static enum TestType {\n-        join_ms, join_ns, sleep_ms, sleep_ns, wait_ms, wait_ns};\n-    private final TestType testType;\n+    @CracTestArg\n+    private TestType testType;\n@@ -68,6 +68,2 @@\n-\n-    private JoinSleepWaitOnCRPauseTest(TestType testType) {\n-        this.testType = testType;\n-    }\n-\n-    private void runTest() throws Exception {\n+    @Override\n+    public void exec() throws Exception {\n@@ -169,0 +165,5 @@\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder()\n+                .imageDir(\"cr_\" + testType.name());\n+        builder.doCheckpoint();\n@@ -170,10 +171,3 @@\n-    public static void main(String args[]) throws Exception {\n-\n-        if (args.length > 1) {\n-\n-            new JoinSleepWaitOnCRPauseTest(\n-                    TestType.valueOf(args[0])).runTest();\n-\n-        } else if (args.length > 0) {\n-\n-            String crImg = \"cr_\" + args[0];\n+        \/\/ sleep a few seconds to ensure the task execution time\n+        \/\/ falls within this pause period\n+        Thread.sleep(CRPAUSE_MS);\n@@ -181,19 +175,1 @@\n-            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-                \"-XX:CRaCCheckpointTo=\" + crImg, \"JoinSleepWaitOnCRPauseTest\",\n-                args[0], \"runTest\");\n-            OutputAnalyzer out = new OutputAnalyzer(pb.start());\n-            out.shouldContain(\"CR: Checkpoint\");\n-            out.shouldHaveExitValue(137);\n-\n-            \/\/ sleep a few seconds to ensure the task execution time\n-            \/\/ falls within this pause period\n-            Thread.sleep(CRPAUSE_MS);\n-\n-            pb = ProcessTools.createJavaProcessBuilder(\"-XX:CRaCRestoreFrom=\" + crImg);\n-            out = new OutputAnalyzer(pb.start());\n-            out.shouldHaveExitValue(0);\n-\n-        } else {\n-\n-            throw new IllegalArgumentException(\"please provide a test type\");\n-        }\n+        builder.doRestore();\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/Thread\/JoinSleepWaitOnCRPauseTest.java","additions":29,"deletions":53,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-\n-public class ResolveInetAddress {\n-    public static void main(String[] args) {\n-        if (args.length < 2) {\n-            System.err.println(\"Args: <ip address> <check file path>\");\n-            return;\n-        }\n-        printAddress(args[0]);\n-        while (!Files.exists(Path.of(args[1]))) {\n-            try {\n-                \/\/noinspection BusyWait\n-                Thread.sleep(100);\n-            } catch (InterruptedException e) {\n-                System.err.println(\"Interrupted!\");\n-                return;\n-            }\n-        }\n-        printAddress(args[0]);\n-    }\n-\n-    private static void printAddress(String hostname) {\n-        try {\n-            InetAddress address = InetAddress.getByName(hostname);\n-            \/\/ we will assume IPv4 address\n-            byte[] bytes = address.getAddress();\n-            System.out.print(bytes[0] & 0xFF);\n-            for (int i = 1; i < bytes.length; ++i) {\n-                System.out.print('.');\n-                System.out.print(bytes[i] & 0xFF);\n-            }\n-            System.out.println();\n-        } catch (UnknownHostException e) {\n-            System.out.println();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveInetAddress.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -24,1 +24,0 @@\n-import jdk.test.lib.Container;\n@@ -27,1 +26,0 @@\n-import jdk.test.lib.containers.docker.DockerRunOptions;\n@@ -29,1 +27,4 @@\n-import jdk.test.lib.process.StreamPumper;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n@@ -31,2 +32,2 @@\n-import java.io.IOException;\n-import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n@@ -35,3 +36,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n@@ -39,1 +37,0 @@\n-import java.util.function.Consumer;\n@@ -46,3 +43,2 @@\n- * @modules java.base\/jdk.crac\n- * @build ResolveInetAddress\n- * @run main\/timeout=360 ResolveTest\n+ * @build ResolveTest\n+ * @run driver jdk.test.lib.crac.CracTest\n@@ -50,1 +46,1 @@\n-public class ResolveTest {\n+public class ResolveTest implements CracTest {\n@@ -53,2 +49,0 @@\n-    public static final String CONTAINER_NAME = \"test-inet-address\";\n-    public static final String CRAC_CRIU_PATH;\n@@ -56,7 +50,5 @@\n-    static {\n-        String path = System.getenv(\"CRAC_CRIU_PATH\");\n-        if (path == null) {\n-            path = Utils.TEST_JDK + \"\/lib\/criu\";\n-        }\n-        CRAC_CRIU_PATH = path;\n-    }\n+    @CracTestArg(value = 0, optional = true)\n+    String ip;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String checkFile;\n@@ -64,1 +56,2 @@\n-    public static void main(String[] args) throws Exception {\n+    @Override\n+    public void test() throws Exception {\n@@ -68,17 +61,4 @@\n-        if (!Files.exists(Path.of(CRAC_CRIU_PATH))) {\n-            throw new RuntimeException(\"criu cannot be found in \" + CRAC_CRIU_PATH);\n-        }\n-        DockerTestUtils.buildJdkDockerImage(imageName, \"Dockerfile-is-ignored\", \"jdk-docker\");\n-        try {\n-            Future<?> completed = startTestProcess();\n-            checkpointTestProcess();\n-            completed.get(5, TimeUnit.SECONDS);\n-            startRestoredProcess();\n-        } finally {\n-            ensureContainerDead();\n-            DockerTestUtils.removeDockerImage(imageName);\n-        }\n-    }\n-\n-    private static Future<?> startTestProcess() throws Exception {\n-        ensureContainerDead();\n+        CracBuilder builder = new CracBuilder()\n+                .inDockerImage(imageName).dockerOptions(\"--add-host\", TEST_HOSTNAME + \":192.168.12.34\")\n+                .captureOutput(true)\n+                .args(CracTest.args(TEST_HOSTNAME, \"\/second-run\"));\n@@ -86,34 +66,14 @@\n-        List<String> cmd = new ArrayList<>();\n-        cmd.add(Container.ENGINE_COMMAND);\n-        cmd.addAll(Arrays.asList(\"run\", \"--rm\", \"--add-host\", TEST_HOSTNAME + \":192.168.12.34\"));\n-        cmd.addAll(Arrays.asList(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\"));\n-        cmd.addAll(Arrays.asList(\"--volume\", \"cr:\/cr\"));\n-        cmd.addAll(Arrays.asList(\"--volume\", CRAC_CRIU_PATH + \":\/criu\"));\n-        cmd.addAll(Arrays.asList(\"--env\", \"CRAC_CRIU_PATH=\/criu\"));\n-        cmd.addAll(Arrays.asList(\"--entrypoint\", \"bash\"));\n-        \/\/ checkpoint-restore does not work without this: TODO fine-grained --cap-add\n-        cmd.add(\"--privileged\");\n-        cmd.addAll(Arrays.asList(\"--name\", CONTAINER_NAME));\n-        cmd.add(imageName);\n-        \/\/ Checkpointing does not work for PID 1, therefore we add an intermediary bash process\n-        List<String> javaCmd = new ArrayList<>();\n-        javaCmd.addAll(Arrays.asList(\"\/jdk\/bin\/java\", \"-cp \/test-classes\/\", \"-XX:CRaCCheckpointTo=\/cr\"));\n-        javaCmd.addAll(Arrays.asList(Utils.getTestJavaOpts()));\n-        javaCmd.addAll(Arrays.asList(\"ResolveInetAddress\", TEST_HOSTNAME, \"\/second-run\"));\n-        cmd.addAll(Arrays.asList(\"-c\", String.join(\" \", javaCmd) + \"; echo i-am-here-to-force-child-process\"));\n-\n-        System.err.println(\"Running: \" + String.join(\" \", cmd));\n-\n-        CompletableFuture<?> firstOutputFuture = new CompletableFuture<Void>();\n-        Future<?> completed = executeWatching(cmd, line -> {\n-            System.out.println(\"OUTPUT: \" + line);\n-            if (line.equals(\"192.168.12.34\")) {\n-                firstOutputFuture.complete(null);\n-            }\n-        }, error -> {\n-            System.err.println(\"ERROR: \" + error);\n-            firstOutputFuture.cancel(false);\n-        });\n-        firstOutputFuture.get(10, TimeUnit.SECONDS);\n-        return completed;\n-    }\n+        try {\n+            CompletableFuture<?> firstOutputFuture = new CompletableFuture<Void>();\n+            CracProcess checkpointed = builder.startCheckpoint().watch(line -> {\n+                System.out.println(\"OUTPUT: \" + line);\n+                if (line.equals(\"192.168.12.34\")) {\n+                    firstOutputFuture.complete(null);\n+                }\n+            }, error -> {\n+                System.err.println(\"ERROR: \" + error);\n+                firstOutputFuture.cancel(false);\n+            });\n+            firstOutputFuture.get(10, TimeUnit.SECONDS);\n+            builder.checkpointViaJcmd();\n+            checkpointed.waitForCheckpointed();\n@@ -121,4 +81,3 @@\n-    private static void ensureContainerDead() throws Exception {\n-        \/\/ ensure the container is not running, ignore if not present\n-        DockerTestUtils.execute(\"docker\", \"kill\", CONTAINER_NAME).getExitValue();\n-    }\n+            builder.recreateContainer(imageName,\n+                    \"--add-host\", TEST_HOSTNAME + \":192.168.56.78\",\n+                    \"--volume\", Utils.TEST_CLASSES + \":\/second-run\"); \/\/ any file\/dir suffices\n@@ -126,5 +85,0 @@\n-    private static void checkpointTestProcess() throws Exception {\n-        DockerTestUtils.execute(\"docker\", \"exec\", CONTAINER_NAME,\n-                        \"\/jdk\/bin\/jcmd\", ResolveInetAddress.class.getName(), \"JDK.checkpoint\")\n-                .shouldHaveExitValue(0);\n-    }\n@@ -132,6 +86,6 @@\n-    private static Future<Void> executeWatching(List<String> command, Consumer<String> outputConsumer, Consumer<String> errorConsumer) throws IOException, ExecutionException, InterruptedException, TimeoutException {\n-        ProcessBuilder pb = new ProcessBuilder(command);\n-        Process p = pb.start();\n-        Future<Void> outputPumper = pump(p.getInputStream(), outputConsumer);\n-        Future<Void> errorPumper = pump(p.getErrorStream(), errorConsumer);\n-        return outputPumper;\n+            builder.startRestore().outputAnalyzer()\n+                    .shouldHaveExitValue(0)\n+                    .shouldContain(\"192.168.56.78\");\n+        } finally {\n+            builder.ensureContainerKilled();\n+        }\n@@ -140,5 +94,14 @@\n-    private static Future<Void> pump(InputStream stream, Consumer<String> consumer) {\n-        return new StreamPumper(stream).addPump(new StreamPumper.LinePump() {\n-            @Override\n-            protected void processLine(String line) {\n-                consumer.accept(line);\n+    @Override\n+    public void exec() throws Exception {\n+        if (ip == null || checkFile == null) {\n+            System.err.println(\"Args: <ip address> <check file path>\");\n+            return;\n+        }\n+        printAddress(ip);\n+        while (!Files.exists(Path.of(checkFile))) {\n+            try {\n+                \/\/noinspection BusyWait\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                System.err.println(\"Interrupted!\");\n+                return;\n@@ -146,1 +109,2 @@\n-        }).process();\n+        }\n+        printAddress(ip);\n@@ -149,13 +113,14 @@\n-    private static void startRestoredProcess() throws Exception {\n-        DockerRunOptions opts = new DockerRunOptions(imageName, \"\/jdk\/bin\/java\", \"ResolveInetAddress\");\n-        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\");\n-        opts.addDockerOpts(\"--volume\", \"cr:\/cr\");\n-        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/second-run\"); \/\/ any file suffices\n-        opts.addDockerOpts(\"--volume\", CRAC_CRIU_PATH + \":\/criu\");\n-        opts.addDockerOpts(\"--env\", \"CRAC_CRIU_PATH=\/criu\");\n-        opts.addDockerOpts(\"--add-host\", TEST_HOSTNAME + \":192.168.56.78\");\n-        opts.addDockerOpts(\"--privileged\");\n-        opts.addJavaOpts(\"-XX:CRaCRestoreFrom=\/cr\");\n-        DockerTestUtils.dockerRunJava(opts)\n-                .shouldHaveExitValue(0)\n-                .shouldContain(\"192.168.56.78\");\n+    private static void printAddress(String hostname) {\n+        try {\n+            InetAddress address = InetAddress.getByName(hostname);\n+            \/\/ we will assume IPv4 address\n+            byte[] bytes = address.getAddress();\n+            System.out.print(bytes[0] & 0xFF);\n+            for (int i = 1; i < bytes.length; ++i) {\n+                System.out.print('.');\n+                System.out.print(bytes[i] & 0xFF);\n+            }\n+            System.out.println();\n+        } catch (UnknownHostException e) {\n+            System.out.println();\n+        }\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveTest.java","additions":73,"deletions":108,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -21,1 +21,0 @@\n-\n@@ -23,2 +22,1 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n+import jdk.test.lib.crac.*;\n@@ -26,1 +24,1 @@\n-public class Test implements Resource {\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -28,0 +26,8 @@\n+\/*\n+ * @test\n+ * @summary check that the recursive checkpoint is not allowed\n+ * @library \/test\/lib\n+ * @build Test\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest 10\n+ *\/\n+public class Test implements Resource, CracTest {\n@@ -31,0 +37,15 @@\n+    @CracTestArg\n+    int numThreads;\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().engine(CracEngine.PAUSE);\n+        CracProcess process = builder.startCheckpoint();\n+        process.waitForPausePid();\n+        for (int i = 1; i <= numThreads + 1; ++i) {\n+            System.err.printf(\"Restore #%d%n\", i);\n+            builder.doRestore();\n+        }\n+        process.waitForSuccess();\n+    }\n+\n@@ -89,9 +110,2 @@\n-    public static void main(String args[]) throws Exception {\n-        if (args.length < 1) { throw new RuntimeException(\"number of threads is missing\"); }\n-        int numThreads;\n-        try{\n-            numThreads = Integer.parseInt(args[0]);\n-        } catch (NumberFormatException ex){\n-            throw new RuntimeException(\"invalid number of threads\");\n-        }\n-\n+    @Override\n+    public void exec() throws Exception {\n@@ -101,1 +115,1 @@\n-        for(int i=0; i<numThreads; i++) {\n+        for (int i = 0; i < numThreads; i++) {\n@@ -106,1 +120,1 @@\n-        Thread.currentThread().sleep(100);\n+        Thread.sleep(100);\n@@ -115,1 +129,1 @@\n-        for(int i=0; i<numThreads; i++) {\n+        for (int i = 0; i < numThreads; i++) {\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it under\n-# the terms of the GNU General Public License version 2 only, as published by\n-# the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-# details (a copy is included in the LICENSE file that accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version 2\n-# along with this work; if not, write to the Free Software Foundation, Inc.,\n-# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-# CA 94089 USA or visit www.azul.com if you need additional information or\n-# have any questions.\n-\n-\n-##\n-## @test Test.sh\n-## @summary check that the recursive checkpoint is not allowed\n-## @compile Test.java\n-## @run shell\/timeout=30 Test.sh\n-##\n-\n-set -x\n-IMGDIR=\"cr\"\n-\n-# We must use pauseengine: CRIU does not support checkpoint after restore, the restored process\n-# has the image directory mapped and second checkpoint would mess this up.\n-${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR -XX:CREngine=pauseengine Test $test 10 &\n-PID=$!\n-# Wait until the checkpoint happens - inotifywait would be better\n-while [ ! -f $IMGDIR\/pid ]; do sleep 1; done;\n-set -e\n-for run in $(seq 1 11); do\n-    echo \"Restore #\"$run\n-    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR -XX:CREngine=pauseengine\n-done\n-wait $PID\n-echo \"PASSED $test\"\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.sh","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -0,0 +1,330 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.util.FileUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+public class CracBuilder {\n+    private static final String DEFAULT_IMAGE_DIR = \"cr\";\n+    public static final String CONTAINER_NAME = \"crac-test\";\n+    public static final String JAVA = Utils.TEST_JDK + \"\/bin\/java\";\n+    public static final String DOCKER_JAVA = \"\/jdk\/bin\/java\";\n+    private static final List<String> CRIU_CANDIDATES = Arrays.asList(Utils.TEST_JDK + \"\/lib\/criu\", \"\/usr\/sbin\/criu\", \"\/sbin\/criu\");\n+    private static final String CRIU_PATH;\n+\n+    \/\/ This dummy field is here as workaround for (possibly) a JTReg bug;\n+    \/\/ some tests don't build CracTestArg into their Test.d\/ directory\n+    \/\/ (not all classes from \/test\/lib are built!) and the tests would fail.\n+    \/\/ This does not always happen when the test is run individually but breaks\n+    \/\/ when the whole suite is executed.\n+    private static final Class<CracTestArg> dummyWorkaround = CracTestArg.class;\n+\n+    boolean verbose = true;\n+    boolean debug = false;\n+    final List<String> classpathEntries = new ArrayList<>();\n+    final Map<String, String> env = new HashMap<>();\n+    String imageDir = DEFAULT_IMAGE_DIR;\n+    CracEngine engine;\n+    boolean printResources;\n+    Class<?> main;\n+    String[] args;\n+    boolean captureOutput;\n+    String dockerImageName;\n+    private String[] dockerOptions;\n+\n+    boolean containerStarted;\n+\n+    static {\n+        String path = System.getenv(\"CRAC_CRIU_PATH\");\n+        if (path == null) {\n+            for (String candidate : CRIU_CANDIDATES) {\n+                if (new File(candidate).exists()) {\n+                    path = candidate;\n+                    break;\n+                }\n+            }\n+        }\n+        CRIU_PATH = path;\n+    }\n+\n+    public CracBuilder() {\n+    }\n+\n+    public CracBuilder verbose(boolean verbose) {\n+        this.verbose = verbose;\n+        return this;\n+    }\n+\n+    public CracBuilder debug(boolean debug) {\n+        this.debug = debug;\n+        return this;\n+    }\n+\n+    public CracBuilder classpathEntry(String cp) {\n+        classpathEntries.add(cp);\n+        return this;\n+    }\n+\n+    public CracBuilder engine(CracEngine engine) {\n+        assertNull(this.engine); \/\/ set once\n+        this.engine = engine;\n+        return this;\n+    }\n+\n+    public Path imageDir() {\n+        return Path.of(imageDir);\n+    }\n+\n+    public CracBuilder imageDir(String imageDir) {\n+        assertEquals(DEFAULT_IMAGE_DIR, this.imageDir); \/\/ set once\n+        this.imageDir = imageDir;\n+        return this;\n+    }\n+\n+    public CracBuilder printResources(boolean print) {\n+        this.printResources = print;\n+        return this;\n+    }\n+\n+    public CracBuilder env(String name, String value) {\n+        env.put(name, value);\n+        return this;\n+    }\n+\n+    public CracBuilder main(Class<?> mainClass) {\n+        assertNull(this.main); \/\/ set once\n+        this.main = mainClass;\n+        return this;\n+    }\n+\n+    public Class<?> main() {\n+        return main != null ? main : CracTest.class;\n+    }\n+\n+    public CracBuilder args(String... args) {\n+        assertNull(this.args); \/\/ set once\n+        this.args = args;\n+        return this;\n+    }\n+\n+    public String[] args() {\n+        return args != null ? args : CracTest.args();\n+    }\n+\n+    public CracBuilder captureOutput(boolean captureOutput) {\n+        this.captureOutput = captureOutput;\n+        return this;\n+    }\n+\n+    public CracBuilder inDockerImage(String imageName) {\n+        assertNull(dockerImageName);\n+        this.dockerImageName = imageName;\n+        return this;\n+    }\n+\n+    public CracBuilder dockerOptions(String... options) {\n+        assertNull(dockerOptions);\n+        this.dockerOptions = options;\n+        return this;\n+    }\n+\n+    public void doCheckpoint() throws Exception {\n+        startCheckpoint().waitForCheckpointed();\n+    }\n+\n+    public CracProcess startCheckpoint() throws Exception {\n+        return startCheckpoint(null);\n+    }\n+\n+    public CracProcess startCheckpoint(List<String> javaPrefix) throws Exception {\n+        ensureContainerStarted();\n+        List<String> cmd = prepareCommand(javaPrefix);\n+        cmd.add(\"-XX:CRaCCheckpointTo=\" + imageDir);\n+        cmd.add(main().getName());\n+        cmd.addAll(Arrays.asList(args()));\n+        log(\"Starting process to be checkpointed:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    void log(String fmt, Object... args) {\n+        if (verbose) {\n+            if (args.length == 0) {\n+                System.err.println(fmt);\n+            } else {\n+                System.err.printf(fmt, args);\n+            }\n+        }\n+    }\n+\n+    private void ensureContainerStarted() throws Exception {\n+        if (dockerImageName == null) {\n+            return;\n+        }\n+        if (CRIU_PATH == null) {\n+            fail(\"CRAC_CRIU_PATH is not set and cannot find criu executable in any of: \" + CRIU_CANDIDATES);\n+        }\n+        if (!containerStarted) {\n+            ensureContainerKilled();\n+            DockerTestUtils.buildJdkDockerImage(dockerImageName, \"Dockerfile-is-ignored\", \"jdk-docker\");\n+            FileUtils.deleteFileTreeWithRetry(Path.of(\".\", \"jdk-docker\"));\n+            \/\/ Make sure we start with a clean image directory\n+            DockerTestUtils.execute(Container.ENGINE_COMMAND, \"volume\", \"rm\", \"cr\");\n+            List<String> cmd = prepareContainerCommand(dockerImageName, dockerOptions);\n+            log(\"Starting docker container:\\n\" + String.join(\" \", cmd));\n+            assertEquals(0, new ProcessBuilder().inheritIO().command(cmd).start().waitFor());\n+            containerStarted = true;\n+        }\n+    }\n+\n+    private List<String> prepareContainerCommand(String imageName, String[] options) {\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(Container.ENGINE_COMMAND);\n+        cmd.addAll(Arrays.asList(\"run\", \"--rm\", \"-d\"));\n+        cmd.add(\"--privileged\"); \/\/ required to give CRIU sufficient permissions\n+        cmd.add(\"--init\"); \/\/ otherwise the checkpointed process would not be reaped (by sleep with PID 1)\n+        int entryCounter = 0;\n+        for (var entry : Utils.TEST_CLASS_PATH.split(File.pathSeparator)) {\n+            cmd.addAll(Arrays.asList(\"--volume\", entry + \":\/cp\/\" + (entryCounter++)));\n+        }\n+        cmd.addAll(Arrays.asList(\"--volume\", \"cr:\/cr\"));\n+        cmd.addAll(Arrays.asList(\"--volume\", CRIU_PATH + \":\/criu\"));\n+        cmd.addAll(Arrays.asList(\"--env\", \"CRAC_CRIU_PATH=\/criu\"));\n+        cmd.addAll(Arrays.asList(\"--name\", CONTAINER_NAME));\n+        if (debug) {\n+            cmd.addAll(Arrays.asList(\"--publish\", \"5005:5005\"));\n+        }\n+        if (options != null) {\n+            cmd.addAll(Arrays.asList(options));\n+        }\n+        cmd.add(imageName);\n+        cmd.addAll(Arrays.asList(\"sleep\", \"3600\"));\n+        return cmd;\n+    }\n+\n+    public void ensureContainerKilled() throws Exception {\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"kill\", CONTAINER_NAME).getExitValue();\n+        DockerTestUtils.removeDockerImage(dockerImageName);\n+    }\n+\n+    public void recreateContainer(String imageName, String... options) throws Exception {\n+        assertTrue(containerStarted);\n+        String minPid = DockerTestUtils.execute(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME,\n+                \"cat\", \"\/proc\/sys\/kernel\/ns_last_pid\").getStdout().trim();\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"kill\", CONTAINER_NAME).getExitValue();\n+        List<String> cmd = prepareContainerCommand(imageName, options);\n+        log(\"Recreating docker container:\\n\" + String.join(\" \", cmd));\n+        assertEquals(0, new ProcessBuilder().inheritIO().command(cmd).start().waitFor());\n+        \/\/ We need to cycle PIDs; had we tried to restore right away the exec would get the\n+        \/\/ same PIDs and restore would fail.\n+        log(\"Cycling PIDs until %s%n\", minPid);\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"exec\",\n+                CONTAINER_NAME, \"bash\", \"-c\",\n+                \"while [ $(cat \/proc\/sys\/kernel\/ns_last_pid) -le \" + minPid + \" ]; do cat \/dev\/null; done\");\n+    }\n+\n+    public CracProcess doRestore() throws Exception {\n+        return startRestore().waitForSuccess();\n+    }\n+\n+    public CracProcess startRestore() throws Exception {\n+         return startRestore(null);\n+    }\n+    public CracProcess startRestore(List<String> prefixJava) throws Exception {\n+        ensureContainerStarted();\n+        List<String> cmd = prepareCommand(prefixJava);\n+        cmd.add(\"-XX:CRaCRestoreFrom=\" + imageDir);\n+        log(\"Starting restored process:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    public CracProcess startPlain() throws IOException {\n+        List<String> cmd = new ArrayList<>();\n+        if (dockerImageName != null) {\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+        }\n+        cmd.add(JAVA);\n+        cmd.add(\"-ea\");\n+        cmd.add(\"-cp\");\n+        cmd.add(getClassPath());\n+        if (debug) {\n+            cmd.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=0.0.0.0:5005\");\n+        }\n+        cmd.add(main().getName());\n+        cmd.addAll(Arrays.asList(args()));\n+        log(\"Starting process without CRaC:\");\n+        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    private String getClassPath() {\n+        String classPath = classpathEntries.isEmpty() ? \"\" : String.join(File.pathSeparator, classpathEntries) + File.pathSeparator;\n+        if (dockerImageName == null) {\n+            classPath += Utils.TEST_CLASS_PATH;\n+        } else {\n+            int numEntries = Utils.TEST_CLASS_PATH.split(File.pathSeparator).length;\n+            for (int i = 0; i < numEntries; ++i) {\n+                classPath += \"\/cp\/\" + i + File.pathSeparator;\n+            }\n+        }\n+        return classPath;\n+    }\n+\n+    public CracProcess doPlain() throws IOException, InterruptedException {\n+        return startPlain().waitForSuccess();\n+    }\n+\n+    private List<String> prepareCommand(List<String> javaPrefix) {\n+        List<String> cmd = new ArrayList<>();\n+        if (javaPrefix != null) {\n+            cmd.addAll(javaPrefix);\n+        } else if (dockerImageName != null) {\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+            cmd.add(DOCKER_JAVA);\n+        } else {\n+            cmd.add(JAVA);\n+        }\n+        cmd.add(\"-ea\");\n+        cmd.add(\"-cp\");\n+        cmd.add(getClassPath());\n+        if (engine != null) {\n+            cmd.add(\"-XX:CREngine=\" + engine.engine);\n+        }\n+        if (printResources) {\n+            cmd.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+            cmd.add(\"-XX:+CRPrintResourcesOnCheckpoint\");\n+        }\n+        if (debug) {\n+            cmd.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=0.0.0.0:5005\");\n+            cmd.add(\"-XX:-CRDoThrowCheckpointException\");\n+        }\n+        return cmd;\n+    }\n+\n+    public void doCheckpointAndRestore() throws Exception {\n+        doCheckpoint();\n+        doRestore();\n+    }\n+\n+    public void checkpointViaJcmd() throws Exception {\n+        List<String> cmd = new ArrayList<>();\n+        if (dockerImageName != null) {\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME, \"\/jdk\/bin\/jcmd\"));\n+        } else {\n+            cmd.add(Utils.TEST_JDK + \"\/bin\/jcmd\");\n+        }\n+        cmd.addAll(Arrays.asList(main().getName(), \"JDK.checkpoint\"));\n+        \/\/ This works for non-docker commands, too\n+        DockerTestUtils.execute(cmd).shouldHaveExitValue(0);\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":330,"deletions":0,"binary":false,"changes":330,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+package jdk.test.lib.crac;\n+\n+public enum CracEngine {\n+    CRIU(\"criuengine\"),\n+    PAUSE(\"pauseengine\"),\n+    SIMULATE(\"simengine\");\n+\n+    public final String engine;\n+\n+    CracEngine(String engine) {\n+        this.engine = engine;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracEngine.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.StreamPumper;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+public class CracProcess {\n+    private final CracBuilder builder;\n+    private final Process process;\n+\n+    public CracProcess(CracBuilder builder, List<String> cmd) throws IOException {\n+        this.builder = builder;\n+        ProcessBuilder pb = new ProcessBuilder().inheritIO();\n+        if (builder.captureOutput) {\n+            pb.redirectOutput(ProcessBuilder.Redirect.PIPE);\n+            pb.redirectError(ProcessBuilder.Redirect.PIPE);\n+        }\n+        pb.environment().putAll(builder.env);\n+        this.process = pb.command(cmd).start();\n+    }\n+\n+    public int waitFor() throws InterruptedException {\n+        return process.waitFor();\n+    }\n+\n+    public void waitForCheckpointed() throws InterruptedException {\n+        if (builder.engine == null || builder.engine == CracEngine.CRIU) {\n+            assertEquals(137, process.waitFor(), \"Checkpointed process was not killed as expected.\");\n+            \/\/ TODO: we could check that \"CR: Checkpoint\" was written out\n+        } else {\n+            fail(\"With engine \" + builder.engine.engine + \" use the async version.\");\n+        }\n+    }\n+\n+    public void waitForPausePid() throws IOException, InterruptedException {\n+        assertEquals(CracEngine.PAUSE, builder.engine, \"Pause PID file created only with pauseengine\");\n+        try (WatchService watcher = FileSystems.getDefault().newWatchService()) {\n+            Path imageDir = builder.imageDir().toAbsolutePath();\n+            waitForFileCreated(watcher, imageDir.getParent(), path -> \"cr\".equals(path.toFile().getName()));\n+            waitForFileCreated(watcher, imageDir, path -> \"pid\".equals(path.toFile().getName()));\n+        }\n+    }\n+\n+    private void waitForFileCreated(WatchService watcher, Path dir, Predicate<Path> predicate) throws IOException, InterruptedException {\n+        WatchKey key = dir.register(watcher, StandardWatchEventKinds.ENTRY_CREATE);\n+        assertTrue(key.isValid());\n+        try {\n+            try (Stream<Path> dirContents = Files.list(dir)) {\n+                if (dirContents.anyMatch(predicate)) {\n+                    \/\/ file already present\n+                    return;\n+                }\n+            }\n+            for (; ; ) {\n+                WatchKey key2 = watcher.take();\n+                for (WatchEvent<?> event : key2.pollEvents()) {\n+                    if (event.kind() != StandardWatchEventKinds.ENTRY_CREATE) {\n+                        continue;\n+                    }\n+                    if (predicate.test((Path) event.context())) {\n+                        return;\n+                    }\n+                }\n+                key2.reset();\n+            }\n+        } finally {\n+            key.cancel();\n+        }\n+    }\n+\n+    public CracProcess waitForSuccess() throws InterruptedException {\n+        int exitValue = process.waitFor();\n+        assertEquals(0, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+        builder.log(\"Process %d completed with exit value %d%n\", process.pid(), exitValue);\n+        return this;\n+    }\n+\n+    public OutputAnalyzer outputAnalyzer() throws IOException {\n+        assertTrue(builder.captureOutput, \"Output must be captured with .captureOutput(true)\");\n+        return new OutputAnalyzer(process);\n+    }\n+\n+    public CracProcess watch(Consumer<String> outputConsumer, Consumer<String> errorConsumer) {\n+        assertTrue(builder.captureOutput, \"Output must be captured with .captureOutput(true)\");\n+        pump(process.getInputStream(), outputConsumer);\n+        pump(process.getErrorStream(), errorConsumer);\n+        return this;\n+    }\n+\n+    private static void pump(InputStream stream, Consumer<String> consumer) {\n+        new StreamPumper(stream).addPump(new StreamPumper.LinePump() {\n+            @Override\n+            protected void processLine(String line) {\n+                consumer.accept(line);\n+            }\n+        }).process();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.crac.Core;\n+\n+import java.lang.reflect.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * CRaC tests usually consists of two parts; the test started by JTreg through the 'run' tag\n+ * and subprocesses started by the test with various VM options. These are represented by the\n+ * {@link #test()} and {@link #exec()} methods.\n+ * CracTest use '@run driver jdk.test.crac.lib.CracTest' as the executable command; the main\n+ * method in this class discovers the executed class from system properties passed by JTReg,\n+ * instantiates the test (public no-arg constructor is needed), populates fields annotated\n+ * with {@link CracTestArg} and executes the {@link #test()} method.\n+ * The test method is expected to use {@link CracBuilder} to start another process. By default,\n+ * CracBuilder invokes the test with arguments that will again instantiate and fill the instance\n+ * and invoke the {@link #exec()} method.\n+ *\/\n+public interface CracTest {\n+\n+    String RESTORED_MESSAGE = \"Restored\";\n+\n+    \/**\n+     * This method is called when JTReg invokes the test; it is supposed to start\n+     * another process (most often using CRaC VM options) and validate its behaviour.\n+     *\n+     * @throws Exception\n+     *\/\n+    void test() throws Exception;\n+\n+    \/**\n+     * This method is invoked in the subprocess; this is where you're likely to call\n+     * {@link Core#checkpointRestore()}.\n+     *\n+     * @throws Exception\n+     *\/\n+    void exec() throws Exception;\n+\n+    class ArgsHolder {\n+        private static final String RUN_TEST = \"__run_test__\";\n+        private static Class<? extends CracTest> testClass;\n+        private static String[] args;\n+        \/\/ This field is present as workaround for @build <test> somehow missing\n+        \/\/ the annotation when\n+        private static final Class<CracTestArg> dummyField = CracTestArg.class;\n+    }\n+\n+    \/**\n+     * Main method for orchestrating the test. This should be called directly by JTReg.\n+     *\/\n+    static void main(String[] args) throws Exception {\n+        String testClassName;\n+        if (args.length == 0 || !ArgsHolder.RUN_TEST.equals(args[0])) {\n+            \/\/ We will look up the class name (and package) to avoid boilerplate in any @run invocation\n+            String testFile = System.getProperty(\"test.file\");\n+            String source = Files.readString(Path.of(testFile)).replace('\\n', ' ');\n+            Matcher clsMatcher = Pattern.compile(\"class\\\\s+(\\\\S+)\\\\s+(extends\\\\s+\\\\S+\\\\s+)?implements\\\\s+(\\\\S+\\\\s*,\\\\s*)*CracTest\").matcher(source);\n+            if (!clsMatcher.find()) {\n+                fail(\"Cannot find test class in \" + testFile + \", does it look like class <test> implements CracTest?\");\n+            }\n+            testClassName = clsMatcher.group(1);\n+            Matcher pkgMatcher = Pattern.compile(\"package\\\\s+([^;]+);\").matcher(source);\n+            if (pkgMatcher.find()) {\n+                testClassName = pkgMatcher.group(1) + \".\" + testClassName;\n+            }\n+        } else {\n+            testClassName = args[1];\n+        }\n+\n+        \/\/ When we use CracTest as driver the file with test is not compiled without a @build tag.\n+        \/\/ We could compile the class here and load it from a new classloader but since the test library\n+        \/\/ is not compiled completely we could be missing some dependencies - this would be just too fragile.\n+        Class<?> testClass;\n+        try {\n+            testClass = Class.forName(testClassName);\n+        } catch (ClassNotFoundException e) {\n+            throw new ClassNotFoundException(\"Test class \" + testClassName + \" not found, add jtreg tag @build \" + args[0], e);\n+        }\n+        if (CracTest.class.isAssignableFrom(testClass)) {\n+            \/\/noinspection unchecked\n+            run((Class<? extends CracTest>) testClass, args);\n+        } else {\n+            throw new IllegalArgumentException(\"Class \" + testClass.getName() + \" does not implement CracTest!\");\n+        }\n+    }\n+\n+    \/**\n+     * This method should be invoked from the public static void main(String[]) method.\n+     *\n+     * @param testClass Class implementing the test.\n+     * @param args Arguments received in the main method.\n+     * @throws Exception\n+     *\/\n+    static void run(Class<? extends CracTest> testClass, String[] args) throws Exception {\n+        assertNotNull(args);\n+        ArgsHolder.testClass = testClass;\n+        int argsOffset = 0;\n+        if (args.length == 0 || !args[0].equals(ArgsHolder.RUN_TEST)) {\n+            String[] newArgs = new String[args.length + 2];\n+            newArgs[0] = ArgsHolder.RUN_TEST;\n+            newArgs[1] = testClass.getName();\n+            System.arraycopy(args, 0, newArgs, 2, args.length);\n+            ArgsHolder.args = newArgs;\n+        } else {\n+            argsOffset = 2;\n+        }\n+\n+        try {\n+            Constructor<? extends CracTest> ctor = testClass.getConstructor();\n+            CracTest testInstance = ctor.newInstance();\n+            Field[] argFields = getArgFields(testClass);\n+            for (int index = 0; index < argFields.length; index++) {\n+                Field f = argFields[index];\n+                assertFalse(Modifier.isFinal(f.getModifiers()), \"@CracTestArg fields must not be final!\");\n+                Class<?> t = f.getType();\n+                if (index + argsOffset >= args.length) {\n+                    if (f.getAnnotation(CracTestArg.class).optional()) {\n+                        break;\n+                    } else {\n+                        fail(\"Not enough args for field \" + f.getName() + \"(\" + index + \"): have \" + (args.length - argsOffset));\n+                    }\n+                }\n+                String arg = args[index + argsOffset];\n+                Object value = arg;\n+                if (t == boolean.class || t == Boolean.class) {\n+                    assertTrue(\"true\".equals(arg) || \"false\".equals(arg), \"Argument \" + index + \"Boolean arg should be either 'true' or 'false', was: \" + arg);\n+                    value = Boolean.parseBoolean(arg);\n+                } else if (t == int.class || t == Integer.class) {\n+                    try {\n+                        value = Integer.parseInt(arg);\n+                    } catch (NumberFormatException e) {\n+                        fail(\"Cannot parse argument '\" + arg + \"' as integer for @CracTestArg(\" + index + \") \" + f.getName());\n+                    }\n+                } else if (t == long.class || t == Long.class) {\n+                    try {\n+                        value = Long.parseLong(arg);\n+                    } catch (NumberFormatException e) {\n+                        fail(\"Cannot parse argument '\" + arg + \"' as long for @CracTestArg(\" + index + \") \" + f.getName());\n+                    }\n+                } else if (t.isEnum()) {\n+                    value = Enum.valueOf((Class<Enum>) t, arg);\n+                }\n+                f.setAccessible(true);\n+                f.set(testInstance, value);\n+            }\n+            if (argsOffset == 0) {\n+                testInstance.test();\n+            } else {\n+                testInstance.exec();\n+            }\n+        } catch (NoSuchMethodException e) {\n+            fail(\"Test class \" + testClass.getName() + \" is expected to have a public no-arg constructor\");\n+        }\n+    }\n+\n+    private static Field[] getArgFields(Class<? extends CracTest> testClass) {\n+        \/\/ TODO: check superclasses\n+        Field[] sortedFields = Stream.of(testClass.getDeclaredFields()).filter(f -> f.isAnnotationPresent(CracTestArg.class))\n+                .sorted(Comparator.comparingInt(f -> f.getAnnotation(CracTestArg.class).value()))\n+                .toArray(Field[]::new);\n+        if (sortedFields.length == 0) {\n+            return sortedFields;\n+        }\n+        int firstOptional = -1;\n+        for (int i = 0; i < sortedFields.length; ++i) {\n+            CracTestArg annotation = sortedFields[i].getAnnotation(CracTestArg.class);\n+            int index = annotation.value();\n+            assertGreaterThanOrEqual(index, 0);\n+            if (i == 0) {\n+                assertEquals(0, index, \"@CracTestArg numbers should start with 0\");\n+            }\n+            if (index < i) {\n+                fail(\"Duplicate @CracTestArg(\" + index + \"): both fields \" + sortedFields[i - 1].getName() + \" and \" + sortedFields[i].getName());\n+            } else if (index > i) {\n+                fail(\"Gap in @CracTestArg indices: missing \" + i + \", next is \" + index);\n+            }\n+            if (annotation.optional()) {\n+                firstOptional = index;\n+            } else if (firstOptional >= 0) {\n+                fail(\"Argument \" + firstOptional + \" is optional; all subsequent arguments must be optional, too.\");\n+            }\n+        }\n+        return sortedFields;\n+    }\n+\n+    \/**\n+     * Used as argument for {@link CracBuilder#args(String...)}.\n+     *\/\n+    static String[] args(String... extraArgs) {\n+        assertNotNull(ArgsHolder.args, \"Args are null; are you trying to access them from test method?\");\n+        if (extraArgs == null || extraArgs.length == 0) {\n+            return ArgsHolder.args;\n+        } else {\n+            return Stream.concat(Stream.of(ArgsHolder.args), Stream.of(extraArgs)).toArray(String[]::new);\n+        }\n+    }\n+\n+    static Class<? extends CracTest> testClass() {\n+        return ArgsHolder.testClass;\n+    }\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTest.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+package jdk.test.lib.crac;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * Used to mark fields in {@link CracTest} that should be populated from main method arguments.\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.FIELD)\n+public @interface CracTestArg {\n+    \/**\n+     * @return The (zero-based) index of the argument used as source of the data.\n+     *\/\n+    int value() default 0;\n+\n+    \/**\n+     * @return Can this argument be omitted?\n+     *\/\n+    boolean optional() default false;\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTestArg.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"}]}