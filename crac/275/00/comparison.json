{"files":[{"patch":"@@ -152,0 +152,3 @@\n+        \/\/ If the channel using this selector was closed, some keys might be cancelled\n+        \/\/ and we shall remove them.\n+        processDeregisterQueue();\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,0 +107,4 @@\n+        @Override\n+        protected void markForReopen() {\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.channels.SelectionKey;\n@@ -102,0 +103,10 @@\n+\n+            @Override\n+            public void revalidateSelectionKey(AbstractSelectionKey selectionKey) {\n+                selectionKey.revalidate();\n+            }\n+\n+            @Override\n+            public void reregisterSelectionKey(AbstractSelectableChannel channel, SelectionKey key) {\n+                channel.reregister(key);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractInterruptibleChannel.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -246,0 +246,9 @@\n+    void reregister(SelectionKey key) {\n+        assert key.channel() == this;\n+        synchronized (regLock) {\n+            synchronized (keyLock) {\n+                assert findKey(key.selector()) == null;\n+                addKey(key);\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelectableChannel.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+    void revalidate() { \/\/ package-private, called only by CRaC on reopen\n+        assert invalid;\n+        invalid = false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelectionKey.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.nio.channels.SelectionKey;\n@@ -28,0 +29,2 @@\n+import java.nio.channels.spi.AbstractSelectableChannel;\n+import java.nio.channels.spi.AbstractSelectionKey;\n@@ -31,0 +34,2 @@\n+    void revalidateSelectionKey(AbstractSelectionKey selectionKey);\n+    void reregisterSelectionKey(AbstractSelectableChannel channel, SelectionKey key);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioChannelsSpiAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -11,1 +11,3 @@\n-import java.util.Map;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n@@ -16,0 +18,4 @@\n+    \/\/ While the collection should be used by the single thread invoking the checkpoint\n+    \/\/ we won't prevent some races that could touch these as well.\n+    private static final Map<Object, List<Runnable>> markedForReopen = new ConcurrentHashMap<>();\n+\n@@ -25,0 +31,12 @@\n+    protected static void markForReopen(Object owner) {\n+        var prev = markedForReopen.putIfAbsent(owner, Collections.synchronizedList(new ArrayList<>()));\n+        if (prev != null) {\n+            throw new IllegalStateException(\"Marking for reopen twice\");\n+        }\n+    }\n+\n+    public static Consumer<Runnable> reopenQueue(Object owner) {\n+        List<Runnable> queue = markedForReopen.get(owner);\n+        return queue == null ? null : queue::add;\n+    }\n+\n@@ -46,1 +64,4 @@\n-                case \"close\", \"reopen\":\n+                case \"reopen\":\n+                    markForReopen();\n+                    \/\/ intentional fallthrough\n+                case \"close\":\n@@ -153,0 +174,4 @@\n+    protected void markForReopen() {\n+        throw new UnsupportedOperationException(\"Reopen not implemented on sockets\");\n+    }\n+\n@@ -156,0 +181,8 @@\n+\n+    protected void afterReopen(Object self) {\n+        List<Runnable> runnables = markedForReopen.remove(self);\n+        if (runnables == null) {\n+            throw new IllegalStateException(self + \" was not marked for reopen\");\n+        }\n+        runnables.forEach(Runnable::run);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResourceBase.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -105,0 +105,4 @@\n+            @Override\n+            protected void markForReopen() {\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.internal.access.JavaNioChannelsSpiAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.JDKSocketResourceBase;\n+\n@@ -37,7 +41,1 @@\n-import java.util.ArrayDeque;\n-import java.util.Collections;\n-import java.util.Deque;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.Objects;\n-import java.util.Set;\n+import java.util.*;\n@@ -55,0 +53,2 @@\n+    private static final JavaNioChannelsSpiAccess SPI_ACCESS = SharedSecrets.getJavaNioChannelsSpiAccess();\n+\n@@ -258,0 +258,23 @@\n+        \/\/ If a key registered on the channel that is about to be reopened\n+        \/\/ by FD policies is cancelled during JDK resource C\/R handling\n+        \/\/ this would be automatically uncancelled. We cannot prevent such race\n+        \/\/ even if marking the keys individually.\n+        Consumer<Runnable> enqueue = JDKSocketResourceBase.reopenQueue(ski.channel());\n+        if (enqueue != null) {\n+            enqueue.accept(() -> {\n+                SPI_ACCESS.revalidateSelectionKey(ski);\n+                implRegister(ski);\n+                setEventOps(ski);\n+                keys.add(ski);\n+                if (ski.channel() instanceof AbstractSelectableChannel asc) {\n+                    SPI_ACCESS.reregisterSelectionKey(asc, ski);\n+                }\n+                if (isOpen()) {\n+                    \/\/ Let the implementation process updates queue\n+                    wakeup();\n+                } else {\n+                    keys.remove(ski);\n+                    ski.cancel();\n+                }\n+            });\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorImpl.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import jdk.internal.crac.JDKSocketResourceBase;\n@@ -764,0 +765,5 @@\n+        @Override\n+        protected void markForReopen() {\n+            JDKSocketResourceBase.markForReopen(ServerSocketChannelImpl.this);\n+        }\n+\n@@ -791,0 +797,1 @@\n+            afterReopen(ServerSocketChannelImpl.this);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,0 +103,5 @@\n+        \/\/ This channel is closed and the current accept is going to throw\n+        \/\/ AsynchronousCloseException, but if CRaC is going to reopen it after restore\n+        \/\/ we must reset the accepting state.\n+        enableAccept();\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixAsynchronousServerSocketChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2025 Azul Systems, Inc. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.nio.channels.AsynchronousCloseException;\n@@ -31,1 +32,1 @@\n-import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n@@ -34,0 +35,2 @@\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n@@ -50,18 +53,16 @@\n-    protected void testConnection(AsynchronousServerSocketChannel serverSocket) throws Exception {\n-        CountDownLatch latch = new CountDownLatch(1);\n-        Thread serverThread = new Thread(() -> {\n-            try {\n-                Future<AsynchronousSocketChannel> socket = serverSocket.accept();\n-                socket.get();\n-                latch.countDown();\n-                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        });\n-        serverThread.setDaemon(true);\n-        serverThread.start();\n-        AsynchronousSocketChannel clientSocket = AsynchronousSocketChannel.open();\n-        Future<Void> connectFuture = clientSocket.connect(serverSocket.getLocalAddress());\n-        connectFuture.get();\n-        latch.await();\n+    protected boolean acceptClient(AsynchronousServerSocketChannel serverSocket) throws Exception {\n+        try {\n+            serverSocket.accept().get().close();\n+            return true;\n+        } catch (ExecutionException ee) {\n+            assertTrue(ee.getCause() instanceof AsynchronousCloseException);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    protected void connectClient(AsynchronousServerSocketChannel serverSocket) throws Exception {\n+        try (AsynchronousSocketChannel clientSocket = AsynchronousSocketChannel.open()) {\n+            Future<Void> connectFuture = clientSocket.connect(serverSocket.getLocalAddress());\n+            connectFuture.get();\n+        }\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningAsynchronousSocketChannelTest.java","additions":21,"deletions":20,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2025 Azul Systems, Inc. All rights reserved.\n@@ -24,1 +24,0 @@\n-import jdk.test.lib.Asserts;\n@@ -26,0 +25,3 @@\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import static jdk.test.lib.Asserts.*;\n@@ -30,0 +32,1 @@\n+import java.nio.channels.ClosedChannelException;\n@@ -32,1 +35,0 @@\n-import java.util.concurrent.CountDownLatch;\n@@ -41,1 +43,2 @@\n- * @run driver jdk.test.lib.crac.CracTest\n+ * @run driver jdk.test.lib.crac.CracTest true\n+ * @run driver jdk.test.lib.crac.CracTest false\n@@ -44,0 +47,3 @@\n+    @CracTestArg\n+    boolean blocking;\n+\n@@ -46,1 +52,3 @@\n-        return ServerSocketChannel.open().bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        ServerSocketChannel channel = ServerSocketChannel.open();\n+        channel.configureBlocking(blocking);\n+        return channel.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n@@ -50,9 +58,10 @@\n-    protected void testConnection(ServerSocketChannel serverSocket) throws Exception {\n-        CountDownLatch latch = new CountDownLatch(1);\n-        Thread serverThread = new Thread(() -> {\n-            try {\n-                SocketChannel socket = serverSocket.accept();\n-                latch.countDown();\n-                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n-            } catch (IOException e) {\n-                e.printStackTrace();\n+    protected boolean acceptClient(ServerSocketChannel serverSocket) throws IOException {\n+        try {\n+            SocketChannel socket;\n+            if (blocking) {\n+                socket = serverSocket.accept();\n+                assertNotNull(socket);\n+            } else {\n+                while ((socket = serverSocket.accept()) == null) {\n+                    Thread.yield();\n+                }\n@@ -60,6 +69,12 @@\n-        });\n-        serverThread.setDaemon(true);\n-        serverThread.start();\n-        SocketChannel clientSocket = SocketChannel.open(serverSocket.getLocalAddress());\n-        Asserts.assertTrue(clientSocket.isConnected());\n-        latch.await();\n+            socket.close();\n+            return true;\n+        } catch (ClosedChannelException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    protected void connectClient(ServerSocketChannel serverSocket) throws Exception {\n+        try (SocketChannel clientSocket = SocketChannel.open(serverSocket.getLocalAddress())) {\n+            assertTrue(clientSocket.isConnected());\n+        }\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningSocketChannelTest.java","additions":35,"deletions":20,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2025 Azul Systems, Inc. All rights reserved.\n@@ -31,1 +31,3 @@\n-import java.util.concurrent.CountDownLatch;\n+import java.net.SocketException;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n@@ -49,16 +51,9 @@\n-    protected void testConnection(ServerSocket serverSocket) throws Exception {\n-        CountDownLatch latch = new CountDownLatch(1);\n-        Thread serverThread = new Thread(() -> {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                latch.countDown();\n-                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n-            } catch (IOException e) {\n-                e.printStackTrace();\n-            }\n-        });\n-        serverThread.setDaemon(true);\n-        serverThread.start();\n-        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n-        Asserts.assertTrue(clientSocket.isConnected());\n-        latch.await();\n+    protected boolean acceptClient(ServerSocket serverSocket) throws Exception {\n+        try {\n+            Socket socket = serverSocket.accept();\n+            socket.close();\n+            return true;\n+        } catch (SocketException e) {\n+            assertEquals(\"Socket closed\", e.getMessage());\n+            return false;\n+        }\n@@ -67,0 +62,6 @@\n+    @Override\n+    protected void connectClient(ServerSocket serverSocket) throws Exception {\n+        try (Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort())) {\n+            Asserts.assertTrue(clientSocket.isConnected());\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningSocketTest.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.io.Closeable;\n@@ -31,1 +32,0 @@\n-import java.net.InetAddress;\n@@ -34,0 +34,10 @@\n+import java.util.concurrent.CompletableFuture;\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+public abstract class ReopenListeningTestBase<ServerType extends Closeable> extends FDPolicyTestBase implements CracTest {\n+\n+    protected interface Acceptor<ServerType> {\n+        void accept(ServerType serverSocket) throws Exception;\n+    }\n@@ -35,1 +45,0 @@\n-public abstract class ReopenListeningTestBase<ServerType> extends FDPolicyTestBase implements CracTest {\n@@ -43,4 +52,0 @@\n-                ---\n-                type: SOCKET\n-                family: ip\n-                action: close\n@@ -63,0 +68,6 @@\n+\n+        CompletableFuture<Boolean> cf = asyncAccept(serverSocket);\n+        \/\/ There's no way to even check that the accepting thread entered accept() or select()\n+        Thread.sleep(100);\n+        assertFalse(cf.isDone());\n+\n@@ -64,0 +75,3 @@\n+        connectClient(serverSocket);\n+        assertFalse(cf.get());\n+\n@@ -65,0 +79,2 @@\n+\n+        serverSocket.close();\n@@ -69,1 +85,25 @@\n-    protected abstract void testConnection(ServerType serverSocket) throws Exception;\n+    protected abstract boolean acceptClient(ServerType serverType) throws Exception;\n+\n+    \/\/ This method creates the connection and validates that the port is open;\n+    \/\/ it does not wait for the other party to accept the connection.\n+    protected abstract void connectClient(ServerType serverSocket) throws Exception;\n+\n+    private void testConnection(ServerType serverSocket) throws Exception {\n+        CompletableFuture<Boolean> cf = asyncAccept(serverSocket);\n+        connectClient(serverSocket);\n+        assertTrue(cf.get());\n+    }\n+\n+    protected CompletableFuture<Boolean> asyncAccept(ServerType serverSocket) {\n+        CompletableFuture<Boolean> cf = new CompletableFuture<>();\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                cf.complete(acceptClient(serverSocket));\n+            } catch (Throwable t) {\n+                cf.completeExceptionally(t);\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        return cf;\n+    }\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningTestBase.java","additions":47,"deletions":7,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.channels.*;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenListeningTestBase\n+ * @build ReopenListeningSocketChannelTest\n+ * @build ReopenListeningWithSelectorTest\n+ * @run driver\/timeout=10 jdk.test.lib.crac.CracTest false\n+ *\/\n+public class ReopenListeningWithSelectorTest extends ReopenListeningSocketChannelTest implements CracTest {\n+    private Selector selector;\n+\n+    @Override\n+    public void exec() throws Exception {\n+        super.exec();\n+        selector.close();\n+    }\n+\n+    @Override\n+    protected ServerSocketChannel createServer() throws IOException {\n+        selector = Selector.open();\n+        ServerSocketChannel channel = super.createServer();\n+        channel.register(selector, SelectionKey.OP_ACCEPT);\n+        return channel;\n+    }\n+\n+    @Override\n+    protected boolean acceptClient(ServerSocketChannel serverSocket) throws IOException {\n+        if (selector.select() == 0) {\n+            return false;\n+        }\n+        for (SelectionKey key : selector.selectedKeys()) {\n+            assertTrue(key.isAcceptable());\n+            assertEquals(serverSocket, key.channel());\n+            SocketChannel socket = serverSocket.accept();\n+            socket.close();\n+        }\n+        selector.selectedKeys().clear();\n+        return true;\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningWithSelectorTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}