{"files":[{"patch":"@@ -68,0 +68,2 @@\n+                    \/\/ Let's warn before actually closing the resource\n+                    warnOpenResource(policy, \"Socket \" + owner);\n@@ -73,1 +75,1 @@\n-                    \/\/ intentional fallthrough\n+                    yield NO_EXCEPTION;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResourceBase.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+        implReopen();\n@@ -173,1 +174,0 @@\n-        implReopen();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.crac.Core;\n@@ -44,0 +45,2 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -55,1 +58,3 @@\n-    protected final FileDescriptor fd;\n+    private static final FileDispatcherImpl nd = new FileDispatcherImpl();\n+\n+    protected FileDescriptor fd;\n@@ -610,0 +615,41 @@\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.internal.crac.mirror.Resource> context) throws Exception {\n+            try {\n+                begin();\n+                synchronized (stateLock) {\n+                    \/\/ On Windows, the socket channel with its FD is created in the accept()\n+                    \/\/ (returning incomplete future) so the user code does not have the chance to close it.\n+                    if (state == ST_UNCONNECTED) {\n+                        nd.close(fd);\n+                        Core.getClaimedFDs().claimFd(fd, AsynchronousSocketChannelImpl.this, NO_EXCEPTION, fd);\n+                    } else {\n+                        \/\/ Unlock so that we could close by FD policy\n+                        end();\n+                        try {\n+                            super.beforeCheckpoint(context);\n+                        } finally {\n+                            \/\/ lock again - afterRestore should start locked\n+                            begin();\n+                        }\n+                    }\n+                }\n+            } catch (ClosedChannelException e) {\n+                \/\/ ignored\n+            }\n+            \/\/ Not calling end() here - we've left the fd inconsistent\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends jdk.internal.crac.mirror.Resource> context) throws Exception {\n+            try {\n+                synchronized (stateLock) {\n+                    if (state == ST_UNCONNECTED) {\n+                        fd = Net.socket();\n+                    }\n+                }\n+            } finally {\n+                end();\n+            }\n+            super.afterRestore(context);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private final long dataBuffer;\n+    private long dataBuffer;\n@@ -103,0 +103,1 @@\n+        dataBuffer = 0;\n@@ -115,0 +116,2 @@\n+        assert(dataBuffer == 0);\n+        dataBuffer = unsafe.allocateMemory(DATA_BUFFER_SIZE);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousServerSocketChannelImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -48,0 +51,2 @@\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+            SharedSecrets.getJavaIOFileDescriptorAccess();\n@@ -157,0 +162,4 @@\n+        synchronized (fd) {\n+            \/\/ On Windows the FD value is used for sockets\n+            fdAccess.set(fd, -1);\n+        }\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousSocketChannelImpl.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static jdk.test.lib.Asserts.assertEquals;\n@@ -55,1 +56,2 @@\n-            serverSocket.accept().get().close();\n+            AsynchronousSocketChannel channel = serverSocket.accept().get();\n+            channel.close();\n@@ -58,1 +60,5 @@\n-            assertTrue(ee.getCause() instanceof AsynchronousCloseException);\n+            Throwable cause = ee.getCause();\n+            if (!(cause instanceof AsynchronousCloseException)) {\n+                assertTrue(cause instanceof IOException, ee.toString());\n+                assertTrue(ee.getMessage().contains(\"The I\/O operation has been aborted because of either a thread exit or an application request\"), ee.toString());\n+            }\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningAsynchronousSocketChannelTest.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningTestBase.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}