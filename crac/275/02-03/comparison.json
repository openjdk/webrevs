{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.util.function.Consumer;\n@@ -113,0 +114,5 @@\n+\n+            @Override\n+            public void forEachKey(AbstractSelectableChannel channel, Consumer<SelectionKey> keyConsumer) {\n+                channel.forEach(keyConsumer);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractInterruptibleChannel.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-    private void forEach(Consumer<SelectionKey> action) {\n+    void forEach(Consumer<SelectionKey> action) {\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractSelectableChannel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Consumer;\n@@ -36,0 +37,1 @@\n+    void forEachKey(AbstractSelectableChannel channel, Consumer<SelectionKey> keyConsumer);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioChannelsSpiAccess.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12,2 +12,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Consumer;\n@@ -18,4 +16,0 @@\n-    \/\/ While the collection should be used by the single thread invoking the checkpoint\n-    \/\/ we won't prevent some races that could touch these as well.\n-    private static final Map<Object, List<Runnable>> markedForReopen = new ConcurrentHashMap<>();\n-\n@@ -31,12 +25,0 @@\n-    protected static void markForReopen(Object owner) {\n-        var prev = markedForReopen.putIfAbsent(owner, Collections.synchronizedList(new ArrayList<>()));\n-        if (prev != null) {\n-            throw new IllegalStateException(\"Marking for reopen twice\");\n-        }\n-    }\n-\n-    public static Consumer<Runnable> reopenQueue(Object owner) {\n-        List<Runnable> queue = markedForReopen.get(owner);\n-        return queue == null ? null : queue::add;\n-    }\n-\n@@ -183,8 +165,0 @@\n-\n-    protected void afterReopen(Object self) {\n-        List<Runnable> runnables = markedForReopen.remove(self);\n-        if (runnables == null) {\n-            throw new IllegalStateException(self + \" was not marked for reopen\");\n-        }\n-        runnables.forEach(Runnable::run);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResourceBase.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -246,0 +246,10 @@\n+    void registerExisting(SelectionKeyImpl ski) {\n+        implRegister(ski);\n+        setEventOps(ski);\n+        keys.add(ski);\n+    }\n+\n+    void removeKey(SelectionKeyImpl ski) {\n+        keys.remove(ski);\n+    }\n+\n@@ -258,23 +268,0 @@\n-        \/\/ If a key registered on the channel that is about to be reopened\n-        \/\/ by FD policies is cancelled during JDK resource C\/R handling\n-        \/\/ this would be automatically uncancelled. We cannot prevent such race\n-        \/\/ even if marking the keys individually.\n-        Consumer<Runnable> enqueue = JDKSocketResourceBase.reopenQueue(ski.channel());\n-        if (enqueue != null) {\n-            enqueue.accept(() -> {\n-                SPI_ACCESS.revalidateSelectionKey(ski);\n-                implRegister(ski);\n-                setEventOps(ski);\n-                keys.add(ski);\n-                if (ski.channel() instanceof AbstractSelectableChannel asc) {\n-                    SPI_ACCESS.reregisterSelectionKey(asc, ski);\n-                }\n-                if (isOpen()) {\n-                    \/\/ Let the implementation process updates queue\n-                    wakeup();\n-                } else {\n-                    keys.remove(ski);\n-                    ski.cancel();\n-                }\n-            });\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorImpl.java","additions":10,"deletions":23,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+import java.nio.channels.spi.AbstractSelectableChannel;\n+import java.nio.channels.spi.AbstractSelectionKey;\n@@ -49,0 +51,1 @@\n+import java.util.ArrayList;\n@@ -51,0 +54,1 @@\n+import java.util.List;\n@@ -54,0 +58,2 @@\n+import java.util.function.Consumer;\n+\n@@ -741,0 +747,2 @@\n+        private List<SelectionKey> reopenQueue;\n+\n@@ -767,1 +775,3 @@\n-            JDKSocketResourceBase.markForReopen(ServerSocketChannelImpl.this);\n+            \/\/ No need to synchronization: reopen will be invoked from single thread\n+            reopenQueue = new ArrayList<>();\n+            SPI_ACCESS.forEachKey(ServerSocketChannelImpl.this, reopenQueue::add);\n@@ -797,1 +807,26 @@\n-            afterReopen(ServerSocketChannelImpl.this);\n+\n+            for (SelectionKey key : reopenQueue) {\n+                assert(key.channel() == ServerSocketChannelImpl.this);\n+                \/\/ If a key registered on the channel that is about to be reopened\n+                \/\/ by FD policies is cancelled during JDK resource C\/R handling\n+                \/\/ this would be automatically uncancelled.\n+                if (key instanceof AbstractSelectionKey ask) {\n+                    SPI_ACCESS.revalidateSelectionKey(ask);\n+                }\n+                if (key.channel() instanceof AbstractSelectableChannel asc) {\n+                    SPI_ACCESS.reregisterSelectionKey(asc, key);\n+                }\n+                if (key.selector() instanceof SelectorImpl selector) {\n+                    assert key instanceof SelectionKeyImpl;\n+                    SelectionKeyImpl ski = (SelectionKeyImpl) key;\n+                    selector.registerExisting(ski);\n+                    if (selector.isOpen()) {\n+                        \/\/ Let the implementation process updates queue\n+                        selector.wakeup();\n+                    } else {\n+                        selector.removeKey(ski);\n+                        key.cancel();\n+                    }\n+                }\n+            }\n+            reopenQueue = null;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"}]}