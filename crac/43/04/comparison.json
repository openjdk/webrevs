{"files":[{"patch":"@@ -36,2 +36,0 @@\n-JVM_RegisterPersistent\n-JVM_DeregisterPersistent\n","filename":"make\/data\/hotspot-symbols\/symbols-shared","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -177,4 +179,1 @@\n-    M_ZIP_CACHE    = 1 << 0,\n-    M_CANT_RESTORE = 1 << 1,\n-    M_CLASSPATH    = 1 << 2,\n-    M_PERSISTENT   = 1 << 3,\n+    M_CANT_RESTORE = 1 << 0,\n@@ -259,15 +258,0 @@\n-struct PersistentResourceDesc {\n-  int _fd;\n-  dev_t _st_dev;\n-  ino_t _st_ino;\n-  PersistentResourceDesc(int fd, int st_dev, int st_ino) :\n-    _fd(fd),\n-    _st_dev((dev_t)st_dev),\n-    _st_ino((ino_t)st_ino)\n-  {}\n-\n-  PersistentResourceDesc() :\n-    _fd(INT_MAX)\n-  {}\n-};\n-\n@@ -388,0 +372,1 @@\n+  jarray _fd_arr;\n@@ -396,1 +381,2 @@\n-  VM_Crac(bool dry_run, bufferedStream* jcmd_stream) :\n+  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n+    _fd_arr(fd_arr),\n@@ -419,0 +405,1 @@\n+  bool is_claimed_fd(int fd);\n@@ -455,1 +442,0 @@\n-static GrowableArray<PersistentResourceDesc>* _persistent_resources = NULL;\n@@ -5863,73 +5849,0 @@\n-static void mark_classpath_entry(FdsInfo *fds, char* cp) {\n-  struct stat st;\n-  if (-1 == stat(cp, &st)) {\n-    return;\n-  }\n-  for (int i = 0; i < fds->len(); ++i) {\n-    if (same_stat(&st, fds->get_stat(i))) {\n-      fds->mark(i, FdsInfo::M_CLASSPATH);\n-    }\n-  }\n-}\n-\n-static void do_classpaths(void (*fn)(FdsInfo*, char*), FdsInfo *fds, char* classpath) {\n-  assert(SafepointSynchronize::is_at_safepoint(),\n-      \"can't do nasty things with sysclasspath\");\n-  char *cp = classpath;\n-  char *n;\n-  while ((n = strchr(cp, ':'))) {\n-    *n = '\\0';\n-    fn(fds, cp);\n-    *n = ':';\n-    cp = n + 1;\n-  }\n-  mark_classpath_entry(fds, cp);\n-}\n-\n-\n-static void mark_all_in(FdsInfo *fds, char* dirpath) {\n-  DIR *dir = os::opendir(dirpath);\n-  if (!dir) {\n-    return;\n-  }\n-\n-  struct dirent* dent;\n-  while ((dent = os::readdir(dir))) {\n-    for (int i = 0; i < fds->len(); ++i) {\n-      if (fds->get_state(i) != FdsInfo::ROOT) {\n-        continue;\n-      }\n-      struct stat* fstat = fds->get_stat(i);\n-      if (dent->d_ino == fstat->st_ino) {\n-        fds->mark(i, FdsInfo::M_CLASSPATH);\n-      }\n-    }\n-  }\n-\n-  os::closedir(dir);\n-}\n-\n-static void mark_persistent(FdsInfo *fds) {\n-  if (!_persistent_resources) {\n-    return;\n-  }\n-\n-  for (int i = 0; i < _persistent_resources->length(); ++i) {\n-    PersistentResourceDesc* pr = _persistent_resources->adr_at(i);\n-    int fd = pr->_fd;\n-    if (fds->len() <= fd) {\n-      break;\n-    }\n-    if (fds->get_state(fd) != FdsInfo::ROOT) {\n-      continue;\n-    }\n-    struct stat* st = fds->get_stat(fd);\n-    if (st->st_dev == pr->_st_dev && st->st_ino == pr->_st_ino) {\n-      fds->mark(fd, FdsInfo::M_PERSISTENT);\n-    }\n-  }\n-\n-  delete _persistent_resources;\n-  _persistent_resources = NULL;\n-}\n-\n@@ -6188,0 +6101,11 @@\n+bool VM_Crac::is_claimed_fd(int fd) {\n+  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n+  for (int j = 0; j < claimed_fds->length(); ++j) {\n+    jint cfd = claimed_fds->int_at(j);\n+    if (fd == cfd) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -6193,4 +6117,0 @@\n-  do_classpaths(mark_classpath_entry, &fds, Arguments::get_sysclasspath());\n-  do_classpaths(mark_classpath_entry, &fds, Arguments::get_appclasspath());\n-  do_classpaths(mark_all_in, &fds, Arguments::get_ext_dirs());\n-  mark_persistent(&fds);\n@@ -6212,17 +6132,2 @@\n-    if (_vm_inited_fds.get_state(i, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n-      print_resources(\"OK: inherited from process env\\n\");\n-      continue;\n-    }\n-\n-    struct stat* st = fds.get_stat(i);\n-    if (S_ISCHR(st->st_mode)) {\n-      const int mjr = major(st->st_rdev);\n-      const int mnr = minor(st->st_rdev);\n-      if (mjr == 1 && (mnr == 8 || mnr == 9)) {\n-        print_resources(\"OK: always available, random or urandom\\n\");\n-        continue;\n-      }\n-    }\n-\n-    if (fds.check(i, FdsInfo::M_CLASSPATH) && !fds.check(i, FdsInfo::M_CANT_RESTORE)) {\n-      print_resources(\"OK: in classpath\\n\");\n+    if (is_claimed_fd(i)) {\n+      print_resources(\"OK: claimed by java code\\n\");\n@@ -6232,2 +6137,2 @@\n-    if (fds.check(i, FdsInfo::M_PERSISTENT)) {\n-      print_resources(\"OK: assured persistent\\n\");\n+    if (_vm_inited_fds.get_state(i, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n+      print_resources(\"OK: inherited from process env\\n\");\n@@ -6237,0 +6142,1 @@\n+    struct stat* st = fds.get_stat(i);\n@@ -6288,47 +6194,0 @@\n-void os::Linux::register_persistent_fd(int fd, int st_dev, int st_ino) {\n-  if (!CRaCCheckpointTo) {\n-    return;\n-  }\n-  if (!_persistent_resources) {\n-    _persistent_resources = new (ResourceObj::C_HEAP, mtInternal)\n-      GrowableArray<PersistentResourceDesc>(0, mtInternal);\n-  }\n-  int dup = -1;\n-  int i = 0;\n-  while (i < _persistent_resources->length()) {\n-    int pfd = _persistent_resources->adr_at(i)->_fd;\n-    if (pfd == fd) {\n-      dup = i;\n-      break;\n-    } else if (fd < pfd) {\n-      break;\n-    }\n-    ++i;\n-  }\n-\n-  if (0 <= dup) {\n-    _persistent_resources->at_put(dup, PersistentResourceDesc(fd, st_dev, st_ino));\n-  } else {\n-    _persistent_resources->insert_before(i, PersistentResourceDesc(fd, st_dev, st_ino));\n-  }\n-}\n-\n-void os::Linux::deregister_persistent_fd(int fd, int st_dev, int st_ino) {\n-  if (!CRaCCheckpointTo) {\n-    return;\n-  }\n-  if (!_persistent_resources) {\n-    return;\n-  }\n-  int i = 0;\n-  while (i < _persistent_resources->length()) {\n-    PersistentResourceDesc* pr = _persistent_resources->adr_at(i);\n-    if (pr->_fd == fd && pr->_st_dev == (dev_t)st_dev && pr->_st_ino == (ino_t)st_ino) {\n-      break;\n-    }\n-  }\n-  if (i < _persistent_resources->length()) {\n-    _persistent_resources->remove_at(i);\n-  }\n-}\n-\n@@ -6376,1 +6235,1 @@\n-Handle os::Linux::checkpoint(bool dry_run, jlong jcmd_stream, TRAPS) {\n+Handle os::Linux::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n@@ -6390,1 +6249,1 @@\n-  VM_Crac cr(dry_run, (bufferedStream*)jcmd_stream);\n+  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":25,"deletions":166,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  static Handle checkpoint(bool dry_run, jlong jcmd_stream, TRAPS);\n+  static Handle checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS);\n@@ -179,2 +179,0 @@\n-  static void register_persistent_fd(int fd, int st_dev, int st_ino);\n-  static void deregister_persistent_fd(int fd, int st_dev, int st_ino);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1146,7 +1146,1 @@\n-JVM_Checkpoint(JNIEnv *env, jboolean dry_run, jlong jcmd_stream);\n-\n-JNIEXPORT void JNICALL\n-JVM_RegisterPersistent(int fd, int st_dev, int st_ino);\n-\n-JNIEXPORT void JNICALL\n-JVM_DeregisterPersistent(int fd, int st_dev, int st_ino);\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3852,2 +3852,2 @@\n-JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jboolean dry_run, jlong jcmd_stream))\n-  Handle ret = os::Linux::checkpoint(dry_run, jcmd_stream, CHECK_NULL);\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = os::Linux::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n@@ -3856,8 +3856,0 @@\n-\n-JVM_LEAF(void, JVM_RegisterPersistent(int fd, int st_dev, int st_ino))\n-  os::Linux::register_persistent_fd(fd, st_dev, st_ino);\n-JVM_END\n-\n-JVM_LEAF(void, JVM_DeregisterPersistent(int fd, int st_dev, int st_ino))\n-  os::Linux::deregister_persistent_fd(fd, st_dev, st_ino);\n-JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -34,0 +36,1 @@\n+import java.io.FileDescriptor;\n@@ -62,0 +65,3 @@\n+    private static final JavaIOFileDescriptorAccess fdAccess\n+            = SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n@@ -113,1 +119,4 @@\n-            IOUtil.configureBlocking(IOUtil.newFD(eventfd.efd()), false);\n+            FileDescriptor fd = IOUtil.newFD(eventfd.efd());\n+            \/\/ This FileDescriptor is a one-time use, the actual FD will be closed from EventFD\n+            fdAccess.markClosed(fd);\n+            IOUtil.configureBlocking(fd, false);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.impl.CheckpointOpenFileException;\n@@ -34,0 +36,3 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKContext;\n+import jdk.internal.crac.JDKResource;\n@@ -58,0 +63,34 @@\n+    class Resource implements jdk.internal.crac.JDKResource {\n+        private boolean closedByNIO;\n+        final Exception stackTraceHolder;\n+\n+        Resource() {\n+            JDKContext jdkContext = Core.getJDKContext();\n+            jdkContext.register(this);\n+            if (JDKContext.COLLECT_FD_STACKTRACES) {\n+                stackTraceHolder = new Exception(\"This file descriptor was created here\");\n+            } else {\n+                stackTraceHolder = null;\n+            }\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n+            if (!closedByNIO) {\n+                FileDescriptor.this.beforeCheckpoint();\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends jdk.crac.Resource> context) throws Exception {\n+            FileDescriptor.this.afterRestore();\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.FILE_DESCRIPTORS;\n+        }\n+    }\n+\n+    Resource resource = new Resource();\n+\n@@ -65,0 +104,19 @@\n+\n+        Core.getJDKContext().register(checkpointListener = new JDKResource() {\n+            @Override\n+            public Priority getPriority() {\n+                return Priority.NORMAL;\n+            }\n+\n+            @Override\n+            public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) {\n+                JDKContext ctx = (JDKContext) context;\n+                ctx.claimFd(in, \"System.in\");\n+                ctx.claimFd(out, \"System.out\");\n+                ctx.claimFd(err, \"System.err\");\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends jdk.crac.Resource> context) {\n+            }\n+        });\n@@ -91,0 +149,5 @@\n+                    @Override\n+                    public void markClosed(FileDescriptor fdo) {\n+                        fdo.resource.closedByNIO = true;\n+                    }\n+\n@@ -180,0 +243,3 @@\n+    private static final JDKResource checkpointListener;\n+\n+\n@@ -300,0 +366,18 @@\n+    private synchronized void beforeCheckpoint() throws CheckpointOpenFileException {\n+        if (valid()) {\n+            JDKContext ctx = jdk.internal.crac.Core.getJDKContext();\n+            if (ctx.claimFdWeak(this, this)) {\n+                String msg = \"FileDescriptor \" + this.fd + \" left open. \";\n+                if (!JDKContext.COLLECT_FD_STACKTRACES) {\n+                    msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n+                }\n+                throw new CheckpointOpenFileException(msg, resource.stackTraceHolder);\n+            }\n+        }\n+    }\n+\n+    private synchronized void afterRestore() {\n+\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n@@ -32,0 +35,3 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKContext;\n+import jdk.internal.crac.JDKResource;\n@@ -83,0 +89,36 @@\n+    private class Resource implements JDKResource {\n+        private static final JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+        Resource() {\n+            Core.getJDKContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n+            if (Core.getJDKContext().claimFdWeak(fd, this)) {\n+                if (Core.getJDKContext().matchClasspath(path)) {\n+                    \/\/ Files on the classpath are considered persistent, exception is not thrown\n+                    return;\n+                }\n+                int fdNum = fdAccess.get(fd);\n+                String msg = \"RandomAccessFile \" + path + \" left open (file descriptor \" + fdNum + \"). \";\n+                if (!JDKContext.COLLECT_FD_STACKTRACES) {\n+                    msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n+                }\n+                throw new CheckpointOpenFileException(msg, fd.resource.stackTraceHolder);\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends jdk.crac.Resource> context) throws Exception {\n+\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.PRE_FILE_DESRIPTORS;\n+        }\n+    }\n+\n+    Resource resource = new Resource();\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.nio.charset.CharacterCodingException;\n@@ -69,0 +68,1 @@\n+import jdk.internal.crac.JDKContext;\n@@ -1804,1 +1804,1 @@\n-                    Core.registerPersistent(fd);\n+                    Core.getJDKContext().claimFd(fd, this);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-import java.io.StringWriter;\n-import java.io.PrintWriter;\n+import jdk.internal.crac.JDKContext;\n@@ -37,0 +36,2 @@\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n@@ -43,1 +44,1 @@\n-import java.util.Arrays;\n+import java.util.*;\n@@ -59,2 +60,1 @@\n-\n-    private static native Object[] checkpointRestore0(boolean dryRun, long jcmdStream);\n+    private static native Object[] checkpointRestore0(int[] fdArr, Object[] objArr, boolean dryRun, long jcmdStream);\n@@ -65,0 +65,1 @@\n+        private FlagsHolder() {}\n@@ -88,1 +89,1 @@\n-                            new CheckpointOpenFileException(messages[i]));\n+                            new CheckpointOpenFileException(messages[i], null));\n@@ -98,1 +99,1 @@\n-                            new CheckpointOpenResourceException(messages[i]));\n+                            new CheckpointOpenResourceException(messages[i], null));\n@@ -128,1 +129,12 @@\n-        final Object[] bundle = checkpointRestore0(checkpointException != null, jcmdStream);\n+        JDKContext jdkContext = jdk.internal.crac.Core.getJDKContext();\n+        List<Map.Entry<Integer, Object>> claimedPairs = jdkContext.getClaimedFds().entrySet().stream().toList();\n+        int[] fdArr = new int[claimedPairs.size()];\n+        Object[] objArr = new Object[claimedPairs.size()];\n+        LoggerContainer.debug(\"Claimed open file descriptors:\");\n+        for (int i = 0; i < claimedPairs.size(); ++i) {\n+            fdArr[i] = claimedPairs.get(i).getKey();\n+            objArr[i] = claimedPairs.get(i).getValue();\n+            LoggerContainer.debug( \"\\t%d %s\\n\", fdArr[i], objArr[i]);\n+        }\n+\n+        final Object[] bundle = checkpointRestore0(fdArr, objArr, checkpointException != null, jcmdStream);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,21 @@\n+package jdk.crac;\n+\n+\/**\n+ * Some classes that could use logging are initialized early during the boot\n+ * and keeping the logger in static final field there could cause problems\n+ * (e.g. recursion when service-loading logger implementation).\n+ * Therefore, we isolate the logger into a subclass and initialize lazily.\n+ *\/\n+public class LoggerContainer {\n+    public static final System.Logger logger = System.getLogger(\"jdk.crac\");\n+\n+    public static void info(String msg) {\n+        logger.log(System.Logger.Level.INFO, msg);\n+    }\n+\n+    public static void debug(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.DEBUG, fmt, params);\n+    }\n+\n+    private LoggerContainer() {}\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/LoggerContainer.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -25,5 +25,1 @@\n-import jdk.crac.CheckpointException;\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.RestoreException;\n-import sun.security.action.GetBooleanAction;\n+import jdk.crac.*;\n@@ -32,1 +28,2 @@\n-import java.util.stream.Collectors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -35,7 +32,3 @@\n-\n-    private static class FlagsHolder {\n-        public static final boolean DEBUG =\n-            GetBooleanAction.privilegedGetProperty(\"jdk.crac.debug\");\n-    }\n-\n-    private WeakHashMap<R, P> checkpointQ = new WeakHashMap<>();\n+    private WeakHashMap<R, Long> resources = new WeakHashMap<>();\n+    \/\/ Queue content is temporary, so we won't mind that it's not a weak reference\n+    private Queue<Map.Entry<R, Long>> resourceQueue = new LinkedList<>();\n@@ -43,1 +36,7 @@\n-    private Comparator<Map.Entry<R, P>> comparator;\n+    private volatile long currentPriority = -1;\n+    \/\/ We use two locks: checkpointLock is required for both running the beforeCheckpoint\n+    \/\/ and registering a new resource, while restoreLock is required for running afterRestore\n+    \/\/ and beforeCheckpoint (to achieve exclusivity of before and after). It is fine\n+    \/\/ to acquire checkpointLock and register a new resource during afterRestore.\n+    private final ReentrantLock checkpointLock = new ReentrantLock();\n+    private final ReentrantLock restoreLock = new ReentrantLock();\n@@ -45,2 +44,23 @@\n-    protected AbstractContextImpl(Comparator<Map.Entry<R, P>> comparator) {\n-        this.comparator = comparator;\n+    protected void register(R resource, long priority) {\n+        assert priority >= 0;\n+        boolean locked = false;\n+        try {\n+            \/\/ We don't want to deadlock if the registration happens from another thread\n+            while (!checkpointLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n+                throwIfCheckpointInProgress(priority);\n+            }\n+            locked = true;\n+            \/\/ This is important for the case of recursive registration\n+            throwIfCheckpointInProgress(priority);\n+            if (currentPriority < 0) {\n+                resources.put(resource, priority);\n+            } else {\n+                resourceQueue.add(Map.entry(resource, priority));\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        } finally {\n+            if (locked) {\n+                checkpointLock.unlock();\n+            }\n+        }\n@@ -49,2 +69,5 @@\n-    protected synchronized void register(R resource, P payload) {\n-        checkpointQ.put(resource, payload);\n+    private void throwIfCheckpointInProgress(long priority) {\n+        if (priority <= currentPriority) {\n+            throw new IllegalStateException(\"Notifications for an upcoming checkpoint are already in progress (priority \"\n+                    + currentPriority + \"). Please make sure to register this resource earlier or use higher priorty (\" + priority + \")\");\n+        }\n@@ -54,5 +77,18 @@\n-    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-        List<R> resources = checkpointQ.entrySet().stream()\n-            .sorted(comparator)\n-            .map(Map.Entry::getKey)\n-            .collect(Collectors.toList());\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        \/\/ If afterRestore is running we need to delay the beforeCheckpoint\n+        restoreLock.lock();\n+        try {\n+            checkpointLock.lock();\n+            try {\n+                runBeforeCheckpoint();\n+            } finally {\n+                if (restoreQ != null) {\n+                    Collections.reverse(restoreQ);\n+                }\n+                currentPriority = -1;\n+                checkpointLock.unlock();\n+            }\n+        } finally {\n+            restoreLock.unlock();\n+        }\n+    }\n@@ -60,0 +96,5 @@\n+    private void runBeforeCheckpoint() throws CheckpointException {\n+        Map.Entry<R, Long> drained;\n+        while ((drained = resourceQueue.poll()) != null) {\n+            resources.put(drained.getKey(), drained.getValue());\n+        }\n@@ -61,3 +102,21 @@\n-        for (Resource r : resources) {\n-            if (FlagsHolder.DEBUG) {\n-                System.err.println(\"jdk.crac beforeCheckpoint \" + r.toString());\n+        TreeMap<Long, List<R>> resources = this.resources.entrySet().stream().collect(\n+                TreeMap::new, (m, e) -> m.computeIfAbsent(e.getValue(), p -> new ArrayList<>()).add(e.getKey()), TreeMap::putAll);\n+        restoreQ = new ArrayList<>(this.resources.size());\n+\n+        \/\/ We cannot simply iterate because we could cause mutations\n+        while (!resources.isEmpty()) {\n+            var entry = resources.firstEntry();\n+            resources.remove(entry.getKey());\n+            currentPriority = entry.getKey();\n+            for (R r : entry.getValue()) {\n+                LoggerContainer.debug(\"beforeCheckpoint %s\", r);\n+                try {\n+                    r.beforeCheckpoint(this);\n+                    restoreQ.add(r);\n+                } catch (CheckpointException e) {\n+                    for (Throwable t : e.getSuppressed()) {\n+                        exception.addSuppressed(t);\n+                    }\n+                } catch (Exception e) {\n+                    exception.addSuppressed(e);\n+                }\n@@ -65,5 +124,4 @@\n-            try {\n-                r.beforeCheckpoint(this);\n-            } catch (CheckpointException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    exception.addSuppressed(t);\n+            while ((drained = resourceQueue.poll()) != null) {\n+                if (drained.getValue() <= currentPriority) {\n+                    \/\/ this should be prevented in register method\n+                    throw new IllegalStateException();\n@@ -71,2 +129,1 @@\n-            } catch (Exception e) {\n-                exception.addSuppressed(e);\n+                resources.computeIfAbsent(drained.getValue(), p -> new ArrayList<>()).add(drained.getKey());\n@@ -76,3 +133,0 @@\n-        Collections.reverse(resources);\n-        restoreQ = resources;\n-\n@@ -85,11 +139,18 @@\n-    public synchronized void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-        RestoreException exception = new RestoreException();\n-        for (Resource r : restoreQ) {\n-            if (FlagsHolder.DEBUG) {\n-                System.err.println(\"jdk.crac afterRestore \" + r.toString());\n-            }\n-            try {\n-                r.afterRestore(this);\n-            } catch (RestoreException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    exception.addSuppressed(t);\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        restoreLock.lock();\n+        try {\n+            RestoreException exception = new RestoreException();\n+            for (Resource r : restoreQ) {\n+                LoggerContainer.debug(\"afterRestore %s\");\n+                try {\n+                    r.afterRestore(this);\n+                } catch (RestoreException e) {\n+                    Throwable[] suppressed = e.getSuppressed();\n+                    if (suppressed.length == 0) {\n+                        exception.addSuppressed(e);\n+                    }\n+                    for (Throwable t : suppressed) {\n+                        exception.addSuppressed(t);\n+                    }\n+                } catch (Exception e) {\n+                    exception.addSuppressed(e);\n@@ -97,2 +158,0 @@\n-            } catch (Exception e) {\n-                exception.addSuppressed(e);\n@@ -100,2 +159,1 @@\n-        }\n-        restoreQ = null;\n+            restoreQ = null;\n@@ -103,2 +161,5 @@\n-        if (0 < exception.getSuppressed().length) {\n-            throw exception;\n+            if (0 < exception.getSuppressed().length) {\n+                throw exception;\n+            }\n+        } finally {\n+            restoreLock.unlock();\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":114,"deletions":53,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public CheckpointOpenFileException(String details) {\n-        super(details);\n+    public CheckpointOpenFileException(String details, Throwable cause) {\n+        super(details, cause);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenFileException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public CheckpointOpenResourceException(String details) {\n-        super(details);\n+    public CheckpointOpenResourceException(String details, Throwable cause) {\n+        super(details, cause);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenResourceException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-        super(details);\n+        super(details, null);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenSocketException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,7 +38,0 @@\n-    static class ContextComparator implements Comparator<Map.Entry<Resource, Long>> {\n-        @Override\n-        public int compare(Map.Entry<Resource, Long> o1, Map.Entry<Resource, Long> o2) {\n-            return (int)(o2.getValue() - o1.getValue());\n-        }\n-    }\n-\n@@ -46,1 +39,0 @@\n-        super(new ContextComparator());\n@@ -51,1 +43,4 @@\n-        register(r, order++);\n+        \/\/ Priorities are executed from lowest to highest; in order to call\n+        \/\/ beforeCheckpoint in reverse order compared to registration we use\n+        \/\/ descending numbers.\n+        register(r, Long.MAX_VALUE - (order++));\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    public void markClosed(FileDescriptor fdo);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOFileDescriptorAccess.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.WeakHashMap;\n@@ -33,3 +34,0 @@\n-\n-    private static native void registerPersistent0(FileDescriptor fd);\n-\n@@ -44,4 +42,0 @@\n-\n-    public static void registerPersistent(FileDescriptor fd) {\n-        registerPersistent0(fd);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n@@ -30,0 +34,3 @@\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.action.GetBooleanAction;\n@@ -31,2 +38,7 @@\n-import java.util.Comparator;\n-import java.util.Map;\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.stream.Collectors;\n@@ -35,4 +47,24 @@\n-    static class ContextComparator implements Comparator<Map.Entry<JDKResource, Void>> {\n-        @Override\n-        public int compare(Map.Entry<JDKResource, Void> o1, Map.Entry<JDKResource, Void> o2) {\n-            return o1.getKey().getPriority().compareTo(o2.getKey().getPriority());\n+    public static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n+    public static final String COLLECT_FD_STACKTRACES_HINT = \"Use -D\" + COLLECT_FD_STACKTRACES_PROPERTY + \"=true to find the source.\";\n+    public static final boolean COLLECT_FD_STACKTRACES =\n+            GetBooleanAction.privilegedGetProperty(JDKContext.COLLECT_FD_STACKTRACES_PROPERTY);\n+\n+    private WeakHashMap<FileDescriptor, Object> claimedFds;\n+\n+    public boolean matchClasspath(String path) {\n+        Path p = Path.of(path);\n+        String classpath = System.getProperty(\"java.class.path\");\n+        int index = 0;\n+        while (index >= 0) {\n+            int end = classpath.indexOf(File.pathSeparatorChar, index);\n+            if (end < 0) {\n+                end = classpath.length();\n+            }\n+            try {\n+                if (Files.isSameFile(p, Path.of(classpath.substring(index, end)))) {\n+                    return true;\n+                }\n+            } catch (IOException e) {\n+                \/\/ ignore exception\n+                return false;\n+            }\n@@ -40,0 +72,1 @@\n+        return false;\n@@ -43,1 +76,12 @@\n-        super(new ContextComparator());\n+    }\n+\n+    @Override\n+    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        claimedFds = new WeakHashMap<>();\n+        super.beforeCheckpoint(context);\n+    }\n+\n+    @Override\n+    public synchronized void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        super.afterRestore(context);\n+        claimedFds = null;\n@@ -48,1 +92,24 @@\n-        register(resource, null);\n+        register(resource, resource.getPriority().ordinal());\n+    }\n+\n+    public Map<Integer, Object> getClaimedFds() {\n+        JavaIOFileDescriptorAccess fileDescriptorAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+        return claimedFds.entrySet().stream()\n+                .collect(Collectors.toMap(entry -> fileDescriptorAccess.get(entry.getKey()), Map.Entry::getValue));\n+    }\n+\n+    public void claimFd(FileDescriptor fd, Object obj) {\n+        if (!fd.valid()) {\n+            return;\n+        }\n+        Object e = claimedFds.put(fd, obj);\n+        if (e != null) {\n+            throw new AssertionError(fd + \" was already claimed by \" + e);\n+        }\n+    }\n+\n+    public boolean claimFdWeak(FileDescriptor fd, Object obj) {\n+        if (!fd.valid()) {\n+            return false;\n+        }\n+        return claimedFds.putIfAbsent(fd, obj) == null;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":75,"deletions":8,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+\n+        PRE_FILE_DESRIPTORS,\n+        FILE_DESCRIPTORS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.crac.LoggerContainer;\n@@ -39,7 +40,0 @@\n-    \/\/ PersistentJarFile is <clinit>ed when loading classes on the module path;\n-    \/\/ when initializing the logger an implementation of logging is looked up through\n-    \/\/ service-loading and that causes a recursion in opening the module.\n-    \/\/ Therefore, we isolate the logger into a subclass and initialize only when needed.\n-    private static class LoggerContainer {\n-        private static final System.Logger logger = System.getLogger(\"jdk.crac\");\n-    }\n@@ -54,1 +48,1 @@\n-        LoggerContainer.logger.log(System.Logger.Level.INFO, this.getName() + \" is recorded as always available on restore\");\n+        LoggerContainer.info(this.getName() + \" is recorded as always available on restore\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKContext;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -145,2 +151,2 @@\n-    private static final class UnclosableInputStream extends FilterInputStream {\n-        UnclosableInputStream(InputStream in) {\n+    private static final class UnclosableInputStream extends FilterInputStream implements JDKResource {\n+        UnclosableInputStream(FileInputStream in) {\n@@ -148,0 +154,1 @@\n+            Core.getJDKContext().register(this);\n@@ -158,0 +165,15 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            ((JDKContext)context).claimFd(((FileInputStream)in).getFD(), this);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.NORMAL;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/FileInputStreamPool.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"jdk_internal_crac_Core.h\"\n@@ -39,16 +38,2 @@\n-Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jboolean dry_run, jlong jcmd_stream)\n-{\n-    return JVM_Checkpoint(env, dry_run, jcmd_stream);\n-}\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_crac_Core_registerPersistent0\n-  (JNIEnv *env, jclass ignore, jobject fileDesc)\n-{\n-    jint fd = THIS_FD(fileDesc);\n-\n-    struct stat st;\n-    if (-1 == fstat(fd, &st)) {\n-        return;\n-    }\n-\n-    JVM_RegisterPersistent(fd, st.st_dev, st.st_ino);\n+Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jarray fdArr, jobjectArray objArr, jboolean dry_run, jlong jcmd_stream) {\n+    return JVM_Checkpoint(env, fdArr, objArr, dry_run, jcmd_stream);\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        FileDispatcherImpl.close0(fd);\n+        FileDispatcherImpl.closeAndMark(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/DatagramDispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.crac.JDKResource.Priority;\n@@ -209,0 +208,7 @@\n+    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n+    \/\/ NOT used by FileDispatcherImpl\n+    static void closeAndMark(FileDescriptor fd) throws IOException {\n+        fdAccess.markClosed(fd);\n+        close0(fd);\n+    }\n+\n@@ -246,3 +252,1 @@\n-    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n-    \/\/ NOT used by FileDispatcherImpl\n-    static native void close0(FileDescriptor fd) throws IOException;\n+    private static native void close0(FileDescriptor fd) throws IOException;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        FileDispatcherImpl.close0(fd);\n+        FileDispatcherImpl.closeAndMark(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SocketDispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKContext;\n@@ -400,0 +402,2 @@\n+\n+            Core.getJDKContext().register(this);\n@@ -596,0 +600,6 @@\n+            synchronized (LOCK_SET_SEED) {\n+                if (seedOut != null) {\n+                    Core.getJDKContext().claimFdWeak(((FileOutputStream)seedOut).getFD(), this);\n+                }\n+            }\n+\n@@ -612,1 +622,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,2 @@\n+static char* altstack = NULL;\n+\n@@ -72,1 +74,8 @@\n-  static char altstack[SIGSTKSZ];\n+  if (altstack == NULL) {\n+    \/\/ Dynamically allocated in case SIGSTKSZ is not constant\n+    altstack = malloc(SIGSTKSZ);\n+    if (altstack == NULL) {\n+      fprintf(stderr, \"Test ERROR. Unable to malloc altstack space\\n\");\n+      exit(7);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/runtime\/StackGuardPages\/exeinvoke.c","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.crac.*;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracEngine;\n-import jdk.test.lib.crac.CracTest;\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @build LazyProps\n- * @run driver jdk.test.lib.crac.CracTest\n- *\/\n-public class LazyProps implements CracTest {\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().engine(CracEngine.SIMULATE)\n-                .captureOutput(true)\n-                .startCheckpoint().waitForSuccess()\n-                .outputAnalyzer().shouldContain(\"jdk.crac beforeCheckpoint\");\n-    }\n-\n-    @Override\n-    public void exec() throws RestoreException, CheckpointException {\n-        Resource resource = new Resource() {\n-            @Override\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception { }\n-            @Override\n-            public void afterRestore(Context<? extends Resource> context) throws Exception { }\n-        };\n-        Core.getGlobalContext().register(resource);\n-\n-        System.setProperty(\"jdk.crac.debug\", \"true\");\n-        Core.checkpointRestore();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/LazyProps.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"}]}