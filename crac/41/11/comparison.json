{"files":[{"patch":"@@ -247,0 +247,1 @@\n+      os_linux_ifunc.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,0 +149,3 @@\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -536,0 +536,3 @@\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -223,1 +223,10 @@\n-             \"mitigations for the Intel JCC erratum\")\n+             \"mitigations for the Intel JCC erratum\")                       \\\n+                                                                            \\\n+  product(ccstr, CPUFeatures, NULL, \"CPU feature set, \"                     \\\n+      \"use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when you \"    \\\n+      \"get an error during -XX:CRaCRestoreFrom on a different machine; \"    \\\n+      \"-XX:CPUFeatures=native is the default; \"                             \\\n+      \"-XX:CPUFeatures=generic is compatible but not as slow as 0\")         \\\n+                                                                            \\\n+  product(bool, ShowCPUFeatures, false, \"Show features of this CPU \"        \\\n+      \"to be possibly used for the -XX:CPUFeatures=0xnumber option\")\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -618,0 +618,35 @@\n+uint64_t VM_Version::CPUFeatures_parse(const char *ccstr) {\n+  assert(ccstr, \"CPUFeatures_parse NULL\");\n+  if (strcmp(ccstr, \"native\") == 0) {\n+    return Abstract_VM_Version::features();\n+  }\n+  if (strcmp(ccstr, \"generic\") == 0) {\n+    \/\/ 32-bit x86 cannot rely on anything.\n+    return 0\n+#ifdef AMD64\n+      \/\/ These options are all in \/proc\/cpuinfo of one of the first 64-bit CPUs - Atom D2700 (and Opteron 1352): https:\/\/superuser.com\/q\/1572306\/1015048\n+      | CPU_SSE | CPU_SSE2 \/\/ enabled in 'gcc -Q --help=target', used by OpenJDK\n+      | CPU_FXSR \/\/ enabled in 'gcc -Q --help=target', unused by OpenJDK\n+      | CPU_MMX \/\/ enabled in 'gcc -Q --help=target', used only by 32-bit x86 OpenJDK\n+      | CPU_TSC \/\/ not used by gcc, used by OpenJDK\n+      | CPU_CX8 \/\/ gcc detects it to set cpu \"pentium\" (=32-bit only), used by OpenJDK\n+      | CPU_CMOV \/\/ gcc detects it to set cpu \"pentiumpro\" (=32-bit only), used by OpenJDK\n+      | CPU_FLUSH \/\/ =\"clflush\" in cpuinfo, not used by gcc, required by OpenJDK\n+#endif\n+    ;\n+  }\n+  char *endptr;\n+  errno = 0;\n+  unsigned long long ull = strtoull(ccstr, &endptr, 0);\n+  if (!errno && (!endptr || !*endptr))\n+    return ull;\n+  char buf[512];\n+  int res = jio_snprintf(\n+              buf, sizeof(buf),\n+              \"Improperly specified VM option 'CPUFeatures=%s'\", ccstr);\n+  assert(res > 0, \"not enough temporary space allocated\");\n+  vm_exit_during_initialization(buf);\n+  \/\/ NOTREACHED\n+  return 0;\n+}\n+\n@@ -645,0 +680,25 @@\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"This machine's CPU features are: -XX:CPUFeatures=0x\" UINT64_FORMAT_X, _features);\n+  }\n+\n+  assert(!CPUFeatures == FLAG_IS_DEFAULT(CPUFeatures), \"CPUFeatures parsing\");\n+  if (CPUFeatures) {\n+    uint64_t CPUFeatures_x64 = CPUFeatures_parse(CPUFeatures);\n+    uint64_t features_missing = CPUFeatures_x64 & ~_features;\n+    if (features_missing) {\n+      char buf[512];\n+      int res = jio_snprintf(\n+                  buf, sizeof(buf),\n+                  \"Specified -XX:CPUFeatures=0x\" UINT64_FORMAT_X\n+                  \"; this machine's CPU features are 0x\" UINT64_FORMAT_X\n+                  \"; missing features of this CPU are 0x\" UINT64_FORMAT_X \" \",\n+                  CPUFeatures_x64, _features, features_missing);\n+      assert(res > 0, \"not enough temporary space allocated\");\n+      insert_features_names(buf + res, sizeof(buf) - res, features_missing);\n+      assert(buf[res] == ',', \"unexpeced VM_Version::insert_features_names separator instead of ','\");\n+      buf[res] = '=';\n+      vm_exit_during_initialization(buf);\n+    }\n+    _features = CPUFeatures_x64;\n+  }\n+\n@@ -797,1 +857,1 @@\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  insert_features_names(buf + res, sizeof(buf) - res);\n@@ -1888,1 +1948,1 @@\n-void VM_Version::initialize() {\n+void VM_Version::initialize_features() {\n@@ -1904,0 +1964,4 @@\n+}\n+\n+void VM_Version::initialize() {\n+  initialize_features();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -712,0 +712,2 @@\n+  static uint64_t CPUFeatures_parse(const char *ccstr);\n+\n@@ -743,0 +745,4 @@\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _features_names, features);\n+  }\n+\n@@ -746,0 +752,1 @@\n+  static void initialize_features();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"os_linux_ifunc.hpp\"\n@@ -122,0 +123,1 @@\n+# include <execinfo.h>\n@@ -417,0 +419,1 @@\n+  static void verify_cpu_compatibility();\n@@ -643,1 +646,1 @@\n-void os::Linux::initialize_system_info() {\n+void os::Linux::initialize_processor_count() {\n@@ -645,0 +648,5 @@\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n+void os::Linux::initialize_system_info() {\n+  initialize_processor_count();\n@@ -657,1 +665,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n@@ -6022,1 +6029,230 @@\n-static int checkpoint_restore(int *shmid) {\n+class Freeze {\n+  static const int signo = SIGUSR1;\n+  struct sigaction act_old;\n+  GrowableArray<pid_t> all_threads_done;\n+\n+  template<class Callback> bool all_threads(Callback callback) {\n+    const char dirname[] = \"\/proc\/self\/task\";\n+    DIR *dir = opendir(dirname);\n+    if (dir == NULL) {\n+      tty->print_cr(\"JVM: Error opening %s: %m\", dirname);\n+      return false;\n+    }\n+    pid_t tid = gettid();\n+    struct dirent *ent;\n+    while (errno = 0, ent = readdir(dir)) {\n+      const char *name = ent->d_name;\n+      if (strcmp(name, \".\") == 0)\n+\tcontinue;\n+      if (strcmp(name, \"..\") == 0)\n+\tcontinue;\n+      char *endptr;\n+      unsigned long ul = strtoul(name, &endptr, 10);\n+      pid_t ent_tid = ul;\n+      if (ul >= LONG_MAX || ent_tid != (long) ul) {\n+\ttty->print_cr(\"JVM: Error parsing %s entry \\\"%s\\\"\", dirname, name);\n+\treturn false;\n+      }\n+      if (ent_tid == tid)\n+\tcontinue;\n+      if (!all_threads_done.append_if_missing(ent_tid))\n+\tcontinue;\n+      callback(ent_tid);\n+    }\n+    if (errno) {\n+      tty->print_cr(\"JVM: Error reading %s: %m\", dirname);\n+      return false;\n+    }\n+    if (closedir(dir)) {\n+      tty->print_cr(\"JVM: Error closing %s: %m\", dirname);\n+      return false;\n+    }\n+    return true;\n+  }\n+  static pthread_mutex_t signaled_and_in_handler_mutex; \/\/ protect both 'signaled' and 'in_handler'\n+  static pthread_cond_t signaled_cond;\n+  static size_t signaled, in_handler;\n+  static pthread_cond_t resume_cond;\n+#ifdef __x86_64__\n+  __attribute__((noinline, noclone)) static bool caller_is_unsafe() {\n+    \/\/ [0] is ourselves, [1] is handler(), [2] is signal frame, [3] is a signal-interrupted code.\n+    const size_t bt_size = 4;\n+    void *bt[bt_size];\n+    if (backtrace(bt, bt_size) != bt_size) {\n+      tty->print_cr(\"JVM: Freeze: TID %d backtrace(%zu) failed\\n\", (int)gettid(), bt_size);\n+      return false;\n+    }\n+    const void *code = bt[bt_size - 1];\n+    Dl_info info;\n+    if (!dladdr(code, &info)) {\n+      \/\/ Signal-interrupted code is not in a shared library.\n+      return false;\n+    }\n+    const char *cs = strrchr(info.dli_fname, '\/');\n+    if (!cs || strcmp(cs + 1, \"libc.so.6\") != 0) {\n+      \/\/ Signal-interrupted code is not in glibc.\n+      return false;\n+    }\n+    const uint16_t *syscall = ((const uint16_t *)code) - 1;\n+    \/\/ The check is not absolutely safe as we cannot disasemble backwards.\n+    if (*syscall == 0x050f) {\n+      \/\/ Signal-interrupted code is waiting in syscall.\n+      return false;\n+    }\n+    return true;\n+  }\n+#endif \/\/ __x86_64__\n+  static void handler(int handler_signo) {\n+    assert(handler_signo == signo, \"handler signo\");\n+    int err;\n+    err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    ++signaled;\n+    ++in_handler;\n+    err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    err = pthread_cond_signal(&signaled_cond);\n+    assert(!err, \"pthread error\");\n+#ifdef __x86_64__\n+    if (caller_is_unsafe()) {\n+      frozen = false;\n+      err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+      assert(!err, \"pthread error\");\n+      --in_handler;\n+      err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+      assert(!err, \"pthread error\");\n+      return;\n+    }\n+#endif \/\/ __x86_64__\n+    \/\/ Just wait until thaw() is called. No mutex is needed for that.\n+    pthread_mutex_t unused_mutex = PTHREAD_MUTEX_INITIALIZER;\n+    err = pthread_mutex_lock(&unused_mutex);\n+    assert(!err, \"pthread error\");\n+    err = pthread_cond_wait(&resume_cond, &unused_mutex);\n+    assert(!err, \"pthread error\");\n+    err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    --in_handler;\n+    err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+  }\n+  static bool frozen;\n+#ifdef ASSERT\n+  static bool singleton;\n+#endif\n+\n+public:\n+  bool freeze() {\n+    assert(!frozen, \"double freeze?\");\n+    struct sigaction act;\n+    memset(&act, 0, sizeof(act));\n+    act.sa_handler = handler;\n+    if (sigaction(signo, &act, &act_old)) {\n+      tty->print_cr(\"JVM: Freeze::freeze sigaction(%d): %m\", signo);\n+      return false;\n+    }\n+    assert(act_old.sa_handler == SIG_DFL, \"SIG_DFL for signo\");\n+    signaled_and_in_handler_mutex = PTHREAD_MUTEX_INITIALIZER;\n+    signaled_cond = PTHREAD_COND_INITIALIZER;\n+    signaled = 0;\n+    in_handler = 0;\n+    resume_cond = PTHREAD_COND_INITIALIZER;\n+    size_t count = 0;\n+    frozen = true;\n+    bool retry;\n+    all_threads_done.clear();\n+    do {\n+      retry = false;\n+      all_threads([&](pid_t ent_tid) {\n+\tif (!tgkill(getpid(), ent_tid, signo)) {\n+\t  ++count;\n+\t  retry = true;\n+\t} else {\n+\t  tty->print_cr(\"JVM: Error sending signal %d to TID %ld\", signo, (long)ent_tid);\n+\t  frozen = false;\n+\t}\n+      });\n+      int err;\n+      err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+      assert(!err, \"pthread error\");\n+      while (signaled < count) {\n+\terr = pthread_cond_wait(&signaled_cond, &signaled_and_in_handler_mutex);\n+\tassert(!err, \"pthread error\");\n+      }\n+      assert(signaled == count, \"JVM: Freeze: signaled == count\");\n+      err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+      assert(!err, \"pthread error\");\n+    } while (retry && frozen);\n+    if (sigaction(signo, &act_old, NULL)) {\n+      tty->print_cr(\"JVM: Freeze::thaw sigaction(%d): %m\", signo);\n+      return false;\n+    }\n+    return frozen;\n+  }\n+  bool freeze_retried() {\n+    for (int retry = 0; retry < 100; ++retry) {\n+      freeze();\n+      if (frozen)\n+\treturn frozen;\n+      thaw();\n+      if (retry == 0)\n+\ttty->print_cr(\"JVM: Freeze: Some tasks are unsafe to freeze (in glibc), retrying\");\n+      usleep(1000000\/2 + random() % 1000000\/2);\n+    }\n+    tty->print_cr(\"JVM: Freeze: Some tasks failed to freeze (in glibc)\");\n+    return frozen;\n+  }\n+  size_t in_handler_get_locked() {\n+    int err;\n+    err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    size_t retval = in_handler;\n+    err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    return retval;\n+  }\n+  void thaw() {\n+    while (in_handler_get_locked()) {\n+      int err;\n+      err = pthread_cond_broadcast(&resume_cond);\n+      assert(!err, \"pthread error\");\n+#ifdef _POSIX_PRIORITY_SCHEDULING\n+      err = sched_yield();\n+      assert(!err, \"sched_yield error\");\n+#endif\n+    }\n+  }\n+  Freeze() {\n+#ifdef ASSERT\n+    assert(!singleton, \"singleton safety\");\n+    singleton = true;\n+#endif\n+    frozen = false;\n+  }\n+  ~Freeze() {\n+    if (frozen)\n+      thaw();\n+#ifdef ASSERT\n+    assert(singleton, \"singleton safety\");\n+    singleton = false;\n+#endif\n+  }\n+};\n+pthread_mutex_t Freeze::signaled_and_in_handler_mutex;\n+pthread_cond_t Freeze::signaled_cond;\n+size_t Freeze::signaled, Freeze::in_handler;\n+pthread_cond_t Freeze::resume_cond;\n+bool Freeze::frozen;\n+#ifdef ASSERT\n+bool Freeze::singleton = false;\n+#endif\n+\n+int os::Linux::checkpoint_restore(int *shmid) {\n+\n+  \/\/ All the systems for restore should have the same glibc version (despite possibly different CPUs).\n+  linux_ifunc_fetch_offsets();\n+\n+  Freeze freeze;\n+  if (!freeze.freeze_retried()) {\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n@@ -6040,0 +6276,8 @@\n+  linux_ifunc_reset();\n+\n+  initialize_processor_count();\n+  if (_cpu_to_node != NULL)\n+    rebuild_cpu_to_node_map();\n+\n+  freeze.thaw();\n+\n@@ -6187,0 +6431,52 @@\n+void VM_Crac::verify_cpu_compatibility() {\n+  uint64_t features_saved = Abstract_VM_Version::features();\n+#define SUPPORTS_SET \\\n+    SUPPORTS(supports_cx8) \\\n+    SUPPORTS(supports_atomic_getset4) \\\n+    SUPPORTS(supports_atomic_getset8) \\\n+    SUPPORTS(supports_atomic_getadd4) \\\n+    SUPPORTS(supports_atomic_getadd8) \\\n+    \/**\/\n+#define SUPPORTS(x) bool x##_saved = Abstract_VM_Version::x();\n+  SUPPORTS_SET\n+#undef SUPPORTS\n+\n+  \/\/ FIXME: x86 only\n+  StubCodeDesc::thaw();\n+  VM_Version::initialize_features();\n+\n+  \/\/ Abstract_VM_Version::features() may be less than current CPU's features as they have been already masked by the CPUFeatures argument (if it is present).\n+  uint64_t features_missing = features_saved & ~Abstract_VM_Version::features();\n+  if (features_missing) {\n+    char buf[512];\n+    int res = jio_snprintf(\n+                buf, sizeof(buf),\n+                \"You have to specify -XX:CPUFeatures=0x\" UINT64_FORMAT_X \" during -XX:CRaCCheckpointTo making of the checkpoint\"\n+                \"; specified -XX:CRaCRestoreFrom file contains CPU features 0x\" UINT64_FORMAT_X\n+                \"; missing features of this CPU are 0x\" UINT64_FORMAT_X \" \",\n+                Abstract_VM_Version::features() & features_saved,\n+                features_saved, features_missing);\n+    assert(res > 0, \"not enough temporary space allocated\");\n+    VM_Version::insert_features_names(buf + res, sizeof(buf) - res, features_missing);\n+    assert(buf[res] == ',', \"unexpeced VM_Version::insert_features_names separator instead of ','\");\n+    buf[res] = '=';\n+    vm_exit_during_initialization(buf);\n+  }\n+  auto supports_exit = [&](const char *supports, bool file, bool this_cpu) {\n+    char buf[512];\n+    int res = jio_snprintf(\n+                buf, sizeof(buf),\n+                \"Specified -XX:CRaCRestoreFrom file contains feature \\\"%s\\\" value %d while this CPU has value %d\",\n+                supports, file, this_cpu);\n+    assert(res > 0, \"not enough temporary space allocated\");\n+    vm_exit_during_initialization(buf);\n+  };\n+#define SUPPORTS(x)                                           \\\n+  if (x##_saved != Abstract_VM_Version::x()) {                \\\n+    supports_exit( #x , Abstract_VM_Version::x(), x##_saved); \\\n+  }\n+  SUPPORTS_SET\n+#undef SUPPORTS\n+#undef SUPPORTS_SET\n+}\n+\n@@ -6271,1 +6567,1 @@\n-    int ret = checkpoint_restore(&shmid);\n+    int ret = os::Linux::checkpoint_restore(&shmid);\n@@ -6278,0 +6574,2 @@\n+  verify_cpu_compatibility();\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":302,"deletions":4,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  static void initialize_processor_count();\n@@ -188,0 +189,2 @@\n+  static int checkpoint_restore(int *shmid);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,738 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#define _GNU_SOURCE 1\n+#include <stddef.h>\n+#include <dlfcn.h>\n+#include <assert.h>\n+#include <stdio.h>\n+#include <link.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include <limits.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+#include <sys\/mman.h>\n+#include <sys\/user.h>\n+#include <stdlib.h>\n+\n+\/\/ These offsets are for Debian 12 x86_64:\n+\/\/ gdb -batch \/lib64\/ld-linux-x86-64.so.2 -ex\n+static unsigned   l_scope_offset = 0x3b0;\n+static const char l_scope_offset_expr[] = \"p &((struct link_map *)0)->l_scope\";\n+static unsigned   l_relocated_offset = 0x334;\n+static const char l_relocated_offset_expr[] = \"p &((struct link_map *)0)->l_relocated\";\n+static unsigned   rtld_global_ro_dl_x86_cpu_features_offset = 0x70;\n+static const char rtld_global_ro_dl_x86_cpu_features_offset_expr[] = \"p (void *)&_rtld_global_ro._dl_x86_cpu_features - (void *)&_rtld_global_ro\";\n+static unsigned   rtld_global_ro_dl_x86_cpu_features_sizeof = 0x1e0;\n+static const char rtld_global_ro_dl_x86_cpu_features_sizeof_expr[] = \"p sizeof(_rtld_global_ro._dl_x86_cpu_features)\";\n+static unsigned   arch_kind_unknown = 0;\n+static const char arch_kind_unknown_expr[] = \"p (int)arch_kind_unknown\";\n+static unsigned   tunable_t_sizeof = 112;\n+static const char tunable_t_sizeof_expr[] = \"p sizeof(tunable_t)\";\n+static unsigned   l_relocated_bitno = 3;\n+\n+#ifndef DT_RELRSZ\n+#define DT_RELRSZ       35              \/* Total size of RELR relative relocations *\/\n+#endif\n+\n+#define strcmp strcmp_local\n+static int strcmp_local(const char *s1, const char *s2) {\n+  const unsigned char *a = (const unsigned char *) s1;\n+  const unsigned char *b = (const unsigned char *) s2;\n+  for (;; ++a, ++b) {\n+    if (*a != *b)\n+      return *b > *a ? +1 : -1;\n+    if (*a == 0)\n+      return 0;\n+  }\n+}\n+\n+#define memcmp memcmp_local\n+static int memcmp_local(const void *s1, const void *s2, size_t n) {\n+  const unsigned char *a = (const unsigned char *) s1;\n+  const unsigned char *b = (const unsigned char *) s2;\n+  for (; n-- > 0; ++a, ++b) {\n+    if (*a != *b)\n+      return *b > *a ? +1 : -1;\n+  }\n+  return 0;\n+}\n+\n+#define strchr strchr_local\n+static char *strchr_local(char *s, int c) {\n+  for (; *s; ++s)\n+    if ((uint8_t)*s == (uint8_t)c)\n+      return s;\n+  return NULL;\n+}\n+static const char *strchr_local(const char *cs, int c) {\n+  return strchr_local((char *)cs, c);\n+}\n+\n+#define strlen strlen_local\n+__attribute__ ((optimize(0))) \/\/ otherwise GCC will replace the function by system strlen() again; also fixed by -fno-builtin\n+static size_t strlen_local(const char *cs) {\n+  size_t retval = 0;\n+  while (*cs++)\n+    ++retval;\n+  return retval;\n+}\n+\n+#define memset memset_local\n+static void *memset_local(void *m, int c, size_t n) {\n+  for (uint8_t *d = (uint8_t *)m; n--; ++d)\n+    *d = c;\n+  return m;\n+}\n+\n+static void ehdr_verify(const Elf64_Ehdr *ehdr) {\n+  assert(ehdr->e_ident[EI_MAG0] == ELFMAG0);\n+  assert(ehdr->e_ident[EI_MAG1] == ELFMAG1);\n+  assert(ehdr->e_ident[EI_MAG2] == ELFMAG2);\n+  assert(ehdr->e_ident[EI_MAG3] == ELFMAG3);\n+  assert(ehdr->e_ident[EI_CLASS] == ELFCLASS64);\n+  assert(ehdr->e_ident[EI_VERSION] == EV_CURRENT);\n+  assert(ehdr->e_ident[EI_OSABI] == ELFOSABI_NONE\n+      || ehdr->e_ident[EI_OSABI] == ELFOSABI_GNU\/*STT_GNU_IFUNC*\/);\n+}\n+\n+size_t file_page_size(int fd) {\n+  off_t retval = lseek(fd, 0, SEEK_END);\n+  assert(retval != (off_t)-1);\n+  retval += PAGE_SIZE - 1;\n+  retval &= -PAGE_SIZE;\n+  return retval;\n+}\n+\n+static const void *file_mmap(int fd) {\n+  const void *retval = mmap(NULL, file_page_size(fd), PROT_READ, MAP_PRIVATE, fd, 0);\n+  assert(retval != MAP_FAILED);\n+  return retval;\n+}\n+\n+static void file_munmap(const void *p, int fd) {\n+  int err = munmap((void *)p, file_page_size(fd));\n+  assert(!err);\n+}\n+\n+struct symtab_lookup {\n+  const char *name;\n+  const void *start, *end;\n+  unsigned sht;\n+};\n+static int symtab_lookup_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data_voidp) {\n+  struct symtab_lookup *data_p = (struct symtab_lookup *)data_voidp;\n+  const char *filename = info->dlpi_name;\n+  if (strcmp(filename, \"linux-vdso.so.1\") == 0)\n+    return 0; \/\/ unused\n+  if (!*filename)\n+    filename = \"\/proc\/self\/exe\";\n+  int elf_fd = open(filename, O_RDONLY);\n+  assert(elf_fd != -1);\n+  const Elf64_Ehdr *ehdr = (const Elf64_Ehdr *)file_mmap(elf_fd);\n+  ehdr_verify(ehdr);\n+  assert(ehdr->e_phentsize == sizeof(Elf64_Phdr));\n+  assert(ehdr->e_phnum == info->dlpi_phnum);\n+  const Elf64_Shdr *shdr_base = (const Elf64_Shdr *)(((const uint8_t *)ehdr) + ehdr->e_shoff);\n+  assert(ehdr->e_shentsize == sizeof(*shdr_base));\n+  const Elf64_Sym *symtab = NULL;\n+  size_t sym_count = 0;\n+  const char *strtab;\n+  size_t strtab_size;\n+  for (size_t shdr_ix = 0; shdr_ix < ehdr->e_shnum; ++shdr_ix) {\n+    const Elf64_Shdr *shdr = shdr_base + shdr_ix;\n+    \/\/   [34] .symtab           SYMTAB          0000000000000000 0cfb68 003fd8 18     35 642  8\n+    if (shdr->sh_type == data_p->sht) {\n+      symtab = (const Elf64_Sym *)(((const uint8_t *)ehdr) + shdr->sh_offset);\n+      sym_count = shdr->sh_size \/ sizeof(*symtab);\n+      assert(shdr->sh_size == sym_count * sizeof(*symtab));\n+      assert(shdr->sh_link);\n+      const Elf64_Shdr *strtab_shdr = shdr_base + shdr->sh_link;\n+      strtab = (const char *)(((const uint8_t *)ehdr) + strtab_shdr->sh_offset);\n+      strtab_size = strtab_shdr->sh_size;\n+      break;\n+    }\n+  }\n+  for (size_t sym_ix = 0; sym_ix < sym_count; ++sym_ix) {\n+    const Elf64_Sym *sym = symtab + sym_ix;\n+    assert(sym->st_name < strtab_size);\n+    if (strcmp(strtab + sym->st_name, data_p->name) == 0) {\n+      \/\/assert(ELF64_ST_BIND(sym->st_info) == STB_LOCAL); \/\/ FIXME\n+      \/\/assert(ELF64_ST_TYPE(sym->st_info) == STT_FUNC); \/\/ FIXME\n+      assert(ELF64_ST_VISIBILITY(sym->st_other) == STV_DEFAULT); \/\/ FIXME\n+      if (sym->st_shndx == SHN_UNDEF) {\n+        assert(sym->st_value == 0);\n+        assert(sym->st_size == 0);\n+        continue;\n+      }\n+      assert(sym->st_value != 0);\n+      assert(sym->st_size != 0);\n+      \/\/ FIXME: We may have found the symbol multiple times - which one is preferred?\n+      data_p->start = (const void *)(((uintptr_t)sym->st_value) + info->dlpi_addr);\n+      data_p->end = (const void *)(((const uint8_t *)data_p->start) + sym->st_size);\n+      break;\n+    }\n+  }\n+  file_munmap(ehdr, elf_fd);\n+  int err = close(elf_fd);\n+  assert(!err);\n+  return 0;\n+}\n+\n+static const void *symtab_lookup(const char *name, const void **end_return, unsigned sht) {\n+  assert(sht == SHT_DYNSYM || sht == SHT_SYMTAB);\n+  struct symtab_lookup data;\n+  data.name = name;\n+  data.start = NULL;\n+  data.sht= sht;\n+  int i = dl_iterate_phdr(symtab_lookup_iterate_phdr, &data);\n+  assert(!i);\n+  if (sht == SHT_DYNSYM) {\n+    if (!data.start) {\n+      fprintf(stderr, \"symtab_lookup failed: %s\\n\", name);\n+      assert(0);\n+    }\n+    const void *dl = dlsym(RTLD_DEFAULT, name);\n+    assert(dl == data.start);\n+  }\n+  if (end_return)\n+    *end_return = data.end;\n+  return data.start;\n+}\n+\n+static char *file_read(const char *fn) {\n+  int fd = open(fn, O_RDONLY);\n+  assert(fd != -1);\n+  \/\/ realloc() calls memmove().\n+  size_t buf_size = 0x100000;\n+  char *buf = (char *)malloc(buf_size);\n+  assert(buf);\n+  size_t buf_have = 0;\n+  for (;;) {\n+    assert(buf_have < buf_size);\n+    ssize_t got = read(fd, buf + buf_have, buf_size - buf_have);\n+    assert(got != -1);\n+    if (got == 0)\n+      break;\n+    assert(got > 0);\n+    assert(buf_have + got <= buf_size);\n+    buf_have += got;\n+  }\n+  assert(buf_have < buf_size);\n+  buf[buf_have] = 0;\n+  assert(strlen(buf) == buf_have);\n+  return buf;\n+}\n+\n+static uint64_t read_hex(const char **cs_p) {\n+  uint64_t retval = 0;\n+  for (;;)\n+#define cs (*cs_p)\n+    switch (*cs) {\n+    case '0' ... '9':\n+      retval <<= 4;\n+      retval |= *cs++ - '0';\n+      continue;\n+    case 'a' ... 'f':\n+      retval <<= 4;\n+      retval |= *cs++ - 'a' + 0xa;\n+      continue;\n+    default:\n+      return retval;\n+      break;\n+    }\n+#undef cs\n+}\n+\n+static int mprotect_read(const void *addr, const void **addr_end_return) {\n+  uint64_t addr_u = (uintptr_t)addr;\n+  char *file = file_read(\"\/proc\/self\/maps\");\n+  int retval = -1;\n+  for (const char *cs = file; *cs;) {\n+    \/\/ sscanf() calls rawmemchr().\n+    uint64_t start = read_hex(&cs);\n+    assert(*cs == '-');\n+    ++cs;\n+    uint64_t end = read_hex(&cs);\n+    assert(*cs == ' ');\n+    ++cs;\n+    assert(start < end);\n+    int rwxp = 0;\n+    assert(*cs == 'r' || *cs == '-');\n+    if (*cs++ == 'r')\n+      rwxp |= 04;\n+    assert(*cs == 'w' || *cs == '-');\n+    if (*cs++ == 'w')\n+      rwxp |= 02;\n+    assert(*cs == 'x' || *cs == '-');\n+    if (*cs++ == 'x')\n+      rwxp |= 01;\n+    assert(*cs == 's' || *cs == 'p');\n+    ++cs;\n+    assert(*cs == ' ');\n+    ++cs;\n+    if (start <= addr_u && addr_u < end) {\n+      if (addr_end_return)\n+        *addr_end_return = (const void *)(uintptr_t)end;\n+      retval = rwxp;\n+      break;\n+    }\n+    cs = strchr(cs, '\\n');\n+    assert(cs);\n+    ++cs;\n+  }\n+  if (retval == -1) {\n+    fprintf(stderr, \"Not found an address: %p\\n\", addr);\n+    assert(0);\n+  }\n+  free(file);\n+  return retval;\n+}\n+\n+static void verify_rwxp(const void *start, const void *end, int rwxp_want) {\n+  assert((((uintptr_t)start) & (PAGE_SIZE - 1)) == 0);\n+  assert((((uintptr_t)end  ) & (PAGE_SIZE - 1)) == 0);\n+  assert(start < end);\n+  while (start < end) {\n+    int rwxp_found = mprotect_read(start, &start);\n+    if (rwxp_found != rwxp_want) { printf(\"sudo gdb -p %d\\n\",getpid()); pause(); }\n+    assert(rwxp_found == rwxp_want);\n+  }\n+}\n+\n+const struct link_map *phdr_info_to_link_map(struct dl_phdr_info *phdr_info) {\n+  Dl_info info;\n+  const struct link_map *link_map = NULL;\n+  int err = dladdr1(phdr_info->dlpi_phdr, &info, (void **)&link_map, RTLD_DL_LINKMAP);\n+  assert(err == 1);\n+  assert(link_map);\n+  return link_map;\n+}\n+\n+static void page_align(const void **start_p, const void **end_p) {\n+  *start_p = (const void *)(((uintptr_t)*start_p) & -PAGE_SIZE);\n+  assert(*start_p);\n+  *end_p = (const void *)((((uintptr_t)*end_p) + PAGE_SIZE - 1) & -PAGE_SIZE);\n+}\n+\n+static void readonly_unset(const void *start, const void *end) {\n+  assert((((uintptr_t)start) & (PAGE_SIZE - 1)) == 0);\n+  assert((((uintptr_t)end  ) & (PAGE_SIZE - 1)) == 0);\n+  assert(start <= end);\n+  if (start == end)\n+    return;\n+  verify_rwxp(start, end, 04\/*r--*\/);\n+  int err = mprotect((void *)start, (const uint8_t *)end - (const uint8_t *)start, PROT_READ | PROT_WRITE);\n+  assert(!err);\n+  verify_rwxp(start, end, 06\/*rw-*\/);\n+}\n+\n+static void readonly_reset(const void *start, const void *end) {\n+  assert((((uintptr_t)start) & (PAGE_SIZE - 1)) == 0);\n+  assert((((uintptr_t)end  ) & (PAGE_SIZE - 1)) == 0);\n+  assert(start <= end);\n+  if (start == end)\n+    return;\n+  verify_rwxp(start, end, 06\/*rw-*\/);\n+  int err = mprotect((void *)start, (const uint8_t *)end - (const uint8_t *)start, PROT_READ);\n+  assert(!err);\n+  verify_rwxp(start, end, 04\/*r--*\/);\n+}\n+\n+static const void *dl_relocate_object_get() {\n+  const uint8_t *dl_get_tls_static_info = (const uint8_t *)symtab_lookup(\"_dl_get_tls_static_info\", NULL, SHT_DYNSYM);\n+  const uint8_t and_1shl27_edx_mov_rsi_offset_rbp[] = { 0x81, 0xe2, 0x00, 0x00, 0x00, 0x08, 0x48, 0x89, 0xb5 };\n+  const uint8_t *p = dl_get_tls_static_info - 1;\n+  for (;;) {\n+    if (memcmp(p, and_1shl27_edx_mov_rsi_offset_rbp, sizeof(and_1shl27_edx_mov_rsi_offset_rbp)) == 0)\n+      break;\n+    --p;\n+  }\n+  const uint8_t push_rbp_mov_rsp_rbp[] = { 0x55, 0x48, 0x89, 0xe5 };\n+  for (;;) {\n+    if (memcmp(p, push_rbp_mov_rsp_rbp, sizeof(push_rbp_mov_rsp_rbp)) == 0)\n+      break;\n+    --p;\n+  }\n+  const uint8_t endbr64[] = { 0xf3, 0x0f, 0x1e, 0xfa };\n+  if (memcmp(p - sizeof(endbr64), endbr64, sizeof(endbr64)) == 0)\n+    p -= sizeof(endbr64);\n+  return p;\n+}\n+\n+static void swap(const void **a_p, const void **b_p) {\n+  const void *p = *a_p;\n+  *a_p = *b_p;\n+  *b_p = p;\n+}\n+\n+static void intersect(const void **first_start_p, const void **first_end_p, const void **second_start_p, const void **second_end_p) {\n+  assert((((uintptr_t)*first_start_p) & (PAGE_SIZE - 1)) == 0);\n+  assert((((uintptr_t)*first_end_p  ) & (PAGE_SIZE - 1)) == 0);\n+  assert(*first_start_p <= *first_end_p);\n+  assert((((uintptr_t)*second_start_p) & (PAGE_SIZE - 1)) == 0);\n+  assert((((uintptr_t)*second_end_p  ) & (PAGE_SIZE - 1)) == 0);\n+  assert(*second_start_p <= *second_end_p);\n+  if (*first_start_p > *second_start_p) {\n+    swap(first_start_p, second_start_p);\n+    swap(second_start_p, second_start_p);\n+  }\n+  if (*second_start_p < *first_end_p) {\n+    *second_start_p = *first_end_p;\n+    if (*second_start_p > *second_end_p)\n+      *second_end_p = *second_start_p;\n+  }\n+}\n+\n+typedef void (*dl_relocate_object_p) (struct link_map *l, const void *\/*struct r_scope_elem *scope[]*\/, int reloc_mode, int consider_profiling);\n+\n+static int reset_ifunc_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data_unused) {\n+  dl_relocate_object_p dl_relocate_object = (dl_relocate_object_p)dl_relocate_object_get();\n+  dl_relocate_object_p dl_relocate_object_symtab = (dl_relocate_object_p)symtab_lookup(\"_dl_relocate_object\", NULL, SHT_SYMTAB);\n+  assert(dl_relocate_object_symtab == NULL || dl_relocate_object_symtab == dl_relocate_object);\n+  if (strcmp(info->dlpi_name, \"\/lib64\/ld-linux-x86-64.so.2\") == 0) \/\/ _dl_relocate_object would crash on scope == NULL.\n+    return 0; \/\/ unused\n+  const void *relro = NULL;\n+  const void *relro_end;\n+  assert(size >= offsetof(struct dl_phdr_info, dlpi_adds));\n+  for (size_t phdr_ix = 0; phdr_ix < info->dlpi_phnum; ++phdr_ix) {\n+    const Elf64_Phdr *phdr = info->dlpi_phdr + phdr_ix;\n+    if (phdr->p_type == PT_GNU_RELRO) {\n+      \/\/ It does not apply: assert(phdr->p_offset == phdr->p_vaddr);\n+      assert(phdr->p_paddr == phdr->p_vaddr);\n+      \/\/ \/lib64\/libz.so.1: p_filesz=0x538 > p_memsz=0x550\n+      assert(!relro);\n+      relro = (const void *)(uintptr_t)(phdr->p_vaddr + info->dlpi_addr);\n+      relro_end = (const void *)(((const uint8_t *)relro) + phdr->p_memsz);\n+      page_align(&relro, &relro_end);\n+      assert(relro);\n+    }\n+  }\n+  if (relro)\n+    readonly_unset(relro, relro_end);\n+  const struct link_map *map = phdr_info_to_link_map(info);\n+  Elf64_Dyn *dynamic = map->l_ld;\n+  Elf64_Xword *relxsz_p = NULL;\n+  Elf64_Xword *relrsz_p = NULL;\n+  Elf64_Xword *relxcount_p = NULL;\n+  for (; dynamic->d_tag != DT_NULL; ++dynamic)\n+    switch (dynamic->d_tag) {\n+    case DT_RELASZ:\n+    case DT_RELSZ:\n+      assert(!relxsz_p);\n+      relxsz_p = &dynamic->d_un.d_val;\n+      break;\n+    case DT_RELRSZ:\n+      assert(!relrsz_p);\n+      relrsz_p = &dynamic->d_un.d_val;\n+      break;\n+    case DT_RELCOUNT:\n+    case DT_RELACOUNT:\n+      assert(!relxcount_p);\n+      relxcount_p = &dynamic->d_un.d_val;\n+      break;\n+    case DT_PLTREL:\n+      \/\/ It is impossible to relocate DT_REL twice.\n+      assert(dynamic->d_un.d_val == DT_RELA);\n+      break;\n+    }\n+  Elf64_Xword relxsz_saved;\n+  if (relxsz_p) {\n+    relxsz_saved = *relxsz_p;\n+    *relxsz_p = 0;\n+  }\n+  Elf64_Xword relrsz_saved;\n+  if (relrsz_p) {\n+    relrsz_saved = *relrsz_p;\n+    *relrsz_p = 0;\n+  }\n+  Elf64_Xword relxcount_saved;\n+  if (relxcount_p) {\n+    relxcount_saved = *relxcount_p;\n+    *relxcount_p = 0;\n+  }\n+  unsigned *l_relocated_p = (unsigned *)(((const uint8_t *)map) + l_relocated_offset);\n+  assert(*l_relocated_p & (1 << l_relocated_bitno));\n+  *l_relocated_p &= ~(1 << l_relocated_bitno);\n+  assert(!(*l_relocated_p & (1 << l_relocated_bitno)));\n+  void **l_scope_p = (void **)(((const uint8_t *)map) + l_scope_offset);\n+  \/\/ FIXME: skip ifuncs\n+  dl_relocate_object((struct link_map *)map, *l_scope_p, 0\/*lazy*\/, 0\/*consider_profiling*\/);\n+  \/\/ It was read\/write before but dl_relocate_object made it read-only.\n+  const void *dynamic_start = NULL;\n+  const void *dynamic_end;\n+  if (relxsz_p) {\n+    dynamic_start = relxsz_p;\n+    dynamic_end = relxsz_p + 1;\n+  }\n+  if (relrsz_p) {\n+    if (!dynamic_start) {\n+      dynamic_start = relrsz_p;\n+      dynamic_end = relrsz_p + 1;\n+    } else {\n+      if (dynamic_start > relrsz_p)\n+        dynamic_start = relrsz_p;\n+      if (dynamic_end < relrsz_p + 1)\n+        dynamic_end = relrsz_p + 1;\n+    }\n+  }\n+  if (relxcount_p) {\n+    if (!dynamic_start) {\n+      dynamic_start = relxcount_p;\n+      dynamic_end = relxcount_p + 1;\n+    } else {\n+      if (dynamic_start > relxcount_p)\n+        dynamic_start = relxcount_p;\n+      if (dynamic_end < relxcount_p + 1)\n+        dynamic_end = relxcount_p + 1;\n+    }\n+  }\n+  if (dynamic_start) {\n+    page_align(&dynamic_start, &dynamic_end);\n+    \/\/ dl_relocate_object made it already readonly: readonly_reset(relro, relro_end);\n+    intersect(&relro, &relro_end, &dynamic_start, &dynamic_end);\n+    readonly_unset(relro, relro_end);\n+    readonly_unset(dynamic_start, dynamic_end);\n+  }\n+  if (relxsz_p)\n+    *relxsz_p = relxsz_saved;\n+  if (relrsz_p)\n+    *relrsz_p = relrsz_saved;\n+  if (relxcount_p)\n+    *relxcount_p = relxcount_saved;\n+  if (dynamic_start)\n+    readonly_reset(dynamic_start, dynamic_end);\n+  if (relro)\n+    readonly_reset(relro, relro_end);\n+  return 0; \/\/ unused\n+}\n+\n+\/* 00000000000168b0 <__tunable_get_val>:\n+ * 168b0:       f3 0f 1e fa             endbr64\n+ * 168b4:       89 ff                   mov    %edi,%edi\n+ * 168b6:       48 8d 0d e3 f1 01 00    lea    0x1f1e3(%rip),%rcx        # 35aa0 <tunable_list>\n+ *\/\n+static const void *tunable_list_get() {\n+  const uint8_t *tunable_get_val = (const uint8_t *)symtab_lookup(\"__tunable_get_val\", NULL, SHT_DYNSYM);\n+  const uint8_t endbr64[] = { 0xf3, 0x0f, 0x1e, 0xfa };\n+  if (memcmp(tunable_get_val, endbr64, sizeof(endbr64)) == 0)\n+    tunable_get_val += sizeof(endbr64);\n+  const uint8_t mov_edi_edi[] = { 0x89, 0xff };\n+  assert(memcmp(tunable_get_val, mov_edi_edi, sizeof(mov_edi_edi)) == 0);\n+  tunable_get_val += sizeof(mov_edi_edi);\n+  const uint8_t lea_offset_rip_rcx[] = { 0x48, 0x8d, 0x0d };\n+  assert(memcmp(tunable_get_val, lea_offset_rip_rcx, sizeof(lea_offset_rip_rcx)) == 0);\n+  tunable_get_val += sizeof(lea_offset_rip_rcx);\n+  return tunable_get_val + 4 + *(const uint32_t *)tunable_get_val;\n+}\n+\n+static size_t tunable_list_count() {\n+  FILE *f = popen(\"\/lib64\/ld-linux-x86-64.so.2 --list-tunables\", \"r\");\n+  assert(f);\n+  size_t lines = 0;\n+  for (;;) {\n+    int i = fgetc(f);\n+    if (i == EOF)\n+      break;\n+    if (i == '\\n')\n+      ++lines;\n+  }\n+  assert(!ferror(f));\n+  assert(feof(f));\n+  int rc = pclose(f);\n+  assert(rc == 0);\n+  return lines;\n+}\n+\n+static const void *dl_x86_init_cpu_features_get() {\n+  const uint8_t *dl_x86_get_cpu_features = (const uint8_t *)symtab_lookup(\"_dl_x86_get_cpu_features\", NULL, SHT_DYNSYM);\n+  const uint8_t mov_offset_rip_eax[] = { 0x8b, 0x05 };\n+  const uint8_t *p = dl_x86_get_cpu_features - 1;\n+  for (;;) {\n+    if (memcmp(p, mov_offset_rip_eax, sizeof(mov_offset_rip_eax)) == 0)\n+      break;\n+    --p;\n+  }\n+  const uint8_t endbr64[] = { 0xf3, 0x0f, 0x1e, 0xfa };\n+  if (memcmp(p - sizeof(endbr64), endbr64, sizeof(endbr64)) == 0)\n+    p -= sizeof(endbr64);\n+  return p;\n+}\n+\n+typedef void (*dl_x86_init_cpu_features_p)();\n+static void reset_glibc() {\n+  const void *rtld_global_ro_end;\n+  const void *rtld_global_ro = symtab_lookup(\"_rtld_global_ro\", &rtld_global_ro_end, SHT_DYNSYM);\n+  const void *rtld_global_ro_symtab_end;\n+  const void *rtld_global_ro_symtab = symtab_lookup(\"_rtld_global_ro\", &rtld_global_ro_symtab_end, SHT_SYMTAB);\n+  if (rtld_global_ro_symtab) {\n+    assert(rtld_global_ro_symtab == rtld_global_ro);\n+    assert(rtld_global_ro_symtab_end == rtld_global_ro_end);\n+  }\n+  const void *rtld_global_ro_exact = rtld_global_ro;\n+  const void *tunable_list = tunable_list_get();\n+  const void *tunable_list_end = ((const uint8_t *)tunable_list) + tunable_t_sizeof * tunable_list_count();\n+  const void *tunable_list_symtab_end;\n+  const void *tunable_list_symtab = symtab_lookup(\"tunable_list\", &tunable_list_symtab_end, SHT_SYMTAB);\n+  assert(tunable_list_symtab == NULL || tunable_list_symtab == tunable_list);\n+  assert(tunable_list_symtab == NULL || tunable_list_symtab_end == tunable_list_end);\n+  page_align(&rtld_global_ro, &rtld_global_ro_end);\n+  page_align(&tunable_list, &tunable_list_end);\n+  intersect(&rtld_global_ro, &rtld_global_ro_end, &tunable_list, &tunable_list_end);\n+  readonly_unset(rtld_global_ro, rtld_global_ro_end);\n+  readonly_unset(tunable_list, tunable_list_end);\n+  void *cpu_features = (void *)(((uint8_t *)rtld_global_ro_exact) + rtld_global_ro_dl_x86_cpu_features_offset);\n+  assert(*(const uint32_t *)cpu_features != arch_kind_unknown); \/\/ .basic.kind\n+  memset(cpu_features, 0, rtld_global_ro_dl_x86_cpu_features_sizeof);\n+  assert(*(const uint32_t *)cpu_features == arch_kind_unknown); \/\/ .basic.kind\n+  dl_x86_init_cpu_features_p dl_x86_init_cpu_features = (dl_x86_init_cpu_features_p)dl_x86_init_cpu_features_get();\n+  dl_x86_init_cpu_features_p dl_x86_init_cpu_features_symtab = (dl_x86_init_cpu_features_p)symtab_lookup(\"_dl_x86_init_cpu_features\", NULL, SHT_SYMTAB);\n+  assert(dl_x86_init_cpu_features_symtab == NULL || dl_x86_init_cpu_features_symtab == dl_x86_init_cpu_features);\n+  (*dl_x86_init_cpu_features)();\n+  assert(*(const uint32_t *)cpu_features != arch_kind_unknown); \/\/ .basic.kind\n+  readonly_reset(rtld_global_ro, rtld_global_ro_end);\n+  readonly_reset(tunable_list, tunable_list_end);\n+}\n+\n+static FILE *fetch_offset_popen(const char *expr) {\n+  char *cmd;\n+  int err;\n+  err = asprintf(&cmd, \"gdb -batch \/lib64\/ld-linux-x86-64.so.2 -ex '%s'\", expr);\n+  assert(err > 0);\n+  FILE *f = popen(cmd, \"r\");\n+  assert(f);\n+  free(cmd);\n+  return f;\n+}\n+\n+static void fetch_offset(unsigned *unsigned_p, const char *expr) {\n+  FILE *f = fetch_offset_popen(expr);\n+  char line[LINE_MAX];\n+  char *s = fgets(line, sizeof(line), f);\n+  if (s == NULL) {\n+    assert(feof(f));\n+    assert(!ferror(f));\n+    return;\n+  }\n+  assert(s == line);\n+  s = strchr(line, '\\n');\n+  assert(s);\n+  assert(!s[1]);\n+  *s = 0;\n+  s = strrchr(line, ')');\n+  if (s)\n+    ++s;\n+  else {\n+    s = strrchr(line, '=');\n+    if (!s) {\n+      fprintf(stderr, \"No ')' or '=' found for: %s\\n\", expr);\n+      return;\n+    }\n+    ++s;\n+  }\n+  int err;\n+  err = pclose(f);\n+  char *end;\n+  unsigned long ul = strtoul(s, &end, 0);\n+  if (ul >= INT_MAX || (end && *end)) {\n+    fprintf(stderr,\"Number not parseable \\\"%s\\\" for: %s\\n\", s, expr);\n+    return;\n+  }\n+  assert(!err);\n+  if (*unsigned_p == ul)\n+    return;\n+  fprintf(stderr,\"%u->%lu %s\\n\",*unsigned_p,ul,expr);\n+  *unsigned_p = ul;\n+}\n+\n+static void fetch_l_relocated_bitno() {\n+  FILE *f = fetch_offset_popen(\"ptype\/o struct link_map\");\n+  char line[LINE_MAX];\n+  for (;;) {\n+    char *s = fgets(line, sizeof(line), f);\n+    if (!s) {\n+      assert(feof(f));\n+      assert(!ferror(f));\n+      break;\n+    }\n+    s = strchr(line, '\\n');\n+    assert(s);\n+    assert(!s[1]);\n+    *s = 0;\n+    \/\/ ptype\/o struct link_map\n+    \/\/ \/*    820: 3   |       4 *\/    unsigned int l_relocated : 1;\n+    \/\/            ^\n+    \/\/ 820==0x334\n+    if (!strstr(line, \" l_relocated : 1;\"))\n+      continue;\n+    assert(line[0] == '\/');\n+    assert(line[1] == '*');\n+    char *end;\n+    unsigned long ul;\n+    ul = strtoul(line + 2, &end, 0);\n+    if (!end || *end != ':') {\n+      fprintf(stderr, \"':' not found: %s\\n\", line);\n+      break;\n+    }\n+    if (ul != l_relocated_offset) {\n+      fprintf(stderr, \"l_relocated_offset = %u != %lu from: %s\\n\", l_relocated_offset, ul, line);\n+      break;\n+    }\n+    ul = strtoul(end + 1, &end, 0);\n+    while (end && *end == ' ')\n+      ++end;\n+    if (!end || *end != '|') {\n+      fprintf(stderr, \"'|' not found: %s end=%s ul=%lu\\n\", line, end,ul);\n+      break;\n+    }\n+    if (ul >= 320) {\n+      fprintf(stderr, \"Too large l_relocated_bitno = %lu: %s\\n\", ul, line);\n+      break;\n+    }\n+    fprintf(stderr,\"%u->%lu %s\\n\",l_relocated_bitno,ul,\"l_relocated_bitno\");\n+    l_relocated_bitno = ul;\n+    break;\n+  }\n+  pclose(f);\n+}\n+\n+void linux_ifunc_fetch_offsets() {\n+#define GET(n) fetch_offset(&n, n##_expr)\n+  GET(l_scope_offset);\n+  GET(l_relocated_offset);\n+  GET(rtld_global_ro_dl_x86_cpu_features_offset);\n+  GET(rtld_global_ro_dl_x86_cpu_features_sizeof);\n+  GET(arch_kind_unknown);\n+  GET(tunable_t_sizeof);\n+  fetch_l_relocated_bitno();\n+}\n+\n+void linux_ifunc_reset() {\n+  \/\/ dl_relocate_object() from reset_ifunc_iterate_phdr may be calling glibc ifunc resolvers already.\n+  reset_glibc();\n+  int i = dl_iterate_phdr(reset_ifunc_iterate_phdr, NULL\/*data*\/);\n+  assert(!i);\n+}\n","filename":"src\/hotspot\/os\/linux\/os_linux_ifunc.cpp","additions":738,"deletions":0,"binary":false,"changes":738,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_OS_LINUX_IFUNC_HPP\n+#define OS_LINUX_OS_LINUX_IFUNC_HPP\n+\n+void linux_ifunc_fetch_offsets();\n+void linux_ifunc_reset();\n+\n+#endif \/\/ OS_LINUX_OS_LINUX_IFUNC_HPP\n","filename":"src\/hotspot\/os\/linux\/os_linux_ifunc.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -218,0 +218,7 @@\n+  if (info != NULL && uc != NULL && thread == NULL && sig == SIGSEGV) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n+      \/\/ Verify that OS save\/restore AVX registers.\n+      stub = VM_Version::cpuinfo_cont_addr();\n+    }\n+  } else\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -301,2 +301,1 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n-  uint64_t features = _features;\n+void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features) {\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+  static void insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features = _features);\n+\n@@ -124,1 +126,0 @@\n-  static void insert_features_names(char* buf, size_t buflen, const char* features_names[]);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+void StubCodeDesc::thaw() {\n+  assert(_frozen, \"repeated thaw operation\");\n+  _frozen = false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  static void thaw();\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2329,0 +2329,9 @@\n+.B \\f[CB]\\-XX:CPUFeatures=\\f[R]\\f[I]0xnumber\\f[R]\n+CPU feature set, use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when\n+you get an error during -XX:CRaCRestoreFrom on a different machine.\n+\\f[CB]\\-XX:CPUFeatures=native\\f[R] is the default.\n+\\f[CB]\\-XX:CPUFeatures=generic\\f[R] is compatible with any CPU but not as slow\n+as \\f[CB]\\-XX:CPUFeatures=0\\f[R].\n+.RS\n+.RE\n+.TP\n@@ -2610,0 +2619,6 @@\n+.B \\f[CB]\\-XX:+ShowCPUFeatures\\f[R]\n+Show features of this CPU to be possibly used for the\n+\\f[CB]\\-XX:CPUFeatures=0xnumber\\f[R] option.\n+.RS\n+.RE\n+.TP\n","filename":"src\/java.base\/share\/man\/java.1","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,2 @@\n+static char* altstack = NULL;\n+\n@@ -72,1 +74,8 @@\n-  static char altstack[SIGSTKSZ];\n+  if (altstack == NULL) {\n+    \/\/ Dynamically allocated in case SIGSTKSZ is not constant\n+    altstack = malloc(SIGSTKSZ);\n+    if (altstack == NULL) {\n+      fprintf(stderr, \"Test ERROR. Unable to malloc altstack space\\n\");\n+      exit(7);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/runtime\/StackGuardPages\/exeinvoke.c","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}