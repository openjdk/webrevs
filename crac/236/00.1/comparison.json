{"files":[{"patch":"@@ -65,0 +65,1 @@\n+    -tag crac:cmopt:'CRaC:' \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -823,0 +823,2 @@\n+USE_CRIU_CRAC:=@USE_CRIU_CRAC@\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+LINUX_X64_CRIU_FILENAME=criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_URL=https:\/\/github.com\/CRaC\/criu\/releases\/download\/release-1.3\/criu-crac-release-1.3.tar.gz\n+LINUX_X64_CRIU_SHA256=82a014bf342c957305b98a71867c0994ebf6e7379f01f083121884793768d966\n+\n","filename":"make\/conf\/github-actions.conf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,0 +159,4 @@\n+ifneq ($(call check-jvm-feature, cpu_feature_active), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_CPU_FEATURE_ACTIVE=0\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,0 +205,13 @@\n+# Build checkpoint\/restore exec library\n+################################################################################\n+\n+# CFLAGS_windows from make\/autoconf\/flags-cflags.m4#FLAGS_SETUP_CFLAGS_HELPER\n+$(eval $(call SetupJdkLibrary, BUILD_LIBCREXEC, \\\n+    NAME := crexec, \\\n+    LINK_TYPE := C++, \\\n+    EXTRA_HEADER_DIRS := libjvm, \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB) -DCRLIB_IS_IMPL, \\\n+    CXXFLAGS_windows := -D_WINDOWS -DWIN32, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB), \\\n+))\n+TARGETS += $(BUILD_LIBCREXEC)\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    BUILD_TEST_LIB_JAR_EXCLUDES := jdk\/test\/lib\/containers\n+    BUILD_TEST_LIB_JAR_EXCLUDES := jdk\/test\/lib\/containers\/cgroup jdk\/test\/lib\/containers\/systemd\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -43,0 +44,7 @@\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# if defined(__clang__) && defined(__STRICT_ANSI__)\n+\/\/ clang <stdbool.h> is missing this definition compared to gcc\n+#  define _Bool bool\n+# endif\n+# include <sys\/platform\/x86.h>\n+#endif\n@@ -49,0 +57,3 @@\n+uint64_t VM_Version::_glibc_features;\n+uint64_t VM_Version::_features_saved;\n+uint64_t VM_Version::_glibc_features_saved;\n@@ -51,1 +62,2 @@\n-const char* VM_Version::_features_names[] = { CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::      _features_names[] = {   CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::_glibc_features_names[] = { GLIBC_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n@@ -87,2 +99,11 @@\n-  assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), \"clflush should be available\");\n-  return true;\n+  if (!Universe::is_fully_initialized()) {\n+    return true;\n+  }\n+  if ((_features & CPU_FLUSH) != 0) {\n+    return true;\n+  }\n+  if (FLAG_IS_DEFAULT(CPUFeatures)) {\n+    vm_exit_during_initialization(\"clflush should be available\");\n+  }\n+  vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: \" UINT64_FORMAT_X, CPU_FLUSH));\n+  return false;\n@@ -861,1 +882,290 @@\n-void VM_Version::get_processor_features() {\n+uint64_t VM_Version::CPUFeatures_parse(const char *str, uint64_t &glibc_features) {\n+  glibc_features = _glibc_features;\n+#ifndef LINUX\n+  _ignore_glibc_not_using = true;\n+  return _features;\n+#endif\n+  if (str == nullptr || strcmp(str, \"native\") == 0) {\n+    return _features;\n+  }\n+  if (strcmp(str, \"ignore\") == 0) {\n+    _ignore_glibc_not_using = true;\n+    return _features;\n+  }\n+  glibc_features = 0;\n+  if (strcmp(str, \"generic\") == 0) {\n+    \/\/ 32-bit x86 cannot rely on anything.\n+    return 0\n+#ifdef AMD64\n+      \/\/ The following options are all in \/proc\/cpuinfo of one of the first 64-bit CPUs - Atom D2700 (and Opteron 1352): https:\/\/superuser.com\/q\/1572306\/1015048\n+      | CPU_SSE \/\/ enabled in 'gcc -Q --help=target', used by OpenJDK\n+      | CPU_SSE2 \/\/ enabled in 'gcc -Q --help=target', required by OpenJDK\n+      | CPU_FXSR \/\/ enabled in 'gcc -Q --help=target', not used by OpenJDK\n+      | CPU_MMX \/\/ enabled in 'gcc -Q --help=target', used only by 32-bit x86 OpenJDK\n+      | CPU_TSC \/\/ not used by gcc, used by OpenJDK\n+      | CPU_CX8 \/\/ gcc detects it to set cpu \"pentium\" (=32-bit only), used by OpenJDK\n+      | CPU_CMOV \/\/ gcc detects it to set cpu \"pentiumpro\" (=32-bit only), used by OpenJDK\n+      | CPU_FLUSH \/\/ =\"clflush\" in cpuinfo, not used by gcc, required by OpenJDK\n+      \/\/ GLIBC_MOVBE is disabled in 'gcc -Q --help=target' and for example i7-720QM does not support it\n+      \/\/ GLIBC_LAHFSAHF is disabled in 'gcc -Q --help=target' and \"Early Intel Pentium 4 CPUs with Intel 64 support ... lacked the LAHF and SAHF instructions\"\n+#endif\n+    ;\n+  }\n+  char *endptr;\n+  errno = 0;\n+  uint64_t retval;\n+  unsigned long long ull = strtoull(str, &endptr, 0);\n+  retval = ull;\n+  if (!errno && *endptr == ',' && retval == ull) {\n+    ull = strtoull(endptr + 1, &endptr, 0);\n+    glibc_features = ull;\n+    if (!errno && !*endptr && glibc_features == ull) {\n+      return retval;\n+    }\n+  }\n+  vm_exit_during_initialization(err_msg(\"VM option 'CPUFeatures=%s' must be of the form: 0xnum,0xnum\", str));\n+  return -1;\n+}\n+\n+bool VM_Version::_ignore_glibc_not_using = false;\n+#ifdef LINUX\n+const char VM_Version::glibc_prefix[] = \":glibc.cpu.hwcaps=\";\n+const size_t VM_Version::glibc_prefix_len = strlen(glibc_prefix);\n+\n+bool VM_Version::glibc_env_set(char *disable_str) {\n+#define TUNABLES_NAME \"GLIBC_TUNABLES\"\n+#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n+  char *env_val = disable_str;\n+  const char *env = getenv(TUNABLES_NAME);\n+  if (env && (strcmp(env, env_val) == 0 || (!INCLUDE_CPU_FEATURE_ACTIVE && getenv(REEXEC_NAME)))) {\n+    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Environment variable already set, glibc CPU_FEATURE_ACTIVE is unavailable - re-exec suppressed: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      return true;\n+    }\n+  }\n+  {\n+    ResourceMark rm;\n+    size_t env_buf_size = strlen(disable_str) + (!env ? 0 : strlen(env) + 100);\n+    char *env_buf = NEW_RESOURCE_ARRAY(char, env_buf_size);\n+    if (env) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n+      if (!hwcaps) {\n+        strcpy(env_buf, env);\n+        strcat(env_buf, disable_str);\n+      } else {\n+        const char *colon = strchr(hwcaps, ':');\n+        if (!colon) {\n+          strcpy(env_buf, env);\n+          strcat(env_buf, disable_str + glibc_prefix_len);\n+        } else {\n+          int err = jio_snprintf(env_buf, env_buf_size, \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n+          assert(err >= 0 && (unsigned) err < env_buf_size, \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+        }\n+      }\n+      env_val = env_buf;\n+    }\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+    }\n+    if (setenv(TUNABLES_NAME, env_val, 1)) {\n+      vm_exit_during_initialization(err_msg(\"setenv \" TUNABLES_NAME \" error: %m\"));\n+    }\n+  }\n+\n+  if (getenv(REEXEC_NAME)) {\n+    vm_exit_during_initialization(err_msg(\"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str));\n+  }\n+  if (setenv(REEXEC_NAME, \"1\", 1)) {\n+    vm_exit_during_initialization(err_msg(\"setenv \" REEXEC_NAME \" error: %m\"));\n+  }\n+#undef REEXEC_NAME\n+  return false;\n+}\n+\n+void VM_Version::glibc_reexec() {\n+  char *buf = nullptr;\n+  size_t buf_allocated = 0;\n+  size_t buf_used = 0;\n+#define CMDLINE \"\/proc\/self\/cmdline\"\n+  int fd = open(CMDLINE, O_RDONLY);\n+  if (fd == -1)\n+    vm_exit_during_initialization(err_msg(\"Cannot open \" CMDLINE \": %m\"));\n+  ssize_t got;\n+  do {\n+    if (buf_used == buf_allocated) {\n+      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n+      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n+      if (buf == nullptr)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu bytes\", buf_allocated));\n+    }\n+    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n+    if (got == -1)\n+      vm_exit_during_initialization(err_msg(\"Cannot read \" CMDLINE \": %m\"));\n+    buf_used += got;\n+  } while (got);\n+  if (close(fd))\n+    vm_exit_during_initialization(err_msg(\"Cannot close \" CMDLINE \": %m\"));\n+  char **argv = nullptr;\n+  size_t argv_allocated = 0;\n+  size_t argv_used = 0;\n+  char *s = buf;\n+  while (s <= buf + buf_used) {\n+    if (argv_used == argv_allocated) {\n+      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n+      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n+      if (argv == nullptr)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu pointers\", argv_allocated));\n+    }\n+    if (s == buf + buf_used) {\n+      break;\n+    }\n+    argv[argv_used++] = s;\n+    s += strnlen(s, buf + buf_used - s);\n+    if (s == buf + buf_used)\n+      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n+    ++s;\n+  }\n+  argv[argv_used] = nullptr;\n+#undef CMDLINE\n+\n+#define EXEC \"\/proc\/self\/exe\"\n+  execv(EXEC, argv);\n+  vm_exit_during_initialization(err_msg(\"Cannot re-execute \" EXEC \": %m\"));\n+#undef EXEC\n+}\n+\n+\/\/ Returns whether we should have got set a GLIBC_TUNABLES environment variables but did not get any.\n+bool VM_Version::glibc_not_using() {\n+  if (_ignore_glibc_not_using)\n+    return true;\n+\n+  uint64_t       features_expected =   MAX_CPU - 1;\n+  uint64_t glibc_features_expected = MAX_GLIBC - 1;\n+  if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+          features_expected =       _features;\n+    glibc_features_expected = _glibc_features;\n+  }\n+  uint64_t shouldnotuse_CPU   =       features_expected & ~      _features;\n+  uint64_t shouldnotuse_GLIBC = glibc_features_expected & ~_glibc_features;\n+\n+#ifndef ASSERT\n+  if (!shouldnotuse_CPU && !shouldnotuse_GLIBC)\n+    return true;\n+#endif\n+\n+  \/\/ glibc: sysdeps\/x86\/get-isa-level.h:\n+  \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMOV)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, CX8)\n+  \/\/ glibc:     && CPU_FEATURE_CPU_P (cpu_features, FPU)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FXSR)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MMX)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE2))\n+  \/\/ glibc:     isa_level = GNU_PROPERTY_X86_ISA_1_BASELINE;\n+  if ((_features & CPU_CMOV) &&\n+      (_features & CPU_CX8) &&\n+      \/\/ FPU is always present on i686+: (_features & CPU_FPU) &&\n+      (_features & CPU_SSE2)) {\n+    \/\/ These cannot be disabled by GLIBC_TUNABLES.\n+    if (shouldnotuse_CPU & (CPU_FXSR | CPU_MMX | CPU_SSE)) {\n+      assert(!(shouldnotuse_CPU & CPU_SSE2), \"CPU_SSE2 in both _features and shouldnotuse_CPU cannot happen\");\n+      \/\/ FIXME: The choice should be based on glibc impact, not the feature age.\n+      \/\/ CX8 is i586+, CMOV is i686+ 1995+, SSE2 is 2000+\n+      shouldnotuse_CPU |= CPU_SSE2;\n+    }\n+    if ((_features & CPU_FXSR) &&\n+        (_features & CPU_MMX) &&\n+        (_features & CPU_SSE)) {\n+      \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMPXCHG16B)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LAHF64_SAHF64)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, POPCNT)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_1)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_2))\n+      \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V2;\n+      if ((_features & CPU_POPCNT) &&\n+          (_features & CPU_SSSE3) &&\n+          (_features & CPU_SSE4_1) &&\n+          (_features & CPU_SSE4_2)) {\n+        if ((shouldnotuse_CPU & CPU_SSE3) ||\n+            (shouldnotuse_GLIBC & (GLIBC_CMPXCHG16 | GLIBC_LAHFSAHF))) {\n+          assert(!(shouldnotuse_CPU & CPU_SSE4_2), \"CPU_SSE4_2 in both _features and shouldnotuse_CPU cannot happen\");\n+          \/\/ POPCNT is 2007+, SSSE3 is 2006+, SSE4_1 is 2007+, SSE4_2 is 2008+.\n+          shouldnotuse_CPU |= CPU_SSE4_2;\n+        }\n+        if ((_features & CPU_SSE3) &&\n+            (_glibc_features & GLIBC_CMPXCHG16) &&\n+            (_glibc_features & GLIBC_LAHFSAHF)) {\n+          \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI1)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, F16C)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FMA)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LZCNT)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MOVBE))\n+          \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V3;\n+          if ((_features & CPU_AVX) &&\n+              (_features & CPU_AVX2) &&\n+              (_features & CPU_BMI1) &&\n+              (_features & CPU_BMI2) &&\n+              (_features & CPU_FMA) &&\n+              (_features & CPU_LZCNT) &&\n+              (_glibc_features & GLIBC_MOVBE)) {\n+            if (shouldnotuse_GLIBC & GLIBC_F16C) {\n+              assert(!(shouldnotuse_GLIBC & GLIBC_MOVBE), \"GLIBC_MOVBE in both _glibc_features and shouldnotuse_GLIBC cannot happen\");\n+              \/\/ FMA is 2012+, AVX2+BMI1+BMI2+LZCNT are 2013+, MOVBE is 2015+\n+              shouldnotuse_GLIBC |= GLIBC_MOVBE;\n+            }\n+            if (_glibc_features & GLIBC_F16C) {\n+              \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX512F)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512BW)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512CD)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512DQ)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512VL))\n+              \/\/ glibc:   isa_level |= GNU_PROPERTY_X86_ISA_1_V4;\n+              \/\/ All these flags are supported by disable() below.\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+#define PASTE_TOKENS3(x, y, z) PASTE_TOKENS(x, PASTE_TOKENS(y, z))\n+  enum kind { KIND_CPU = 0, KIND_GLIBC, KIND_COUNT };\n+\n+  static const size_t tunables_size_max = 17;\n+  \/\/ 64 is # of bits in uint64_t VM_Version::_glibc_features.\n+  char disable_str[KIND_COUNT * 64 * (1\/*','*\/ + 1\/*'-'*\/ + tunables_size_max) + 1\/*'\\0'*\/];\n+  strcpy(disable_str, glibc_prefix);\n+  char *disable_end = disable_str + glibc_prefix_len;\n+  auto disable = [&](enum kind kind, uint64_t value, const char *tunables) {\n+    size_t remains = disable_str + sizeof(disable_str) - disable_end;\n+    guarantee(2 + strlen(tunables) < remains, \"internal error: disable_str overflow\");\n+    *disable_end++ = ',';\n+    *disable_end++ = '-';\n+    disable_end = stpcpy(disable_end, tunables);\n+  };\n+\n+#ifdef ASSERT\n+  uint64_t handled[KIND_COUNT] = { 0 };\n+#endif\n+  auto shouldnotuse_handled = [&](enum kind kind, uint64_t value, const char *kindstr, const char *tunables) {\n+    assert(strlen(tunables) <= tunables_size_max, \"Too long string %s\", tunables);\n+    assert((handled[kind] & value) == 0, \"already used %s_%s\", kindstr, tunables);\n+    DEBUG_ONLY(handled[kind] |= value);\n+  };\n+#define EXCESSIVE_HANDLED(kind, tunables) shouldnotuse_handled(PASTE_TOKENS(KIND_, kind), PASTE_TOKENS3(kind, _, tunables), STR(kind), STR(tunables))\n+\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# define FEATURE_ACTIVE(tunables) CPU_FEATURE_ACTIVE(tunables)\n+#else\n+# define FEATURE_ACTIVE(tunables) true\n+#endif\n@@ -863,0 +1173,120 @@\n+  const uint64_t shouldnotuseval[KIND_COUNT] = { shouldnotuse_CPU, shouldnotuse_GLIBC };\n+  auto shouldnotuse = [&](enum kind kind, uint64_t value, const char *kindstr, const char *tunables, bool feature_active) {\n+    shouldnotuse_handled(kind, value, kindstr, tunables);\n+    if ((shouldnotuseval[kind] & value) != 0 && feature_active) {\n+      disable(kind, value, tunables);\n+    }\n+  };\n+#define EXCESSIVE(kind, tunables) \\\n+    shouldnotuse(PASTE_TOKENS(KIND_, kind), PASTE_TOKENS3(kind, _, tunables), STR(kind), STR(tunables), FEATURE_ACTIVE(tunables))\n+\n+  EXCESSIVE(CPU  , AVX     );\n+  EXCESSIVE(CPU  , CX8     );\n+  EXCESSIVE(CPU  , FMA     );\n+  EXCESSIVE(CPU  , RTM     );\n+  EXCESSIVE(CPU  , AVX2    );\n+  EXCESSIVE(CPU  , BMI1    );\n+  EXCESSIVE(CPU  , BMI2    );\n+  EXCESSIVE(CPU  , CMOV    );\n+  EXCESSIVE(CPU  , ERMS    );\n+  EXCESSIVE(CPU  , SSE2    );\n+  EXCESSIVE(CPU  , LZCNT   );\n+  EXCESSIVE(CPU  , SSSE3   );\n+  EXCESSIVE(CPU  , POPCNT  );\n+  EXCESSIVE(CPU  , SSE4_1  );\n+  EXCESSIVE(CPU  , SSE4_2  );\n+  EXCESSIVE(CPU  , AVX512F );\n+  EXCESSIVE(CPU  , AVX512CD);\n+  EXCESSIVE(CPU  , AVX512BW);\n+  EXCESSIVE(CPU  , AVX512DQ);\n+  EXCESSIVE(CPU  , AVX512ER);\n+  EXCESSIVE(CPU  , AVX512PF);\n+  EXCESSIVE(CPU  , AVX512VL);\n+  EXCESSIVE(GLIBC, IBT     );\n+  EXCESSIVE(GLIBC, FMA4    );\n+  EXCESSIVE(GLIBC, MOVBE   );\n+  EXCESSIVE(GLIBC, SHSTK   );\n+  EXCESSIVE(GLIBC, XSAVE   );\n+  EXCESSIVE(GLIBC, OSXSAVE );\n+  EXCESSIVE(GLIBC, HTT     );\n+#undef EXCESSIVE\n+#undef EXCESSIVE3\n+\n+#ifdef ASSERT\n+  \/\/ These cannot be disabled by GLIBC_TUNABLES interface.\n+#define GLIBC_UNSUPPORTED(kind, hotspot) EXCESSIVE_HANDLED(kind, hotspot)\n+  GLIBC_UNSUPPORTED(CPU  , 3DNOW_PREFETCH   );\n+  GLIBC_UNSUPPORTED(CPU  , SSE4A            );\n+  GLIBC_UNSUPPORTED(CPU  , TSC              );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV_BIT       );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV           );\n+  GLIBC_UNSUPPORTED(CPU  , AES              );\n+  GLIBC_UNSUPPORTED(CPU  , CLMUL            );\n+  GLIBC_UNSUPPORTED(CPU  , ADX              );\n+  GLIBC_UNSUPPORTED(CPU  , SHA              );\n+  GLIBC_UNSUPPORTED(CPU  , VZEROUPPER       );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPOPCNTDQ );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPCLMULQDQ);\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VAES      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VNNI      );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSH            );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSHOPT         );\n+  GLIBC_UNSUPPORTED(CPU  , CLWB             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI2     );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI      );\n+  GLIBC_UNSUPPORTED(CPU  , HV               );\n+  GLIBC_UNSUPPORTED(CPU  , SSE3             );\n+  GLIBC_UNSUPPORTED(CPU  , SERIALIZE        );\n+  GLIBC_UNSUPPORTED(CPU  , RDTSCP           );\n+  GLIBC_UNSUPPORTED(CPU  , RDPID            );\n+  GLIBC_UNSUPPORTED(CPU  , FSRM             );\n+  GLIBC_UNSUPPORTED(CPU  , GFNI             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_BITALG    );\n+  GLIBC_UNSUPPORTED(CPU  , F16C             );\n+  GLIBC_UNSUPPORTED(CPU  , PKU              );\n+  GLIBC_UNSUPPORTED(CPU  , OSPKE            );\n+  GLIBC_UNSUPPORTED(CPU  , CET_IBT          );\n+  GLIBC_UNSUPPORTED(CPU  , CET_SS           );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_IFMA      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX_IFMA         );\n+  GLIBC_UNSUPPORTED(CPU  , APX_F            );\n+  GLIBC_UNSUPPORTED(CPU  , SHA512           );\n+  \/\/ These are handled as an exception above.\n+  GLIBC_UNSUPPORTED(CPU  , FXSR             );\n+  GLIBC_UNSUPPORTED(CPU  , MMX              );\n+  GLIBC_UNSUPPORTED(CPU  , SSE              );\n+  GLIBC_UNSUPPORTED(CPU  , HT               );\n+  GLIBC_UNSUPPORTED(GLIBC, CMPXCHG16        );\n+  GLIBC_UNSUPPORTED(GLIBC, LAHFSAHF         );\n+  GLIBC_UNSUPPORTED(GLIBC, F16C             );\n+#undef GLIBC_UNSUPPORTED\n+\n+  auto check_kind = [&](enum kind kind, const char *kindstr, uint64_t mask) {\n+    if (handled[kind] != mask) {\n+      vm_exit_during_initialization(err_msg(\"internal error: Unsupported disabling of some %s_* 0x%\" PRIx64 \" != full 0x%\" PRIx64, kindstr, handled[kind], mask));\n+    }\n+  };\n+#define CHECK_KIND(kind) check_kind(PASTE_TOKENS(KIND_, kind), STR(kind), PASTE_TOKENS(MAX_, kind) - 1)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+#endif \/\/ ASSERT\n+\n+  *disable_end = 0;\n+  if (disable_end == disable_str + glibc_prefix_len)\n+    return true;\n+  if (glibc_env_set(disable_str))\n+    return true;\n+  return false;\n+}\n+#endif \/\/LINUX\n+\n+void VM_Version::print_using_features_cr() {\n+  if (_ignore_glibc_not_using) {\n+    tty->print_cr(\"CPU features are being kept intact as requested by -XX:CPUFeatures=ignore\");\n+  } else {\n+    tty->print_cr(\"CPU features being used are: -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, _features, _glibc_features);\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hardware() {\n@@ -867,0 +1297,1 @@\n+  _glibc_features = 0;\n@@ -883,0 +1314,1 @@\n+    LINUX_ONLY(_glibc_features = _cpuid_info.glibc_flags();)\n@@ -895,0 +1327,6 @@\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"This machine's CPU features are: -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, _features, _glibc_features);\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hotspot() {\n@@ -898,0 +1336,2 @@\n+    if (!FLAG_IS_DEFAULT(CPUFeatures))\n+      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, CPU_SSE2, (uint64_t)0));\n@@ -1099,1 +1539,1 @@\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  insert_features_names(buf + res, sizeof(buf) - res);\n@@ -2152,0 +2592,73 @@\n+\/\/ Print the feature names as \" = feat1, ..., featN\\n\";\n+void VM_Version::missing_features(uint64_t features_missing, uint64_t glibc_features_missing) {\n+  tty->print(\"; missing features of this CPU are \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X \" =\", features_missing, glibc_features_missing);\n+  char buf[512] = \"\";\n+  \/\/ insert_features_names() does crash for undefined too high-numbered features.\n+  insert_features_names(buf, sizeof(buf)          ,       features_missing & (  MAX_CPU - 1));\n+  char *s = buf + strlen(buf);\n+  insert_features_names(s  , buf + sizeof(buf) - s, glibc_features_missing & (MAX_GLIBC - 1));\n+  tty->print_cr(\n+    \"%s\\n\"\n+    \"If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures .\",\n+    \/* + 1 to skip the first ','. *\/\n+    buf + 1);\n+}\n+\n+static_assert(sizeof(VM_Version::CPUFeaturesBinary) == 2 * 8, \"unexpected sizeof\");\n+bool VM_Version::cpu_features_binary(VM_Version::CPUFeaturesBinary *data) {\n+  data->cpu = _features;\n+  data->glibc = _glibc_features;\n+  return true;\n+}\n+\n+bool VM_Version::cpu_features_binary_check(const CPUFeaturesBinary *data) {\n+  assert(CPUFeatures == nullptr, \"This should only be called on restore and CPUFeatures is not restore-settable\");\n+\n+  if (!data) {\n+    return false;\n+  }\n+\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"This snapshot's stored CPU features are: -XX:CPUFeatures=0x%\" PRIx64 \",0x%\" PRIx64, data->cpu, data->glibc);\n+  }\n+\n+  uint64_t   CPUFeatures_x64 = data->cpu;\n+  uint64_t GLIBCFeatures_x64 = data->glibc;\n+\n+  uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+  uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  if (features_missing || glibc_features_missing) {\n+    tty->print(\n+      \"You have to specify -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X\n+      \" together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X,\n+      CPUFeatures_x64 & _features, GLIBCFeatures_x64 & _glibc_features,\n+      CPUFeatures_x64, GLIBCFeatures_x64);\n+    missing_features(features_missing, glibc_features_missing);\n+    if (!IgnoreCPUFeatures) {\n+      return false;\n+    }\n+  }\n+\n+        _features_saved =       _features;\n+  _glibc_features_saved = _glibc_features;\n+\n+        _features =   CPUFeatures_x64;\n+  _glibc_features = GLIBCFeatures_x64;\n+\n+  if (ShowCPUFeatures && !CRaCRestoreFrom) {\n+    print_using_features_cr();\n+  }\n+\n+#ifdef LINUX\n+  \/\/ glibc_not_using() has done setenv(TUNABLES_NAME) and it expects us to re-exec ourselves.\n+  \/\/ But we were only checking the cpufeatures file before restoring the process so we ignore the result.\n+  glibc_not_using();\n+#endif\n+\n+  return true;\n+}\n+\n@@ -2204,1 +2717,41 @@\n-  get_processor_features();\n+  assert(      _features == 0,       \"_features should be zero at startup\");\n+  assert(_glibc_features == 0, \"_glibc_features should be zero at startup\");\n+  get_processor_features_hardware();\n+\n+  assert(!CPUFeatures == FLAG_IS_DEFAULT(CPUFeatures), \"CPUFeatures parsing\");\n+\n+  uint64_t GLIBCFeatures_x64;\n+  uint64_t   CPUFeatures_x64 = CPUFeatures_parse(CPUFeatures, GLIBCFeatures_x64);\n+\n+  uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+  uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  if (features_missing || glibc_features_missing) {\n+    tty->print(\n+      \"Specified -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X\n+      \"; this machine's CPU features are \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X,\n+      CPUFeatures_x64, GLIBCFeatures_x64,\n+      _features, _glibc_features);\n+    missing_features(features_missing, glibc_features_missing);\n+    vm_exit_during_initialization();\n+  }\n+\n+        _features_saved =       _features;\n+  _glibc_features_saved = _glibc_features;\n+\n+        _features =   CPUFeatures_x64;\n+  _glibc_features = GLIBCFeatures_x64;\n+\n+  if (ShowCPUFeatures && !CRaCRestoreFrom) {\n+    print_using_features_cr();\n+  }\n+\n+#ifdef LINUX\n+  if (!glibc_not_using())\n+    glibc_reexec();\n+#endif\n+\n+  get_processor_features_hotspot();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":559,"deletions":6,"binary":false,"changes":565,"status":"modified"},{"patch":"@@ -923,0 +923,3 @@\n+void os::reset_cached_process_id() {\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -866,0 +866,3 @@\n+void os::reset_cached_process_id() {\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -748,0 +748,12 @@\n+GrowableArray<int> ClassLoader::get_classpath_entry_fds() {\n+  GrowableArray<int> fds;\n+  assert(Thread::current()->is_VM_thread(), \"should be called from VM op\");\n+  \/\/ we don't use mutexes here because it is called from VM op\n+  for (ClassPathEntry *entry = first_append_entry(); entry != nullptr; entry = entry->next()) {\n+    if (entry->is_jar_file()) {\n+      fds.append(((ClassPathZipEntry *) entry)->get_fd());\n+    }\n+  }\n+  return fds;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  int get_fd() const { return ZipLibrary::get_fd(_zip); }\n@@ -373,0 +374,3 @@\n+  \/\/ returns list of file descriptors used for both boot and app classpath entries\n+  static GrowableArray<int> get_classpath_entry_fds();\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -990,0 +991,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1140,0 +1148,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -406,0 +407,6 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), (char*)eden()->end() - (char*)eden()->top());\n+    os::cleanup_memory((char*)from()->top(), (char*)from()->end() - (char*)from()->top());\n+    os::cleanup_memory((char*)to()->top(), (char*)to()->end() - (char*)to()->top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1056,0 +1056,4 @@\n+\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    _page_allocator->uncommit_unused_memory();\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1168,0 +1168,15 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+  _block_async(),\n@@ -295,0 +296,3 @@\n+    _block_async.lock();\n+    _block_async.unlock();\n+\n@@ -358,0 +362,9 @@\n+void AsyncLogWriter::stop() {\n+  _block_async.lock();\n+  flush();\n+}\n+\n+void AsyncLogWriter::resume() {\n+  _block_async.unlock();\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -170,0 +170,2 @@\n+  \/\/ for asynchronous thread run()\n+  PlatformMonitor _block_async;\n@@ -221,0 +223,2 @@\n+  void stop();\n+  void resume();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,0 +122,4 @@\n+\n+  \/\/ Default log level for 'crac' is Info\n+  precond(!log_is_enabled(Info, crac)); \/\/ If this fails, the below can be removed\n+  LogTagSetMapping<LOG_TAGS(crac)>::tagset().set_output_level(StdoutLog, LogLevel::Info);\n@@ -723,0 +727,22 @@\n+bool LogConfiguration::is_fd_used(int fd) {\n+  assert(fd != -1, \"fd must be valid\");\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    if (fd == _outputs[i]->fd_get()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void LogConfiguration::close() {\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    _outputs[i]->close();\n+  }\n+}\n+\n+void LogConfiguration::reopen() {\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    _outputs[i]->reopen();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -146,0 +146,5 @@\n+\n+  \/\/ Is this file descriptor in use?\n+  static bool is_fd_used(int fd);\n+  static void close();\n+  static void reopen();\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -463,0 +463,37 @@\n+\n+int LogFileOutput::fd_get() const {\n+  if (_stream == nullptr) {\n+    return -1;\n+  }\n+  return LogFileStreamOutput::fd_get();\n+}\n+\n+void LogFileOutput::close() {\n+  if (_stream == nullptr) {\n+    return;\n+  }\n+  if (fclose(_stream)) {\n+    jio_fprintf(defaultStream::error_stream(), \"Error closing log file '%s' (%s).\\n\",\n+                _file_name, os::strerror(errno));\n+  }\n+  _stream = nullptr;\n+}\n+\n+void LogFileOutput::reopen() {\n+  assert(_stream == nullptr, \"reopening an already opened log file\");\n+\n+  \/\/ Open the active log file using the same stream as before\n+  jlong the_time = os::javaTimeMillis();\n+  LogFileOutput::set_file_name_parameters(the_time);\n+  FREE_C_HEAP_ARRAY(char, _file_name);\n+  _file_name = make_file_name(_name + strlen(Prefix), _pid_str, _vm_start_time_str);\n+  _stream = os::fopen(_file_name, FileOpenMode);\n+  if (_stream == nullptr) {\n+    jio_fprintf(defaultStream::error_stream(), \"Could not reopen log file '%s' (%s).\\n\",\n+                _file_name, os::strerror(errno));\n+    return;\n+  }\n+\n+  \/\/ _current_size still keeps how much data we wrote for the rotation purposes.\n+  \/\/ The log file may contain more data now.\n+}\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  LOG_TAG(crac) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3673,0 +3674,5 @@\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -313,2 +313,1 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n-  uint64_t features = _features;\n+void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features) {\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  static void insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features = _features);\n@@ -131,1 +132,0 @@\n-  static void insert_features_names(char* buf, size_t buflen, const char* features_names[]);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2024, Azul Systems, Inc. All rights reserved.\n@@ -52,0 +53,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -77,0 +79,1 @@\n+#include <type_traits>\n@@ -89,0 +92,1 @@\n+char*  Arguments::_java_command_crac            = nullptr;\n@@ -553,0 +557,10 @@\n+  { \"CREngine\",                     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowedOpenFilePrefixes\",    JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowToSkipCheckpoint\",      JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRHeapDumpOnCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPrintResourcesOnCheckpoint\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTraceStartupTime\",           JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRDoThrowCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPauseOnCheckpointError\",     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTrace\",                      JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::undefined() },\n+\n@@ -564,0 +578,8 @@\n+  { \"CREngine\",                        \"CRaCEngine\" },\n+  { \"CRAllowedOpenFilePrefixes\",       \"CRaCAllowedOpenFilePrefixes\" },\n+  { \"CRAllowToSkipCheckpoint\",         \"CRaCAllowToSkipCheckpoint \"},\n+  { \"CRHeapDumpOnCheckpointException\", \"CRaCHeapDumpOnCheckpointException\" },\n+  { \"CRPrintResourcesOnCheckpoint\",    \"CRaCPrintResourcesOnCheckpoint\" },\n+  { \"CRTraceStartupTime\",              \"CRaCTraceStartupTime\" },\n+  { \"CRDoThrowCheckpointException\",    \"CRaCDoThrowCheckpointException\" },\n+  { \"CRPauseOnCheckpointError\",        \"CRaCPauseOnCheckpointError\" },\n@@ -1091,0 +1113,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == NULL) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1100,4 +1135,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1105,6 +1137,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == nullptr) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1241,1 +1269,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1243,2 +1273,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1248,1 +1276,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1256,1 +1285,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1258,1 +1287,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1260,0 +1289,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2148,0 +2184,83 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (!match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      continue;\n+    }\n+    \/\/ ccstr is never set to an empty string by the parser so we should not\n+    \/\/ treat an empty string value as the option being set. If it ever becomes\n+    \/\/ ccstrlist or the parser changes, the value check will need to be removed.\n+    static_assert(std::is_same<ccstr, decltype(CRaCRestoreFrom)>(), \"expected ccstr\");\n+    const char* eq = strchr(tail, '=');\n+    if (eq != nullptr && eq[1] != '\\0') {\n+      return true; \/\/ the value is not an empty string\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = NULL;\n+      const char* value = NULL;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.crac_command\") == 0) {\n+        char *old_java_command = _java_command_crac;\n+        _java_command_crac = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != NULL) {\n+          os::free(old_java_command);\n+        }\n+      } else {\n+        add_property(tail);\n+      }\n+\n+      if (key != tail) { \/\/ key was copied\n+        FreeHeap(const_cast<char *>(key));\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != NULL) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n+          return false;\n+        }\n+        build_jvm_flags(tail);\n+      }\n+    }\n+  }\n+\n+  postcond(CRaCRestoreFrom != nullptr);\n+\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -2160,0 +2279,1 @@\n+        !match_option(option, \"-Dsun.java.crac_command\", &tail) &&\n@@ -2968,0 +3088,8 @@\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return JNI_ERR;\n+  }\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n@@ -3979,0 +4107,7 @@\n+\n+void Arguments::reset_for_crac_restore() {\n+  if (!FLAG_IS_DEFAULT(LogVMOutput)){\n+    FLAG_SET_DEFAULT(LogVMOutput, false);\n+    FLAG_SET_DEFAULT(LogFile, nullptr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":151,"deletions":16,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n-\/\/ only with product\/product_pd flags.\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, MANAGEABLE or RESTORE_SETTABLE. Currently\n+\/\/ extra_attrs can be used only with product\/product_pd flags.\n@@ -100,0 +100,3 @@\n+\/\/ RESTORE_SETTABLE are flags that can be set during restore from a snapshot.\n+\/\/    All MANAGEABLE flags are implicitly RESTORE_SETTABLE but\n+\/\/    RESTORE_SETTABLE are not MANAGEABLE.\n@@ -177,1 +180,2 @@\n-  product(bool, UnlockDiagnosticVMOptions, trueInDebug, DIAGNOSTIC,         \\\n+  product(bool, UnlockDiagnosticVMOptions, trueInDebug,                     \\\n+          DIAGNOSTIC | RESTORE_SETTABLE,                                    \\\n@@ -180,1 +184,2 @@\n-  product(bool, UnlockExperimentalVMOptions, false, EXPERIMENTAL,           \\\n+  product(bool, UnlockExperimentalVMOptions, false,                         \\\n+          EXPERIMENTAL | RESTORE_SETTABLE,                                  \\\n@@ -1018,1 +1023,1 @@\n-  product(bool, LogVMOutput, false, DIAGNOSTIC,                             \\\n+  product(bool, LogVMOutput, false, DIAGNOSTIC | RESTORE_SETTABLE,          \\\n@@ -1021,1 +1026,1 @@\n-  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                              \\\n+  product(ccstr, LogFile, nullptr, DIAGNOSTIC | RESTORE_SETTABLE,           \\\n@@ -1940,1 +1945,1 @@\n-  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                    \\\n+  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr, RESTORE_SETTABLE,  \\\n@@ -1954,0 +1959,65 @@\n+  product(ccstr, CRaCCheckpointTo, NULL, RESTORE_SETTABLE,                  \\\n+        \"Path to checkpoint image directory\")                               \\\n+                                                                            \\\n+  product(ccstr, CRaCRestoreFrom, NULL, RESTORE_SETTABLE,                   \\\n+      \"Path to image for restore, replaces the initializing VM on success\") \\\n+                                                                            \\\n+  product(uint, CRaCMinPid, 128,                                            \\\n+      \"Mininal PID value for checkpoint'ed process\")                        \\\n+      range(1, UINT_MAX)                                                    \\\n+                                                                            \\\n+  product(bool, CRaCResetStartTime, true, DIAGNOSTIC | RESTORE_SETTABLE,    \\\n+      \"Reset JVM's start time and uptime on restore\")                       \\\n+                                                                            \\\n+  product_pd(ccstr, CRaCEngine, RESTORE_SETTABLE,                           \\\n+      \"Path or name of a program or a shared library implementing \"         \\\n+      \"checkpoint and restore. On restore this option applies only to \"     \\\n+      \"the restoring VM, i.e. the restored VM keeps the value it had \"      \\\n+      \"before the checkpoint.\")                                             \\\n+                                                                            \\\n+  product(ccstrlist, CRaCEngineOptions, nullptr, RESTORE_SETTABLE,          \\\n+      \"Options passed to CRaCEngine, in the form of 'key1=value,key2'. \"    \\\n+      \"The list of supported options is engine-dependent, use \"             \\\n+      \"'-XX:CRaCEngineOptions=help' to make the VM print the information \"  \\\n+      \"about the engine, including its supported options, and exit. On \"    \\\n+      \"restore this option applies only to the restoring VM, i.e. the \"     \\\n+      \"restored VM keeps the value it had before the checkpoint.\")          \\\n+                                                                            \\\n+  product(bool, CRaCIgnoreRestoreIfUnavailable, false, RESTORE_SETTABLE,    \\\n+      \"Ignore -XX:CRaCRestoreFrom and continue initialization if restore \"  \\\n+      \"is unavailable\")                                                     \\\n+                                                                            \\\n+  product(ccstr, CRaCIgnoredFileDescriptors, NULL, RESTORE_SETTABLE,        \\\n+      \"Comma-separated list of file descriptor numbers or paths. \"          \\\n+      \"All file descriptors greater than 2 (stdin, stdout and stderr are \"  \\\n+      \"excluded automatically) not in this list are closed when the VM \"    \\\n+      \"is started.\")                                                        \\\n+                                                                            \\\n+  product_pd(ccstrlist, CRaCAllowedOpenFilePrefixes, \"List of path \"        \\\n+      \"prefixes for files that can be open during checkpoint; CRaC won't \"  \\\n+      \"error upon detecting these and will leave the handling up to C\/R \"   \\\n+      \"engine. This option applies only to files opened by native code; \"   \\\n+      \"for files opened by Java code use -Djdk.crac.resource-policies=...\") \\\n+                                                                            \\\n+  product(bool, CRaCAllowToSkipCheckpoint, false, DIAGNOSTIC,               \\\n+      \"Allow implementation to not call Checkpoint if helper not found\")    \\\n+                                                                            \\\n+  product(bool, CRaCHeapDumpOnCheckpointException, false, DIAGNOSTIC,       \\\n+      \"Dump heap on CheckpointException thrown because of CRaC \"            \\\n+      \"precondition failed\")                                                \\\n+                                                                            \\\n+  product(bool, CRaCPrintResourcesOnCheckpoint, false, DIAGNOSTIC,          \\\n+      \"Print resources to decide CheckpointException\")                      \\\n+                                                                            \\\n+  product(bool, CRaCTraceStartupTime, false, DIAGNOSTIC,                    \\\n+      \"Trace startup time\")                                                 \\\n+                                                                            \\\n+  product(bool, CRaCDoThrowCheckpointException, true, EXPERIMENTAL,         \\\n+      \"Throw CheckpointException if uncheckpointable resource handle found\")\\\n+                                                                            \\\n+  product(bool, CRaCPauseOnCheckpointError, false, DIAGNOSTIC,              \\\n+      \"Pauses the checkpoint when a problem is found on VM level.\")         \\\n+                                                                            \\\n+  product(size_t, CRaCMaxHeapSizeBeforeCheckpoint, 0, \"Maximum size \"       \\\n+      \"of heap before checkpoint. By default equals to -Xmx.\")              \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":77,"deletions":7,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1242,0 +1242,1 @@\n+  void wakeup_sleep() { _SleepEvent->unpark(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -428,0 +429,9 @@\n+static jint check_for_restore(JavaVMInitArgs* args) {\n+  if (Arguments::is_restore_option_set(args)) {\n+    if (!Arguments::parse_options_for_restore(args)) {\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -431,0 +441,8 @@\n+#ifdef __APPLE__\n+  \/\/ BSD clock would be initialized in os::init() but we need to do that earlier\n+  \/\/ as crac::prepare_restore() calls os::javaTimeNanos().\n+  os::Bsd::clock_init();\n+#endif\n+  crac::crac_restore_data restore_data;\n+  crac::prepare_restore(restore_data);\n+\n@@ -461,0 +479,2 @@\n+  if (check_for_restore(args) != JNI_OK) return JNI_ERR;\n+\n@@ -495,0 +515,2 @@\n+  crac::vm_create_start();\n+\n@@ -583,0 +605,11 @@\n+  \/\/ Output stream module should be already initialized for error reporting during restore.\n+  \/\/ JDK version should also be intialized. There is lot of initializations needed to read\n+  \/\/ the current machine's CPUFeatures.\n+  if (CRaCRestoreFrom) {\n+    crac::restore(restore_data);\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      log_error(crac)(\"Failed to restore %s\", CRaCRestoreFrom);\n+      return JNI_ERR;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1788,0 +1788,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+#if INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n@@ -154,0 +158,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -1051,0 +1057,26 @@\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_crac_mirror_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::checkpointRestoreInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != NULL) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      outputStream* stream = output();\n+#if INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+      assert(PosixAttachListener::get_current_op(), \"should exist\");\n+      if (PosixAttachListener::get_current_op()->is_effectively_completed()) {\n+        stream = tty;\n+      }\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS) && !defined(AIX)\n+      stream->print_cr(\"An exception during a checkpoint operation:\");\n+      stream->print(\"%s\", out);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -854,0 +854,14 @@\n+class CheckpointDCmd : public DCmd {\n+public:\n+  CheckpointDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"JDK.checkpoint\"; }\n+    static const char* description() {\n+      return \"Checkpoint via jdk.crac.checkpointRestore().\";\n+    }\n+    static const char* impact() {\n+      return \"High: JVM terminates\";\n+    }\n+    static int num_arguments() { return 0; }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n+import java.util.*;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n@@ -32,0 +32,2 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.impl.CheckpointOpenResourceException;\n@@ -34,0 +36,1 @@\n+import jdk.internal.crac.*;\n@@ -59,0 +62,66 @@\n+    class Resource extends JDKFdResource {\n+        private boolean closedByNIO;\n+\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.internal.crac.mirror.Resource> context) throws Exception {\n+            if (!closedByNIO && valid()) {\n+                ClaimedFDs claimedFDs = Core.getClaimedFDs();\n+                FileDescriptor self = FileDescriptor.this;\n+                String nativeDescription = nativeDescription0();\n+\n+                OpenResourcePolicies.Policy policy = findPolicy(nativeDescription);\n+                String action = \"error\";\n+                Supplier<Exception> supplier = null;\n+                \/\/ Normally the claiming should be overridden by FileInputStream\/FileOutputStream\n+                \/\/ but in case these are collected we handle FDs 0..2 here as well.\n+                if (policy != null) {\n+                    action = policy.action;\n+                } else if (self == in || self == out || self == err) {\n+                    action = \"ignore\";\n+                }\n+                supplier = switch (action.toLowerCase()) {\n+                    case \"error\":\n+                        yield () -> new CheckpointOpenResourceException(\n+                            FileDescriptor.class.getSimpleName() + \" \" + fd + \": \" + nativeDescription,\n+                            getStackTraceHolder());\n+                    case \"close\":\n+                        close();\n+                    case \"ignore\":\n+                        warnOpenResource(policy, \"File descriptor \" + fd);\n+                        yield NO_EXCEPTION;\n+                    default: throw new IllegalArgumentException(\"Unknown policy action for file descriptor \" + fd + \": \" + action);\n+                };\n+                claimedFDs.claimFd(self, self, supplier);\n+            }\n+        }\n+\n+        private OpenResourcePolicies.Policy findPolicy(String nativeDescription) {\n+            return OpenResourcePolicies.find(false, \"filedescriptor\", params -> {\n+                String value = params.get(\"value\");\n+                if (value != null) {\n+                    try {\n+                        int expected = Integer.parseInt(value);\n+                        if (expected != fd) {\n+                            return false;\n+                        }\n+                    } catch (NumberFormatException e) {\n+                        throw new IllegalArgumentException(\"Cannot parse file descriptor value '\" + value + \"'\");\n+                    }\n+                }\n+                String regex = params.get(\"regex\");\n+                if (regex != null) {\n+                    return Pattern.compile(regex).matcher(nativeDescription).find();\n+                }\n+                return true;\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getName() + \"(FD \" + fd + \")\";\n+        }\n+    }\n+\n+    Resource resource = new Resource();\n+\n@@ -92,0 +161,5 @@\n+                    @Override\n+                    public void markClosed(FileDescriptor fdo) {\n+                        fdo.resource.closedByNIO = true;\n+                    }\n+\n@@ -307,0 +381,2 @@\n+    private native String nativeDescription0();\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":79,"deletions":3,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.InvocationHandler;\n@@ -32,0 +33,1 @@\n+import java.lang.reflect.Proxy;\n@@ -74,2 +76,2 @@\n-    private final ByteBuffer memoryMap;\n-    private final FileChannel channel;\n+    private ByteBuffer memoryMap;\n+    private FileChannel channel;\n@@ -78,4 +80,4 @@\n-    private final IntBuffer redirect;\n-    private final IntBuffer offsets;\n-    private final ByteBuffer locations;\n-    private final ByteBuffer strings;\n+    private IntBuffer redirect;\n+    private IntBuffer offsets;\n+    private ByteBuffer locations;\n+    private ByteBuffer strings;\n@@ -84,0 +86,1 @@\n+    private Object cracResource;\n@@ -85,1 +88,1 @@\n-    @SuppressWarnings({ \"removal\", \"this-escape\", \"suppression\" })\n+    @SuppressWarnings({ \"this-escape\", \"suppression\" })\n@@ -106,24 +109,2 @@\n-            channel = FileChannel.open(imagePath, StandardOpenOption.READ);\n-            \/\/ No lambdas during bootstrap\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run() {\n-                    if (BasicImageReader.class.getClassLoader() == null) {\n-                        try {\n-                            Class<?> fileChannelImpl =\n-                                Class.forName(\"sun.nio.ch.FileChannelImpl\");\n-                            Method setUninterruptible =\n-                                    fileChannelImpl.getMethod(\"setUninterruptible\");\n-                            setUninterruptible.invoke(channel);\n-                        } catch (ClassNotFoundException |\n-                                 NoSuchMethodException |\n-                                 IllegalAccessException |\n-                                 InvocationTargetException ex) {\n-                            \/\/ fall thru - will only happen on JDK-8 systems where this code\n-                            \/\/ is only used by tools using jrt-fs (non-critical.)\n-                        }\n-                    }\n-\n-                    return null;\n-                }\n-            });\n+            channel = openFileChannel();\n+            registerIfCracPresent();\n@@ -134,1 +115,1 @@\n-            map = channel.map(FileChannel.MapMode.READ_ONLY, 0, channel.size());\n+            map = createMemoryMap(channel.size());\n@@ -160,1 +141,1 @@\n-            map = channel.map(FileChannel.MapMode.READ_ONLY, 0, indexSize);\n+            map = createMemoryMap(indexSize);\n@@ -169,0 +150,8 @@\n+\n+        initMappedBuffers();\n+\n+        stringsReader = new ImageStringsReader(this);\n+        decompressor = new Decompressor();\n+    }\n+\n+    protected void initMappedBuffers() {\n@@ -173,0 +162,1 @@\n+    }\n@@ -174,2 +164,129 @@\n-        stringsReader = new ImageStringsReader(this);\n-        decompressor = new Decompressor();\n+    protected ByteBuffer createMemoryMap(long size) throws IOException {\n+        return channel.map(FileChannel.MapMode.READ_ONLY, 0, size);\n+    }\n+\n+    \/\/ Since this class must be compatible with JDK 8 and any non-CRaC JDK due to being part of jrtfs.jar\n+    \/\/ we must register this to CRaC via reflection.\n+    private void registerIfCracPresent() {\n+        Class<?> priorityClass = null;\n+        try {\n+            priorityClass = Class.forName(\"jdk.internal.crac.Core$Priority\");\n+        } catch (ClassNotFoundException e) {\n+            \/\/ there is no CRaC; suppress an exception\n+            return;\n+        }\n+        try {\n+            Object[] priorities = priorityClass.getEnumConstants();\n+            if (priorities == null) {\n+                return;\n+            }\n+            Object normalPriority = null;\n+            for (int i = 0; i < priorities.length; ++i) {\n+                if (\"NORMAL\".equals(priorities[i].toString())) {\n+                    normalPriority = priorities[i];\n+                }\n+            }\n+            if (normalPriority == null) {\n+                throw new IllegalStateException();\n+            }\n+            Class<?> resourceClass = Class.forName(\"jdk.internal.crac.mirror.Resource\");\n+            Method getContextMethod = priorityClass.getMethod(\"getContext\");\n+            Object ctx = getContextMethod.invoke(normalPriority);\n+            Class<?> ctxClass = ctx.getClass();\n+\n+            registerCracResource(resourceClass, ctxClass, ctx);\n+        } catch (IllegalAccessException e) {\n+            \/\/ try to register via public API\n+            registerIfPublicCracPresent();\n+        } catch (NoSuchMethodException | InvocationTargetException | ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private void registerIfPublicCracPresent() {\n+        Class<?> cracCoreClass = null;\n+        try {\n+            cracCoreClass = Class.forName(\"jdk.crac.Core\");\n+        } catch (ClassNotFoundException e) {\n+            \/\/ there is no public CRaC; suppress an exception\n+            return;\n+        }\n+        try {\n+            Class<?> resourceClass = Class.forName(\"jdk.crac.Resource\");\n+            Method getGlobalContextMethod = cracCoreClass.getMethod(\"getGlobalContext\");\n+            Object ctx = getGlobalContextMethod.invoke(null);\n+            Class<?> ctxClass = Class.forName(\"jdk.crac.Context\");\n+\n+            registerCracResource(resourceClass, ctxClass, ctx);\n+        } catch (IllegalAccessException e) {\n+            e.printStackTrace();\n+        } catch (NoSuchMethodException | InvocationTargetException | ClassNotFoundException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private void registerCracResource(Class<?> resourceClass, Class<?> ctxClass, Object ctx)\n+            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n+        Method registerMethod = ctxClass.getMethod(\"register\", resourceClass);\n+        cracResource = Proxy.newProxyInstance(\n+            resourceClass.getClassLoader(),\n+            new Class<?>[] { resourceClass },\n+            new InvocationHandler() {\n+                @Override\n+                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+                    if (\"beforeCheckpoint\".equals(method.getName())) {\n+                        channel.close();\n+                        redirect = null;\n+                        offsets = null;\n+                        locations = null;\n+                        strings = null;\n+                        memoryMap = null;\n+                    } else if (\"afterRestore\".equals(method.getName())) {\n+                        if (channel != null) {\n+                            channel = openFileChannel();\n+                            memoryMap = createMemoryMap(MAP_ALL ? channel.size() : indexSize).asReadOnlyBuffer();\n+                            initMappedBuffers();\n+                        }\n+                    } else if (\"toString\".equals(method.getName())) {\n+                        return BasicImageReader.this.toString();\n+                    } else if (\"hashCode\".equals(method.getName())) {\n+                        return 0;\n+                    } else if (\"equals\".equals(method.getName())) {\n+                        return args[0] == cracResource;\n+                    } else {\n+                        throw new UnsupportedOperationException(method.toString());\n+                    }\n+                    return null;\n+                }\n+            }\n+        );\n+        registerMethod.invoke(ctx, cracResource);\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private FileChannel openFileChannel() throws IOException {\n+        FileChannel channel = FileChannel.open(imagePath, StandardOpenOption.READ);\n+        \/\/ No lambdas during bootstrap\n+        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n+            @Override\n+            public Void run() {\n+                if (BasicImageReader.class.getClassLoader() == null) {\n+                    try {\n+                        Class<?> fileChannelImpl =\n+                            Class.forName(\"sun.nio.ch.FileChannelImpl\");\n+                        Method setUninterruptible =\n+                                fileChannelImpl.getMethod(\"setUninterruptible\");\n+                        setUninterruptible.invoke(channel);\n+                    } catch (ClassNotFoundException |\n+                             NoSuchMethodException |\n+                             IllegalAccessException |\n+                             InvocationTargetException ex) {\n+                        \/\/ fall thru - will only happen on JDK-8 systems where this code\n+                        \/\/ is only used by tools using jrt-fs (non-critical.)\n+                    }\n+                }\n+\n+                return null;\n+            }\n+        });\n+        return channel;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/BasicImageReader.java","additions":152,"deletions":35,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-\n@@ -179,0 +178,5 @@\n+    exports jdk.internal.crac to\n+        java.rmi,\n+        jdk.jfr,\n+        jdk.management.agent,\n+        jdk.sctp;\n@@ -409,0 +413,8 @@\n+    exports jdk.internal.crac.mirror to\n+        java.rmi,\n+        jdk.crac,\n+        jdk.jfr,\n+        jdk.management.agent;\n+\n+    exports jdk.internal.crac.mirror.impl to\n+        jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -104,0 +105,1 @@\n+    private final JDKSocketResource resource = new Resource();\n@@ -1949,0 +1951,31 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(DatagramChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -128,0 +129,8 @@\n+    \/\/ last backlog used for listen() invocation\n+    private int backlog;\n+\n+    static {\n+        \/\/ trigger eager initialization\n+        new FileDispatcherImpl();\n+    }\n+\n@@ -448,0 +457,27 @@\n+    public boolean isListening() {\n+        return server;\n+    }\n+\n+    public void reopenAfterRestore() throws IOException {\n+        if (!server) {\n+            throw new UnsupportedOperationException(\"Reopen not implemented for non-server sockets\");\n+        }\n+        synchronized (stateLock) {\n+            FileDescriptor fd;\n+            fd = Net.serverSocket(true);\n+            Runnable closer = closerFor(fd, true);\n+            IOUtil.setfdVal(NioSocketImpl.this.fd, IOUtil.fdVal(fd));\n+            NioSocketImpl.this.cleaner = CleanerFactory.cleaner().register(NioSocketImpl.this, closer);\n+            state = ST_UNCONNECTED;\n+\n+            if (localport != 0) {\n+                int port = localport;\n+                localport = 0;\n+                bind(address, port);\n+            }\n+            if (backlog > 0) {\n+                Net.listen(fd, backlog);\n+            }\n+        }\n+    }\n+\n@@ -645,1 +681,2 @@\n-            Net.listen(fd, backlog < 1 ? 50 : backlog);\n+            this.backlog = backlog < 1 ? 50 : backlog;\n+            Net.listen(fd, this.backlog);\n@@ -1190,1 +1227,1 @@\n-    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+    private static Runnable closerFor0(FileDescriptor fd, boolean stream) {\n@@ -1210,0 +1247,14 @@\n+    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+\n+        \/\/ FIXME ensure FileDispatcherImpl's Resource is registered before the closer is used,\n+        \/\/ otherwise the closer during beforeCheckpoint may be the first one to access\n+        \/\/ FileDescriptor, and then Dispatcher Resource will be blocked for registration.\n+        try {\n+            MethodHandles.lookup().ensureInitialized(FileDispatcherImpl.class);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        return closerFor0(fd, stream);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":53,"deletions":2,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+import jdk.internal.access.JavaNioChannelsSpiAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.JDKSocketResource;\n@@ -71,0 +74,1 @@\n+    private static final JavaNioChannelsSpiAccess SPI_ACCESS = SharedSecrets.getJavaNioChannelsSpiAccess();\n@@ -77,1 +81,3 @@\n-    private final int fdVal;\n+    private int fdVal;\n+    private final Resource resource = new Resource();\n+    private int backlog;\n@@ -299,0 +305,2 @@\n+            \/\/ Persisting the backlog since there's no way to query that before close\n+            this.backlog = backlog < 1 ? 50 : backlog;\n@@ -405,1 +413,0 @@\n-\n@@ -731,0 +738,55 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(ServerSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isListening() {\n+            return true;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore() throws IOException {\n+            FileDescriptor newFd;\n+            if (family == UNIX) {\n+                newFd = UnixDomainSockets.socket();\n+            } else {\n+                newFd = Net.serverSocket(family, true);\n+            }\n+            \/\/ We could avoid making fdVal non-final and dup2(...) to the original\n+            \/\/ value but that could accidentally conflict with another FD created\n+            \/\/ during restore.\n+            fdVal = IOUtil.fdVal(newFd);\n+            IOUtil.setfdVal(fd, fdVal);\n+            synchronized (stateLock) {\n+                state = ST_INUSE;\n+                if (isUnixSocket()) {\n+                    localAddress = unixBind(localAddress, backlog);\n+                } else {\n+                    localAddress = netBind(localAddress, backlog);\n+                }\n+            }\n+            SPI_ACCESS.setChannelReopened(ServerSocketChannelImpl.this);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -86,0 +87,1 @@\n+    private final Resource resource = new Resource();\n@@ -1603,0 +1605,31 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(SocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1076,0 +1076,15 @@\n+`-XX:CRaCCheckpointTo=`*directory*\n+:   The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+    a running Java program into an image directory. Restoring from the image should\n+    solve some of the problematic start-up and warm-up times.\n+\n+    This option defines a path to the snapshot which is currently a directory. The\n+    directory will be created if it does not exist, but no parent directories are\n+    created.\n+\n+`-XX:CRaCRestoreFrom=`*directory*\n+:   Restores a snapshot created by `-XX:CRaCCheckpointTo=`*directory*.\n+\n+`-XX:CRaCMinPid=`*value*\n+:   A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+\n@@ -1824,0 +1839,6 @@\n+`-XX:CPUFeatures=`*0xnumber,0xnumber*\n+:   CPU feature set, use `-XX:CPUFeatures=`*0xnumber,0xnumber* with\n+    `-XX:CRaCCheckpointTo` when you get an error during `-XX:CRaCRestoreFrom`\n+    on a different machine. `-XX:CPUFeatures=native` is the default.\n+    `-XX:CPUFeatures=generic` is compatible with any CPU.\n+\n@@ -1828,0 +1849,5 @@\n+`-XX:+IgnoreCPUFeatures`\n+:   Skip any verifications of `-XX:CPUFeatures`. It may lead to a crash\n+    if `-XX:CRaCRestoreFrom` is used on a CPU with less features than the CPU\n+    where `-XX:CRaCCheckpointTo` was made.\n+\n@@ -1991,0 +2017,4 @@\n+`-XX:+ShowCPUFeatures`\n+:   Show features of this CPU to be possibly used for the\n+    `-XX:CPUFeatures=`*0xnumber* option.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,0 +31,7 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -33,0 +40,20 @@\n+    static class ResourceProxy implements JDKResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            UnixDispatcher.beforeCheckpoint();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context)\n+                throws IOException {\n+            UnixDispatcher.afterRestore();\n+        }\n+    }\n+\n+    static Object closeLock = new Object();\n+    static boolean forceNonDeferedClose;\n+    static int closeCnt;\n+\n+    static ResourceProxy resourceProxy = new ResourceProxy();\n+\n+\n@@ -35,1 +62,55 @@\n-        close0(fd);\n+        closeAndMark(fd);\n+    }\n+\n+    void preClose(FileDescriptor fd) throws IOException {\n+        boolean doPreclose = true;\n+        synchronized (closeLock) {\n+            if (forceNonDeferedClose) {\n+                doPreclose = false;\n+            }\n+            if (doPreclose) {\n+                ++closeCnt;\n+            }\n+        }\n+\n+        if (!doPreclose) {\n+            return;\n+        }\n+\n+        try {\n+            preClose0(fd);\n+        } finally {\n+            synchronized (closeLock) {\n+                closeCnt--;\n+                if (forceNonDeferedClose && closeCnt == 0) {\n+                    closeLock.notifyAll();\n+                }\n+            }\n+        }\n+    }\n+\n+    static void beforeCheckpoint() throws InterruptedException {\n+        synchronized (closeLock) {\n+            forceNonDeferedClose = true;\n+            while (closeCnt != 0) {\n+                closeLock.wait();\n+            }\n+            beforeCheckpoint0();\n+        }\n+    }\n+\n+    static void afterRestore() throws IOException {\n+        synchronized (closeLock) {\n+            afterRestore0();\n+            forceNonDeferedClose = false;\n+        }\n+    }\n+\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+        SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    static void closeAndMark(FileDescriptor fd) throws IOException {\n+        \/\/ Originally this used fdAccess.markClosed() and close0() but leaving\n+        \/\/ the FD value set breaks JDKSocketResource (we don't want the extra\n+        \/\/ test if the FD resource has been marked).\n+        fdAccess.close(fd);\n@@ -53,0 +134,4 @@\n+    static native void beforeCheckpoint0();\n+\n+    static native void afterRestore0() throws IOException;\n+\n@@ -56,0 +141,4 @@\n+        \/\/ We cannot register using normal priority because other JDK resources\n+        \/\/ might read configuration files with this or later priority.\n+        \/\/ It's difficult to trigger static initialization outside the package.\n+        Core.Priority.PRE_FILE_DESCRIPTORS.getContext().register(resourceProxy);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixDispatcher.java","additions":90,"deletions":1,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -116,0 +116,2 @@\n+# JDK-8310862 was closed but we're still seeing errors with the updated test\n+runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8310862 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -514,0 +514,6 @@\n+# jdk_crac\n+\n+jdk\/crac\/LinkedCleanableRefTest.java                            8353064 generic-all\n+\n+############################################################################\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}