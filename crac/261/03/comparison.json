{"files":[{"patch":"@@ -558,1 +558,2 @@\n-        Arguments::java_command_crac() ? Arguments::java_command_crac() : \"\",\n+        !CRaCIgnoreRestoreIfUnavailable && Arguments::java_command_crac() != nullptr ?\n+          Arguments::java_command_crac() : \"\",\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1992,2 +1992,6 @@\n-          \"Ignore -XX:CRaCRestoreFrom and continue initialization if \"      \\\n-          \"restore is not possible\")                                        \\\n+          \"If the image selected via CRaCRestoreFrom is identified as \"     \\\n+          \"being unusable, continue initializing the JVM instead of \"       \\\n+          \"failing. Enabling this option does not guarantee that the \"      \\\n+          \"initialization will continue after any failed restoration \"      \\\n+          \"attempt; it only covers an early image\/environment \"             \\\n+          \"verification.\")                                                  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1088,0 +1088,16 @@\n+    You can optionally pass the name of the new main class and its arguments when\n+    using this option. In such a case, the new main method will be invoked with\n+    the specified arguments by the thread that initiated the checkpoint, after all\n+    CRaC resources have been successfully processed.\n+\n+`-XX:+CRaCIgnoreRestoreIfUnavailable`\n+:   If the checkpoint image specified for restoration is identified as being\n+    unusable, continue with the normal startup instead of failing.\n+\n+    When restoring with this option, you should specify the command-line arguments\n+    for the normal startup process. If the restoration succeeds, they are ignored;\n+    otherwise, they are used for starting up.\n+\n+    If an initial image verification passes, but restoration still fails, the JVM\n+    will not attempt to start normally.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.nio.file.Files;\n+import java.util.Collections;\n@@ -30,0 +32,1 @@\n+import static jdk.test.lib.Asserts.*;\n@@ -60,2 +63,2 @@\n-        } else {\n-            FileUtils.deleteFileTreeWithRetry(builder.imageDir()); \/\/ Existance depends on the order of @run tags\n+        } else if (Files.exists(builder.imageDir())) { \/\/ Existance depends on the order of @run tags\n+            FileUtils.deleteFileTreeWithRetry(builder.imageDir());\n@@ -64,3 +67,10 @@\n-        builder.startRestoreWithArgs(null, List.of(Main.class.getName(), \"false\"))\n-            .waitForSuccess().outputAnalyzer()\n-            .stdoutShouldNotContain(WARMUP_MSG).stdoutShouldContain(MAIN_MSG);\n+        final var out = builder.startRestoreWithArgs(null, List.of(Main.class.getName(), \"false\"))\n+            .waitForSuccess().outputAnalyzer();\n+        out.stdoutShouldNotContain(WARMUP_MSG);\n+\n+        \/\/ Check the count to ensure a new main is not launched on successful restore\n+        final var mainMsgCount = Collections.frequency(out.stdoutAsLines(), MAIN_MSG);\n+        if (mainMsgCount != 1) {\n+            out.reportDiagnosticSummary();\n+            assertEquals(1, mainMsgCount, \"Main message should be printed exactly once\");\n+        }\n","filename":"test\/jdk\/jdk\/crac\/ignoreRestore\/RestoreIfPossibleTest.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}