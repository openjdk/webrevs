{"files":[{"patch":"@@ -558,1 +558,2 @@\n-        Arguments::java_command_crac() ? Arguments::java_command_crac() : \"\",\n+        !CRaCIgnoreRestoreIfUnavailable && Arguments::java_command_crac() != nullptr ?\n+          Arguments::java_command_crac() : \"\",\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1088,0 +1088,15 @@\n+    When using this option, there is no requirement to specify a main class and its\n+    arguments because the restored execution is based on the ones specified before\n+    the checkpoint. However, it is possible to pass a new main class and new\n+    arguments. After a successful restoration, the new main method will be invoked\n+    with the specified arguments in the thread that started the checkpoint, on top\n+    of its existing call stack.\n+\n+`-XX:+CRaCIgnoreRestoreIfUnavailable`\n+:   If restoration from a checkpoint image fails, continue with the normal startup\n+    instead of failing.\n+\n+    When restoring with this option, you should specify a main class and its\n+    arguments as usual. If the restoration succeeds, they are ignored, but if it\n+    fails, they are used for the normal startup process.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.nio.file.Files;\n+import java.util.Collections;\n@@ -30,0 +32,1 @@\n+import static jdk.test.lib.Asserts.*;\n@@ -60,2 +63,2 @@\n-        } else {\n-            FileUtils.deleteFileTreeWithRetry(builder.imageDir()); \/\/ Existance depends on the order of @run tags\n+        } else if (Files.exists(builder.imageDir())) { \/\/ Existance depends on the order of @run tags\n+            FileUtils.deleteFileTreeWithRetry(builder.imageDir());\n@@ -64,3 +67,10 @@\n-        builder.startRestoreWithArgs(null, List.of(Main.class.getName(), \"false\"))\n-            .waitForSuccess().outputAnalyzer()\n-            .stdoutShouldNotContain(WARMUP_MSG).stdoutShouldContain(MAIN_MSG);\n+        final var out = builder.startRestoreWithArgs(null, List.of(Main.class.getName(), \"false\"))\n+            .waitForSuccess().outputAnalyzer();\n+        out.stdoutShouldNotContain(WARMUP_MSG);\n+\n+        \/\/ Check the count to ensure a new main is not launched on successful restore\n+        final var mainMsgCount = Collections.frequency(out.stdoutAsLines(), MAIN_MSG);\n+        if (mainMsgCount != 1) {\n+            out.reportDiagnosticSummary();\n+            assertEquals(1, mainMsgCount, \"Main message should be printed exactly once\");\n+        }\n","filename":"test\/jdk\/jdk\/crac\/ignoreRestore\/RestoreIfPossibleTest.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"}]}