{"files":[{"patch":"@@ -230,0 +230,4 @@\n+$(eval $(call SetupBuildDemo, JavaCompilerCRaC, \\\n+    DEMO_SUBDIR := crac, \\\n+))\n+\n","filename":"make\/CompileDemos.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    -tag crac:cmopt:'CRaC:' \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+    jdk.crac \\\n","filename":"make\/conf\/module-loader-map.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -159,0 +159,4 @@\n+ifneq ($(call check-jvm-feature, cpu_feature_active), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_CPU_FEATURE_ACTIVE=0\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,0 +107,57 @@\n+\n+ifeq ($(OPENJDK_TARGET_OS), linux)\n+  $(eval $(call SetupJdkExecutable, BUILD_CRIUENGINE, \\\n+      NAME := criuengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criuengine, \\\n+      INCLUDE_FILES := criuengine.c, \\\n+      OPTIMIZATION := HIGH, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_CRIUENGINE)\n+\n+endif\n+\n+ifeq ($(call isTargetOs, macosx linux windows), true)\n+  ifeq ($(OPENJDK_TARGET_OS), windows)\n+    CRAC_ENGINE_DIR = modules_cmds\n+  else\n+    CRAC_ENGINE_DIR = modules_libs\n+  endif\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n+      NAME := pauseengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/pauseengine, \\\n+      INCLUDE_FILES := pauseengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_PAUSEENGINE)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_SIMENGINE, \\\n+      NAME := simengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/share\/native\/simengine, \\\n+      INCLUDE_FILES := simengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/$(CRAC_ENGINE_DIR)\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_SIMENGINE)\n+\n+  ifneq ($(USE_CRIU_CRAC),)\n+\n+    CRIU_CRAC_BIN := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE)\/criu\n+    TARGETS += $(CRIU_CRAC_BIN)\n+\n+$(CRIU_CRAC_BIN) : $(USE_CRIU_CRAC)\n+\t$(call MakeTargetDir)\n+\t$(CP) $(USE_CRIU_CRAC) $(CRIU_CRAC_BIN)\n+\n+  endif\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -204,0 +204,13 @@\n+# Build checkpoint\/restore exec library\n+################################################################################\n+\n+# CFLAGS_windows from make\/autoconf\/flags-cflags.m4#FLAGS_SETUP_CFLAGS_HELPER\n+$(eval $(call SetupJdkLibrary, BUILD_LIBCREXEC, \\\n+    NAME := crexec, \\\n+    LINK_TYPE := C++, \\\n+    EXTRA_HEADER_DIRS := libjvm, \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB) -DCRLIB_IS_IMPL, \\\n+    CXXFLAGS_windows := -D_WINDOWS -DWIN32, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB), \\\n+))\n+TARGETS += $(BUILD_LIBCREXEC)\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    EXCLUDES := jdk\/test\/lib\/containers jdk\/test\/lib\/security, \\\n+    EXCLUDES := jdk\/test\/lib\/containers\/cgroup jdk\/test\/lib\/containers\/systemd jdk\/test\/lib\/security, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -288,0 +288,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -43,0 +44,3 @@\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# include <sys\/platform\/x86.h>\n+#endif\n@@ -49,0 +53,1 @@\n+uint64_t VM_Version::_glibc_features;\n@@ -51,1 +56,2 @@\n-const char* VM_Version::_features_names[] = { CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::      _features_names[] = {   CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::_glibc_features_names[] = { GLIBC_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n@@ -87,2 +93,11 @@\n-  assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), \"clflush should be available\");\n-  return true;\n+  if (!Universe::is_fully_initialized()) {\n+    return true;\n+  }\n+  if ((_features & CPU_FLUSH) != 0) {\n+    return true;\n+  }\n+  if (FLAG_IS_DEFAULT(CPUFeatures)) {\n+    vm_exit_during_initialization(\"clflush should be available\");\n+  }\n+  vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires FLUSH flag to be set: \" UINT64_FORMAT_X, CPU_FLUSH));\n+  return false;\n@@ -861,1 +876,273 @@\n-void VM_Version::get_processor_features() {\n+uint64_t VM_Version::CPUFeatures_parse(uint64_t &glibc_features) {\n+  glibc_features = _glibc_features;\n+#ifndef LINUX\n+  _ignore_glibc_not_using = true;\n+  return _features;\n+#endif\n+  if (CPUFeatures == NULL || strcmp(CPUFeatures, \"native\") == 0) {\n+    return _features;\n+  }\n+  if (strcmp(CPUFeatures, \"ignore\") == 0) {\n+    _ignore_glibc_not_using = true;\n+    return _features;\n+  }\n+  glibc_features = 0;\n+  if (strcmp(CPUFeatures, \"generic\") == 0) {\n+    \/\/ 32-bit x86 cannot rely on anything.\n+    return 0\n+#ifdef AMD64\n+      \/\/ The following options are all in \/proc\/cpuinfo of one of the first 64-bit CPUs - Atom D2700 (and Opteron 1352): https:\/\/superuser.com\/q\/1572306\/1015048\n+      | CPU_SSE \/\/ enabled in 'gcc -Q --help=target', used by OpenJDK\n+      | CPU_SSE2 \/\/ enabled in 'gcc -Q --help=target', required by OpenJDK\n+      | CPU_FXSR \/\/ enabled in 'gcc -Q --help=target', not used by OpenJDK\n+      | CPU_MMX \/\/ enabled in 'gcc -Q --help=target', used only by 32-bit x86 OpenJDK\n+      | CPU_TSC \/\/ not used by gcc, used by OpenJDK\n+      | CPU_CX8 \/\/ gcc detects it to set cpu \"pentium\" (=32-bit only), used by OpenJDK\n+      | CPU_CMOV \/\/ gcc detects it to set cpu \"pentiumpro\" (=32-bit only), used by OpenJDK\n+      | CPU_FLUSH \/\/ =\"clflush\" in cpuinfo, not used by gcc, required by OpenJDK\n+      \/\/ GLIBC_MOVBE is disabled in 'gcc -Q --help=target' and for example i7-720QM does not support it\n+      \/\/ GLIBC_LAHFSAHF is disabled in 'gcc -Q --help=target' and \"Early Intel Pentium 4 CPUs with Intel 64 support ... lacked the LAHF and SAHF instructions\"\n+#endif\n+    ;\n+  }\n+  char *endptr;\n+  errno = 0;\n+  uint64_t retval;\n+  unsigned long long ull = strtoull(CPUFeatures, &endptr, 0);\n+  retval = ull;\n+  if (!errno && *endptr == ',' && retval == ull) {\n+    ull = strtoull(endptr + 1, &endptr, 0);\n+    glibc_features = ull;\n+    if (!errno && !*endptr && glibc_features == ull) {\n+      return retval;\n+    }\n+  }\n+  vm_exit_during_initialization(err_msg(\"VM option 'CPUFeatures=%s' must be of the form: 0xnum,0xnum\", CPUFeatures));\n+  return -1;\n+}\n+\n+bool VM_Version::_ignore_glibc_not_using = false;\n+bool VM_Version::_crac_restore_missing_features;\n+#ifdef LINUX\n+const char VM_Version::glibc_prefix[] = \":glibc.cpu.hwcaps=\";\n+const size_t VM_Version::glibc_prefix_len = strlen(glibc_prefix);\n+\n+bool VM_Version::glibc_env_set(char *disable_str) {\n+#define TUNABLES_NAME \"GLIBC_TUNABLES\"\n+#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n+  char *env_val = disable_str;\n+  const char *env = getenv(TUNABLES_NAME);\n+  if (env && (strcmp(env, env_val) == 0 || (!INCLUDE_CPU_FEATURE_ACTIVE && getenv(REEXEC_NAME)))) {\n+    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+      if (ShowCPUFeatures) {\n+        tty->print_cr(\"Environment variable already set, glibc CPU_FEATURE_ACTIVE is unavailable - re-exec suppressed: \" TUNABLES_NAME \"=%s\", env);\n+      }\n+      return true;\n+    }\n+  }\n+  char env_buf[strlen(disable_str) + (!env ? 0 : strlen(env) + 100)];\n+  if (env) {\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+    }\n+    const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n+    if (!hwcaps) {\n+      strcpy(env_buf, env);\n+      strcat(env_buf, disable_str);\n+    } else {\n+      const char *colon = strchr(hwcaps, ':');\n+      if (!colon) {\n+        strcpy(env_buf, env);\n+        strcat(env_buf, disable_str + glibc_prefix_len);\n+      } else {\n+        int err = jio_snprintf(env_buf, sizeof(env_buf), \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n+        assert(err >= 0 && (unsigned)err < sizeof(env_buf), \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+      }\n+    }\n+    env_val = env_buf;\n+  }\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+  }\n+  int err = setenv(TUNABLES_NAME, env_val, 1);\n+  if (err)\n+    vm_exit_during_initialization(err_msg(\"setenv \" TUNABLES_NAME \" error: %m\"));\n+\n+  if (getenv(REEXEC_NAME))\n+    vm_exit_during_initialization(err_msg(\"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str));\n+  if (setenv(REEXEC_NAME, \"1\", 1))\n+    vm_exit_during_initialization(err_msg(\"setenv \" REEXEC_NAME \" error: %m\"));\n+#undef REEXEC_NAME\n+#undef TUNABLES_NAME\n+  return false;\n+}\n+\n+void VM_Version::glibc_reexec() {\n+  char *buf = NULL;\n+  size_t buf_allocated = 0;\n+  size_t buf_used = 0;\n+#define CMDLINE \"\/proc\/self\/cmdline\"\n+  int fd = open(CMDLINE, O_RDONLY);\n+  if (fd == -1)\n+    vm_exit_during_initialization(err_msg(\"Cannot open \" CMDLINE \": %m\"));\n+  ssize_t got;\n+  do {\n+    if (buf_used == buf_allocated) {\n+      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n+      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n+      if (buf == NULL)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu bytes\", buf_allocated));\n+    }\n+    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n+    if (got == -1)\n+      vm_exit_during_initialization(err_msg(\"Cannot read \" CMDLINE \": %m\"));\n+    buf_used += got;\n+  } while (got);\n+  if (close(fd))\n+    vm_exit_during_initialization(err_msg(\"Cannot close \" CMDLINE \": %m\"));\n+  char **argv = NULL;\n+  size_t argv_allocated = 0;\n+  size_t argv_used = 0;\n+  char *s = buf;\n+  while (s <= buf + buf_used) {\n+    if (argv_used == argv_allocated) {\n+      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n+      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n+      if (argv == NULL)\n+        vm_exit_during_initialization(err_msg(CMDLINE \" reading failed allocating %zu pointers\", argv_allocated));\n+    }\n+    if (s == buf + buf_used) {\n+      break;\n+    }\n+    argv[argv_used++] = s;\n+    s += strnlen(s, buf + buf_used - s);\n+    if (s == buf + buf_used)\n+      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n+    ++s;\n+  }\n+  argv[argv_used] = NULL;\n+#undef CMDLINE\n+\n+#define EXEC \"\/proc\/self\/exe\"\n+  execv(EXEC, argv);\n+  vm_exit_during_initialization(err_msg(\"Cannot re-execute \" EXEC \": %m\"));\n+#undef EXEC\n+}\n+\n+void VM_Version::glibc_not_using(uint64_t shouldnotuse_CPU, uint64_t shouldnotuse_GLIBC) {\n+#ifndef ASSERT\n+  if (!shouldnotuse_CPU && !shouldnotuse_GLIBC)\n+    return;\n+#endif\n+\n+  \/\/ glibc: sysdeps\/x86\/get-isa-level.h:\n+  \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMOV)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, CX8)\n+  \/\/ glibc:     && CPU_FEATURE_CPU_P (cpu_features, FPU)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FXSR)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MMX)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE2))\n+  \/\/ glibc:     isa_level = GNU_PROPERTY_X86_ISA_1_BASELINE;\n+  if ((_features & CPU_CMOV) &&\n+      (_features & CPU_CX8) &&\n+      \/\/ FPU is always present on i686+: (_features & CPU_FPU) &&\n+      (_features & CPU_SSE2)) {\n+    \/\/ These cannot be disabled by GLIBC_TUNABLES.\n+    if (shouldnotuse_CPU & (CPU_FXSR | CPU_MMX | CPU_SSE)) {\n+      assert(!(shouldnotuse_CPU & CPU_SSE2), \"CPU_SSE2 in both _features and shouldnotuse_CPU cannot happen\");\n+      \/\/ FIXME: The choice should be based on glibc impact, not the feature age.\n+      \/\/ CX8 is i586+, CMOV is i686+ 1995+, SSE2 is 2000+\n+      shouldnotuse_CPU |= CPU_SSE2;\n+    }\n+    if ((_features & CPU_FXSR) &&\n+        (_features & CPU_MMX) &&\n+        (_features & CPU_SSE)) {\n+      \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMPXCHG16B)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LAHF64_SAHF64)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, POPCNT)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_1)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_2))\n+      \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V2;\n+      if ((_features & CPU_POPCNT) &&\n+          (_features & CPU_SSSE3) &&\n+          (_features & CPU_SSE4_1) &&\n+          (_features & CPU_SSE4_2)) {\n+        if ((shouldnotuse_CPU & CPU_SSE3) ||\n+            (shouldnotuse_GLIBC & (GLIBC_CMPXCHG16 | GLIBC_LAHFSAHF))) {\n+          assert(!(shouldnotuse_CPU & CPU_SSE4_2), \"CPU_SSE4_2 in both _features and shouldnotuse_CPU cannot happen\");\n+          \/\/ POPCNT is 2007+, SSSE3 is 2006+, SSE4_1 is 2007+, SSE4_2 is 2008+.\n+          shouldnotuse_CPU |= CPU_SSE4_2;\n+        }\n+        if ((_features & CPU_SSE3) &&\n+            (_glibc_features & GLIBC_CMPXCHG16) &&\n+            (_glibc_features & GLIBC_LAHFSAHF)) {\n+          \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI1)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, F16C)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FMA)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LZCNT)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MOVBE))\n+          \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V3;\n+          if ((_features & CPU_AVX) &&\n+              (_features & CPU_AVX2) &&\n+              (_features & CPU_BMI1) &&\n+              (_features & CPU_BMI2) &&\n+              (_features & CPU_FMA) &&\n+              (_features & CPU_LZCNT) &&\n+              (_glibc_features & GLIBC_MOVBE)) {\n+            if (shouldnotuse_GLIBC & GLIBC_F16C) {\n+              assert(!(shouldnotuse_GLIBC & GLIBC_MOVBE), \"GLIBC_MOVBE in both _glibc_features and shouldnotuse_GLIBC cannot happen\");\n+              \/\/ FMA is 2012+, AVX2+BMI1+BMI2+LZCNT are 2013+, MOVBE is 2015+\n+              shouldnotuse_GLIBC |= GLIBC_MOVBE;\n+            }\n+            if (_glibc_features & GLIBC_F16C) {\n+              \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX512F)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512BW)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512CD)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512DQ)\n+              \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512VL))\n+              \/\/ glibc:   isa_level |= GNU_PROPERTY_X86_ISA_1_V4;\n+              \/\/ All these flags are supported by disable() below.\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+#define PASTE_TOKENS3(x, y, z) PASTE_TOKENS(x, PASTE_TOKENS(y, z))\n+  enum kind { KIND_CPU = 0, KIND_GLIBC, KIND_COUNT };\n+\n+  static const size_t tunables_size_max = 17;\n+  \/\/ 64 is # of bits in uint64_t VM_Version::_glibc_features.\n+  char disable_str[KIND_COUNT * 64 * (1\/*','*\/ + 1\/*'-'*\/ + tunables_size_max) + 1\/*'\\0'*\/];\n+  strcpy(disable_str, glibc_prefix);\n+  char *disable_end = disable_str + glibc_prefix_len;\n+  auto disable = [&](enum kind kind, uint64_t value, const char *tunables) {\n+    size_t remains = disable_str + sizeof(disable_str) - disable_end;\n+    guarantee(2 + strlen(tunables) < remains, \"internal error: disable_str overflow\");\n+    *disable_end++ = ',';\n+    *disable_end++ = '-';\n+    disable_end = stpcpy(disable_end, tunables);\n+  };\n+\n+#ifdef ASSERT\n+  uint64_t handled[KIND_COUNT] = { 0 };\n+#endif\n+  auto shouldnotuse_handled = [&](enum kind kind, uint64_t value, const char *kindstr, const char *tunables) {\n+    assert(strlen(tunables) <= tunables_size_max, \"Too long string %s\", tunables);\n+    assert((handled[kind] & value) == 0, \"already used %s_%s\", kindstr, tunables);\n+    DEBUG_ONLY(handled[kind] |= value);\n+  };\n+#define EXCESSIVE_HANDLED(kind, tunables) shouldnotuse_handled(PASTE_TOKENS(KIND_, kind), PASTE_TOKENS3(kind, _, tunables), STR(kind), STR(tunables))\n+\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# define FEATURE_ACTIVE(tunables) CPU_FEATURE_ACTIVE(tunables)\n+#else\n+# define FEATURE_ACTIVE(tunables) true\n+#endif\n@@ -863,0 +1150,141 @@\n+  const uint64_t shouldnotuseval[KIND_COUNT] = { shouldnotuse_CPU, shouldnotuse_GLIBC };\n+  auto shouldnotuse = [&](enum kind kind, uint64_t value, const char *kindstr, const char *tunables, bool feature_active) {\n+    shouldnotuse_handled(kind, value, kindstr, tunables);\n+    if ((shouldnotuseval[kind] & value) != 0 && feature_active) {\n+      disable(kind, value, tunables);\n+    }\n+  };\n+#define EXCESSIVE(kind, tunables) \\\n+    shouldnotuse(PASTE_TOKENS(KIND_, kind), PASTE_TOKENS3(kind, _, tunables), STR(kind), STR(tunables), FEATURE_ACTIVE(tunables))\n+\n+  EXCESSIVE(CPU  , AVX     );\n+  EXCESSIVE(CPU  , CX8     );\n+  EXCESSIVE(CPU  , FMA     );\n+  EXCESSIVE(CPU  , RTM     );\n+  EXCESSIVE(CPU  , AVX2    );\n+  EXCESSIVE(CPU  , BMI1    );\n+  EXCESSIVE(CPU  , BMI2    );\n+  EXCESSIVE(CPU  , CMOV    );\n+  EXCESSIVE(CPU  , ERMS    );\n+  EXCESSIVE(CPU  , SSE2    );\n+  EXCESSIVE(CPU  , LZCNT   );\n+  EXCESSIVE(CPU  , SSSE3   );\n+  EXCESSIVE(CPU  , POPCNT  );\n+  EXCESSIVE(CPU  , SSE4_1  );\n+  EXCESSIVE(CPU  , SSE4_2  );\n+  EXCESSIVE(CPU  , AVX512F );\n+  EXCESSIVE(CPU  , AVX512CD);\n+  EXCESSIVE(CPU  , AVX512BW);\n+  EXCESSIVE(CPU  , AVX512DQ);\n+  EXCESSIVE(CPU  , AVX512ER);\n+  EXCESSIVE(CPU  , AVX512PF);\n+  EXCESSIVE(CPU  , AVX512VL);\n+  EXCESSIVE(GLIBC, IBT     );\n+  EXCESSIVE(GLIBC, FMA4    );\n+  EXCESSIVE(GLIBC, MOVBE   );\n+  EXCESSIVE(GLIBC, SHSTK   );\n+  EXCESSIVE(GLIBC, XSAVE   );\n+  EXCESSIVE(GLIBC, OSXSAVE );\n+  EXCESSIVE(GLIBC, HTT     );\n+#undef EXCESSIVE\n+#undef EXCESSIVE3\n+\n+#ifdef ASSERT\n+  \/\/ These cannot be disabled by GLIBC_TUNABLES interface.\n+#define GLIBC_UNSUPPORTED(kind, hotspot) EXCESSIVE_HANDLED(kind, hotspot)\n+  GLIBC_UNSUPPORTED(CPU  , 3DNOW_PREFETCH   );\n+  GLIBC_UNSUPPORTED(CPU  , SSE4A            );\n+  GLIBC_UNSUPPORTED(CPU  , TSC              );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV_BIT       );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV           );\n+  GLIBC_UNSUPPORTED(CPU  , AES              );\n+  GLIBC_UNSUPPORTED(CPU  , CLMUL            );\n+  GLIBC_UNSUPPORTED(CPU  , ADX              );\n+  GLIBC_UNSUPPORTED(CPU  , SHA              );\n+  GLIBC_UNSUPPORTED(CPU  , VZEROUPPER       );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPOPCNTDQ );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPCLMULQDQ);\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VAES      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VNNI      );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSH            );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSHOPT         );\n+  GLIBC_UNSUPPORTED(CPU  , CLWB             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI2     );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI      );\n+  GLIBC_UNSUPPORTED(CPU  , HV               );\n+  GLIBC_UNSUPPORTED(CPU  , SSE3             );\n+  GLIBC_UNSUPPORTED(CPU  , SERIALIZE        );\n+  GLIBC_UNSUPPORTED(CPU  , RDTSCP           );\n+  GLIBC_UNSUPPORTED(CPU  , RDPID            );\n+  GLIBC_UNSUPPORTED(CPU  , FSRM             );\n+  GLIBC_UNSUPPORTED(CPU  , GFNI             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_BITALG    );\n+  GLIBC_UNSUPPORTED(CPU  , F16C             );\n+  GLIBC_UNSUPPORTED(CPU  , PKU              );\n+  GLIBC_UNSUPPORTED(CPU  , OSPKE            );\n+  GLIBC_UNSUPPORTED(CPU  , CET_IBT          );\n+  GLIBC_UNSUPPORTED(CPU  , CET_SS           );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_IFMA      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX_IFMA         );\n+  GLIBC_UNSUPPORTED(CPU  , APX_F            );\n+  GLIBC_UNSUPPORTED(CPU  , SHA512           );\n+  \/\/ These are handled as an exception above.\n+  GLIBC_UNSUPPORTED(CPU  , FXSR             );\n+  GLIBC_UNSUPPORTED(CPU  , MMX              );\n+  GLIBC_UNSUPPORTED(CPU  , SSE              );\n+  GLIBC_UNSUPPORTED(CPU  , HT               );\n+  GLIBC_UNSUPPORTED(GLIBC, CMPXCHG16        );\n+  GLIBC_UNSUPPORTED(GLIBC, LAHFSAHF         );\n+  GLIBC_UNSUPPORTED(GLIBC, F16C             );\n+#undef GLIBC_UNSUPPORTED\n+\n+  auto check_kind = [&](enum kind kind, const char *kindstr, uint64_t mask) {\n+    if (handled[kind] != mask) {\n+      vm_exit_during_initialization(err_msg(\"internal error: Unsupported disabling of some %s_* 0x%\" PRIx64 \" != full 0x%\" PRIx64, kindstr, handled[kind], mask));\n+    }\n+  };\n+#define CHECK_KIND(kind) check_kind(PASTE_TOKENS(KIND_, kind), STR(kind), PASTE_TOKENS(MAX_, kind) - 1)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+#endif \/\/ ASSERT\n+\n+  *disable_end = 0;\n+  if (disable_end == disable_str + glibc_prefix_len)\n+    return;\n+  if (glibc_env_set(disable_str))\n+    return;\n+  glibc_reexec();\n+}\n+#endif \/\/LINUX\n+\n+void VM_Version::nonlibc_tty_print_uint64(uint64_t num) {\n+  static const char prefix[] = \"0x\";\n+  tty->write(prefix, sizeof(prefix) - 1);\n+  bool first = true;\n+  for (int pos = 64 - 4; pos >= 0; pos -= 4) {\n+    unsigned nibble = (num >> pos) & 0xf;\n+    if (first && nibble == 0 && pos)\n+      continue;\n+    first = false;\n+    char c = nibble >= 0xa ? 'a' + nibble - 0xa : '0' + nibble;\n+    tty->write(&c, sizeof(c));\n+  }\n+}\n+\n+void VM_Version::nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2) {\n+  nonlibc_tty_print_uint64(num1);\n+  static const char comma = ',';\n+  tty->print_raw(&comma, sizeof(comma));\n+  nonlibc_tty_print_uint64(num2);\n+}\n+\n+void VM_Version::print_using_features_cr() {\n+  if (_ignore_glibc_not_using) {\n+    tty->print_cr(\"CPU features are being kept intact as requested by -XX:CPUFeatures=ignore\");\n+  } else {\n+    tty->print_cr(\"CPU features being used are: -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, _features, _glibc_features);\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hardware() {\n@@ -867,0 +1295,1 @@\n+  _glibc_features = 0;\n@@ -883,0 +1312,1 @@\n+    LINUX_ONLY(_glibc_features = _cpuid_info.glibc_flags();)\n@@ -895,0 +1325,9 @@\n+  if (ShowCPUFeatures) {\n+    static const char prefix[] = \"This machine's CPU features are: -XX:CPUFeatures=\";\n+    tty->print_raw(prefix, sizeof(prefix) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    tty->cr();\n+  }\n+}\n+\n+void VM_Version::get_processor_features_hotspot() {\n@@ -898,0 +1337,2 @@\n+    if (!FLAG_IS_DEFAULT(CPUFeatures))\n+      vm_exit_during_initialization(err_msg(\"-XX:CPUFeatures option requires SSE2 flag to be set: \" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, CPU_SSE2, (uint64_t)0));\n@@ -1098,1 +1539,1 @@\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  insert_features_names(buf + res, sizeof(buf) - res);\n@@ -2151,0 +2592,72 @@\n+\/\/ Print the feature names as \" = feat1, ..., featN\\n\";\n+void VM_Version::missing_features(uint64_t features_missing, uint64_t glibc_features_missing) {\n+  static const char part1[] = \"; missing features of this CPU are \";\n+  tty->print_raw(part1, sizeof(part1) - 1);\n+  nonlibc_tty_print_uint64_comma_uint64(features_missing, glibc_features_missing);\n+  static const char part2[] = \" =\";\n+  tty->print_raw(part2, sizeof(part2) - 1);\n+  char buf[512] = \"\";\n+  \/\/ insert_features_names() does crash for undefined too high-numbered features.\n+  insert_features_names(buf, sizeof(buf)          ,       features_missing & (  MAX_CPU - 1));\n+  char *s = buf;\n+  while (*s)\n+    ++s;\n+  insert_features_names(s  , buf + sizeof(buf) - s, glibc_features_missing & (MAX_GLIBC - 1));\n+  while (*s)\n+    ++s;\n+  \/* +1 to skip the first ','. *\/\n+  tty->print_raw(buf + 1, s - (buf + 1));\n+  tty->cr();\n+  static const char line2[] = \"If you are sure it will not crash you can override this check by -XX:+UnlockExperimentalVMOptions -XX:+IgnoreCPUFeatures .\";\n+  tty->print_raw(line2, sizeof(line2) - 1);\n+  tty->cr();\n+}\n+\n+void VM_Version::crac_restore() {\n+  assert(CRaCCheckpointTo != NULL, \"\");\n+\n+  if (ShowCPUFeatures) {\n+    static const char prefix[] = \"This snapshot's stored CPU features are: -XX:CPUFeatures=\";\n+    tty->print_raw(prefix, sizeof(prefix) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    tty->cr();\n+  }\n+\n+  VM_Version::CpuidInfo cpuid_info = { 0, };\n+  get_cpu_info_stub(&cpuid_info);\n+  cpuid_info.assert_is_initialized();\n+\n+  uint64_t       new_cpu_features = 0;\n+  uint64_t new_cpu_glibc_features = 0;\n+  if (cpuid_info.extended_cpu_family() > 4) { \/\/ it supports CPUID\n+    new_cpu_features = cpuid_info.feature_flags();\n+    LINUX_ONLY(new_cpu_glibc_features = cpuid_info.glibc_flags();)\n+  }\n+\n+  uint64_t       features_missing =       _features & ~      new_cpu_features;\n+  uint64_t glibc_features_missing = _glibc_features & ~new_cpu_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  _crac_restore_missing_features = features_missing || glibc_features_missing;\n+  if (_crac_restore_missing_features) {\n+    static const char part1[] = \"You have to specify -XX:CPUFeatures=\";\n+    tty->print_raw(part1, sizeof(part1) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(new_cpu_features & _features, new_cpu_glibc_features & _glibc_features);\n+    static const char part2[] = \" together with -XX:CRaCCheckpointTo when making a checkpoint file; specified -XX:CRaCRestoreFrom file contains CPU features \";\n+    tty->print_raw(part2, sizeof(part2) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    missing_features(features_missing, glibc_features_missing);\n+  }\n+\n+  if (ShowCPUFeatures)\n+    print_using_features_cr();\n+}\n+\n+void VM_Version::crac_restore_finalize() {\n+  if (_crac_restore_missing_features && !IgnoreCPUFeatures) {\n+    vm_exit_during_initialization();\n+  }\n+}\n+\n@@ -2203,1 +2716,47 @@\n-  get_processor_features();\n+  assert(      _features == 0,       \"_features should be zero at startup\");\n+  assert(_glibc_features == 0, \"_glibc_features should be zero at startup\");\n+  get_processor_features_hardware();\n+\n+  assert(!CPUFeatures == FLAG_IS_DEFAULT(CPUFeatures), \"CPUFeatures parsing\");\n+  uint64_t GLIBCFeatures_x64;\n+  uint64_t   CPUFeatures_x64 = CPUFeatures_parse(GLIBCFeatures_x64);\n+  uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+  uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n+\n+  \/\/ Workaround JDK-8311164: CPU_HT is set randomly on hybrid CPUs like Alder Lake.\n+  features_missing &= ~CPU_HT;\n+\n+  if (features_missing || glibc_features_missing) {\n+    static const char part1[] = \"Specified -XX:CPUFeatures=\";\n+    tty->print_raw(part1, sizeof(part1) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(CPUFeatures_x64, GLIBCFeatures_x64);\n+    static const char part2[] = \"; this machine's CPU features are \";\n+    tty->print_raw(part2, sizeof(part2) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n+    missing_features(features_missing, glibc_features_missing);\n+    vm_exit_during_initialization();\n+  }\n+\n+  uint64_t       features_saved =       _features;\n+  uint64_t glibc_features_saved = _glibc_features;\n+\n+        _features =   CPUFeatures_x64;\n+  _glibc_features = GLIBCFeatures_x64;\n+\n+  if (ShowCPUFeatures)\n+    print_using_features_cr();\n+\n+#ifdef LINUX\n+  if (!_ignore_glibc_not_using) {\n+    uint64_t       features_expected =   MAX_CPU - 1;\n+    uint64_t glibc_features_expected = MAX_GLIBC - 1;\n+    if (!INCLUDE_CPU_FEATURE_ACTIVE) {\n+            features_expected =       features_saved;\n+      glibc_features_expected = glibc_features_saved;\n+    }\n+    glibc_not_using(      features_expected & ~      _features,\n+                    glibc_features_expected & ~_glibc_features);\n+  }\n+#endif\n+\n+  get_processor_features_hotspot();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":565,"deletions":6,"binary":false,"changes":571,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -86,1 +87,2 @@\n-                        : 2,\n+                        : 1,\n+               movbe    : 1,\n@@ -90,1 +92,1 @@\n-                        : 1,\n+               xsave    : 1,\n@@ -157,1 +159,3 @@\n-                            : 23;\n+                            : 7,\n+               fma4         : 1,\n+                            : 15;\n@@ -428,0 +432,1 @@\n+    MAX_CPU = CPU_SHA512 << 1\n@@ -430,0 +435,23 @@\n+  \/* Tracking of a CPU feature for glibc *\/ \\\n+  enum Glibc_Feature_Flag : uint64_t {\n+#define GLIBC_FEATURE_FLAGS(decl) \\\n+    decl(FMA4,              \"fma4\",               0) \\\n+    decl(MOVBE,             \"movbe\",              1) \\\n+    decl(OSXSAVE,           \"osxsave\",            2) \\\n+    decl(IBT,               \"ibt\",                3) \\\n+    decl(SHSTK,             \"shstk\",              4) \/* Also known as cet_ss *\/ \\\n+    decl(XSAVE,             \"xsave\",              5) \\\n+    decl(CMPXCHG16,         \"cmpxchg16\",          6) \/* Also known in cpuinfo as cx16 and in glibc as cmpxchg16b *\/ \\\n+    decl(LAHFSAHF,          \"lahfsahf\",           7) \/* Also known in cpuinfo as lahf_lm and in glibc as lahf64_sahf64 *\/ \\\n+    decl(F16C,              \"f16c\",               8) \\\n+    decl(HTT,               \"htt\",                9) \/* hotspot calls it 'ht' but it is affected by threads_per_core() *\/\n+\n+#define DECLARE_GLIBC_FEATURE_FLAG(id, name, bit) GLIBC_##id = (1ULL << bit),\n+    GLIBC_FEATURE_FLAGS(DECLARE_GLIBC_FEATURE_FLAG)\n+#undef DECLARE_GLIBC_FEATURE_FLAG\n+    MAX_GLIBC = GLIBC_HTT << 1\n+  };\n+\n+  \/\/ glibc feature flags.\n+  static uint64_t _glibc_features;\n+\n@@ -431,0 +459,1 @@\n+  static const char* _glibc_features_names[];\n@@ -568,0 +597,23 @@\n+#ifdef LINUX\n+    uint64_t glibc_flags() const {\n+      uint64_t result = 0;\n+      if (std_cpuid1_ecx.bits.movbe != 0)\n+        result |= GLIBC_MOVBE;\n+      if (std_cpuid1_ecx.bits.osxsave != 0)\n+        result |= GLIBC_OSXSAVE;\n+      if (std_cpuid1_ecx.bits.xsave != 0)\n+        result |= GLIBC_XSAVE;\n+      if (std_cpuid1_ecx.bits.cmpxchg16 != 0)\n+        result |= GLIBC_CMPXCHG16;\n+      if (std_cpuid1_ecx.bits.f16c != 0)\n+        result |= GLIBC_F16C;\n+      if (ext_cpuid1_ecx.bits.fma4 != 0)\n+        result |= GLIBC_FMA4;\n+      if (ext_cpuid1_ecx.bits.LahfSahf != 0)\n+        result |= GLIBC_LAHFSAHF;\n+      if (std_cpuid1_edx.bits.ht != 0)\n+        result |= GLIBC_HTT;\n+      return result;\n+    }\n+#endif \/\/LINUX\n+\n@@ -604,0 +656,20 @@\n+  static void get_processor_features_hardware();\n+  static void get_processor_features_hotspot();\n+\n+  static uint64_t CPUFeatures_parse(uint64_t &glibc_features);\n+#ifdef LINUX\n+  static void glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC);\n+  static bool glibc_env_set(char *disable_str);\n+  \/*[[noreturn]]*\/ static void glibc_reexec();\n+  \/\/ C++17: Make glibc_prefix and glibc_prefix_len constexpr.\n+  static const char glibc_prefix[];\n+  static const size_t glibc_prefix_len;\n+#endif \/\/LINUX\n+  \/\/ C++17: Make _ignore_glibc_not_using inline.\n+  static bool _ignore_glibc_not_using;\n+  static bool _crac_restore_missing_features;\n+  static void nonlibc_tty_print_uint64(uint64_t num);\n+  static void nonlibc_tty_print_uint64_comma_uint64(uint64_t num1, uint64_t num2);\n+  static void print_using_features_cr();\n+  \/*[[noreturn]]*\/ static void missing_features(uint64_t features_missing, uint64_t glibc_features_missing);\n+\n@@ -651,0 +723,7 @@\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _features_names, features);\n+  }\n+  static void insert_glibc_features_names(char* buf, size_t buflen, uint64_t glibc_features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _glibc_features_names, glibc_features);\n+  }\n+\n@@ -653,0 +732,2 @@\n+  static void crac_restore();\n+  static void crac_restore_finalize();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":84,"deletions":3,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2017, 2022, Azul Systems, Inc. All rights reserved.\n@@ -26,0 +27,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -68,0 +70,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -87,0 +90,1 @@\n+# include <arpa\/inet.h>\n@@ -91,1 +95,0 @@\n-# include <sys\/stat.h>\n@@ -94,0 +97,1 @@\n+# include <sys\/sysmacros.h>\n@@ -111,1 +115,0 @@\n-# include <fcntl.h>\n@@ -120,0 +123,1 @@\n+# include <libgen.h>\n@@ -519,0 +523,5 @@\n+void os::Linux::initialize_processor_count() {\n+  set_processor_count((int) sysconf(_SC_NPROCESSORS_CONF));\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n@@ -520,1 +529,1 @@\n-  set_processor_count((int)sysconf(_SC_NPROCESSORS_CONF));\n+  initialize_processor_count();\n@@ -533,1 +542,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -60,0 +61,1 @@\n+  static void initialize_processor_count();\n@@ -292,0 +294,7 @@\n+  static void initialize_cpu_count() {\n+    initialize_processor_count();\n+    if (cpu_to_node() != NULL) {\n+      rebuild_cpu_to_node_map();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -44,4 +47,0 @@\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(sockaddr_un::sun_path)\n-#endif\n-\n@@ -64,93 +63,0 @@\n-\/\/ forward reference\n-class PosixAttachOperation;\n-\n-class PosixAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n- public:\n-  static void set_path(char* path) {\n-    if (path == nullptr) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  static PosixAttachOperation* dequeue();\n-};\n-\n-class SocketChannel : public AttachOperation::RequestReader, public AttachOperation::ReplyWriter {\n-private:\n-  int _socket;\n-public:\n-  SocketChannel(int socket) : _socket(socket) {}\n-  ~SocketChannel() {\n-    close();\n-  }\n-\n-  bool opened() const {\n-    return _socket != -1;\n-  }\n-\n-  void close() {\n-    if (opened()) {\n-      ::close(_socket);\n-      _socket = -1;\n-    }\n-  }\n-\n-  \/\/ RequestReader\n-  int read(void* buffer, int size) override {\n-    ssize_t n;\n-    RESTARTABLE(::read(_socket, buffer, (size_t)size), n);\n-    return checked_cast<int>(n);\n-  }\n-\n-  \/\/ ReplyWriter\n-  int write(const void* buffer, int size) override {\n-    ssize_t n;\n-    RESTARTABLE(::write(_socket, buffer, size), n);\n-    return checked_cast<int>(n);\n-  }\n-  \/\/ called after writing all data\n-  void flush() override {\n-    ::shutdown(_socket, SHUT_RDWR);\n-  }\n-};\n-\n-class PosixAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  SocketChannel _socket_channel;\n-\n- public:\n-  void complete(jint res, bufferedStream* st) override;\n-\n-  PosixAttachOperation(int socket) : AttachOperation(), _socket_channel(socket) {\n-  }\n-\n-  bool read_request() {\n-    return AttachOperation::read_request(&_socket_channel, &_socket_channel);\n-  }\n-};\n-\n@@ -162,0 +68,1 @@\n+PosixAttachOperation* PosixAttachListener::_current_op = nullptr;\n@@ -307,0 +214,1 @@\n+      _current_op = op;\n@@ -312,0 +220,12 @@\n+\/\/ An operation completion is splitted into two parts.\n+\/\/ For proper handling the jcmd connection at CRaC checkpoint action.\n+\/\/ An effectively_complete_raw is called in checkpoint processing, before criu engine calls, for properly closing the socket.\n+\/\/ The complete() gets called after restore for proper deletion the leftover object.\n+\n+void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n+  PosixAttachOperation::effectively_complete_raw(result, st);\n+  \/\/ reset the current op as late as possible, this happens on attach listener thread.\n+  PosixAttachListener::reset_current_op();\n+  delete this;\n+}\n+\n@@ -320,3 +240,6 @@\n-void PosixAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n+void PosixAttachOperation::effectively_complete_raw(jint result, bufferedStream* st) {\n+\n+  if (_effectively_completed) {\n+    assert(st->size() == 0, \"no lost output\");\n+    return;\n+  }\n@@ -324,0 +247,12 @@\n+  \/\/ write operation result\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    ThreadBlockInVM tbivm(JavaThread::cast(thread));\n+    write_operation_result(result, st);\n+  } else {\n+    write_operation_result(result, st);\n+  }\n+  _effectively_completed = true;\n+}\n+\n+void PosixAttachOperation::write_operation_result(jint result, bufferedStream* st) {\n@@ -326,1 +261,2 @@\n-  delete this;\n+  _socket_channel.close();\n+  st->reset();\n@@ -329,0 +265,16 @@\n+static void assert_listener_thread() {\n+#ifdef ASSERT\n+  ResourceMark rm; \/\/ For retrieving the thread names\n+  assert(strcmp(\"Attach Listener\", Thread::current()->name()) == 0, \"should gets called from Attach Listener thread\");\n+#endif\n+}\n+\n+PosixAttachOperation* PosixAttachListener::get_current_op() {\n+  assert_listener_thread();\n+  return PosixAttachListener::_current_op;\n+}\n+\n+void PosixAttachListener::reset_current_op() {\n+  assert_listener_thread();\n+  PosixAttachListener::_current_op = NULL;\n+}\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":53,"deletions":101,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -100,0 +101,1 @@\n+static jlong restore_time_count = 0;\n@@ -875,0 +877,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -897,0 +903,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1317,0 +1331,4 @@\n+  initialize_time_counters();\n+}\n+\n+void os::Posix::initialize_time_counters(void) {\n@@ -1318,0 +1336,5 @@\n+  restore_time_count = initial_time_count;\n+}\n+\n+void os::Posix::reset_time_counters(void) {\n+  restore_time_count = javaTimeNanos();\n@@ -1471,1 +1494,1 @@\n-  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec);\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + crac::monotonic_time_offset();\n@@ -1500,0 +1523,4 @@\n+jlong os::elapsed_counter_since_restore() {\n+  return os::javaTimeNanos() - restore_time_count;\n+}\n+\n@@ -2024,0 +2051,4 @@\n+int os::execv(const char *path, const char *argv[]) {\n+  return ::execv(path, (char * const *)argv);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -33,0 +34,1 @@\n+\/\/#include \"os_linux.inline.hpp\"\n@@ -43,0 +45,4 @@\n+#ifdef LINUX\n+#include \"perfMemory_linux.hpp\"\n+#endif \/\/LINUX\n+\n@@ -1341,0 +1347,83 @@\n+\n+#ifdef LINUX\n+bool PerfMemoryLinux::checkpoint() {\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  void *anon = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (anon == MAP_FAILED) {\n+    tty->print_cr(\"Cannot allocate new memory for perfdata: %s\", os::strerror(errno));\n+    return false;\n+  }\n+  \/\/ Note: we might be losing updates that happen between this copy and mremap\n+  \/\/ TODO: consider acquiring PeriodicTask_lock around this\n+  memcpy(anon, PerfMemory::start(), PerfMemory::used());\n+  if (mremap(anon, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap perfdata memory as anonymous: %s\", os::strerror(errno));\n+    if (munmap(anon, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap unused private perfdata memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  remove_file(backing_store_file_name);\n+  \/\/ We cannot keep the filename because some C\/R engines might not preserve PID numbers\n+  \/\/ Also, username might change.\n+  FREE_C_HEAP_ARRAY(char, backing_store_file_name);\n+  backing_store_file_name = nullptr;\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::restore() {\n+  assert(backing_store_file_name == nullptr, \"Should be nil'ed on checkpoint\");\n+  \/\/ With -XX:-UsePerfData the capacity is zero\n+  if (PerfDisableSharedMem || PerfMemory::capacity() == 0) {\n+    return true;\n+  }\n+  int vmid = os::current_process_id();\n+  char* user_name = get_user_name(geteuid());\n+  if (!user_name) {\n+    return false;\n+  }\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  if (!make_user_tmp_dir(dirname)) {\n+    return false;\n+  }\n+  backing_store_file_name = get_sharedmem_filename(dirname, vmid, -1);\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"Cannot open shared perfdata file: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  if (::ftruncate(fd, PerfMemory::capacity())) {\n+    tty->print_cr(\"Cannot restore (ftruncate) perfdata file size: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  void* shared = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == shared) {\n+    tty->print_cr(\"cannot mmap shared perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+  ::close(fd);\n+\n+  \/\/ Here is another place where we might lose the update\n+  memcpy(shared, PerfMemory::start(), PerfMemory::used());\n+  if (::mremap(shared, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap shared perfdata: %s\", os::strerror(errno));\n+    if (munmap(shared, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap the shared memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  return true;\n+}\n+#endif \/\/LINUX\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n@@ -1540,0 +1540,15 @@\n+\n+  sigemptyset(&blocked_sigs);\n+\/\/ RESTORE_SIGNAL is used only on Linux, other platform don't send this\n+#ifdef LINUX\n+  \/\/ The signal is used with default crexec library, other CRaCEngines might use\n+  \/\/ signals in a different way and having this signal blocked could interfere.\n+  const char *signal_engines[] = { \"criu\", \"criuengine\", \"sim\", \"simengine\", \"pause\", \"pauseengine\", NULL };\n+  for (int i = 0; signal_engines[i] != NULL; ++i) {\n+    if (strcmp(CRaCEngine, signal_engines[i]) == 0) {\n+      sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+      break;\n+    }\n+  }\n+#endif\n+\n@@ -1550,0 +1565,5 @@\n+static sigset_t* blocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &blocked_sigs;\n+}\n+\n@@ -1567,0 +1587,1 @@\n+  pthread_sigmask(SIG_BLOCK, blocked_signals(), nullptr);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvm.h\"\n+#include \"runtime\/crac_structs.hpp\"\n+\n+void crac::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  return true;\n+}\n+\n+void crac::reset_time_counters() {\n+  os::win32::reset_performance_counters();\n+}\n","filename":"src\/hotspot\/os\/windows\/crac_windows.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -825,0 +826,1 @@\n+static jlong restore_performance_count;\n@@ -832,1 +834,0 @@\n-\n@@ -837,0 +838,5 @@\n+jlong os::elapsed_counter_since_restore() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceCounter(&count);\n+  return count.QuadPart - restore_performance_count;\n+}\n@@ -1116,0 +1122,1 @@\n+  restore_performance_count = initial_performance_count;\n@@ -1118,0 +1125,9 @@\n+void os::win32::reset_performance_counters() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceFrequency(&count);\n+  \/\/ Until we perform a real C\/R on Windows this is safe, performance frequency\n+  \/\/ should be the same. With real C\/R the counters will be probably incomparable.\n+  assert(performance_frequency == count.QuadPart, \"Performance frequency changed\");\n+  QueryPerformanceCounter(&count);\n+  restore_performance_count = count.QuadPart;\n+}\n@@ -1557,0 +1573,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -4683,0 +4726,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5686,0 +5754,4 @@\n+int os::execv(const char *path, const char *argv[]) {\n+  return _execv(path, argv);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -402,0 +402,9 @@\n+  \/\/ VM_Version::crac_restore()->VM_Version::get_processor_features_hardware()\n+  \/\/ executes cpuinfo without a started Java thread.\n+  if (info != nullptr && uc != nullptr && thread == nullptr && sig == SIGSEGV) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n+      stub = VM_Version::cpuinfo_cont_addr();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -222,0 +222,9 @@\n+  \/\/ VM_Version::crac_restore()->VM_Version::get_processor_features_hardware()\n+  \/\/ executes cpuinfo without a started Java thread.\n+  if (info != nullptr && uc != nullptr && thread == nullptr && sig == SIGSEGV) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n+      stub = VM_Version::cpuinfo_cont_addr();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -823,0 +823,20 @@\n+GrowableArray<int> ClassLoader::get_classpath_entry_fds() {\n+  GrowableArray<int> fds;\n+  assert(Thread::current()->is_VM_thread(), \"should be called from VM op\");\n+  \/\/ we don't use mutexes here because it is called from VM op\n+  for (ClassPathEntry *entry = first_append_entry(); entry != nullptr; entry = entry->next()) {\n+    if (entry->is_jar_file()) {\n+      fds.append(((ClassPathZipEntry *) entry)->get_fd());\n+    }\n+  }\n+#if INCLUDE_CDS\n+  \/\/ Probably not needed as _app_classpath_entries is filled only when dumping CDS classes\n+  for (ClassPathEntry *entry = _app_classpath_entries; entry != nullptr; entry = entry->next()) {\n+    if (entry->is_jar_file()) {\n+      fds.append(((ClassPathZipEntry *) entry)->get_fd());\n+    }\n+  }\n+#endif \/\/ INCLUDE_CDS\n+  return fds;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -741,0 +741,4 @@\n+  template(jdk_internal_crac_mirror_Core,          \"jdk\/internal\/crac\/mirror\/Core\")                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+  template(checkpointRestoreInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,0 +194,21 @@\n+void CompileLog::before_checkpoint() {\n+  \/\/ Remove only output stream, don't destroy the CompileLog itself.\n+  delete _out;\n+  _out = NULL;\n+  unlink(_file); \/\/ like in CompileLog dtor\n+  \/\/ _file_end: do not touch, mark_file_end calculates it based on the actual file size.\n+}\n+\n+void CompileLog::after_restore() {\n+  FILE* fp = os::fopen(_file, \"wt\");\n+  _out = new(mtCompiler) fileStream(fp, true);\n+}\n+\n+void CompileLog::swap_streams_on_restore() {\n+  CompileLog* log = _first;\n+  while (log != nullptr) {\n+    log->after_restore();\n+    log = log->_next;\n+  }\n+}\n+\n@@ -307,0 +328,40 @@\n+void CompileLog::finish_log_on_checkpoint(outputStream* file) {\n+  char buf[4 * K];\n+  int buflen = sizeof(buf);\n+  CompileLog* log = _first;\n+  file->print_raw(\"<compilation_log closed at a checkpoint >\");\n+\n+  while (log != nullptr) {\n+    log->flush();\n+    const char* partial_file = log->file();\n+    int partial_fd = open(partial_file, O_RDONLY);\n+    if (partial_fd != -1) {\n+      \/\/ print\/print_cr may need to allocate large stack buffer to format\n+      \/\/ strings, here we use snprintf() and print_raw() instead.\n+      file->print_raw(\"<compilation_log thread='\");\n+      jio_snprintf(buf, buflen, \"%zu\", log->thread_id());\n+      file->print_raw(buf);\n+      file->print_raw_cr(\"'>\");\n+\n+      size_t nr; \/\/ number read into buf from partial log\n+      \/\/ In case of unsuccessful completion, read returns -1.\n+      ssize_t bytes_read;\n+      \/\/ Copy data up to the end of the last <event> element:\n+      julong to_read = log->_file_end;\n+      while (to_read > 0) {\n+        if (to_read < (julong)buflen)\n+              nr = (size_t)to_read;\n+        else  nr = buflen;\n+        bytes_read = ::read(partial_fd, buf, (int)nr);\n+        if (bytes_read <= 0) break;\n+        nr = bytes_read;\n+        to_read -= (julong)nr;\n+        file->write(buf, nr);\n+      }\n+      ::close(partial_fd);\n+    }\n+    log->before_checkpoint();\n+    log = log->_next;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compileLog.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"gc\/g1\/g1UncommitRegionTask.hpp\"\n@@ -1032,0 +1033,4 @@\n+  virtual void finish_collection() override {\n+    G1UncommitRegionTask::finish_collection();\n+  }\n+\n@@ -1326,0 +1331,4 @@\n+\n+  void after_restore(void) override {\n+    _hrm.after_restore();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -69,1 +69,3 @@\n-  _regions(), _heap_mapper(nullptr),\n+  _regions(),\n+  _max_available_regions(0),\n+  _heap_mapper(nullptr),\n@@ -88,0 +90,2 @@\n+  _max_available_regions = (uint) (CRaCMaxHeapSizeBeforeCheckpoint == 0 ? _regions.length() :\n+    CRaCMaxHeapSizeBeforeCheckpoint \/ G1HeapRegion::GrainBytes);\n@@ -92,0 +96,4 @@\n+void G1HeapRegionManager::after_restore() {\n+  _max_available_regions = (uint) _regions.length();\n+}\n+\n@@ -133,1 +141,3 @@\n-  expand_exact(candidate, num_regions, G1CollectedHeap::heap()->workers());\n+  if (!expand_exact(candidate, num_regions, G1CollectedHeap::heap()->workers())) {\n+    return nullptr;\n+  }\n@@ -164,0 +174,4 @@\n+  assert(_committed_map.num_active() + _committed_map.num_inactive() + num_regions <= _max_available_regions,\n+    \"Expanding over the limit: %d active, %d inactive, %d requested, limit %d\",\n+    _committed_map.num_active(), _committed_map.num_inactive(), num_regions, _max_available_regions);\n+\n@@ -342,2 +356,5 @@\n-    uint to_expand = MIN2(num_regions - expanded, regions.length());\n-    expand(regions.start(), to_expand, pretouch_workers);\n+    uint to_expand = MIN3(num_regions - expanded, regions.length(),\n+      _max_available_regions - _committed_map.num_active() - _committed_map.num_inactive());\n+    if (to_expand > 0) {\n+      expand(regions.start(), to_expand, pretouch_workers);\n+    }\n@@ -367,1 +384,1 @@\n-void G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n+bool G1HeapRegionManager::expand_exact(uint start, uint num_regions, WorkerThreads* pretouch_workers) {\n@@ -386,0 +403,6 @@\n+      \/\/ Fail if we're over the limits (were not able to just reactivate)\n+      if (_committed_map.num_active() + _committed_map.num_inactive() + (i - start) + 1 > _max_available_regions) {\n+        log_debug(gc)(\"Cannot expand to regions %u - %u: active %u, inactive %u, max %u\", start, end,\n+         _committed_map.num_active(),  _committed_map.num_inactive(), _max_available_regions);\n+        return false;\n+      }\n@@ -393,0 +416,1 @@\n+  return true;\n@@ -399,4 +423,12 @@\n-    for (uint i = 0; i < reserved_length(); i++) {\n-      if (is_available(i)) {\n-        \/\/ Already in use continue\n-        continue;\n+    if (_committed_map.num_active() + _committed_map.num_inactive() >= _max_available_regions) {\n+      \/\/ We have to use existing inactive region, cannot allocate new one\n+      \/\/ while we have inactive.\n+      for (uint i = 0; i < reserved_length(); i++) {\n+        if (!_committed_map.inactive(i)) {\n+          continue;\n+        }\n+        expand_candidate = i;\n+        if (is_on_preferred_index(expand_candidate, preferred_index)) {\n+          \/\/ We have found a candidate on the preferred node, break.\n+          break;\n+        }\n@@ -404,5 +436,13 @@\n-      \/\/ Always save the candidate so we can expand later on.\n-      expand_candidate = i;\n-      if (is_on_preferred_index(expand_candidate, preferred_index)) {\n-        \/\/ We have found a candidate on the preferred node, break.\n-        break;\n+    }\n+    if (expand_candidate == UINT_MAX) {\n+      for (uint i = 0; i < reserved_length(); i++) {\n+        if (is_available(i)) {\n+          \/\/ Already in use continue\n+          continue;\n+        }\n+        \/\/ Always save the candidate so we can expand later on.\n+        expand_candidate = i;\n+        if (is_on_preferred_index(expand_candidate, preferred_index)) {\n+          \/\/ We have found a candidate on the preferred node, break.\n+          break;\n+        }\n@@ -415,0 +455,1 @@\n+    log_debug(gc)(\"No regions left\");\n@@ -417,0 +458,1 @@\n+  log_debug(gc)(\"Candidate is %u\", expand_candidate);\n@@ -418,2 +460,1 @@\n-  expand_exact(expand_candidate, 1, nullptr);\n-  return 1;\n+  return expand_exact(expand_candidate, 1, nullptr) ? 1 : 0;\n@@ -541,1 +582,3 @@\n-      expand_exact(curr_index, 1, pretouch_workers);\n+      if (!expand_exact(curr_index, 1, pretouch_workers)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -255,0 +255,7 @@\n+  \/\/ Handle do_cleanup_unused here to print correct capacity below.\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    \/\/ HeapRegionManager::shrink_by do not allow remove all regions.\n+    \/\/ Make sure at least one is there.\n+    maximum_desired_capacity = G1HeapRegion::GrainBytes;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -135,0 +135,8 @@\n+\n+void G1UncommitRegionTask::finish_collection() {\n+  \/\/ If _instance is NULL G1 GC is either not in use or its collection has not yet been executed.\n+  if (_instance) {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    g1h->uncommit_regions((uint)-1);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1UncommitRegionTask.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -990,0 +991,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1144,0 +1152,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -418,0 +419,6 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), (char*)eden()->end() - (char*)eden()->top());\n+    os::cleanup_memory((char*)from()->top(), (char*)from()->end() - (char*)from()->top());\n+    os::cleanup_memory((char*)to()->top(), (char*)to()->end() - (char*)to()->top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -120,0 +120,2 @@\n+  bool _cleanup_unused;\n+\n@@ -378,0 +380,6 @@\n+  void set_cleanup_unused(bool value) { _cleanup_unused = value; }\n+  bool do_cleanup_unused() const { return _cleanup_unused; }\n+\n+  \/\/ G1UncommitRegionTask may be still pending after collect() has returned.\n+  virtual void finish_collection() {}\n+\n@@ -519,0 +527,2 @@\n+\n+  virtual void after_restore(void) {}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -97,0 +97,2 @@\n+  assert(CRaCMaxHeapSizeBeforeCheckpoint == 0 || CRaCMaxHeapSizeBeforeCheckpoint >= InitialHeapSize, \"Incompatible initial and maximum heap size before checkpoint\");\n+  assert(CRaCMaxHeapSizeBeforeCheckpoint == 0 || CRaCMaxHeapSizeBeforeCheckpoint <= MaxHeapSize, \"Incompatible initial and maximum heap size before checkpoint\");\n@@ -167,0 +169,20 @@\n+  if (FLAG_IS_CMDLINE(CRaCMaxHeapSizeBeforeCheckpoint)) {\n+    if (!UseG1GC) {\n+      vm_exit_during_initialization(\"CRaCMaxHeapSizeBeforeCheckpoint can be used only with G1 garbage collector.\");\n+    }\n+    if (CRaCMaxHeapSizeBeforeCheckpoint < InitialHeapSize) {\n+      if (FLAG_IS_CMDLINE(InitialHeapSize)) {\n+        vm_exit_during_initialization(\"Incompatible initial heap and maximum before checkpoint sizes specified\");\n+      } else {\n+        FLAG_SET_ERGO(InitialHeapSize, CRaCMaxHeapSizeBeforeCheckpoint);\n+      }\n+    }\n+    if (CRaCMaxHeapSizeBeforeCheckpoint > MaxHeapSize) {\n+      if (FLAG_IS_CMDLINE(MaxHeapSize)) {\n+        vm_exit_during_initialization(\"Incompatible heap sizes - maximum before checkpoint and absolute maximum - specified\");\n+      } else {\n+        FLAG_SET_ERGO(MaxHeapSize, CRaCMaxHeapSizeBeforeCheckpoint);\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1060,0 +1060,4 @@\n+\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    _page_allocator->uncommit_unused_memory();\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -913,1 +913,1 @@\n-size_t ZPageAllocator::uncommit(uint64_t* timeout) {\n+size_t ZPageAllocator::uncommit(uint64_t* timeout, uintx delay) {\n@@ -932,1 +932,1 @@\n-    flushed = _cache.flush_for_uncommit(flush, &pages, timeout);\n+    flushed = _cache.flush_for_uncommit(flush, &pages, timeout, delay);\n@@ -1052,0 +1052,15 @@\n+\n+void ZPageAllocator::uncommit_unused_memory() {\n+  uint64_t timeout;\n+  size_t flushed, uncommitted = 0;\n+  do {\n+    flushed = uncommit(&timeout, 0);\n+    uncommitted += flushed;\n+  } while (flushed > 0);\n+  if (uncommitted > 0) {\n+    EventZUncommit event;\n+    log_info(gc, heap)(\"Uncommitted (cleanup): %zuM(%.0f%%)\",\n+      uncommitted \/ M, percent_of(uncommitted, ZHeap::heap()->max_capacity()));\n+    event.commit(uncommitted);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+  uintx          _delay;\n@@ -282,1 +283,1 @@\n-  ZPageCacheFlushForUncommitClosure(size_t requested, uint64_t now, uint64_t* timeout)\n+  ZPageCacheFlushForUncommitClosure(size_t requested, uint64_t now, uint64_t* timeout, uintx delay)\n@@ -285,1 +286,2 @@\n-      _timeout(timeout) {\n+      _timeout(timeout),\n+      _delay(delay) {\n@@ -287,1 +289,1 @@\n-    *_timeout = ZUncommitDelay;\n+    *_timeout = delay;\n@@ -291,1 +293,1 @@\n-    const uint64_t expires = page->last_used() + ZUncommitDelay;\n+    const uint64_t expires = page->last_used() + _delay;\n@@ -309,1 +311,1 @@\n-size_t ZPageCache::flush_for_uncommit(size_t requested, ZList<ZPage>* to, uint64_t* timeout) {\n+size_t ZPageCache::flush_for_uncommit(size_t requested, ZList<ZPage>* to, uint64_t* timeout, uintx delay) {\n@@ -311,1 +313,1 @@\n-  const uint64_t expires = _last_commit + ZUncommitDelay;\n+  const uint64_t expires = _last_commit + delay;\n@@ -320,1 +322,1 @@\n-    *timeout = ZUncommitDelay;\n+    *timeout = delay;\n@@ -324,1 +326,1 @@\n-  ZPageCacheFlushForUncommitClosure cl(requested, now, timeout);\n+  ZPageCacheFlushForUncommitClosure cl(requested, now, timeout, delay);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageCache.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      const size_t flushed = _page_allocator->uncommit(&timeout);\n+      const size_t flushed = _page_allocator->uncommit(&timeout, ZUncommitDelay);\n","filename":"src\/hotspot\/share\/gc\/z\/zUncommitter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1180,0 +1180,15 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"jfr\/jni\/jfrUpcalls.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"jfr\/periodic\/jfrOSInterface.hpp\"\n@@ -36,0 +38,2 @@\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -151,0 +155,26 @@\n+\n+void Jfr::before_checkpoint() {\n+  JfrOSInterface::before_checkpoint();\n+}\n+\n+void Jfr::after_restore() {\n+  const char *jfr_flag = \"StartFlightRecording\";\n+  JVMFlag *flag = JVMFlag::find_flag(jfr_flag);\n+  if (flag->get_origin() == JVMFlagOrigin::CRAC_RESTORE) {\n+    \/\/ -XX:StartFlightRecording passed on restore\n+    assert(JfrOptionSet::start_flight_recording_options() == nullptr, \"should have been released\");\n+    size_t buf_len = 4 + strlen(jfr_flag) + 1 + strlen(flag->get_ccstr()) + 1;\n+    ResourceMark rm;\n+    char *buf = NEW_RESOURCE_ARRAY(char, buf_len);\n+    snprintf(buf, buf_len, \"-XX:%s=%s\", jfr_flag, flag->get_ccstr());\n+    JavaVMOption option;\n+    option.optionString = buf;\n+    option.extraInfo = nullptr;\n+    const JavaVMOption *option_ptr = &option;\n+    JfrOptionSet::parse_start_flight_recording_option(&option_ptr, buf + 4 + strlen(jfr_flag));\n+    \/\/ We cannot invoke this directly now as DCmdStart command would be blocked\n+    \/\/ trying to register new file descriptors. Instead we just record a request and\n+    \/\/ the recording will be started at the right moment from JDKResource.\n+    JfrUpcalls::request_start_after_restore();\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+  static void before_checkpoint();\n+  static void after_restore();\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,0 +432,4 @@\n+\n+JVM_ENTRY_NO_ENV(void, jfr_start_after_restore(JNIEnv* env, jclass jvm))\n+  return JfrRecorder::start_after_restore();\n+JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-      (char*)\"nanosNow\", (char*)\"()J\", (void*)jfr_nanos_now\n+      (char*)\"nanosNow\", (char*)\"()J\", (void*)jfr_nanos_now,\n+      (char*)\"startFlightRecorderAfterRestore\", (char*)\"()V\", (void*)jfr_start_after_restore,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+static Symbol* request_start_after_restore_sym = nullptr;\n+static Symbol* request_start_after_restore_sig_sym = nullptr;\n@@ -62,0 +64,2 @@\n+    request_start_after_restore_sym = SymbolTable::new_permanent_symbol(\"requestStartAfterRestore\");\n+    request_start_after_restore_sig_sym = SymbolTable::new_permanent_symbol(\"()V\");\n@@ -210,0 +214,26 @@\n+\n+void JfrUpcalls::request_start_after_restore() {\n+  JavaThread * const THREAD = JavaThread::current();\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  if (!initialize(THREAD)) {\n+    log_error(jfr, system)(\"JfrUpcall could not be initialized.\");\n+    return;\n+  }\n+  JavaValue result(T_VOID);\n+  const Klass* klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    ResourceMark rm(THREAD);\n+    log_error(jfr, system)(\"JfrUpcall cannot resolve class %s, flight recording won't be started\",\n+      jvm_upcalls_class_sym->as_C_string());\n+    return;\n+  }\n+  assert(klass != nullptr, \"invariant\");\n+  JfrJavaArguments args(&result, klass, request_start_after_restore_sym, request_start_after_restore_sig_sym);\n+  JfrJavaSupport::call_static(&args, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    ResourceMark rm(THREAD);\n+    log_error(jfr, system)(\"JfrUpcall failed for %s\", request_start_after_restore_sym->as_C_string());\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -91,0 +91,8 @@\n+\n+  void before_checkpoint() {\n+    \/\/ SystemProcessInterface::SystemProcesses::ProcessIterator has an open FD\n+    \/\/ to \/proc directory - we need to close this before checkpoint.\n+    \/\/ _system_process_interfaces will be re-created on demand\n+    delete _system_process_interface;\n+    _system_process_interface = nullptr;\n+  }\n@@ -314,0 +322,6 @@\n+\n+void JfrOSInterface::before_checkpoint() {\n+  if (_instance != nullptr && _instance->_impl != nullptr) {\n+    return _instance->_impl->before_checkpoint();\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrOSInterface.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+    case JVMFlagOrigin::CRAC_RESTORE: return \"CRaC restore\";\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -465,0 +465,7 @@\n+\n+void JfrRecorder::start_after_restore() {\n+  JavaThread* const THREAD = JavaThread::current();\n+  validate_recording_options(THREAD);\n+  launch_command_line_recordings(THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"pending exception\");\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  : _flush_sem(0), _lock(), _data_available(false),\n+  : _flush_sem(0), _lock(), _block_async(), _data_available(false),\n@@ -177,0 +177,3 @@\n+\n+    _block_async.lock();\n+    _block_async.unlock();\n@@ -225,0 +228,9 @@\n+void AsyncLogWriter::stop() {\n+  _block_async.lock();\n+  flush();\n+}\n+\n+void AsyncLogWriter::resume() {\n+  _block_async.unlock();\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -163,0 +163,2 @@\n+  \/\/ for asynchronous thread run()\n+  PlatformMonitor _block_async;\n@@ -205,0 +207,2 @@\n+  void stop();\n+  void resume();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,0 +122,4 @@\n+\n+  \/\/ Default log level for 'crac' is Info\n+  precond(!log_is_enabled(Info, crac)); \/\/ If this fails, the below can be removed\n+  LogTagSetMapping<LOG_TAGS(crac)>::tagset().set_output_level(StdoutLog, LogLevel::Info);\n@@ -719,0 +723,22 @@\n+\n+bool LogConfiguration::is_fd_used(int fd) {\n+  assert(fd != -1, \"fd must be valid\");\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    if (fd == _outputs[i]->fd_get()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void LogConfiguration::close() {\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    _outputs[i]->close();\n+  }\n+}\n+\n+void LogConfiguration::reopen() {\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    _outputs[i]->reopen();\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -468,0 +468,37 @@\n+\n+int LogFileOutput::fd_get() const {\n+  if (_stream == nullptr) {\n+    return -1;\n+  }\n+  return LogFileStreamOutput::fd_get();\n+}\n+\n+void LogFileOutput::close() {\n+  if (_stream == nullptr) {\n+    return;\n+  }\n+  if (fclose(_stream)) {\n+    jio_fprintf(defaultStream::error_stream(), \"Error closing log file '%s' (%s).\\n\",\n+                _file_name, os::strerror(errno));\n+  }\n+  _stream = nullptr;\n+}\n+\n+void LogFileOutput::reopen() {\n+  assert(_stream == nullptr, \"reopening an already opened log file\");\n+\n+  \/\/ Open the active log file using the same stream as before\n+  jlong the_time = os::javaTimeMillis();\n+  LogFileOutput::set_file_name_parameters(the_time);\n+  FREE_C_HEAP_ARRAY(char, _file_name);\n+  _file_name = make_file_name(_name + strlen(Prefix), _pid_str, _vm_start_time_str);\n+  _stream = os::fopen(_file_name, FileOpenMode);\n+  if (_stream == nullptr) {\n+    jio_fprintf(defaultStream::error_stream(), \"Could not reopen log file '%s' (%s).\\n\",\n+                _file_name, os::strerror(errno));\n+    return;\n+  }\n+\n+  \/\/ _current_size still keeps how much data we wrote for the rotation purposes.\n+  \/\/ The log file may contain more data now.\n+}\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"runtime\/crac.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3683,0 +3684,5 @@\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -843,0 +843,8 @@\n+    case EXT_EVENT_CRAC_BEFORE_CHECKPOINT :\n+      ext_callbacks->CracBeforeCheckpoint = callback;\n+      env->env_event_enable()->set_user_enabled(event_type, enabling);\n+      break;\n+    case EXT_EVENT_CRAC_AFTER_RESTORE :\n+      ext_callbacks->CracAfterRestore = callback;\n+      env->env_event_enable()->set_user_enabled(event_type, enabling);\n+      break;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+  EXT_EVENT_CRAC_AFTER_RESTORE = JVMTI_MIN_EVENT_TYPE_VAL-5,\n+  EXT_EVENT_CRAC_BEFORE_CHECKPOINT = JVMTI_MIN_EVENT_TYPE_VAL-4,\n@@ -50,1 +52,1 @@\n-  EXT_MIN_EVENT_TYPE_VAL = EXT_EVENT_VIRTUAL_THREAD_UNMOUNT,\n+  EXT_MIN_EVENT_TYPE_VAL = EXT_EVENT_CRAC_AFTER_RESTORE,\n@@ -58,0 +60,2 @@\n+  jvmtiExtensionEvent CracBeforeCheckpoint;\n+  jvmtiExtensionEvent CracAfterRestore;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3237,0 +3237,36 @@\n+\n+void JvmtiExport::post_crac_before_checkpoint() {\n+  JavaThread *thread = JavaThread::current();\n+  HandleMark hm(thread);\n+  EVT_TRIG_TRACE(EXT_EVENT_CRAC_BEFORE_CHECKPOINT, (\"Trg CRaC Before Checkpoint event triggered\"));\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n+    if (env->is_enabled((jvmtiEvent)EXT_EVENT_CRAC_BEFORE_CHECKPOINT)) {\n+      EVT_TRACE(EXT_EVENT_CRAC_BEFORE_CHECKPOINT, (\"[?] Evt Before Checkpoint sent\"));\n+      JvmtiEventMark jem(thread);\n+      JvmtiJavaThreadEventTransition jet(thread);\n+      jvmtiExtensionEvent callback = env->ext_callbacks()->CracBeforeCheckpoint;\n+      if (callback != nullptr) {\n+        (*callback)(env->jvmti_external());\n+      }\n+    }\n+  }\n+}\n+\n+void JvmtiExport::post_crac_after_restore() {\n+  JavaThread *thread = JavaThread::current();\n+  HandleMark hm(thread);\n+  EVT_TRIG_TRACE(EXT_EVENT_CRAC_AFTER_RESTORE, (\"Trg CRaC After Restore event triggered\"));\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n+    if (env->is_enabled((jvmtiEvent)EXT_EVENT_CRAC_AFTER_RESTORE)) {\n+      EVT_TRACE(EXT_EVENT_CRAC_AFTER_RESTORE, (\"[?] Evt After Restore sent\"));\n+      JvmtiEventMark jem(thread);\n+      JvmtiJavaThreadEventTransition jet(thread);\n+      jvmtiExtensionEvent callback = env->ext_callbacks()->CracAfterRestore;\n+      if (callback != nullptr) {\n+        (*callback)(env->jvmti_external());\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -241,0 +241,6 @@\n+  static jvmtiParamInfo crac_before_checkpoint_params[] = {\n+    { (char*)\"JNI Environment\", JVMTI_KIND_IN_PTR, JVMTI_TYPE_JNIENV, JNI_FALSE }\n+  };\n+  static jvmtiParamInfo crac_after_restore_params[] = {\n+    { (char*)\"JNI Environment\", JVMTI_KIND_IN_PTR, JVMTI_TYPE_JNIENV, JNI_FALSE }\n+  };\n@@ -263,0 +269,14 @@\n+  static jvmtiExtensionEventInfo crac_before_checkpoint_ext_event = {\n+    EXT_EVENT_CRAC_BEFORE_CHECKPOINT,\n+    (char*)\"jdk.crac.events.BeforeCheckpoint\",\n+    (char*)\"CRAC_BEFORE_CHECKPOINT event\",\n+    sizeof(crac_before_checkpoint_params)\/sizeof(crac_before_checkpoint_params[0]),\n+    crac_before_checkpoint_params\n+  };\n+  static jvmtiExtensionEventInfo crac_after_restore_ext_event = {\n+    EXT_EVENT_CRAC_AFTER_RESTORE,\n+    (char*)\"jdk.crac.events.AfterRestore\",\n+    (char*)\"CRAC_AFTER_RESTORE event\",\n+    sizeof(crac_after_restore_params)\/sizeof(crac_after_restore_params[0]),\n+    crac_after_restore_params\n+  };\n@@ -267,0 +287,2 @@\n+  _ext_events->append(&crac_before_checkpoint_ext_event);\n+  _ext_events->append(&crac_after_restore_ext_event);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -305,2 +305,1 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n-  uint64_t features = _features;\n+void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features) {\n@@ -311,4 +310,10 @@\n-      int res = jio_snprintf(buf, buflen, \", %s\", features_names[features_names_index]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+      \/\/ Do not use any libc string functions. Our caller VM_Version::fatal_missing_features may have GNU_IFUNC-misconfigured glibc.\n+      if (buflen-- > 0)\n+        *buf++ = ',';\n+      if (buflen-- > 0)\n+        *buf++ = ' ';\n+      for (const char *src = features_names[features_names_index]; *src; ++src)\n+      if (buflen-- > 0)\n+        *buf++ = *src;\n+      assert(buflen > 0, \"not enough temporary space allocated\");\n+      *buf = 0;\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2024, Azul Systems, Inc. All rights reserved.\n@@ -53,0 +54,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -78,0 +80,1 @@\n+#include <type_traits>\n@@ -90,0 +93,1 @@\n+char*  Arguments::_java_command_crac            = nullptr;\n@@ -553,0 +557,10 @@\n+  { \"CREngine\",                     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowedOpenFilePrefixes\",    JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowToSkipCheckpoint\",      JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRHeapDumpOnCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPrintResourcesOnCheckpoint\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTraceStartupTime\",           JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRDoThrowCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPauseOnCheckpointError\",     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTrace\",                      JDK_Version::undefined(), JDK_Version::jdk(24), JDK_Version::undefined() },\n+\n@@ -564,0 +578,8 @@\n+  { \"CREngine\",                        \"CRaCEngine\" },\n+  { \"CRAllowedOpenFilePrefixes\",       \"CRaCAllowedOpenFilePrefixes\" },\n+  { \"CRAllowToSkipCheckpoint\",         \"CRaCAllowToSkipCheckpoint \"},\n+  { \"CRHeapDumpOnCheckpointException\", \"CRaCHeapDumpOnCheckpointException\" },\n+  { \"CRPrintResourcesOnCheckpoint\",    \"CRaCPrintResourcesOnCheckpoint\" },\n+  { \"CRTraceStartupTime\",              \"CRaCTraceStartupTime\" },\n+  { \"CRDoThrowCheckpointException\",    \"CRaCDoThrowCheckpointException\" },\n+  { \"CRPauseOnCheckpointError\",        \"CRaCPauseOnCheckpointError\" },\n@@ -1091,0 +1113,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == NULL) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1100,4 +1135,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1105,6 +1137,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == nullptr) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1241,1 +1269,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1243,2 +1273,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1248,1 +1276,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1256,1 +1285,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1258,1 +1287,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1260,0 +1289,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2140,0 +2176,83 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (!match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      continue;\n+    }\n+    \/\/ ccstr is never set to an empty string by the parser so we should not\n+    \/\/ treat an empty string value as the option being set. If it ever becomes\n+    \/\/ ccstrlist or the parser changes, the value check will need to be removed.\n+    static_assert(std::is_same<ccstr, decltype(CRaCRestoreFrom)>(), \"expected ccstr\");\n+    const char* eq = strchr(tail, '=');\n+    if (eq != nullptr && eq[1] != '\\0') {\n+      return true; \/\/ the value is not an empty string\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = NULL;\n+      const char* value = NULL;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.crac_command\") == 0) {\n+        char *old_java_command = _java_command_crac;\n+        _java_command_crac = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != NULL) {\n+          os::free(old_java_command);\n+        }\n+      } else {\n+        add_property(tail);\n+      }\n+\n+      if (key != tail) { \/\/ key was copied\n+        FreeHeap(const_cast<char *>(key));\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != NULL) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n+          return false;\n+        }\n+        build_jvm_flags(tail);\n+      }\n+    }\n+  }\n+\n+  postcond(CRaCRestoreFrom != nullptr);\n+\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -2152,0 +2271,1 @@\n+        !match_option(option, \"-Dsun.java.crac_command\", &tail) &&\n@@ -2960,0 +3080,8 @@\n+  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n+    return JNI_ERR;\n+  }\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n@@ -3971,0 +4099,7 @@\n+\n+void Arguments::reset_for_crac_restore() {\n+  if (!FLAG_IS_DEFAULT(LogVMOutput)){\n+    FLAG_SET_DEFAULT(LogVMOutput, false);\n+    FLAG_SET_DEFAULT(LogFile, nullptr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":151,"deletions":16,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+  static char* _java_command_crac;\n@@ -285,0 +286,4 @@\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n+\n@@ -402,0 +407,1 @@\n+  static const char* java_command_crac()        { return _java_command_crac; }\n@@ -456,0 +462,2 @@\n+  \/\/ Reset LogVMoutput to default values\n+  static void reset_for_crac_restore();\n@@ -521,0 +529,4 @@\n+  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,668 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"classfile\/classLoader.hpp\"\n+#include \"jfr\/jfr.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"prims\/jvmtiExport.hpp\"\n+#include \"runtime\/crac_engine.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/heapDumper.hpp\"\n+#include \"services\/writeableFlags.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/decoder.hpp\"\n+#include \"os.inline.hpp\"\n+#include \"utilities\/defaultStream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+static jlong _restore_start_time;\n+static jlong _restore_start_nanos;\n+\n+CracEngine *crac::_engine = nullptr;\n+char crac::_checkpoint_bootid[UUID_LENGTH];\n+jlong crac::_checkpoint_wallclock_seconds;\n+jlong crac::_checkpoint_wallclock_nanos;\n+jlong crac::_checkpoint_monotonic_nanos;\n+jlong crac::_javaTimeNanos_offset;\n+\n+jlong crac::restore_start_time() {\n+  if (!_restore_start_time) {\n+    return -1;\n+  }\n+  return _restore_start_time;\n+}\n+\n+jlong crac::uptime_since_restore() {\n+  if (!_restore_start_nanos) {\n+    return -1;\n+  }\n+  return os::javaTimeNanos() - _restore_start_nanos;\n+}\n+\n+void VM_Crac::print_resources(const char* msg, ...) {\n+  if (CRaCPrintResourcesOnCheckpoint) {\n+    va_list ap;\n+    va_start(ap, msg);\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    _ostream->vprint(msg, ap);\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+    va_end(ap);\n+  }\n+}\n+\n+#if defined(__APPLE__) || defined(_WINDOWS)\n+static char * strchrnul(char * str, char c) {\n+  for (; *str && c != *str; ++str) {}\n+  return str;\n+}\n+#endif \/\/__APPLE__ || _WINDOWS\n+\n+int crac::checkpoint_restore(int *shmid) {\n+  guarantee(_engine != nullptr, \"CRaC engine is not initialized\");\n+\n+  crac::record_time_before_checkpoint();\n+\n+  \/\/ CRaCCheckpointTo can be changed on restore so we need to update the conf\n+  \/\/ to account for that.\n+  \/\/ Note that CRaCEngine and CRaCEngineOptions are not updated (as documented)\n+  \/\/ so we don't need to re-init the whole engine handle.\n+  if (restore_start_time() != -1 && \/\/ A way to detect we've restored at least once\n+      !_engine->configure_image_location(CRaCCheckpointTo)) {\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  const int ret = _engine->checkpoint();\n+  if (ret != 0) {\n+    log_error(crac)(\"CRaC engine failed to checkpoint to %s: error %i\", CRaCCheckpointTo, ret);\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  switch (_engine->prepare_restore_data_api()) {\n+    case CracEngine::ApiStatus::OK: {\n+      constexpr size_t required_size = sizeof(*shmid);\n+      const size_t available_size = _engine->get_restore_data(shmid, sizeof(*shmid));\n+      if (available_size == 0) { \/\/ Possible if we were not killed by the engine and thus there is no restoring JVM\n+        *shmid = 0; \/\/ Not an error, just no restore data\n+        break;\n+      }\n+      if (available_size == required_size) {\n+        break;\n+      }\n+      if (available_size > required_size) {\n+        log_debug(crac)(\"CRaC engine has more restore data than expected\");\n+        break;\n+      }\n+      log_error(crac)(\"CRaC engine provided not enough restore data: need %zu bytes, got %zu\",\n+                      required_size, available_size);\n+      \/\/ fallthrough\n+    }\n+    case CracEngine::ApiStatus::ERR:         *shmid = -1; break; \/\/ Indicates error to the caller\n+    case CracEngine::ApiStatus::UNSUPPORTED: *shmid = 0;  break; \/\/ Not an error, just no restore data\n+  }\n+\n+#ifdef LINUX\n+  if (CRaCCPUCountInit) {\n+    os::Linux::initialize_cpu_count();\n+  }\n+#endif \/\/LINUX\n+\n+  crac::update_javaTimeNanos_offset();\n+\n+  if (CRaCTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n+  }\n+\n+  return JVM_CHECKPOINT_OK;\n+}\n+\n+bool VM_Crac::read_shm(int shmid) {\n+  precond(shmid > 0);\n+  CracSHM shm(shmid);\n+  int shmfd = shm.open(O_RDONLY);\n+  shm.unlink();\n+  if (shmfd < 0) {\n+    log_error(crac)(\"Cannot read restore parameters\");\n+    return false;\n+  }\n+  bool ret = _restore_parameters.read_from(shmfd);\n+  close(shmfd);\n+  return ret;\n+}\n+\n+bool VM_Crac::is_claimed_fd(int fd) {\n+  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n+  for (int j = 0; j < claimed_fds->length(); ++j) {\n+    jint cfd = claimed_fds->int_at(j);\n+    if (fd == cfd) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+class WakeupClosure: public ThreadClosure {\n+  void do_thread(Thread* thread) {\n+    JavaThread *jt = JavaThread::cast(thread);\n+    jt->wakeup_sleep();\n+    jt->parker()->unpark();\n+    jt->_ParkEvent->unpark();\n+  }\n+};\n+\n+\/\/ It requires Threads_lock to be held so it is being run as a part of VM_Operation.\n+static void wakeup_threads_in_timedwait_vm() {\n+  WakeupClosure wc;\n+  Threads::java_threads_do(&wc);\n+}\n+\n+\/\/ Run it after VM_Operation as it holds Threads_lock which would cause:\n+\/\/ Attempting to acquire lock PeriodicTask_lock\/safepoint out of order with lock Threads_lock\/safepoint-1 -- possible deadlock\n+static void wakeup_threads_in_timedwait() {\n+  MonitorLocker ml(PeriodicTask_lock, Mutex::_safepoint_check_flag);\n+  WatcherThread::watcher_thread()->unpark();\n+}\n+\n+class DefaultStreamHandler {\n+public:\n+  DefaultStreamHandler() {\n+    defaultStream::instance->before_checkpoint();\n+  }\n+\n+  ~DefaultStreamHandler() {\n+    defaultStream::instance->after_restore();\n+  }\n+};\n+\n+void VM_Crac::doit() {\n+  \/\/ dry-run fails checkpoint\n+  bool ok = true;\n+  DefaultStreamHandler defStreamHandler;\n+\n+  Decoder::before_checkpoint();\n+  if (!check_fds()) {\n+    ok = false;\n+  }\n+\n+  if ((!ok || _dry_run) && CRaCHeapDumpOnCheckpointException) {\n+    HeapDumper::dump_heap();\n+  }\n+\n+  if (!ok && CRaCPauseOnCheckpointError) {\n+    os::message_box(\"Checkpoint failed\", \"Errors were found during checkpoint.\");\n+  }\n+\n+  if (!ok && CRaCDoThrowCheckpointException) {\n+    return;\n+  } else if (_dry_run) {\n+    _ok = ok;\n+    return;\n+  }\n+\n+  if (!memory_checkpoint()) {\n+    return;\n+  }\n+\n+  int shmid = -1;\n+  if (CRaCAllowToSkipCheckpoint) {\n+    log_info(crac)(\"Skip Checkpoint\");\n+    shmid = 0;\n+  } else {\n+    log_info(crac)(\"Checkpoint ...\");\n+    report_ok_to_jcmd_if_any();\n+    int ret = crac::checkpoint_restore(&shmid);\n+    if (ret == JVM_CHECKPOINT_ERROR) {\n+      memory_restore();\n+      return;\n+    }\n+  }\n+\n+  \/\/ It needs to check CPU features before any other code (such as VM_Crac::read_shm) depends on them.\n+  VM_Version::crac_restore();\n+  Arguments::reset_for_crac_restore();\n+\n+  if (shmid == 0) { \/\/ E.g. engine does not support restore data\n+    log_debug(crac)(\"Restore parameters (JVM flags, env vars, system properties, arguments...) not provided\");\n+    _restore_start_time = os::javaTimeMillis();\n+    _restore_start_nanos = os::javaTimeNanos();\n+  } else {\n+    if (shmid < 0 || !VM_Crac::read_shm(shmid)) {\n+      vm_direct_exit(1, \"Restore cannot continue, VM will exit.\"); \/\/ More info in logs\n+      ShouldNotReachHere();\n+    }\n+    _restore_start_nanos += crac::monotonic_time_offset();\n+  }\n+\n+  if (CRaCResetStartTime) {\n+    crac::reset_time_counters();\n+  }\n+\n+  \/\/ VM_Crac::read_shm needs to be already called to read RESTORE_SETTABLE parameters.\n+  VM_Version::crac_restore_finalize();\n+\n+  memory_restore();\n+\n+  wakeup_threads_in_timedwait_vm();\n+\n+  _ok = true;\n+}\n+\n+void crac::print_engine_info_and_exit() {\n+  CracEngine engine;\n+  if (!engine.is_initialized()) {\n+    return;\n+  }\n+\n+  const CracEngine::ApiStatus status = engine.prepare_description_api();\n+  if (status == CracEngine::ApiStatus::ERR) {\n+    return;\n+  }\n+  if (status == CracEngine::ApiStatus::UNSUPPORTED) {\n+    tty->print_cr(\"Selected CRaC engine does not provide information about itself\");\n+    vm_exit(0);\n+    ShouldNotReachHere();\n+  }\n+  postcond(status == CracEngine::ApiStatus::OK);\n+\n+  const char *description = engine.description();\n+  if (description == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to provide its textual description\");\n+    return;\n+  }\n+  tty->print_raw_cr(description);\n+\n+  const char *conf_doc = engine.configuration_doc();\n+  if (conf_doc == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to provide documentation of its configuration options\");\n+    return;\n+  }\n+  tty->cr();\n+  tty->print_raw_cr(\"Configuration options:\");\n+  tty->print_raw(conf_doc); \/\/ Doc string ends with CR by convention\n+\n+  const char * const *controlled_opts = CracEngine::vm_controlled_options();\n+  tty->cr();\n+  tty->print_raw(\"Configuration options controlled by the JVM: \");\n+  for (const auto *opt = controlled_opts; *opt != nullptr; opt++) {\n+    tty->print_raw(*opt);\n+    if (*(opt + 1) != nullptr) {\n+      tty->print_raw(\", \");\n+    }\n+  }\n+  tty->cr();\n+\n+  vm_exit(0);\n+  ShouldNotReachHere();\n+}\n+\n+bool crac::prepare_checkpoint() {\n+  precond(CRaCCheckpointTo != nullptr);\n+\n+  struct stat st;\n+  if (0 == os::stat(CRaCCheckpointTo, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      log_error(crac)(\"CRaCCheckpointTo=%s is not a directory\", CRaCCheckpointTo);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == os::mkdir(CRaCCheckpointTo)) {\n+      log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n+      return false;\n+    }\n+    if (-1 == os::rmdir(CRaCCheckpointTo)) {\n+      log_warning(crac)(\"Cannot cleanup after CRaCCheckpointTo check: %s\", os::strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+\n+  \/\/ Initialize CRaC engine now to verify all the related VM options\n+  assert(_engine == nullptr, \"CRaC engine should be initialized only once\");\n+  _engine = new CracEngine(CRaCCheckpointTo);\n+  if (!_engine->is_initialized()) {\n+    delete _engine;\n+    _engine = nullptr;\n+  }\n+  return _engine != nullptr;\n+}\n+\n+static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n+  objArrayHandle bundle(THREAD, bundleObj);\n+  jvalue jval;\n+  jval.i = ret;\n+  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n+  bundle->obj_at_put(0, retObj);\n+  bundle->obj_at_put(1, new_args());\n+  bundle->obj_at_put(2, new_props());\n+  bundle->obj_at_put(3, err_codes());\n+  bundle->obj_at_put(4, err_msgs());\n+  return bundle;\n+}\n+\n+\/** Checkpoint main entry.\n+ *\/\n+Handle crac::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n+  log_debug(crac)(\"Checkpoint %i requested (dry run=%s)\", os::current_process_id(), BOOL_TO_STR(dry_run));\n+\n+  if (CRaCCheckpointTo == nullptr) {\n+    log_error(crac)(\"CRaCCheckpointTo is not specified\");\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+  if (-1 == os::mkdir(CRaCCheckpointTo) && errno != EEXIST) {\n+    log_error(crac)(\"Cannot create CRaCCheckpointTo=%s: %s\", CRaCCheckpointTo, os::strerror(errno));\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+#if INCLUDE_JVMTI\n+  JvmtiExport::post_crac_before_checkpoint();\n+#endif\n+\n+  Universe::heap()->set_cleanup_unused(true);\n+  Universe::heap()->collect(GCCause::_full_gc_alot);\n+  Universe::heap()->set_cleanup_unused(false);\n+  Universe::heap()->finish_collection();\n+\n+  if (os::can_trim_native_heap()) {\n+    os::size_change_t sc;\n+    if (os::trim_native_heap(&sc)) {\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n+        log_debug(crac)(\"Trim native heap before checkpoint: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \")\",\n+                        PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta));\n+      }\n+    }\n+  }\n+\n+  JFR_ONLY(Jfr::before_checkpoint();)\n+\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer) {\n+    aio_writer->stop();\n+  }\n+  LogConfiguration::close();\n+\n+  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    VMThread::execute(&cr);\n+  }\n+\n+  Universe::heap()->after_restore();\n+\n+  LogConfiguration::reopen();\n+  if (aio_writer) {\n+    aio_writer->resume();\n+  }\n+\n+  JFR_ONLY(Jfr::after_restore();)\n+\n+#if INCLUDE_JVMTI\n+  JvmtiExport::post_crac_after_restore();\n+#endif\n+\n+  if (cr.ok()) {\n+    \/\/ Using handle rather than oop; dangling oop would fail with -XX:+CheckUnhandledOops\n+    Handle new_args;\n+    if (cr.new_args()) {\n+      oop args_oop = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n+      new_args = Handle(THREAD, args_oop);\n+    }\n+\n+    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n+    objArrayHandle props(THREAD, propsObj);\n+\n+    for (int i = 0; i < new_properties->length(); i++) {\n+      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n+      props->obj_at_put(i, propObj);\n+    }\n+\n+    wakeup_threads_in_timedwait();\n+\n+    return ret_cr(JVM_CHECKPOINT_OK, new_args, props, Handle(), Handle(), THREAD);\n+  }\n+\n+  GrowableArray<CracFailDep>* failures = cr.failures();\n+\n+  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n+  typeArrayHandle codes(THREAD, codesObj);\n+  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n+  objArrayHandle msgs(THREAD, msgsObj);\n+\n+  for (int i = 0; i < failures->length(); ++i) {\n+    codes->int_at_put(i, failures->at(i)._type);\n+    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n+    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n+    msgs->obj_at_put(i, msgObj);\n+  }\n+\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n+}\n+\n+void crac::prepare_restore(crac_restore_data& restore_data) {\n+  restore_data.restore_time = os::javaTimeMillis();\n+  restore_data.restore_nanos = os::javaTimeNanos();\n+}\n+\n+void crac::restore(crac_restore_data& restore_data) {\n+  precond(CRaCRestoreFrom != nullptr);\n+\n+  struct stat statbuf;\n+  if (os::stat(CRaCRestoreFrom, &statbuf) != 0) {\n+    log_error(crac)(\"Cannot open CRaCRestoreFrom=%s: %s\", CRaCRestoreFrom, os::strerror(errno));\n+    return;\n+  }\n+  if ((statbuf.st_mode & S_IFMT) != S_IFDIR) {\n+    log_error(crac)(\"CRaCRestoreFrom=%s is not a directory\", CRaCRestoreFrom);\n+    return;\n+  }\n+\n+  \/\/ Note that this is a local, i.e. the handle will be destroyed if we fail to restore\n+  CracEngine engine(CRaCRestoreFrom);\n+  if (!engine.is_initialized()) {\n+    return;\n+  }\n+\n+  switch (engine.prepare_restore_data_api()) {\n+    case CracEngine::ApiStatus::OK: {\n+      const int shmid = os::current_process_id();\n+      CracSHM shm(shmid);\n+      const int shmfd = shm.open(O_RDWR | O_CREAT | O_TRUNC);\n+      if (shmfd < 0) {\n+        log_error(crac)(\"Failed to open a space shared with restored process\");\n+        return;\n+      }\n+      const bool write_success = CracRestoreParameters::write_to(\n+        shmfd,\n+        Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n+        Arguments::system_properties(),\n+        Arguments::java_command_crac() ? Arguments::java_command_crac() : \"\",\n+        restore_data.restore_time,\n+        restore_data.restore_nanos\n+      );\n+      close(shmfd);\n+      if (!write_success) {\n+        log_error(crac)(\"Failed to write to a space shared with restored process\");\n+        return;\n+      }\n+      if (!engine.set_restore_data(&shmid, sizeof(shmid))) {\n+        log_error(crac)(\"CRaC engine failed to record restore data\");\n+        return;\n+      }\n+      break;\n+    }\n+    case CracEngine::ApiStatus::ERR: break;\n+    case CracEngine::ApiStatus::UNSUPPORTED:\n+      log_warning(crac)(\"Cannot pass restore parameters (JVM flags, env vars, system properties, arguments...) \"\n+        \"with the selected CRaC engine\");\n+      break;\n+  }\n+\n+  const int ret = engine.restore();\n+  if (ret != 0) {\n+    log_error(crac)(\"CRaC engine failed to restore from %s: error %i\", CRaCRestoreFrom, ret);\n+  }\n+}\n+\n+bool CracRestoreParameters::read_from(int fd) {\n+  struct stat st;\n+  if (fstat(fd, &st)) {\n+    perror(\"fstat (ignoring restore parameters)\");\n+    return false;\n+  }\n+\n+  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+  if (read(fd, contents, st.st_size) < 0) {\n+    perror(\"read (ignoring restore parameters)\");\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return false;\n+  }\n+\n+  _raw_content = contents;\n+\n+  \/\/ parse the contents to read new system properties and arguments\n+  header* hdr = (header*)_raw_content;\n+  char* cursor = _raw_content + sizeof(header);\n+\n+  ::_restore_start_time = hdr->_restore_time;\n+  ::_restore_start_nanos = hdr->_restore_nanos;\n+\n+  for (int i = 0; i < hdr->_nflags; i++) {\n+    FormatBuffer<80> err_msg(\"%s\", \"\");\n+    JVMFlag::Error result;\n+    const char *name = cursor;\n+    if (*cursor == '+' || *cursor == '-') {\n+      name = cursor + 1;\n+      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n+        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+      cursor += strlen(cursor) + 1;\n+    } else if (strncmp(name, \"CRaCEngine\", ARRAY_SIZE(\"CRaCEngine\") - 1) == 0) {\n+      \/\/ CRaCEngine and CRaCEngineOptions are not updated from the restoring process\n+      assert(strncmp(name, \"CRaCEngine=\", strlen(\"CRaCEngine=\")) == 0 ||\n+             strncmp(name, \"CRaCEngineOptions=\", strlen(\"CRaCEngineOptions=\")) == 0,\n+             \"unexpected CRaCEngine* flag: %s\", name);\n+      result = JVMFlag::Error::SUCCESS;\n+      cursor += strlen(cursor) + 1;\n+    } else {\n+      char* eq = strchrnul(cursor, '=');\n+      if (*eq == '\\0') {\n+        result = JVMFlag::Error::MISSING_VALUE;\n+        cursor = eq + 1;\n+      } else {\n+        *eq = '\\0';\n+        char* value = eq + 1;\n+        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+        cursor = value + strlen(value) + 1;\n+      }\n+    }\n+    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %d\",\n+        name, result);\n+  }\n+\n+  for (int i = 0; i < hdr->_nprops; i++) {\n+    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+    int idx = _properties->append(cursor);\n+    size_t prop_len = strlen(cursor) + 1;\n+    cursor = cursor + prop_len;\n+  }\n+\n+  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n+  memcpy(env_mem, cursor, hdr->_env_memory_size);\n+\n+  const char* env_end = env_mem + hdr->_env_memory_size;\n+  while (env_mem < env_end) {\n+    const size_t s = strlen(env_mem) + 1;\n+    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n+    putenv(env_mem);\n+    env_mem += s;\n+  }\n+  cursor += hdr->_env_memory_size;\n+\n+  _args = cursor;\n+  return true;\n+}\n+\n+void crac::record_time_before_checkpoint() {\n+  os::javaTimeSystemUTC(_checkpoint_wallclock_seconds, _checkpoint_wallclock_nanos);\n+  _checkpoint_monotonic_nanos = os::javaTimeNanos();\n+  memset(_checkpoint_bootid, 0, UUID_LENGTH);\n+  read_bootid(_checkpoint_bootid);\n+}\n+\n+void crac::update_javaTimeNanos_offset() {\n+  char buf[UUID_LENGTH];\n+  \/\/ We will change the nanotime offset only if this is not the same boot\n+  \/\/ to prevent reducing the accuracy of System.nanoTime() unnecessarily.\n+  \/\/ It is possible that in a real-world case the boot_id does not change\n+  \/\/ (containers keep the boot_id) - but the monotonic time changes. We will\n+  \/\/ only guarantee that the nanotime does not go backwards in that case but\n+  \/\/ won't offset the time based on wall-clock time as this change in monotonic\n+  \/\/ time is likely intentional.\n+  if (!read_bootid(buf) || memcmp(buf, _checkpoint_bootid, UUID_LENGTH) != 0) {\n+    jlong current_wallclock_seconds;\n+    jlong current_wallclock_nanos;\n+    os::javaTimeSystemUTC(current_wallclock_seconds, current_wallclock_nanos);\n+\n+    jlong diff_wallclock =\n+      (current_wallclock_seconds - _checkpoint_wallclock_seconds) * NANOSECS_PER_SEC +\n+      current_wallclock_nanos - _checkpoint_wallclock_nanos;\n+    \/\/ If the wall clock has gone backwards we won't add it to the offset\n+    if (diff_wallclock < 0) {\n+      diff_wallclock = 0;\n+    }\n+\n+    \/\/ javaTimeNanos() call on the second line below uses the *_offset, so we will zero\n+    \/\/ it to make the call return true monotonic time rather than the adjusted value.\n+    _javaTimeNanos_offset = 0;\n+    _javaTimeNanos_offset = _checkpoint_monotonic_nanos - os::javaTimeNanos() + diff_wallclock;\n+  } else {\n+    \/\/ ensure monotonicity even if this looks like the same boot\n+    jlong diff = os::javaTimeNanos() - _checkpoint_monotonic_nanos;\n+    if (diff < 0) {\n+      _javaTimeNanos_offset -= diff;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":668,"deletions":0,"binary":false,"changes":668,"status":"added"},{"patch":"@@ -0,0 +1,409 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"crlib\/crlib.h\"\n+#include \"crlib\/crlib_restore_data.h\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"nmt\/memTag.hpp\"\n+#include \"runtime\/crac_engine.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+#include <cstddef>\n+#include <cstring>\n+\n+\/\/ CRaC engine configuration options JVM sets directly instead of relaying from the user\n+#define VM_CONTROLLED_ENGINE_OPTS(OPT) \\\n+  OPT(image_location) \\\n+  OPT(exec_location) \\\n+\n+#define ARRAY_ELEM(opt) #opt,\n+static constexpr const char * const vm_controlled_engine_opts[] = {\n+  VM_CONTROLLED_ENGINE_OPTS(ARRAY_ELEM) nullptr\n+};\n+#undef ARRAY_ELEM\n+\n+#define DEFINE_OPT_VAR(opt) static constexpr const char engine_opt_##opt[] = #opt;\n+VM_CONTROLLED_ENGINE_OPTS(DEFINE_OPT_VAR)\n+#undef DEFINE_OPT_VAR\n+\n+#ifdef _WINDOWS\n+static char *strsep(char **strp, const char *delim) {\n+  char *str = *strp;\n+  if (str == nullptr) {\n+    return nullptr;\n+  }\n+  size_t len = strcspn(str, delim);\n+  if (str[len] == '\\0') {\n+    *strp = nullptr;\n+    return str;\n+  }\n+  str[len] = '\\0';\n+  *strp += len + 1;\n+  return str;\n+}\n+#endif \/\/ _WINDOWS\n+\n+const char * const *CracEngine::vm_controlled_options() {\n+  return vm_controlled_engine_opts;\n+}\n+\n+static bool find_engine(const char *dll_dir, char *path, size_t path_size, bool *is_library) {\n+  \/\/ Try to interpret as a file path\n+  if (os::is_path_absolute(CRaCEngine)) {\n+    const size_t path_len = strlen(CRaCEngine);\n+    if (path_len + 1 > path_size) {\n+      log_error(crac)(\"CRaCEngine file path is too long: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    if (!os::file_exists(CRaCEngine)) {\n+      log_error(crac)(\"CRaCEngine file does not exist: %s\", CRaCEngine);\n+      return false;\n+    }\n+\n+    strcpy(path, CRaCEngine);\n+\n+    const char *last_slash = strrchr(CRaCEngine, *os::file_separator());\n+    const char *basename;\n+    if (last_slash == nullptr) {\n+      basename = CRaCEngine;\n+    } else {\n+      basename = last_slash + strlen(os::file_separator());\n+    }\n+    *is_library = strncmp(basename, JNI_LIB_PREFIX, strlen(JNI_LIB_PREFIX)) == 0 &&\n+      strcmp(path + path_len - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0;\n+    log_debug(crac)(\"CRaCEngine path %s is %s library\", CRaCEngine, *is_library ? \"a\" : \"not a\");\n+\n+    return true;\n+  }\n+\n+  \/\/ Try to interpret as a library name\n+  if (os::dll_locate_lib(path, path_size, dll_dir, CRaCEngine)) {\n+    *is_library = true;\n+    log_debug(crac)(\"Found CRaCEngine %s as a library in %s\", CRaCEngine, path);\n+    return true;\n+  }\n+\n+  *is_library = false;\n+  log_debug(crac)(\"CRaCEngine %s is not a library in %s\", CRaCEngine, dll_dir);\n+\n+  constexpr const char suffix[] = WINDOWS_ONLY(\".exe\") NOT_WINDOWS(\"\");\n+#ifndef S_ISREG\n+# define S_ISREG(__mode) (((__mode) & S_IFMT) == S_IFREG)\n+#endif \/\/ S_ISREG\n+  struct stat st;\n+\n+  \/\/ Try to interpret as an executable name with \"engine\" suffix omitted\n+  size_t path_len = strlen(dll_dir) + strlen(os::file_separator()) + strlen(CRaCEngine) + strlen(\"engine\") + strlen(suffix);\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%sengine%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n+    }\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine an executable name with 'engine' omitted: path is too long\");\n+  }\n+\n+  \/\/ Try to interpret as an executable name\n+  precond(path_len > strlen(\"engine\"));\n+  path_len -= strlen(\"engine\");\n+  if (path_len + 1 <= path_size) {\n+    os::snprintf_checked(path, path_size, \"%s%s%s%s\", dll_dir, os::file_separator(), CRaCEngine, suffix);\n+    if (os::stat(path, &st) == 0 && S_ISREG(st.st_mode)) {\n+      log_debug(crac)(\"Found CRaCEngine %s as %s\", CRaCEngine, path);\n+      return true;\n+    }\n+  } else {\n+    log_debug(crac)(\"Not looking for CRaCEngine as an executable name: path is too long\");\n+  }\n+\n+  return false;\n+}\n+\n+static bool configure_image_location(const crlib_api_t &api, crlib_conf_t *conf, const char *image_location) {\n+  precond(image_location != nullptr && image_location[0] != '\\0');\n+  if (!api.configure(conf, engine_opt_image_location, image_location)) {\n+    log_error(crac)(\"CRaC engine failed to configure: '%s' = '%s'\", engine_opt_image_location, image_location);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ These functions are used in a template instantiation and need to have external linkage. Otherwise\n+\/\/ Windows-debug build fails with linkage errors for the instantiation's symbols.\n+class CStringUtils : public AllStatic {\n+public:\n+  static unsigned int hash(const char * const &s) {\n+    unsigned int h = 0;\n+    for (const char *p = s; *p != '\\0'; p++) {\n+      h = 31 * h + *p;\n+    }\n+    return h;\n+  }\n+\n+  static bool equals(const char * const &s0, const char * const &s1) {\n+    return strcmp(s0, s1) == 0;\n+  }\n+};\n+\n+\/\/ Have to use C-heap because resource area may yet be unavailable when this is used\n+using CStringSet = ResourceHashtable<const char *, bool, 256, AnyObj::C_HEAP, MemTag::mtInternal,\n+                                     CStringUtils::hash, CStringUtils::equals>;\n+\n+static crlib_conf_t *create_conf(const crlib_api_t &api, const char *image_location, const char *exec_location) {\n+  crlib_conf_t * const conf = api.create_conf();\n+  if (conf == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to create its configuration\");\n+    return nullptr;\n+  }\n+\n+  if (CRaCEngineOptions != nullptr && strcmp(CRaCEngineOptions, \"help\") == 0) {\n+    return conf;\n+  }\n+\n+  if (image_location != nullptr && !configure_image_location(api, conf, image_location)) {\n+    api.destroy_conf(conf);\n+    return nullptr;\n+  }\n+\n+  if (exec_location != nullptr) { \/\/ Only passed when using crexec\n+    guarantee(api.can_configure(conf, engine_opt_exec_location),\n+              \"crexec does not support expected option: %s\", engine_opt_exec_location);\n+    if (!api.configure(conf, engine_opt_exec_location, exec_location)) {\n+      log_error(crac)(\"crexec failed to configure: '%s' = '%s'\", engine_opt_exec_location, exec_location);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+  }\n+\n+  if (CRaCEngineOptions == nullptr || CRaCEngineOptions[0] == '\\0' \/* possible for ccstrlist *\/) {\n+    return conf;\n+  }\n+\n+  CStringSet vm_controlled_keys;\n+#define PUT_CONTROLLED_KEY(opt) vm_controlled_keys.put_when_absent(engine_opt_##opt, false);\n+  VM_CONTROLLED_ENGINE_OPTS(PUT_CONTROLLED_KEY)\n+#undef PUT_CONTROLLED_KEY\n+\n+  char *engine_options = os::strdup_check_oom(CRaCEngineOptions, mtInternal);\n+  char *const engine_options_start = engine_options;\n+  CStringSet keys;\n+  do {\n+    char *key_value = strsep(&engine_options, \",\\n\"); \/\/ '\\n' appears when ccstrlist is appended to\n+    const char *key = strsep(&key_value, \"=\");\n+    const char *value = key_value != nullptr ? key_value : \"\";\n+    assert(key != nullptr, \"Should have terminated before\");\n+    if (vm_controlled_keys.contains(key)) {\n+      log_warning(crac)(\"VM-controlled CRaC engine option provided, skipping: %s\", key);\n+      continue;\n+    }\n+    {\n+      bool is_new_key;\n+      keys.put_if_absent(key, &is_new_key);\n+      if (!is_new_key) {\n+        log_warning(crac)(\"CRaC engine option '%s' specified multiple times\", key);\n+      }\n+    }\n+    if (!api.configure(conf, key, value)) {\n+      log_error(crac)(\"CRaC engine failed to configure: '%s' = '%s'\", key, value);\n+      os::free(engine_options_start);\n+      api.destroy_conf(conf);\n+      return nullptr;\n+    }\n+    log_debug(crac)(\"CRaC engine option: '%s' = '%s'\", key, value);\n+  } while (engine_options != nullptr);\n+  os::free(engine_options_start);\n+\n+  return conf;\n+}\n+\n+CracEngine::CracEngine(const char *image_location) {\n+  if (CRaCEngine == nullptr) {\n+    log_error(crac)(\"CRaCEngine must not be empty\");\n+    return;\n+  }\n+\n+  \/\/ Arguments::get_dll_dir() might not have been initialized yet\n+  char dll_dir[JVM_MAXPATHLEN];\n+  os::jvm_path(dll_dir, sizeof(dll_dir));\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n+  char *after_elem = nullptr;\n+  for (int i = 0; i < 2; ++i) {\n+    after_elem = strrchr(dll_dir, *os::file_separator());\n+    *after_elem = '\\0';\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  bool is_library;\n+  if (!find_engine(dll_dir, path, sizeof(path), &is_library)) {\n+    log_error(crac)(\"Cannot find CRaC engine %s\", CRaCEngine);\n+    return;\n+  }\n+  postcond(path[0] != '\\0');\n+\n+  char exec_path[JVM_MAXPATHLEN] = \"\\0\";\n+  if (!is_library) {\n+    strcpy(exec_path, path); \/\/ Save to later pass it to crexec\n+    if (!os::dll_locate_lib(path, sizeof(path), dll_dir, \"crexec\")) {\n+      log_error(crac)(\"Cannot find crexec library to use CRaCEngine executable\");\n+      return;\n+    }\n+  }\n+\n+  char error_buf[1024];\n+  void * const lib = os::dll_load(path, error_buf, sizeof(error_buf));\n+  if (lib == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library from %s: %s\", path, error_buf);\n+    return;\n+  }\n+\n+  using api_func_t = decltype(&CRLIB_API);\n+  const auto api_func = reinterpret_cast<api_func_t>(os::dll_lookup(lib, CRLIB_API_FUNC));\n+  if (api_func == nullptr) {\n+    log_error(crac)(\"Cannot load CRaC engine library entrypoint '\" CRLIB_API_FUNC \"' from %s\", path);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  crlib_api_t * const api = api_func(CRLIB_API_VERSION, sizeof(crlib_api_t));\n+  if (api == nullptr) {\n+    log_error(crac)(\"CRaC engine failed to initialize its API (version %i). \"\n+                    \"Maybe this version is not supported?\", CRLIB_API_VERSION);\n+    os::dll_unload(lib);\n+    return;\n+  }\n+  if (api->create_conf == nullptr || api->destroy_conf == nullptr ||\n+      api->checkpoint == nullptr || api->restore == nullptr ||\n+      api->can_configure == nullptr || api->configure == nullptr ||\n+      api->get_extension == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid API\");\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  const char *exec_location = exec_path[0] != '\\0' ? exec_path : nullptr;\n+  crlib_conf_t * const conf = create_conf(*api, image_location, exec_location);\n+  if (conf == nullptr) {\n+    os::dll_unload(lib);\n+    return;\n+  }\n+\n+  _lib = lib;\n+  _api = api;\n+  _conf = conf;\n+}\n+\n+CracEngine::~CracEngine() {\n+  if (is_initialized()) {\n+    _api->destroy_conf(_conf);\n+    os::dll_unload(_lib);\n+  }\n+}\n+\n+bool CracEngine::is_initialized() const {\n+  assert((_lib == nullptr && _api == nullptr && _conf == nullptr) ||\n+          (_lib != nullptr && _api != nullptr && _conf != nullptr), \"invariant\");\n+  return _lib != nullptr;\n+}\n+\n+int CracEngine::checkpoint() const {\n+  precond(is_initialized());\n+  return _api->checkpoint(_conf);\n+}\n+\n+int CracEngine::restore() const {\n+  precond(is_initialized());\n+  return _api->restore(_conf);\n+}\n+\n+bool CracEngine::configure_image_location(const char *image_location) const {\n+  precond(is_initialized());\n+  return ::configure_image_location(*_api, _conf, image_location);\n+}\n+\n+CracEngine::ApiStatus CracEngine::prepare_restore_data_api() {\n+  precond(is_initialized());\n+  if (_restore_data_api != nullptr) {\n+    return ApiStatus::OK;\n+  }\n+\n+  crlib_restore_data_t * const restore_data_api = CRLIB_EXTENSION_RESTORE_DATA(_api);\n+  if (restore_data_api == nullptr) {\n+    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n+    return ApiStatus::UNSUPPORTED;\n+  }\n+  if (restore_data_api->set_restore_data == nullptr || restore_data_api->get_restore_data == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid API for extension: \" CRLIB_EXTENSION_RESTORE_DATA_NAME);\n+    return ApiStatus::ERR;\n+  }\n+  _restore_data_api = restore_data_api;\n+  return ApiStatus::OK;\n+}\n+\n+bool CracEngine::set_restore_data(const void *data, size_t size) const {\n+  precond(_restore_data_api != nullptr);\n+  return _restore_data_api->set_restore_data(_conf, data, size);\n+}\n+\n+size_t CracEngine::get_restore_data(void *buf, size_t size) const {\n+  precond(_restore_data_api != nullptr);\n+  return _restore_data_api->get_restore_data(_conf, buf, size);\n+}\n+\n+CracEngine::ApiStatus CracEngine::prepare_description_api() {\n+  precond(is_initialized());\n+  if (_description_api != nullptr) {\n+    return ApiStatus::OK;\n+  }\n+\n+  crlib_description_t * const description_api = CRLIB_EXTENSION_DESCRIPTION(_api);\n+  if (description_api == nullptr) {\n+    log_debug(crac)(\"CRaC engine does not support extension: \" CRLIB_EXTENSION_DESCRIPTION_NAME);\n+    return ApiStatus::UNSUPPORTED;\n+  }\n+  if (description_api->identity == nullptr || description_api->description == nullptr ||\n+      description_api->configuration_doc == nullptr ||\n+      description_api->configurable_keys == nullptr ||\n+      description_api->supported_extensions == nullptr) {\n+    log_error(crac)(\"CRaC engine provided invalid API for extension: \" CRLIB_EXTENSION_DESCRIPTION_NAME);\n+    return ApiStatus::ERR;\n+  }\n+  _description_api = description_api;\n+  return ApiStatus::OK;\n+}\n+\n+const char *CracEngine::description() const {\n+  precond(_description_api != nullptr);\n+  return _description_api->description(_conf);\n+}\n+\n+const char *CracEngine::configuration_doc() const {\n+  precond(_description_api != nullptr);\n+  return _description_api->configuration_doc(_conf);\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":409,"deletions":0,"binary":false,"changes":409,"status":"added"},{"patch":"@@ -337,0 +337,1 @@\n+    { KIND_RESTORE_SETTABLE, \"restore\" },\n@@ -401,0 +402,2 @@\n+    case JVMFlagOrigin::CRAC_RESTORE:\n+      st->print(\"crac restore\");\n@@ -508,3 +511,4 @@\n-const int DIAGNOSTIC   = JVMFlag::KIND_DIAGNOSTIC;\n-const int MANAGEABLE   = JVMFlag::KIND_MANAGEABLE;\n-const int EXPERIMENTAL = JVMFlag::KIND_EXPERIMENTAL;\n+const int DIAGNOSTIC       = JVMFlag::KIND_DIAGNOSTIC;\n+const int MANAGEABLE       = JVMFlag::KIND_MANAGEABLE;\n+const int EXPERIMENTAL     = JVMFlag::KIND_EXPERIMENTAL;\n+const int RESTORE_SETTABLE = JVMFlag::KIND_RESTORE_SETTABLE;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1239,0 +1239,1 @@\n+  void wakeup_sleep() { _SleepEvent->unpark(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2242,0 +2242,9 @@\n+void os::cleanup_memory(char* addr, size_t bytes) {\n+  char* start = (char*)align_up(addr, os::vm_page_size());\n+  char* end = (char*)align_down(addr + bytes, os::vm_page_size());\n+  if (start < end) {\n+    os::uncommit_memory(start, end - start);\n+    os::commit_memory(start, end - start, false);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -428,0 +429,15 @@\n+static jint check_for_restore(JavaVMInitArgs* args, crac::crac_restore_data& restore_data) {\n+  if (Arguments::is_restore_option_set(args)) {\n+    if (!Arguments::parse_options_for_restore(args)) {\n+      return JNI_ERR;\n+    }\n+    crac::restore(restore_data);\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -431,0 +447,8 @@\n+#ifdef __APPLE__\n+  \/\/ BSD clock would be initialized in os::init() but we need to do that earlier\n+  \/\/ as crac::prepare_restore() calls os::javaTimeNanos().\n+  os::Bsd::clock_init();\n+#endif\n+  crac::crac_restore_data restore_data;\n+  crac::prepare_restore(restore_data);\n+\n@@ -461,0 +485,4 @@\n+  \/\/ Output stream module should be already initialized for error reporting during restore.\n+  \/\/ JDK version should also be intialized for arguments parsing.\n+  if (check_for_restore(args, restore_data) != JNI_OK) return JNI_ERR;\n+\n@@ -495,0 +523,2 @@\n+  crac::vm_create_start();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2481,0 +2481,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+#if INCLUDE_SERVICES && !defined(_WINDOWS)\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS)\n@@ -154,0 +158,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -1051,0 +1057,26 @@\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_crac_mirror_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::checkpointRestoreInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != NULL) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      outputStream* stream = output();\n+#if INCLUDE_SERVICES && !defined(_WINDOWS)\n+      assert(PosixAttachListener::get_current_op(), \"should exist\");\n+      if (PosixAttachListener::get_current_op()->is_effectively_completed()) {\n+        stream = tty;\n+      }\n+#endif \/\/ INCLUDE_SERVICES\n+      stream->print_cr(\"An exception during a checkpoint operation:\");\n+      stream->print(\"%s\", out);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -916,1 +917,1 @@\n-    return Management::ticks_to_ms(os::elapsed_counter());\n+    return Management::ticks_to_ms(os::elapsed_counter_since_restore());\n@@ -980,0 +981,12 @@\n+  case JMM_JVM_RESTORE_START_TIME_MS:\n+    return crac::restore_start_time();\n+\n+  case JMM_JVM_UPTIME_SINCE_RESTORE_MS:\n+    {\n+      jlong ticks = crac::uptime_since_restore();\n+      if (ticks == -1) {\n+        return -1;\n+      }\n+      return Management::ticks_to_ms(ticks);\n+    }\n+\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -237,2 +237,2 @@\n-    \/\/ only writeable flags are allowed to be set\n-    if (f->is_writeable()) {\n+    \/\/ only writeable or restore_settable flags are allowed to be set\n+    if (f->is_writeable() || (f->is_restore_settable() && origin == JVMFlagOrigin::CRAC_RESTORE)) {\n","filename":"src\/hotspot\/share\/services\/writeableFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,0 +124,9 @@\n+void Decoder::before_checkpoint() {\n+  MutexLocker locker(shared_decoder_lock(), Mutex::_no_safepoint_check_flag);\n+  if (_shared_decoder != nullptr) {\n+    delete _shared_decoder;\n+    _shared_decoder = nullptr;\n+  }\n+  guarantee(_error_handler_decoder == nullptr, \"Error handler decoder should not be present\");\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/decoder.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -796,1 +796,1 @@\n-void defaultStream::finish_log() {\n+void defaultStream::finish_log(bool is_checkpoint) {\n@@ -800,0 +800,3 @@\n+  if (is_checkpoint) {\n+    CompileLog::finish_log_on_checkpoint(xs->out());\n+  } else {\n@@ -801,1 +804,2 @@\n-  CompileLog::finish_log(xs->out());  \/\/ write compile logging, if any, now\n+    CompileLog::finish_log(xs->out());  \/\/ write compile logging, if any, now\n+  }\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+typedef int(*ZIP_GetFD_t)(jzfile *zip);\n@@ -49,0 +50,1 @@\n+static ZIP_GetFD_t ZIP_GetFD = nullptr;\n@@ -88,0 +90,1 @@\n+  ZIP_GetFD = CAST_TO_FN_PTR(ZIP_GetFD_t, dll_lookup(\"ZIP_GetFD\", path, false));\n@@ -208,0 +211,4 @@\n+\n+int ZipLibrary::get_fd(jzfile *zip) {\n+  return ZIP_GetFD ? ZIP_GetFD(zip) : -1;\n+}\n","filename":"src\/hotspot\/share\/utilities\/zipLibrary.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -362,0 +362,5 @@\n+     * @crac When the process is restored on another machine or if the machine\n+     * rebooted the value is updated based on wall-clock time difference,\n+     * resulting in a loss of accuracy when comparing timestamps obtained\n+     * before and after checkpoint.\n+     *\n@@ -617,0 +622,6 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload system properties in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -651,0 +662,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -710,0 +722,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -731,0 +746,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -831,0 +849,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -838,0 +862,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -867,0 +892,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload the environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -872,0 +903,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -217,0 +217,4 @@\n+     *\n+     * @crac Instances created by this constructor are automatically reseeded\n+     * after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n@@ -260,0 +264,4 @@\n+     * @crac Instances created by this constructor are <strong>not<\/strong>\n+     * reseeded after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n+     *\n@@ -362,0 +370,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -410,0 +420,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -455,0 +467,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -503,0 +517,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -561,0 +577,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -614,0 +632,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-\n@@ -178,0 +177,5 @@\n+    exports jdk.internal.crac to\n+        java.rmi,\n+        jdk.jfr,\n+        jdk.management.agent,\n+        jdk.sctp;\n@@ -408,0 +412,8 @@\n+    exports jdk.internal.crac.mirror to\n+        java.rmi,\n+        jdk.crac,\n+        jdk.jfr,\n+        jdk.management.agent;\n+\n+    exports jdk.internal.crac.mirror.impl to\n+        jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1076,0 +1076,15 @@\n+`-XX:CRaCCheckpointTo=`*directory*\n+:   The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+    a running Java program into an image directory. Restoring from the image should\n+    solve some of the problematic start-up and warm-up times.\n+\n+    This option defines a path to the snapshot which is currently a directory. The\n+    directory will be created if it does not exist, but no parent directories are\n+    created.\n+\n+`-XX:CRaCRestoreFrom=`*directory*\n+:   Restores a snapshot created by `-XX:CRaCCheckpointTo=`*directory*.\n+\n+`-XX:CRaCMinPid=`*value*\n+:   A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+\n@@ -1824,0 +1839,7 @@\n+`-XX:CPUFeatures=`*0xnumber*\n+:   CPU feature set, use `-XX:CPUFeatures=`*0xnumber* with `-XX:CRaCCheckpointTo` when\n+    you get an error during `-XX:CRaCRestoreFrom` on a different machine.\n+    `-XX:CPUFeatures=native` is the default.\n+    `-XX:CPUFeatures=generic` is compatible with any CPU but not as slow\n+    as `-XX:CPUFeatures=0`.\n+\n@@ -1991,0 +2013,4 @@\n+`-XX:+ShowCPUFeatures`\n+:   Show features of this CPU to be possibly used for the\n+    `-XX:CPUFeatures=`*0xnumber* option.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,0 +37,7 @@\n+#ifndef WIN32\n+#include <errno.h>\n+#endif\n+#ifdef LINUX\n+#include <syscall.h>\n+#endif\n+\n@@ -52,0 +59,149 @@\n+\n+#ifndef _WIN32\n+#include <stdbool.h>\n+#include <sys\/wait.h>\n+\n+static bool is_checkpoint = false;\n+static bool is_restore = false;\n+static const int crac_min_pid_default = 128;\n+static int crac_min_pid = 0;\n+static bool is_min_pid_set = false;\n+\n+static inline const char *find_option(const char *arg, const char *vmoption) {\n+    const int len = strlen(vmoption);\n+    if (0 == strncmp(arg, vmoption, len)) {\n+        return arg + len;\n+    }\n+    return NULL;\n+}\n+\n+static void parse_crac(const char *arg) {\n+    if (!is_checkpoint && find_option(arg, \"-XX:CRaCCheckpointTo\")) {\n+        is_checkpoint = true;\n+    } else if (!is_restore && find_option(arg, \"-XX:CRaCRestoreFrom\")) {\n+        is_restore = true;\n+    } else if (!is_min_pid_set) {\n+        const char *value = find_option(arg, \"-XX:CRaCMinPid=\");\n+        if (value != NULL) {\n+            crac_min_pid = atoi(value);\n+            is_min_pid_set = true;\n+        }\n+    }\n+}\n+\n+static pid_t g_child_pid = -1;\n+\n+static int wait_for_children() {\n+    int status = -1;\n+    pid_t pid;\n+    do {\n+        int st = 0;\n+        pid = wait(&st);\n+        if (pid == g_child_pid) {\n+            status = st;\n+        }\n+    } while (-1 != pid || ECHILD != errno);\n+\n+    if (WIFEXITED(status)) {\n+        return WEXITSTATUS(status);\n+    }\n+\n+    if (WIFSIGNALED(status)) {\n+        \/\/ Try to terminate the current process with the same signal\n+        \/\/ as the child process was terminated\n+        const int sig = WTERMSIG(status);\n+        signal(sig, SIG_DFL);\n+        raise(sig);\n+        \/\/ Signal was ignored, return 128+n as bash does\n+        \/\/ see https:\/\/linux.die.net\/man\/1\/bash\n+        return 128+sig;\n+    }\n+\n+    return 1;\n+}\n+\n+static void sighandler(int sig, siginfo_t *info, void *param) {\n+    if (0 < g_child_pid) {\n+        kill(g_child_pid, sig);\n+    }\n+}\n+\n+static void setup_sighandler() {\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    const int MaxSignalValue = 31;\n+    for (int sig = 1; sig <= MaxSignalValue; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(\"sigprocmask\");\n+    }\n+}\n+\n+static int set_last_pid(int pid) {\n+#ifdef LINUX\n+    char buf[11]; \/\/ enough for int32\n+    const int len = snprintf(buf, sizeof(buf), \"%d\", pid);\n+    if (0 > len || sizeof(buf) < (size_t)len) {\n+        return EINVAL;\n+    }\n+    const char *last_pid_filename = \"\/proc\/sys\/kernel\/ns_last_pid\";\n+    const int last_pid_file = open(last_pid_filename, O_WRONLY|O_TRUNC, 0666);\n+    if (0 > last_pid_file) {\n+        return errno;\n+    }\n+    int res = 0;\n+    if (len > write(last_pid_file, buf, len)) {\n+        res = errno;\n+    }\n+    close(last_pid_file);\n+    return res;\n+#else\n+    return EPERM;\n+#endif\n+}\n+\n+static void spin_last_pid(int pid) {\n+    const int MaxSpinCount = pid < 1000 ? 1000 : pid;\n+    int cnt = MaxSpinCount;\n+    int child = 0;\n+    int prev = 0;\n+    do {\n+        child = fork();\n+        if (0 > child) {\n+            perror(\"spin_last_pid clone\");\n+            exit(1);\n+        }\n+        if (0 == child) {\n+            exit(0);\n+        }\n+        if (child < prev) {\n+            fprintf(stderr, \"%s: Invalid argument (%d)\\n\", __FUNCTION__, pid);\n+            exit(1);\n+        }\n+        if (0 >= cnt) {\n+            fprintf(stderr, \"%s: Can't reach pid %d, out of try count. Current pid=%d\\n\", __FUNCTION__, pid, child);\n+            exit(1);\n+        }\n+        prev = child;\n+        int status;\n+        if (0 > waitpid(child, &status, 0)) {\n+            perror(\"spin_last_pid waitpid\");\n+            exit(1);\n+        }\n+        --cnt;\n+    } while (child < pid);\n+}\n+#endif \/\/ _WIN32\n+\n@@ -130,0 +286,1 @@\n+            parse_crac(argv[i]);\n@@ -149,1 +306,69 @@\n-#endif \/* WIN32 *\/\n+\n+    const int is_init = 1 == getpid();\n+    if (is_init && !is_min_pid_set) {\n+        crac_min_pid = crac_min_pid_default;\n+    }\n+    const int needs_pid_adjust = getpid() < crac_min_pid;\n+    if (is_checkpoint && (is_init || needs_pid_adjust)) {\n+        \/\/ Move PID value for new processes to a desired value\n+        \/\/ to avoid PID conflicts on restore.\n+        if (needs_pid_adjust) {\n+            const int res = set_last_pid(crac_min_pid);\n+            if (EPERM == res || EACCES == res || EROFS == res) {\n+                spin_last_pid(crac_min_pid);\n+            } else if (0 != res) {\n+                fprintf(stderr, \"set_last_pid: %s\\n\", strerror(res));\n+                exit(1);\n+            }\n+        }\n+\n+        \/\/ Avoid unexpected process completion when checkpointing under docker container run\n+        \/\/ by creating the main process waiting for children before exit.\n+        g_child_pid = fork();\n+        if (0 == g_child_pid && needs_pid_adjust && getpid() < crac_min_pid) {\n+            if (is_min_pid_set) {\n+                fprintf(stderr, \"Error: Can't adjust PID to min PID %d, current PID %d\\n\", crac_min_pid, (int)getpid());\n+                exit(1);\n+            } else {\n+                fprintf(stderr,\n+                        \"Warning: Can't adjust PID to min PID %d, current PID %d.\\n\"\n+                        \"This message can be suppressed by '-XX:CRaCMinPid=1' option\\n\",\n+                        crac_min_pid, (int)getpid());\n+            }\n+        }\n+        if (0 < g_child_pid) {\n+            \/\/ The main process should forward signals to the child.\n+            setup_sighandler();\n+            const int status = wait_for_children();\n+            exit(status);\n+        }\n+    }\n+#ifdef LINUX\n+    \/\/ \/proc filesystem is only on LINUX\/*NIX - rseq is not relevant elsewhere anyway\n+    if (is_checkpoint || is_restore) {\n+        const char *GLIBC_TUNABLES = \"GLIBC_TUNABLES\";\n+        const char *tunables = getenv(GLIBC_TUNABLES);\n+        \/\/ do not try overwrite an existing tunable setting\n+        if (!tunables || !strstr(tunables, \"glibc.pthread.rseq\")) {\n+            char tunables_buf[4096];\n+            const char *new_tunables = \"glibc.pthread.rseq=0\";\n+            if (tunables) {\n+                int sz = snprintf(tunables_buf, sizeof(tunables_buf), \"%s:%s\", tunables, new_tunables);\n+                if (sz < 0 || (int)sizeof(tunables_buf) <= sz) {\n+                    fprintf(stderr, \"Cannot update GLIBC_TUNABLES: does not fit\\n\");\n+                    return 1;\n+                }\n+                new_tunables = tunables_buf;\n+            }\n+\n+            if (setenv(GLIBC_TUNABLES, new_tunables, 1) < 0) {\n+                perror(\"setenv GLIBC_TUNABLES\");\n+                return 1;\n+            }\n+            execv(\"\/proc\/self\/exe\", argv);\n+            perror(\"re-exec\");\n+            return 1;\n+        }\n+    }\n+#endif \/* LINUX *\/\n+#endif \/* not WIN32 *\/\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":226,"deletions":1,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -326,0 +326,1 @@\n+    SetJavaCommandLinePropCrac(what, argc, argv);\n@@ -1844,0 +1845,58 @@\n+void\n+SetJavaCommandLinePropCrac(char *what, int argc, char **argv)\n+{\n+    \/\/ let's build a new option that escapes whitespaces:\n+    \/\/ Test \"1 2\" 3 -> \"-Dsun.java.crac_command=Test 1\\ 2 3\"\n+    \/\/ and parse it in the VM\/JDK\n+\n+    if (what == NULL) {\n+        \/* unexpected, one of these should be set. just return without\n+         * setting the property\n+         *\/\n+        return;\n+    }\n+\n+    const char* dashDstr = \"-Dsun.java.crac_command=\";\n+\n+    \/* determine the amount of memory to allocate assuming\n+     * the individual components will be space separated\n+     *\/\n+    size_t len = JLI_StrLen(what);\n+    for (int i = 0; i < argc; i++) {\n+        len += JLI_StrLen(argv[i]) + 1;\n+    }\n+    \/* allocate space enough for character escaping*\/\n+    len *= 2;\n+\n+    \/* allocate the memory *\/\n+    char *javaCommand = (char*) JLI_MemAlloc(len + JLI_StrLen(dashDstr) + 1);\n+\n+    \/* build the -D string *\/\n+    *javaCommand = '\\0';\n+    JLI_StrCat(javaCommand, dashDstr);\n+    JLI_StrCat(javaCommand, what);\n+\n+    char *javaCmdEnd = javaCommand + JLI_StrLen(javaCommand);\n+    for (int i = 0; i < argc; i++) {\n+        \/* The components of the string are space separated. In\n+         * the case of embedded white space, it will be escaped\n+         * with a special char.\n+         * This is needed until SetJavaCommandLineProp is fixed in OpenJDK.\n+         *\/\n+        const char escChar = '\\\\';\n+        const char sepChar = ' ';\n+        const char *arg = argv[i];\n+        const size_t argLen = JLI_StrLen(arg);\n+        *javaCmdEnd++ = sepChar;\n+        for (size_t j = 0; j < argLen; ++j) {\n+            const char curChar = arg[j];\n+            if (escChar == curChar || sepChar == curChar) {\n+                *javaCmdEnd++ = escChar;\n+            }\n+            *javaCmdEnd++ = curChar;\n+        }\n+    }\n+    *javaCmdEnd++ = '\\0';\n+    AddOption(javaCommand, NULL);\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1693,0 +1693,10 @@\n+\n+JNIEXPORT int\n+ZIP_GetFD(jzfile *zip) {\n+#ifdef WIN32\n+    \/\/ File descriptors not applicable on Windows\n+    return -1;\n+#else\n+    return (int) zip->zfd;\n+#endif \/\/ !WIN32\n+}\n","filename":"src\/java.base\/share\/native\/libzip\/zip_util.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1342,0 +1342,1 @@\n+        *env = &single_env;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libdt_socket\/socketTransport.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -165,0 +165,18 @@\n+#if defined(LINUX)\n+    \/\/ In case of multi-threading socket processing, a 'close' call may hang as long as other thread\n+    \/\/ still use a socket with 'select' or whatever. This is exactly the case I met on WSL Ubuntu 22.04.\n+    \/\/ This is why 'shutdown' call is needed here (as well for AIX and Windows) - it stops all the\n+    \/\/ communications via socket, so all system calls using this socket will exit with an error.\n+    \/\/\n+    \/\/ On the other hand, a socket may be set with SO_LINGER property controlling a socket behaviour on close.\n+    \/\/ This affects both 'close' and 'shutdown' calls, so, if SO_LINGER set, it doesn't make sense to call\n+    \/\/ 'shutdown'. So, here we make 'shutdown' call only of SO_LINGER isn't set.\n+    struct linger l;\n+    socklen_t len = sizeof(l);\n+\n+    if (getsockopt(fd, SOL_SOCKET, SO_LINGER, (char *)&l, &len) == 0) {\n+        if (l.l_onoff == 0) {\n+            shutdown(fd, SHUT_RDWR);\n+        }\n+    }\n+#endif\n","filename":"src\/jdk.jdwp.agent\/unix\/native\/libdt_socket\/socket_md.c","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.crac.Core;\n@@ -160,0 +161,7 @@\n+\n+    \/**\n+     * Called by the JVM when it is restored with a new -XX:StartFlightRecorder\n+     *\/\n+    static void requestStartAfterRestore() {\n+        Core.setStartFlightRecorder(JVM::startFlightRecorderAfterRestore);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.io.File;\n@@ -36,0 +37,1 @@\n+import java.nio.file.Files;\n@@ -48,0 +50,1 @@\n+import java.util.stream.Collectors;\n@@ -49,0 +52,4 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -72,0 +79,88 @@\n+    private JDKResource resource = new JDKResource() {\n+        private List<PlatformRecording> futureRecordings;\n+        private static int MAX_BACKUPS = Integer.getInteger(\"jdk.jfr.max_backups\", 20);\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            synchronized (PlatformRecorder.this) {\n+                ArrayList<PlatformRecording> copy = new ArrayList<>(recordings);\n+                futureRecordings = copy.stream().map(r -> {\n+                    \/\/ PlatformRecording has to have a matching Recording - otherwise we could not control those\n+                    \/\/ through jcmd\n+                    Recording rec = new Recording(r.getSettings());\n+                    PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(rec);\n+                    if (r.getName().equals(String.valueOf(r.getId()))) {\n+                        \/\/ default name == id, use the new id as name as well\n+                        rec.setName(String.valueOf(rec.getId()));\n+                    } else {\n+                        \/\/ custom name, keep it\n+                        rec.setName(r.getName());\n+                    }\n+                    rec.setToDisk(r.isToDisk());\n+                    rec.setSettings(r.getSettings());\n+                    pr.setDumpDirectory(r.getDumpDirectory());\n+                    try {\n+                        pr.setDestination(r.getDestination());\n+                    } catch (IOException e) {\n+                        \/\/ never thrown\n+                        Logger.log(JFR, ERROR, \"Cannot copy destination: \" + e.getMessage());\n+                    }\n+                    rec.setMaxAge(r.getMaxAge());\n+                    rec.setMaxSize(r.getMaxSize());\n+                    pr.setInternalDuration(r.getDuration());\n+                    rec.setDumpOnExit(r.getDumpOnExit());\n+                    pr.setFlushInterval(r.getFlushInterval());\n+                    return pr;\n+                }).collect(Collectors.toList());\n+                recordings.removeAll(futureRecordings);\n+                copy.forEach(r -> r.stop(\"Checkpoint\"));\n+                assert recordings.isEmpty();\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            synchronized (PlatformRecorder.this) {\n+                futureRecordings.forEach(r -> {\n+                    recordings.add(r);\n+                    WriteablePath destination = r.getDestination();\n+                    \/\/ The backup recording has to be moved before creating WriteablePath\n+                    \/\/ (and touching the recording output file)\n+                    try {\n+                        File destFile = destination.getReal().toFile();\n+                        if (destFile.exists()) {\n+                            Path backup = null;\n+                            for (int i = 0; backup == null && i < MAX_BACKUPS; ++i) {\n+                                String name = destFile.getName();\n+                                \/\/ Mission Control has issues opening recording files\n+                                \/\/ that don't end with .jfr\n+                                if (name.endsWith(\".jfr\")) {\n+                                    name = name.substring(0, name.length() - 4) + \".\" + i + \".jfr\";\n+                                } else {\n+                                    name = name + \".\" + i;\n+                                }\n+                                backup = destination.getReal().getParent().resolve(name);\n+                                if (backup.toFile().exists()) {\n+                                    backup = null;\n+                                }\n+                            }\n+                            if (backup != null) {\n+                                Files.move(destFile.toPath(), backup);\n+                                Logger.log(JFR, INFO, \"Backed up \" + destFile + \" to \" + backup);\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        Logger.log(JFR, ERROR, \"Cannot backup previous recording: \" + e);\n+                    }\n+                    try {\n+                        \/\/ We need to invoke WriteablePath after restore to create the dump file.\n+                        \/\/ Since we're creating another WriteablePath we can use the original specification\n+                        r.setDestination(new WriteablePath(destination.getPath()));\n+                    } catch (IOException e) {\n+                        Logger.log(JFR, ERROR, \"Cannot reset recording destination: \" + e);\n+                    }\n+                    r.start();\n+                });\n+            }\n+        }\n+    };\n@@ -85,0 +180,2 @@\n+\n+        Core.Priority.JFR.getContext().register(resource);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -830,0 +830,4 @@\n+    Path getDumpDirectory() {\n+        return dumpDirectory;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,0 +117,2 @@\n+# JDK-8310862 was closed but we're still seeing errors with the updated test\n+runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8310862 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -516,0 +516,6 @@\n+# jdk_crac\n+\n+jdk\/crac\/LinkedCleanableRefTest.java                            8353064 generic-all\n+\n+############################################################################\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,212 @@\n+package jdk.test.lib.crac;\n+\n+import jdk.crac.Core;\n+\n+import java.lang.reflect.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Comparator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * CRaC tests usually consists of two parts; the test started by JTreg through the 'run' tag\n+ * and subprocesses started by the test with various VM options. These are represented by the\n+ * {@link #test()} and {@link #exec()} methods.\n+ * CracTest use '@run driver jdk.test.crac.lib.CracTest' as the executable command; the main\n+ * method in this class discovers the executed class from system properties passed by JTReg,\n+ * instantiates the test (public no-arg constructor is needed), populates fields annotated\n+ * with {@link CracTestArg} and executes the {@link #test()} method.\n+ * The test method is expected to use {@link CracBuilder} to start another process. By default,\n+ * CracBuilder invokes the test with arguments that will again instantiate and fill the instance\n+ * and invoke the {@link #exec()} method.\n+ *\/\n+public interface CracTest {\n+\n+    String RESTORED_MESSAGE = \"Restored\";\n+\n+    \/**\n+     * This method is called when JTReg invokes the test; it is supposed to start\n+     * another process (most often using CRaC VM options) and validate its behaviour.\n+     *\n+     * @throws Exception\n+     *\/\n+    void test() throws Exception;\n+\n+    \/**\n+     * This method is invoked in the subprocess; this is where you're likely to call\n+     * {@link Core#checkpointRestore()}.\n+     *\n+     * @throws Exception\n+     *\/\n+    void exec() throws Exception;\n+\n+    class ArgsHolder {\n+        private static final String RUN_TEST = \"__run_test__\";\n+        private static Class<? extends CracTest> testClass;\n+        private static String[] args;\n+        \/\/ This field is present as workaround for @build <test> somehow missing\n+        \/\/ the annotation when\n+        private static final Class<CracTestArg> dummyField = CracTestArg.class;\n+    }\n+\n+    \/**\n+     * Main method for orchestrating the test. This should be called directly by JTReg.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static void main(String[] args) throws Exception {\n+        String testClassName;\n+        if (args.length == 0 || !ArgsHolder.RUN_TEST.equals(args[0])) {\n+            \/\/ We will look up the class name (and package) to avoid boilerplate in any @run invocation\n+            String testFile = System.getProperty(\"test.file\");\n+            String source = Files.readString(Path.of(testFile)).replace('\\n', ' ');\n+            Matcher clsMatcher = Pattern.compile(\"class\\\\s+(\\\\S+)\\\\s+(extends\\\\s+\\\\S+\\\\s+)?implements\\\\s+(\\\\S+\\\\s*,\\\\s*)*CracTest\").matcher(source);\n+            if (!clsMatcher.find()) {\n+                fail(\"Cannot find test class in \" + testFile + \", does it look like class <test> implements CracTest?\");\n+            }\n+            testClassName = clsMatcher.group(1);\n+            Matcher pkgMatcher = Pattern.compile(\"package\\\\s+([^;]+);\").matcher(source);\n+            if (pkgMatcher.find()) {\n+                testClassName = pkgMatcher.group(1) + \".\" + testClassName;\n+            }\n+        } else {\n+            testClassName = args[1];\n+        }\n+\n+        \/\/ When we use CracTest as driver the file with test is not compiled without a @build tag.\n+        \/\/ We could compile the class here and load it from a new classloader but since the test library\n+        \/\/ is not compiled completely we could be missing some dependencies - this would be just too fragile.\n+        Class<?> testClass;\n+        try {\n+            testClass = Class.forName(testClassName);\n+        } catch (ClassNotFoundException e) {\n+            throw new ClassNotFoundException(\"Test class \" + testClassName + \" not found, add jtreg tag @build \" + testClassName, e);\n+        }\n+        if (CracTest.class.isAssignableFrom(testClass)) {\n+            \/\/noinspection unchecked\n+            run((Class<? extends CracTest>) testClass, args);\n+        } else {\n+            throw new IllegalArgumentException(\"Class \" + testClass.getName() + \" does not implement CracTest!\");\n+        }\n+    }\n+\n+    \/**\n+     * This method should be invoked from the public static void main(String[]) method.\n+     *\n+     * @param testClass Class implementing the test.\n+     * @param args Arguments received in the main method.\n+     * @throws Exception\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    static void run(Class<? extends CracTest> testClass, String[] args) throws Exception {\n+        assertNotNull(args);\n+        ArgsHolder.testClass = testClass;\n+        int argsOffset = 0;\n+        if (args.length == 0 || !args[0].equals(ArgsHolder.RUN_TEST)) {\n+            String[] newArgs = new String[args.length + 2];\n+            newArgs[0] = ArgsHolder.RUN_TEST;\n+            newArgs[1] = testClass.getName();\n+            System.arraycopy(args, 0, newArgs, 2, args.length);\n+            ArgsHolder.args = newArgs;\n+        } else {\n+            argsOffset = 2;\n+        }\n+\n+        try {\n+            Constructor<? extends CracTest> ctor = testClass.getConstructor();\n+            CracTest testInstance = ctor.newInstance();\n+            Field[] argFields = getArgFields(testClass);\n+            for (int index = 0; index < argFields.length; index++) {\n+                Field f = argFields[index];\n+                assertFalse(Modifier.isFinal(f.getModifiers()), \"@CracTestArg fields must not be final!\");\n+                Class<?> t = f.getType();\n+                if (index + argsOffset >= args.length) {\n+                    if (f.getAnnotation(CracTestArg.class).optional()) {\n+                        break;\n+                    } else {\n+                        fail(\"Not enough args for field \" + f.getName() + \"(\" + index + \"): have \" + (args.length - argsOffset));\n+                    }\n+                }\n+                String arg = args[index + argsOffset];\n+                Object value = arg;\n+                if (t == boolean.class || t == Boolean.class) {\n+                    assertTrue(\"true\".equals(arg) || \"false\".equals(arg), \"Argument \" + index + \"Boolean arg should be either 'true' or 'false', was: \" + arg);\n+                    value = Boolean.parseBoolean(arg);\n+                } else if (t == int.class || t == Integer.class) {\n+                    try {\n+                        value = Integer.parseInt(arg);\n+                    } catch (NumberFormatException e) {\n+                        fail(\"Cannot parse argument '\" + arg + \"' as integer for @CracTestArg(\" + index + \") \" + f.getName());\n+                    }\n+                } else if (t == long.class || t == Long.class) {\n+                    try {\n+                        value = Long.parseLong(arg);\n+                    } catch (NumberFormatException e) {\n+                        fail(\"Cannot parse argument '\" + arg + \"' as long for @CracTestArg(\" + index + \") \" + f.getName());\n+                    }\n+                } else if (t.isEnum()) {\n+                    value = Enum.valueOf((Class<Enum>) t, arg);\n+                }\n+                f.setAccessible(true);\n+                f.set(testInstance, value);\n+            }\n+            if (argsOffset == 0) {\n+                testInstance.test();\n+            } else {\n+                testInstance.exec();\n+            }\n+        } catch (NoSuchMethodException e) {\n+            fail(\"Test class \" + testClass.getName() + \" is expected to have a public no-arg constructor\");\n+        }\n+    }\n+\n+    private static Field[] getArgFields(Class<? extends CracTest> testClass) {\n+        \/\/ TODO: check superclasses\n+        Field[] sortedFields = Stream.of(testClass.getDeclaredFields()).filter(f -> f.isAnnotationPresent(CracTestArg.class))\n+                .sorted(Comparator.comparingInt(f -> f.getAnnotation(CracTestArg.class).value()))\n+                .toArray(Field[]::new);\n+        if (sortedFields.length == 0) {\n+            return sortedFields;\n+        }\n+        int firstOptional = -1;\n+        for (int i = 0; i < sortedFields.length; ++i) {\n+            CracTestArg annotation = sortedFields[i].getAnnotation(CracTestArg.class);\n+            int index = annotation.value();\n+            assertGreaterThanOrEqual(index, 0);\n+            if (i == 0) {\n+                assertEquals(0, index, \"@CracTestArg numbers should start with 0\");\n+            }\n+            if (index < i) {\n+                fail(\"Duplicate @CracTestArg(\" + index + \"): both fields \" + sortedFields[i - 1].getName() + \" and \" + sortedFields[i].getName());\n+            } else if (index > i) {\n+                fail(\"Gap in @CracTestArg indices: missing \" + i + \", next is \" + index);\n+            }\n+            if (annotation.optional()) {\n+                firstOptional = index;\n+            } else if (firstOptional >= 0) {\n+                fail(\"Argument \" + firstOptional + \" is optional; all subsequent arguments must be optional, too.\");\n+            }\n+        }\n+        return sortedFields;\n+    }\n+\n+    \/**\n+     * Used as argument for {@link CracBuilder#args(String...)}.\n+     *\/\n+    static String[] args(String... extraArgs) {\n+        assertNotNull(ArgsHolder.args, \"Args are null; are you trying to access them from test method?\");\n+        if (extraArgs == null || extraArgs.length == 0) {\n+            return ArgsHolder.args;\n+        } else {\n+            return Stream.concat(Stream.of(ArgsHolder.args), Stream.of(extraArgs)).toArray(String[]::new);\n+        }\n+    }\n+\n+    static Class<? extends CracTest> testClass() {\n+        return ArgsHolder.testClass;\n+    }\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTest.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"}]}