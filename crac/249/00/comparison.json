{"files":[{"patch":"@@ -118,0 +118,1 @@\n+        Constructor<? extends CracTest> ctor;\n@@ -119,33 +120,17 @@\n-            Constructor<? extends CracTest> ctor = testClass.getConstructor();\n-            CracTest testInstance = ctor.newInstance();\n-            Field[] argFields = getArgFields(testClass);\n-            for (int index = 0; index < argFields.length; index++) {\n-                Field f = argFields[index];\n-                assertFalse(Modifier.isFinal(f.getModifiers()), \"@CracTestArg fields must not be final!\");\n-                Class<?> t = f.getType();\n-                if (index + argsOffset >= args.length) {\n-                    if (f.getAnnotation(CracTestArg.class).optional()) {\n-                        break;\n-                    } else {\n-                        fail(\"Not enough args for field \" + f.getName() + \"(\" + index + \"): have \" + (args.length - argsOffset));\n-                    }\n-                }\n-                String arg = args[index + argsOffset];\n-                Object value = arg;\n-                if (t == boolean.class || t == Boolean.class) {\n-                    assertTrue(\"true\".equals(arg) || \"false\".equals(arg), \"Argument \" + index + \"Boolean arg should be either 'true' or 'false', was: \" + arg);\n-                    value = Boolean.parseBoolean(arg);\n-                } else if (t == int.class || t == Integer.class) {\n-                    try {\n-                        value = Integer.parseInt(arg);\n-                    } catch (NumberFormatException e) {\n-                        fail(\"Cannot parse argument '\" + arg + \"' as integer for @CracTestArg(\" + index + \") \" + f.getName());\n-                    }\n-                } else if (t == long.class || t == Long.class) {\n-                    try {\n-                        value = Long.parseLong(arg);\n-                    } catch (NumberFormatException e) {\n-                        fail(\"Cannot parse argument '\" + arg + \"' as long for @CracTestArg(\" + index + \") \" + f.getName());\n-                    }\n-                } else if (t.isEnum()) {\n-                    value = Enum.valueOf((Class<Enum>) t, arg);\n+            ctor = testClass.getConstructor();\n+        } catch (NoSuchMethodException e) {\n+            fail(\"Test class \" + testClass.getName() + \" is expected to have a public no-arg constructor\");\n+            return; \/\/ Unreachable but makes the compiler sure ctor is always initialized below\n+        }\n+\n+        CracTest testInstance = ctor.newInstance();\n+        Field[] argFields = getArgFields(testClass);\n+        for (int index = 0; index < argFields.length; index++) {\n+            Field f = argFields[index];\n+            assertFalse(Modifier.isFinal(f.getModifiers()), \"@CracTestArg fields must not be final!\");\n+            Class<?> t = f.getType();\n+            if (index + argsOffset >= args.length) {\n+                if (f.getAnnotation(CracTestArg.class).optional()) {\n+                    break;\n+                } else {\n+                    fail(\"Not enough args for field \" + f.getName() + \"(\" + index + \"): have \" + (args.length - argsOffset));\n@@ -153,2 +138,0 @@\n-                f.setAccessible(true);\n-                f.set(testInstance, value);\n@@ -156,4 +139,19 @@\n-            if (argsOffset == 0) {\n-                testInstance.test();\n-            } else {\n-                testInstance.exec();\n+            String arg = args[index + argsOffset];\n+            Object value = arg;\n+            if (t == boolean.class || t == Boolean.class) {\n+                assertTrue(\"true\".equals(arg) || \"false\".equals(arg), \"Argument \" + index + \"Boolean arg should be either 'true' or 'false', was: \" + arg);\n+                value = Boolean.parseBoolean(arg);\n+            } else if (t == int.class || t == Integer.class) {\n+                try {\n+                    value = Integer.parseInt(arg);\n+                } catch (NumberFormatException e) {\n+                    fail(\"Cannot parse argument '\" + arg + \"' as integer for @CracTestArg(\" + index + \") \" + f.getName());\n+                }\n+            } else if (t == long.class || t == Long.class) {\n+                try {\n+                    value = Long.parseLong(arg);\n+                } catch (NumberFormatException e) {\n+                    fail(\"Cannot parse argument '\" + arg + \"' as long for @CracTestArg(\" + index + \") \" + f.getName());\n+                }\n+            } else if (t.isEnum()) {\n+                value = Enum.valueOf((Class<Enum>) t, arg);\n@@ -161,2 +159,7 @@\n-        } catch (NoSuchMethodException e) {\n-            fail(\"Test class \" + testClass.getName() + \" is expected to have a public no-arg constructor\");\n+            f.setAccessible(true);\n+            f.set(testInstance, value);\n+        }\n+        if (argsOffset == 0) {\n+            testInstance.test();\n+        } else {\n+            testInstance.exec();\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTest.java","additions":44,"deletions":41,"binary":false,"changes":85,"status":"modified"}]}