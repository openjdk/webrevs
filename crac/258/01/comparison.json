{"files":[{"patch":"@@ -91,0 +91,2 @@\n+char** Arguments::_jvm_restore_flags_array      = nullptr;\n+int    Arguments::_num_jvm_restore_flags        = 0;\n@@ -1044,0 +1046,4 @@\n+void Arguments::build_jvm_restore_flags(const char* arg) {\n+  add_string(&_jvm_restore_flags_array, &_num_jvm_restore_flags, arg);\n+}\n+\n@@ -1335,0 +1341,6 @@\n+    } else if (strcmp(key, \"sun.java.crac_command\") == 0) {\n+      char *old_java_command_crac = _java_command_crac;\n+      _java_command_crac = os::strdup_check_oom(value, mtArguments);\n+      if (old_java_command_crac != nullptr) {\n+        os::free(old_java_command_crac);\n+      }\n@@ -2171,83 +2183,0 @@\n-bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n-  const char* tail;\n-  \/\/ iterate over arguments\n-  for (int index = 0; index < args->nOptions; index++) {\n-    const JavaVMOption* option = args->options + index;\n-    if (!match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n-      continue;\n-    }\n-    \/\/ ccstr is never set to an empty string by the parser so we should not\n-    \/\/ treat an empty string value as the option being set. If it ever becomes\n-    \/\/ ccstrlist or the parser changes, the value check will need to be removed.\n-    static_assert(std::is_same<ccstr, decltype(CRaCRestoreFrom)>(), \"expected ccstr\");\n-    const char* eq = strchr(tail, '=');\n-    if (eq != nullptr && eq[1] != '\\0') {\n-      return true; \/\/ the value is not an empty string\n-    }\n-  }\n-  return false;\n-}\n-\n-bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n-  const char *tail = nullptr;\n-\n-  \/\/ iterate over arguments\n-  for (int index = 0; index < args->nOptions; index++) {\n-    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n-\n-    const JavaVMOption* option = args->options + index;\n-\n-    if (match_option(option, \"-Djava.class.path\", &tail) ||\n-        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n-      \/\/ These options are already set based on -cp (and aliases), -jar\n-      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n-      \/\/ late to prohibit explicitly setting them at this point.\n-    } else if (match_option(option, \"-D\", &tail)) {\n-      const char* key = nullptr;\n-      const char* value = nullptr;\n-\n-      get_key_value(tail, &key, &value);\n-\n-      if (strcmp(key, \"sun.java.crac_command\") == 0) {\n-        char *old_java_command = _java_command_crac;\n-        _java_command_crac = os::strdup_check_oom(value, mtArguments);\n-        if (old_java_command != nullptr) {\n-          os::free(old_java_command);\n-        }\n-      } else {\n-        add_property(tail);\n-      }\n-\n-      if (key != tail) { \/\/ key was copied\n-        FreeHeap(const_cast<char *>(key));\n-      }\n-    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n-      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n-        return false;\n-      }\n-      const char *argname;\n-      size_t arg_len;\n-      bool ignored_plus_minus;\n-      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n-      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n-      if (flag != nullptr) {\n-        if (!flag->is_restore_settable()) {\n-          jio_fprintf(defaultStream::error_stream(),\n-            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n-          return false;\n-        }\n-        build_jvm_flags(tail);\n-      }\n-    }\n-  }\n-\n-  postcond(CRaCRestoreFrom != nullptr);\n-\n-  if (CRaCEngineOptions && strcmp(CRaCEngineOptions, \"help\") == 0) {\n-    crac::print_engine_info_and_exit(); \/\/ Does not return on success\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n@@ -3009,0 +2938,84 @@\n+\/\/ arg is a JVM argument without the leading \"-XX:\", e.g. \"+BoolOpt\" or \"StrOpt=str\"\n+bool Arguments::process_flag_for_restore(const char *arg) {\n+  \/\/ -XX:Flags and -XX:VMOptionsFile do not have corresponding JVMFlags\n+  if ((strncmp(arg, \"Flags=\", ARRAY_SIZE(\"Flags=\") - 1) == 0) ||\n+      (strncmp(arg, \"VMOptionsFile=\", ARRAY_SIZE(\"VMOptionsFile=\") - 1) == 0)) {\n+    return true;\n+  }\n+\n+  const char* name;\n+  size_t name_len;\n+  bool has_plus_minus;\n+  parse_argname(arg, &name, &name_len, &has_plus_minus);\n+\n+  const JVMFlag* flag;\n+  {\n+    char buf[BUFLEN + 1];\n+    const char* stripped_name;\n+    if (name[name_len] == '\\0') {\n+      stripped_name = name;\n+    } else {\n+      guarantee(name_len <= BUFLEN, \"argument name too long: %s\", name); \/\/ Should've been detected earlier\n+      strncpy(buf, name, name_len);\n+      buf[name_len] = '\\0';\n+      stripped_name = buf;\n+    }\n+    flag = JVMFlag::find_declared_flag(real_flag_name(stripped_name));\n+    guarantee(flag != nullptr, \"unknown JVM flag name: %s\", name); \/\/ Should've been detected earlier\n+  }\n+  assert(has_plus_minus == flag->is_bool(), \"sanity check\");\n+\n+  if (flag->is_restore_settable()) {\n+    \/\/ Restored JVM will search for the flag using the name we record here so we\n+    \/\/ must ensure the real one is recorded\n+    if (strcmp(flag->name(), name) == 0) {\n+      build_jvm_restore_flags(arg);\n+    } else {\n+      const size_t real_arg_len = strlen(arg) + (strlen(flag->name()) - name_len);\n+      char* const real_arg = AllocateHeap(real_arg_len + 1, MemTag::mtArguments);\n+      const int ret = has_plus_minus ?\n+        jio_snprintf(real_arg, real_arg_len + 1, \"%c%s\", arg[0], flag->name()) :\n+        jio_snprintf(real_arg, real_arg_len + 1, \"%s%s\", flag->name(), arg + name_len);\n+      guarantee(ret >= 0 && checked_cast<size_t>(ret) == real_arg_len, \"snprintf failed: %i\", ret);\n+      build_jvm_restore_flags(real_arg);\n+      FreeHeap(real_arg);\n+    }\n+  } else if (!CRaCIgnoreRestoreIfUnavailable) {\n+    \/\/ Same message format as used in JVMFlag::get_locked_message() for\n+    \/\/ diagnostic\/experimental\/develop options\n+    jio_fprintf(defaultStream::error_stream(),\n+                \"Error: VM option '%*.s' is not restore-settable and is not available on restore.\\n\",\n+                name_len, name);\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool Arguments::process_flags_for_restore() {\n+  precond(CRaCRestoreFrom != nullptr);\n+\n+  char** const vm_flags = Arguments::jvm_flags_array();\n+  for (int i = 0; i < Arguments::num_jvm_flags(); i++) {\n+    if (!process_flag_for_restore(vm_flags[i])) {\n+      return false;\n+    }\n+  }\n+\n+  char** const vm_args = Arguments::jvm_args_array();\n+  for (int i = 0; i < Arguments::num_jvm_args(); i++) {\n+    const JavaVMOption opt{vm_args[i]};\n+    const char *tail;\n+    \/\/ FIXME: other kinds of arguments can also lead to VM flags being set so\n+    \/\/  ideally we would want to process those too. But there seems to be no way\n+    \/\/  to do this except highly intrusive (add processing into each special\n+    \/\/  branch of arguments parsing) or performance-costly (iterate through all\n+    \/\/  JVMFlags) ones.\n+    if (match_option(&opt, \"-XX:\", &tail) && !process_flag_for_restore(tail)) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n@@ -3092,0 +3105,3 @@\n+  if (CRaCRestoreFrom && !process_flags_for_restore()) {\n+    return JNI_EINVAL;\n+  }\n@@ -4204,0 +4220,12 @@\n+\n+void Arguments::free_restore_only_data() {\n+  os::free(_java_command_crac);\n+  _java_command_crac = nullptr;\n+\n+  for (int i = 0; i < _num_jvm_restore_flags; i++) {\n+    os::free(_jvm_restore_flags_array[i]);\n+  }\n+  FREE_C_HEAP_ARRAY(char*, _jvm_restore_flags_array);\n+  _num_jvm_restore_flags = 0;\n+  _jvm_restore_flags_array = nullptr;\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":111,"deletions":83,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -199,0 +199,3 @@\n+  \/\/ an array containing all restore-settable jvm flags specified in any way on restore\n+  static char** _jvm_restore_flags_array;\n+  static int    _num_jvm_restore_flags;\n@@ -201,0 +204,1 @@\n+  \/\/ same as _java_command but with spaces inside args escaped\n@@ -357,0 +361,1 @@\n+  static void build_jvm_restore_flags(const char* arg);\n@@ -409,0 +414,1 @@\n+  static char** jvm_restore_flags_array()  { return _jvm_restore_flags_array; }\n@@ -411,0 +417,1 @@\n+  static int num_jvm_restore_flags()       { return _num_jvm_restore_flags; }\n@@ -413,1 +420,1 @@\n-  static const char* java_command_crac()        { return _java_command_crac; }\n+  static const char* java_command_crac()   { return _java_command_crac; }\n@@ -535,1 +542,2 @@\n-  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+  static bool process_flag_for_restore(const char *arg);\n+  static bool process_flags_for_restore();\n@@ -537,1 +545,1 @@\n-  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+  static void free_restore_only_data();\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-        Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n+        Arguments::jvm_restore_flags_array(), Arguments::num_jvm_restore_flags(),\n@@ -635,0 +635,5 @@\n+        \/\/ A single ccstrlist flag can be specified multiple times meaning those\n+        \/\/ should be concatenated. But with the current code the last occurence\n+        \/\/ will just overwrite the previous ones.\n+        assert(!JVMFlag::find_flag(cursor)->ccstr_accumulates(),\n+               \"setting ccstrlist flags on restore is not supported: %s\", cursor);\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -429,9 +429,0 @@\n-static jint check_for_restore(JavaVMInitArgs* args) {\n-  if (Arguments::is_restore_option_set(args)) {\n-    if (!Arguments::parse_options_for_restore(args)) {\n-      return JNI_ERR;\n-    }\n-  }\n-  return JNI_OK;\n-}\n-\n@@ -495,2 +486,0 @@\n-  if (check_for_restore(args) != JNI_OK) return JNI_ERR;\n-\n@@ -631,0 +620,1 @@\n+  Arguments::free_restore_only_data(); \/\/ Not needed anymore\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2025, Azul Systems, Inc. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.lib.crac.CracProcess;\n@@ -33,0 +34,1 @@\n+import java.nio.file.Files;\n@@ -34,0 +36,1 @@\n+import java.util.*;\n@@ -45,0 +48,2 @@\n+    private static final String RESTORE_MSG = \"RESTORED\";\n+\n@@ -47,3 +52,1 @@\n-        final String enginePath = Path.of(Utils.TEST_JDK, \"lib\", \"criuengine\").toString();\n-\n-        CracBuilder builder = new CracBuilder();\n+        final var enginePath = Path.of(Utils.TEST_JDK, \"lib\", \"criuengine\").toString();\n@@ -51,0 +54,1 @@\n+        CracBuilder builder = new CracBuilder().captureOutput(true);\n@@ -56,0 +60,1 @@\n+        \/\/ 1) Only restore-settable options => should succeed\n@@ -61,1 +66,2 @@\n-        builder.doRestore();\n+        builder.vmOption(\"-XX:+UnlockExperimentalVMOptions\");\n+        checkRestoreOutput(builder.doRestore());\n@@ -63,1 +69,1 @@\n-        \/\/ Setting non-manageable option\n+        \/\/ 2) Adding a non-restore-settable option => should fail\n@@ -66,0 +72,24 @@\n+\n+        \/\/ 3) Non-restore-settable option from before + allowing restore to fail => should succeed\n+        builder.vmOption(\"-XX:+CRaCIgnoreRestoreIfUnavailable\");\n+        checkRestoreOutput(builder.doRestore());\n+\n+        \/\/ 4) Only restore-settable options one of which is aliased => should succeed\n+        \/\/ TODO: once we have aliased restore-settable boolean options include them here\n+        builder.clearVmOptions();\n+        builder.vmOption(\"-XX:CREngine=\" + enginePath); \/\/ Deprecated alias\n+        builder.vmOption(\"-XX:CRaCEngineOptions=args=-v2\");\n+        builder.vmOption(\"-XX:CRaCCheckpointTo=another\");\n+        builder.vmOption(\"-XX:CRaCIgnoredFileDescriptors=42,43\");\n+        builder.vmOption(\"-XX:+UnlockExperimentalVMOptions\");\n+        checkRestoreOutput(builder.doRestore());\n+\n+        \/\/ 5) Same as (1) but options come from a settings file => should succeed\n+        builder.clearVmOptions();\n+        builder.vmOption(\"-XX:Flags=\" + createSettingsFile(enginePath));\n+        checkRestoreOutput(builder.doRestore());\n+\n+        \/\/ 6) Same as (1) but options come from a VM options file => should succeed\n+        builder.clearVmOptions();\n+        builder.vmOption(\"-XX:VMOptionsFile=\" + createVMOptionsFile(enginePath));\n+        checkRestoreOutput(builder.doRestore());\n@@ -73,3 +103,3 @@\n-            VMOption engine1 = bean.getVMOption(\"CRaCEngine\");\n-            assertEquals(\"criuengine\", engine1.getValue());\n-            assertEquals(VMOption.Origin.VM_CREATION, engine1.getOrigin());\n+            VMOption engine = bean.getVMOption(\"CRaCEngine\");\n+            assertEquals(\"criuengine\", engine.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engine.getOrigin());\n@@ -77,3 +107,3 @@\n-            VMOption engineOptions1 = bean.getVMOption(\"CRaCEngineOptions\");\n-            assertEquals(\"args=-v1\", engineOptions1.getValue());\n-            assertEquals(VMOption.Origin.VM_CREATION, engineOptions1.getOrigin());\n+            VMOption engineOptions = bean.getVMOption(\"CRaCEngineOptions\");\n+            assertEquals(\"args=-v1\", engineOptions.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engineOptions.getOrigin());\n@@ -81,3 +111,3 @@\n-            VMOption checkpointTo1 = bean.getVMOption(\"CRaCCheckpointTo\");\n-            assertEquals(\"cr\", checkpointTo1.getValue());\n-            assertEquals(VMOption.Origin.VM_CREATION, checkpointTo1.getOrigin());\n+            VMOption checkpointTo = bean.getVMOption(\"CRaCCheckpointTo\");\n+            assertEquals(\"cr\", checkpointTo.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, checkpointTo.getOrigin());\n@@ -85,3 +115,3 @@\n-            VMOption restoreFrom1 = bean.getVMOption(\"CRaCRestoreFrom\");\n-            assertEquals(\"\", restoreFrom1.getValue());\n-            assertEquals(VMOption.Origin.DEFAULT, restoreFrom1.getOrigin());\n+            VMOption nmt = bean.getVMOption(\"NativeMemoryTracking\");\n+            assertEquals(\"off\", nmt.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, nmt.getOrigin());\n@@ -89,3 +119,7 @@\n-            VMOption nmt1 = bean.getVMOption(\"NativeMemoryTracking\");\n-            assertEquals(\"off\", nmt1.getValue());\n-            assertEquals(VMOption.Origin.VM_CREATION, nmt1.getOrigin());\n+            VMOption restoreFrom = bean.getVMOption(\"CRaCRestoreFrom\");\n+            assertEquals(\"\", restoreFrom.getValue());\n+            assertEquals(VMOption.Origin.DEFAULT, restoreFrom.getOrigin());\n+\n+            VMOption unlockExperimentalOpts = bean.getVMOption(\"UnlockExperimentalVMOptions\");\n+            assertEquals(\"false\", unlockExperimentalOpts.getValue());\n+            assertEquals(VMOption.Origin.DEFAULT, unlockExperimentalOpts.getOrigin());\n@@ -95,0 +129,1 @@\n+        System.out.println(RESTORE_MSG);\n@@ -101,3 +136,3 @@\n-            VMOption engine2 = bean.getVMOption(\"CRaCEngine\");\n-            assertEquals(\"criuengine\", engine2.getValue());\n-            assertEquals(VMOption.Origin.VM_CREATION, engine2.getOrigin());\n+            VMOption engine = bean.getVMOption(\"CRaCEngine\");\n+            assertEquals(\"criuengine\", engine.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engine.getOrigin());\n@@ -105,3 +140,7 @@\n-            VMOption engineOptions2 = bean.getVMOption(\"CRaCEngineOptions\");\n-            assertEquals(\"args=-v1\", engineOptions2.getValue());\n-            assertEquals(VMOption.Origin.VM_CREATION, engineOptions2.getOrigin());\n+            VMOption engineOptions = bean.getVMOption(\"CRaCEngineOptions\");\n+            assertEquals(\"args=-v1\", engineOptions.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, engineOptions.getOrigin());\n+\n+            VMOption nmt = bean.getVMOption(\"NativeMemoryTracking\");\n+            assertEquals(\"off\", nmt.getValue());\n+            assertEquals(VMOption.Origin.VM_CREATION, nmt.getOrigin());\n@@ -111,3 +150,3 @@\n-            VMOption checkpointTo2 = bean.getVMOption(\"CRaCCheckpointTo\");\n-            assertEquals(\"another\", checkpointTo2.getValue());\n-            assertEquals(VMOption.Origin.OTHER, checkpointTo2.getOrigin());\n+            VMOption checkpointTo = bean.getVMOption(\"CRaCCheckpointTo\");\n+            assertEquals(\"another\", checkpointTo.getValue());\n+            assertEquals(VMOption.Origin.OTHER, checkpointTo.getOrigin());\n@@ -115,3 +154,3 @@\n-            VMOption restoreFrom2 = bean.getVMOption(\"CRaCRestoreFrom\");\n-            assertEquals(\"cr\", restoreFrom2.getValue());\n-            assertEquals(VMOption.Origin.OTHER, restoreFrom2.getOrigin());\n+            VMOption restoreFrom = bean.getVMOption(\"CRaCRestoreFrom\");\n+            assertEquals(\"cr\", restoreFrom.getValue());\n+            assertEquals(VMOption.Origin.OTHER, restoreFrom.getOrigin());\n@@ -123,3 +162,3 @@\n-            VMOption nmt = bean.getVMOption(\"NativeMemoryTracking\");\n-            assertEquals(\"off\", nmt.getValue());\n-            assertEquals(VMOption.Origin.VM_CREATION, nmt.getOrigin());\n+            VMOption unlockExperimentalOpts = bean.getVMOption(\"UnlockExperimentalVMOptions\");\n+            assertEquals(\"true\", unlockExperimentalOpts.getValue());\n+            assertEquals(VMOption.Origin.OTHER, unlockExperimentalOpts.getOrigin());\n@@ -128,0 +167,31 @@\n+\n+    private static void checkRestoreOutput(CracProcess restored) throws Exception {\n+        restored.outputAnalyzer()\n+            .shouldNotContain(\"[warning]\")\n+            .shouldNotContain(\"[error]\")\n+            .stdoutShouldContain(RESTORE_MSG);\n+    }\n+\n+    private static String createSettingsFile(String enginePath) throws Exception {\n+        final var path = Utils.createTempFile(\"settings\", \".txt\");\n+        Files.write(path, List.of(\n+            \"CRaCEngine=\" + enginePath,\n+            \"CRaCEngineOptions=args=-v2\",\n+            \"CRaCCheckpointTo=another\",\n+            \"CRaCIgnoredFileDescriptors=42,43\",\n+            \"+UnlockExperimentalVMOptions\"\n+        ));\n+        return path.toString();\n+    }\n+\n+    private static String createVMOptionsFile(String enginePath) throws Exception {\n+        final var path = Utils.createTempFile(\"vmoptions\", \".txt\");\n+        Files.write(path, List.of(\n+            \"-XX:CRaCEngine=\" + enginePath,\n+            \"-XX:CRaCEngineOptions=args=-v2\",\n+            \"-XX:CRaCCheckpointTo=another\",\n+            \"-XX:CRaCIgnoredFileDescriptors=42,43\",\n+            \"-XX:+UnlockExperimentalVMOptions\"\n+        ));\n+        return path.toString();\n+    }\n","filename":"test\/jdk\/jdk\/crac\/VMOptionsTest.java","additions":106,"deletions":36,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -83,2 +83,5 @@\n-        test(\"simengine\", \"image_location=cr\", 0,\n-                \"VM-controlled CRaC engine option provided, skipping: image_location\");\n+        test(\"simengine\", \"args=simengine ignores this\", 0,\n+                \"CRaC engine option: 'args' = 'simengine ignores this'\");\n+        test(\"simengine\", Arrays.asList(\"image_location=cr\"), 0,\n+                Arrays.asList(\"VM-controlled CRaC engine option provided, skipping: image_location\"),\n+                Arrays.asList(\"[error]\") \/* warning are expected (VM-controlled option used), errors are not *\/);\n@@ -86,1 +89,4 @@\n-            test(\"criuengine\", Arrays.asList(\"keep_running=true,args=-v -v -v -v\"), 0,\n+            test(\"criuengine\", \"keep_running=true,args=-v -v -v -v\", 0,\n+                    \"CRaC engine option: 'keep_running' = 'true'\",\n+                    \"CRaC engine option: 'args' = '-v -v -v -v'\");\n+            test(\"criuengine\", Arrays.asList(\"keep_running=true,args=-v -v -v -v,keep_running=false\"), 0,\n@@ -89,8 +95,4 @@\n-                        \"CRaC engine option: 'args' = '-v -v -v -v'\"\n-                    ),\n-                    Arrays.asList(\"specified multiple times\"));\n-            test(\"criuengine\", \"keep_running=true,args=-v -v -v -v,keep_running=false\", 0,\n-                    \"CRaC engine option: 'keep_running' = 'true'\",\n-                    \"CRaC engine option: 'args' = '-v -v -v -v'\",\n-                    \"CRaC engine option: 'keep_running' = 'false'\",\n-                    \"CRaC engine option 'keep_running' specified multiple times\");\n+                        \"CRaC engine option: 'args' = '-v -v -v -v'\",\n+                        \"CRaC engine option: 'keep_running' = 'false'\",\n+                        \"CRaC engine option 'keep_running' specified multiple times\"),\n+                    Arrays.asList(\"[error]\") \/* warning are expected (repeated 'keep_running'), errors are not *\/);\n@@ -147,1 +149,1 @@\n-                Collections.emptyList());\n+                Arrays.asList(\"[error]\") \/* warning are expected (repeated 'args'), errors are not *\/);\n@@ -188,0 +190,4 @@\n+        if (expectedExitValue == 0 && notExpectedTexts.isEmpty()) {\n+            notExpectedTexts = Arrays.asList(\"[warning]\", \"[error]\");\n+        }\n+\n@@ -196,0 +202,1 @@\n+\n","filename":"test\/jdk\/jdk\/crac\/engineOptions\/ParsingTest.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -76,1 +76,3 @@\n-                OutputAnalyzer oa = builder.captureOutput(true).startRestore().outputAnalyzer().shouldContain(\"cannot be set during restore\").shouldNotHaveExitValue(0);\n+                builder.captureOutput(true).startRestore().outputAnalyzer()\n+                    .shouldContain(\"is not restore-settable and is not available on restore\")\n+                    .shouldNotHaveExitValue(0);\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/LoggingVMlogOpenTestNegative.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}