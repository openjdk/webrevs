{"files":[{"patch":"@@ -956,1 +956,0 @@\n-static bool from_reexec;\n@@ -963,0 +962,1 @@\n+  bool from_reexec = getenv(REEXEC_NAME) != nullptr;\n@@ -1069,2 +1069,0 @@\n-  from_reexec = getenv(REEXEC_NAME) != nullptr;\n-\n@@ -1200,2 +1198,0 @@\n-\/\/ There is no CPU_FEATURE_ACTIVE() available for this symbol.\n-#define EXCESSIVE_GLIBC_PREFERRED(tunables) EXCESSIVE2(tunables, !from_reexec)\n@@ -1232,1 +1228,4 @@\n-  EXCESSIVE_GLIBC_PREFERRED(AVX_Fast_Unaligned_Load);\n+  \/\/ There is no CPU_FEATURE_ACTIVE() available for this symbol.\n+  \/\/ The detection is a copy from glibc sysdeps\/x86\/cpu-features.c .\n+  \/\/ There is no check for 'xem_xcr0_eax.bits.sse != 0 && xem_xcr0_eax.bits.ymm != 0' but FEATURE_ACTIVE(AVX) depends on it so it can be assumed.\n+  EXCESSIVE2(AVX_Fast_Unaligned_Load, FEATURE_ACTIVE(OSXSAVE) && FEATURE_ACTIVE(AVX) && FEATURE_ACTIVE(AVX2));\n@@ -3659,1 +3658,1 @@\n-  \/\/ sysdeps\/x86\/cpu-features.c\n+  \/\/ The detection is a copy from glibc sysdeps\/x86\/cpu-features.c .\n@@ -3661,6 +3660,5 @@\n-    if (xem_xcr0_eax.bits.sse != 0 &&\n-        xem_xcr0_eax.bits.ymm != 0) {\n-      if (vm_features.supports_feature(CPU_AVX)) {\n-        if (vm_features.supports_feature(CPU_AVX2)) {\n-          vm_features.set_feature(CPU_AVX_Fast_Unaligned_Load);\n-        }\n+    if (vm_features.supports_feature(CPU_AVX)) {\n+      assert(xem_xcr0_eax.bits.sse != 0, \"required by CPU_AVX\");\n+      assert(xem_xcr0_eax.bits.ymm != 0, \"required by CPU_AVX\");\n+      if (vm_features.supports_feature(CPU_AVX2)) {\n+        vm_features.set_feature(CPU_AVX_Fast_Unaligned_Load);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"}]}