{"files":[{"patch":"@@ -170,1 +170,3 @@\n-        jdk.sctp;\n+        java.rmi,\n+        jdk.sctp,\n+        jdk.management.agent;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -288,1 +293,1 @@\n-        if (exportCount == 0 && getEndpoint().getListenPort() != 0) {\n+        if (exportCount == 0) {\n@@ -653,1 +658,1 @@\n-    private class ConnectionHandler implements Runnable {\n+    private class ConnectionHandler implements Runnable, JDKResource {\n@@ -676,0 +681,1 @@\n+            Core.Priority.NORMAL.getContext().register(this);\n@@ -867,0 +873,10 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            closeSocket(socket);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            \/\/ noop, the connection is not reopened\n+        }\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPTransport.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -55,0 +55,5 @@\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -260,0 +265,1 @@\n+    private static JMXConnectorServer localServer = null;\n@@ -262,0 +268,1 @@\n+    private static JDKResource cracResource;\n@@ -318,2 +325,2 @@\n-            JMXConnectorServer cs = ConnectorBootstrap.startLocalConnectorServer();\n-            String address = cs.getAddress().toString();\n+            localServer = ConnectorBootstrap.startLocalConnectorServer();\n+            String address = localServer.getAddress().toString();\n@@ -334,0 +341,14 @@\n+    private static synchronized void stopLocalManagementAgent() throws IOException {\n+        Properties agentProps = VMSupport.getAgentProperties();\n+        agentProps.remove(LOCAL_CONNECTOR_ADDRESS_PROP);\n+        try {\n+            localServer.stop();\n+            localServer = null;\n+        } catch (IOException e) {\n+            warning(CONNECTOR_SERVER_IO_ERROR, e.getMessage());\n+            \/\/ rethrowing to fail the checkpoint\n+            throw e;\n+        }\n+        ConnectorAddressLink.unexportLocal();\n+    }\n+\n@@ -452,0 +473,15 @@\n+            if (cracResource == null) {\n+                cracResource = new JDKResource() {\n+                    @Override\n+                    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                        stopRemoteManagementAgent();\n+                        stopLocalManagementAgent();\n+                    }\n+\n+                    @Override\n+                    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                        startAgent();\n+                    }\n+                };\n+                Core.Priority.NORMAL.getContext().register(cracResource);\n+            }\n","filename":"src\/jdk.management.agent\/share\/classes\/jdk\/internal\/agent\/Agent.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -31,4 +31,2 @@\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n@@ -63,0 +61,10 @@\n+\n+        private void putString(String str) {\n+            byte[] bytes = str.getBytes(StandardCharsets.UTF_8);\n+            if (bytes.length + 1 > bb.capacity()) {\n+                throw new IllegalArgumentException(\"Address is too long\");\n+            }\n+            bb.clear();\n+            bb.put(0, bytes, 0, bytes.length);\n+            bb.put(bytes.length, (byte) 0);\n+        }\n@@ -102,0 +110,1 @@\n+    private static PerfHandle localPerfHandle = null;\n@@ -114,3 +123,12 @@\n-        Perf perf = Perf.getPerf();\n-        perf.createString(\n-            CONNECTOR_ADDRESS_COUNTER, 1, Units.STRING.intValue(), address);\n+        if (localPerfHandle == null) {\n+            Perf perf = Perf.getPerf();\n+            byte[] addressBytes = address.getBytes(StandardCharsets.UTF_8);\n+            \/\/ These 2kB is a magic constant - should we make it tunable via system property?\n+            byte[] bytes = new byte[Math.max(addressBytes.length + 1, 2048)];\n+            System.arraycopy(addressBytes, 0, bytes, 0, addressBytes.length);\n+            Arrays.fill(bytes, addressBytes.length, bytes.length, (byte) 0);\n+            localPerfHandle = new PerfHandle(perf.createString(\n+                    CONNECTOR_ADDRESS_COUNTER, 3, Units.STRING.intValue(), address));\n+        } else {\n+            localPerfHandle.putString(address);\n+        }\n@@ -123,0 +141,4 @@\n+    public static void unexportLocal() {\n+        localPerfHandle.putString(\"\");\n+    }\n+\n","filename":"src\/jdk.management.agent\/share\/classes\/jdk\/internal\/agent\/ConnectorAddressLink.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.management.*;\n+\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import javax.management.JMX;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+import javax.management.remote.JMXConnector;\n+import javax.management.remote.JMXConnectorFactory;\n+import javax.management.remote.JMXServiceURL;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build RemoteJmxTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class RemoteJmxTest implements CracTest {\n+    private static final String PORT = \"9995\";\n+    private static final String BOOTED = \"BOOTED\";\n+    private static final String RESTORED = \"RESTORED\";\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder().captureOutput(true);\n+        builder.javaOption(\"java.rmi.server.hostname\", \"localhost\")\n+                .javaOption(\"com.sun.management.jmxremote\", \"true\")\n+                .javaOption(\"com.sun.management.jmxremote.port\", PORT)\n+                .javaOption(\"com.sun.management.jmxremote.rmi.port\", PORT)\n+                .javaOption(\"com.sun.management.jmxremote.ssl\", \"false\")\n+                .javaOption(\"com.sun.management.jmxremote.authenticate\", \"false\")\n+                .javaOption(\"sun.rmi.transport.tcp.logLevel\", \"FINER\")\n+                .javaOption(\"jdk.crac.collect-fd-stacktraces\", \"true\");\n+        CracProcess checkpointed = builder.startCheckpoint();\n+        checkpointed.waitForStdout(BOOTED);\n+        assertEquals(-1L, getUptimeFromRestoreFromJmx());\n+        checkpointed.sendNewline();\n+        checkpointed.waitForCheckpointed();\n+        CracProcess restored = builder.startRestore();\n+        restored.waitForStdout(RESTORED);\n+        assertGreaterThanOrEqual(getUptimeFromRestoreFromJmx(), 0L);\n+        restored.sendNewline();\n+        restored.waitForSuccess();\n+    }\n+\n+    private long getUptimeFromRestoreFromJmx() throws IOException, MalformedObjectNameException {\n+        JMXConnector conn = JMXConnectorFactory.connect(new JMXServiceURL(\"service:jmx:rmi:\/\/\/jndi\/rmi:\/\/localhost:\" + PORT + \"\/jmxrmi\"));\n+        CRaCMXBean cracBean = JMX.newMBeanProxy(conn.getMBeanServerConnection(), new ObjectName(\"jdk.management:type=CRaC\"), CRaCMXBean.class);\n+        return cracBean.getUptimeSinceRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(BOOTED);\n+        assertEquals((int)'\\n', System.in.read());\n+        Core.checkpointRestore();\n+        System.out.println(RESTORED);\n+        assertEquals((int)'\\n', System.in.read());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RemoteJmxTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -10,0 +10,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -39,1 +40,6 @@\n-            assertEquals(137, process.waitFor(), \"Checkpointed process was not killed as expected.\");\n+            int expected = 137;\n+            int actual = process.waitFor();\n+            if (expected != actual && builder.captureOutput) {\n+                printOutput();\n+            }\n+            assertEquals(expected, actual, \"Checkpointed process was not killed as expected.\");\n@@ -99,7 +105,1 @@\n-            try {\n-                OutputAnalyzer oa = outputAnalyzer();\n-                System.err.print(oa.getStderr());\n-                System.out.print(oa.getStdout());\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n+            printOutput();\n@@ -112,0 +112,10 @@\n+    private void printOutput() {\n+        try {\n+            OutputAnalyzer oa = outputAnalyzer();\n+            System.err.print(oa.getStderr());\n+            System.out.print(oa.getStdout());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n@@ -124,0 +134,12 @@\n+    public void waitForStdout(String str) throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        watch(line -> {\n+            if (line.equals(str)) {\n+                latch.countDown();\n+            } else {\n+                throw new IllegalArgumentException(\"Unexpected input\");\n+            }\n+        }, System.err::println);\n+        assertTrue(latch.await(10, TimeUnit.SECONDS));\n+    }\n+\n@@ -140,0 +162,6 @@\n+\n+    public void sendNewline() throws IOException {\n+        OutputStream input = process.getOutputStream();\n+        input.write('\\n');\n+        input.flush();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":36,"deletions":8,"binary":false,"changes":44,"status":"modified"}]}