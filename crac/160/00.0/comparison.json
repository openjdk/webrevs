{"files":[{"patch":"@@ -506,0 +506,16 @@\n+################################################################################\n+# Filter the unsupported feature combinations.\n+# This is called after JVM_FEATURES_ACTIVE are fully populated.\n+#\n+AC_DEFUN([JVM_FEATURES_FILTER_UNSUPPORTED],\n+[\n+  # G1 late barrier expansion in C2 is not implemented for some platforms.\n+  # Choose not to support G1 in this configuration.\n+  if JVM_FEATURES_IS_ACTIVE(compiler2); then\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86\"; then\n+      AC_MSG_NOTICE([G1 cannot be used with C2 on this platform, disabling G1])\n+      UTIL_GET_NON_MATCHING_VALUES(JVM_FEATURES_ACTIVE, $JVM_FEATURES_ACTIVE, \"g1gc\")\n+    fi\n+  fi\n+])\n+\n@@ -581,0 +597,3 @@\n+    # Filter unsupported feature combinations from JVM_FEATURES_ACTIVE.\n+    JVM_FEATURES_FILTER_UNSUPPORTED\n+\n","filename":"make\/autoconf\/jvm-features.m4","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2774,1 +2774,1 @@\n-    rp = os::Posix::realpath(dli_fname, buf, buflen);\n+    rp = os::realpath(dli_fname, buf, buflen);\n@@ -2808,1 +2808,1 @@\n-        rp = os::Posix::realpath(java_home_var, buf, buflen);\n+        rp = os::realpath(java_home_var, buf, buflen);\n@@ -2829,1 +2829,1 @@\n-          rp = os::Posix::realpath(dli_fname, buf, buflen);\n+          rp = os::realpath(dli_fname, buf, buflen);\n@@ -5064,10 +5064,0 @@\n-\/\/ return current position of file pointer\n-jlong os::current_file_offset(int fd) {\n-  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);\n-}\n-\n-\/\/ move file pointer to the specified offset\n-jlong os::seek_to_file_offset(int fd, jlong offset) {\n-  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-void os::check_dump_limit(char* buffer, size_t bufferSize) {\n+void os::check_core_dump_prerequisites(char* buffer, size_t bufferSize, bool check_only) {\n@@ -112,13 +112,7 @@\n-    return;\n-  }\n-\n-  int n;\n-  struct rlimit rlim;\n-  bool success;\n-\n-  char core_path[PATH_MAX];\n-  n = get_core_path(core_path, PATH_MAX);\n-\n-  if (n <= 0) {\n-    jio_snprintf(buffer, bufferSize, \"core.%d (may not exist)\", current_process_id());\n-    success = true;\n+  } else {\n+    struct rlimit rlim;\n+    bool success = true;\n+    bool warn = true;\n+    char core_path[PATH_MAX];\n+    if (get_core_path(core_path, PATH_MAX) <= 0) {\n+      jio_snprintf(buffer, bufferSize, \"core.%d (may not exist)\", current_process_id());\n@@ -126,3 +120,2 @@\n-  } else if (core_path[0] == '\"') { \/\/ redirect to user process\n-    jio_snprintf(buffer, bufferSize, \"Core dumps may be processed with %s\", core_path);\n-    success = true;\n+    } else if (core_path[0] == '\"') { \/\/ redirect to user process\n+      jio_snprintf(buffer, bufferSize, \"Core dumps may be processed with %s\", core_path);\n@@ -130,17 +123,21 @@\n-  } else if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n-    jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n-    success = true;\n-  } else {\n-    switch(rlim.rlim_cur) {\n-      case RLIM_INFINITY:\n-        jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n-        success = true;\n-        break;\n-      case 0:\n-        jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n-        success = false;\n-        break;\n-      default:\n-        jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n-        success = true;\n-        break;\n+    } else if (getrlimit(RLIMIT_CORE, &rlim) != 0) {\n+      jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n+    } else {\n+      switch(rlim.rlim_cur) {\n+        case RLIM_INFINITY:\n+          jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n+          warn = false;\n+          break;\n+        case 0:\n+          jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n+          success = false;\n+          break;\n+        default:\n+          jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n+          break;\n+      }\n+    }\n+    if (!check_only) {\n+      VMError::record_coredump_status(buffer, success);\n+    } else if (warn) {\n+      warning(\"CreateCoredumpOnCrash specified, but %s\", buffer);\n@@ -149,2 +146,0 @@\n-\n-  VMError::record_coredump_status(buffer, success);\n@@ -352,0 +347,10 @@\n+\/\/ return current position of file pointer\n+jlong os::current_file_offset(int fd) {\n+  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);\n+}\n+\n+\/\/ move file pointer to the specified offset\n+jlong os::seek_to_file_offset(int fd, jlong offset) {\n+  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);\n+}\n+\n@@ -1040,1 +1045,1 @@\n-char* os::Posix::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n+char* os::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n@@ -1043,1 +1048,1 @@\n-    assert(false, \"os::Posix::realpath: invalid arguments.\");\n+    assert(false, \"os::realpath: invalid arguments.\");\n@@ -1078,1 +1083,0 @@\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":43,"deletions":39,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -77,7 +77,0 @@\n-  \/\/ A safe implementation of realpath which will not cause a buffer overflow if the resolved path\n-  \/\/   is longer than PATH_MAX.\n-  \/\/ On success, returns 'outbuf', which now contains the path.\n-  \/\/ On error, it will return null and set errno. The content of 'outbuf' is undefined.\n-  \/\/ On truncation error ('outbuf' too small), it will return null and set errno to ENAMETOOLONG.\n-  static char* realpath(const char* filename, char* outbuf, size_t outbuflen);\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1291,3 +1291,2 @@\n-\/\/ Check if dump file can be created.\n-void os::check_dump_limit(char* buffer, size_t buffsz) {\n-  bool status = true;\n+\/\/ Check if core dump is active and if a core dump file can be created\n+void os::check_core_dump_prerequisites(char* buffer, size_t bufferSize, bool check_only) {\n@@ -1295,4 +1294,5 @@\n-    jio_snprintf(buffer, buffsz, \"CreateCoredumpOnCrash is disabled from command line\");\n-    status = false;\n-  }\n-\n+    jio_snprintf(buffer, bufferSize, \"CreateCoredumpOnCrash is disabled from command line\");\n+    VMError::record_coredump_status(buffer, false);\n+  } else {\n+    bool success = true;\n+    bool warn = true;\n@@ -1300,4 +1300,5 @@\n-  if (!os::win32::is_windows_server() && FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {\n-    jio_snprintf(buffer, buffsz, \"Minidumps are not enabled by default on client versions of Windows\");\n-    status = false;\n-  }\n+    if (!os::win32::is_windows_server() && FLAG_IS_DEFAULT(CreateCoredumpOnCrash)) {\n+      jio_snprintf(buffer, bufferSize, \"Minidumps are not enabled by default on client versions of Windows\");\n+      success = false;\n+      warn = true;\n+    }\n@@ -1306,7 +1307,20 @@\n-  if (status) {\n-    const char* cwd = get_current_directory(nullptr, 0);\n-    int pid = current_process_id();\n-    if (cwd != nullptr) {\n-      jio_snprintf(buffer, buffsz, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n-    } else {\n-      jio_snprintf(buffer, buffsz, \".\\\\hs_err_pid%u.mdmp\", pid);\n+    if (success) {\n+      if (!check_only) {\n+        const char* cwd = get_current_directory(nullptr, 0);\n+        int pid = current_process_id();\n+        if (cwd != nullptr) {\n+          jio_snprintf(buffer, bufferSize, \"%s\\\\hs_err_pid%u.mdmp\", cwd, pid);\n+        } else {\n+          jio_snprintf(buffer, bufferSize, \".\\\\hs_err_pid%u.mdmp\", pid);\n+        }\n+\n+        if (dumpFile == nullptr &&\n+            (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n+            == INVALID_HANDLE_VALUE) {\n+          jio_snprintf(buffer, bufferSize, \"Failed to create minidump file (0x%x).\", GetLastError());\n+          success = false;\n+        }\n+      } else {\n+        \/\/ For now on Windows, there are no more checks that we can do\n+        warn = false;\n+      }\n@@ -1315,5 +1329,4 @@\n-    if (dumpFile == nullptr &&\n-       (dumpFile = CreateFile(buffer, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr))\n-                 == INVALID_HANDLE_VALUE) {\n-      jio_snprintf(buffer, buffsz, \"Failed to create minidump file (0x%x).\", GetLastError());\n-      status = false;\n+    if (!check_only) {\n+      VMError::record_coredump_status(buffer, success);\n+    } else if (warn) {\n+      warning(\"CreateCoredumpOnCrash specified, but %s\", buffer);\n@@ -1322,1 +1335,0 @@\n-  VMError::record_coredump_status(buffer, status);\n@@ -5441,0 +5453,22 @@\n+char* os::realpath(const char* filename, char* outbuf, size_t outbuflen) {\n+\n+  if (filename == nullptr || outbuf == nullptr || outbuflen < 1) {\n+    assert(false, \"os::realpath: invalid arguments.\");\n+    errno = EINVAL;\n+    return nullptr;\n+  }\n+\n+  char* result = nullptr;\n+  ALLOW_C_FUNCTION(::_fullpath, char* p = ::_fullpath(nullptr, filename, 0);)\n+  if (p != nullptr) {\n+    if (strlen(p) < outbuflen) {\n+      strcpy(outbuf, p);\n+      result = outbuf;\n+    } else {\n+      errno = ENAMETOOLONG;\n+    }\n+    ALLOW_C_FUNCTION(::free, ::free(p);) \/\/ *not* os::free\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":58,"deletions":24,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -429,0 +429,1 @@\n+  template(clear0_name,                               \"clear0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -241,2 +241,0 @@\n- private:\n-  SafepointMechanism::ThreadData _poll_data;\n@@ -601,0 +599,16 @@\n+  static ByteSize polling_word_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_word);\n+    \/\/ At least on x86_64, safepoint polls encode the offset as disp8 imm.\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }\n+\n+  static ByteSize polling_page_offset() {\n+    ByteSize offset = byte_offset_of(Thread, _poll_data) +\n+                      byte_offset_of(SafepointMechanism::ThreadData, _polling_page);\n+    \/\/ At least on x86_64, safepoint polls encode the offset as disp8 imm.\n+    assert(in_bytes(offset) < 128, \"Offset >= 128\");\n+    return offset;\n+  }\n+\n@@ -790,2 +804,0 @@\n-  static ByteSize polling_word_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_word);}\n-  static ByteSize polling_page_offset()          { return byte_offset_of(JavaThread, _poll_data) + byte_offset_of(SafepointMechanism::ThreadData, _polling_page);}\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -677,0 +677,7 @@\n+  \/\/ A safe implementation of realpath which will not cause a buffer overflow if the resolved path\n+  \/\/ is longer than PATH_MAX.\n+  \/\/ On success, returns 'outbuf', which now contains the path.\n+  \/\/ On error, it will return null and set errno. The content of 'outbuf' is undefined.\n+  \/\/ On truncation error ('outbuf' too small), it will return null and set errno to ENAMETOOLONG.\n+  static char* realpath(const char* filename, char* outbuf, size_t outbuflen);\n+\n@@ -953,1 +960,1 @@\n-  static void check_dump_limit(char* buffer, size_t bufferSize);\n+  static void check_core_dump_prerequisites(char* buffer, size_t bufferSize, bool check_only = false);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -688,0 +689,5 @@\n+  if (!FLAG_IS_DEFAULT(CreateCoredumpOnCrash) && CreateCoredumpOnCrash) {\n+    char buffer[2*JVM_MAXPATHLEN];\n+    os::check_core_dump_prerequisites(buffer, sizeof(buffer), true);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1593,1 +1593,0 @@\n-  declare_c2_type(StoreCMNode, StoreNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1237,1 +1237,0 @@\n-#ifndef _WIN64\n@@ -1240,1 +1239,1 @@\n-    const char* absname = os::Posix::realpath(name, tmp, sizeof(tmp));\n+    const char* absname = os::realpath(name, tmp, sizeof(tmp));\n@@ -1242,1 +1241,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-        clear0();\n+        clearImpl();\n@@ -423,3 +423,8 @@\n-    \/* Implementation of clear(), also used by enqueue().  A simple\n-     * assignment of the referent field won't do for some garbage\n-     * collectors.\n+    \/* Implementation of clear(). A simple assignment of the referent field\n+     * won't do for some garbage collectors. There is the override for phantom\n+     * references, which requires different semantics. This method is also\n+     * used by enqueue().\n+     *\n+     * <p>This method exists only to avoid making clear0() virtual. Making\n+     * clear0() virtual has the undesirable effect of C2 often preferring\n+     * to call the native implementation over the intrinsic.\n@@ -427,0 +432,5 @@\n+    void clearImpl() {\n+        clear0();\n+    }\n+\n+    @IntrinsicCandidate\n@@ -528,1 +538,1 @@\n-        clear0();               \/\/ Intentionally clear0() rather than clear()\n+        clearImpl(); \/\/ Intentionally clearImpl() to dispatch to overridden method, if needed\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+\n+import jdk.internal.util.OperatingSystem;\n@@ -158,0 +160,5 @@\n+        \/\/ for systems other than Windows we don't\n+        \/\/ do any special conversion\n+        if (!OperatingSystem.isWindows()) {\n+            return url;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":8,"deletions":1,"binary":false,"changes":9,"previous_filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-            if ((*env)->ExceptionOccurred(env)) {\n+            if ((*env)->ExceptionCheck(env)) {\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-applications\/ctw\/modules\/java_base_2.java 8341831 linux-x64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/System\/NanoTimeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/System\/TimedWaitingTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @requires docker.support\n+ * @requires container.support\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}