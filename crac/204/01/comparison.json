{"files":[{"patch":"@@ -28,0 +28,5 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+\n@@ -31,0 +36,1 @@\n+import java.util.concurrent.Phaser;\n@@ -54,1 +60,1 @@\n-    private final int epfd;\n+    private int epfd;\n@@ -87,0 +93,78 @@\n+    private final Event CHECKPOINT = new Event(null, 0);\n+\n+    private final CRaCResource resource = new CRaCResource();\n+\n+    private class CRaCResource implements JDKResource {\n+        \/\/ The field is volatile since it's accessed in isCheckpoint() which might be called\n+        \/\/ after a wakeup, without any guarantees for memory barriers.\n+        private volatile Phaser phaser;\n+        \/\/ Not volatile as it's accessed only after receiving CHECKPOINT event through the\n+        \/\/ queue which establishes a happens-after relation.\n+        private AtomicInteger counter;\n+        private IOException restoreException;\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            int threads = threadCount();\n+            if (threads == 0) {\n+                throw new IllegalStateException();\n+            }\n+            phaser = new Phaser(threadCount() + 1);\n+            counter = new AtomicInteger(threads);\n+            for (int i = 0; i < threads; ++i) {\n+                \/\/ cannot use executeOnHandlerTask as taskQueue is null in a non-fixed threadpool\n+                queue.offer(CHECKPOINT);\n+            }\n+            \/\/ we call wakeup only once since there's only one thread actually polling\n+            wakeup();\n+            \/\/ synchronization 1: wait until other threads enter processCheckpoint\n+            phaser.arriveAndAwaitAdvance();\n+        }\n+\n+        private void processCheckpoint() {\n+            boolean isLast = counter.decrementAndGet() == 0;\n+            if (isLast) {\n+                \/\/ This code is closing epfd even if there are FDs registered in that; the existence\n+                \/\/ of these FDs will cause their own exceptions on checkpoint.\n+                \/\/ If these are ignored by FD policies it's up to the user to deal with missed registrations.\n+                try { FileDispatcherImpl.closeIntFD(epfd); } catch (IOException ioe) { }\n+                try { FileDispatcherImpl.closeIntFD(sp[0]); } catch (IOException ioe) { }\n+                try { FileDispatcherImpl.closeIntFD(sp[1]); } catch (IOException ioe) { }\n+            }\n+            \/\/ synchronization 1: threads entering processCheckpoint()\n+            phaser.arriveAndAwaitAdvance();\n+            \/\/ synchronization 2: block threads until afterRestore()\n+            phaser.arriveAndAwaitAdvance();\n+            if (isLast) {\n+                try {\n+                    epfd = EPoll.create();\n+                    long fds = IOUtil.makePipe(true);\n+                    sp[0] = (int) (fds >>> 32);\n+                    sp[1] = (int) fds;\n+                } catch (IOException e) {\n+                    restoreException = e;\n+                }\n+            }\n+            \/\/ synchronization 3: notify that FDs have been re-created\n+            phaser.arrive();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            \/\/ synchronization 2: unblock threads waiting until restore\n+            phaser.arriveAndAwaitAdvance();\n+            \/\/ synchronization 3: wait until all threads re-create the FDs\n+            phaser.arriveAndAwaitAdvance();\n+            counter = null;\n+            phaser = null;\n+            if (restoreException != null) {\n+                Exception e = restoreException;\n+                restoreException = null;\n+                throw e;\n+            }\n+        }\n+\n+        public boolean isCheckpoint() {\n+            return phaser != null;\n+        }\n+    }\n@@ -113,0 +197,2 @@\n+\n+        Core.Priority.EPOLLSELECTOR.getContext().register(resource);\n@@ -292,0 +378,5 @@\n+                        if (resource.isCheckpoint()) {\n+                            \/\/ the wakeup was caused by checkpoint, but there might not be any taskQueue\n+                            \/\/ and no task. It is not a shutdown, though.\n+                            continue;\n+                        }\n@@ -301,0 +392,3 @@\n+                    } else if (ev == CHECKPOINT) {\n+                        resource.processCheckpoint();\n+                        continue;\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollPort.java","additions":95,"deletions":1,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -78,0 +78,5 @@\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -94,0 +94,7 @@\n+        \/\/ We cannot override this in subclass because SocketImpl is public and resource factory method\n+        \/\/ would expose JDKSocketResource outside JDK.\n+        @Override\n+        protected boolean isListening() {\n+            return SocketImpl.this.isListening();\n+        }\n+\n@@ -98,0 +105,5 @@\n+\n+        @Override\n+        protected void reopenAfterRestore() throws IOException {\n+            SocketImpl.this.reopenAfterRestore();\n+        }\n@@ -100,0 +112,16 @@\n+    \/**\n+     * Is this socket listening (server)?\n+     * @return True if listening\n+     *\/\n+    protected boolean isListening() {\n+        return false;\n+    }\n+\n+    \/**\n+     * Used only by CRaC\n+     * @throws IOException When cannot be reopened\n+     *\/\n+    protected void reopenAfterRestore() throws IOException {\n+        throw new UnsupportedOperationException(\"Reopen not implemented\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -133,0 +133,10 @@\n+    \/**\n+     * Used only internally by CRaC\n+     *\/\n+    protected final void setReopened() {\n+        synchronized (closeLock) {\n+            assert closed;\n+            closed = false;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/spi\/AbstractInterruptibleChannel.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,0 +7,2 @@\n+import java.util.Map;\n+import java.util.function.Predicate;\n@@ -19,0 +21,1 @@\n+    protected abstract boolean isListening();\n@@ -36,0 +39,4 @@\n+        Predicate<Map<String, String>> listenMatcher = params -> {\n+            String cfgListening = params.get(\"listening\");\n+            return cfgListening == null || Boolean.parseBoolean(cfgListening) == isListening();\n+        };\n@@ -37,1 +44,1 @@\n-                params -> localMatcher.test(params) && remoteMatcher.test(params));\n+                params -> localMatcher.test(params) && remoteMatcher.test(params) && listenMatcher.test(params));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResource.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -142,1 +142,0 @@\n-                \/\/ FIXME: implement\n@@ -144,1 +143,1 @@\n-                    throw new UnsupportedOperationException(\"Policy \" + policy.type + \" not implemented\");\n+                    reopenAfterRestore();\n@@ -153,0 +152,4 @@\n+\n+    protected void reopenAfterRestore() throws IOException {\n+        throw new UnsupportedOperationException(\"Reopen not implemented on sockets\");\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResourceBase.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-                if (line.startsWith(\"#\")) {\n+                if (line.startsWith(\"#\") || line.isEmpty()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/OpenResourcePolicies.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private static int dryRunsCounter = -1;\n@@ -72,0 +73,2 @@\n+        public static final boolean DRY_RUNS_INTERRUPTED = Boolean.getBoolean(\"jdk.crac.dry-runs.interrupted\");\n+        public static final int DRY_RUNS = Integer.getInteger(\"jdk.crac.dry-runs\", 0);\n@@ -153,0 +156,25 @@\n+        if (dryRunsCounter < 0) {\n+            dryRunsCounter = FlagsHolder.DRY_RUNS;\n+        }\n+        while (dryRunsCounter > 0) {\n+            jdk.internal.crac.Core.setClaimedFDs(new ClaimedFDs());\n+            try {\n+                globalContext.beforeCheckpoint(null);\n+            } catch (CheckpointException ce) {\n+                checkpointException.handle(ce);\n+            }\n+            jdk.internal.crac.Core.setClaimedFDs(null);\n+            try {\n+                globalContext.afterRestore(null);\n+            } catch (RestoreException re) {\n+                checkpointException.resuppress(re);\n+            }\n+            dryRunsCounter--;\n+            if (FlagsHolder.DRY_RUNS_INTERRUPTED) {\n+                checkpointException.get().addSuppressed(new RuntimeException(\"Dry-run executed, not continuing with checkpoint\"));\n+            }\n+            \/\/ We use only checkpoint exception type because effectively even afterRestore() runs\n+            \/\/ before checkpoint. The exact source is clear from stack trace\n+            checkpointException.throwIfAny();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+    \/\/ last backlog used for bind(...)\n+    private int backlog;\n+\n@@ -92,0 +95,5 @@\n+            @Override\n+            protected boolean isListening() {\n+                return true;\n+            }\n+\n@@ -96,0 +104,14 @@\n+\n+            @Override\n+            protected void reopenAfterRestore() throws IOException {\n+                FileDescriptor newfd = Net.serverSocket(true);\n+                IOUtil.setfdVal(fd, IOUtil.fdVal(newfd));\n+                reopen();\n+                synchronized (stateLock) {\n+                    SocketAddress local = localAddress;\n+                    if (local != null) {\n+                        localAddress = null;\n+                        bind(local, backlog);\n+                    }\n+                }\n+            }\n@@ -139,0 +161,14 @@\n+    private void reopen() throws IOException {\n+        closeLock.writeLock().lock();\n+        try {\n+            assert(closed);\n+            closed = false;\n+        } finally {\n+            closeLock.writeLock().unlock();\n+        }\n+        implReopen();\n+    }\n+\n+    protected void implReopen() throws IOException {\n+    }\n+\n@@ -185,1 +221,2 @@\n-                Net.listen(fd, backlog < 1 ? 50 : backlog);\n+                this.backlog = backlog < 1 ? 50 : backlog;\n+                Net.listen(fd, this.backlog);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -625,0 +625,5 @@\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1987,0 +1987,5 @@\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -129,0 +129,3 @@\n+    \/\/ last backlog used for listen() invocation\n+    private int backlog;\n+\n@@ -454,0 +457,29 @@\n+    @Override\n+    protected boolean isListening() {\n+        return server;\n+    }\n+\n+    @Override\n+    protected void reopenAfterRestore() throws IOException {\n+        if (!server) {\n+            throw new UnsupportedOperationException(\"Reopen not implemented for non-server sockets\");\n+        }\n+        synchronized (stateLock) {\n+            FileDescriptor fd;\n+            fd = Net.serverSocket(true);\n+            Runnable closer = closerFor(fd, true);\n+            IOUtil.setfdVal(NioSocketImpl.this.fd, IOUtil.fdVal(fd));\n+            NioSocketImpl.this.cleaner = CleanerFactory.cleaner().register(NioSocketImpl.this, closer);\n+            state = ST_UNCONNECTED;\n+\n+            if (localport != 0) {\n+                int port = localport;\n+                localport = 0;\n+                bind(address, port);\n+            }\n+            if (backlog > 0) {\n+                Net.listen(fd, backlog);\n+            }\n+        }\n+    }\n+\n@@ -651,1 +683,2 @@\n-            Net.listen(fd, backlog < 1 ? 50 : backlog);\n+            this.backlog = backlog < 1 ? 50 : backlog;\n+            Net.listen(fd, this.backlog);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-    private final int fdVal;\n+    private int fdVal;\n@@ -80,0 +80,1 @@\n+    private int backlog;\n@@ -301,0 +302,2 @@\n+            \/\/ Persisting the backlog since there's no way to query that before close\n+            this.backlog = backlog < 1 ? 50 : backlog;\n@@ -761,0 +764,5 @@\n+        @Override\n+        protected boolean isListening() {\n+            return true;\n+        }\n+\n@@ -765,0 +773,24 @@\n+\n+        @Override\n+        protected void reopenAfterRestore() throws IOException {\n+            FileDescriptor newFd;\n+            if (family == UNIX) {\n+                newFd = UnixDomainSockets.socket();\n+            } else {\n+                newFd = Net.serverSocket(family, true);\n+            }\n+            \/\/ We could avoid making fdVal non-final and dup2(...) to the original\n+            \/\/ value but that could accidentally conflict with another FD created\n+            \/\/ during restore.\n+            fdVal = IOUtil.fdVal(newFd);\n+            IOUtil.setfdVal(fd, fdVal);\n+            synchronized (stateLock) {\n+                state = ST_INUSE;\n+                if (isUnixSocket()) {\n+                    localAddress = unixBind(localAddress, backlog);\n+                } else {\n+                    localAddress = netBind(localAddress, backlog);\n+                }\n+            }\n+            setReopened();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1638,0 +1638,5 @@\n+        @Override\n+        protected boolean isListening() {\n+            return false;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    private final int fdVal;\n+    private int fdVal;\n@@ -115,0 +115,6 @@\n+    @Override\n+    protected void implReopen() {\n+        fdVal = IOUtil.fdVal(fd);\n+        port.register(fdVal, this);\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixAsynchronousServerSocketChannelImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-    private final long handle;\n-    private final int completionKey;\n+    private long handle;\n+    private int completionKey;\n@@ -56,1 +56,1 @@\n-    private final PendingIoCache ioCache;\n+    private PendingIoCache ioCache;\n@@ -105,0 +105,12 @@\n+    @Override\n+    protected void implReopen() throws IOException {\n+        handle = IOUtil.fdVal(fd);\n+        ioCache = new PendingIoCache();\n+        try {\n+            completionKey = iocp.associate(this, handle);\n+        } catch (IOException x) {\n+            closesocket0(handle);\n+            throw x;\n+        }\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousServerSocketChannelImpl.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.channels.AsynchronousServerSocketChannel;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenListeningTestBase\n+ * @build ReopenListeningAsynchronousSocketChannelTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenListeningAsynchronousSocketChannelTest extends ReopenListeningTestBase<AsynchronousServerSocketChannel> implements CracTest {\n+    @Override\n+    protected AsynchronousServerSocketChannel createServer() throws IOException {\n+        return AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+    }\n+\n+    @Override\n+    protected void testConnection(AsynchronousServerSocketChannel serverSocket) throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Future<AsynchronousSocketChannel> socket = serverSocket.accept();\n+                socket.get();\n+                latch.countDown();\n+                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        AsynchronousSocketChannel clientSocket = AsynchronousSocketChannel.open();\n+        Future<Void> connectFuture = clientSocket.connect(serverSocket.getLocalAddress());\n+        connectFuture.get();\n+        latch.await();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningAsynchronousSocketChannelTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenListeningTestBase\n+ * @build ReopenListeningSocketChannelTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenListeningSocketChannelTest extends ReopenListeningTestBase<ServerSocketChannel> implements CracTest {\n+    @Override\n+    protected ServerSocketChannel createServer() throws IOException {\n+        return ServerSocketChannel.open().bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+    }\n+\n+    @Override\n+    protected void testConnection(ServerSocketChannel serverSocket) throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                SocketChannel socket = serverSocket.accept();\n+                latch.countDown();\n+                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        SocketChannel clientSocket = SocketChannel.open(serverSocket.getLocalAddress());\n+        Asserts.assertTrue(clientSocket.isConnected());\n+        latch.await();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningSocketChannelTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenListeningTestBase\n+ * @build ReopenListeningSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenListeningSocketTest extends ReopenListeningTestBase<ServerSocket> implements CracTest {\n+    @Override\n+    protected ServerSocket createServer() throws IOException {\n+        return new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+    }\n+\n+    @Override\n+    protected void testConnection(ServerSocket serverSocket) throws Exception {\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        Asserts.assertTrue(clientSocket.isConnected());\n+        latch.await();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningSocketTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracEngine;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public abstract class ReopenListeningTestBase<ServerType> extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: SOCKET\n+                family: ip\n+                listening: true\n+                action: reopen\n+                ---\n+                type: SOCKET\n+                family: ip\n+                action: close\n+                \"\"\");\n+        try {\n+            new CracBuilder()\n+                    .engine(CracEngine.SIMULATE)\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .javaOption(\"jdk.crac.collect-fd-stacktraces\", \"true\")\n+                    .startCheckpoint().waitForSuccess();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerType serverSocket = createServer();\n+        testConnection(serverSocket);\n+        Core.checkpointRestore();\n+        testConnection(serverSocket);\n+    }\n+\n+    protected abstract ServerType createServer() throws IOException;\n+\n+    protected abstract void testConnection(ServerType serverSocket) throws Exception;\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningTestBase.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}