{"files":[{"patch":"@@ -98,0 +98,2 @@\n+        \/\/ The field is volatile since it's accessed in isCheckpoint() which might be called\n+        \/\/ after a wakeup, without any guarantees for memory barriers.\n@@ -99,0 +101,2 @@\n+        \/\/ Not volatile as it's accessed only after receiving CHECKPOINT event through the\n+        \/\/ queue which establishes a happens-after relation.\n@@ -116,0 +120,1 @@\n+            \/\/ synchronization 1: wait until other threads enter processCheckpoint\n@@ -129,0 +134,1 @@\n+            \/\/ synchronization 1: threads entering processCheckpoint()\n@@ -130,0 +136,1 @@\n+            \/\/ synchronization 2: block threads until afterRestore()\n@@ -141,1 +148,2 @@\n-            phaser.arriveAndAwaitAdvance();\n+            \/\/ synchronization 3: notify that FDs have been re-created\n+            phaser.arrive();\n@@ -146,0 +154,1 @@\n+            \/\/ synchronization 2: unblock threads waiting until restore\n@@ -147,0 +156,1 @@\n+            \/\/ synchronization 3: wait until all threads re-create the FDs\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollPort.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-    private final JDKSocketResource resource = new JDKSocketResource(SocketImpl.this) {\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,4 +41,1 @@\n-            if (cfgListening == null || \"*\".equals(cfgListening)) {\n-                return true;\n-            }\n-            return Boolean.parseBoolean(cfgListening) == isListening();\n+            return cfgListening == null || Boolean.parseBoolean(cfgListening) == isListening();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResource.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    private static int dryRunsCounter = -1;\n@@ -72,0 +73,2 @@\n+        public static final boolean DRY_RUNS_INTERRUPTED = Boolean.getBoolean(\"jdk.crac.dry-runs.interrupted\");\n+        public static final int DRY_RUNS = Integer.getInteger(\"jdk.crac.dry-runs\", 0);\n@@ -153,0 +156,25 @@\n+        if (dryRunsCounter < 0) {\n+            dryRunsCounter = FlagsHolder.DRY_RUNS;\n+        }\n+        while (dryRunsCounter > 0) {\n+            jdk.internal.crac.Core.setClaimedFDs(new ClaimedFDs());\n+            try {\n+                globalContext.beforeCheckpoint(null);\n+            } catch (CheckpointException ce) {\n+                checkpointException.handle(ce);\n+            }\n+            jdk.internal.crac.Core.setClaimedFDs(null);\n+            try {\n+                globalContext.afterRestore(null);\n+            } catch (RestoreException re) {\n+                checkpointException.resuppress(re);\n+            }\n+            dryRunsCounter--;\n+            if (FlagsHolder.DRY_RUNS_INTERRUPTED) {\n+                checkpointException.get().addSuppressed(new RuntimeException(\"Dry-run executed, not continuing with checkpoint\"));\n+            }\n+            \/\/ We use only checkpoint exception type because effectively even afterRestore() runs\n+            \/\/ before checkpoint. The exact source is clear from stack trace\n+            checkpointException.throwIfAny();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-    private void reopen() {\n+    private void reopen() throws IOException {\n@@ -172,1 +172,1 @@\n-    protected void implReopen() {\n+    protected void implReopen() throws IOException {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-    private final long handle;\n-    private final int completionKey;\n+    private long handle;\n+    private int completionKey;\n@@ -56,1 +56,1 @@\n-    private final PendingIoCache ioCache;\n+    private PendingIoCache ioCache;\n@@ -105,0 +105,12 @@\n+    @Override\n+    protected void implReopen() throws IOException {\n+        handle = IOUtil.fdVal(fd);\n+        ioCache = new PendingIoCache();\n+        try {\n+            completionKey = iocp.associate(this, handle);\n+        } catch (IOException x) {\n+            closesocket0(handle);\n+            throw x;\n+        }\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousServerSocketChannelImpl.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n- * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningAsynchronousSocketChannelTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n- * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningSocketChannelTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n- * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningSocketTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.test.lib.crac.CracEngine;\n@@ -37,1 +38,0 @@\n-        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n@@ -47,1 +47,1 @@\n-                \"\"\".replace(\"$loopback\", loopback));\n+                \"\"\");\n@@ -50,0 +50,1 @@\n+                    .engine(CracEngine.SIMULATE)\n@@ -52,1 +53,1 @@\n-                    .doCheckpointAndRestore();\n+                    .startCheckpoint().waitForSuccess();\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenListeningTestBase.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}