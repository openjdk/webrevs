{"files":[{"patch":"@@ -67,1 +67,0 @@\n-    private static int dryRunsCounter = -1;\n@@ -73,2 +72,0 @@\n-        public static final boolean DRY_RUNS_INTERRUPTED = Boolean.getBoolean(\"jdk.crac.dry-runs.interrupted\");\n-        public static final int DRY_RUNS = Integer.getInteger(\"jdk.crac.dry-runs\", 0);\n@@ -156,25 +153,0 @@\n-        if (dryRunsCounter < 0) {\n-            dryRunsCounter = FlagsHolder.DRY_RUNS;\n-        }\n-        while (dryRunsCounter > 0) {\n-            jdk.internal.crac.Core.setClaimedFDs(new ClaimedFDs());\n-            try {\n-                globalContext.beforeCheckpoint(null);\n-            } catch (CheckpointException ce) {\n-                checkpointException.handle(ce);\n-            }\n-            jdk.internal.crac.Core.setClaimedFDs(null);\n-            try {\n-                globalContext.afterRestore(null);\n-            } catch (RestoreException re) {\n-                checkpointException.resuppress(re);\n-            }\n-            dryRunsCounter--;\n-            if (FlagsHolder.DRY_RUNS_INTERRUPTED) {\n-                checkpointException.get().addSuppressed(new RuntimeException(\"Dry-run executed, not continuing with checkpoint\"));\n-            }\n-            \/\/ We use only checkpoint exception type because effectively even afterRestore() runs\n-            \/\/ before checkpoint. The exact source is clear from stack trace\n-            checkpointException.throwIfAny();\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/mirror\/Core.java","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"}]}