{"files":[{"patch":"@@ -68,2 +68,1 @@\n-    int print_numbers(char *buf_orig, size_t buflen) const { return 0; }\n-    static constexpr size_t print_buffer_length() { return 0; }\n+    const char *print_numbers() const { return \"\"; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,2 +45,1 @@\n-    int print_numbers(char *buf_orig, size_t buflen) const { return 0; }\n-    static constexpr size_t print_buffer_length() { return 0; }\n+    const char *print_numbers() const { return \"\"; }\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-    int print_numbers(char *buf_orig, size_t buflen) const { return 0; }\n-    static constexpr size_t print_buffer_length() { return 0; }\n+    const char *print_numbers() const { return \"\"; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -311,2 +311,1 @@\n-    int print_numbers(char *buf_orig, size_t buflen) const { return 0; }\n-    static constexpr size_t print_buffer_length() { return 0; }\n+    const char *print_numbers() const { return \"\"; }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -418,2 +418,1 @@\n-    int print_numbers(char *buf_orig, size_t buflen) const { return 0; }\n-    static constexpr size_t print_buffer_length() { return 0; }\n+    const char *print_numbers() const { return \"\"; }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -615,2 +615,4 @@\n-    static constexpr size_t print_buffer_length() {\n-      return MAX_CPU_FEATURES;\n+    const char *print_numbers() const {\n+      char *buf = NEW_RESOURCE_ARRAY(char, MAX_CPU_FEATURES);\n+      print_numbers(buf, MAX_CPU_FEATURES);\n+      return buf;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-    int print_numbers(char *buf_orig, size_t buflen) const { return 0; }\n-    static constexpr size_t print_buffer_length() { return 0; }\n+    const char *print_numbers() const { return \"\"; }\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,8 +79,0 @@\n-\/\/ Error codes returned from crlib_api.restore():\n-#define RESTORE_ERROR_UNKNOWN   -1 \/\/ generic error\n-#define RESTORE_ERROR_NOT_FOUND -2 \/\/ image location does not contain an image\n-#define RESTORE_ERROR_NO_ACCESS -3 \/\/ image cannot be accessed\/retrieved (permissions or I\/O issue)\n-#define RESTORE_ERROR_INVALID   -4 \/\/ image is not suitable (e.g. corruption or wrong architecture)\n-#define RESTORE_ERROR_MEMORY    -5 \/\/ memory allocation failure during restore\n-#define RESTORE_ERROR_PROCINFO  -6 \/\/ the process cannot fetch information about itself\n-\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib.h","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\/\/ When two bitmaps of different size are compared this behaves as if the shorter\n+\/\/ bitmap was extended with zeros to the length of the longer bitmap.\n@@ -37,1 +39,0 @@\n-  \/* Natural zero-extensions of the bitmaps are equal *\/\n@@ -39,1 +40,1 @@\n-  \/* Bitmap in image must be subset or equal to bitmap in constraint *\/\n+  \/\/ Bitmap in image must be subset or equal to bitmap in constraint\n@@ -41,1 +42,1 @@\n-  \/* Bitmap in image must be superset or equal to bitmap in constraint *\/\n+  \/\/ Bitmap in image must be superset or equal to bitmap in constraint\n@@ -43,1 +44,1 @@\n-} bitmap_comparison_t;\n+} crlib_bitmap_comparison_t;\n@@ -45,2 +46,2 @@\n-\/\/ API for storing & verifying application-defined labels and bitmaps\n-typedef struct crlib_image_constraints {\n+\/\/ API for storing & verifying application-defined image characteristics, generally called tags.\n+typedef const struct crlib_image_constraints {\n@@ -49,1 +50,1 @@\n-  \/\/ Invoked before checkpoint. Return false if name or value exceed limits, or if the name was already used.\n+  \/\/ Invoked before checkpoint. Return false if name or value exceed limits, or if the name has already been used.\n@@ -51,1 +52,1 @@\n-  bool (*set_bitmap)(crlib_conf_t *, const char *name, const unsigned char *value, size_t length_bytes);\n+  bool (*set_bitmap)(crlib_conf_t *, const char *name, const unsigned char *value, size_t size_bytes);\n@@ -54,3 +55,9 @@\n-  \/\/ with RESTORE_ERROR_INVALID if these constraints are not matched.\n-  void (*require_label)(crlib_conf_t *, const char *name, const char *value);\n-  void (*require_bitmap)(crlib_conf_t *, const char *name, const unsigned char *value, size_t length_bytes, bitmap_comparison_t comparison);\n+  \/\/ if these constraints are not matched.\n+  \/\/ Multiple constraints on the same tag are permitted.\n+  \/\/ These methods return false when the constraint cannot be added to the configuration.\n+  bool (*require_label)(crlib_conf_t *, const char *name, const char *value);\n+  bool (*require_bitmap)(crlib_conf_t *, const char *name, const unsigned char *value, size_t size_bytes, crlib_bitmap_comparison_t comparison);\n+\n+  \/\/ Invoked after (failed) restore. Returns true if the restore failed due to\n+  \/\/ any of the constraints on tag <name>, false otherwise.\n+  bool (*is_failed)(crlib_conf_t *, const char *name);\n@@ -63,1 +70,1 @@\n-#endif \/\/ CRLIB_USER_DATA_H\n+#endif \/\/ CRLIB_IMAGE_CONSTRAINTS_H\n","filename":"src\/hotspot\/share\/include\/crlib\/crlib_image_constraints.h","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -588,21 +588,1 @@\n-    const char *msg = \"\";\n-    switch (ret) {\n-      case RESTORE_ERROR_NOT_FOUND:\n-        msg = \"the image or its part cannot be found\";\n-        break;\n-      case RESTORE_ERROR_NO_ACCESS:\n-        msg = \"the image cannot be accessed\/retrieved (permissions or I\/O issue)\";\n-        break;\n-      case RESTORE_ERROR_INVALID:\n-        msg = \"the image does not match current CPU or is corrupted\";\n-        break;\n-      case RESTORE_ERROR_MEMORY:\n-        msg = \"memory allocation failure during restore\";\n-        break;\n-      case RESTORE_ERROR_PROCINFO:\n-        msg = \"the process cannot fetch information about itself\";\n-        break;\n-    }\n-    log_error(crac)(\"CRaC engine failed to restore from %s: %s (error %d)\", CRaCRestoreFrom, msg, ret);\n-  }\n-  if (ret == RESTORE_ERROR_INVALID) {\n+    log_error(crac)(\"CRaC engine failed to restore from %s\", CRaCRestoreFrom);\n@@ -610,5 +590,2 @@\n-    if (VM_Version::cpu_features_binary(&data)) {\n-      char buf[VM_Version::VM_Features::print_buffer_length()];\n-      data.print_numbers(buf, sizeof(buf));\n-      log_error(crac)(\"\\tIf the restore failed due to a wrong CPU features, try using -XX:CPUFeatures=%s on checkpoint.\", buf);\n-    }\n+    VM_Version::cpu_features_binary(&data); \/\/ ignore return value\n+    engine.check_cpuinfo(&data);\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -482,0 +482,14 @@\n+\n+void CracEngine::check_cpuinfo(const VM_Version::VM_Features *datap) const {\n+  if (_image_constraints_api == nullptr) {\n+    \/\/ When CPU features are ignored\n+    return;\n+  }\n+  if (_image_constraints_api->is_failed(_conf, cpuarch_name)) {\n+    log_error(crac)(\"Restore failed due to wrong or missing CPU architecture (current architecture is \" ARCHPROPNAME \")\");\n+  }\n+  if (_image_constraints_api->is_failed(_conf, cpufeatures_name)) {\n+    ResourceMark rm;\n+    log_error(crac)(\"Restore failed due to incompatible or missing CPU features, try using -XX:CPUFeatures=%s on checkpoint.\", datap->print_numbers());\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+  void check_cpuinfo(const VM_Version::VM_Features *datap) const;\n","filename":"src\/hotspot\/share\/runtime\/crac_engine.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-      log_error(crac)(\"Failed to restore %s\", CRaCRestoreFrom);\n+      log_error(crac)(\"Failed to restore from %s\", CRaCRestoreFrom);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"crexec.hpp\"\n@@ -49,4 +50,0 @@\n-#ifndef PATH_MAX\n-# define PATH_MAX 1024\n-#endif\n-\n@@ -81,2 +78,3 @@\n-static void require_label(crlib_conf_t *, const char *name, const char *value);\n-static void require_bitmap(crlib_conf_t *, const char *name, const unsigned char *value, size_t length_bytes, bitmap_comparison_t comparison);\n+static bool require_label(crlib_conf_t *, const char *name, const char *value);\n+static bool require_bitmap(crlib_conf_t *, const char *name, const unsigned char *value, size_t length_bytes, crlib_bitmap_comparison_t comparison);\n+static bool is_failed(crlib_conf_t *, const char *name);\n@@ -137,0 +135,1 @@\n+  is_failed,\n@@ -141,1 +140,0 @@\n-  &user_data_extension.header,\n@@ -143,0 +141,1 @@\n+  &user_data_extension.header,\n@@ -147,3 +146,0 @@\n-#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(*(x)))\n-\n-#define CREXEC \"crexec: \"\n@@ -607,2 +603,2 @@\n-static void require_label(crlib_conf_t *conf, const char *name, const char *value) {\n-  conf->image_constraints().require_label(name, value);\n+static bool require_label(crlib_conf_t *conf, const char *name, const char *value) {\n+  return conf->image_constraints().require_label(name, value);\n@@ -611,2 +607,6 @@\n-static void require_bitmap(crlib_conf_t *conf, const char *name, const unsigned char *value, size_t length_bytes, bitmap_comparison_t comparison) {\n-  conf->image_constraints().require_bitmap(name, value, length_bytes, comparison);\n+static bool require_bitmap(crlib_conf_t *conf, const char *name, const unsigned char *value, size_t length_bytes, crlib_bitmap_comparison_t comparison) {\n+  return conf->image_constraints().require_bitmap(name, value, length_bytes, comparison);\n+}\n+\n+static bool is_failed(crlib_conf_t *conf, const char *name) {\n+  return conf->image_constraints().is_failed(name);\n@@ -808,1 +808,1 @@\n-    return RESTORE_ERROR_UNKNOWN;\n+    return -1;\n@@ -812,1 +812,1 @@\n-    return RESTORE_ERROR_UNKNOWN;\n+    return -1;\n@@ -820,0 +820,4 @@\n+  if (!conf->image_constraints().validate(conf->argv()[ARGV_IMAGE_LOCATION])) {\n+    return -1;\n+  }\n+\n@@ -824,1 +828,1 @@\n-    return RESTORE_ERROR_UNKNOWN;\n+    return -1;\n@@ -831,6 +835,1 @@\n-    return RESTORE_ERROR_UNKNOWN;\n-  }\n-\n-  int error = conf->image_constraints().validate(conf->argv()[ARGV_IMAGE_LOCATION]);\n-  if (error) {\n-    return error;\n+    return -1;\n@@ -844,1 +843,1 @@\n-  return RESTORE_ERROR_UNKNOWN;\n+  return -1;\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.cpp","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef CREXEC_HPP\n+#define CREXEC_HPP\n+\n+#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(*(x)))\n+\n+#define CREXEC \"crexec: \"\n+\n+#ifndef PATH_MAX \/\/ For Windows\n+# define PATH_MAX 1024\n+#endif\n+\n+#endif \/\/ CREXEC_HPP\n","filename":"src\/java.base\/share\/native\/libcrexec\/crexec.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-  bool put(const char *key, T&& value);\n+  template<typename TT> bool put(const char *key, TT&& value);\n@@ -135,2 +135,2 @@\n-template<class T>\n-bool Hashtable<T>::put(const char *key, T&& value) {\n+template<class T> template<typename TT>\n+bool Hashtable<T>::put(const char* key, TT&& value) {\n@@ -141,1 +141,1 @@\n-  *value_ptr = std::forward<T>(value);\n+  *value_ptr = std::forward<TT>(value);\n","filename":"src\/java.base\/share\/native\/libcrexec\/hashtable.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"crexec.hpp\"\n@@ -34,1 +35,0 @@\n-#define CREXEC \"crexec: \"\n@@ -38,1 +38,1 @@\n-static FILE *open_tags(const char *image_location, const char *mode) {\n+static FILE *open_tags(const char* image_location, const char* mode) {\n@@ -46,1 +46,1 @@\n-    fprintf(stderr, CREXEC \"cannot open(%s) %s: %s\\n\", fname, mode, strerror(errno));\n+    fprintf(stderr, CREXEC \"cannot open %s in mode %s: %s\\n\", fname, mode, strerror(errno));\n@@ -52,3 +52,12 @@\n-bool ImageConstraints::set_label(const char *name, const char *value) {\n-  if (check_tag(name)) {\n-    fprintf(stderr, CREXEC \"Label %s is already set\\n\", name);\n+bool ImageConstraints::check_tag(const char* type, const char* name, size_t value_size) {\n+  bool present = false;\n+  _tags.foreach([&](Tag &tag) {\n+    if (!strcmp(tag.name, name)) {\n+      present = true;\n+    }\n+  });\n+  if (present) {\n+    fprintf(stderr, CREXEC \"%s %s is already set\\n\", type, name);\n+    return false;\n+  } else if (strpbrk(name, \"=\\n\")) {\n+    fprintf(stderr, CREXEC \"%s name must not contain '=' or newline\\n\", type);\n@@ -57,3 +66,2 @@\n-  size_t value_length = strlen(value) + 1;\n-  if (strlen(name) >= _max_name_length || value_length >= _max_value_length) {\n-    fprintf(stderr, CREXEC \"Label %s=%s is too long\\n\", name, value);\n+  if (strlen(name) >= _MAX_NAME_SIZE) {\n+    fprintf(stderr, CREXEC \"%s %s is too long\\n\", type, name);\n@@ -62,3 +70,13 @@\n-  char *name_copy = strdup(name);\n-  if (name_copy == nullptr) {\n-    fprintf(stderr, CREXEC \"out of memory\\n\");\n+  if (value_size >= _MAX_VALUE_SIZE) {\n+      fprintf(stderr, CREXEC \"%s %s value is too long (%zu bytes)\\n\", type, name, value_size);\n+      return false;\n+  }\n+  return true;\n+}\n+\n+bool ImageConstraints::set_label(const char* name, const char* value) {\n+  size_t value_size = strlen(value) + 1;\n+  if (!check_tag(\"Label\", name, value_size)) {\n+    return false;\n+  } else if (strchr(value, '\\n')) {\n+    fprintf(stderr, CREXEC \"Label value must not contain a newline\\n\");\n@@ -67,2 +85,4 @@\n-  const char *value_copy = strdup(value);\n-  if (value_copy == nullptr) {\n+  char* name_copy = strdup(name);\n+  char* value_copy = strdup(value);\n+  if (name_copy == nullptr || value_copy == nullptr || !_tags.add(\n+      Tag(TagType::LABEL, name_copy, value_copy, value_size))) {\n@@ -71,0 +91,1 @@\n+    free(value_copy);\n@@ -73,1 +94,0 @@\n-  _tags.add({ LABEL, name_copy, value_copy, value_length });\n@@ -77,3 +97,2 @@\n-bool ImageConstraints::set_bitmap(const char *name, const unsigned char *value, size_t length_bytes) {\n-  if (check_tag(name)) {\n-      fprintf(stderr, CREXEC \"Bitmap %s is already set\\n\", name);\n+bool ImageConstraints::set_bitmap(const char* name, const unsigned char* value, size_t value_size) {\n+  if (!check_tag(\"Bitmap\", name, value_size)) {\n@@ -82,3 +101,4 @@\n-  if (strlen(name) >= _max_name_length || length_bytes >= _max_value_length) {\n-      fprintf(stderr, CREXEC \"Bitmap %s=(%zu bytes) is too long\\n\", name, length_bytes);\n-      return false;\n+  char* name_copy = strdup(name);\n+  void* bitmap_copy = malloc(value_size);\n+  if (bitmap_copy != nullptr) {\n+    memcpy(bitmap_copy, value, value_size);\n@@ -86,7 +106,2 @@\n-  char *name_copy = strdup(name);\n-  if (name_copy == nullptr) {\n-    fprintf(stderr, CREXEC \"out of memory\\n\");\n-    return false;\n-  }\n-  void *bitmap_copy = malloc(length_bytes);\n-  if (bitmap_copy == nullptr) {\n+  if (name_copy == nullptr || bitmap_copy == nullptr || !_tags.add(\n+      Tag(TagType::BITMAP, name_copy, (const unsigned char*) bitmap_copy, value_size))) {\n@@ -95,0 +110,1 @@\n+    free(bitmap_copy);\n@@ -97,2 +113,0 @@\n-  memcpy(bitmap_copy, value, length_bytes);\n-  _tags.add({ BITMAP, name_copy, (const unsigned char *) bitmap_copy, length_bytes });\n@@ -102,2 +116,2 @@\n-bool ImageConstraints::persist(const char *image_location) const {\n-  FILE *f = open_tags(image_location, \"w\");\n+bool ImageConstraints::persist(const char* image_location) const {\n+  FILE* f = open_tags(image_location, \"w\");\n@@ -108,2 +122,2 @@\n-    if (tag.type == LABEL) {\n-      fprintf(f, LABEL_PREFIX \"%s=%s\\n\", tag.name, static_cast<const char *>(tag.data));\n+    if (tag.type == TagType::LABEL) {\n+      fprintf(f, LABEL_PREFIX \"%s=%s\\n\", tag.name, static_cast<const char*>(tag.data));\n@@ -112,3 +126,3 @@\n-      const unsigned char *bytes = static_cast<const unsigned char *>(tag.data);\n-      for (const unsigned char *end = bytes + tag.data_length; bytes < end; bytes++) {\n-        fprintf(f, \"%02x\", *bytes);\n+      const unsigned char* bytes = static_cast<const unsigned char*>(tag.data);\n+      for (const unsigned char* end = bytes + tag.data_size; bytes < end; bytes++) {\n+        fprintf(f, \"%02x\",* bytes);\n@@ -126,1 +140,1 @@\n-static inline unsigned char from_hex(char c, bool *err) {\n+static inline unsigned char from_hex(char c, bool& err) {\n@@ -132,1 +146,1 @@\n-    *err = true;\n+    err = true;\n@@ -137,2 +151,2 @@\n-static inline bool check_zeroes(const unsigned char *mem, size_t length) {\n-  for (const unsigned char *end = mem + length; mem < end; ++mem) {\n+static inline bool check_zeroes(const unsigned char* mem, size_t length) {\n+  for (const unsigned char* end = mem + length; mem < end; ++mem) {\n@@ -146,2 +160,2 @@\n-bool ImageConstraints::Constraint::compare_bitmaps(const unsigned char *bitmap, size_t length) const {\n-  size_t common_length = data_length < length ? data_length : length;\n+bool ImageConstraints::Constraint::compare_bitmaps(const unsigned char* bitmap, size_t size) const {\n+  size_t common_size = data_size < size ? data_size : size;\n@@ -149,1 +163,1 @@\n-    if (memcmp(data, bitmap, common_length)) {\n+    if (memcmp(data, bitmap, common_size)) {\n@@ -152,1 +166,1 @@\n-    if (data_length > length && !check_zeroes(static_cast<const unsigned char *>(data) + common_length, data_length - common_length)) {\n+    if (data_size > size && !check_zeroes(static_cast<const unsigned char*>(data) + common_size, data_size - common_size)) {\n@@ -154,1 +168,1 @@\n-    } else if (!check_zeroes(bitmap + common_length, length - common_length)) {\n+    } else if (!check_zeroes(bitmap + common_size, size - common_size)) {\n@@ -159,2 +173,2 @@\n-  const unsigned char *bm1 = bitmap, *bm2 = static_cast<const unsigned char *>(data);\n-  size_t l1 = length, l2 = data_length;\n+  const unsigned char* bm1 = bitmap, * bm2 = static_cast<const unsigned char*>(data);\n+  size_t s1 = size, s2 = data_size;\n@@ -164,2 +178,2 @@\n-    l1 = l2;\n-    l2 = length;\n+    s1 = s2;\n+    s2 = size;\n@@ -168,1 +182,1 @@\n-  for (size_t i = 0; i < common_length; ++i) {\n+  for (size_t i = 0; i < common_size; ++i) {\n@@ -173,2 +187,2 @@\n-  if (l1 > l2) {\n-    return check_zeroes(bm1 + common_length, l1 - common_length);\n+  if (s1 > s2) {\n+    return check_zeroes(bm1 + common_size, s1 - common_size);\n@@ -179,1 +193,1 @@\n-static void print_bitmap(const char *name, const unsigned char *data, size_t length) {\n+static void print_bitmap(const char* name, const unsigned char* data, size_t size) {\n@@ -181,1 +195,1 @@\n-  for (size_t i = 0; i < length; ++i) {\n+  for (size_t i = 0; i < size; ++i) {\n@@ -187,2 +201,2 @@\n-int ImageConstraints::validate(const char *image_location) const {\n-  FILE *f = open_tags(image_location, \"r\");\n+bool ImageConstraints::validate(const char* image_location) const {\n+  FILE* f = open_tags(image_location, \"r\");\n@@ -190,1 +204,1 @@\n-    return errno == ENOENT ? RESTORE_ERROR_NOT_FOUND : RESTORE_ERROR_NO_ACCESS;\n+    return false;\n@@ -192,1 +206,1 @@\n-  char line[strlen(BITMAP_PREFIX) + _max_name_length + 1 + _max_value_length + 2];\n+  char line[strlen(BITMAP_PREFIX) + _MAX_NAME_SIZE + 1 + _MAX_VALUE_SIZE + 2];\n@@ -195,2 +209,2 @@\n-    char *eq = strchr(line, '=');\n-    char *nl = strchr(eq + 1, '\\n');\n+    char* eq = strchr(line, '=');\n+    char* nl = strchr(eq + 1, '\\n');\n@@ -199,1 +213,1 @@\n-      return RESTORE_ERROR_INVALID;\n+      return false;\n@@ -205,4 +219,4 @@\n-      char *name = strdup(line + strlen(LABEL_PREFIX));\n-      char *value = strdup(eq + 1);\n-      if (name == nullptr || value == nullptr) {\n-        fprintf(stderr, CREXEC, \"Cannot allocate memory for validation\\n\");\n+      char* name = strdup(line + strlen(LABEL_PREFIX));\n+      char* value = strdup(eq + 1);\n+      if (name == nullptr || value == nullptr || !tags.add({ TagType::LABEL, name, value, (size_t) (nl - eq) })) {\n+        fprintf(stderr, CREXEC \"Cannot allocate memory for validation\\n\");\n@@ -211,1 +225,1 @@\n-        return RESTORE_ERROR_MEMORY;\n+        return false;\n@@ -213,1 +227,0 @@\n-      tags.add({ LABEL, name, value, (size_t) (nl - eq) });\n@@ -218,1 +231,1 @@\n-        return RESTORE_ERROR_INVALID;\n+        return false;\n@@ -220,1 +233,1 @@\n-      unsigned char *data = (unsigned char *) malloc(length);\n+      unsigned char* data = (unsigned char*) malloc(length);\n@@ -223,1 +236,1 @@\n-        return RESTORE_ERROR_MEMORY;\n+        return false;\n@@ -227,1 +240,1 @@\n-        data[i] = (from_hex(eq[1 + 2 * i], &err) << 4) + from_hex(eq[2 + 2 * i], &err);\n+        data[i] = (from_hex(eq[1 + 2 * i], err) << 4) + from_hex(eq[2 + 2 * i], err);\n@@ -231,1 +244,1 @@\n-        return RESTORE_ERROR_INVALID;\n+        return false;\n@@ -233,2 +246,2 @@\n-      char *name = strdup(line + strlen(BITMAP_PREFIX));\n-      if (name == nullptr) {\n+      char* name = strdup(line + strlen(BITMAP_PREFIX));\n+      if (name == nullptr || !tags.add({ TagType::BITMAP, name, data, length })) {\n@@ -236,0 +249,1 @@\n+        free(name);\n@@ -237,1 +251,1 @@\n-        return RESTORE_ERROR_MEMORY;\n+        return false;\n@@ -239,1 +253,0 @@\n-      tags.add({ BITMAP, name, data, length });\n@@ -242,1 +255,1 @@\n-      return RESTORE_ERROR_INVALID;\n+      return false;\n@@ -245,1 +258,1 @@\n-  const char **keys = new(std::nothrow) const char*[tags.size()];\n+  const char** keys = new(std::nothrow) const char*[tags.size()];\n@@ -248,1 +261,1 @@\n-    return RESTORE_ERROR_MEMORY;\n+    return false;\n@@ -257,0 +270,1 @@\n+  bool result = true;\n@@ -258,1 +272,1 @@\n-    ht.put(t.name, std::move(t));\n+    result = ht.put(t.name, std::move(t)) && result;\n@@ -260,3 +274,3 @@\n-  int result = 0;\n-  _constraints.foreach([&](const Constraint &c) {\n-    Tag *t = ht.get(c.name);\n+  _constraints.foreach([&](Constraint &c) {\n+    Tag* t = ht.get(c.name);\n+    c.failed = true;\n@@ -265,1 +279,0 @@\n-      result = RESTORE_ERROR_INVALID;\n@@ -268,2 +281,1 @@\n-      result = RESTORE_ERROR_INVALID;\n-    } else if (c.type == LABEL && strcmp(static_cast<const char *>(c.data), static_cast<const char *>(t->data))) {\n+    } else if (c.type == TagType::LABEL && strcmp(static_cast<const char*>(c.data), static_cast<const char*>(t->data))) {\n@@ -271,3 +283,2 @@\n-        static_cast<const char *>(c.data), static_cast<const char *>(t->data));\n-      result = RESTORE_ERROR_INVALID;\n-    } else if (c.type == BITMAP && !c.compare_bitmaps(static_cast<const unsigned char *>(t->data), t->data_length)) {\n+        static_cast<const char*>(c.data), static_cast<const char*>(t->data));\n+    } else if (c.type == TagType::BITMAP && !c.compare_bitmaps(static_cast<const unsigned char*>(t->data), t->data_size)) {\n@@ -275,3 +286,4 @@\n-      print_bitmap(\"Constraint: \", static_cast<const unsigned char *>(c.data), c.data_length);\n-      print_bitmap(\"Image:      \", static_cast<const unsigned char *>(t->data), t->data_length);\n-      result = RESTORE_ERROR_INVALID;\n+      print_bitmap(\"Constraint: \", static_cast<const unsigned char*>(c.data), c.data_size);\n+      print_bitmap(\"Image:      \", static_cast<const unsigned char*>(t->data), t->data_size);\n+    } else {\n+      c.failed = false;\n@@ -279,0 +291,1 @@\n+    result = result && !c.failed;\n","filename":"src\/java.base\/share\/native\/libcrexec\/image_constraints.cpp","additions":106,"deletions":93,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include <cstdint>\n@@ -36,1 +37,1 @@\n-  enum TagType {\n+  enum class TagType: std::uint8_t {\n@@ -43,3 +44,16 @@\n-    const char *name;\n-    const void *data;\n-    size_t data_length;\n+    const char* name;\n+    const void* data;\n+    size_t data_size;\n+\n+    Tag() = default;\n+    Tag(TagType t, const char* n, const void* d, size_t ds):\n+      type(t), name(n), data(d), data_size(ds) {}\n+\n+    Tag(Tag &&o) {\n+      type = o.type;\n+      name = o.name;\n+      data = o.data;\n+      data_size = o.data_size;\n+      o.name = nullptr;\n+      o.data = nullptr;\n+    }\n@@ -48,2 +62,2 @@\n-        free((void *) name);\n-        free((void *) data);\n+      free((void*) name);\n+      free((void*) data);\n@@ -52,8 +66,8 @@\n-    Tag &operator=(Tag &&o) {\n-        type = o.type;\n-        name = o.name;\n-        data = o.data;\n-        data_length = o.data_length;\n-        o.name = nullptr;\n-        o.data = nullptr;\n-        return *this;\n+    Tag& operator=(Tag &&o) {\n+      type = o.type;\n+      name = o.name;\n+      data = o.data;\n+      data_size = o.data_size;\n+      o.name = nullptr;\n+      o.data = nullptr;\n+      return *this;\n@@ -65,4 +79,18 @@\n-    const char *name;\n-    const void *data;\n-    size_t data_length;\n-    bitmap_comparison_t comparison;\n+    bool failed;\n+    const char* name;\n+    const void* data;\n+    size_t data_size;\n+    crlib_bitmap_comparison_t comparison;\n+\n+    Constraint(TagType t, const char* n, const void* d, size_t ds, crlib_bitmap_comparison_t c):\n+      type(t), failed(false), name(n), data(d), data_size(ds), comparison(c) {}\n+\n+    Constraint(Constraint &&o) {\n+      type = o.type;\n+      name = o.name;\n+      data = o.data;\n+      data_size = o.data_size;\n+      comparison = o.comparison;\n+      o.name = nullptr;\n+      o.data = nullptr;\n+    }\n@@ -71,2 +99,2 @@\n-        free((void *) name);\n-        free((void *) data);\n+      free((void*) name);\n+      free((void*) data);\n@@ -75,10 +103,0 @@\n-    Constraint &operator=(Constraint &&o) {\n-        type = o.type;\n-        name = o.name;\n-        data = o.data;\n-        data_length = o.data_length;\n-        comparison = o.comparison;\n-        o.name = nullptr;\n-        o.data = nullptr;\n-        return *this;\n-    }\n@@ -86,1 +104,1 @@\n-    bool compare_bitmaps(const unsigned char *bitmap, size_t length) const;\n+    bool compare_bitmaps(const unsigned char* bitmap, size_t length) const;\n@@ -92,2 +110,2 @@\n-  const size_t _max_name_length = 256;\n-  const size_t _max_value_length = 256;\n+  static constexpr const size_t _MAX_NAME_SIZE = 256;\n+  static constexpr const size_t _MAX_VALUE_SIZE = 256;\n@@ -95,9 +113,1 @@\n-  bool check_tag(const char *name) {\n-    bool present = false;\n-    _tags.foreach([&](Tag &tag) {\n-      if (!strcmp(tag.name, name)) {\n-        present = true;\n-      }\n-    });\n-    return present;\n-  }\n+  bool check_tag(const char* type, const char* name, size_t value_size);\n@@ -106,2 +116,2 @@\n-  bool set_label(const char *name, const char *value);\n-  bool set_bitmap(const char *name, const unsigned char *value, size_t length_bytes);\n+  bool set_label(const char* name, const char* value);\n+  bool set_bitmap(const char* name, const unsigned char* value, size_t length_bytes);\n@@ -109,2 +119,2 @@\n-  void require_label(const char *name, const char *value) {\n-    _constraints.add({ LABEL, strdup(name), strdup(value), strlen(value) + 1, EQUALS });\n+  bool require_label(const char* name, const char* value) {\n+    return _constraints.add(Constraint(TagType::LABEL, strdup(name), strdup(value), strlen(value) + 1, EQUALS));\n@@ -113,2 +123,2 @@\n-  void require_bitmap(const char *name, const unsigned char *value, size_t length_bytes, bitmap_comparison_t comparison) {\n-    void *copy = malloc(length_bytes);\n+  bool require_bitmap(const char* name, const unsigned char* value, size_t length_bytes, crlib_bitmap_comparison_t comparison) {\n+    void* copy = malloc(length_bytes);\n@@ -116,1 +126,11 @@\n-    _constraints.add({ BITMAP, strdup(name), copy, length_bytes, comparison });\n+    return _constraints.add(Constraint(TagType::BITMAP, strdup(name), copy, length_bytes, comparison));\n+  }\n+\n+  bool is_failed(const char* name) {\n+    bool result = false;\n+    _constraints.foreach([&](Constraint &c) {\n+      if (!strcmp(c.name, name) && c.failed) {\n+        result = true;\n+      }\n+    });\n+    return result;\n@@ -119,2 +139,2 @@\n-  bool persist(const char *image_location) const;\n-  int validate(const char *image_location) const;\n+  bool persist(const char* image_location) const;\n+  bool validate(const char* image_location) const;\n","filename":"src\/java.base\/share\/native\/libcrexec\/image_constraints.hpp","additions":71,"deletions":51,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -35,1 +35,4 @@\n-    Node *_next;\n+    Node* _next;\n+\n+    template<typename TT>\n+    Node(TT&& v): _item(std::forward<TT>(v)) {}\n@@ -38,13 +41,3 @@\n-  Node *_head;\n-  Node *_tail;\n-  size_t _size;\n-public:\n-  LinkedList(): _head(nullptr), _tail(nullptr), _size(0) {}\n-  ~LinkedList() {\n-    Node *node = _head;\n-    while (node) {\n-      Node *next = node->_next;\n-      delete node;\n-      node = next;\n-    }\n-  }\n+  Node* _head = nullptr;\n+  Node* _tail = nullptr;\n+  size_t _size = 0;\n@@ -52,3 +45,4 @@\n-  T& add(T&& item) {\n-    Node *node = new(std::nothrow) Node();\n-    node->_item = std::forward<T>(item);\n+  inline bool add_node(Node *node) {\n+    if (node == nullptr) {\n+      return false;\n+    }\n@@ -58,0 +52,1 @@\n+      _tail = node;\n@@ -65,1 +60,1 @@\n-    return node->_item;\n+    return true;\n@@ -68,1 +63,2 @@\n-  template<typename Func> void foreach(Func f) const {\n+public:\n+  ~LinkedList() {\n@@ -70,0 +66,17 @@\n+    while (node) {\n+      Node *next = node->_next;\n+      delete node;\n+      node = next;\n+    }\n+  }\n+\n+  bool add(T&& item) {\n+    return add_node(new(std::nothrow) Node(std::move(item)));\n+  }\n+\n+  bool add(const T& item) {\n+    return add_node(new(std::nothrow) Node(item));\n+  }\n+\n+  template<typename Func> void foreach(Func f) const {\n+    Node* node = _head;\n@@ -76,1 +89,1 @@\n-  size_t size() {\n+  size_t size() const {\n","filename":"src\/java.base\/share\/native\/libcrexec\/linkedlist.hpp","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-(set +e;echo \"$restore\"|grep \"the image is either corrupted or does not match current CPU\" && ! echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n+(set +e;echo \"$restore\"|grep \"Restore failed due to incompatible or missing CPU features\" && ! echo \"$restore\"|grep \"CPUFeaturesCheck \";checkpoint_restore_result)\n","filename":"test\/jdk\/jdk\/crac\/CPUFeatures\/CPUFeatures.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            .shouldContain(\"the image or its part cannot be found\").shouldContain(MAIN_MSG);\n+            .shouldContain(\"cannot open cr\/tags in mode r\").shouldContain(MAIN_MSG);\n","filename":"test\/jdk\/jdk\/crac\/ignoreRestore\/NoCPUFeaturesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}