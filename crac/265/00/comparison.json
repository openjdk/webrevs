{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2023-2025, Azul Systems, Inc. All rights reserved.\n@@ -25,0 +25,1 @@\n+import jdk.test.lib.crac.AsyncStreamReader;\n@@ -38,1 +39,0 @@\n-import java.io.InputStream;\n@@ -41,1 +41,0 @@\n-import java.io.IOException;\n@@ -43,2 +42,1 @@\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n@@ -91,2 +89,3 @@\n-    private void waitForString(BufferedReader reader, String str) throws IOException {\n-        for (String line = reader.readLine(); true; line = reader.readLine()) {\n+    private void waitForString(AsyncStreamReader reader, String str, long timeoutMillis) throws Exception {\n+        while (true) {\n+            String line = reader.readLine(timeoutMillis);\n@@ -99,0 +98,5 @@\n+    private void waitForString(AsyncStreamReader reader, String str) throws Exception {\n+        final long timeoutMillis = 30000;\n+        waitForString(reader, str, timeoutMillis);\n+    }\n+\n@@ -107,1 +111,2 @@\n-        var errReader = new BufferedReader(new InputStreamReader(process.errOutput()));\n+        var errReader = new AsyncStreamReader(process.errOutput());\n+        var reader = new AsyncStreamReader(process.output());\n@@ -109,1 +114,0 @@\n-            var reader = new BufferedReader(new InputStreamReader(process.output()));\n@@ -143,0 +147,5 @@\n+        } catch (TimeoutException e) {\n+            System.err.println(\"reader.isRunning()=\" + reader.isRunning());\n+            CracProcess.printThreadDump(process.pid());\n+            CracProcess.dumpProcess(process.pid());\n+            throw e;\n@@ -144,2 +153,4 @@\n-                for (String line = errReader.readLine(); null != line; line = errReader.readLine()) {\n-                    System.err.println(line);\n+            try {\n+                final long timeoutMillis = 1000;\n+                while (true) {\n+                    System.err.println(\"APP STDERR: \" + errReader.readLine(timeoutMillis));\n@@ -147,1 +158,4 @@\n-                process.destroyForcibly();\n+            } catch (TimeoutException e) {\n+                \/\/ do nothing\n+            }\n+            process.destroyForcibly();\n@@ -153,1 +167,2 @@\n-        System.out.println(STARTED);\n+        System.out.println(STARTED + \", pid=\" + ProcessHandle.current().pid());\n+        System.out.flush();\n@@ -160,1 +175,0 @@\n-\n","filename":"test\/jdk\/jdk\/crac\/jdwp\/JdwpTransportTest.java","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+package jdk.test.lib.crac;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class AsyncStreamReader {\n+    private final LinkedBlockingQueue<String> lines = new LinkedBlockingQueue<>();\n+    private volatile boolean isRunning = true;\n+\n+    public AsyncStreamReader(InputStream stream) {\n+        Thread t = new Thread(() -> {\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(stream))) {\n+                for (String line; (line = reader.readLine()) != null;) {\n+                    lines.put(line);\n+                }\n+            } catch (IOException | InterruptedException e) {\n+                e.printStackTrace();\n+            } finally {\n+                isRunning = false;\n+            }\n+        });\n+        t.setDaemon(true);\n+        t.start();\n+    }\n+\n+    public String readLine(long timeoutMillis) throws TimeoutException, InterruptedException {\n+        String line = lines.poll(timeoutMillis, TimeUnit.MILLISECONDS);\n+        if (line == null) {\n+            throw new TimeoutException(\"Timeout \" + timeoutMillis + \" msecs while waiting for new line\");\n+        }\n+        return line;\n+    }\n+\n+    public boolean isRunning() {\n+        return isRunning;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/AsyncStreamReader.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -6,0 +6,1 @@\n+import java.io.BufferedReader;\n@@ -8,0 +9,1 @@\n+import java.io.InputStreamReader;\n@@ -195,0 +197,67 @@\n+\n+    public static void printThreadDump(long pid) throws IOException {\n+        boolean isAlive = ProcessHandle.of(pid).map(ProcessHandle::isAlive).orElse(false);\n+        if (!isAlive) {\n+            System.err.println(\"Process \" + pid + \" is not alive.\");\n+        } else {\n+            System.err.println(\"Running: jcmd \" + pid + \" Thread.print\");\n+            Process jcmdProc = new ProcessBuilder(jdk.test.lib.Utils.TEST_JDK + \"\/bin\/jcmd\", String.valueOf(pid), \"Thread.print\")\n+                    .redirectErrorStream(true)\n+                    .start();\n+            try (BufferedReader reader = new BufferedReader(new InputStreamReader(jcmdProc.getInputStream()))) {\n+                for (String line = reader.readLine(); null != line; line = reader.readLine()) {\n+                    System.err.println(\"JCMD: \" + line);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean checkGcoreAvailable() {\n+        ProcessBuilder builder = new ProcessBuilder(\"which\", \"gcore\");\n+        builder.redirectErrorStream(true);\n+        try {\n+            Process process = builder.start();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n+            String line = reader.readLine();\n+            int exitCode = process.waitFor();\n+            if (exitCode == 0 && line != null && !line.trim().isEmpty()) {\n+                System.out.println(\"gcore is available.\");\n+                return true;\n+            } else {\n+                System.out.println(\"gcore is NOT available.\");\n+                return false;\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            System.out.println(\"Could not run 'which gcore' or was interrupted\");\n+            return false;\n+        }\n+    }\n+\n+    public static void dumpProcess(long pid) throws IOException, InterruptedException {\n+        \/\/ For gcore, it's required 'sudo sysctl -w kernel.yama.ptrace_scope=0'\n+        \/\/ For kill, it's required 'ulimit -c unlimited && echo core.%p | sudo tee \/proc\/sys\/kernel\/core_pattern'\n+        ProcessBuilder builder = checkGcoreAvailable() ? new ProcessBuilder(\"gcore\", String.valueOf(pid))\n+                : new ProcessBuilder(\"kill\", \"-ABRT\", String.valueOf(pid));\n+        builder.redirectErrorStream(true);\n+        try {\n+            Process process = builder.start();\n+            var reader = new AsyncStreamReader(process.getInputStream());\n+            int exitCode = process.waitFor();\n+            try {\n+                while (true) {\n+                    System.out.println(\"dumpProcess: \" + reader.readLine(100));\n+                }\n+            } catch (Exception e) {\n+                \/\/ do nothing\n+            }\n+            if (exitCode == 0) {\n+                System.out.println(\"Core dump seems created successfully for pid=\" + pid);\n+            } else {\n+                System.out.println(\"Something went wrong while dumping the app\");\n+            }\n+        } catch (IOException | InterruptedException e) {\n+            System.out.println(\"Exception thrown while dumping the app\");\n+            e.printStackTrace();\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"}]}