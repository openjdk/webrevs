{"files":[{"patch":"@@ -596,3 +596,0 @@\n-    \/** Number of CPUS, to place bounds on some sizings *\/\n-    static final int NCPU = Runtime.getRuntime().availableProcessors();\n-\n@@ -2426,1 +2423,2 @@\n-        if ((stride = (NCPU > 1) ? (n >>> 3) \/ NCPU : n) < MIN_TRANSFER_STRIDE)\n+        int ncpu = CpuCount.get();\n+        if ((stride = (ncpu > 1) ? (n >>> 3) \/ ncpu : n) < MIN_TRANSFER_STRIDE)\n@@ -2621,1 +2619,1 @@\n-                else if (counterCells != cs || n >= NCPU)\n+                else if (counterCells != cs || n >= CpuCount.get())\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+package java.util.concurrent;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n+final class CpuCount {\n+    private static int NCPU = Runtime.getRuntime().availableProcessors();\n+    private static final JDKResource RESOURCE = new JDKResource() {\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.NORMAL;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            NCPU = Runtime.getRuntime().availableProcessors();\n+        }\n+    };\n+\n+    static {\n+        Core.getJDKContext().register(RESOURCE);\n+    }\n+\n+    \/**\n+     * This method returns the same number as {@link Runtime#availableProcessors()}\n+     * but the invocation is cheaper as it does so by accessing a static field caching\n+     * the value. Therefore, it is not guaranteed to return the most up-to-date value.\n+     *\n+     * @return Number of CPUs.\n+     *\/\n+    public static int get() {\n+        return NCPU;\n+    }\n+\n+    private CpuCount() {}\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CpuCount.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -270,10 +270,0 @@\n-    \/** The number of CPUs, for sizing and spin control *\/\n-    private static final int NCPU = Runtime.getRuntime().availableProcessors();\n-\n-    \/**\n-     * The maximum slot index of the arena: The number of slots that\n-     * can in principle hold all threads without contention, or at\n-     * most the maximum indexable value.\n-     *\/\n-    static final int FULL = (NCPU >= (MMASK << 1)) ? MMASK : NCPU >>> 1;\n-\n@@ -344,0 +334,10 @@\n+    \/**\n+     * The maximum slot index of the arena: The number of slots that\n+     * can in principle hold all threads without contention, or at\n+     * most the maximum indexable value.\n+     *\/\n+    private static int full() {\n+        int ncpu = CpuCount.get();\n+        return (ncpu >= (MMASK << 1)) ? MMASK : ncpu >>> 1;\n+    }\n+\n@@ -430,1 +430,1 @@\n-                else if ((c = p.collides) < m || m == FULL ||\n+                else if ((c = p.collides) < m || m == full() ||\n@@ -469,1 +469,1 @@\n-                if (NCPU > 1 && bound == 0 &&\n+                if (CpuCount.get() > 1 && bound == 0 &&\n@@ -471,1 +471,1 @@\n-                    arena = new Node[(FULL + 2) << ASHIFT];\n+                    arena = new Node[(full() + 2) << ASHIFT];\n@@ -486,1 +486,1 @@\n-        int spins = (NCPU > 1) ? SPINS : 1;\n+        int spins = (CpuCount.get() > 1) ? SPINS : 1;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Exchanger.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -51,0 +56,1 @@\n+import java.util.function.IntSupplier;\n@@ -1413,1 +1419,1 @@\n-    final int bounds;                    \/\/ min, max threads packed as shorts\n+    int bounds;                          \/\/ min, max threads packed as shorts\n@@ -1426,0 +1432,2 @@\n+    private final AutoResize resizeResource;\n+\n@@ -2547,0 +2555,15 @@\n+        if (isAllowResize() && p == Runtime.getRuntime().availableProcessors()) {\n+            resizeResource = new AutoResize(() -> Runtime.getRuntime().availableProcessors());\n+        } else {\n+            resizeResource = null;\n+        }\n+    }\n+\n+    private static boolean isAllowResize() {\n+        boolean allowResize = true;\n+        try {\n+            String allow = System.getProperty(\"java.util.concurrent.ForkJoinPool.allowResize\");\n+            allowResize = allow == null || \"true\".equalsIgnoreCase(allow);\n+        } catch (Exception ignore) {\n+        }\n+        return allowResize;\n@@ -2567,0 +2590,1 @@\n+        long ka = DEFAULT_KEEPALIVE;\n@@ -2576,0 +2600,4 @@\n+            String kas = System.getProperty\n+                (\"java.util.concurrent.ForkJoinPool.common.keepAlive\");\n+            if (kas != null)\n+                ka = Long.parseLong(kas);\n@@ -2579,1 +2607,1 @@\n-        this.keepAlive = DEFAULT_KEEPALIVE;\n+        this.keepAlive = ka;\n@@ -2598,0 +2626,5 @@\n+        if (isAllowResize()) {\n+            resizeResource = new AutoResize(() -> Runtime.getRuntime().availableProcessors() - 1);\n+        } else {\n+            resizeResource = null;\n+        }\n@@ -3515,0 +3548,36 @@\n+\n+    private class AutoResize implements JDKResource {\n+        private final IntSupplier parallelismSupplier;\n+\n+        public AutoResize(IntSupplier parallelismSuplier) {\n+            this.parallelismSupplier = parallelismSuplier;\n+            Core.getJDKContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            int p = parallelismSupplier.getAsInt();\n+            int m = mode;\n+            int oldP = m & SMASK;\n+            int newSpares = Math.max(0, (bounds >>> SWIDTH) + oldP - p);\n+            int newMinAvail = ((bounds & SMASK) + oldP - p);\n+            if (ForkJoinPool.this == ForkJoinPool.common && p > 0) {\n+                newSpares = ForkJoinPool.COMMON_MAX_SPARES;\n+                newMinAvail = 1 - p;\n+            }\n+            bounds = (newMinAvail & SMASK) | (newSpares << SWIDTH);\n+            while (m < SHUTDOWN && !MODE.compareAndSet(ForkJoinPool.this, m, (p & SMASK) | (m & ~SMASK))) {\n+                m = mode;\n+            }\n+            getAndAddCtl((((oldP - p) * TC_UNIT) & TC_MASK) + (((oldP - p) * RC_UNIT) & RC_MASK));\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.NORMAL;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":71,"deletions":2,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1005,3 +1005,0 @@\n-    \/** The number of CPUs, for spin control *\/\n-    private static final int NCPU = Runtime.getRuntime().availableProcessors();\n-\n@@ -1019,1 +1016,3 @@\n-    static final int SPINS_PER_ARRIVAL = (NCPU < 2) ? 1 : 1 << 8;\n+    private static int spinsPerArrival() {\n+        return CpuCount.get() < 2 ? 1 : 1 << 8;\n+    }\n@@ -1035,1 +1034,1 @@\n-        int spins = SPINS_PER_ARRIVAL;\n+        int spins = spinsPerArrival();\n@@ -1042,2 +1041,2 @@\n-                    (lastUnarrived = unarrived) < NCPU)\n-                    spins += SPINS_PER_ARRIVAL;\n+                    (lastUnarrived = unarrived) < CpuCount.get())\n+                    spins += spinsPerArrival();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Phaser.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -153,1 +158,16 @@\n-    static final int NCPU = Runtime.getRuntime().availableProcessors();\n+    private static int NCPU = Runtime.getRuntime().availableProcessors();\n+    private static final JDKResource RESOURCE = new JDKResource() {\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.NORMAL;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            NCPU = Runtime.getRuntime().availableProcessors();\n+        }\n+    };\n@@ -384,0 +404,1 @@\n+        Core.getJDKContext().register(RESOURCE);\n@@ -405,1 +426,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build ForkJoinPoolResizeTest\n+ * @run driver jdk.test.lib.crac.CracTest 1 4\n+ * @run driver jdk.test.lib.crac.CracTest 8 16\n+ * @run driver jdk.test.lib.crac.CracTest 4 1\n+ * @run driver jdk.test.lib.crac.CracTest 16 1\n+ * @run driver jdk.test.lib.crac.CracTest 1 1\n+ * @run driver jdk.test.lib.crac.CracTest 4 4\n+ *\/\n+public class ForkJoinPoolResizeTest implements CracTest {\n+    public static final String IMAGE_NAME = Common.imageName(\"fork-join-pool\");\n+    public static final long KEEP_ALIVE_TIME = 100; \/\/ milliseconds\n+    @CracTestArg(0)\n+    int initialCpus;\n+\n+    @CracTestArg(1)\n+    int restoreCpus;\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            System.err.println(\"Docker not available\");\n+            return;\n+        }\n+        int cpus = Runtime.getRuntime().availableProcessors();\n+        if (initialCpus > cpus || restoreCpus > cpus) {\n+            System.err.printf(\"Ignoring test that requires %d CPUs but we have at most %d%n\", Math.max(initialCpus, restoreCpus), cpus);\n+            return;\n+        }\n+        CracBuilder builder = new CracBuilder().inDockerImage(IMAGE_NAME);\n+        builder.dockerOptions(\"--cpus\", String.valueOf(initialCpus)).doCheckpoint();\n+        builder.recreateContainer(IMAGE_NAME, \"--cpus\", String.valueOf(restoreCpus));\n+        builder.doRestore();\n+\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        assertEquals(initialCpus, Runtime.getRuntime().availableProcessors());\n+        AtomicInteger threadCounter = new AtomicInteger(0);\n+        ForkJoinPool fjp = new ForkJoinPool(initialCpus, pool -> {\n+            threadCounter.incrementAndGet();\n+            return ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);\n+        }, null, false,\n+                initialCpus, 100, 1, null, KEEP_ALIVE_TIME, TimeUnit.MILLISECONDS);\n+        assertEquals(0, fjp.getPoolSize());\n+        assertEquals(initialCpus, fjp.getParallelism());\n+\n+        CountDownLatch firstBatchStart = new CountDownLatch(initialCpus);\n+        \/\/ We use twice as many jobs to make sure not more than expected threads are created\n+        CountDownLatch firstBatchEnd = new CountDownLatch(initialCpus * 2);\n+        startJobs(fjp, firstBatchStart, firstBatchEnd, initialCpus * 2);\n+        firstBatchStart.await();\n+        assertEquals(initialCpus, fjp.getActiveThreadCount());\n+        firstBatchEnd.await();\n+        assertEquals(initialCpus, fjp.getPoolSize());\n+\n+        \/\/ If we wait > initialCpus * keep alive the threads will die\n+        Thread.sleep((initialCpus + 1) * KEEP_ALIVE_TIME);\n+        assertEquals(0, fjp.getActiveThreadCount());\n+        assertEquals(0, fjp.getPoolSize());\n+        threadCounter.set(0);\n+\n+        Core.checkpointRestore();\n+        assertEquals(restoreCpus, Runtime.getRuntime().availableProcessors());\n+        assertEquals(restoreCpus, fjp.getParallelism());\n+\n+        CountDownLatch secondBatchStart = new CountDownLatch(restoreCpus);\n+        CountDownLatch thirdBatchEnd = new CountDownLatch(restoreCpus);\n+        \/\/ Scheduling jobs does not immediately start all the threads; we have to wait for them to start\n+        startJobs(fjp, secondBatchStart, null, restoreCpus);\n+        startJobs(fjp, null, thirdBatchEnd, restoreCpus);\n+        secondBatchStart.await();\n+\n+        assertEquals(restoreCpus, fjp.getPoolSize());\n+        \/\/ The active thread count is somewhat unreliable\n+\/\/        assertEquals(restoreCpus, fjp.getActiveThreadCount());\n+        assertEquals(restoreCpus, threadCounter.get());\n+\n+        thirdBatchEnd.await();\n+        \/\/ This should let any extra threads die off\n+        Thread.sleep((restoreCpus + 1) * KEEP_ALIVE_TIME);\n+        assertEquals(0, fjp.getPoolSize());\n+        assertEquals(0, fjp.getActiveThreadCount());\n+    }\n+\n+    private static void startJobs(ForkJoinPool fjp, CountDownLatch startLatch, CountDownLatch completeLatch, int count) {\n+        for (int i = 0; i < count; ++i) {\n+            fjp.execute(() -> {\n+                if (startLatch != null) {\n+                    startLatch.countDown();\n+                }\n+                System.out.println(Thread.currentThread().getName() + \" \" + System.currentTimeMillis() + \" START\");\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                if (completeLatch != null) {\n+                    completeLatch.countDown();\n+                }\n+                System.out.println(Thread.currentThread().getName() + \" \" + System.currentTimeMillis() + \" COMPLETE \");\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/util\/concurrent\/ForkJoinPoolResizeTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}