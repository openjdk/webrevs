{"files":[{"patch":"@@ -111,2 +111,1 @@\n-    --override-methods=summary \\\n-    --no-external-specs-page\n+    --override-methods=summary\n@@ -118,2 +117,1 @@\n-    -html5 -javafx --expand-requires transitive \\\n-    --no-external-specs-page\n+    -html5 -javafx --expand-requires transitive\n","filename":"make\/Docs.gmk","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -562,0 +562,3 @@\n+# LDFLAGS used to link the static jdk library\n+LDFLAGS_STATIC_JDK := @LDFLAGS_STATIC_JDK@\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -181,0 +181,6 @@\n+  else ifeq ($(call isCompiler, clang), true)\n+    JVM_CFLAGS_FEATURES += -flto -fno-strict-aliasing\n+    ifeq ($(call isBuildOs, aix), true)\n+      JVM_CFLAGS_FEATURES += -ffat-lto-objects\n+    endif\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto -fno-strict-aliasing\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  static bool supports_float16() { return PowerArchitecturePPC64 >= 9; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,0 +119,2 @@\n+  \/\/ Zicond Conditional operations\n+  \/\/\n@@ -167,0 +169,1 @@\n+  decl(ext_Zicond      , \"Zicond\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicond))      \\\n@@ -226,0 +229,1 @@\n+    RV_ENABLE_EXTENSION(UseZicond)                  \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-#define  LongDispFacilityMask           0x0000200000000000UL  \/\/ z900 with microcode update\n-#define  LongDispFacilityHighPerfMask   0x0000300000000000UL  \/\/ z990\n+#define  LongDispFacilityMask           0x0000200000000000UL  \/\/ z900 with microcode update, Bit: 18\n+#define  LongDispFacilityHighPerfMask   0x0000100000000000UL  \/\/ z990, Bit: 19\n@@ -67,1 +67,2 @@\n-#define  DecimalFloatingPointMask       0x0000000000300000UL  \/\/ z10\n+#define  DecimalFloatingPointMask       0x0000000000200000UL  \/\/ z10, Bit: 42\n+#define  DecimalFloatingPointHighPerfMask 0x0000000000100000UL  \/\/ z10, Bit: 43\n@@ -117,0 +118,6 @@\n+#define NNPAssistFacilityMask           0x0000000004000000UL  \/\/ z16, Neural-network-processing-assist facility, Bit: 165\n+\n+\/\/ ----------------------------------------------\n+\/\/ --- FeatureBitString Bits 193..200 (DW[3]) ---\n+\/\/ ----------------------------------------------\n+#define  BEAREnhFacilityMask            0x4000000000000000UL  \/\/ z16, BEAR-enhancement facility, Bit: 193\n@@ -182,3 +189,4 @@\n-  static bool is_z13()  { return has_CryptoExt5()             && !has_MiscInstrExt2();}\n-  static bool is_z14()  { return has_MiscInstrExt2()          && !has_MiscInstrExt3();}\n-  static bool is_z15()  { return has_MiscInstrExt3();}\n+  static bool is_z13()  { return has_CryptoExt5()             && !has_MiscInstrExt2(); }\n+  static bool is_z14()  { return has_MiscInstrExt2()          && !has_MiscInstrExt3(); }\n+  static bool is_z15()  { return has_MiscInstrExt3()          && !has_BEAR_Enh_Facility(); }\n+  static bool is_z16()  { return has_BEAR_Enh_Facility(); }\n@@ -460,0 +468,1 @@\n+  static bool has_DecimalFloatingPointHighPerf() { return  (_features[0] & DecimalFloatingPointHighPerfMask) == DecimalFloatingPointHighPerfMask; }\n@@ -491,0 +500,3 @@\n+  static bool has_BEAR_Enh_Facility()         { return  (_features[3] & BEAREnhFacilityMask)           == BEAREnhFacilityMask; }\n+  static bool has_NNP_Assist_Facility()       { return  (_features[2] & NNPAssistFacilityMask)         == NNPAssistFacilityMask; }\n+\n@@ -513,0 +525,1 @@\n+  static void set_has_DecimalFloatingPointHighPerf() { _features[0] |= DecimalFloatingPointHighPerfMask; }\n@@ -563,0 +576,2 @@\n+  static void set_has_BEAR_Enh_Facility()         { _features[3] |= BEAREnhFacilityMask;}\n+  static void set_has_NNP_Assist_Facility()       { _features[2] |= NNPAssistFacilityMask;}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -468,3 +468,7 @@\n-\/\/ i386: 224, ia64: 1105, amd64: 186, sparc: 143\n-  #ifdef __ia64__\n-    #define SYS_gettid 1105\n+\/\/ i386: 224, amd64: 186, sparc: 143\n+  #if defined(__i386__)\n+    #define SYS_gettid 224\n+  #elif defined(__amd64__)\n+    #define SYS_gettid 186\n+  #elif defined(__sparc__)\n+    #define SYS_gettid 143\n@@ -472,13 +476,1 @@\n-    #ifdef __i386__\n-      #define SYS_gettid 224\n-    #else\n-      #ifdef __amd64__\n-        #define SYS_gettid 186\n-      #else\n-        #ifdef __sparc__\n-          #define SYS_gettid 143\n-        #else\n-          #error define gettid for the arch\n-        #endif\n-      #endif\n-    #endif\n+    #error \"Define SYS_gettid for this architecture\"\n@@ -486,2 +478,1 @@\n-#endif\n-\n+#endif \/\/ SYS_gettid\n@@ -582,0 +573,1 @@\n+#define JVM_LIB_NAME \"libjvm.so\"\n@@ -596,6 +588,4 @@\n-    \/\/ Found the full path to libjvm.so.\n-    \/\/ Now cut the path to <java_home>\/jre if we can.\n-    pslash = strrchr(buf, '\/');\n-    if (pslash != nullptr) {\n-      *pslash = '\\0';            \/\/ Get rid of \/libjvm.so.\n-    }\n+    \/\/ Found the full path to the binary. It is normally of this structure:\n+    \/\/   <jdk_path>\/lib\/<hotspot_variant>\/libjvm.so\n+    \/\/ but can also be like this for a statically linked binary:\n+    \/\/   <jdk_path>\/bin\/<executable>\n@@ -604,1 +594,11 @@\n-      *pslash = '\\0';            \/\/ Get rid of \/{client|server|hotspot}.\n+      if (strncmp(pslash + 1, JVM_LIB_NAME, strlen(JVM_LIB_NAME)) == 0) {\n+        \/\/ Binary name is libjvm.so. Get rid of \/libjvm.so.\n+        *pslash = '\\0';\n+      }\n+\n+      \/\/ Get rid of \/<hotspot_variant>, if binary is libjvm.so,\n+      \/\/ or cut off \/<executable>, if it is a statically linked binary.\n+      pslash = strrchr(buf, '\/');\n+      if (pslash != nullptr) {\n+        *pslash = '\\0';\n+      }\n@@ -608,0 +608,2 @@\n+    \/\/ Get rid of \/lib, if binary is libjvm.so,\n+    \/\/ or cut off \/bin, if it is a statically linked binary.\n@@ -611,1 +613,1 @@\n-        *pslash = '\\0';        \/\/ Get rid of \/lib.\n+        *pslash = '\\0';\n@@ -1199,3 +1201,3 @@\n-  \/\/ We are told to free resources of the argument thread,\n-  \/\/ but we can only really operate on the current thread.\n-  assert(Thread::current()->osthread() == osthread,\n+  \/\/ We are told to free resources of the argument thread, but we can only really operate\n+  \/\/ on the current thread. The current thread may be already detached at this point.\n+  assert(Thread::current_or_null() == nullptr || Thread::current()->osthread() == osthread,\n@@ -1789,2 +1791,0 @@\n-#elif  (defined IA64)\n-  static  Elf32_Half running_arch_code=EM_IA_64;\n@@ -1823,1 +1823,1 @@\n-        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n+        AARCH64, ALPHA, ARM, AMD64, IA32, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n@@ -2730,2 +2730,0 @@\n-#elif defined(IA64)\n-  strncpy(cpuinfo, \"IA64\", length);\n@@ -4595,1 +4593,1 @@\n-  char* codebuf = os::attempt_reserve_memory_at(hint, page_size);\n+  char* codebuf = os::attempt_reserve_memory_at(hint, page_size, false, mtThread);\n@@ -4603,1 +4601,1 @@\n-    codebuf = os::attempt_reserve_memory_at(hint, page_size);\n+    codebuf = os::attempt_reserve_memory_at(hint, page_size, false, mtThread);\n@@ -4610,2 +4608,0 @@\n-  MemTracker::record_virtual_memory_tag((address)codebuf, mtInternal);\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":34,"deletions":38,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -859,0 +859,6 @@\n+void* os::lookup_function(const char* name) {\n+  \/\/ This returns the global symbol in the main executable and its dependencies,\n+  \/\/ as well as shared objects dynamically loaded with RTLD_GLOBAL flag.\n+  return dlsym(RTLD_DEFAULT, name);\n+}\n+\n@@ -952,45 +958,0 @@\n-\/\/ Builds a platform dependent Agent_OnLoad_<lib_name> function name\n-\/\/ which is used to find statically linked in agents.\n-\/\/ Parameters:\n-\/\/            sym_name: Symbol in library we are looking for\n-\/\/            lib_name: Name of library to look in, null for shared libs.\n-\/\/            is_absolute_path == true if lib_name is absolute path to agent\n-\/\/                                     such as \"\/a\/b\/libL.so\"\n-\/\/            == false if only the base name of the library is passed in\n-\/\/               such as \"L\"\n-char* os::build_agent_function_name(const char *sym_name, const char *lib_name,\n-                                    bool is_absolute_path) {\n-  char *agent_entry_name;\n-  size_t len;\n-  size_t name_len;\n-  size_t prefix_len = strlen(JNI_LIB_PREFIX);\n-  size_t suffix_len = strlen(JNI_LIB_SUFFIX);\n-  const char *start;\n-\n-  if (lib_name != nullptr) {\n-    name_len = strlen(lib_name);\n-    if (is_absolute_path) {\n-      \/\/ Need to strip path, prefix and suffix\n-      if ((start = strrchr(lib_name, *os::file_separator())) != nullptr) {\n-        lib_name = ++start;\n-      }\n-      if (strlen(lib_name) <= (prefix_len + suffix_len)) {\n-        return nullptr;\n-      }\n-      lib_name += prefix_len;\n-      name_len = strlen(lib_name) - suffix_len;\n-    }\n-  }\n-  len = (lib_name != nullptr ? name_len : 0) + strlen(sym_name) + 2;\n-  agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);\n-  if (agent_entry_name == nullptr) {\n-    return nullptr;\n-  }\n-  strcpy(agent_entry_name, sym_name);\n-  if (lib_name != nullptr) {\n-    strcat(agent_entry_name, \"_\");\n-    strncat(agent_entry_name, lib_name, name_len);\n-  }\n-  return agent_entry_name;\n-}\n-\n@@ -2285,1 +2246,0 @@\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":6,"deletions":46,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -963,4 +963,0 @@\n-#if defined(IA64) && defined(LINUX)\n-    { SIGILL,  ILL_BADIADDR, \"ILL_BADIADDR\", \"Unimplemented instruction address\" },\n-    { SIGILL,  ILL_BREAK,    \"ILL_BREAK\",    \"Application Break instruction\" },\n-#endif\n@@ -980,3 +976,0 @@\n-#endif\n-#if defined(IA64) && !defined(AIX)\n-    { SIGSEGV, SEGV_PSTKOVF, \"SEGV_PSTKOVF\", \"Paragraph stack overflow\" },\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -792,3 +792,3 @@\n-  \/\/ We are told to free resources of the argument thread,\n-  \/\/ but we can only really operate on the current thread.\n-  assert(Thread::current()->osthread() == osthread,\n+  \/\/ We are told to free resources of the argument thread, but we can only really operate\n+  \/\/ on the current thread. The current thread may be already detached at this point.\n+  assert(Thread::current_or_null() == nullptr || Thread::current()->osthread() == osthread,\n@@ -1420,0 +1420,6 @@\n+void* os::lookup_function(const char* name) {\n+  \/\/ This is needed only for static builds which are not supported on Windows\n+  ShouldNotReachHere();\n+  return nullptr; \/\/ Satisfy compiler\n+}\n+\n@@ -5909,51 +5915,0 @@\n-\/\/ Builds a platform dependent Agent_OnLoad_<lib_name> function name\n-\/\/ which is used to find statically linked in agents.\n-\/\/ Parameters:\n-\/\/            sym_name: Symbol in library we are looking for\n-\/\/            lib_name: Name of library to look in, null for shared libs.\n-\/\/            is_absolute_path == true if lib_name is absolute path to agent\n-\/\/                                     such as \"C:\/a\/b\/L.dll\"\n-\/\/            == false if only the base name of the library is passed in\n-\/\/               such as \"L\"\n-char* os::build_agent_function_name(const char *sym_name, const char *lib_name,\n-                                    bool is_absolute_path) {\n-  char *agent_entry_name;\n-  size_t len;\n-  size_t name_len;\n-  size_t prefix_len = strlen(JNI_LIB_PREFIX);\n-  size_t suffix_len = strlen(JNI_LIB_SUFFIX);\n-  const char *start;\n-\n-  if (lib_name != nullptr) {\n-    len = name_len = strlen(lib_name);\n-    if (is_absolute_path) {\n-      \/\/ Need to strip path, prefix and suffix\n-      if ((start = strrchr(lib_name, *os::file_separator())) != nullptr) {\n-        lib_name = ++start;\n-      } else {\n-        \/\/ Need to check for drive prefix\n-        if ((start = strchr(lib_name, ':')) != nullptr) {\n-          lib_name = ++start;\n-        }\n-      }\n-      if (len <= (prefix_len + suffix_len)) {\n-        return nullptr;\n-      }\n-      lib_name += prefix_len;\n-      name_len = strlen(lib_name) - suffix_len;\n-    }\n-  }\n-  len = (lib_name != nullptr ? name_len : 0) + strlen(sym_name) + 2;\n-  agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);\n-  if (agent_entry_name == nullptr) {\n-    return nullptr;\n-  }\n-\n-  strcpy(agent_entry_name, sym_name);\n-  if (lib_name != nullptr) {\n-    strcat(agent_entry_name, \"_\");\n-    strncat(agent_entry_name, lib_name, name_len);\n-  }\n-  return agent_entry_name;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":9,"deletions":54,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -746,1 +746,1 @@\n-  \/* Thread.dump_to_file jcmd *\/                                                                                  \\\n+  \/* jcmd Thread.dump_to_file *\/                                                                                  \\\n@@ -750,0 +750,5 @@\n+                                                                                                                  \\\n+  \/* jcmd Thread.vthread_scheduler and Thread.vthread_pollers *\/                                                  \\\n+  template(jdk_internal_vm_JcmdVThreadCommands,    \"jdk\/internal\/vm\/JcmdVThreadCommands\")                         \\\n+  template(printScheduler_name,                    \"printScheduler\")                                              \\\n+  template(printPollers_name,                      \"printPollers\")                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1150,7 +1150,0 @@\n-#define JNI_ONLOAD_SYMBOLS   {\"JNI_OnLoad\"}\n-#define JNI_ONUNLOAD_SYMBOLS {\"JNI_OnUnload\"}\n-#define JVM_ONLOAD_SYMBOLS      {\"JVM_OnLoad\"}\n-#define AGENT_ONLOAD_SYMBOLS    {\"Agent_OnLoad\"}\n-#define AGENT_ONUNLOAD_SYMBOLS  {\"Agent_OnUnload\"}\n-#define AGENT_ONATTACH_SYMBOLS  {\"Agent_OnAttach\"}\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2981,2 +2981,2 @@\n-  \/\/ Set lock id of new current Thread\n-  thread->set_lock_id(java_lang_Thread::thread_id(threadObj));\n+  \/\/ Set _monitor_owner_id of new current Thread\n+  thread->set_monitor_owner_id(java_lang_Thread::thread_id(threadObj));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,1 +190,0 @@\n-                 IA64_ONLY(\"ia64\")               \\\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -325,1 +325,11 @@\n-  if  (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {\n+  return internal_module_property_helper(property, false);\n+}\n+\n+\/\/ Returns true if property is one of those recognized by is_internal_module_property() but\n+\/\/ is not supported by CDS archived full module graph.\n+bool Arguments::is_incompatible_cds_internal_module_property(const char* property) {\n+  return internal_module_property_helper(property, true);\n+}\n+\n+bool Arguments::internal_module_property_helper(const char* property, bool check_for_cds) {\n+  if (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {\n@@ -331,4 +341,1 @@\n-        matches_property_suffix(property_suffix, ADDMODS, ADDMODS_LEN) ||\n-        matches_property_suffix(property_suffix, PATH, PATH_LEN) ||\n-        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN) ||\n-        matches_property_suffix(property_suffix, ENABLE_NATIVE_ACCESS, ENABLE_NATIVE_ACCESS_LEN)) {\n+        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN)) {\n@@ -339,0 +346,9 @@\n+\n+    if (!check_for_cds) {\n+      \/\/ CDS notes: these properties are supported by CDS archived full module graph.\n+      if (matches_property_suffix(property_suffix, PATH, PATH_LEN) ||\n+          matches_property_suffix(property_suffix, ADDMODS, ADDMODS_LEN) ||\n+          matches_property_suffix(property_suffix, ENABLE_NATIVE_ACCESS, ENABLE_NATIVE_ACCESS_LEN)) {\n+        return true;\n+      }\n+    }\n@@ -343,9 +359,0 @@\n-bool Arguments::is_add_modules_property(const char* key) {\n-  return (strcmp(key, MODULE_PROPERTY_PREFIX ADDMODS) == 0);\n-}\n-\n-\/\/ Return true if the key matches the --module-path property name (\"jdk.module.path\").\n-bool Arguments::is_module_path_property(const char* key) {\n-  return (strcmp(key, MODULE_PROPERTY_PREFIX PATH) == 0);\n-}\n-\n@@ -1804,5 +1811,6 @@\n-unsigned int addreads_count = 0;\n-unsigned int addexports_count = 0;\n-unsigned int addopens_count = 0;\n-unsigned int patch_mod_count = 0;\n-unsigned int enable_native_access_count = 0;\n+static unsigned int addreads_count = 0;\n+static unsigned int addexports_count = 0;\n+static unsigned int addopens_count = 0;\n+static unsigned int patch_mod_count = 0;\n+static unsigned int enable_native_access_count = 0;\n+static bool patch_mod_javabase = false;\n@@ -1812,0 +1820,5 @@\n+  \/\/ This may modify compiler flags. Must be called before CompilerConfig::check_args_consistency()\n+  if (!CDSConfig::check_vm_args_consistency(patch_mod_javabase, mode_flag_cmd_line)) {\n+    return false;\n+  }\n+\n@@ -1982,2 +1995,0 @@\n-  bool patch_mod_javabase = false;\n-\n@@ -1997,1 +2008,1 @@\n-  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlagOrigin::JIMAGE_RESOURCE);\n+  jint result = parse_each_vm_init_arg(vm_options_args, JVMFlagOrigin::JIMAGE_RESOURCE);\n@@ -2004,1 +2015,1 @@\n-  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_tool_options_args, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2010,1 +2021,1 @@\n-  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlagOrigin::COMMAND_LINE);\n+  result = parse_each_vm_init_arg(cmd_line_args, JVMFlagOrigin::COMMAND_LINE);\n@@ -2017,1 +2028,1 @@\n-  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_options_args, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2038,1 +2049,1 @@\n-  result = finalize_vm_init_args(patch_mod_javabase);\n+  result = finalize_vm_init_args();\n@@ -2093,1 +2104,1 @@\n-int Arguments::process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase) {\n+int Arguments::process_patch_mod_option(const char* patch_mod_tail) {\n@@ -2109,1 +2120,1 @@\n-      add_patch_mod_prefix(module_name, module_equal + 1, patch_mod_javabase);\n+      add_patch_mod_prefix(module_name, module_equal + 1);\n@@ -2240,1 +2251,1 @@\n-jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin) {\n+jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, JVMFlagOrigin origin) {\n@@ -2367,1 +2378,1 @@\n-      int res = process_patch_mod_option(tail, patch_mod_javabase);\n+      int res = process_patch_mod_option(tail);\n@@ -2916,1 +2927,1 @@\n-void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool* patch_mod_javabase) {\n+void Arguments::add_patch_mod_prefix(const char* module_name, const char* path) {\n@@ -2922,1 +2933,1 @@\n-    if (*patch_mod_javabase) {\n+    if (patch_mod_javabase) {\n@@ -2925,1 +2936,1 @@\n-      *patch_mod_javabase = true;\n+      patch_mod_javabase = true;\n@@ -2977,1 +2988,1 @@\n-jint Arguments::finalize_vm_init_args(bool patch_mod_javabase) {\n+jint Arguments::finalize_vm_init_args() {\n@@ -3058,3 +3069,0 @@\n-  if (!CDSConfig::check_vm_args_consistency(patch_mod_javabase, mode_flag_cmd_line)) {\n-    return JNI_ERR;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":45,"deletions":37,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-  static int process_patch_mod_option(const char* patch_mod_tail, bool* patch_mod_javabase);\n+  static int process_patch_mod_option(const char* patch_mod_tail);\n@@ -332,2 +332,2 @@\n-  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin);\n-  static jint finalize_vm_init_args(bool patch_mod_javabase);\n+  static jint parse_each_vm_init_arg(const JavaVMInitArgs* args, JVMFlagOrigin origin);\n+  static jint finalize_vm_init_args();\n@@ -372,0 +372,2 @@\n+  static bool internal_module_property_helper(const char* property, bool check_for_cds);\n+\n@@ -472,3 +474,1 @@\n-  static bool is_add_modules_property(const char* key);\n-  static unsigned int addmods_count() { return  _addmods_count; }\n-  static bool is_module_path_property(const char* key);\n+  static bool is_incompatible_cds_internal_module_property(const char* property);\n@@ -483,1 +483,1 @@\n-  static void add_patch_mod_prefix(const char *module_name, const char *path, bool* patch_mod_javabase);\n+  static void add_patch_mod_prefix(const char *module_name, const char *path);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  int64_t _lock_id;\n+  int64_t _monitor_owner_id;\n@@ -172,3 +172,3 @@\n-  void set_lock_id(int64_t tid) {\n-    assert(tid >= ThreadIdentifier::initial() && tid < ThreadIdentifier::current(), \"invalid tid\");\n-    _lock_id = tid;\n+  void set_monitor_owner_id(int64_t id) {\n+    assert(id >= ThreadIdentifier::initial() && id < ThreadIdentifier::current(), \"\");\n+    _monitor_owner_id = id;\n@@ -176,1 +176,1 @@\n-  int64_t lock_id() const { return _lock_id; }\n+  int64_t monitor_owner_id() const { return _monitor_owner_id; }\n@@ -887,1 +887,1 @@\n-  static ByteSize lock_id_offset()            { return byte_offset_of(JavaThread, _lock_id); }\n+  static ByteSize monitor_owner_id_offset()   { return byte_offset_of(JavaThread, _monitor_owner_id); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -516,0 +516,5 @@\n+    if (is_vm_statically_linked()) {\n+      _native_java_library = get_default_process_handle();\n+      return _native_java_library;\n+    }\n+\n@@ -549,2 +554,1 @@\n-void* os::find_agent_function(JvmtiAgent *agent_lib, bool check_lib,\n-                              const char *syms[], size_t syms_len) {\n+void* os::find_agent_function(JvmtiAgent *agent_lib, bool check_lib, const char *sym) {\n@@ -552,1 +556,0 @@\n-  const char *lib_name;\n@@ -555,2 +558,0 @@\n-  char *agent_function_name;\n-  size_t i;\n@@ -560,6 +561,4 @@\n-  lib_name = ((check_lib || agent_lib->is_static_lib()) ? agent_lib->name() : nullptr);\n-  for (i = 0; i < syms_len; i++) {\n-    agent_function_name = build_agent_function_name(syms[i], lib_name, agent_lib->is_absolute_path());\n-    if (agent_function_name == nullptr) {\n-      break;\n-    }\n+  const char *lib_name = ((check_lib || agent_lib->is_static_lib()) ? agent_lib->name() : nullptr);\n+\n+  char* agent_function_name = build_agent_function_name(sym, lib_name, agent_lib->is_absolute_path());\n+  if (agent_function_name != nullptr) {\n@@ -568,3 +567,0 @@\n-    if (entryName != nullptr) {\n-      break;\n-    }\n@@ -576,6 +572,1 @@\n-bool os::find_builtin_agent(JvmtiAgent* agent, const char *syms[],\n-                            size_t syms_len) {\n-  void *ret;\n-  void *proc_handle;\n-  void *save_handle;\n-\n+bool os::find_builtin_agent(JvmtiAgent* agent, const char* sym) {\n@@ -586,1 +577,1 @@\n-  proc_handle = get_default_process_handle();\n+  void* proc_handle = get_default_process_handle();\n@@ -588,1 +579,1 @@\n-  save_handle = agent->os_lib();\n+  void* save_handle = agent->os_lib();\n@@ -591,1 +582,1 @@\n-  ret = find_agent_function(agent, true, syms, syms_len);\n+  void* ret = find_agent_function(agent, true, sym);\n@@ -2502,0 +2493,58 @@\n+\n+\/\/ Builds a platform dependent Agent_OnLoad_<lib_name> function name\n+\/\/ which is used to find statically linked in agents.\n+\/\/ Parameters:\n+\/\/            sym_name: Symbol in library we are looking for\n+\/\/            lib_name: Name of library to look in, null for shared libs.\n+\/\/            is_absolute_path == true if lib_name is absolute path to agent\n+\/\/                                     such as \"C:\/a\/b\/L.dll\" or \"\/a\/b\/libL.so\"\n+\/\/            == false if only the base name of the library is passed in\n+\/\/               such as \"L\"\n+char* os::build_agent_function_name(const char *sym_name, const char *lib_name,\n+                                    bool is_absolute_path) {\n+  char *agent_entry_name;\n+  size_t len = 0;\n+  size_t name_len = 0;\n+  size_t prefix_len = strlen(JNI_LIB_PREFIX);\n+  size_t suffix_len = strlen(JNI_LIB_SUFFIX);\n+  size_t underscore_len = 0; \/\/ optional underscore if lib_name is set\n+  const char *start;\n+\n+  if (lib_name != nullptr) {\n+    if (is_absolute_path) {\n+      \/\/ Need to strip path, prefix and suffix\n+      if ((start = strrchr(lib_name, *os::file_separator())) != nullptr) {\n+        lib_name = ++start;\n+      }\n+#ifdef WINDOWS\n+      else { \/\/ Need to check for drive prefix e.g. C:L.dll\n+        if ((start = strchr(lib_name, ':')) != nullptr) {\n+          lib_name = ++start;\n+        }\n+      }\n+#endif\n+      name_len = strlen(lib_name);\n+      if (name_len <= (prefix_len + suffix_len)) {\n+        return nullptr;\n+      }\n+      lib_name += prefix_len;\n+      name_len = strlen(lib_name) - suffix_len;\n+    } else {\n+      name_len = strlen(lib_name);\n+    }\n+    underscore_len = 1;\n+  }\n+  \/\/ Total buffer length to allocate - includes null terminator.\n+  len = strlen(sym_name) + underscore_len + name_len + 1;\n+  agent_entry_name = NEW_C_HEAP_ARRAY_RETURN_NULL(char, len, mtThread);\n+  if (agent_entry_name == nullptr) {\n+    return nullptr;\n+  }\n+\n+  strcpy(agent_entry_name, sym_name);\n+  if (lib_name != nullptr) {\n+    strcat(agent_entry_name, \"_\");\n+    strncat(agent_entry_name, lib_name, name_len);\n+  }\n+  return agent_entry_name;\n+}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":72,"deletions":23,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -779,0 +779,3 @@\n+  \/\/ Lookup the named function. This is used by the static JDK.\n+  static void* lookup_function(const char* name);\n+\n@@ -793,2 +796,1 @@\n-  static bool find_builtin_agent(JvmtiAgent *agent_lib, const char *syms[],\n-                                 size_t syms_len);\n+  static bool find_builtin_agent(JvmtiAgent* agent_lib, const char* sym);\n@@ -797,2 +799,1 @@\n-  static void *find_agent_function(JvmtiAgent *agent_lib, bool check_lib,\n-                                   const char *syms[], size_t syms_len);\n+  static void* find_agent_function(JvmtiAgent* agent_lib, bool check_lib, const char* sym);\n@@ -875,2 +876,1 @@\n-  \/\/ only walk stack if %ebp is used as frame pointer; on ia64, it's not\n-  \/\/ possible to walk C stack without having the unwind table.\n+  \/\/ only walk stack if %ebp is used as frame pointer.\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  assert(main_thread_tid == thread->lock_id(), \"\");\n+  assert(main_thread_tid == thread->monitor_owner_id(), \"\");\n@@ -581,1 +581,1 @@\n-  \/\/ Set the lock_id now since we will run Java code before the Thread instance\n+  \/\/ Set the _monitor_owner_id now since we will run Java code before the Thread instance\n@@ -583,1 +583,1 @@\n-  main_thread->set_lock_id(ThreadIdentifier::next());\n+  main_thread->set_monitor_owner_id(ThreadIdentifier::next());\n@@ -1393,2 +1393,1 @@\n-          \/\/ _lock_id is the thread ID of the mounted virtual thread\n-          st->print_cr(\"   Mounted virtual thread #\" INT64_FORMAT, p->lock_id());\n+          st->print_cr(\"   Mounted virtual thread #\" INT64_FORMAT, java_lang_Thread::thread_id(p->vthread()));\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-  nonstatic_field(JavaThread,                  _lock_id,                                      int64_t)                               \\\n+  nonstatic_field(JavaThread,                  _monitor_owner_id,                             int64_t)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,0 +135,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadSchedulerDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadPollersDCmd>(full_export, true, false));\n@@ -160,2 +162,1 @@\n-  \/\/ These commands won't be exported via the DiagnosticCommandMBean until an\n-  \/\/ appropriate permission is created for them\n+  \/\/ These commands not currently exported via the DiagnosticCommandMBean\n@@ -1109,7 +1110,0 @@\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (HAS_PENDING_EXCEPTION) {\n-    java_lang_Throwable::print(PENDING_EXCEPTION, output());\n-    output()->cr();\n-    CLEAR_PENDING_EXCEPTION;\n-    return;\n-  }\n@@ -1146,0 +1140,39 @@\n+\/\/ Calls a static no-arg method on jdk.internal.vm.JcmdVThreadCommands that returns a byte[] with\n+\/\/ the output. If the method completes successfully then the bytes are copied to the output stream.\n+\/\/ If the method fails then the exception is printed to the output stream.\n+static void execute_vthread_command(Symbol* method_name, outputStream* output, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_vm_JcmdVThreadCommands(), true, CHECK);\n+\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  JavaCalls::call_static(&result,\n+                         k,\n+                         method_name,\n+                         vmSymbols::void_byte_array_signature(),\n+                         &args,\n+                         THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    java_lang_Throwable::print(PENDING_EXCEPTION, output);\n+    output->cr();\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  \/\/ copy the bytes to the output stream\n+  oop res = cast_to_oop(result.get_jobject());\n+  typeArrayOop ba = typeArrayOop(res);\n+  jbyte* addr = typeArrayOop(res)->byte_at_addr(0);\n+  output->print_raw((const char*)addr, ba->length());\n+}\n+\n+void VThreadSchedulerDCmd::execute(DCmdSource source, TRAPS) {\n+  execute_vthread_command(vmSymbols::printScheduler_name(), output(), CHECK);\n+}\n+\n+void VThreadPollersDCmd::execute(DCmdSource source, TRAPS) {\n+  execute_vthread_command(vmSymbols::printPollers_name(), output(), CHECK);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -67,5 +67,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.util.PropertyPermission\",\n-                        \"java.vm.version\", \"read\"};\n-    return p;\n-  }\n@@ -83,5 +78,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -104,5 +94,0 @@\n-    static const JavaPermission permission() {\n-      JavaPermission p = {\"java.util.PropertyPermission\",\n-                          \"*\", \"read\"};\n-      return p;\n-    }\n@@ -126,5 +111,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -149,5 +129,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -167,5 +142,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -189,5 +159,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -211,5 +176,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -243,5 +203,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -287,5 +242,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-      \"monitor\", nullptr};\n-      return p;\n-  }\n@@ -306,5 +256,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-      \"monitor\", nullptr};\n-      return p;\n-  }\n@@ -337,5 +282,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -363,5 +303,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -390,5 +325,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -415,5 +345,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -439,5 +364,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -549,6 +469,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n-\n@@ -571,5 +485,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -595,5 +504,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -616,5 +520,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -636,5 +535,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -662,5 +556,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -683,5 +572,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -703,5 +587,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -726,5 +605,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -746,5 +620,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -812,5 +681,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -835,5 +699,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -858,5 +717,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -881,5 +735,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -905,5 +754,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -932,3 +776,22 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\", \"monitor\", nullptr};\n-    return p;\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class VThreadSchedulerDCmd : public DCmd {\n+public:\n+  VThreadSchedulerDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+  static const char* name() {\n+    return \"Thread.vthread_scheduler\";\n+  }\n+  static const char* description() {\n+    return \"Print the virtual thread scheduler, and the delayed task schedulers that support \"\n+           \"virtual threads doing timed operations.\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class VThreadPollersDCmd : public DCmd {\n+public:\n+  VThreadPollersDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+  static const char* name() {\n+    return \"Thread.vthread_pollers\";\n@@ -936,0 +799,4 @@\n+  static const char* description() {\n+    return \"Print the I\/O pollers that support virtual threads doing blocking network I\/O operations.\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n@@ -955,5 +822,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"monitor\", nullptr};\n-    return p;\n-  }\n@@ -973,5 +835,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n@@ -991,5 +848,0 @@\n-  static const JavaPermission permission() {\n-    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n-                        \"control\", nullptr};\n-    return p;\n-  }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":26,"deletions":174,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2029,4 +2029,0 @@\n-    JavaPermission p = info->permission();\n-    infoArray[i].permission_class = p._class;\n-    infoArray[i].permission_name = p._name;\n-    infoArray[i].permission_action = p._action;\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -465,12 +465,0 @@\n-\/\/ This is a REALLY BIG HACK, but on AIX <sys\/systemcfg.h> unconditionally defines IA64.\n-\/\/ At least on AIX 7.1 this is a real problem because 'systemcfg.h' is indirectly included\n-\/\/ by 'pthread.h' and other common system headers.\n-\n-#if defined(IA64) && !defined(AIX)\n-#define IA64_ONLY(code) code\n-#define NOT_IA64(code)\n-#else\n-#define IA64_ONLY(code)\n-#define NOT_IA64(code) code\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -1413,1 +1414,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -1517,1 +1517,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2339,0 +2338,4 @@\n+            public Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers() {\n+                return VirtualThread.delayedTaskSchedulers();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1648,0 +1648,3 @@\n+        if (ipAddressLiteral.isEmpty()) {\n+            throw IPAddressUtil.invalidIpAddressLiteral(ipAddressLiteral);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -458,0 +458,1 @@\n+        assert address instanceof InetSocketAddress;\n@@ -467,1 +468,1 @@\n-            if (localAddr != null)\n+            if (localAddr != null) {\n@@ -469,7 +470,4 @@\n-            connect(address);\n-        } catch (IOException | IllegalArgumentException e) {\n-            try {\n-                close();\n-            } catch (IOException ce) {\n-                e.addSuppressed(ce);\n-            throw e;\n+            connect(address);\n+        } catch (Throwable throwable) {\n+            closeSuppressingExceptions(throwable);\n+            throw throwable;\n@@ -575,0 +573,4 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, or the\n+     * connection cannot be established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -593,0 +595,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -609,0 +613,5 @@\n+     * <p> If the endpoint is an unresolved {@link InetSocketAddress}, the\n+     * connection cannot be established, or the timeout expires before the\n+     * connection is established, then the socket is closed, and an\n+     * {@link IOException} is thrown.\n+     *\n@@ -629,0 +638,2 @@\n+     * @throws  UnknownHostException if the endpoint is an unresolved\n+     *          {@link InetSocketAddress}\n@@ -648,1 +659,1 @@\n-            throw new SocketException(\"already connected\");\n+            throw new SocketException(\"Already connected\");\n@@ -653,0 +664,6 @@\n+        if (epoint.isUnresolved()) {\n+            var uhe = new UnknownHostException(epoint.getHostName());\n+            closeSuppressingExceptions(uhe);\n+            throw uhe;\n+        }\n+\n@@ -654,1 +671,0 @@\n-        int port = epoint.getPort();\n@@ -659,9 +675,3 @@\n-        } catch (SocketTimeoutException e) {\n-            throw e;\n-        } catch (InterruptedIOException e) {\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual() && thread.isInterrupted()) {\n-                close();\n-                throw new SocketException(\"Closed by interrupt\");\n-            }\n-            throw e;\n+        } catch (IOException error) {\n+            closeSuppressingExceptions(error);\n+            throw error;\n@@ -1593,0 +1603,8 @@\n+    private void closeSuppressingExceptions(Throwable parentException) {\n+        try {\n+            close();\n+        } catch (IOException exception) {\n+            parentException.addSuppressed(exception);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":37,"deletions":19,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -965,5 +965,1 @@\n-        @SuppressWarnings(\"removal\")\n-        String property = AccessController.doPrivileged(\n-                (PrivilegedAction<String>) () -> Security.getProperty(\n-                    \"securerandom.strongAlgorithms\"));\n-\n+        String property = Security.getProperty(\"securerandom.strongAlgorithms\");\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    private static final boolean DISABLE_JAR_CHECKING;\n+    private static final boolean JAR_CHECKING_ENABLED;\n@@ -88,1 +88,3 @@\n-        DISABLE_JAR_CHECKING = p != null ? p.equals(\"true\") || p.isEmpty() : false;\n+        \/\/ JAR check is disabled by default and will be enabled only if the \"disable JAR check\"\n+        \/\/ system property has been set to \"false\".\n+        JAR_CHECKING_ENABLED = \"false\".equals(p);\n@@ -656,2 +658,4 @@\n-        \/* Throws if the given jar file is does not start with the correct LOC *\/\n-        @SuppressWarnings(\"removal\")\n+        \/*\n+         * Throws an IOException if the LOC file Header Signature (0x04034b50),\n+         * is not found starting at byte 0 of the given jar.\n+         *\/\n@@ -659,2 +663,1 @@\n-            if (System.getSecurityManager() != null && !DISABLE_JAR_CHECKING\n-                && !zipAccess.startsWithLocHeader(jar)) {\n+            if (JAR_CHECKING_ENABLED && !zipAccess.startsWithLocHeader(jar)) {\n@@ -669,1 +672,0 @@\n-\n@@ -907,1 +909,5 @@\n-            path = ParseUtil.decode(path);\n+            try {\n+                path = ParseUtil.decode(path);\n+            } catch (IllegalArgumentException iae) {\n+                throw new IOException(iae);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-     * Heads of a CleanableList for each reference type.\n+     * Currently active PhantomCleanable-s.\n@@ -59,1 +59,1 @@\n-    final PhantomCleanable<?> phantomCleanableList;\n+    final CleanableList activeList;\n@@ -93,1 +93,1 @@\n-        phantomCleanableList = new PhantomCleanableRef();\n+        activeList = new CleanableList();\n@@ -141,1 +141,1 @@\n-        while (!phantomCleanableList.isListEmpty()) {\n+        while (!activeList.isEmpty()) {\n@@ -221,8 +221,0 @@\n-        \/**\n-         * Constructor used only for root of phantom cleanable list.\n-         *\/\n-        PhantomCleanableRef() {\n-            super();\n-            this.action = null;\n-        }\n-\n@@ -292,0 +284,133 @@\n+\n+    \/**\n+     * A specialized implementation that tracks phantom cleanables.\n+     *\/\n+    static final class CleanableList {\n+        \/**\n+         * Capacity for a single node in the list.\n+         * This balances memory overheads vs locality vs GC walking costs.\n+         *\/\n+        static final int NODE_CAPACITY = 4096;\n+\n+        \/**\n+         * Head node. This is the only node where PhantomCleanables are\n+         * added to or removed from. This is the only node with variable size,\n+         * all other nodes linked from the head are always at full capacity.\n+         *\/\n+        private Node head;\n+\n+        \/**\n+         * Cached node instance to provide better behavior near NODE_CAPACITY\n+         * threshold: if list size flips around NODE_CAPACITY, it would reuse\n+         * the cached node instead of wasting and re-allocating a new node all\n+         * the time.\n+         *\/\n+        private Node cache;\n+\n+        public CleanableList() {\n+            reset();\n+        }\n+\n+        \/**\n+         * Testing support: reset list to initial state.\n+         *\/\n+        synchronized void reset() {\n+            this.head = new Node();\n+        }\n+\n+        \/**\n+         * Returns true if cleanable list is empty.\n+         *\n+         * @return true if the list is empty\n+         *\/\n+        public synchronized boolean isEmpty() {\n+            \/\/ Head node size is zero only when the entire list is empty.\n+            return head.size == 0;\n+        }\n+\n+        \/**\n+         * Insert this PhantomCleanable in the list.\n+         *\/\n+        public synchronized void insert(PhantomCleanable<?> phc) {\n+            if (head.size == NODE_CAPACITY) {\n+                \/\/ Head node is full, insert new one.\n+                \/\/ If possible, pick a pre-allocated node from cache.\n+                Node newHead;\n+                if (cache != null) {\n+                    newHead = cache;\n+                    cache = null;\n+                } else {\n+                    newHead = new Node();\n+                }\n+                newHead.next = head;\n+                head = newHead;\n+            }\n+            assert head.size < NODE_CAPACITY;\n+\n+            \/\/ Put the incoming object in head node and record indexes.\n+            final int lastIndex = head.size;\n+            phc.node = head;\n+            phc.index = lastIndex;\n+            head.arr[lastIndex] = phc;\n+            head.size++;\n+        }\n+\n+        \/**\n+         * Remove this PhantomCleanable from the list.\n+         *\n+         * @return true if Cleanable was removed or false if not because\n+         * it had already been removed before\n+         *\/\n+        public synchronized boolean remove(PhantomCleanable<?> phc) {\n+            if (phc.node == null) {\n+                \/\/ Not in the list.\n+                return false;\n+            }\n+            assert phc.node.arr[phc.index] == phc;\n+\n+            \/\/ Replace with another element from the head node, as long\n+            \/\/ as it is not the same element. This keeps all non-head\n+            \/\/ nodes at full capacity.\n+            final int lastIndex = head.size - 1;\n+            assert lastIndex >= 0;\n+            if (head != phc.node || (phc.index != lastIndex)) {\n+                PhantomCleanable<?> mover = head.arr[lastIndex];\n+                mover.node = phc.node;\n+                mover.index = phc.index;\n+                phc.node.arr[phc.index] = mover;\n+            }\n+\n+            \/\/ Now we can unlink the removed element.\n+            phc.node = null;\n+\n+            \/\/ Remove the last element from the head node.\n+            head.arr[lastIndex] = null;\n+            head.size--;\n+\n+            \/\/ If head node becomes empty after this, and there are\n+            \/\/ nodes that follow it, replace the head node with another\n+            \/\/ full one. If needed, stash the now free node in cache.\n+            if (head.size == 0 && head.next != null) {\n+                Node newHead = head.next;\n+                if (cache == null) {\n+                    cache = head;\n+                    cache.next = null;\n+                }\n+                head = newHead;\n+            }\n+\n+            return true;\n+        }\n+\n+        \/**\n+         * Segment node.\n+         *\/\n+        static class Node {\n+            \/\/ Array of tracked cleanables, and the amount of elements in it.\n+            final PhantomCleanable<?>[] arr = new PhantomCleanable<?>[NODE_CAPACITY];\n+            int size;\n+\n+            \/\/ Linked list structure.\n+            Node next;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":137,"deletions":12,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-    exports java.lang.classfile.components;\n@@ -183,0 +182,2 @@\n+    exports jdk.internal.classfile.components to\n+        jdk.jfr;\n@@ -321,2 +322,0 @@\n-        java.management.rmi,\n-        java.rmi,\n@@ -335,1 +334,0 @@\n-        java.rmi,\n@@ -350,1 +348,0 @@\n-        java.rmi,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-            if (ioe instanceof InterruptedIOException) {\n+            if (ioe instanceof SocketTimeoutException) {\n@@ -610,0 +610,3 @@\n+            } else if (ioe instanceof InterruptedIOException) {\n+                assert Thread.currentThread().isVirtual();\n+                throw new SocketException(\"Closed by interrupt\");\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,3 +73,0 @@\n-     * @throws SecurityException     if a security manager exists and its\n-     *                               <code>checkRead<\/code> method denies read\n-     *                               access to the file.\n@@ -86,3 +83,0 @@\n-        \/\/ (this also checks the read permission on the file if SecurityManager\n-        \/\/ is present, so no checking is needed later when we just return the\n-        \/\/ already opened stream)\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/FileInputStreamPool.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -282,1 +282,2 @@\n-However, as in `@`-files, use of a wildcard is not supported. In order to\n+Any wildcard literal `*` in the `JDK_JAVA_OPTIONS` environment variable\n+content isn't expanded and is passed as-is to the starting VM. In order to\n@@ -3102,3 +3103,3 @@\n-    file. That means, an asterisk  `*` is passed on as-is to the starting VM.\n-    For example `*.java` stays `*.java` and is not expanded to `Foo.java`,\n-    `Bar.java`, etc. like on some command line shell.\n+    file. That means an asterisk (`*`) is passed on as-is to the starting VM.\n+    For example `*.java` stays `*.java` and is not expanded to\n+    `Foo.java Bar.java ...`, as would happen with some command line shells.\n@@ -3147,2 +3148,0 @@\n--   Wildcards (\\*) aren't allowed in these lists (such as specifying `*.java`).\n-\n","filename":"src\/java.base\/share\/man\/java.md","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -139,51 +139,2 @@\n-    @SuppressWarnings(\"removal\")\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<>() {\n-                @Override\n-                public RandomIO run() {\n-\n-                    File seedFile;\n-                    File nextFile;\n-\n-                    switch(v) {\n-                    case MIXED:\n-                        URL egdUrl;\n-                        File egdFile = null;\n-\n-                        if ((egdUrl = getEgdUrl()) != null) {\n-                            try {\n-                                egdFile = SunEntries.getDeviceFile(egdUrl);\n-                            } catch (IOException e) {\n-                                \/\/ Swallow, seedFile is still null\n-                            }\n-                        }\n-\n-                        \/\/ Try egd first.\n-                        if ((egdFile != null) && egdFile.canRead()) {\n-                            seedFile = egdFile;\n-                        } else {\n-                            \/\/ fall back to \/dev\/random.\n-                            seedFile = new File(NAME_RANDOM);\n-                        }\n-                        nextFile = new File(NAME_URANDOM);\n-                        break;\n-\n-                    case BLOCKING:\n-                        seedFile = new File(NAME_RANDOM);\n-                        nextFile = new File(NAME_RANDOM);\n-                        break;\n-\n-                    case NONBLOCKING:\n-                        seedFile = new File(NAME_URANDOM);\n-                        nextFile = new File(NAME_URANDOM);\n-                        break;\n-\n-                    default:\n-                        \/\/ Shouldn't happen!\n-                        return null;\n-                    }\n-                    if (debug != null) {\n-                        debug.println(\"NativePRNG.\" + v +\n-                            \" seedFile: \" + seedFile +\n-                            \" nextFile: \" + nextFile);\n-                    }\n+        File seedFile;\n+        File nextFile;\n@@ -193,7 +144,4 @@\n-                    if (!seedFile.canRead() || !nextFile.canRead()) {\n-                        if (debug != null) {\n-                            debug.println(\"NativePRNG.\" + v +\n-                                \" Couldn't read Files.\");\n-                        }\n-                        return null;\n-                    }\n+        switch(v) {\n+        case MIXED:\n+            URL egdUrl;\n+            File egdFile = null;\n@@ -201,5 +149,5 @@\n-                    try {\n-                        return new RandomIO(seedFile, nextFile);\n-                    } catch (Exception e) {\n-                        return null;\n-                    }\n+            if ((egdUrl = getEgdUrl()) != null) {\n+                try {\n+                    egdFile = SunEntries.getDeviceFile(egdUrl);\n+                } catch (IOException e) {\n+                    \/\/ Swallow, seedFile is still null\n@@ -207,1 +155,46 @@\n-        });\n+            }\n+\n+            \/\/ Try egd first.\n+            if ((egdFile != null) && egdFile.canRead()) {\n+                seedFile = egdFile;\n+            } else {\n+                \/\/ fall back to \/dev\/random.\n+                seedFile = new File(NAME_RANDOM);\n+            }\n+            nextFile = new File(NAME_URANDOM);\n+            break;\n+\n+        case BLOCKING:\n+            seedFile = new File(NAME_RANDOM);\n+            nextFile = new File(NAME_RANDOM);\n+            break;\n+\n+        case NONBLOCKING:\n+            seedFile = new File(NAME_URANDOM);\n+            nextFile = new File(NAME_URANDOM);\n+            break;\n+\n+        default:\n+            \/\/ Shouldn't happen!\n+            return null;\n+        }\n+\n+        if (debug != null) {\n+            debug.println(\"NativePRNG.\" + v +\n+                \" seedFile: \" + seedFile +\n+                \" nextFile: \" + nextFile);\n+        }\n+\n+        if (!seedFile.canRead() || !nextFile.canRead()) {\n+            if (debug != null) {\n+                debug.println(\"NativePRNG.\" + v +\n+                    \" Couldn't read Files.\");\n+            }\n+            return null;\n+        }\n+\n+        try {\n+            return new RandomIO(seedFile, nextFile);\n+        } catch (Exception e) {\n+            return null;\n+        }\n@@ -475,1 +468,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -480,11 +472,5 @@\n-                    seedOut = AccessController.doPrivileged(\n-                            new PrivilegedAction<>() {\n-                        @Override\n-                        public OutputStream run() {\n-                            try {\n-                                return new FileOutputStream(seedFile, true);\n-                            } catch (Exception e) {\n-                                return null;\n-                            }\n-                        }\n-                    });\n+                    try {\n+                        seedOut = new FileOutputStream(seedFile, true);\n+                    } catch (Exception e) {\n+                        seedOut = null;\n+                    }\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":62,"deletions":76,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -279,0 +279,7 @@\n+    if (JLI_IsStaticallyLinked()) {\n+        \/\/ With static builds, all JDK and VM natives are statically linked\n+        \/\/ with the launcher executable. No need to manipulate LD_LIBRARY_PATH\n+        \/\/ by adding <jdk_path>\/lib and etc. The 'jrepath', 'jvmpath' and\n+        \/\/ 'jvmcfg' are not used by the caller for static builds. Simply return.\n+        return;\n+    }\n@@ -321,0 +328,1 @@\n+\n@@ -522,5 +530,9 @@\n-    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n-    if (libjvm == NULL) {\n-        JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);\n-        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n-        return JNI_FALSE;\n+    if (JLI_IsStaticallyLinked()) {\n+        libjvm = dlopen(NULL, RTLD_NOW + RTLD_GLOBAL);\n+    } else {\n+        libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n+        if (libjvm == NULL) {\n+            JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);\n+            JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+            return JNI_FALSE;\n+        }\n@@ -603,5 +615,8 @@\n-        if (!GetJDKInstallRoot(jdkRoot, sizeof(jdkRoot), JNI_FALSE)) {\n-            JLI_ReportErrorMessage(LAUNCHER_ERROR1);\n-            return NULL;\n-        }\n-        ret = JLI_Snprintf(splashPath, sizeof(splashPath), \"%s\/lib\/%s\",\n+        if (JLI_IsStaticallyLinked()) {\n+            hSplashLib = dlopen(NULL, RTLD_LAZY);\n+        } else {\n+            if (!GetJDKInstallRoot(jdkRoot, sizeof(jdkRoot), JNI_FALSE)) {\n+                JLI_ReportErrorMessage(LAUNCHER_ERROR1);\n+                return NULL;\n+            }\n+            ret = JLI_Snprintf(splashPath, sizeof(splashPath), \"%s\/lib\/%s\",\n@@ -610,7 +625,9 @@\n-        if (ret >= (int) sizeof(splashPath)) {\n-            JLI_ReportErrorMessage(LAUNCHER_ERROR3);\n-            return NULL;\n-        }\n-        if (ret < 0) {\n-            JLI_ReportErrorMessage(LAUNCHER_ERROR5);\n-            return NULL;\n+            if (ret >= (int) sizeof(splashPath)) {\n+                JLI_ReportErrorMessage(LAUNCHER_ERROR3);\n+                return NULL;\n+            }\n+            if (ret < 0) {\n+                JLI_ReportErrorMessage(LAUNCHER_ERROR5);\n+                return NULL;\n+            }\n+            hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);\n@@ -618,1 +635,0 @@\n-        hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":34,"deletions":18,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -205,9 +203,2 @@\n-    public String   getCompilerName() {\n-        @SuppressWarnings(\"removal\")\n-        String name =  AccessController.doPrivileged(\n-            new PrivilegedAction<>() {\n-                public String run() {\n-                    return System.getProperty(\"sun.management.compiler\");\n-                }\n-            });\n-        return name;\n+    public String getCompilerName() {\n+        return System.getProperty(\"sun.management.compiler\");\n@@ -258,2 +249,1 @@\n-        @SuppressWarnings(\"removal\")\n-        Perf perf =  AccessController.doPrivileged(new Perf.GetPerfAction());\n+        Perf perf = Perf.getPerf();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagementImpl.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-import sun.rmi.runtime.NewThreadAction;\n+import sun.rmi.runtime.RuntimeUtil;\n@@ -106,2 +106,1 @@\n-                    return new NewThreadAction(\n-                        runnable, \"TCP Connection(idle)\", true, true).run();\n+                    return RuntimeUtil.newUserThread(runnable, \"TCP Connection(idle)\", true);\n@@ -311,2 +310,2 @@\n-                Thread t = new NewThreadAction(new AcceptLoop(server),\n-                                        \"TCP Accept-\" + port, true).run();\n+                Thread t = RuntimeUtil.newSystemThread(\n+                    new AcceptLoop(server), \"TCP Accept-\" + port, true);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPTransport.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+gc\/shenandoah\/oom\/TestAllocOutOfMemory.java#large 8344312 linux-ppc64le\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}