{"files":[{"patch":"@@ -72,0 +72,1 @@\n+    -tag crac:cmopt:'CRaC:' \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -824,0 +824,2 @@\n+USE_CRIU_CRAC:=@USE_CRIU_CRAC@\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,0 +155,4 @@\n+ifneq ($(call check-jvm-feature, cpu_feature_active), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_CPU_FEATURE_ACTIVE=0\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -130,0 +132,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -281,0 +281,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -417,0 +417,2 @@\n+  static void crac_restore() {}\n+  static void crac_restore_finalize() {}\n@@ -588,0 +590,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, unsigned long features[] = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2017, 2022, Azul Systems, Inc. All rights reserved.\n@@ -27,0 +28,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -69,0 +71,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -88,0 +91,1 @@\n+# include <arpa\/inet.h>\n@@ -92,1 +96,0 @@\n-# include <sys\/stat.h>\n@@ -95,0 +98,1 @@\n+# include <sys\/sysmacros.h>\n@@ -112,1 +116,0 @@\n-# include <fcntl.h>\n@@ -121,0 +124,1 @@\n+# include <libgen.h>\n@@ -502,0 +506,5 @@\n+void os::Linux::initialize_processor_count() {\n+  set_processor_count((int) sysconf(_SC_NPROCESSORS_CONF));\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n@@ -503,1 +512,1 @@\n-  set_processor_count((int)sysconf(_SC_NPROCESSORS_CONF));\n+  initialize_processor_count();\n@@ -516,1 +525,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -100,0 +101,1 @@\n+static jlong restore_time_count = 0;\n@@ -875,0 +877,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -897,0 +903,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1317,0 +1331,4 @@\n+  initialize_time_counters();\n+}\n+\n+void os::Posix::initialize_time_counters(void) {\n@@ -1318,0 +1336,5 @@\n+  restore_time_count = initial_time_count;\n+}\n+\n+void os::Posix::reset_time_counters(void) {\n+  restore_time_count = javaTimeNanos();\n@@ -1471,1 +1494,1 @@\n-  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec);\n+  jlong result = jlong(tp.tv_sec) * NANOSECS_PER_SEC + jlong(tp.tv_nsec) + crac::monotonic_time_offset();\n@@ -1500,0 +1523,4 @@\n+jlong os::elapsed_counter_since_restore() {\n+  return os::javaTimeNanos() - restore_time_count;\n+}\n+\n@@ -2024,0 +2051,30 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  char** env = os::get_environ();\n+\n+  pid_t pid = fork();\n+  if (pid == -1) {\n+    perror(\"cannot fork for subprocess\");\n+    return -1;\n+  }\n+  if (pid == 0) {\n+    execve(path, (char* const*)argv, env);\n+    perror(\"execve\");\n+    exit(1);\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return -1;\n+  }\n+  return WEXITSTATUS(status) == 0 ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return ::execv(path, (char * const *)argv);\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n@@ -1541,0 +1541,7 @@\n+\n+  sigemptyset(&blocked_sigs);\n+\/\/ RESTORE_SIGNAL is used only on Linux, other platform don't send this\n+#ifdef LINUX\n+  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+#endif\n+\n@@ -1551,0 +1558,5 @@\n+static sigset_t* blocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &blocked_sigs;\n+}\n+\n@@ -1568,0 +1580,1 @@\n+  pthread_sigmask(SIG_BLOCK, blocked_signals(), nullptr);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -804,0 +805,1 @@\n+static jlong restore_performance_count;\n@@ -811,1 +813,0 @@\n-\n@@ -816,0 +817,5 @@\n+jlong os::elapsed_counter_since_restore() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceCounter(&count);\n+  return count.QuadPart - restore_performance_count;\n+}\n@@ -1095,0 +1101,1 @@\n+  restore_performance_count = initial_performance_count;\n@@ -1097,0 +1104,9 @@\n+void os::win32::reset_performance_counters() {\n+  LARGE_INTEGER count;\n+  QueryPerformanceFrequency(&count);\n+  \/\/ Until we perform a real C\/R on Windows this is safe, performance frequency\n+  \/\/ should be the same. With real C\/R the counters will be probably incomparable.\n+  assert(performance_frequency == count.QuadPart, \"Performance frequency changed\");\n+  QueryPerformanceCounter(&count);\n+  restore_performance_count = count.QuadPart;\n+}\n@@ -1538,0 +1554,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -4690,0 +4733,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5693,0 +5761,9 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  const int status = _spawnv(_P_WAIT, path, argv); \/\/ env is inherited by a child process\n+  return 0 == status ? 0 : -1;\n+}\n+\n+int os::execv(const char *path, const char *argv[]) {\n+  return _execv(path, argv);\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":78,"deletions":1,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -742,0 +742,4 @@\n+  template(jdk_internal_crac_mirror_Core,          \"jdk\/internal\/crac\/mirror\/Core\")                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+  template(checkpointRestoreInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1180,0 +1180,15 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3725,0 +3726,5 @@\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = crac::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -306,2 +306,1 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n-  uint64_t features = _features;\n+void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features) {\n@@ -312,4 +311,10 @@\n-      int res = jio_snprintf(buf, buflen, \", %s\", features_names[features_names_index]);\n-      assert(res > 0, \"not enough temporary space allocated\");\n-      buf += res;\n-      buflen -= res;\n+      \/\/ Do not use any libc string functions. Our caller VM_Version::fatal_missing_features may have GNU_IFUNC-misconfigured glibc.\n+      if (buflen-- > 0)\n+        *buf++ = ',';\n+      if (buflen-- > 0)\n+        *buf++ = ' ';\n+      for (const char *src = features_names[features_names_index]; *src; ++src)\n+      if (buflen-- > 0)\n+        *buf++ = *src;\n+      assert(buflen > 0, \"not enough temporary space allocated\");\n+      *buf = 0;\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2024, Azul Systems, Inc. All rights reserved.\n@@ -54,0 +55,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -566,0 +568,9 @@\n+  { \"CREngine\",                     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowedOpenFilePrefixes\",    JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRAllowToSkipCheckpoint\",      JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRHeapDumpOnCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPrintResourcesOnCheckpoint\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRTraceStartupTime\",           JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRDoThrowCheckpointException\", JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+  { \"CRPauseOnCheckpointError\",     JDK_Version::jdk(24), JDK_Version::undefined(), JDK_Version::undefined() },\n+\n@@ -577,0 +588,8 @@\n+  { \"CREngine\",                        \"CRaCEngine\" },\n+  { \"CRAllowedOpenFilePrefixes\",       \"CRaCAllowedOpenFilePrefixes\" },\n+  { \"CRAllowToSkipCheckpoint\",         \"CRaCAllowToSkipCheckpoint \"},\n+  { \"CRHeapDumpOnCheckpointException\", \"CRaCHeapDumpOnCheckpointException\" },\n+  { \"CRPrintResourcesOnCheckpoint\",    \"CRaCPrintResourcesOnCheckpoint\" },\n+  { \"CRTraceStartupTime\",              \"CRaCTraceStartupTime\" },\n+  { \"CRDoThrowCheckpointException\",    \"CRaCDoThrowCheckpointException\" },\n+  { \"CRPauseOnCheckpointError\",        \"CRaCPauseOnCheckpointError\" },\n@@ -1104,0 +1123,13 @@\n+static void parse_argname(const char *arg, const char **argname, size_t *arg_len, bool *has_plus_minus) {\n+  \/\/ Determine if the flag has '+', '-', or '=' characters.\n+  *has_plus_minus = (*arg == '+' || *arg == '-');\n+  *argname = *has_plus_minus ? arg + 1 : arg;\n+\n+  const char* equal_sign = strchr(*argname, '=');\n+  if (equal_sign == NULL) {\n+    *arg_len = strlen(*argname);\n+  } else {\n+    *arg_len = equal_sign - *argname;\n+  }\n+}\n+\n@@ -1113,4 +1145,1 @@\n-  \/\/ Determine if the flag has '+', '-', or '=' characters.\n-  bool has_plus_minus = (*arg == '+' || *arg == '-');\n-  const char* const argname = has_plus_minus ? arg + 1 : arg;\n-\n+  const char* argname;\n@@ -1118,6 +1147,2 @@\n-  const char* equal_sign = strchr(argname, '=');\n-  if (equal_sign == nullptr) {\n-    arg_len = strlen(argname);\n-  } else {\n-    arg_len = equal_sign - argname;\n-  }\n+  bool has_plus_minus;\n+  parse_argname(arg, &argname, &arg_len, &has_plus_minus);\n@@ -1254,1 +1279,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1256,2 +1283,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1261,1 +1286,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1269,1 +1295,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1271,1 +1297,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1273,0 +1299,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2153,0 +2186,65 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (match_option(option, \"-Djava.class.path\", &tail) ||\n+        match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      \/\/ These options are already set based on -cp (and aliases), -jar\n+      \/\/ or even inheriting the CLASSPATH env var; therefore it's too\n+      \/\/ late to prohibit explicitly setting them at this point.\n+    } else if (match_option(option, \"-D\", &tail)) {\n+      const char* key = NULL;\n+      const char* value = NULL;\n+\n+      get_key_value(tail, &key, &value);\n+\n+      if (strcmp(key, \"sun.java.command\") == 0) {\n+        char *old_java_command = _java_command;\n+        _java_command = os::strdup_check_oom(value, mtArguments);\n+        if (old_java_command != NULL) {\n+          os::free(old_java_command);\n+        }\n+      } else {\n+        add_property(tail);\n+      }\n+    } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+      \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n+      \/\/ already been handled\n+      if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+        return false;\n+      }\n+      const char *argname;\n+      size_t arg_len;\n+      bool ignored_plus_minus;\n+      parse_argname(tail, &argname, &arg_len, &ignored_plus_minus);\n+      const JVMFlag* flag = JVMFlag::find_declared_flag((const char*)argname, arg_len);\n+      if (flag != NULL) {\n+        if (!flag->is_restore_settable()) {\n+          jio_fprintf(defaultStream::error_stream(),\n+            \"Flag %.*s cannot be set during restore: %s\\n\", arg_len, argname, option->optionString);\n+          return false;\n+        }\n+        build_jvm_flags(tail);\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2915,0 +3013,7 @@\n+  if (CRaCCheckpointTo && UseZGC) {\n+    \/\/ jdk.crac.impl.CheckpointOpenFileException: FD fd=3 type=regular path=\/memfd:java_heap (deleted)\n+    jio_fprintf(defaultStream::output_stream(),\n+      \"-XX:+UseZGC is currently unsupported for -XX:CRaCCheckpointTo.\\n\");\n+    return JNI_ERR;\n+  }\n+\n@@ -2969,0 +3074,4 @@\n+  if (CRaCCheckpointTo && !crac::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n@@ -3980,0 +4089,7 @@\n+\n+void Arguments::reset_for_crac_restore() {\n+  if (!FLAG_IS_DEFAULT(LogVMOutput)){\n+    FLAG_SET_DEFAULT(LogVMOutput, false);\n+    FLAG_SET_DEFAULT(LogFile, nullptr);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":132,"deletions":16,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -283,0 +283,4 @@\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n+\n@@ -454,0 +458,2 @@\n+  \/\/ Reset LogVMoutput to default values\n+  static void reset_for_crac_restore();\n@@ -516,0 +522,4 @@\n+  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1234,0 +1234,1 @@\n+  void wakeup_sleep() { _SleepEvent->unpark(); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2218,0 +2218,9 @@\n+void os::cleanup_memory(char* addr, size_t bytes) {\n+  char* start = (char*)align_up(addr, os::vm_page_size());\n+  char* end = (char*)align_down(addr + bytes, os::vm_page_size());\n+  if (start < end) {\n+    os::uncommit_memory(start, end - start);\n+    os::commit_memory(start, end - start, false);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -293,0 +293,2 @@\n+  \/\/ Before restore returns the same value as elapsed_counter()\n+  static jlong elapsed_counter_since_restore();\n@@ -479,0 +481,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n@@ -638,0 +642,4 @@\n+  static int exec_child_process_and_wait(const char *path, const char *argv[]);\n+\n+  static int execv(const char *path, const char *argv[]);\n+\n@@ -697,0 +705,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -700,0 +711,2 @@\n+  static bool           is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -428,0 +429,15 @@\n+static jint check_for_restore(JavaVMInitArgs* args, crac::crac_restore_data& restore_data) {\n+  if (Arguments::is_restore_option_set(args)) {\n+    if (!Arguments::parse_options_for_restore(args)) {\n+      return JNI_ERR;\n+    }\n+    crac::restore(restore_data);\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -431,0 +447,8 @@\n+#ifdef __APPLE__\n+  \/\/ BSD clock would be initialized in os::init() but we need to do that earlier\n+  \/\/ as crac::prepare_restore() calls os::javaTimeNanos().\n+  os::Bsd::clock_init();\n+#endif\n+  crac::crac_restore_data restore_data;\n+  crac::prepare_restore(restore_data);\n+\n@@ -461,0 +485,4 @@\n+  \/\/ Output stream module should be already initialized for error reporting during restore.\n+  \/\/ JDK version should also be intialized for arguments parsing.\n+  if (check_for_restore(args, restore_data) != JNI_OK) return JNI_ERR;\n+\n@@ -495,0 +523,2 @@\n+  crac::vm_create_start();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2483,0 +2483,1 @@\n+  declare_constant(JVMFlagOrigin::CRAC_RESTORE)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+#if INCLUDE_SERVICES && !defined(_WINDOWS)\n+#include \"attachListener_posix.hpp\"\n+#include \"posixAttachOperation.hpp\"\n+#endif \/\/ INCLUDE_SERVICES && !defined(_WINDOWS)\n@@ -155,0 +159,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -1052,0 +1058,26 @@\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_crac_mirror_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::checkpointRestoreInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != NULL) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      outputStream* stream = output();\n+#if INCLUDE_SERVICES && !defined(_WINDOWS)\n+      assert(PosixAttachListener::get_current_op(), \"should exist\");\n+      if (PosixAttachListener::get_current_op()->is_effectively_completed()) {\n+        stream = tty;\n+      }\n+#endif \/\/ INCLUDE_SERVICES\n+      stream->print_cr(\"An exception during a checkpoint operation:\");\n+      stream->print(\"%s\", out);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -853,0 +853,14 @@\n+class CheckpointDCmd : public DCmd {\n+public:\n+  CheckpointDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"JDK.checkpoint\"; }\n+    static const char* description() {\n+      return \"Checkpoint via jdk.crac.checkpointRestore().\";\n+    }\n+    static const char* impact() {\n+      return \"High: JVM terminates\";\n+    }\n+    static int num_arguments() { return 0; }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -917,1 +918,1 @@\n-    return Management::ticks_to_ms(os::elapsed_counter());\n+    return Management::ticks_to_ms(os::elapsed_counter_since_restore());\n@@ -981,0 +982,12 @@\n+  case JMM_JVM_RESTORE_START_TIME_MS:\n+    return crac::restore_start_time();\n+\n+  case JMM_JVM_UPTIME_SINCE_RESTORE_MS:\n+    {\n+      jlong ticks = crac::uptime_since_restore();\n+      if (ticks == -1) {\n+        return -1;\n+      }\n+      return Management::ticks_to_ms(ticks);\n+    }\n+\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -254,0 +254,4 @@\n+#ifndef INCLUDE_CPU_FEATURE_ACTIVE\n+#define INCLUDE_CPU_FEATURE_ACTIVE 1\n+#endif \/\/ INCLUDE_CPU_FEATURE_ACTIVE\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -362,0 +362,5 @@\n+     * @crac When the process is restored on another machine or if the machine\n+     * rebooted the value is updated based on wall-clock time difference,\n+     * resulting in a loss of accuracy when comparing timestamps obtained\n+     * before and after checkpoint.\n+     *\n@@ -617,0 +622,6 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload system properties in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -651,0 +662,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -710,0 +722,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -731,0 +746,3 @@\n+     * @crac System properties can be updated on restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -831,0 +849,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -838,0 +862,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -867,0 +892,6 @@\n+     * @crac Environment variables can be updated on restore from a checkpoint.\n+     * The application can {@link jdk.crac\/jdk.crac.Context#register(jdk.crac.Resource) register}\n+     * a resource and reload the environment variables in the\n+     * {@link jdk.crac\/jdk.crac.Resource#afterRestore(jdk.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -872,0 +903,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n@@ -59,0 +61,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -232,0 +236,6 @@\n+ * @crac This class holds a cache of resolved hostname-address pairs;\n+ * this cache is wiped out before checkpoint. Therefore, lookups after restore\n+ * will cause name address resolution.\n+ * This ensures that the addresses are up-to-date in the environment where\n+ * the process is restored.\n+ *\n@@ -350,0 +360,3 @@\n+    \/* Resource registration uses weak references; we need to keep it locally. *\/\n+    private static final JDKResource checkpointListener;\n+\n@@ -386,0 +399,14 @@\n+        \/\/ DNS cache is cleared before the checkpoint; application restored at a later point\n+        \/\/ or in a different environment should query DNS again.\n+        checkpointListener = new JDKResource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                cache.clear();\n+                expirySet.clear();\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            }\n+        };\n+        Core.Priority.NORMAL.getContext().register(checkpointListener);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.SharedSecrets;\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -217,0 +217,4 @@\n+     *\n+     * @crac Instances created by this constructor are automatically reseeded\n+     * after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n@@ -259,0 +263,4 @@\n+     * @crac Instances created by this constructor are <strong>not<\/strong>\n+     * reseeded after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n+     *\n@@ -360,0 +368,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -407,0 +417,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -451,0 +463,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -498,0 +512,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -555,0 +571,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -607,0 +625,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import jdk.internal.util.jar.PersistentJarFile;\n@@ -681,1 +682,1 @@\n-                return checkJar(new JarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n+                return checkJar(new PersistentJarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n@@ -37,0 +36,6 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -43,1 +48,1 @@\n-public final class CleanerImpl implements Runnable {\n+public final class CleanerImpl implements Runnable, JDKResource {\n@@ -49,0 +54,1 @@\n+    private static JavaLangRefAccess javaLangRefAccess = SharedSecrets.getJavaLangRefAccess();\n@@ -58,0 +64,2 @@\n+    volatile boolean forceCleanup = false;\n+\n@@ -113,0 +121,1 @@\n+        Core.Priority.CLEANERS.getContext().register(this);\n@@ -137,0 +146,21 @@\n+            if (forceCleanup) {\n+                ArrayList<PhantomCleanable<?>> refArr = new ArrayList<>();\n+                synchronized (phantomCleanableList) {\n+                    for (var ref = phantomCleanableList.next; ref != phantomCleanableList; ref = ref.next) {\n+                        if (ref.refersTo(null)) {\n+                            refArr.add(ref);\n+                        }\n+                    }\n+                    for (var ref : refArr) {\n+                        try {\n+                            ref.clean();\n+                        } catch (Throwable e) {\n+                            \/\/ ignore exceptions from the cleanup action\n+                        }\n+                    }\n+                }\n+                synchronized (this) {\n+                    forceCleanup = false;\n+                    notify();\n+                }\n+            }\n@@ -140,1 +170,1 @@\n-                Cleanable ref = (Cleanable) queue.remove(60 * 1000L);\n+                Cleanable ref = (Cleanable) javaLangRefAccess.pollReferenceQueue(queue, 60 * 1000L);\n@@ -149,0 +179,23 @@\n+        synchronized (this) {\n+            \/\/ wakeup the checkpoint thread when we this thread terminates before noticing\n+            \/\/ the forced cleanup\n+            forceCleanup = false;\n+            notify();\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (phantomCleanableList.isListEmpty()) {\n+            \/\/ The thread is already terminated; don't wait for anything\n+            return;\n+        }\n+        forceCleanup = true;\n+        javaLangRefAccess.wakeupReferenceQueue(queue);\n+        while (forceCleanup) {\n+            wait();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n@@ -192,0 +245,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"PhantomCleanableRef:\"  + action;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":62,"deletions":4,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-\n@@ -179,0 +178,4 @@\n+    exports jdk.internal.crac to\n+        java.rmi,\n+        jdk.management.agent,\n+        jdk.sctp;\n@@ -417,0 +420,7 @@\n+    exports jdk.internal.crac.mirror to\n+        java.rmi,\n+        jdk.crac,\n+        jdk.management.agent;\n+\n+    exports jdk.internal.crac.mirror.impl to\n+        jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -128,0 +129,5 @@\n+    static {\n+        \/\/ trigger eager initialization\n+        new FileDispatcherImpl();\n+    }\n+\n@@ -1203,1 +1209,1 @@\n-    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+    private static Runnable closerFor0(FileDescriptor fd, boolean stream) {\n@@ -1223,0 +1229,14 @@\n+    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+\n+        \/\/ FIXME ensure FileDispatcherImpl's Resource is registered before the closer is used,\n+        \/\/ otherwise the closer during beforeCheckpoint may be the first one to access\n+        \/\/ FileDescriptor, and then Dispatcher Resource will be blocked for registration.\n+        try {\n+            MethodHandles.lookup().ensureInitialized(FileDispatcherImpl.class);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        return closerFor0(fd, stream);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -139,2 +144,2 @@\n-    private static final class UnclosableInputStream extends FilterInputStream {\n-        UnclosableInputStream(InputStream in) {\n+    private static final class UnclosableInputStream extends FilterInputStream implements JDKResource {\n+        UnclosableInputStream(FileInputStream in) {\n@@ -142,0 +147,1 @@\n+            Core.Priority.NORMAL.getContext().register(this);\n@@ -152,0 +158,11 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            FileDescriptor fd = ((FileInputStream)in).getFD();\n+            Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/FileInputStreamPool.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1076,0 +1076,15 @@\n+`-XX:CRaCCheckpointTo=`*directory*\n+:   The CRaC (Coordinated Restore at Checkpoint) Project provides checkpointing of\n+    a running Java program into an image directory. Restoring from the image should\n+    solve some of the problematic start-up and warm-up times.\n+\n+    This option defines a path to the snapshot which is currently a directory. The\n+    directory will be created if it does not exist, but no parent directories are\n+    created.\n+\n+`-XX:CRaCRestoreFrom=`*directory*\n+:   Restores a snapshot created by `-XX:CRaCCheckpointTo=`*directory*.\n+\n+`-XX:CRaCMinPid=`*value*\n+:   A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+\n@@ -1819,0 +1834,7 @@\n+`-XX:CPUFeatures=`*0xnumber*\n+:   CPU feature set, use `-XX:CPUFeatures=`*0xnumber* with `-XX:CRaCCheckpointTo` when\n+    you get an error during `-XX:CRaCRestoreFrom` on a different machine.\n+    `-XX:CPUFeatures=native` is the default.\n+    `-XX:CPUFeatures=generic` is compatible with any CPU but not as slow\n+    as `-XX:CPUFeatures=0`.\n+\n@@ -1986,0 +2008,4 @@\n+`-XX:+ShowCPUFeatures`\n+:   Show features of this CPU to be possibly used for the\n+    `-XX:CPUFeatures=`*0xnumber* option.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n@@ -33,0 +34,4 @@\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -73,0 +78,5 @@\n+ * @crac Before checkpoint the underlying random number generator is discarded\n+ * and after restore a new {@link sun.security.provider.SecureRandom} is\n+ * created, therefore this produces different sequences when restored multiple\n+ * times.\n+ *\n@@ -332,1 +342,1 @@\n-    private static class RandomIO {\n+    private static class RandomIO implements JDKResource {\n@@ -386,0 +396,4 @@\n+        \/\/ lock for checkpoint\/restore\n+        \/\/ allows clearing mixRandom and internal buffer before checkpoint\n+        private final ReentrantReadWriteLock crLock = new ReentrantReadWriteLock();\n+\n@@ -392,0 +406,1 @@\n+            Core.Priority.NATIVE_PRNG.getContext().register(this);\n@@ -471,1 +486,9 @@\n-                getMixRandom().engineSetSeed(seed);\n+                crLock.readLock().lock();\n+                try {\n+                    if(crLock.getWriteHoldCount() != 0) {\n+                        throw new IllegalStateException(\"PRNG object is invalidated\");\n+                    }\n+                    getMixRandom().engineSetSeed(seed);\n+                } finally {\n+                    crLock.readLock().unlock();\n+                }\n@@ -529,0 +552,1 @@\n+            crLock.readLock().lock();\n@@ -530,0 +554,3 @@\n+                    if(crLock.getWriteHoldCount() != 0) {\n+                        throw new IllegalStateException(\"PRNG object is invalidated\");\n+                    }\n@@ -562,0 +589,2 @@\n+                } finally {\n+                    crLock.readLock().unlock();\n@@ -564,0 +593,15 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            synchronized (LOCK_SET_SEED) {\n+                if (seedOut != null) {\n+                    FileDescriptor fd = ((FileOutputStream)seedOut).getFD();\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n+                }\n+            }\n+\n+            crLock.writeLock().lock();\n+            mixRandom = null;\n+            buffered = 0;\n+            lastRead = 0;\n+            Arrays.fill(nextBuffer, (byte)0);\n@@ -565,0 +609,6 @@\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            crLock.writeLock().unlock();\n+        }\n+    }\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":52,"deletions":2,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -678,0 +678,9 @@\n+    {\n+      const int restore_signal = SIGRTMIN + 2;\n+      \/\/ block restore_signal in launcher thread to allow JVM handle it\n+      sigset_t block_sig;\n+      sigemptyset(&block_sig);\n+      sigaddset(&block_sig, restore_signal);\n+      pthread_sigmask(SIG_BLOCK, &block_sig, NULL);\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -275,0 +275,12 @@\n+\n+    \/\/ CRaC support\n+    private native long getRestoreTime0();\n+    private native long getUptimeSinceRestore0();\n+\n+    public long getRestoreTime() {\n+        return getRestoreTime0();\n+    }\n+\n+    public long getUptimeSinceRestore() {\n+        return getUptimeSinceRestore0();\n+    }\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagementImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,0 +62,5 @@\n+\n+import jdk.internal.crac.mirror.Context;\n+import jdk.internal.crac.mirror.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -260,1 +265,1 @@\n-        if (exportCount == 0 && getEndpoint().getListenPort() != 0) {\n+        if (exportCount == 0) {\n@@ -598,1 +603,1 @@\n-    private class ConnectionHandler implements Runnable {\n+    private class ConnectionHandler implements Runnable, JDKResource {\n@@ -610,0 +615,1 @@\n+            Core.Priority.NORMAL.getContext().register(this);\n@@ -767,0 +773,10 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            closeSocket(socket);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            \/\/ noop, the connection is not reopened\n+        }\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/tcp\/TCPTransport.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -114,0 +114,2 @@\n+# JDK-8310862 was closed but we're still seeing errors with the updated test\n+runtime\/ClassInitErrors\/TestStackOverflowDuringInit.java 8310862 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}